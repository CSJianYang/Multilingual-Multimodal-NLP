[
    {
        "title": "Palindrome Number",
        "question_content": "Given an integer x, return true if x is a palindrome, and false otherwise.\n&nbsp;\nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n&nbsp;\nConstraints:\n\n\t-231&nbsp;<= x <= 231&nbsp;- 1\n\n&nbsp;\nFollow up: Could you solve it without converting the integer to a string?",
        "solutions": [
            {
                "id": 5127,
                "title": "9-line-accepted-java-code-without-the-need-of-handling-overflow",
                "content": "compare half of the digits in x, so don't need to deal with overflow.\\n\\n    public boolean isPalindrome(int x) {\\n        if (x<0 || (x!=0 && x%10==0)) return false;\\n        int rev = 0;\\n        while (x>rev){\\n        \\trev = rev*10 + x%10;\\n        \\tx = x/10;\\n        }\\n        return (x==rev || x==rev/10);\\n    }",
                "solutionTags": [],
                "code": "compare half of the digits in x, so don't need to deal with overflow.\\n\\n    public boolean isPalindrome(int x) {\\n        if (x<0 || (x!=0 && x%10==0)) return false;\\n        int rev = 0;\\n        while (x>rev){\\n        \\trev = rev*10 + x%10;\\n        \\tx = x/10;\\n        }\\n        return (x==rev || x==rev/10);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 785314,
                "title": "python-3-1-solution-is-89-20-faster-2nd-is-99-14-faster-explanation-added",
                "content": "**Suggestions to make them better are always welcomed.**\\n\\n**Solution 1: 89.20% faster**\\nThis is the easiest way to check if integer is palindrome. \\n\\nConvert the number to string and compare it with the reversed string.\\n\\nI wrote this working solution first and then found in the description that we need to solve this problem without converting the input to string. Then I wrote solution 2.\\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n\\t\\treturn False\\n\\t\\n\\treturn str(x) == str(x)[::-1]\\n```\\n\\nIf we don\\'t want to convert the number to string, then recreate a new number in reverse order.\\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x<0:\\n\\t\\treturn False\\n\\n\\tinputNum = x\\n\\tnewNum = 0\\n\\twhile x>0:\\n\\t\\tnewNum = newNum * 10 + x%10\\n\\t\\tx = x//10\\n\\treturn newNum == inputNum\\n```\\n\\n**Solution 2: 99.14% faster.**\\nI\\'d recommend you to solve leetcode question 7 (reverse integer) to understand the logic behind this solution.\\n\\nPython3 int type has no lower or upper bounds. But if there are constraints given then we have to make sure that while reversing the integer we don\\'t cross those constraints.\\n\\nSo, instead of reversing the whole integer, let\\'s convert half of the integer and then check if it\\'s palindrome.\\nBut we don\\'t know when is that half going to come. \\n\\nExample, if x = 15951, then let\\'s create reverse of x in loop. Initially, x = 15951, revX = 0\\n1. x = 1595, revX = 1\\n2. x = 159, revX = 15\\n3. x = 15, revX = 159\\n\\nWe see that revX > x after  3 loops and we crossed the half way in the integer bcoz it\\'s an odd length integer.\\nIf it\\'s an even length integer, our loop stops exactly in the middle.\\n\\nNow we can compare x and revX, if even length, or x and revX//10 if odd length and return True if they match.\\n\\nThere\\'s a difference between / and // division in Python3. Read it here on [stackoverflow](https://stackoverflow.com/questions/183853/what-is-the-difference-between-and-when-used-for-division).\\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0 or (x > 0 and x%10 == 0):   # if x is negative, return False. if x is positive and last digit is 0, that also cannot form a palindrome, return False.\\n\\t\\treturn False\\n\\t\\n\\tresult = 0\\n\\twhile x > result:\\n\\t\\tresult = result * 10 + x % 10\\n\\t\\tx = x // 10\\n\\t\\t\\n\\treturn True if (x == result or x == result // 10) else False\\n```\\n\\n **If you like the solutions, please upvote it for better reach to other people.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n\\t\\treturn False\\n\\t\\n\\treturn str(x) == str(x)[::-1]\\n```\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x<0:\\n\\t\\treturn False\\n\\n\\tinputNum = x\\n\\tnewNum = 0\\n\\twhile x>0:\\n\\t\\tnewNum = newNum * 10 + x%10\\n\\t\\tx = x//10\\n\\treturn newNum == inputNum\\n```\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0 or (x > 0 and x%10 == 0):   # if x is negative, return False. if x is positive and last digit is 0, that also cannot form a palindrome, return False.\\n\\t\\treturn False\\n\\t\\n\\tresult = 0\\n\\twhile x > result:\\n\\t\\tresult = result * 10 + x % 10\\n\\t\\tx = x // 10\\n\\t\\t\\n\\treturn True if (x == result or x == result // 10) else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3213890,
                "title": "fastest-java-solution",
                "content": "## For better Visualization:\\n\\n[https://www.youtube.com/watch?v=9xUcC6iIq7I]()\\n\\n## Idea\\nWe\\'re going to convert our **int** to **String** and then compare the first element to the very last element, second element to second last element and so on *[elements at the same distance from the beginning and from the end]*.. If they don\\'t match we return a False\\n\\n## JAVA Code\\n``` JAVA []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String s = String.valueOf(x); // Convert to String\\n        int n = s.length(); // Store the String length to int n\\n\\n        for (int i=0; i<n/2; i++) {\\n            // We check whether the elements at the same distance from\\n            // beginning and from ending are same, if not we return false\\n            if (s.charAt(i) != s.charAt(n-i-1)) return false;\\n        }\\n\\n        // if no flaws are found we return true\\n        return true;\\n    }\\n}\\n```\\n\\nThere is another approach to this problem:\\n\\nWe can store one half of the integer in a another variable in reversed order. Then we compare it to the other unaltered half of the number and see if they are equal or not [which should be in case of palindromes]\\n\\n``` JAVA []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x<0 || (x!=0 && x%10==0)) return false;\\n        int rev = 0;\\n        while (x>rev){\\n            rev = rev*10 + x%10;\\n            x = x/10;\\n        }\\n        return (x==rev || x==rev/10);\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/d141c86e-a7ed-4750-baa3-2ae88d11bf05_1676971396.8824553.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String s = String.valueOf(x); // Convert to String\\n        int n = s.length(); // Store the String length to int n\\n\\n        for (int i=0; i<n/2; i++) {\\n            // We check whether the elements at the same distance from\\n            // beginning and from ending are same, if not we return false\\n            if (s.charAt(i) != s.charAt(n-i-1)) return false;\\n        }\\n\\n        // if no flaws are found we return true\\n        return true;\\n    }\\n}\\n```\n``` JAVA []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x<0 || (x!=0 && x%10==0)) return false;\\n        int rev = 0;\\n        while (x>rev){\\n            rev = rev*10 + x%10;\\n            x = x/10;\\n        }\\n        return (x==rev || x==rev/10);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5165,
                "title": "an-easy-c-8-lines-code-only-reversing-till-half-and-then-compare",
                "content": "    class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(x<0|| (x!=0 &&x%10==0)) return false;\\n            int sum=0;\\n            while(x>sum)\\n            {\\n                sum = sum*10+x%10;\\n                x = x/10;\\n            }\\n            return (x==sum)||(x==sum/10);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(x<0|| (x!=0 &&x%10==0)) return false;\\n            int sum=0;\\n            while(x>sum)\\n            {\\n                sum = sum*10+x%10;\\n                x = x/10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3651712,
                "title": "2-method-s-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nThe intuition behind this code is to reverse the entire input number and check if the reversed number is equal to the original number. If they are the same, then the number is a palindrome.\\n\\n# Approach 1: Reversing the Entire Number\\n# Explanation:\\n1. We begin by performing an initial check. If the input number `x` is negative, it cannot be a palindrome since palindromes are typically defined for positive numbers. In such cases, we immediately return `false`.\\n\\n2. We initialize two variables:\\n   - `reversed`: This variable will store the reversed value of the number `x`.\\n   - `temp`: This variable is a temporary placeholder to manipulate the input number without modifying the original value.\\n\\n3. We enter a loop that continues until `temp` becomes zero:\\n   - Inside the loop, we extract the last digit of `temp` using the modulo operator `%` and store it in the `digit` variable.\\n   - To reverse the number, we multiply the current value of `reversed` by 10 and add the extracted `digit`.\\n   - We then divide `temp` by 10 to remove the last digit and move on to the next iteration.\\n\\n4. Once the loop is completed, we have reversed the entire number. Now, we compare the reversed value `reversed` with the original input value `x`.\\n   - If they are equal, it means the number is a palindrome, so we return `true`.\\n   - If they are not equal, it means the number is not a palindrome, so we return `false`.\\n\\nThe code uses a `long long` data type for the `reversed` variable to handle potential overflow in case of large input numbers.\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n\\n        long long reversed = 0;\\n        long long temp = x;\\n\\n        while (temp != 0) {\\n            int digit = temp % 10;\\n            reversed = reversed * 10 + digit;\\n            temp /= 10;\\n        }\\n\\n        return (reversed == x);\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n\\n        long reversed = 0;\\n        long temp = x;\\n\\n        while (temp != 0) {\\n            int digit = (int) (temp % 10);\\n            reversed = reversed * 10 + digit;\\n            temp /= 10;\\n        }\\n\\n        return (reversed == x);\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0:\\n            return False\\n\\n        reversed_num = 0\\n        temp = x\\n\\n        while temp != 0:\\n            digit = temp % 10\\n            reversed_num = reversed_num * 10 + digit\\n            temp //= 10\\n\\n        return reversed_num == x\\n\\n```\\n\\n# Approach 2: Reversing Half of the Number\\nInstead of reversing the entire number, we can reverse only the last half of the number. This approach is tricky because when we reverse the last half of the number, we don\\'t want the middle digit to be reversed back to its original value. This can happen if the number has an odd number of digits. To resolve this, we can compare the first half of the number with the reversed second half of the number.\\n# Explanation:\\n1. We begin with an initial check to handle special cases:\\n   - If the input number `x` is negative, it cannot be a palindrome since palindromes are typically defined for positive numbers. In such cases, we immediately return `false`.\\n   - If `x` is non-zero and ends with a zero, it cannot be a palindrome because leading zeros are not allowed in palindromes. We return `false` for such cases.\\n\\n2. We initialize two variables:\\n   - `reversed`: This variable will store the reversed second half of the digits of the number.\\n   - `temp`: This variable is a temporary placeholder to manipulate the input number without modifying the original value.\\n\\n3. We enter a loop that continues until the first half of the digits (`x`) becomes less than or equal to the reversed second half (`reversed`):\\n   - Inside the loop, we extract the last digit of `x` using the modulo operator `%` and add it to the `reversed` variable after multiplying it by 10 (shifting the existing digits to the left).\\n   - We then divide `x` by 10 to remove the last digit and move towards the center of the number.\\n\\n4. Once the loop is completed, we have reversed the second half of the digits. Now, we compare the first half of the digits (`x`) with the reversed second half (`reversed`) to determine if the number is a palindrome:\\n   - For an even number of digits, if `x` is equal to `reversed`, then the number is a palindrome. We return `true`.\\n   - For an odd number of digits, if `x` is equal to `reversed / 10` (ignoring the middle digit), then the number is a palindrome. We return `true`.\\n   - If none of the above conditions are met, it means the number is not a palindrome, so we return `false`.\\n\\nThe code avoids the need for reversing the entire number by comparing only the necessary parts. This approach reduces both time complexity and memory usage, resulting in a more efficient solution.\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n\\n        int reversed = 0;\\n        while (x > reversed) {\\n            reversed = reversed * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return (x == reversed) || (x == reversed / 10);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n\\n        int reversed = 0;\\n        int original = x;\\n\\n        while (x > reversed) {\\n            reversed = reversed * 10 + x % 10;\\n            x /= 10;\\n        }\\n\\n        return (x == reversed) || (x == reversed / 10);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n\\n        reversed_num = 0\\n        original = x\\n\\n        while x > reversed_num:\\n            reversed_num = reversed_num * 10 + x % 10\\n            x //= 10\\n\\n        return x == reversed_num or x == reversed_num // 10\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/bc4560f0-64e2-4083-8f14-c5e8220c2e7f_1687078450.4746537.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n\\n        long long reversed = 0;\\n        long long temp = x;\\n\\n        while (temp != 0) {\\n            int digit = temp % 10;\\n            reversed = reversed * 10 + digit;\\n            temp /= 10;\\n        }\\n\\n        return (reversed == x);\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n\\n        long reversed = 0;\\n        long temp = x;\\n\\n        while (temp != 0) {\\n            int digit = (int) (temp % 10);\\n            reversed = reversed * 10 + digit;\\n            temp /= 10;\\n        }\\n\\n        return (reversed == x);\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0:\\n            return False\\n\\n        reversed_num = 0\\n        temp = x\\n\\n        while temp != 0:\\n            digit = temp % 10\\n            reversed_num = reversed_num * 10 + digit\\n            temp //= 10\\n\\n        return reversed_num == x\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n\\n        int reversed = 0;\\n        while (x > reversed) {\\n            reversed = reversed * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return (x == reversed) || (x == reversed / 10);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n\\n        int reversed = 0;\\n        int original = x;\\n\\n        while (x > reversed) {\\n            reversed = reversed * 10 + x % 10;\\n            x /= 10;\\n        }\\n\\n        return (x == reversed) || (x == reversed / 10);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n\\n        reversed_num = 0\\n        original = x\\n\\n        while x > reversed_num:\\n            reversed_num = reversed_num * 10 + x % 10\\n            x //= 10\\n\\n        return x == reversed_num or x == reversed_num // 10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283534,
                "title": "accepted-java-c-code-beats-98",
                "content": "**Note:**\\n\\n**`Check only half of the digits of given number to prevent OVERFLOW`**\\n\\n# Complexity\\n- Time complexity: $$O(n/2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# JAVA :-\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | **9** *ms* | *Beats* **98%**\\n**Memory** | **40** *MB* | *Beats* **67%**\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0 || x!=0 && x%10 ==0 ) return false;\\n        int check=0;\\n        while(x>check){\\n            check = check*10 + x%10;\\n            x/=10;\\n        }\\n        return (x==check || x==check/10);\\n    }\\n}\\n````\\n# C :-\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | **15** *ms* | *Beats* **80%**\\n**Memory** | **6** *MB* | *Beats* **93%**\\n```\\nbool isPalindrome(int x){\\n    if(x<0 || x!=0 && x%10 ==0 ) return false;\\n    int check=0;\\n    while(x>check){\\n        check = check*10 + x%10;\\n        x/=10;\\n    }\\n    return (x==check || x==check/10);\\n}\\n```\\n```\\n **   Use similar Math in PYTHON / C++   **\\n```\\n## UPVOTE : |\\n![waiting-tom-and-jerry.gif](https://assets.leetcode.com/users/images/4f0cc754-71e1-4cfc-816b-36a94c20b17f_1678366238.9546802.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0 || x!=0 && x%10 ==0 ) return false;\\n        int check=0;\\n        while(x>check){\\n            check = check*10 + x%10;\\n            x/=10;\\n        }\\n        return (x==check || x==check/10);\\n    }\\n}\\n```\n```\\nbool isPalindrome(int x){\\n    if(x<0 || x!=0 && x%10 ==0 ) return false;\\n    int check=0;\\n    while(x>check){\\n        check = check*10 + x%10;\\n        x/=10;\\n    }\\n    return (x==check || x==check/10);\\n}\\n```\n```\\n **   Use similar Math in PYTHON / C++   **\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499161,
                "title": "99-22-javascript-dart-without-converting-the-integer-to-a-string",
                "content": "#### How to reverse the number\\n```\\noriginal number: 543\\nreverse number: 0\\n\\n//Get the last digit of the original number\\noriginal % 10 = 543 % 10 = 3\\n//Put this digit as the last one in the reverse number\\nreverse * 10 + digit = 0 * 10 + 3 = 0 + 3 = 3\\nreverse: 3\\n//Remove this digit from the original number\\noriginal / 10 = 543 / 10 = 54.3\\n~~54.3 = 54\\noriginal: 54\\n\\n//Repeat\\noriginal % 10 = 54 % 10 = 4\\nreverse * 10 + digit = 3 * 10 + 4 = 30 + 4 = 34\\nreverse: 34\\noriginal / 10 = 54 / 10 = 5.4\\n~~5.4 = 5\\noriginal: 5\\n\\n//Repeat\\noriginal % 10 = 5 % 10 = 5\\nreverse * 10 + digit = 34 * 10 + 5 = 340 + 5 = 345\\nreverse: 345\\noriginal / 10 = 5 / 10 = 0.5\\n~~0.5 = 0\\noriginal: 0\\n\\ninput: 543\\noutput: 345\\n\\n```\\n\\nSo if the reverse number is equal to the original number, then it is a palindrome\\n\\n```\\n345 != 543 //not palindrome\\n272 == 272 //is palindrome\\n```\\n\\n**Please upvote if it was helpful!**\\n\\n``` JavaScript []\\nvar isPalindrome = function(x) {\\n    var reverse = 0;\\n    var copy = x;\\n\\n    //The loop break when the copy of original number becomes zero\\n    //Also negative number cannot be a palindrome\\n    while (copy > 0) {\\n      const digit = copy % 10;\\n      reverse = reverse * 10 + digit;\\n      copy = ~~(copy / 10);\\n    }\\n\\n    return reverse == x;\\n};\\n```\\n``` Dart []\\nclass Solution {\\n  bool isPalindrome(int x) {\\n    int reverse = 0;\\n    int copy = x;\\n\\n    //The loop break when the copy of original number becomes zero\\n    //Also negative number cannot be a palindrome\\n    while (copy > 0) {\\n      final digit = copy % 10;\\n      reverse = reverse * 10 + digit;\\n      copy = copy ~/ 10;\\n    }\\n\\n    return reverse == x;\\n  }\\n}\\n\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/786157401/)",
                "solutionTags": [
                    "JavaScript",
                    "Dart"
                ],
                "code": "```\\noriginal number: 543\\nreverse number: 0\\n\\n//Get the last digit of the original number\\noriginal % 10 = 543 % 10 = 3\\n//Put this digit as the last one in the reverse number\\nreverse * 10 + digit = 0 * 10 + 3 = 0 + 3 = 3\\nreverse: 3\\n//Remove this digit from the original number\\noriginal / 10 = 543 / 10 = 54.3\\n~~54.3 = 54\\noriginal: 54\\n\\n//Repeat\\noriginal % 10 = 54 % 10 = 4\\nreverse * 10 + digit = 3 * 10 + 4 = 30 + 4 = 34\\nreverse: 34\\noriginal / 10 = 54 / 10 = 5.4\\n~~5.4 = 5\\noriginal: 5\\n\\n//Repeat\\noriginal % 10 = 5 % 10 = 5\\nreverse * 10 + digit = 34 * 10 + 5 = 340 + 5 = 345\\nreverse: 345\\noriginal / 10 = 5 / 10 = 0.5\\n~~0.5 = 0\\noriginal: 0\\n\\ninput: 543\\noutput: 345\\n\\n```\n```\\n345 != 543 //not palindrome\\n272 == 272 //is palindrome\\n```\n``` JavaScript []\\nvar isPalindrome = function(x) {\\n    var reverse = 0;\\n    var copy = x;\\n\\n    //The loop break when the copy of original number becomes zero\\n    //Also negative number cannot be a palindrome\\n    while (copy > 0) {\\n      const digit = copy % 10;\\n      reverse = reverse * 10 + digit;\\n      copy = ~~(copy / 10);\\n    }\\n\\n    return reverse == x;\\n};\\n```\n``` Dart []\\nclass Solution {\\n  bool isPalindrome(int x) {\\n    int reverse = 0;\\n    int copy = x;\\n\\n    //The loop break when the copy of original number becomes zero\\n    //Also negative number cannot be a palindrome\\n    while (copy > 0) {\\n      final digit = copy % 10;\\n      reverse = reverse * 10 + digit;\\n      copy = copy ~/ 10;\\n    }\\n\\n    return reverse == x;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398168,
                "title": "c-three-simple-and-short-different-solutions",
                "content": "**Solution I:**\\nConvert the number to a string, revert it and compare.\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string rev = to_string(x);\\n        reverse(rev.begin(), rev.end());\\n        return to_string(x) == rev;\\n    }\\n};\\n```\\n**Solution II:**\\nConvert the number to a string, then use two pointers at beginning and end to check if it\\'s a palindrome.\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        int i = 0, j = s.size()-1;\\n        while (i <= j) if (s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n};\\n```\\n**Solution III:**\\nReverse the second half of the number and then compare.\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x % 10 == 0 && x != 0)) return false;\\n        int rev = 0;\\n        while (rev < x) {\\n            rev = rev * 10 + x % 10;\\n            x /= 10;\\n        }\\n        \\n        return x == rev || x == rev / 10;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string rev = to_string(x);\\n        reverse(rev.begin(), rev.end());\\n        return to_string(x) == rev;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        int i = 0, j = s.size()-1;\\n        while (i <= j) if (s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x % 10 == 0 && x != 0)) return false;\\n        int rev = 0;\\n        while (rev < x) {\\n            rev = rev * 10 + x % 10;\\n            x /= 10;\\n        }\\n        \\n        return x == rev || x == rev / 10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387961,
                "title": "no-string-or-array-conversion-4-lines-99-66-beat",
                "content": "Use a varibale to reverse number then check with given number\\n```\\nvar isPalindrome = function(x) {\\n  if (x < 0) return false\\n\\n  let rev = 0\\n  for(let i = x; i >= 1; i = Math.floor(i/10)) rev = rev*10 + i%10\\n  return rev === x\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(x) {\\n  if (x < 0) return false\\n\\n  let rev = 0\\n  for(let i = x; i >= 1; i = Math.floor(i/10)) rev = rev*10 + i%10\\n  return rev === x\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5188,
                "title": "o-1-space-o-lgn-time-java-solution-no-overflow-risk",
                "content": "    public boolean isPalindrome(int x) {\\n        \\n        if (x < 0) return false;\\n\\n        int p = x; \\n        int q = 0; \\n        \\n        while (p >= 10){\\n            q *=10; \\n            q += p%10; \\n            p /=10; \\n        }\\n        \\n        return q == x / 10 && p == x % 10;\\n    }\\n\\n// so the reversed version of int is always  1 time short in the factor of 10s . \\n\\nin case of Int16,  check 63556  will finally check if (6553 == 6355 && 6 == 63556%10)  so there will have no concerns about the overflow.",
                "solutionTags": [],
                "code": "    public boolean isPalindrome(int x) {\\n        \\n        if (x < 0) return false;\\n\\n        int p = x; \\n        int q = 0; \\n        \\n        while (p >= 10){\\n            q *=10; \\n            q += p%10; \\n            p /=10; \\n        }\\n        \\n        return q == x / 10 && p == x % 10;\\n    }\\n\\n// so the reversed version of int is always  1 time short in the factor of 10s . \\n\\nin case of Int16,  check 63556  will finally check if (6553 == 6355 && 6 == 63556%10)  so there will have no concerns about the overflow.",
                "codeTag": "Unknown"
            },
            {
                "id": 5128,
                "title": "python-solution-based-on-the-algorithm-in-leetcode-blog",
                "content": "    class Solution:\\n        # @param x, an integer\\n        # @return a boolean\\n        def isPalindrome(self, x):\\n            if x < 0:\\n                return False\\n    \\n            ranger = 1\\n            while x / ranger >= 10:\\n                ranger *= 10\\n    \\n            while x:\\n                left = x / ranger\\n                right = x % 10\\n                if left != right:\\n                    return False\\n                \\n                x = (x % ranger) / 10\\n                ranger /= 100\\n    \\n            return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param x, an integer\\n        # @return a boolean\\n        def isPalindrome(self, x):\\n            if x < 0:\\n                return False\\n    \\n            ranger = 1\\n            while x / ranger >= 10:\\n                ranger *= 10\\n    \\n            while x:\\n                left = x / ranger\\n                right = x % 10\\n                if left != right:\\n                    return False\\n                \\n                x = (x % ranger) / 10\\n                ranger /= 100\\n    \\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 316164,
                "title": "python-no-string-involved",
                "content": "Reads the number backwards and checks if the numbers are equal.\\n<br>\\n```\\nimport math \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        orig = x\\n        back_x = 0\\n        while x > 0:\\n            back_x = (back_x * 10) + (x % 10)\\n            x = x // 10\\n        return orig == back_x\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        orig = x\\n        back_x = 0\\n        while x > 0:\\n            back_x = (back_x * 10) + (x % 10)\\n            x = x // 10\\n        return orig == back_x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176639,
                "title": "java-c-best-solution-simple-solution",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n      String s = String.valueOf(x);  \\n\\n        int i = 0;                   \\n        int j = s.length() - 1; \\n       \\n          while(i <= j)      \\n        {\\n            if(s.charAt(i) != s.charAt(j))  \\n                return false;\\n            i++;                                \\n            j--;                                \\n        }  \\n        \\n        return true;\\n        \\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n      String s = String.valueOf(x);  \\n\\n        int i = 0;                   \\n        int j = s.length() - 1; \\n       \\n          while(i <= j)      \\n        {\\n            if(s.charAt(i) != s.charAt(j))  \\n                return false;\\n            i++;                                \\n            j--;                                \\n        }  \\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047788,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        stack<int> st;\\n        if(x<0)\\n            return false;\\n        int y=x;\\n        while(x)\\n        {\\n            st.push(x%10);\\n            x/=10;\\n        }\\n        while(y)\\n        {\\n            if(st.top()!=(y%10))\\n               return false;\\n             st.pop();\\n               y/=10;\\n        }\\n        return true;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        stack<int> st;\\n        if(x<0)\\n            return false;\\n        int y=x;\\n        while(x)\\n        {\\n            st.push(x%10);\\n            x/=10;\\n        }\\n        while(y)\\n        {\\n            if(st.top()!=(y%10))\\n               return false;\\n             st.pop();\\n               y/=10;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5408,
                "title": "simple-java-o-1-space-solution",
                "content": "    public boolean isPalindrome(int x) {\\n        if(x<0 || (x!=0 && x%10==0))\\n        return false;\\n        int res = 0;\\n           while(x>res){\\n            res = res*10 + x%10;\\n            x = x/10;\\n           }\\n        return (x==res || x==res/10);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isPalindrome(int x) {\\n        if(x<0 || (x!=0 && x%10==0))\\n        return false;\\n        int res = 0;\\n           while(x>res){\\n            res = res*10 + x%10;\\n            x = x/10;\\n           }\\n        return (x==res || x==res/10);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1136330,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func isPalindrome(_ x: Int) -> Bool {\\n        return x < 0 ? false : method(x: x) == x\\n    }\\n    private func method(x: Int) -> Int {\\n        var r = 0\\n        var x = x\\n        while x != 0 {\\n            r = r * 10\\n            r = r + x % 10\\n            x /= 10\\n        }\\n        return (r < Int32.min || r > Int32.max) ? 0 : r\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p>\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<br>\\n\\n<pre>\\n<b>Result:</b> Executed 4 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isPalindrome(121)\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test1() {\\n        let value = solution.isPalindrome(-121)\\n        XCTAssertEqual(value, false)\\n    }\\n    \\n    func test2() {\\n        let value = solution.isPalindrome(10)\\n        XCTAssertEqual(value, false)\\n    }\\n    \\n    func test3() {\\n        let value = solution.isPalindrome(-101)\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isPalindrome(_ x: Int) -> Bool {\\n        return x < 0 ? false : method(x: x) == x\\n    }\\n    private func method(x: Int) -> Int {\\n        var r = 0\\n        var x = x\\n        while x != 0 {\\n            r = r * 10\\n            r = r + x % 10\\n            x /= 10\\n        }\\n        return (r < Int32.min || r > Int32.max) ? 0 : r\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isPalindrome(121)\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test1() {\\n        let value = solution.isPalindrome(-121)\\n        XCTAssertEqual(value, false)\\n    }\\n    \\n    func test2() {\\n        let value = solution.isPalindrome(10)\\n        XCTAssertEqual(value, false)\\n    }\\n    \\n    func test3() {\\n        let value = solution.isPalindrome(-101)\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471810,
                "title": "168-ms-faster-than-97-26",
                "content": "```\\nvar isPalindrome = function(x) {\\n    const arr = String(x).split(\\'\\');\\n        \\n    while (arr.length > 1) {\\n        if (arr.shift() !== arr.pop()) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar isPalindrome = function(x) {\\n    const arr = String(x).split(\\'\\');\\n        \\n    while (arr.length > 1) {\\n        if (arr.shift() !== arr.pop()) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2976350,
                "title": "simple-java-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst we have to understand what is meant by a \"**PALINDROME**\" number.\\nSuppose we have a number \\'x\\'. If we **REVERSE** x and store it in \\'y\\' then x and y should be EQUAL.\\n\\nMathematically, x is palindrome iff x = y where y = reverse of x.\\n\\n    Example 1:\\n    let x = 123,\\n    then y = reverse of x = 321;\\n    Since, 123 != 321, Hence, x is NOT palindrome.\\n\\n    Example 2:\\n    let x = 1221,\\n    then y = reverse of x = 1221;\\n    Since 1221 == 1221, Hence, x is palindrome.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Two-Pointer Approach       \\n        \\n    Step1: Convert the integer into string.\\n    Step2: Point two variable at first and last indices of the string.\\n    Step3: Compare the characters at those indices.\\n    Step4: Update the variables.\\nYou will get the answer.\\n\\n        **If this solution helped you, give it a like to help others.**\\n\\n# Complexity\\n- Time complexity: O(n), where n = length of integer.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        // Two-Pointer Approach\\n        \\n        \\n        // Step1: Convert the integer into string.\\n        // Step2: Point two variable at first and last indices of the string.\\n        // Step3: Compare the characters at those indices.\\n        // Step4: Update the variables.\\n\\n        String s = String.valueOf(x);  // convert integer to string.\\n\\n        int i = 0;                     // i will initially point to first index.\\n        int j = s.length() - 1;        // j will initially point to last index. \\n        \\n        // i and j are opposite indices of the string. \\n        // 1. If \\'i\\' is first then \\'j\\' is last.\\n        // 2. Similarly, if \\'i\\' is second then \\'j\\' is second last index of s.\\n        // This is because they are updated simultaneously.\\n\\n        while(i <= j)                   // loop will break when i and j cross each other\\n        {\\n            if(s.charAt(i) != s.charAt(j))  // characters at indices i and j will be compared.\\n                // If the characters are unequal then false will be returned.\\n                return false;\\n            i++;                                // i is incremented.\\n            j--;                                // j is decremented.\\n        }\\n        \\n        // If loop ends without returning false, it means that every \\'ith\\' character\\n        // is equal to every \\'jth\\' character. Thus, the number is palindrome.\\n        // Hence, return true;\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        // Two-Pointer Approach\\n        \\n        \\n        // Step1: Convert the integer into string.\\n        // Step2: Point two variable at first and last indices of the string.\\n        // Step3: Compare the characters at those indices.\\n        // Step4: Update the variables.\\n\\n        String s = String.valueOf(x);  // convert integer to string.\\n\\n        int i = 0;                     // i will initially point to first index.\\n        int j = s.length() - 1;        // j will initially point to last index. \\n        \\n        // i and j are opposite indices of the string. \\n        // 1. If \\'i\\' is first then \\'j\\' is last.\\n        // 2. Similarly, if \\'i\\' is second then \\'j\\' is second last index of s.\\n        // This is because they are updated simultaneously.\\n\\n        while(i <= j)                   // loop will break when i and j cross each other\\n        {\\n            if(s.charAt(i) != s.charAt(j))  // characters at indices i and j will be compared.\\n                // If the characters are unequal then false will be returned.\\n                return false;\\n            i++;                                // i is incremented.\\n            j--;                                // j is decremented.\\n        }\\n        \\n        // If loop ends without returning false, it means that every \\'ith\\' character\\n        // is equal to every \\'jth\\' character. Thus, the number is palindrome.\\n        // Hence, return true;\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549534,
                "title": "python-simple-one-line-solution",
                "content": "**Python :**\\n\\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\treturn str(x) == str(x)[::-1]\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isPalindrome(self, x: int) -> bool:\\n\\treturn str(x) == str(x)[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3497184,
                "title": "c-java-python-javascript-2-approach-brute-and-optimized-fully-explained",
                "content": "# Brute Force Solution:\\n\\n### Intuition: \\nConvert the integer to a string and check if the string is equal to its reverse.\\n\\n### Approach:\\n1. Convert the integer to a string using to_string() method.\\n2. Reverse the string using the reverse() method.\\n3. Compare the original and reversed strings to check if they are equal.\\n4. If they are equal, return true. Otherwise, return false.\\n\\n## Time Complexity:\\nO(n), where n is the number of digits in the integer.\\n## Space Complexity: \\nO(n), where n is the number of digits in the integer.\\n\\n---\\n\\n\\n# Optimized Solution:\\n\\n### Intuition: \\nCheck half of the digits of the integer by extracting the last digit of the integer and adding it to a new integer.\\n\\n### Approach:\\n1. Check if the integer is negative or ends with a zero. If it is, return false.\\n2. Initialize a new integer half to 0.\\n3. While the original integer x is greater than half, extract the last digit of x and add it to half by multiplying half by 10 and adding the last digit of x.\\n4. If the length of x is odd, we need to remove the middle digit from half. To do this, we can simply divide half by 10.\\n5. Check if x is equal to half or half divided by 10.\\n6. If they are equal, return true. Otherwise, return false.\\n\\n### Time Complexity: \\nO(log n), where n is the value of the integer.\\n### Space Complexity: \\nO(1), as we only need to store two integers, x and half.\\n\\n---\\n# C++\\n### Brute Force\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        return s == t;\\n    }\\n};\\n```\\n### Optimized\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        int half = 0;\\n        while (x > half) {\\n            half = half * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return x == half || x == half / 10;\\n    }\\n};\\n\\n```\\n\\n---\\n# JAVA\\n### Brute Force\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String s = Integer.toString(x);\\n        String t = new StringBuilder(s).reverse().toString();\\n        return s.equals(t);\\n    }\\n}\\n```\\n### Optimized\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        int half = 0;\\n        while (x > half) {\\n            half = half * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return x == half || x == half / 10;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n### Brute Force\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        s = str(x)\\n        t = s[::-1]\\n        return s == t\\n```\\n### Optimized\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n        half = 0\\n        while x > half:\\n            half = half * 10 + x % 10\\n            x //= 10\\n        return x == half or x == half // 10\\n```\\n\\n---\\n# JavaScript\\n### Brute Force\\n```\\nvar isPalindrome = function(x) {\\n    var s = x.toString();\\n    var t = s.split(\"\").reverse().join(\"\");\\n    return s === t;\\n};\\n```\\n### Optimized\\n```\\nvar isPalindrome = function(x) {\\n    if (x < 0 || (x !== 0 && x % 10 === 0)) {\\n        return false;\\n    }\\n    var half = 0;\\n    while (x > half) {\\n        half = half * 10 + x % 10;\\n        x = Math.floor(x / 10);\\n    }\\n    return x === half || x === Math.floor(half / 10);\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        return s == t;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        int half = 0;\\n        while (x > half) {\\n            half = half * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return x == half || x == half / 10;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String s = Integer.toString(x);\\n        String t = new StringBuilder(s).reverse().toString();\\n        return s.equals(t);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        int half = 0;\\n        while (x > half) {\\n            half = half * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return x == half || x == half / 10;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        s = str(x)\\n        t = s[::-1]\\n        return s == t\\n```\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n        half = 0\\n        while x > half:\\n            half = half * 10 + x % 10\\n            x //= 10\\n        return x == half or x == half // 10\\n```\n```\\nvar isPalindrome = function(x) {\\n    var s = x.toString();\\n    var t = s.split(\"\").reverse().join(\"\");\\n    return s === t;\\n};\\n```\n```\\nvar isPalindrome = function(x) {\\n    if (x < 0 || (x !== 0 && x % 10 === 0)) {\\n        return false;\\n    }\\n    var half = 0;\\n    while (x > half) {\\n        half = half * 10 + x % 10;\\n        x = Math.floor(x / 10);\\n    }\\n    return x === half || x === Math.floor(half / 10);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5156,
                "title": "two-python-solution-with-o-1-space",
                "content": "\\nI. reverse the number first and see if it is equal to the original number.\\n\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        p, res = x, 0\\n        while p:\\n            res = res * 10 + p % 10\\n            p /= 10\\n        return res == x\\n\\nII. find the largest power of 10 which is smaller then x first. Then check if left most digit is equal to right most digit and so on. \\n\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        b = 1\\n        while x / b >= 10:\\n            b *= 10\\n        while b >= 10:\\n            if x / b != x % 10:\\n                return False\\n            x, b = (x % b) / 10, b / 100\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\nI. reverse the number first and see if it is equal to the original number.\\n\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        p, res = x, 0\\n        while p:\\n            res = res * 10 + p % 10\\n            p /= 10\\n        return res == x\\n\\nII. find the largest power of 10 which is smaller then x first. Then check if left most digit is equal to right most digit and so on. \\n\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        b = 1\\n        while x / b >= 10:\\n            b *= 10\\n        while b >= 10:\\n            if x / b != x % 10:\\n                return False\\n            x, b = (x % b) / 10, b / 100\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 2996838,
                "title": "python-one-line-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nString has method to reverse\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwith reversing it is possible to write in one line\\n\\'[::]\\' this means print all, and this \\'[::-1]\\' reverses, it is mostly used with list in python \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return True if str(x)==str(x)[::-1] else False",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nString has method to reverse\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwith reversing it is possible to write in one line\\n\\'[::]\\' this means print all, and this \\'[::-1]\\' reverses, it is mostly used with list in python \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return True if str(x)==str(x)[::-1] else False",
                "codeTag": "Java"
            },
            {
                "id": 234068,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    if (x < 0) return false;\\n\\t\\n    // reverse the string representation of x\\n    const reverse = `${x}`.split(\\'\\').reverse().join(\\'\\');\\n    // compare the value regardless of types\\n    return x == reverse;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    if (x < 0) return false;\\n\\t\\n    // reverse the string representation of x\\n    const reverse = `${x}`.split(\\'\\').reverse().join(\\'\\');\\n    // compare the value regardless of types\\n    return x == reverse;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5262,
                "title": "neat-ac-java-code-o-n-time-complexity",
                "content": "    public boolean isPalindrome(int x) {\\n            int palindromeX = 0;\\n            int inputX = x;\\n            while(x>0){\\n                palindromeX = palindromeX*10 + (x % 10);\\n                x = x/10;\\n            }\\n            return palindromeX==inputX;\\t\\n        }",
                "solutionTags": [],
                "code": "    public boolean isPalindrome(int x) {\\n            int palindromeX = 0;\\n            int inputX = x;\\n            while(x>0){\\n                palindromeX = palindromeX*10 + (x % 10);\\n                x = x/10;\\n            }\\n            return palindromeX==inputX;\\t\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2739816,
                "title": "java-no-string-faster-than-97-easy",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int original = x;\\n        int rev = 0;\\n        while(x>0){\\n            rev = x%10 + rev*10;\\n            x= x/10;\\n        }\\n        return rev==original ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int original = x;\\n        int rev = 0;\\n        while(x>0){\\n            rev = x%10 + rev*10;\\n            x= x/10;\\n        }\\n        return rev==original ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122215,
                "title": "js-one-liner-beats-93",
                "content": "**Please Upvote if you like this solution.**\\n\\n```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    return x < 0 ? false : (x === +x.toString().split(\"\").reverse().join(\"\"));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    return x < 0 ? false : (x === +x.toString().split(\"\").reverse().join(\"\"));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5230,
                "title": "7-line-simple-c-solution-beats-90-submissions-in-o-1-space-two-pointers",
                "content": "Use two pointers concept, find the half point, and compare first half and 2nd half. \\n\\nVariable ***revhalf*** is the reversed 2nd half(x has even number of digits), or 2nd half with the middle digit(if x has odd number of digits)\\n\\n    class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(x < 0) return false;\\n            int revhalf = 0, slow = x, fast = x;\\n            while(fast){ \\n                revhalf = revhalf * 10 + slow % 10;\\n                slow /= 10;\\n                fast /= 100;\\n            }\\n            return slow == revhalf || slow == revhalf / 10;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(x < 0) return false;\\n            int revhalf = 0, slow = x, fast = x;\\n            while(fast){ \\n                revhalf = revhalf * 10 + slow % 10;\\n                slow /= 10;\\n                fast /= 100;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2732678,
                "title": "js-91-45-no-string",
                "content": "*Upvote if you like my solution ;-)*\\n```\\nvar isPalindrome = function(x) {\\n    if (x < 0 || x % 10 == 0 && x !=0)  {\\n        return false;\\n    }\\n    let t = 0;\\n    while (x > t) {\\n        t = t * 10 + x % 10;\\n        x = Math.floor(x / 10);\\n    }\\n    return t==x || x==Math.floor(t/10);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(x) {\\n    if (x < 0 || x % 10 == 0 && x !=0)  {\\n        return false;\\n    }\\n    let t = 0;\\n    while (x > t) {\\n        t = t * 10 + x % 10;\\n        x = Math.floor(x / 10);\\n    }\\n    return t==x || x==Math.floor(t/10);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 212525,
                "title": "python-scala-with-explanations",
                "content": "We add corner cases to reduce runtime: a negative number or positive number with tailing 0s are not palindromes.\\nThen we reverse the number to check whether it equals to the original one.\\n****\\n> Python\\n```\\n    def isPalindrome(self, x):\\n        if x < 0 or (x > 0 and x % 10 == 0):\\n            return False\\n        \\n        return x == self.reverseUtil(x)\\n        \\n    def reverseUtil(self, x):\\n        result = 0\\n\\n        while x != 0:\\n            digit = x % 10\\n            result = result * 10 + digit\\n            x = int(x / 10)\\n            \\n        return result \\n```\\n> Scala\\n```\\n    def isPalindrome(x: Int): Boolean = {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false\\n        }\\n        var reversedX = reverseNumber(x)\\n        reversedX == x\\n    }\\n    \\n    def reverseNumber(x: Int): Int = {\\n        var varx = x\\n        var result = 0\\n        \\n        while (varx != 0) {\\n            result = result * 10 + varx % 10\\n            varx /= 10\\n        }\\n        \\n        return result\\n    }\\n```\\n\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    def isPalindrome(self, x):\\n        if x < 0 or (x > 0 and x % 10 == 0):\\n            return False\\n        \\n        return x == self.reverseUtil(x)\\n        \\n    def reverseUtil(self, x):\\n        result = 0\\n\\n        while x != 0:\\n            digit = x % 10\\n            result = result * 10 + digit\\n            x = int(x / 10)\\n            \\n        return result \\n```\n```\\n    def isPalindrome(x: Int): Boolean = {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false\\n        }\\n        var reversedX = reverseNumber(x)\\n        reversedX == x\\n    }\\n    \\n    def reverseNumber(x: Int): Int = {\\n        var varx = x\\n        var result = 0\\n        \\n        while (varx != 0) {\\n            result = result * 10 + varx % 10\\n            varx /= 10\\n        }\\n        \\n        return result\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3109195,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long int copy=x;\\n       long long int rev=0;\\n        while(x!=0){\\n            long long int rem;\\n            rem=x%10;\\n            rev=rev*10 +rem;\\n            x=x/10;\\n            \\n        }\\n         bool check=false;\\n        if(rev<0){\\n            return check;\\n        }\\n       \\n        else if(rev==copy){\\n            check=true;\\n            return check;\\n        }else return check;\\n        \\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long int copy=x;\\n       long long int rev=0;\\n        while(x!=0){\\n            long long int rem;\\n            rem=x%10;\\n            rev=rev*10 +rem;\\n            x=x/10;\\n            \\n        }\\n         bool check=false;\\n        if(rev<0){\\n            return check;\\n        }\\n       \\n        else if(rev==copy){\\n            check=true;\\n            return check;\\n        }else return check;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5317,
                "title": "9-ms-java-beats-99-5-java-solutions-easy-to-understand",
                "content": "    public class Solution {\\n        static int v;\\n        public static boolean isPalindrome(int x) {\\n            //optimizations\\n            if(x<0) return false;\\n            if(x<10) return true;\\n            if(x%10==0) return false;\\n            if(x<100&&x%11==0) return true;\\n            if(x<1000&&((x/100)*10+x%10)%11==0) return true;\\n\\n            //actual logic\\n            v=x%10;\\n            x=x/10;\\n            while(x-v>0)\\n            {\\n                    v=v*10+x%10;\\n                    x/=10;\\n            }\\n            if(v>x){v/=10;}\\n            return v==x?true:false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        static int v;\\n        public static boolean isPalindrome(int x) {\\n            //optimizations\\n            if(x<0) return false;\\n            if(x<10) return true;\\n            if(x%10==0) return false;\\n            if(x<100&&x%11==0) return true;\\n            if(x<1000&&((x/100)*10+x%10)%11==0) return true;\\n\\n            //actual logic\\n            v=x%10;\\n            x=x/10;\\n            while(x-v>0)\\n            {\\n                    v=v*10+x%10;\\n                    x/=10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 519779,
                "title": "noob-friendly-python-code-o-1-space-o-n-time",
                "content": "Let me know if a comment or code needs to be clarified so I can make it even easier to understand. Thanks!\\n\\n```\\ndef isPalindrome(self, num):\\n\\t#negatives can\\'t be palindromes cause of their minus sign so\\n\\t#instead of dealing with this in our main code, we get rid of this possibility immediately\\n    if num < 0: return False\\n\\n    \"\"\"\\n\\tSteps in this algorithm:\\n    1. get the reversed number (the original number but its digits reversed). e.g. 125 becomes 521\\n    2. if the reversed number == original number, its a palindrome! Done!\\n    \\n\\tHow to get reversed number (rev_num):\\n    1. we do this by \\'popping\\' the num\\'s last digit. e.g. 125 becomes 12, we store 5 as last_digit\\n    2. and then \\'appending\\' that last digit to rev_num. e.g. rev_num starts at 0. 0 becomes 5 after appending 5. 5 becomes 52 after appending 2 \\n    3. we keep doing this until all num\\'s digits have been popped, which happens when num becomes 0. e.g. when num is 0, rev_num will be 521\\n\\tNote: the \\'popping\\' and \\'appending\\' is done with cute math tricks, which is more space saving & usually faster than converting the number to a string\\n\\t\"\"\"\\n\\t\\n    original_num = num\\n    rev_num = 0\\n\\t#each line inside the while loop below does a neat math trick, try them w/ pencil & paper to understand why they work\\n    while num > 0:\\n\\t  #get last digit from num. e.g. 125 % 10 returns 5\\n      last_digit = num % 10\\n\\t  #remove last digit from num. e.g. lets say num is 125. num is then set to 125 // 10 which is 12\\n      num = num // 10\\n\\t  #effectively, the above two lines of code have simply popped the last digit from num and saved it. e.g. num is changed from 125 to 12. last_digit is set to 5\\n\\n      #append last digit to right of rev_num, e.g. 5 becomes 52 after appending 2\\n      rev_num = rev_num*10 + last_digit\\n    \\n\\t#once the while loop is done, rev_num represents the reversed number of the original number\\n\\t#in below code, if they match, its a palindrome, since palindromes are symmetrical! e.g. 125 does not equal 521 so this condition would fail\\n    return original_num == rev_num\\n\\t\\n\\t\"\"\"\\n\\tside note: the while loop gets completely skipped if num is initially 0.\\n\\tHere that situation conviently still gives us the right answer as rev_num will be 0 so its no problem, but\\n\\tstill its good to think about edge cases.\\n\\t\"\"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isPalindrome(self, num):\\n\\t#negatives can\\'t be palindromes cause of their minus sign so\\n\\t#instead of dealing with this in our main code, we get rid of this possibility immediately\\n    if num < 0: return False\\n\\n    \"\"\"\\n\\tSteps in this algorithm:\\n    1. get the reversed number (the original number but its digits reversed). e.g. 125 becomes 521\\n    2. if the reversed number == original number, its a palindrome! Done!\\n    \\n\\tHow to get reversed number (rev_num):\\n    1. we do this by \\'popping\\' the num\\'s last digit. e.g. 125 becomes 12, we store 5 as last_digit\\n    2. and then \\'appending\\' that last digit to rev_num. e.g. rev_num starts at 0. 0 becomes 5 after appending 5. 5 becomes 52 after appending 2 \\n    3. we keep doing this until all num\\'s digits have been popped, which happens when num becomes 0. e.g. when num is 0, rev_num will be 521\\n\\tNote: the \\'popping\\' and \\'appending\\' is done with cute math tricks, which is more space saving & usually faster than converting the number to a string\\n\\t\"\"\"\\n\\t\\n    original_num = num\\n    rev_num = 0\\n\\t#each line inside the while loop below does a neat math trick, try them w/ pencil & paper to understand why they work\\n    while num > 0:\\n\\t  #get last digit from num. e.g. 125 % 10 returns 5\\n      last_digit = num % 10\\n\\t  #remove last digit from num. e.g. lets say num is 125. num is then set to 125 // 10 which is 12\\n      num = num // 10\\n\\t  #effectively, the above two lines of code have simply popped the last digit from num and saved it. e.g. num is changed from 125 to 12. last_digit is set to 5\\n\\n      #append last digit to right of rev_num, e.g. 5 becomes 52 after appending 2\\n      rev_num = rev_num*10 + last_digit\\n    \\n\\t#once the while loop is done, rev_num represents the reversed number of the original number\\n\\t#in below code, if they match, its a palindrome, since palindromes are symmetrical! e.g. 125 does not equal 521 so this condition would fail\\n    return original_num == rev_num\\n\\t\\n\\t\"\"\"\\n\\tside note: the while loop gets completely skipped if num is initially 0.\\n\\tHere that situation conviently still gives us the right answer as rev_num will be 0 so its no problem, but\\n\\tstill its good to think about edge cases.\\n\\t\"\"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3188691,
                "title": "c-without-converting-to-string-simple-solution-92",
                "content": "# Intuition\\nconstruct reverse integer and check if it is the same as the original\\n\\n# Approach\\ncreate a copy c and use it to construct the reverse integer using modulo arithmetics\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nwhere n is the number of digits\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        int r = 0, c = x;\\n        while (c > 0)\\n        {\\n            r = r * 10 + c % 10;\\n            c /= 10;\\n        }\\n        return r == x; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        int r = 0, c = x;\\n        while (c > 0)\\n        {\\n            r = r * 10 + c % 10;\\n            c /= 10;\\n        }\\n        return r == x; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745571,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)[::-1] == str(x)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)[::-1] == str(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5409,
                "title": "straightforward-java-code",
                "content": "    public class Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum = 0,target = x;\\n        while (x > 0) {\\n            int temp = x % 10;\\n            x /= 10;\\n            sum = sum * 10 + temp;\\n        }\\n        return sum == target;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum = 0,target = x;\\n        while (x > 0) {\\n            int temp = x % 10;\\n            x /= 10;\\n            sum = sum * 10 + temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 5595,
                "title": "solution-using-32-bit-integer-without-overflow",
                "content": "\\nThe idea is to reverse only half of the digits and compare them.\\n\\n        public boolean isPalindrome1(int x) {\\n        if (x == 0) return true;\\n        // in leetcode, negative numbers and numbers with ending zeros\\n        // are not palindrome\\n        if (x < 0 || x % 10 == 0)\\n            return false;\\n\\n        // reverse half of the number\\n        // the exit condition is y >= x\\n        // so that overflow is avoided.\\n        int y = 0;\\n        while (y < x) {\\n            y = y * 10 + (x % 10);\\n            if (x == y)  // to check numbers with odd digits\\n                return true;\\n            x /= 10;\\n        }\\n        return x == y; // to check numbers with even digits\\n    }",
                "solutionTags": [],
                "code": "\\nThe idea is to reverse only half of the digits and compare them.\\n\\n        public boolean isPalindrome1(int x) {\\n        if (x == 0) return true;\\n        // in leetcode, negative numbers and numbers with ending zeros\\n        // are not palindrome\\n        if (x < 0 || x % 10 == 0)\\n            return false;\\n\\n        // reverse half of the number\\n        // the exit condition is y >= x\\n        // so that overflow is avoided.\\n        int y = 0;\\n        while (y < x) {\\n            y = y * 10 + (x % 10);\\n            if (x == y)  // to check numbers with odd digits\\n                return true;\\n            x /= 10;\\n        }\\n        return x == y; // to check numbers with even digits\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 151374,
                "title": "javascript-solution",
                "content": "```js\\nfunction isPalindrome(x) {\\n  if (x < 0) return false;\\n  if (x < 10) return true;\\n  if (x % 10 === 0) return false;\\n\\n  let rev = 0;\\n  while (rev < x) {\\n    rev *= 10;\\n    rev += x%10;\\n    x = Math.trunc(x/10);\\n  }\\n  return rev === x || Math.trunc(rev/10) === x;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction isPalindrome(x) {\\n  if (x < 0) return false;\\n  if (x < 10) return true;\\n  if (x % 10 === 0) return false;\\n\\n  let rev = 0;\\n  while (rev < x) {\\n    rev *= 10;\\n    rev += x%10;\\n    x = Math.trunc(x/10);\\n  }\\n  return rev === x || Math.trunc(rev/10) === x;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5133,
                "title": "my-c-solution",
                "content": "    class Solution {\\n\\npublic:\\n\\n    bool isPalindrome(int x) {\\n        if(x<0)\\n            return false;\\n\\n        int num=x;\\n        int a=0;\\n        while(x)\\n        {\\n            a=a*10 + x%10;\\n            x=x/10;\\n        }\\n        if(a==num)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n\\n\\n----------\\n## Heading ##",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    bool isPalindrome(int x) {\\n        if(x<0)\\n            return false;\\n\\n        int num=x;\\n        int a=0;\\n        while(x)\\n        {\\n            a=a*10 + x%10;\\n            x=x/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3095055,
                "title": "beats-96-beginner-friendly-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/c64fe0ee-2baf-4edc-810e-7bb0d6b71035_1674583737.648591.png)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n\\n    if(x<0)return false;\\n    int temp=x;\\n    int sum=0;\\n    while(x!=0){\\n    sum=(sum*10)+(x%10);\\n    x=x/10;\\n    }\\n    return (temp==sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n\\n    if(x<0)return false;\\n    int temp=x;\\n    int sum=0;\\n    while(x!=0){\\n    sum=(sum*10)+(x%10);\\n    x=x/10;\\n    }\\n    return (temp==sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435115,
                "title": "solution-in-c",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Palindrome Number.\\nMemory Usage: 5.8 MB, less than 97.02% of C online submissions for Palindrome Number.\\n\\n```\\nbool isPalindrome(int x){\\nlong int rev = 0;\\nint temp = x;\\nif(x<0)\\n\\treturn false;\\n\\nwhile(x){\\n    rev = rev * 10 + x % 10;\\n    x /= 10;\\n\\t}\\n        \\nreturn (temp == rev);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPalindrome(int x){\\nlong int rev = 0;\\nint temp = x;\\nif(x<0)\\n\\treturn false;\\n\\nwhile(x){\\n    rev = rev * 10 + x % 10;\\n    x /= 10;\\n\\t}\\n        \\nreturn (temp == rev);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 513145,
                "title": "four-short-python-solutions",
                "content": "S1: Integer-only (compare the original number with the completely reversed number)\\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n        return False\\n    a, b = x, 0\\n    while x:\\n        b *= 10\\n        b += x % 10\\n        x //= 10\\n    return a == b\\n```\\nS2: Integer-only with early stop (reversing only half number of digits is enough)\\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n    if x and not x % 10:\\n        return False\\n    y = 0\\n    while x > y:\\n        y *= 10\\n        y += x % 10\\n        x //= 10\\n    return x == y or x == y // 10   # even/odd number of digits\\n```\\nS3: 1-line string (could it be shorter?)\\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\treturn str(x)[::-1] == str(x)\\n```\\nS4: String with early stop\\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\ts = str(x)\\n    for i in range(len(s) // 2):\\n        if s[i] != s[~i]:\\n            return False\\n    return True\\n```\\nVote up if you find them helpful, thanks!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n        return False\\n    a, b = x, 0\\n    while x:\\n        b *= 10\\n        b += x % 10\\n        x //= 10\\n    return a == b\\n```\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n    if x and not x % 10:\\n        return False\\n    y = 0\\n    while x > y:\\n        y *= 10\\n        y += x % 10\\n        x //= 10\\n    return x == y or x == y // 10   # even/odd number of digits\\n```\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\treturn str(x)[::-1] == str(x)\\n```\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\ts = str(x)\\n    for i in range(len(s) // 2):\\n        if s[i] != s[~i]:\\n            return False\\n    return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 974775,
                "title": "c-4-line-solution-fast-easy-and-light-full-explanation-with-tips-and-tricks",
                "content": "**About:**\\nThis is a quick and easy way to solve this problem, which is both fast and consistent for any input within the integer range. Leetcode has input constraints, so integer overflow will never occur but in the real world you should first check that (x > INT_MAX), from a defensive programming standpoint.\\n\\n**A tip before beginning:**\\n*(Aimed at beginners, or those with a more formal, non-CP experience with C++)*\\nLeetcode automatically specifies ```using namespace std;``` so we do *not* need to prefix operations like \\'reverse\\' with the library identifier ```std``` using the scope operator ```::``` , such as ```std::reverse```. In the real world, it is bad practice to import the entire std namespace, and also bad practice to not specify the library that a function is a part of explicitly since it can cause conflicts during compilation. For competitive programming, it allows us to write faster, though, so definitely use it!\\n\\n**Performance:**\\nRuntime (leetcode runtime is inconsistent): 8ms.\\nMemory usage (consistent): 6.3MB.\\n\\n**Big idea:**\\nIf a reversed string representation of int x is the same as its original (forward) representation, it is a palindrome (return true). Otherwise, it is not, and we return false.\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x); //convert int x to a string\\n        string s2 = s; //make a copy of the string representation of int x to reverse\\n        reverse(s2.begin(), s2.end()); //use reverse to reverse s2  from its beginning to end\\n        return (s == s2); //*see note below\\n    }\\n};\\n```\\n**Notes, tips, and tricks:**\\n*Since (s == s2) is a conditional, and evaluates to a boolean, true or false, we can simplify the following\\n```\\nif(s == s2) {\\n\\treturn true;\\n} else {\\n\\treturn false;\\n}\\n```\\nto \\n```\\nreturn (s == s2);\\n``` \\nwhich will either return true or false.\\n\\nNote also that if you wanted the full if-else statement, you can choose to omit the brackets\\n(i.e.)\\n```\\nif(s == s2)\\n\\treturn true;\\nelse\\n\\treturn false;\\n```\\n\\nwhich is valid for compilation, and common in competitive programming, but bad practice in the real world. This is because you can only have one statement after the conditional if you omit brackets, and it\\'s easy to miss that there aren\\'t brackets and add another statement while working on a project/codebase. So, include brackets in actual programming work! Keep the quick and dirty stuff for competitive programming!\\n\\nI hope this helps :)\\n-ayyitsnicmag",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```using namespace std;```\n```std```\n```::```\n```std::reverse```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x); //convert int x to a string\\n        string s2 = s; //make a copy of the string representation of int x to reverse\\n        reverse(s2.begin(), s2.end()); //use reverse to reverse s2  from its beginning to end\\n        return (s == s2); //*see note below\\n    }\\n};\\n```\n```\\nif(s == s2) {\\n\\treturn true;\\n} else {\\n\\treturn false;\\n}\\n```\n```\\nreturn (s == s2);\\n```\n```\\nif(s == s2)\\n\\treturn true;\\nelse\\n\\treturn false;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981758,
                "title": "go-8ms-solution",
                "content": "```\\nfunc isPalindrome(num int) bool {\\n\\tif num < 0 {\\n\\t\\treturn false\\n\\t}\\n\\tx := num\\n\\treversed := 0\\n\\tfor x != 0 {\\n\\t\\treversed = 10*reversed + x%10\\n\\t\\tx /= 10\\n\\t}\\n\\treturn (reversed == num)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPalindrome(num int) bool {\\n\\tif num < 0 {\\n\\t\\treturn false\\n\\t}\\n\\tx := num\\n\\treversed := 0\\n\\tfor x != 0 {\\n\\t\\treversed = 10*reversed + x%10\\n\\t\\tx /= 10\\n\\t}\\n\\treturn (reversed == num)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 467842,
                "title": "javascript",
                "content": "Runtime: 180 ms, faster than 86.82% of JavaScript online submissions for Palindrome Number.\\nMemory Usage: 45.4 MB, less than 64.65% of JavaScript online submissions for Palindrome Number.\\n\\n```\\nvar isPalindrome = function(x) {\\n    const s = x.toString();\\n    if (s.length === 1) {\\n        return true;\\n    }\\n    const start = s[0];\\n    const end = s[s.length - 1];\\n    if (start !== end) {\\n        return false;\\n    }\\n    if (s.length === 2) {\\n        return true;\\n    }\\n    const subStr = s.substring(1, s.length - 1);\\n    return isPalindrome(subStr);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPalindrome = function(x) {\\n    const s = x.toString();\\n    if (s.length === 1) {\\n        return true;\\n    }\\n    const start = s[0];\\n    const end = s[s.length - 1];\\n    if (start !== end) {\\n        return false;\\n    }\\n    if (s.length === 2) {\\n        return true;\\n    }\\n    const subStr = s.substring(1, s.length - 1);\\n    return isPalindrome(subStr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5583,
                "title": "is-this-simple-enough-what-is-the-so-called-generic-way",
                "content": "    class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            int i = 0;;\\n            if ((x % 10 == 0 && x != 0) || x < 0) return false;\\n            while (i < x) {\\n                i = i * 10 + x % 10;\\n                x = x / 10;\\n            }\\n            return (i == x || i / 10 == x);        \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            int i = 0;;\\n            if ((x % 10 == 0 && x != 0) || x < 0) return false;\\n            while (i < x) {\\n                i = i * 10 + x % 10;\\n                x = x / 10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2686747,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```\\nWe convert the integer to a string and reverse it using index slicing (str(x)[::-1]). Next, we compare the reversed string to the original (str(x) == str(x)[::-1]). We perform the check in the return statement so that our function will return true if the number is a palindrome and false if it is not.\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310664,
                "title": "simple-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(long int x) {\\n       long int r,sum=0,t;\\n        t=x;\\n        while(t>0)\\n        {\\n            r=t%10;\\n            sum=sum*10+r;\\n            t/=10;\\n        }\\n        if(sum==x)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(long int x) {\\n       long int r,sum=0,t;\\n        t=x;\\n        while(t>0)\\n        {\\n            r=t%10;\\n            sum=sum*10+r;\\n            t/=10;\\n        }\\n        if(sum==x)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010225,
                "title": "c-3-line-solution-faster-than-99-65-explained",
                "content": "# Intuition\\nWe can easily solve this problem by looking at the definition of a palindrome. \"An integer is a palindrome when it reads the same forward and backward.\"\\n\\nFirst, we can convert `x` to a string, reverse it, and check if it is equal to the original.\\n\\nWe can convert the string into a char array and reverse it using `Array.Reverse()`.\\n\\nThen, we can concatenate all the values of the array by saying `new string(arr)`.\\n\\n\\n\\n\\nFor context in the solution below:\\n`y` is the char array where x is reversed in.\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n\\t\\tvar y = x.ToString().ToCharArray();  \\n        Array.Reverse(y); //Reverses char array.\\n        return x.ToString() == new string(y);\\n        //Checks if original string is equal to its reverse.\\n    }\\n}\\n```\\n\\nEdit: Thanks to the comments below, I\\'ve learned that there is a built-in function for reversing the string (no need to convert it to a CharArray). Probably could be done in one line, Python style.\\n\\nInstead, it could be done like this:\\n\\n```\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n\\t\\treturn x.ToString().Reverse() == x.ToString()\\n    }\\n}\\n```\\n\\n(Much thanks to @rhazizi and @akimz08)",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n\\t\\tvar y = x.ToString().ToCharArray();  \\n        Array.Reverse(y); //Reverses char array.\\n        return x.ToString() == new string(y);\\n        //Checks if original string is equal to its reverse.\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n\\t\\treturn x.ToString().Reverse() == x.ToString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178022,
                "title": "simple-and-clear-c",
                "content": "```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        int rev = 0, temp = x;\\n        while(temp > 0){\\n            rev = rev*10 + temp%10;\\n            temp /= 10;\\n        }\\n        return x == rev;\\n        \\n    }\\n}\\n```\\n\\nAnother Approach using String in C#\\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string str = x.ToString();\\n        int low = 0;\\n        while(low < str.Length - low - 1){\\n            if(str[low] != str[str.Length-low-1])\\n                return false;\\n            low++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        int rev = 0, temp = x;\\n        while(temp > 0){\\n            rev = rev*10 + temp%10;\\n            temp /= 10;\\n        }\\n        return x == rev;\\n        \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string str = x.ToString();\\n        int low = 0;\\n        while(low < str.Length - low - 1){\\n            if(str[low] != str[str.Length-low-1])\\n                return false;\\n            low++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797115,
                "title": "easy-python-solution-with-o-1-space",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0:\\n            return False\\n        \\n        res = 0\\n        temp = x\\n        \\n        while temp:\\n            temp, n = divmod(temp, 10)\\n            res = (res * 10) + n\\n                \\n        return res == x\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0:\\n            return False\\n        \\n        res = 0\\n        temp = x\\n        \\n        while temp:\\n            temp, n = divmod(temp, 10)\\n            res = (res * 10) + n\\n                \\n        return res == x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744540,
                "title": "piss-easy-javascript-solution-even-noobs-can-understand",
                "content": "```\\nvar isPalindrome = function(x) {\\n    let pali = x.toString()\\n    .split(\\'\\')\\n    .reverse()\\n    .join(\\'\\')\\n    let normal = x.toString()\\n   return (pali === normal)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(x) {\\n    let pali = x.toString()\\n    .split(\\'\\')\\n    .reverse()\\n    .join(\\'\\')\\n    let normal = x.toString()\\n   return (pali === normal)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2350136,
                "title": "rust-one-liner",
                "content": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        return x.to_string().chars().rev().eq(x.to_string().chars())\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        return x.to_string().chars().rev().eq(x.to_string().chars())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527951,
                "title": "java-tc-o-log10-n-2-sc-o-1-optimal-reverse-half-compare",
                "content": "```java\\n/**\\n * Reverse Half & Compare\\n *\\n * Time Complexity: O((log10 N) / 2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Number of digits in input number.\\n */\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        if (x < 10) {\\n            return true;\\n        }\\n\\n        int reverse = 0;\\n        while (reverse < x) {\\n            reverse = reverse * 10 + x % 10;\\n            x /= 10;\\n        }\\n\\n       /**\\n         * If input number has even number of digits then check `x == reverse`.\\n         *\\n         * If input number has odd number of digits then check `x == reverse / 10`. This\\n         * is because, reverse will have one extra digit. Middle digit of original\\n         * number will be least significant digit of reverse.\\n         */\\n        return reverse == x || reverse / 10 == x;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Palindrome questions on LeetCode:\\n- [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/discuss/1539190/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Two-Optimized-solutions-with-Early-Exit-Condition)\\n- [266. Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/discuss/1527941/Java-or-TC:-O(N)-or-SC:-O(N)-or-Early-Exit-and-Space-Optimized-HashSet-solution)\\n- [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/1527948/Java-or-TC:-O(N*(N2)!)-or-SC:-O(N)-or-Optimal-Backtracking-using-CountMap)\\n- [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/discuss/1539193/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Optimized-solution-for-continuous-repeating-chars)\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```java\\n/**\\n * Reverse Half & Compare\\n *\\n * Time Complexity: O((log10 N) / 2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Number of digits in input number.\\n */\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        if (x < 10) {\\n            return true;\\n        }\\n\\n        int reverse = 0;\\n        while (reverse < x) {\\n            reverse = reverse * 10 + x % 10;\\n            x /= 10;\\n        }\\n\\n       /**\\n         * If input number has even number of digits then check `x == reverse`.\\n         *\\n         * If input number has odd number of digits then check `x == reverse / 10`. This\\n         * is because, reverse will have one extra digit. Middle digit of original\\n         * number will be least significant digit of reverse.\\n         */\\n        return reverse == x || reverse / 10 == x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5594,
                "title": "sharing-my-simple-and-straightforward-solution-with-explanation",
                "content": "    bool isPalindrome(int x) {\\n        long reverse = 0;\\n        long num = abs(x);\\n        while(x != 0){\\n            reverse *= 10;\\n            reverse += x % 10;\\n            x /= 10;\\n        }\\n        return reverse == num;\\n    }\\n\\nThe basic idea is to reverse `x`.\\n\\nHowever, we need to handle two issues. First of all, what if reverse number overflows? We use `long` to solve. Secondly, negative number doesn't have palindrome. So we make num = abs(x).",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "    bool isPalindrome(int x) {\\n        long reverse = 0;\\n        long num = abs(x);\\n        while(x != 0){\\n            reverse *= 10;\\n            reverse += x % 10;\\n            x /= 10;\\n        }\\n        return reverse == num;\\n    }\\n\\nThe basic idea is to reverse `x`.\\n\\nHowever, we need to handle two issues. First of all, what if reverse number overflows? We use `long` to solve. Secondly, negative number doesn't have palindrome. So we make num = abs(x).",
                "codeTag": "Unknown"
            },
            {
                "id": 4033190,
                "title": "c-java-python-two-methods-explained-intuition",
                "content": "# Problem Description\\n**Given** an integer x, return **true** if x is a **palindrome**, and **false** otherwise.\\n\\n**Palindrome** is a **word**, **phrase**, **number**, or **other sequence of characters** that **reads** the **same** **forward** and **backward**. In simpler terms, it\\'s something that `remains unchanged when its order is reversed`.\\n\\nHere are a few examples of palindromes:\\n- Words :\"racecar\", \"madam\"\\n- Numbers: 121, 1331, 12321\\n\\n---\\n# Intuition\\n## First Approach (Convert to String)\\nThe **first** approach is to **convert our number into a string** and there we can **access** any digit **freely** unlike the integer that we can\\'t do that there.\\nthen we can make a **mirror** around the middle of the string and **compare** the first char with last char, the second with the one before last and so on.\\nif there is a **difference** then return false otherwise return true. \\n\\n![image.png](https://assets.leetcode.com/users/images/d6c0868b-843e-4f69-a092-4a5f4c39051f_1694475883.578209.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/cf45160a-6169-463a-a4d0-8c85c5fa029a_1694475917.7519221.png)\\n\\n\\n## Second Approach (Extract Digits using %)\\n\\n**Modulo operation** is is a mathematical operation that returns the remainder when one number is divided by another.\\n- 7 % 3 = 1\\n- 9 % 5 = 4\\n\\nModulo operation is very helpful in our problem since it helps us to **extract the least digit in our number**.\\nThe solution is **extract** the digit from the original number then **put it as least digit** in our new reversed number then **delete** that digit by dividing by 10.\\n\\n**Example : 121**\\n```\\nnumber = 121 , reversed = 0 \\ndigit = 121 % 10 = 1 \\nreversed = 0 * 10 + 1 = 1\\nnumber = 121 / 10 = 12\\n```\\n```\\nnumber = 12 , reversed = 1 \\ndigit = 12 % 10 = 2 \\nreversed = 1 * 10 + 2 = 2\\nnumber = 12 / 10 = 1\\n```\\n```\\nnumber = 1 , reversed = 12\\ndigit = 1 % 10 = 1 \\nreversed = 12 * 10 + 1 = 121\\nnumber = 1 / 10 = 0\\n```\\nWe can see that reversed number **equal** to original number which means it is palindrome.\\n\\n\\n---\\n\\n\\n# Approach\\n## First Approach (Convert to String)\\n- **Convert** the integer x to a string representation.\\n- Determine the **length** of the string.\\n- Set up a for **loop** that iterates from the beginning of the string (index 0) to halfway through the string (length / 2).\\n- Inside the loop, **compare** the character at the **current** position (number[i]) with the character at the **corresponding** position from the end of the string (number[length - i - 1]).\\n- If the characters **do not match** (i.e., the number is not palindrome from the center outward), return **false** immediately, indicating that it\\'s not a palindrome.\\n- If the **loop** **completes** without finding any mismatches (all digits match), return **true**, indicating that the integer is a palindrome.\\n\\n# Complexity\\n- **Time complexity:**$$O(N)$$\\nSince we are iterating over all the digits.\\n- **Space complexity:**$$O(N)$$\\nSince we are storing the number as a string where `N` here is the number of the digits.\\n---\\n## Second Approach (Extract Digits using %)\\n- Create **two long variables**, number and reversed, both initially set to the value of the input integer x. The number variable stores the **original** number, and reversed will store the **number in reverse order**.\\n- Enter a while **loop** that continues as long as the value of x is greater than 0.\\n- Inside the **loop**:\\n    - Calculate the **last digit of x** by taking the remainder of x when divided by 10 **(x % 10)**. This digit is stored in the digit variable.\\n    - **Update the reversed variable** by multiplying it by 10 (shifting digits left) and then adding the digit to it. This effectively builds the reversed number digit by digit.\\n    - **Remove the last digit** from x by dividing it by 10 (x /= 10).\\n- After the loop completes, all digits of x have been processed and reversed in reversed.\\n- Check if the number (the original input) is **equal** to the reversed (the reversed input). If they are equal, return **true**, indicating that the integer is a palindrome. If they are not equal, return **false**.\\n\\n# Complexity\\n- **Time complexity:**$$O(N)$$\\nSince we are iterating over all the digits.\\n- **Space complexity:**$$O(1)$$\\nWe only store two additional variables.\\n\\n# Code\\n## First Approach (Convert to String)\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string number = to_string(x) ;\\n        int length = number.size() ;\\n        for(int i = 0 ; i < length / 2 ; i ++){\\n            if(number[i] != number[length - i - 1])\\n                return false ;\\n        }\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String number = Integer.toString(x);\\n        int length = number.length();\\n        for (int i = 0; i < length / 2; i++) {\\n            if (number.charAt(i) != number.charAt(length - i - 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        number = str(x)\\n        length = len(number)\\n        \\n        for i in range(length // 2):\\n            if number[i] != number[length - i - 1]:\\n                return False\\n        \\n        return True\\n```\\n## Second Approach (Extract Digits using %)\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long number = x, reversed = 0;\\n        while(x > 0){\\n            int digit = x % 10 ;\\n            reversed = (reversed * 10) + digit ; \\n            x /= 10 ;\\n        }\\n        return number == reversed ;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        long number = x;\\n        long reversed = 0;\\n        \\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = (reversed * 10) + digit;\\n            x /= 10;\\n        }\\n        return number == reversed;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        number = x\\n        reversed_num = 0\\n        \\n        while x > 0:\\n            digit = x % 10\\n            reversed_num = (reversed_num * 10) + digit\\n            x //= 10\\n        \\n        return number == reversed_num\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nnumber = 121 , reversed = 0 \\ndigit = 121 % 10 = 1 \\nreversed = 0 * 10 + 1 = 1\\nnumber = 121 / 10 = 12\\n```\n```\\nnumber = 12 , reversed = 1 \\ndigit = 12 % 10 = 2 \\nreversed = 1 * 10 + 2 = 2\\nnumber = 12 / 10 = 1\\n```\n```\\nnumber = 1 , reversed = 12\\ndigit = 1 % 10 = 1 \\nreversed = 12 * 10 + 1 = 121\\nnumber = 1 / 10 = 0\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string number = to_string(x) ;\\n        int length = number.size() ;\\n        for(int i = 0 ; i < length / 2 ; i ++){\\n            if(number[i] != number[length - i - 1])\\n                return false ;\\n        }\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String number = Integer.toString(x);\\n        int length = number.length();\\n        for (int i = 0; i < length / 2; i++) {\\n            if (number.charAt(i) != number.charAt(length - i - 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        number = str(x)\\n        length = len(number)\\n        \\n        for i in range(length // 2):\\n            if number[i] != number[length - i - 1]:\\n                return False\\n        \\n        return True\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long number = x, reversed = 0;\\n        while(x > 0){\\n            int digit = x % 10 ;\\n            reversed = (reversed * 10) + digit ; \\n            x /= 10 ;\\n        }\\n        return number == reversed ;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        long number = x;\\n        long reversed = 0;\\n        \\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = (reversed * 10) + digit;\\n            x /= 10;\\n        }\\n        return number == reversed;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        number = x\\n        reversed_num = 0\\n        \\n        while x > 0:\\n            digit = x % 10\\n            reversed_num = (reversed_num * 10) + digit\\n            x //= 10\\n        \\n        return number == reversed_num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928466,
                "title": "easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x<0:\\n            return False\\n\\n        empty = []\\n\\n        while x > 0:\\n            x, remd = divmod(x, 10)\\n            empty.append(remd)\\n\\n        a=empty[::-1]\\n        if a==empty:\\n            return True\\n        \\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x<0:\\n            return False\\n\\n        empty = []\\n\\n        while x > 0:\\n            x, remd = divmod(x, 10)\\n            empty.append(remd)\\n\\n        a=empty[::-1]\\n        if a==empty:\\n            return True\\n        \\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065237,
                "title": "palindrome-number-easy-c-using-string",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing to_string\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x  <  0)return false;\\n        string s = to_string(x);\\n        for(int i=0;i<s.length()/2;i++){\\n            if(s[i] != s[s.length() -1 - i])return false;\\n        }\\n        return true;\\n\\n    }\\n};\\n```\\nupvote if you like it\\n",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x  <  0)return false;\\n        string s = to_string(x);\\n        for(int i=0;i<s.length()/2;i++){\\n            if(s[i] != s[s.length() -1 - i])return false;\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946947,
                "title": "java-runtime-4-ms-beats-100",
                "content": "# Intuition\\nMy initial approach to determining whether a given integer is a palindrome involves reversing the digits of the number and comparing the reversed number with the original number. If they are the same, the number is a palindrome.\\n\\n# Approach\\nI will reverse the digits of the given integer by repeatedly extracting the last digit of the number and building the reversed number. I\\'ll compare the reversed number with the original number, and if they match, the number is a palindrome.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n  The number of digits in the input number is proportional to the logarithm of the number with respect to the base 10. Reversing the digits takes logarithmic time.\\n\\n- Space complexity: O(1)\\n  The algorithm uses a constant amount of extra space to store the reversed number and some variables.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int revers = 0;\\n        int temp =  x;\\n        while (x > 0) {\\n            int digit = x % 10;\\n\\n\\n           revers = revers*10 + digit;\\n\\n\\n            x /= 10;\\n\\n\\n        }\\n\\n        if(revers==temp){\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int revers = 0;\\n        int temp =  x;\\n        while (x > 0) {\\n            int digit = x % 10;\\n\\n\\n           revers = revers*10 + digit;\\n\\n\\n            x /= 10;\\n\\n\\n        }\\n\\n        if(revers==temp){\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469770,
                "title": "o-logn-time-complexity-beginner-friendly-solution-c",
                "content": "- Description:\\n              Firstly, I declare two variables one is copy of x and another is sum which stores reverse number.\\n              I start one loop which stop when my original number is less than or equal to 0. inside it I just reverse that number by using modulo-division method. firstly, I do (x%10) which equal to last digit of original number which stores in sum but after each iteration I multiply 10 to it. and also divides original number to 10.\\n              After that loop I have one copy of original number(Here I can not compare to original number because after looping my original number is becomes 0 causing division in loop). so I compare that copy of number with sum variable which stores reverse number.\\n              If my reverse number is equal to original number then It is palindrome otherwise it doesn\\'t.\\n\\n# Complexity\\n- **Time complexity: O(logn) or O(lengthof(x)) or O(no.ofdigitsin(x))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long on=x;\\n        long long sum=0;\\n        while(x>0)\\n        {\\n            sum=(sum*10)+(x%10);\\n            x/=10;\\n        }\\n        if(sum==on)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/d7e96e70-e0b8-4bd1-8949-6de3276d7cb0_1682854946.7058163.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long on=x;\\n        long long sum=0;\\n        while(x>0)\\n        {\\n            sum=(sum*10)+(x%10);\\n            x/=10;\\n        }\\n        if(sum==on)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569908,
                "title": "easy-c-soution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int temp = x;\\n        long long int rev=0;\\n        while(x>0)\\n        {\\n            rev = rev*10 + x%10;\\n            x = x/10;\\n        }\\n        if(rev==temp)\\n            return true;\\n        return false;\\n    }\\n};\\n\\nup vote if you like it\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int temp = x;\\n        long long int rev=0;\\n        while(x>0)\\n        {\\n            rev = rev*10 + x%10;\\n            x = x/10;\\n        }\\n        if(rev==temp)\\n            return true;\\n        return false;\\n    }\\n};\\n\\nup vote if you like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770500,
                "title": "easy-c-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        int i = 0, j = s.length() - 1;\\n        \\n        while(i <= j)\\n        {\\n            if(s[i] != s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        int i = 0, j = s.length() - 1;\\n        \\n        while(i <= j)\\n        {\\n            if(s[i] != s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756913,
                "title": "100-fastest-solution-explained",
                "content": "Easy to understand, detailed solution with step by step explanation and code in multiple languages:\\n\\nhttps://www.code-recipe.com/post/palindrome-number\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer.\\n\\n**Kindly upvote if this helps you. Thank You**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Go"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 5443,
                "title": "44ms-c-solution",
                "content": "You can also view more solution on [Github](https://github.com/flexwang/CodeTest)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isPalindrome(int x) {\\n\\t\\t\\tif (x < 0) return false;\\n\\t\\t\\tint p1 = 0, p2 = x;\\n\\t\\t\\twhile (p2 > 0) {\\n\\t\\t\\t\\tp1 = p1*10 + p2%10;\\n\\t\\t\\t\\tp2 /= 10;\\n\\t\\t\\t}\\n\\t\\t\\treturn p1 == x;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isPalindrome(int x) {\\n\\t\\t\\tif (x < 0) return false;\\n\\t\\t\\tint p1 = 0, p2 = x;\\n\\t\\t\\twhile (p2 > 0) {\\n\\t\\t\\t\\tp1 = p1*10 + p2%10;\\n\\t\\t\\t\\tp2 /= 10;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3341636,
                "title": "javascript-100-easy-explanation-overall-o-1-space",
                "content": "# Intuition\\nThis approach converts the input integer x into a string using the toString() method. It then creates two pointers, leftIndex and rightIndex, that start at opposite ends of the string. The algorithm then iterates over the string, comparing the characters at the leftIndex and rightIndex. If they are not the same, the function returns false, indicating that x is not a palindrome. If the pointers meet in the middle of the string and all characters match, the function returns true, indicating that x is a palindrome.\\n\\nThis approach has a time complexity of O(n), where n is the length of the string representation of x, and a space complexity of O(1), because it uses a constant amount of extra memory.\\n\\n# Approach\\nThis code checks if a given number is a palindrome or not by converting it into a string and then comparing its characters. A simpler approach can be to directly compare the digits of the number by reversing them and checking if they are equal.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function (x) {\\n  //TIME-COMPLEXITY: O(n);\\n  //MEMORY: O(1);\\n  const str = x.toString();\\n  let leftIndex = 0;\\n  let rightIndex = str.length - 1;\\n\\n  while (leftIndex < rightIndex) {\\n    if (str.charAt(leftIndex) !== str.charAt(rightIndex)) {\\n      return false;\\n    }\\n    leftIndex++;\\n    rightIndex--;\\n  }\\n\\n  return true;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function (x) {\\n  //TIME-COMPLEXITY: O(n);\\n  //MEMORY: O(1);\\n  const str = x.toString();\\n  let leftIndex = 0;\\n  let rightIndex = str.length - 1;\\n\\n  while (leftIndex < rightIndex) {\\n    if (str.charAt(leftIndex) !== str.charAt(rightIndex)) {\\n      return false;\\n    }\\n    leftIndex++;\\n    rightIndex--;\\n  }\\n\\n  return true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728864,
                "title": "c-easy-to-understand-palindrome-number",
                "content": "# Upvote if its helps\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        vector<int> idkw;\\n        if(x<0) return false;\\n        int temp=x;\\n        while(temp){\\n            idkw.push_back(temp%10);\\n            temp/=10;\\n        }\\n        int l=0,r=idkw.size()-1;\\n        while(l<r){\\n            if(idkw[l]!=idkw[r]) return false;\\n            l++;r--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        vector<int> idkw;\\n        if(x<0) return false;\\n        int temp=x;\\n        while(temp){\\n            idkw.push_back(temp%10);\\n            temp/=10;\\n        }\\n        int l=0,r=idkw.size()-1;\\n        while(l<r){\\n            if(idkw[l]!=idkw[r]) return false;\\n            l++;r--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429373,
                "title": "easy-java-solutions",
                "content": "##### Approach 1: Two-Pointer solution\\n``` java\\n     public boolean isPalindrome(int x) {\\n\\t\\t // convert input into an array and rest is nothing but a simple two pointer solution\\n         char[] nums = String.valueOf(x).toCharArray();\\n         int start = 0;\\n         int end = nums.length-1;\\n         while(start < end) {\\n             if(nums[start] != nums[end]) return false;\\n             start++; end--;\\n         }\\n        return true;\\n    }\\n```\\n##### Complexity Analysis\\n* Time Complexity: O(n)\\n* Space Complexity: O(n)\\n\\n##### Approach 2: Intuitive Arithematic Solution\\n```java\\n    public boolean isPalindrome(int x) {\\n\\t\\t// negative case\\n        if(x < 0 || (x!=0 && x%10 == 0)) return false;\\n        int res = 0;\\n\\t\\t// idea here is to recontruct the given input from reverse and later check whether \\n\\t\\t// the input and the result match\\n        while(res < x) {\\n            res = res*10 + x%10;\\n            x = x/10;\\n        }\\n        \\n        return (x==res || res/10 == x);\\n    }\\n```\\n##### Complexity Analysis\\n* Time Complexity: O(n)\\n* Space Complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\n     public boolean isPalindrome(int x) {\\n\\t\\t // convert input into an array and rest is nothing but a simple two pointer solution\\n         char[] nums = String.valueOf(x).toCharArray();\\n         int start = 0;\\n         int end = nums.length-1;\\n         while(start < end) {\\n             if(nums[start] != nums[end]) return false;\\n             start++; end--;\\n         }\\n        return true;\\n    }\\n```\n```java\\n    public boolean isPalindrome(int x) {\\n\\t\\t// negative case\\n        if(x < 0 || (x!=0 && x%10 == 0)) return false;\\n        int res = 0;\\n\\t\\t// idea here is to recontruct the given input from reverse and later check whether \\n\\t\\t// the input and the result match\\n        while(res < x) {\\n            res = res*10 + x%10;\\n            x = x/10;\\n        }\\n        \\n        return (x==res || res/10 == x);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 272592,
                "title": "java-concise-6ms-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0, y = x;\\n        while (y > 0) {\\n            rev = rev * 10 + y % 10;\\n            y /= 10;\\n        }\\n        return rev == x;\\n    }\\n}\\n```\\nTime complexity: O(logN)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0, y = x;\\n        while (y > 0) {\\n            rev = rev * 10 + y % 10;\\n            y /= 10;\\n        }\\n        return rev == x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5141,
                "title": "javascript-fast-optimized",
                "content": "Hi guys, let's check this optimised solution for JS\\n```\\nvar isPalindrome = function(x) {\\n    if (x < 0) return false;        // only positive number\\n    if (x < 10) return true;        // for 1-9 cases\\n    if (x % 10 === 0) return false; // in case of last 0 [3330, 123320, 1000, etc]\\n    let rev = 0;                    // reversed number\\n    while (x >= 10) {\\n        let cur = x % 10;\\n        rev = rev*10 + cur;\\n        if (x === rev) return true; // check before changing\\n        x = ~~(x / 10); // better replace for Math.floor(), bit operator '~' inverts all the bits in your number and in the process converts the number to an int\\n        if (x === rev) return true; // check after changing\\n        if (x < rev) return false;  // stop in case reversed number becomes greater than original value\\n    }\\n    return false; // the longest case (diff in the middle) // [77778777, 10004001] \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPalindrome = function(x) {\\n    if (x < 0) return false;        // only positive number\\n    if (x < 10) return true;        // for 1-9 cases\\n    if (x % 10 === 0) return false; // in case of last 0 [3330, 123320, 1000, etc]\\n    let rev = 0;                    // reversed number\\n    while (x >= 10) {\\n        let cur = x % 10;\\n        rev = rev*10 + cur;\\n        if (x === rev) return true; // check before changing\\n        x = ~~(x / 10); // better replace for Math.floor(), bit operator '~' inverts all the bits in your number and in the process converts the number to an int\\n        if (x === rev) return true; // check after changing\\n        if (x < rev) return false;  // stop in case reversed number becomes greater than original value\\n    }\\n    return false; // the longest case (diff in the middle) // [77778777, 10004001] \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588907,
                "title": "simple-python-solution",
                "content": "This solution is a direct one, i am just comapring reverse of the string to the original string. As we are taking input as integer x. So, first convert it to a str() and then do [::-1] reverse.\\n\\n        if str(x)[::-1] == str(x):\\n            \\n            return True\\n        else:\\n            return False\\n        \\n        \\n You can directly return as well.\\n \\n \\n return True if str(x)[::-1] == str(x) else False\\n \\n \\n If you liked it, give it a Upvote.",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "This solution is a direct one, i am just comapring reverse of the string to the original string. As we are taking input as integer x. So, first convert it to a str() and then do [::-1] reverse.\\n\\n        if str(x)[::-1] == str(x):\\n            \\n            return True\\n        else:\\n            return False\\n        \\n        \\n You can directly return as well.\\n \\n \\n return True if str(x)[::-1] == str(x) else False\\n \\n \\n If you liked it, give it a Upvote.",
                "codeTag": "Unknown"
            },
            {
                "id": 733411,
                "title": "palindrome-number-solution-with-c",
                "content": "bool isPalindrome(int x){\\n    int reverse = 0;\\n    int temp = x; \\n    if (x < 0 || x > 0 && x%10 == 0){\\n        return 0;\\n    }\\n    else{\\n        while(temp!= 0){\\n            if (reverse<= INT_MAX/10){\\n                reverse = reverse*10 + temp%10;\\n                temp /= 10; \\n            }\\n            else break;\\n        }\\n    }\\n    return x == reverse;\\n}",
                "solutionTags": [],
                "code": "bool isPalindrome(int x){\\n    int reverse = 0;\\n    int temp = x; \\n    if (x < 0 || x > 0 && x%10 == 0){\\n        return 0;\\n    }\\n    else{\\n        while(temp!= 0){\\n            if (reverse<= INT_MAX/10){\\n                reverse = reverse*10 + temp%10;\\n                temp /= 10; \\n            }\\n            else break;\\n        }\\n    }\\n    return x == reverse;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 5325,
                "title": "an-accepted-solution-using-no-extra-variable",
                "content": "Yes I misunderstood the meaning of 'no extra space' and I took it for no extra local variable.\\nNevertheless I post a messy one here for those who are by any chance interested.\\nI know it's not what the author intended and it is quite inefficient because of all the repetitive formulas but the basic approach is simple and clear so please don't vote me down :)\\n```\\n#include <math.h>\\n\\n//number of digits of x\\n#define n_digit_of(x) ((int)log10(x))\\n\\n//10^n\\n#define ten_to_power_of(n) ((int)exp(log(10) * (n)))\\n\\n//e.g. the 'order' of 1221 is 1000\\n#define order_of(x) (ten_to_power_of(n_digit_of(x)))\\n\\n//e.g. the number of 'front' 0s of 3000458 is 3.\\n#define n_front_zero_of(x) (n_digit_of(x) - n_digit_of((x) % order_of(x)) - 1)\\n\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false;\\n    }\\n   \\n    while (x >= 10) {\\n        //compare the most significant and least significant digits\\n        if (x / order_of(x) != (x % 10)) {\\n            return false;\\n        }\\n        \\n        //in case like 400303004, we have to judge more digits\\n        if (n_digit_of(x) - n_digit_of(x % order_of(x)) > 1) {\\n            if (x % ten_to_power_of(n_front_zero_of(x) + 1) != (x % 10)) {\\n                return false;\\n            }\\n        }\\n\\n        //now strip the most significant and least significant parts and continue\\n        //e.g. 400303004 => 303        \\n        x = x % order_of(x) / ten_to_power_of((n_front_zero_of(x) + 1));\\n     }\\n    \\n    return true;\\n}",
                "solutionTags": [],
                "code": "Yes I misunderstood the meaning of 'no extra space' and I took it for no extra local variable.\\nNevertheless I post a messy one here for those who are by any chance interested.\\nI know it's not what the author intended and it is quite inefficient because of all the repetitive formulas but the basic approach is simple and clear so please don't vote me down :)\\n```\\n#include <math.h>\\n\\n//number of digits of x\\n#define n_digit_of(x) ((int)log10(x))\\n\\n//10^n\\n#define ten_to_power_of(n) ((int)exp(log(10) * (n)))\\n\\n//e.g. the 'order' of 1221 is 1000\\n#define order_of(x) (ten_to_power_of(n_digit_of(x)))\\n\\n//e.g. the number of 'front' 0s of 3000458 is 3.\\n#define n_front_zero_of(x) (n_digit_of(x) - n_digit_of((x) % order_of(x)) - 1)\\n\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false;\\n    }\\n   \\n    while (x >= 10) {\\n        //compare the most significant and least significant digits\\n        if (x / order_of(x) != (x % 10)) {\\n            return false;\\n        }\\n        \\n        //in case like 400303004, we have to judge more digits\\n        if (n_digit_of(x) - n_digit_of(x % order_of(x)) > 1) {\\n            if (x % ten_to_power_of(n_front_zero_of(x) + 1) != (x % 10)) {\\n                return false;\\n            }\\n        }\\n\\n        //now strip the most significant and least significant parts and continue\\n        //e.g. 400303004 => 303        \\n        x = x % order_of(x) / ten_to_power_of((n_front_zero_of(x) + 1));\\n     }\\n    \\n    return true;\\n}",
                "codeTag": "C++"
            },
            {
                "id": 5173,
                "title": "beat-90-in-java",
                "content": "     public boolean isPalindrome(int x) {\\n            if (x < 0) return false;\\n            int ans = 0;\\n            int num = x;\\n            while ( num > 0) {\\n                ans = ans * 10 + num % 10;\\n                num = num / 10;\\n            }\\n            if (ans != x) return false;\\n            return true;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "     public boolean isPalindrome(int x) {\\n            if (x < 0) return false;\\n            int ans = 0;\\n            int num = x;\\n            while ( num > 0) {\\n                ans = ans * 10 + num % 10;\\n                num = num / 10;\\n            }\\n            if (ans != x) return false;\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 5478,
                "title": "my-72-ms-c-solution",
                "content": "Just remember two x==y checks needed to deal with odd and even digits cases.\\n\\n    class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(!x) return true;\\n            if(x<0 || 0 == x%10 ) return false;\\n            int y =0;\\n            while(x>y)\\n            {\\n                y = y*10 + x%10;\\n                if(x==y) return true; // to deal with odd digits case, e.g. 232\\n                x = x/10; \\n            }\\n            return x==y; // to deal with even digits case, e.g. 22\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(!x) return true;\\n            if(x<0 || 0 == x%10 ) return false;\\n            int y =0;\\n            while(x>y)\\n            {\\n                y = y*10 + x%10;\\n                if(x==y) return true; // to deal with odd digits case, e.g. 232\\n                x = x/10; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 5550,
                "title": "two-pointer-style-solution-walking-from-left-and-right-to-the-middle",
                "content": "I wanted to check if the number is a palindrome the same way you would check if a string is a palindrome, with a left pointer and right pointer that walk toward the middle. The only trick is finding the largest multiple of 10 smaller than x, for which I use the pow, floor, and log10 functions:\\n\\n    bool isPalindrome(int x) {\\n        if (x < 0) return false;\\n        \\n        int left = pow(10, floor(log10(x)));\\n        int right = 1;\\n        while (right < left) {\\n            if ((x / left - x / right) % 10 != 0) {\\n                return false;\\n            }\\n            right *= 10;\\n            left /= 10;\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "I wanted to check if the number is a palindrome the same way you would check if a string is a palindrome, with a left pointer and right pointer that walk toward the middle. The only trick is finding the largest multiple of 10 smaller than x, for which I use the pow, floor, and log10 functions:\\n\\n    bool isPalindrome(int x) {\\n        if (x < 0) return false;\\n        \\n        int left = pow(10, floor(log10(x)));\\n        int right = 1;\\n        while (right < left) {\\n            if ((x / left - x / right) % 10 != 0) {\\n                return false;\\n            }\\n            right *= 10;\\n            left /= 10;\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 5598,
                "title": "a-straightforward-log-n-ac-solution",
                "content": "    class Solution {\\n    public:\\n        bool isPalindrome(long long x) {\\n            if (x < 0) return false;\\n            long long d = 10, e = 10;\\n            while (x / d) d *= 10;\\n            while (d > e)\\n            {\\n                if ((x % d) / (d / 10) != (x % e) / (e / 10))\\n                    return false;\\n                d /= 10;\\n                e *= 10;\\n            }\\n            return true;\\n        }\\n    };\\n\\ncompare the highest digit and lowest digit in each iteration. should the local variable d and e be regarded as 'extra memory'?",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(long long x) {\\n            if (x < 0) return false;\\n            long long d = 10, e = 10;\\n            while (x / d) d *= 10;\\n            while (d > e)\\n            {\\n                if ((x % d) / (d / 10) != (x % e) / (e / 10))\\n                    return false;\\n                d /= 10;\\n                e *= 10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3871467,
                "title": "palindrome-without-using-convertation-to-str",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe hint was not to use convertation x to string , so I used tricks of division. \\n\\n# Approach\\nWe start from the latest digit of initial number and build reverted number. Then check is real number equals to reverted and returns the result. \\n\\n# Complexity\\n- Time complexity: O(n) \\n*where n is length of x , we just go through all numbers of initial x \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        reversed_number = 0\\n        number = x\\n        while x > 0:\\n            digit = x % 10\\n            x = x // 10\\n            reversed_number = reversed_number * 10 + digit\\n\\n        return number == reversed_number\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        reversed_number = 0\\n        number = x\\n        while x > 0:\\n            digit = x % 10\\n            x = x // 10\\n            reversed_number = reversed_number * 10 + digit\\n\\n        return number == reversed_number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278892,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       int y=x;\\n        if(x<0)\\n            return false;\\n            \\n        long int temp=0;\\n        while(y)\\n        {\\n            temp=temp*10+y%10;\\n            y/=10;\\n        }\\n        if(temp==x)\\n            return true;\\n        else\\n            return false;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       int y=x;\\n        if(x<0)\\n            return false;\\n            \\n        long int temp=0;\\n        while(y)\\n        {\\n            temp=temp*10+y%10;\\n            y/=10;\\n        }\\n        if(temp==x)\\n            return true;\\n        else\\n            return false;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954045,
                "title": "5-line-c-code-beats-100",
                "content": "//-------------> \\uD83D\\uDC7B Pls Upvote if it is helpful for You \\uD83D\\uDC7B <--------------//\\n\\n\\n# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n - TypeCasting Integer  to String using \\n - to_string()  function\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s=to_string(x);      // convert int to string \\n        string s1=s;               \\n        reverse(s.begin(),s.end()); // reverse the string \\n        if(s==s1) return 1;        // check they are equal or not  \\n        return 0;\\n    }\\n};\\n```\\n---\\n\\n- \\uD83D\\uDC7B IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION\\uD83D\\uDC7B*\\n![image.png](https://assets.leetcode.com/users/images/27dc1e17-5bbd-4e60-a870-bb322c16992f_1678436893.0397103.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s=to_string(x);      // convert int to string \\n        string s1=s;               \\n        reverse(s.begin(),s.end()); // reverse the string \\n        if(s==s1) return 1;        // check they are equal or not  \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297591,
                "title": "simple-java-code-faster-than-99-97-and-89-47-in-memory",
                "content": "please upvote if u find it usefull :)\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n      int num = 0,temp = x;\\n      while(x>0){\\n              num = num*10 + x%10;\\n              x = x/10;\\n            }\\n      if(temp == num){\\n        return true;\\n      }\\n      return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n      int num = 0,temp = x;\\n      while(x>0){\\n              num = num*10 + x%10;\\n              x = x/10;\\n            }\\n      if(temp == num){\\n        return true;\\n      }\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878340,
                "title": "best-java-solution",
                "content": "Best JAVA Solution\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n        \\n        int sub = x;\\n        int reversed = 0;\\n        while (sub != 0) {\\n            reversed = reversed * 10 + sub % 10;\\n            sub /= 10;\\n        }\\n        \\n        return x == reversed;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n        \\n        int sub = x;\\n        int reversed = 0;\\n        while (sub != 0) {\\n            reversed = reversed * 10 + sub % 10;\\n            sub /= 10;\\n        }\\n        \\n        return x == reversed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5507,
                "title": "my-simplest-ac-code-with-o-zero-space",
                "content": "    #define order(x) ((int)pow(10, (int)log10(x)))\\n    \\n    bool isPalindrome(int x) {\\n    \\t// non palindrome number for negative numbers\\n    \\tif (x < 0)\\n    \\t\\treturn false;\\n    \\n    \\twhile (x) {\\n    \\t\\t// non palindrome if the most significant digit\\n    \\t\\t// doesn't match the least one\\n    \\t\\tif (x % 10 != x / order(x))\\n    \\t\\t\\treturn false;\\n    \\n    \\t\\t// remove both the most and the least digit\\n    \\t\\t// if the second most significant digit is NOT 0,\\n    \\t\\tif (order(x) / 10 == order(x - x % 10 * order(x)))\\n    \\t\\t\\tx = (x - x % 10 * order(x)) / 10;\\n    \\n    \\t\\t// it's 0, then make sure the second least is also 0\\n    \\t\\t// non palindrome if otherwise\\n    \\t\\telse if (x / 10 % 10 != 0)\\n    \\t\\t\\treturn false;\\n    \\n    \\t\\t// now the second most and the second least are both 0,\\n    \\t\\t// remove the most and the least, and change the two 0's to 1's\\n    \\t\\telse\\n    \\t\\t\\tx = (x - x % 10 * order(x) + order(x) / 10) / 10 + 1;\\n    \\t}\\n    \\n    \\treturn true;\\n    }",
                "solutionTags": [],
                "code": "    #define order(x) ((int)pow(10, (int)log10(x)))\\n    \\n    bool isPalindrome(int x) {\\n    \\t// non palindrome number for negative numbers\\n    \\tif (x < 0)\\n    \\t\\treturn false;\\n    \\n    \\twhile (x) {\\n    \\t\\t// non palindrome if the most significant digit\\n    \\t\\t// doesn't match the least one\\n    \\t\\tif (x % 10 != x / order(x))\\n    \\t\\t\\treturn false;\\n    \\n    \\t\\t// remove both the most and the least digit\\n    \\t\\t// if the second most significant digit is NOT 0,\\n    \\t\\tif (order(x) / 10 == order(x - x % 10 * order(x)))\\n    \\t\\t\\tx = (x - x % 10 * order(x)) / 10;\\n    \\n    \\t\\t// it's 0, then make sure the second least is also 0\\n    \\t\\t// non palindrome if otherwise\\n    \\t\\telse if (x / 10 % 10 != 0)\\n    \\t\\t\\treturn false;\\n    \\n    \\t\\t// now the second most and the second least are both 0,\\n    \\t\\t// remove the most and the least, and change the two 0's to 1's\\n    \\t\\telse\\n    \\t\\t\\tx = (x - x % 10 * order(x) + order(x) / 10) / 10 + 1;\\n    \\t}\\n    \\n    \\treturn true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4082932,
                "title": "video-visualization-using-modulo-and-floor-division",
                "content": "https://www.youtube.com/watch?v=OlTk8wM48ww\\n\\nThe idea here is that we don\\'t need to reverse all the digits, only <i>half</i> the digits.  The first line checks some edge cases, and returns False immediately if the number is negative or ends with a 0 (with the exception of the number 0 itself).  The loop then uses the modulo and floor division operators to reverse the digits and transfer them to the `half` variable.\\n\\nOnce the halfway point is reached, we return True if the two halves are equal to each other.  If the number originally had an <i>odd</i> number of digits, then the two halves will be off by 1 digit, so we also remove that digit using floor division, then compare for equality.\\n# Code\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n\\n        half = 0\\n        while x > half:\\n            half = (half * 10) + (x % 10)\\n            x = x // 10\\n\\n        return x == half or x == half // 10\\n```\\n\\n# Alternate solution\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        return x == x[::-1]\\n```\\nAlternate solution: turn the number into a string, reverse it, and see if they\\'re equal.  This is the simplest solution, but the question does challenge us to solve it <i>without</i> turning the number into a string.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n\\n        half = 0\\n        while x > half:\\n            half = (half * 10) + (x % 10)\\n            x = x // 10\\n\\n        return x == half or x == half // 10\\n```\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        return x == x[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230465,
                "title": "faster-than-96-of-java-solutions-java",
                "content": "# Approach\\nStore the value of x in an integer, then reverse the original number using a while loop, where you will keep using modulous to get the remainder and keep adding that to the rev int initilized at the beginning.\\nLastly, check if the rev and the original are equal and or original >=0, return true else false.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev =0;\\n        int original = x;\\n        while(x !=0){\\n            int num = x % 10;\\n            rev = rev *10 + num;\\n            x = x/10;\\n\\n        }\\n\\n        if(original >= 0 && original == rev){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev =0;\\n        int original = x;\\n        while(x !=0){\\n            int num = x % 10;\\n            rev = rev *10 + num;\\n            x = x/10;\\n\\n        }\\n\\n        if(original >= 0 && original == rev){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873538,
                "title": "one-line-solution-kotlin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun isPalindrome(x: Int): Boolean {\\n\\n   return   x.toString().reversed() ==  x.toString()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isPalindrome(x: Int): Boolean {\\n\\n   return   x.toString().reversed() ==  x.toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744506,
                "title": "two-pointers",
                "content": "```\\nbool isPalindrome(int x) {\\n    if (x < 0) \\n        return false;\\n    if (x == 0) // to avoid log10(0)\\n        return true;\\n\\n    int n = log10(x) + 1; // compute -> n digits\\n    int times = n / 2; // we need to compare n / 2 times (move two pointers at one move)\\n    int l = (int) pow(10, n - 1), r = 1;\\n    while (times--) { \\n        if ((x / l) % 10 != (x / r) % 10) { // if (left digit != right digit)\\n            return false;\\n        }\\n        l /= 10;\\n        r *= 10;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPalindrome(int x) {\\n    if (x < 0) \\n        return false;\\n    if (x == 0) // to avoid log10(0)\\n        return true;\\n\\n    int n = log10(x) + 1; // compute -> n digits\\n    int times = n / 2; // we need to compare n / 2 times (move two pointers at one move)\\n    int l = (int) pow(10, n - 1), r = 1;\\n    while (times--) { \\n        if ((x / l) % 10 != (x / r) % 10) { // if (left digit != right digit)\\n            return false;\\n        }\\n        l /= 10;\\n        r *= 10;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683670,
                "title": "code-along-with-explaination-faster-then-81",
                "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n \\n//         frst convert the number into string\\n        string str=to_string(x);\\n//         using builtin reverse function find reverse\\n        reverse(str.begin(),str.end());\\n//         convert original value of int into string and compare it with rev\\n        bool flag=to_string(x)==str;\\n        return flag;\\n            \\n    }\\n};\\n**upvote if u found it helpful**",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n \\n//         frst convert the number into string\\n        string str=to_string(x);\\n//         using builtin reverse function find reverse\\n        reverse(str.begin(),str.end());\\n//         convert original value of int into string and compare it with rev\\n        bool flag=to_string(x)==str;\\n        return flag;\\n            \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2329273,
                "title": "c-java-python3-javascript-solution-90-99-faster",
                "content": "See the code : \\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/5afaf588-9ac5-4ce7-ba46-bfbddb3e7586_1658709281.7354767.png)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "See the code : \\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/5afaf588-9ac5-4ce7-ba46-bfbddb3e7586_1658709281.7354767.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1334247,
                "title": "two-c-solutions-competitive-other",
                "content": "Competative Solution\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        if(s == string(s.rbegin(), s.rend())) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n};\\n```\\n\\nOther Solution\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int rev = 0; \\n       int digit = 0, temp = x;\\n        if(x<0) {\\n            return false;\\n        } else {\\n            while(x != 0) {\\n            digit = x % 10;\\n            rev = rev * 10 + digit;\\n            x = x/10;\\n        }\\n        }      \\n        if(rev == temp) {\\n            return true;\\n        } else {\\n            return false;\\n        }     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        if(s == string(s.rbegin(), s.rend())) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int rev = 0; \\n       int digit = 0, temp = x;\\n        if(x<0) {\\n            return false;\\n        } else {\\n            while(x != 0) {\\n            digit = x % 10;\\n            rev = rev * 10 + digit;\\n            x = x/10;\\n        }\\n        }      \\n        if(rev == temp) {\\n            return true;\\n        } else {\\n            return false;\\n        }     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986012,
                "title": "simple-c-solution",
                "content": "# Simple C++ Solution\\n\\n``` CPP\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0) return false;\\n        long long y = 0, t = x;\\n        while (t != 0) {\\n    \\t    y = y * 10 + t % 10;\\n    \\t    t /= 10;\\n\\t    }\\n\\t    return x == y;\\n    }\\n};\\n```\\n\\n>- Just reverse the numbers of x to y and compare them.\\n>- You would not to care the overflow,  cause I used \"long long\".",
                "solutionTags": [],
                "code": "``` CPP\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0) return false;\\n        long long y = 0, t = x;\\n        while (t != 0) {\\n    \\t    y = y * 10 + t % 10;\\n    \\t    t /= 10;\\n\\t    }\\n\\t    return x == y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771404,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307258,
                "title": "9-php-string-and-math-solutions",
                "content": "The string-based solution looks faster than the math-based solution.\\n\\n> Runtime: **16 ms**, faster than *99.55%* of PHP online submissions\\n> Memory Usage: **14.9 MB**, less than *32.64%* of PHP online submissions\\n\\n```php\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer $x\\n     * @return Boolean\\n     */\\n    function isPalindrome($x)\\n    {\\n        return (string)$x === strrev($x);\\n    }\\n}\\n```\\n\\n> Runtime: **36 ms**, faster than *80.98%* of PHP online submissions\\n> Memory Usage: **14.9 MB**, less than *27.78%* of PHP online submissions\\n\\n```php\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer $x\\n     * @return Boolean\\n     */\\n    function isPalindrome($x)\\n    {\\n        if ($r = 0 === $x % 10 && $x !== 0 || $x < 0) return false;\\n        while ($r < $x) list($r, $x) = [$r * 10 + $x % 10, (int)($x / 10)];\\n        return $x === $r || $x === (int)($r / 10);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Math",
                    "String"
                ],
                "code": "```php\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer $x\\n     * @return Boolean\\n     */\\n    function isPalindrome($x)\\n    {\\n        return (string)$x === strrev($x);\\n    }\\n}\\n```\n```php\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer $x\\n     * @return Boolean\\n     */\\n    function isPalindrome($x)\\n    {\\n        if ($r = 0 === $x % 10 && $x !== 0 || $x < 0) return false;\\n        while ($r < $x) list($r, $x) = [$r * 10 + $x % 10, (int)($x / 10)];\\n        return $x === $r || $x === (int)($r / 10);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258209,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        x.to_string()==x.to_string().chars().rev().collect::<String>()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        x.to_string()==x.to_string().chars().rev().collect::<String>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164574,
                "title": "can-you-please-explain-this-bit-of-code-used-for-fast-io",
                "content": "I understand this is used for fast input output using cin at speeds comparable to scanf.\\n\\n But I don\\'t understand what is this function looking thing inside which they have wrapped \\nthe fast IO code  ? It has [] of array, () of functions and also a return type of function\\n\\n```\\nstatic const auto _____ = []()\\n{\\n    // fast IO code : this I understand\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n```\\n\\nCan you kindly explain, what is this feature of C++ ?\\n``` \\nstatic const auto _____ = [] ()\\n{\\n    // fast IO code\\n}(); \\n```",
                "solutionTags": [],
                "code": "```\\nstatic const auto _____ = []()\\n{\\n    // fast IO code : this I understand\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n```\n``` \\nstatic const auto _____ = [] ()\\n{\\n    // fast IO code\\n}(); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5266,
                "title": "32ms-c-language-solution",
                "content": "    bool isPalindrome(int x) {\\n        if(x < 0) return false;\\n        if(x < 10) return true;\\n        int y = 0;\\n        int tmp = x;\\n        while(tmp)\\n        {\\n            y = y * 10 + (tmp % 10);\\n            tmp /= 10;\\n        }\\n        \\n        return x == y;\\n    }",
                "solutionTags": [],
                "code": "    bool isPalindrome(int x) {\\n        if(x < 0) return false;\\n        if(x < 10) return true;\\n        int y = 0;\\n        int tmp = x;\\n        while(tmp)\\n        {\\n            y = y * 10 + (tmp % 10);\\n            tmp /= 10;\\n        }\\n        \\n        return x == y;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3611963,
                "title": "c-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n            int num = x;\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n            unsigned int rev=0;\\n            while(x!=0){\\n                 int rem = x % 10;\\n                 rev=rev*10 + rem ;\\n                 x = x/10;\\n            }\\n            if(num==rev){\\n                 return true;\\n            }\\n        \\n            else{\\n                 return false ;\\n            } \\n        }   \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n            int num = x;\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n            unsigned int rev=0;\\n            while(x!=0){\\n                 int rem = x % 10;\\n                 rev=rev*10 + rem ;\\n                 x = x/10;\\n            }\\n            if(num==rev){\\n                 return true;\\n            }\\n        \\n            else{\\n                 return false ;\\n            } \\n        }   \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059925,
                "title": "one-liner-in-swift",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func isPalindrome(_ x: Int) -> Bool {\\n        return String(String(x).reversed()) == String(x)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isPalindrome(_ x: Int) -> Bool {\\n        return String(String(x).reversed()) == String(x)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739236,
                "title": "c-two-pointers-math-with-comments",
                "content": "I\\'d love to stick to two pointers technique to check if the integer is palindrome like we do with strings :)\\nInstead of converting the integer to a string, some math can do we the favor.\\n```cpp\\nbool isPalindrome(int x) {\\n    if (x < 0) \\n        return false;\\n    if (x == 0) // to avoid log10(0)\\n        return true;\\n\\n    int n = log10(x) + 1; // compute -> n digits\\n    int times = n / 2; // we need to compare n / 2 times (move two pointers at one move)\\n    int l = (int) pow(10, n - 1), r = 1;\\n    while (times--) { \\n        if ((x / l) % 10 != (x / r) % 10) { // if (left digit != right digit)\\n            return false;\\n        }\\n        l /= 10;\\n        r *= 10;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nbool isPalindrome(int x) {\\n    if (x < 0) \\n        return false;\\n    if (x == 0) // to avoid log10(0)\\n        return true;\\n\\n    int n = log10(x) + 1; // compute -> n digits\\n    int times = n / 2; // we need to compare n / 2 times (move two pointers at one move)\\n    int l = (int) pow(10, n - 1), r = 1;\\n    while (times--) { \\n        if ((x / l) % 10 != (x / r) % 10) { // if (left digit != right digit)\\n            return false;\\n        }\\n        l /= 10;\\n        r *= 10;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711457,
                "title": "palindrome-number-using-recursion",
                "content": "Different and simple approach using Recursion, if useful please upvote\\n```\\nclass Solution {\\npublic:\\n    \\n    bool Check_Palindrome(int x, int left)\\n    {\\n\\t\\t//Convert the Integer to String\\n        stringstream ss;\\n        ss<<x;\\n        string s;\\n        ss>>s;\\n\\t\\t\\n\\t\\t//Since we use the two pointer concept using a single pointer (i.e left)\\n        if(left > s.length()/2)\\n        {\\n            return true;\\n        }\\n        \\n\\t\\t//Compare the String from Start and End(char by char)\\n        if(s[left] != s[s.length()-left-1])\\n        {\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t//Keep repeating till any two of the base conditions execute\\n        return Check_Palindrome(x, left+1);\\n    }\\n    \\n    bool isPalindrome(int x)\\n    {\\n        int start = 0;\\n\\t\\t\\n\\t\\t//If not palindrome return false else true\\n        if(!Check_Palindrome(x, start))\\n        {\\n            return false;\\n        }\\n        return true;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool Check_Palindrome(int x, int left)\\n    {\\n\\t\\t//Convert the Integer to String\\n        stringstream ss;\\n        ss<<x;\\n        string s;\\n        ss>>s;\\n\\t\\t\\n\\t\\t//Since we use the two pointer concept using a single pointer (i.e left)\\n        if(left > s.length()/2)\\n        {\\n            return true;\\n        }\\n        \\n\\t\\t//Compare the String from Start and End(char by char)\\n        if(s[left] != s[s.length()-left-1])\\n        {\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t//Keep repeating till any two of the base conditions execute\\n        return Check_Palindrome(x, left+1);\\n    }\\n    \\n    bool isPalindrome(int x)\\n    {\\n        int start = 0;\\n\\t\\t\\n\\t\\t//If not palindrome return false else true\\n        if(!Check_Palindrome(x, start))\\n        {\\n            return false;\\n        }\\n        return true;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514381,
                "title": "c-faster-than-80-60-easy-to-understand",
                "content": "Palindrome Number -\\n\\n```\\nclass Solution \\n{\\npublic:\\n    bool isPalindrome(int x) \\n    {\\n       long int digit,reverse=0;\\n       int temp=x;\\n       while(x>0)\\n       {\\n           digit=x%10;\\n           reverse=(reverse*10)+digit;\\n           x=x/10;\\n       }\\n      if(temp==reverse)\\n      {return true;}\\n      else\\n      {return false;}  \\n    }\\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isPalindrome(int x) \\n    {\\n       long int digit,reverse=0;\\n       int temp=x;\\n       while(x>0)\\n       {\\n           digit=x%10;\\n           reverse=(reverse*10)+digit;\\n           x=x/10;\\n       }\\n      if(temp==reverse)\\n      {return true;}\\n      else\\n      {return false;}  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480907,
                "title": "javascript-easy-to-read-solution",
                "content": "tried to go for something simple and clear. \\ntime & space: 98.33% & 96.55%\\n\\n```\\nvar isPalindrome = function(x) {\\n   const original = x\\n   let reversed = 0\\n   \\n   if(x < 10 && x >= 0) {\\n       return true\\n   }\\n    \\n    if(x % 10 === 0 || x < 0) {\\n       return false\\n   }\\n    \\n    while(x !== 0 ) {\\n        reversed = reversed * 10 + x % 10\\n        x = Math.trunc(x/10)\\n    }\\n    \\n    return !(original - reversed)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(x) {\\n   const original = x\\n   let reversed = 0\\n   \\n   if(x < 10 && x >= 0) {\\n       return true\\n   }\\n    \\n    if(x % 10 === 0 || x < 0) {\\n       return false\\n   }\\n    \\n    while(x !== 0 ) {\\n        reversed = reversed * 10 + x % 10\\n        x = Math.trunc(x/10)\\n    }\\n    \\n    return !(original - reversed)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5274,
                "title": "python-in-one-line",
                "content": "    class Solution(object):\\n        def isPalindrome(self, x):\\n            return x >= 0 and x == int(str(x)[::-1])",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def isPalindrome(self, x):\\n            return x >= 0 and x == int(str(x)[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 5427,
                "title": "very-simple-java-solution",
                "content": "  \\n\\n    public boolean isPalindrome(int x) {\\n            int xx = x;\\n            int reversed = 0;\\n            \\n            while(xx > 0) {\\n                reversed = reversed * 10 + xx % 10;\\n                xx /= 10;\\n            }\\n            return x == reversed;\\n        }",
                "solutionTags": [],
                "code": "  \\n\\n    public boolean isPalindrome(int x) {\\n            int xx = x;\\n            int reversed = 0;\\n            \\n            while(xx > 0) {\\n                reversed = reversed * 10 + xx % 10;\\n                xx /= 10;\\n            }\\n            return x == reversed;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3944219,
                "title": "putta-easy-solution-c-beats-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        double ans = 0;\\n        int temp = x;\\n\\n        while(x>0){\\n            ans = ans*10 + x%10;\\n            x = x/10;\\n        }\\n        return temp == ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        double ans = 0;\\n        int temp = x;\\n\\n        while(x>0){\\n            ans = ans*10 + x%10;\\n            x = x/10;\\n        }\\n        return temp == ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280798,
                "title": "python3-one-liner-easiest-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- convert integer x to string.\\n- now return true if reverse of x and original order is same else false.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270193,
                "title": "typescript-int-solution",
                "content": "```\\nfunction isPalindrome(x: number): boolean {\\n    let reverseX: number\\n    const tempReverseString = x.toString().split(\"\").reverse().join(\\'\\')\\n    reverseX = parseInt(tempReverseString)\\n\\n    return reverseX === x\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isPalindrome(x: number): boolean {\\n    let reverseX: number\\n    const tempReverseString = x.toString().split(\"\").reverse().join(\\'\\')\\n    reverseX = parseInt(tempReverseString)\\n\\n    return reverseX === x\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3053140,
                "title": "converting-to-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    x = x.toString();\\n    let k = x.length;\\n    for (let i = 0; i < k; i++) {\\n        if (x[i] != x[k - 1]) {\\n            return false;\\n        }\\n        k--;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    x = x.toString();\\n    let k = x.length;\\n    for (let i = 0; i < k; i++) {\\n        if (x[i] != x[k - 1]) {\\n            return false;\\n        }\\n        k--;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3005334,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005289,
                "title": "op",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332990,
                "title": "one-line-python-solution",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```\\n\\nplease upvote if you like",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311737,
                "title": "python3-one-liner-solution",
                "content": "In this approach we are converting the interger into a string so that we can reverse the string using slicing method. Then we are comparing the original string to a reversed string and returning the boolean value.\\n\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003259,
                "title": "python-32ms-beats-99-79-two-pointers-simple-with-explanation",
                "content": "We have two pointers, `i` and `j`, pointing at the start and end of the number respectively:\\n\\n1023201\\ni--> <--j\\n\\nEach iteration we move `i` to the left and `j` to the right, until they are on the same number (until `i >= j`). If the number `i` is pointing at is **not** equal to the number `j` is pointing at, then the number is not a palindrome. Otherwise, after the loop finishes, return `True`.\\n\\nThis is a better solution than reversing the string and comparing the two because not only do you use extra space, but comparing 2 strings is a linear operation, while iterating `i` and `j` simulaneously compare each side of the number.\\n\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        nums = str(x)\\n        \\n        i = 0\\n        j = len(nums) - 1\\n        \\n        while i <= j:\\n            if nums[i] != nums[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n```\\n\\n**If you liked this, please upvote to support me!**\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        nums = str(x)\\n        \\n        i = 0\\n        j = len(nums) - 1\\n        \\n        while i <= j:\\n            if nums[i] != nums[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980816,
                "title": "java-c-python-javascript-kotlin-4lines-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "<iframe src=\"https://leetcode.com/playground/V3ZoeKhz/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/V3ZoeKhz/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful!***",
                "codeTag": "Unknown"
            },
            {
                "id": 1871376,
                "title": "c-6-line-simple-code-easy-to-understand-tc-o-log-n-sc-o-1",
                "content": "Please Upvote if it helps\\u2B06\\uFE0F\\n```\\nbool isPalindrome(int x) {\\n        if(x<0) return 0;\\n        long long int temp=x,rev=0;\\n        while(temp){\\n            rev=rev*10+temp%10;\\n            temp/=10;\\n        }\\n        return x==rev;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Please Upvote if it helps\\u2B06\\uFE0F\\n```\\nbool isPalindrome(int x) {\\n        if(x<0) return 0;\\n        long long int temp=x,rev=0;\\n        while(temp){\\n            rev=rev*10+temp%10;\\n            temp/=10;\\n        }\\n        return x==rev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 827129,
                "title": "0-ms-faster-than-100-00-c-solution",
                "content": "bool isPalindrome(int x) {\\n\\tbool arr[2] = { true, false };\\n\\tint revertedNumber = 0;\\n\\tint tmp = x;\\n\\n\\tif (x < 0 || (x % 10 == 0 && x != 0)) \\n\\t\\treturn false;\\n\\n\\twhile (x > revertedNumber) {\\n\\t\\trevertedNumber = revertedNumber * 10 + x % 10;\\n\\t\\tx /= 10;\\n\\t}\\n\\t\\n\\tif (x == revertedNumber || x == revertedNumber / 10)\\n\\t\\treturn true;\\n\\telse\\n\\t\\treturn false;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "bool isPalindrome(int x) {\\n\\tbool arr[2] = { true, false };\\n\\tint revertedNumber = 0;\\n\\tint tmp = x;\\n\\n\\tif (x < 0 || (x % 10 == 0 && x != 0)) \\n\\t\\treturn false;\\n\\n\\twhile (x > revertedNumber) {\\n\\t\\trevertedNumber = revertedNumber * 10 + x % 10;\\n\\t\\tx /= 10;\\n\\t}\\n\\t\\n\\tif (x == revertedNumber || x == revertedNumber / 10)\\n\\t\\treturn true;\\n\\telse\\n\\t\\treturn false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 495963,
                "title": "1-line-kotlin-solution",
                "content": "```kotlin\\nclass Solution {\\n    fun isPalindrome(x: Int): Boolean =\\n        x.toString().let { it == it.reversed() }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun isPalindrome(x: Int): Boolean =\\n        x.toString().let { it == it.reversed() }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333683,
                "title": "rust-0ms-4ms",
                "content": "![image](https://assets.leetcode.com/users/obliquemotion/image_1563649353.png)\\n\\n\\n```rust\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        if x < 0 {\\n            return false;\\n        }\\n        let digit_count = 1 + (x as f32).log10() as u32;\\n        let half = (digit_count / 2) as usize;\\n        let digits = (0..digit_count).map(|exp| x / 10_i32.pow(exp) % 10);\\n        digits\\n            .clone()\\n            .take(half)\\n            .zip(digits.rev().take(half))\\n            .all(|(lhs, rhs)| lhs == rhs)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        if x < 0 {\\n            return false;\\n        }\\n        let digit_count = 1 + (x as f32).log10() as u32;\\n        let half = (digit_count / 2) as usize;\\n        let digits = (0..digit_count).map(|exp| x / 10_i32.pow(exp) % 10);\\n        digits\\n            .clone()\\n            .take(half)\\n            .zip(digits.rev().take(half))\\n            .all(|(lhs, rhs)| lhs == rhs)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299402,
                "title": "go",
                "content": "```\\nfunc isPalindrome(x int) bool {\\n    s := strconv.Itoa(x)\\n    r := []rune(s)\\n    for i, j := 0, len(r) - 1; i < j; i, j = i + 1, j - 1 {\\n        if r[i] != r[j] {return false}\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isPalindrome(x int) bool {\\n    s := strconv.Itoa(x)\\n    r := []rune(s)\\n    for i, j := 0, len(r) - 1; i < j; i, j = i + 1, j - 1 {\\n        if r[i] != r[j] {return false}\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278450,
                "title": "faster-than-100-of-python-submissions-in-one-line",
                "content": "```python\\ndef isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 5124,
                "title": "javascript-two-pointers-solution",
                "content": "```\\nvar isPalindrome = function(x) {\\n    if(x < 0) return false;\\n    x = x.toString()\\n    var i = 0;\\n    var j = x.length - 1;\\n    while(i < j){\\n        if(x[i] !== x[j]) return false;\\n        i++;\\n        j--;\\n    }\\n    return true;\\n};",
                "solutionTags": [],
                "code": "```\\nvar isPalindrome = function(x) {\\n    if(x < 0) return false;\\n    x = x.toString()\\n    var i = 0;\\n    var j = x.length - 1;\\n    while(i < j){\\n        if(x[i] !== x[j]) return false;\\n        i++;\\n        j--;\\n    }\\n    return true;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 5131,
                "title": "3-line-c-solution",
                "content": "Not the fastest or smartest of course, just trying to make the codes shorter.\\n```\\nlong long t = x, r = 0;\\nwhile (t) r = r * 10 + t % 10, t /= 10;\\nreturn x >= 0 && r == x;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long t = x, r = 0;\\nwhile (t) r = r * 10 + t % 10, t /= 10;\\nreturn x >= 0 && r == x;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5281,
                "title": "golang-58ms-concise-solution",
                "content": "Please let me know if there is room to optimize this code.\\n\\n```\\nfunc isPalindrome(x int) bool {\\n    if x < 0 {\\n        return false\\n    } else if x <= 9 {\\n        return true\\n    } else if x % 10 == 0 {\\n        return false\\n    }\\n    \\n    var y int\\n    for x > y {\\n        r := x % 10\\n        x = x / 10\\n        y = y * 10 + r\\n        \\n        if x == y || x / 10 == y {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPalindrome(x int) bool {\\n    if x < 0 {\\n        return false\\n    } else if x <= 9 {\\n        return true\\n    } else if x % 10 == 0 {\\n        return false\\n    }\\n    \\n    var y int\\n    for x > y {\\n        r := x % 10\\n        x = x / 10\\n        y = y * 10 + r\\n        \\n        if x == y || x / 10 == y {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5411,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if (x < 0) return false;\\n            if (x < 10) return true;\\n            \\n            int high = 0, low = 0, weight = 1;\\n            \\n            while (x / weight > 9)\\n                weight *= 10;\\n            \\n            while (x > 0)\\n            {\\n                high = x / weight;\\n                low = x % 10;\\n                if (low != high)\\n                    return false;\\n                //x -= (high * weight);\\n                x %= weight;\\n                x /= 10;\\n                weight /= 100;\\n            }\\n            \\n            return true;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if (x < 0) return false;\\n            if (x < 10) return true;\\n            \\n            int high = 0, low = 0, weight = 1;\\n            \\n            while (x / weight > 9)\\n                weight *= 10;\\n            \\n            while (x > 0)\\n            {\\n                high = x / weight;\\n                low = x % 10;\\n                if (low != high)\\n                    return false;\\n                //x -= (high * weight);\\n                x %= weight;\\n                x /= 10;\\n                weight /= 100;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3726660,
                "title": "c-java-python3-solutions-90-99-faster",
                "content": "### C#,Java,Python3 different solutions with explanation\\n**\\u2B50[zyrastory.com - LeetCode #9 Solutions](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50**\\n\\n##### **Example : C# Code ( \\u2B06You can also find other languages  in the post )**\\nsolution1 - reverse the string and compare\\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string first = x.ToString();             //turn to string (easy to reverse)\\n        char[] charArr = first.ToCharArray();   //the original target\\n        char[] reverseArr = first.ToCharArray();   \\n\\n        Array.Reverse(reverseArr );                 \\n     \\n        return charArr.SequenceEqual(reverseArr); //compare two array\\n    }\\n}\\n```\\n\\n\\u2B50solution2\\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string k = x.ToString();        \\n        \\n        for(int i=0;i<k.Length/2;i++)   \\n        {\\n            if(k[i] != k[k.Length-1-i]) \\n            {\\n                return false;           // if any char not the same, return false\\n            }\\n        }\\n        return true;                    \\n    }\\n}\\n```\\n---\\n\\n#### **Java Solution**\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String k = String.valueOf(x);\\n      \\n        for(int i=0;i<k.length()/2;i++)\\n        {\\n            if(k.charAt(i) != k.charAt(k.length()-1-i))\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n---\\n#### **Python3 Solution**\\nsolution1\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)[::-1] == str(x);\\n```\\n\\nsolution2\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xx = str(x);\\n        ll = int(len(xx)/2);\\n        \\n        for i in range(ll):\\n            if(xx[i] != xx[-i-1]):\\n                return False;\\n        return True;\\n```\\n---\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know (leave comment or messenger me).\\n\\n**Thanks!**\\n\\nYou can find out other LeetCode problems solution here\\n**\\uD83E\\uDDE1[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string first = x.ToString();             //turn to string (easy to reverse)\\n        char[] charArr = first.ToCharArray();   //the original target\\n        char[] reverseArr = first.ToCharArray();   \\n\\n        Array.Reverse(reverseArr );                 \\n     \\n        return charArr.SequenceEqual(reverseArr); //compare two array\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string k = x.ToString();        \\n        \\n        for(int i=0;i<k.Length/2;i++)   \\n        {\\n            if(k[i] != k[k.Length-1-i]) \\n            {\\n                return false;           // if any char not the same, return false\\n            }\\n        }\\n        return true;                    \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String k = String.valueOf(x);\\n      \\n        for(int i=0;i<k.length()/2;i++)\\n        {\\n            if(k.charAt(i) != k.charAt(k.length()-1-i))\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)[::-1] == str(x);\\n```\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xx = str(x);\\n        ll = int(len(xx)/2);\\n        \\n        for i in range(ll):\\n            if(xx[i] != xx[-i-1]):\\n                return False;\\n        return True;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509462,
                "title": "js-palindrome-super-fast-more-95-with-explain",
                "content": "# Intuition\\nMy way to determine if a number is a palindrome is to reverse the number and then compare it to the original. If they are the same, then it is a palindrome.\\n\\n# Approach\\nThe approach we are taking here is to construct the reverse of the given number and then compare it to the original number.\\n\\n1. We start by checking if the number is less than 0 or if it ends with 0 (but is not 0 itself). If either of these conditions is true, the number cannot be a palindrome and we return false.\\n\\n2. We initialize a variable reverse to 0. This will hold the reverse of our given number.\\n\\n3. We then enter a while loop where we continue to reverse the number. In each iteration, we multiply reverse by 10 (to shift the digits one place to the left) and add the last digit of our given number (which we get by num % 10).\\n\\n4. After adding the last digit of our given number to reverse, we remove the last digit from our given number by doing a floor division by 10 (num = Math.floor(num / 10)).\\n\\n5. We continue this process until our given number becomes 0, which means we have reversed all its digits.\\n\\n6. Finally, we compare the reversed number to the original number. If they are the same, we return true, indicating that the number is a palindrome. If they are different, we return false.\\n\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n     if (x < 0 || (x % 10 === 0 && x !== 0)) {\\n        return false;\\n    }\\n    let num = x;\\n    let reverse = 0;\\n    while (num > 0) {\\n        reverse = reverse * 10 + (num % 10);\\n        num = Math.floor(num / 10);\\n    }\\n    return x === reverse\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n     if (x < 0 || (x % 10 === 0 && x !== 0)) {\\n        return false;\\n    }\\n    let num = x;\\n    let reverse = 0;\\n    while (num > 0) {\\n        reverse = reverse * 10 + (num % 10);\\n        num = Math.floor(num / 10);\\n    }\\n    return x === reverse\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343410,
                "title": "91-beats-for-time-complexity-o-n-finding-palindrome",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBotirjon Shokirov\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are checking first and last element, if they are equal, we are going to check next numbers. if they are not equal, we are simply returning false as it will not be a Palindrome number.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n  const str = x.toString();\\n  let left = 0;\\n  let right = str.length - 1;\\n  \\n  while (left < right) {\\n    if (str.charAt(left) !== str.charAt(right)) {\\n      return false;\\n    }\\n    left++;\\n    right--;\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n  const str = x.toString();\\n  let left = 0;\\n  let right = str.length - 1;\\n  \\n  while (left < right) {\\n    if (str.charAt(left) !== str.charAt(right)) {\\n      return false;\\n    }\\n    left++;\\n    right--;\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3127339,
                "title": "rust-iterators",
                "content": "- Using rust iterators \\n- Reducing runtime by 1/2\\n# Code\\n```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        let x = x.to_string();\\n        let n = x.len();\\n        let x = x.chars().collect::<Vec<char>>();\\n        let head = x[..n/2].iter();\\n        let tail = x[n/2..].iter().rev();\\n        head.zip(tail).all(|(a, b)| a==b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "String"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        let x = x.to_string();\\n        let n = x.len();\\n        let x = x.chars().collect::<Vec<char>>();\\n        let head = x[..n/2].iter();\\n        let tail = x[n/2..].iter().rev();\\n        head.zip(tail).all(|(a, b)| a==b)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080053,
                "title": "brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        long  n=x;\\n        long ans=0;\\n        while(x>0)\\n        {\\n            ans+=x%10;\\n            ans = ans*10;\\n            x=x/10;\\n        }\\n        ans = ans/10;\\n        // System.out.println(ans);\\n        if(ans == n)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        long  n=x;\\n        long ans=0;\\n        while(x>0)\\n        {\\n            ans+=x%10;\\n            ans = ans*10;\\n            x=x/10;\\n        }\\n        ans = ans/10;\\n        // System.out.println(ans);\\n        if(ans == n)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005338,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003018,
                "title": "solution-using-array-no-string-conversion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMany of array operation are similar to string,thinking of the follow up question\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can store all digits of array in string and iterate till its mid in reverse direction and match it with the digits of x with the help of modulo operator(default method to access digits of a number)\\nFor ex-\\nI/P: 10\\nthen arraylist would have\\n     [0,1] (in forward index manner)\\nwhen using modulo operator to access digits again we will get 0 as first element that\\'s why we start traversing from back of the arraylist \\nand match the elements,here in first iteration\\n0(from digits) and 1(from arraylist) will be checked ,they don\\'t match hence we return false\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(digits of n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(digits of n)\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0) return false;\\n        ArrayList<Integer> list\\n            = new ArrayList<Integer>();\\n            int n=x;\\n\\n        while(n>0){\\n            list.add(n%10);\\n            n=n/10;\\n        }\\n        \\n        n=x;\\n        for(int i=list.size()-1;i>=list.size()/2;i--){\\n            if((n%10)!=list.get(i)){\\n                return false;\\n            }\\n            n=n/10;\\n           // System.out.println(list.get(i));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0) return false;\\n        ArrayList<Integer> list\\n            = new ArrayList<Integer>();\\n            int n=x;\\n\\n        while(n>0){\\n            list.add(n%10);\\n            n=n/10;\\n        }\\n        \\n        n=x;\\n        for(int i=list.size()-1;i>=list.size()/2;i--){\\n            if((n%10)!=list.get(i)){\\n                return false;\\n            }\\n            n=n/10;\\n           // System.out.println(list.get(i));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972970,
                "title": "python-no-string-conversion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        if x < 0:\\n            return False\\n        lis = []\\n        while x >= 10:\\n            lis.append(x % 10)\\n            x //= 10\\n        lis.append(x)\\n        for i in range(int(math.ceil(len(lis)/2))):\\n            if lis[i] != lis[len(lis)-i-1]:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        if x < 0:\\n            return False\\n        lis = []\\n        while x >= 10:\\n            lis.append(x % 10)\\n            x //= 10\\n        lis.append(x)\\n        for i in range(int(math.ceil(len(lis)/2))):\\n            if lis[i] != lis[len(lis)-i-1]:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658882,
                "title": "solving-it-without-using-string-in-javascript",
                "content": "**Step one : declare two varables , one for reverse number and one for original number**\\nsince we are going to use reverse algorithm, the original number is gonna change so we need a refrence to the original number to compare it to the reversed one.\\n\\n```javascript\\nlet num = x;\\nlet reverse = 0\\n```\\n\\n**Step two : reverse algorithm**\\nfirst of all if it\\'s negative number, it is not Palindrome because in one side we have a negative sign and not on the other side\\n lets see how we can reverse a number like 124  \\n so we have the `reverse` variable and it is set to 0 and we want to somehow get the **last digit** and add it to our variable.   \\n we can find the last digit of a number by diving it by 10 , and the reminder is our last digit (we can get reminder of a number using `%` operator)\\n ```\\n 124 / 10 = 12.4  (124 % 10 = 4) // 4 is the reminder\\n 321/10 = 32.1  (321 % 10 = 1)  // 1 is the reminder\\n ```\\n**awesome!** so now we know how to find the last digit and we add it to `reverse`\\nnow we need to find a way to remove the last digit so we can add another digit to our `reverse` variable\\n**but how?** when we divide our number by 10 , we get a **decimal point**. in the examples above we have `12.4` and `32.1`. if we remove those we end up with `12` and `32`  (in javascript we do it with `Math.floor()` method)\\n**what now?** now we divide the new number by 10 , and get the reminder, so lets do it\\n```\\nfirst step\\n124 / 10 = 12.4 // we get the 4 and add it to the reverse . remove the decimal point and we have 12\\nsecond step\\n12 / 10 = 1.2 // we get the 2  but we don\\'t add it to reverse! because we will get 6. to go one level up we multipy the reverse by 10 so 4 * 10 = 40 and then we add the 2 so we have 42 .\\n```\\nwe keep doing (aka `loop`) this untill when we remove the decimal point , we get 0 and that\\'s when we are done!\\n\\n**Step three : lets implement this**\\n```javascript\\n// first if number is negative we return false, meaning it\\'s not palindrome;\\nif(x < 0) return false;\\n// our variables\\nlet num = x;\\nlet reverse = 0;\\n\\n// we use a while . we keep going untill we get x = 0\\nwhile( x > 0) {\\n\\t// multiply reverse by 10 and add the reminder\\n\\treverse = reverse * 10 + ( x % 10 )\\n\\t\\n\\t// devide x by 10 and remove decimal point. if x === 0 then it exists the loop\\n\\tx = Math.floor(x / 10)\\n}\\n\\n// now we are out of the while loop and we have the reverse number\\n// lastly we compare the original number with the reverse. we use return and compare these two numbers\\n// this will return True ( if they are equal ) or false( if they are not )\\nreturn reverse === num;\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nlet num = x;\\nlet reverse = 0\\n```\n```\\n 124 / 10 = 12.4  (124 % 10 = 4) // 4 is the reminder\\n 321/10 = 32.1  (321 % 10 = 1)  // 1 is the reminder\\n ```\n```\\nfirst step\\n124 / 10 = 12.4 // we get the 4 and add it to the reverse . remove the decimal point and we have 12\\nsecond step\\n12 / 10 = 1.2 // we get the 2  but we don\\'t add it to reverse! because we will get 6. to go one level up we multipy the reverse by 10 so 4 * 10 = 40 and then we add the 2 so we have 42 .\\n```\n```javascript\\n// first if number is negative we return false, meaning it\\'s not palindrome;\\nif(x < 0) return false;\\n// our variables\\nlet num = x;\\nlet reverse = 0;\\n\\n// we use a while . we keep going untill we get x = 0\\nwhile( x > 0) {\\n\\t// multiply reverse by 10 and add the reminder\\n\\treverse = reverse * 10 + ( x % 10 )\\n\\t\\n\\t// devide x by 10 and remove decimal point. if x === 0 then it exists the loop\\n\\tx = Math.floor(x / 10)\\n}\\n\\n// now we are out of the while loop and we have the reverse number\\n// lastly we compare the original number with the reverse. we use return and compare these two numbers\\n// this will return True ( if they are equal ) or false( if they are not )\\nreturn reverse === num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458263,
                "title": "java-solution-easy-using-recursion",
                "content": "```\\nclass Solution {\\n    //finding reverse of the number using recursion\\n    int rev(int n,int s){\\n        if(n==0) return s;\\n        int sum=s*10+n%10;\\n        return rev(n/10,sum);\\n    }\\n    public boolean isPalindrome(int x) {\\n        if(x<0) return false;\\n        if(rev(x,0)==x) return true; \\n        \\n        //if the reverse of the number is\\n        //equal to the number returm true\\n        \\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //finding reverse of the number using recursion\\n    int rev(int n,int s){\\n        if(n==0) return s;\\n        int sum=s*10+n%10;\\n        return rev(n/10,sum);\\n    }\\n    public boolean isPalindrome(int x) {\\n        if(x<0) return false;\\n        if(rev(x,0)==x) return true; \\n        \\n        //if the reverse of the number is\\n        //equal to the number returm true\\n        \\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969553,
                "title": "typescript-strings-are-bad",
                "content": "Reverse number and compare.\\nNegatives filter out at first.\\nAvoid modulo operator to gain some perfornace points.\\n\\n```typescript\\nfunction isPalindrome(x: number): boolean {\\n    if (x < 0) return false;\\n    \\n    let x1 = 0;\\n    let div = x;\\n    while (div > 0) {\\n        const quotient = Math.floor(div / 10);\\n        const reminder = div - quotient * 10;\\n        div = quotient;\\n        x1 = x1 * 10 + reminder;\\n    }\\n    \\n    return x === x1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction isPalindrome(x: number): boolean {\\n    if (x < 0) return false;\\n    \\n    let x1 = 0;\\n    let div = x;\\n    while (div > 0) {\\n        const quotient = Math.floor(div / 10);\\n        const reminder = div - quotient * 10;\\n        div = quotient;\\n        x1 = x1 * 10 + reminder;\\n    }\\n    \\n    return x === x1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914722,
                "title": "simple-rust",
                "content": "```rust\\nfn is_palindrome(x: i32) -> bool {\\n\\tlet mut acc = x;\\n\\tlet mut y = 0;\\n\\twhile (acc > 0) {\\n\\t\\ty = y * 10 + acc % 10;\\n\\t\\tacc /= 10;\\n\\t}\\n\\tx == y\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nfn is_palindrome(x: i32) -> bool {\\n\\tlet mut acc = x;\\n\\tlet mut y = 0;\\n\\twhile (acc > 0) {\\n\\t\\ty = y * 10 + acc % 10;\\n\\t\\tacc /= 10;\\n\\t}\\n\\tx == y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635684,
                "title": "one-line-js-solution-o-n",
                "content": "This may not be the idle interview way to answer this question but just wanted to share the beauty(?) of JS\\n\\n```\\nvar isPalindrome = function (x) {\\n  return x.toString() === x.toString().split(\"\").reverse().join(\"\");\\n};\\n```\\n\\nRuntime: 168 ms, faster than **92.57%** of JavaScript online submissions for Palindrome Number.\\nMemory Usage: 47.7 MB, less than **91.86%** of JavaScript online submissions for Palindrome Number.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function (x) {\\n  return x.toString() === x.toString().split(\"\").reverse().join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539657,
                "title": "ruby-simple-solution",
                "content": "Quick and easy solution in Ruby without converting to string (convert to array). 2 line solution.\\n```\\ndef is_palindrome(x)\\n   return false if x < 0\\n    return x.digits.join.to_i == x\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array"
                ],
                "code": "```\\ndef is_palindrome(x)\\n   return false if x < 0\\n    return x.digits.join.to_i == x\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1145916,
                "title": "javascript-easy",
                "content": "````\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    let arr = x.toString().split(\\'\\');\\n    let left = 0,\\n        right = arr.length - 1;\\n    while (left < right) {\\n        if (arr[left++] !== arr[right--]) return false;\\n    }\\n    return true;\\n    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    let arr = x.toString().split(\\'\\');\\n    let left = 0,\\n        right = arr.length - 1;\\n    while (left < right) {\\n        if (arr[left++] !== arr[right--]) return false;\\n    }\\n    return true;\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1045945,
                "title": "rust-loop-solution",
                "content": "Runtime: 8 ms, faster than 55.97% of Rust online submissions for Palindrome Number.\\nMemory Usage: 2 MB, less than 91.77% of Rust online submissions for Palindrome Number.\\n```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        if x < 0 || (x % 10 == 0 && x != 0) {\\n            return false\\n        }\\n        \\n        let (mut x, mut rev) = (x, 0);\\n        while x > rev {\\n            rev = rev * 10 + x % 10;\\n            x /= 10;\\n        }\\n        x == rev || x == rev / 10\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        if x < 0 || (x % 10 == 0 && x != 0) {\\n            return false\\n        }\\n        \\n        let (mut x, mut rev) = (x, 0);\\n        while x > rev {\\n            rev = rev * 10 + x % 10;\\n            x /= 10;\\n        }\\n        x == rev || x == rev / 10\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042511,
                "title": "python-solution",
                "content": "Python solution:\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        pal = x\\n        n = 0\\n        while x > 0:\\n            n = n * 10 + x % 10\\n            x = x //10\\n        if pal == n:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        pal = x\\n        n = 0\\n        while x > 0:\\n            n = n * 10 + x % 10\\n            x = x //10\\n        if pal == n:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747909,
                "title": "swift",
                "content": "```\\nfunc isPalindrome(_ x: Int) -> Bool {\\n        \\n     guard x >= 0 else {\\n        return false\\n    }\\n    \\n    if x < 10 {\\n        return true\\n    }\\n    \\n    var temp = x;\\n    var rev = 0;\\n    \\n    while temp != 0 {\\n        rev = (rev * 10) + (temp % 10)\\n        temp /= 10;\\n    }\\n    \\n    \\n    return  rev == x\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isPalindrome(_ x: Int) -> Bool {\\n        \\n     guard x >= 0 else {\\n        return false\\n    }\\n    \\n    if x < 10 {\\n        return true\\n    }\\n    \\n    var temp = x;\\n    var rev = 0;\\n    \\n    while temp != 0 {\\n        rev = (rev * 10) + (temp % 10)\\n        temp /= 10;\\n    }\\n    \\n    \\n    return  rev == x\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593587,
                "title": "python-one-line-solution-48ms-python-explained",
                "content": "In this problem we just need to reverse the integer and check for both.\\nFirst we will check if it\\'s less than \\'zero\\' return False if that\\'s the case else return the comparision between the both reversed string and the given. \\nIf Type cast the integer x to string first and then using x[::-1] we reversed it.\\nAnd we can write this is one line as given below\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return False if x<0 else str(x)[::-1]==str(x)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return False if x<0 else str(x)[::-1]==str(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483133,
                "title": "9-javascript-math-solution",
                "content": "Here\\'s a math-based solution solution different from any of the others I see here.\\n\\n> Runtime: **184 ms**, faster than *81.12%* of JavaScript online submissions\\n> Memory Usage: **44.7 MB**, less than *98.28%* of JavaScript online submissions\\n\\n```javascript\\nconst isPalindrome = x => {\\n  if (x < 0) return false;\\n  let left = 10 ** Math.trunc(Math.log10(Math.abs(x)));\\n  while (0 < x) {\\n    if (Math.trunc(x / left) !== x % 10) return false;\\n    x = Math.trunc((x % left) / 10);\\n    left /= 100;\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```javascript\\nconst isPalindrome = x => {\\n  if (x < 0) return false;\\n  let left = 10 ** Math.trunc(Math.log10(Math.abs(x)));\\n  while (0 < x) {\\n    if (Math.trunc(x / left) !== x % 10) return false;\\n    x = Math.trunc((x % left) / 10);\\n    left /= 100;\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 317510,
                "title": "cpp-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x > 0 && x % 10 == 0))\\n            return false;\\n        int tmp = 0;\\n        while(tmp < x && tmp < x / 10) {\\n            tmp *= 10;\\n            tmp += x % 10;\\n            x /= 10;\\n        }\\n        return tmp == x || tmp == x/10;\\n    }\\n};\\n```\\nTime: O(N)\\nSpace: O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x > 0 && x % 10 == 0))\\n            return false;\\n        int tmp = 0;\\n        while(tmp < x && tmp < x / 10) {\\n            tmp *= 10;\\n            tmp += x % 10;\\n            x /= 10;\\n        }\\n        return tmp == x || tmp == x/10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287547,
                "title": "c-80ms-14-8mb",
                "content": "Runtime: 80 ms, faster than 99.96% of C# online submissions for Palindrome Number.\\nMemory Usage: 14.8 MB, less than 100.00% of C# online submissions for Palindrome Number.\\n\\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        //all negetive integer are not palindrome\\n        if(x < 0){\\n            return false;\\n        } else {\\n            int y = 0;\\n            int temp = x;\\n            while(temp != 0) {\\n                y = y * 10 + temp % 10;\\n                temp = temp / 10;\\n            }\\n            if(y == x){\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        //all negetive integer are not palindrome\\n        if(x < 0){\\n            return false;\\n        } else {\\n            int y = 0;\\n            int temp = x;\\n            while(temp != 0) {\\n                y = y * 10 + temp % 10;\\n                temp = temp / 10;\\n            }\\n            if(y == x){\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176640,
                "title": "python3-solution-without-str",
                "content": "    def isPalindrome(self,x):\n        if ((x<0)or(x%10==0 and x!=0)):\n            return False\n        else:\n            revnum=0\n            while(x>revnum):\n                revnum=revnum*10 + x%10\n                x=x//10\n                \n            return (x == revnum) or (x == revnum//10)",
                "solutionTags": [],
                "code": "    def isPalindrome(self,x):\n        if ((x<0)or(x%10==0 and x!=0)):\n            revnum=0\n            while(x>revnum):\n                revnum=revnum*10 + x%10\n                x=x//10\n            return (x == revnum) or (x == revnum//10)",
                "codeTag": "Python3"
            },
            {
                "id": 164337,
                "title": "javascript-solution",
                "content": "```\\nvar isPalindrome = function(x) {\\n    if(x < 0) return false;\\n    x += \"\";\\n    let i = 0; \\n    let j = x.length - 1;\\n    while(i < j){\\n        if(x[i] !== x[j]) return false;\\n        else{\\n            i ++;\\n            j --;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPalindrome = function(x) {\\n    if(x < 0) return false;\\n    x += \"\";\\n    let i = 0; \\n    let j = x.length - 1;\\n    while(i < j){\\n        if(x[i] !== x[j]) return false;\\n        else{\\n            i ++;\\n            j --;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5358,
                "title": "you-wanted-solution-with-no-extra-space-you-got-it",
                "content": "But it's terribly silly. And the compiler might want to optimize it by using temporary variables, and that's a kind of extra space I'm not responsible for.\\n\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || x > 0 && x % 10 == 0) {\\n            return false;\\n        } else {\\n            return x / 10 == 0 || x / 10 == x % 10 || x / 100 > 0 && x / 100 == x % 10 // 1-3 digits\\n                   || x / 100 > 0 && x / 100 ==       x % 10 * 10   + x % 100 / 10 // 4 digits\\n                   || x / 1000 > 0 && x / 1000 ==     x % 10 * 10   + x % 100 / 10 // 5 digits\\n                   || x / 1000 > 0 && x / 1000 ==     x % 10 * 100  + x % 100 / 10 * 10  + x % 1000 / 100 // 6 digits\\n                   || x / 10000 > 0 && x / 10000 ==   x % 10 * 100  + x % 100 / 10 * 10  + x % 1000 / 100 // 7 digits\\n                   || x / 10000 > 0 && x / 10000 ==   x % 10 * 1000 + x % 100 / 10 * 100 + x % 1000 / 100 * 10\\n                                                      + x % 10000 / 1000 // 8 digits\\n                   || x / 100000 > 0 && x / 100000 == x % 10 * 1000 + x % 100 / 10 * 100 + x % 1000 / 100 * 10\\n                                                      + x % 10000 / 1000 // 9 digits\\n                   || x / 100000 > 0 && x / 100000 == x % 10 * 10000 + x % 100 / 10 * 1000 + x % 1000 / 100 * 100\\n                                                      + x % 10000 / 1000 * 10 + x % 100000 / 10000; // 10 digits\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "But it's terribly silly. And the compiler might want to optimize it by using temporary variables, and that's a kind of extra space I'm not responsible for.\\n\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || x > 0 && x % 10 == 0) {\\n            return false;\\n        } else {\\n            return x / 10 == 0 || x / 10 == x % 10 || x / 100 > 0 && x / 100 == x % 10 // 1-3 digits\\n                   || x / 100 > 0 && x / 100 ==       x % 10 * 10   + x % 100 / 10 // 4 digits\\n                   || x / 1000 > 0 && x / 1000 ==     x % 10 * 10   + x % 100 / 10 // 5 digits\\n                   || x / 1000 > 0 && x / 1000 ==     x % 10 * 100  + x % 100 / 10 * 10  + x % 1000 / 100 // 6 digits\\n                   || x / 10000 > 0 && x / 10000 ==   x % 10 * 100  + x % 100 / 10 * 10  + x % 1000 / 100 // 7 digits\\n                   || x / 10000 > 0 && x / 10000 ==   x % 10 * 1000 + x % 100 / 10 * 100 + x % 1000 / 100 * 10\\n                                                      + x % 10000 / 1000 // 8 digits\\n                   || x / 100000 > 0 && x / 100000 == x % 10 * 1000 + x % 100 / 10 * 100 + x % 1000 / 100 * 10\\n                                                      + x % 10000 / 1000 // 9 digits\\n                   || x / 100000 > 0 && x / 100000 == x % 10 * 10000 + x % 100 / 10 * 1000 + x % 1000 / 100 * 100\\n                                                      + x % 10000 / 1000 * 10 + x % 100000 / 10000; // 10 digits\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 5480,
                "title": "accepted-java-solution-with-short-lines",
                "content": "    public class Solution {\\n        public boolean isPalindrome(int x) {\\n            int temp = Math.abs(x);\\n            int n = temp % 10;\\n            while(temp / 10 != 0){\\n                temp = temp / 10;    \\n                n = n * 10 + temp % 10; \\n            }\\n            if(n == x){\\n                return true;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isPalindrome(int x) {\\n            int temp = Math.abs(x);\\n            int n = temp % 10;\\n            while(temp / 10 != 0){\\n                temp = temp / 10;    \\n                n = n * 10 + temp % 10; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 5544,
                "title": "380ms-accepted-java-solution-what-no-extra-space-mean-though",
                "content": "    public boolean isPalindrome(int x) {\\n    \\n    if (x < 0) return false;\\n    else if (x < 10) return true;\\n    \\n    int n = (int) Math.log10(x);\\n    \\n    for (int i = n; i > n / 2; i--) {\\n    \\tif (x / (int) Math.pow(10, i) % 10 != x / (int) Math.pow(10, n - i) % 10)\\n    \\t\\treturn false;\\n    }\\n    \\n    return true;\\n    \\n    }",
                "solutionTags": [],
                "code": "    public boolean isPalindrome(int x) {\\n    \\n    if (x < 0) return false;\\n    else if (x < 10) return true;\\n    \\n    int n = (int) Math.log10(x);\\n    \\n    for (int i = n; i > n / 2; i--) {\\n    \\tif (x / (int) Math.pow(10, i) % 10 != x / (int) Math.pow(10, n - i) % 10)\\n    \\t\\treturn false;\\n    }\\n    \\n    return true;\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 5571,
                "title": "my-c-code-compare-the-first-half-and-the-second-half-of-x",
                "content": "Here, it is assumed that  Palindrome numbers are non-negative and 0 is considered as \"true\"\\nThe basic idea is to construct a rX which includes the second half digits (in the reverse order) and x, which includes the first half digits (in the normal order) and compare them. Attention should be paid to the odd/even digits cases. In such way, overflow issue is avoided.\\n\\n       class Solution {\\n        public:\\n            bool isPalindrome(int x) {\\n                int rX = 0; // the second half of x\\n                if(!x)\\n                { // if x==0\\n                    return true;\\n                }\\n                else if(x<0 || x%10 == 0)\\n                { // all negative numbers are not Palindrome numbers by definition, also for \"0\" digit, false too\\n                    return false;\\n                }\\n                else\\n                {\\n                    while(rX < x)\\n                    {\\n                        rX = rX*10 + x % 10;\\n                        x = x/10;\\n                    }\\n                    return (rX==x) || (rX/10 == x); //(rX==x) is for the even digits case, (rX/10 == x) is for the odd digits case\\n                    \\n                }\\n                \\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            bool isPalindrome(int x) {\\n                int rX = 0; // the second half of x\\n                if(!x)\\n                { // if x==0\\n                    return true;\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574279,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1564695,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1565223,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1567692,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1564646,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1711906,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1565275,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1566467,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1636603,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1566451,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1574279,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1564695,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1565223,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1567692,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1564646,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1711906,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1565275,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1566467,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1636603,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1566451,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1568819,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1876487,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1850648,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1575867,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1802228,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1575578,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1574137,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1567056,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1715373,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1576968,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1576136,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1568482,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 2013450,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1845665,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1576849,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1576802,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1576801,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1576564,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1576325,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1574621,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1574605,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1574085,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1573659,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1573497,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1573267,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1572721,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1572239,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1571013,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1571014,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1571015,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1570890,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 1576335,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 1568820,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 1576400,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 1576051,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 1571012,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 2077156,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 2076655,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 2076086,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 2074609,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 2073192,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2072974,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2072824,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2071623,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2070501,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2068681,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2068645,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2068641,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2066216,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2065681,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2062151,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2061890,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2061155,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2060827,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2060085,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2059748,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2059343,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2056356,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2054536,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2052856,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2049855,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2049752,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2048270,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2047711,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2038707,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2038283,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2035993,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2033938,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2027545,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2020910,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2015533,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 2014980,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 2002794,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1997618,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1997513,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1996201,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1994518,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1994457,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1983130,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1978337,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1978048,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1975173,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1974947,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1966197,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1960174,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1957078,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1956501,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1953797,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1947646,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1943413,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1943029,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1942933,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1937206,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1936957,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1935873,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1934685,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1934140,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1930986,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1930402,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1925672,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1922076,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1921431,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1920384,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1918185,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1918012,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1917667,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1914886,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1914166,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1906518,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1905849,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1905582,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1905413,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1904849,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1904023,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1903278,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1900327,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1897681,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1895626,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1888070,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1887277,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1887272,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1880246,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1878994,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1876627,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1872250,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1869646,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1865403,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1863442,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1861099,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1860789,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1857630,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1856775,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1853214,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1852840,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1846138,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1846137,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1846136,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1844382,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1843462,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1841640,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1826383,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1825934,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1823284,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1816438,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1813478,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810922,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1807668,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1807169,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1806824,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1806823,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1805990,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1805091,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1801030,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1800344,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1799247,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1796467,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1795623,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1794129,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1793838,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1793608,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1790282,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1787932,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1787910,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1786888,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1786082,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1782337,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1782218,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1777916,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1777829,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1774484,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1773686,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1773559,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1773051,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1771021,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1766431,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1765823,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1765325,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1762242,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1759812,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1759091,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1758894,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1758602,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753201,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1749355,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1746135,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1743546,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1743465,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1743067,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1740130,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1740069,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1740068,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1738472,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1738384,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1737817,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1736747,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1734865,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1734502,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1734196,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1732677,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1731470,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1730757,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1730630,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1728385,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1725481,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1722491,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1720340,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1719178,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1718138,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1717769,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1717444,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1714731,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1711366,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1711184,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1709056,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1707182,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1701906,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1700870,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1692815,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1692472,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1692096,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1691105,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1689697,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1678539,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1677535,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1672244,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1672205,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1671237,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1670990,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1666934,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1666748,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Convert Sorted List to Binary Search Tree",
        "question_content": "<p>Given the <code>head</code> of a singly linked list where elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword=\"height-balanced\"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/linked.jpg\" style=\"width: 500px; height: 388px;\" />\n<pre>\n<strong>Input:</strong> head = [-10,-3,0,5,9]\n<strong>Output:</strong> [0,-3,9,-10,null,5]\n<strong>Explanation:</strong> One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in <code>head</code> is in the range <code>[0, 2 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 35476,
                "title": "share-my-java-solution-1ms-very-short-and-concise",
                "content": "    public class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        return toBST(head,null);\\n    }\\n    public TreeNode toBST(ListNode head, ListNode tail){\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        if(head==tail) return null;\\n        \\n        while(fast!=tail&&fast.next!=tail){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        TreeNode thead = new TreeNode(slow.val);\\n        thead.left = toBST(head,slow);\\n        thead.right = toBST(slow.next,tail);\\n        return thead;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        return toBST(head,null);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 35472,
                "title": "share-my-o-1-space-and-o-n-time-java-code",
                "content": "    private ListNode node;\\n    \\n    public TreeNode sortedListToBST(ListNode head) {\\n    \\tif(head == null){\\n    \\t\\treturn null;\\n    \\t}\\n    \\t\\n    \\tint size = 0;\\n    \\tListNode runner = head;\\n    \\tnode = head;\\n    \\t\\n    \\twhile(runner != null){\\n    \\t\\trunner = runner.next;\\n    \\t\\tsize ++;\\n    \\t}\\n    \\t\\n    \\treturn inorderHelper(0, size - 1);\\n    }\\n\\n    public TreeNode inorderHelper(int start, int end){\\n    \\tif(start > end){\\n    \\t\\treturn null;\\n    \\t}\\n    \\t\\n    \\tint mid = start + (end - start) / 2;\\n    \\tTreeNode left = inorderHelper(start, mid - 1);\\n    \\t\\n    \\tTreeNode treenode = new TreeNode(node.val);\\n    \\ttreenode.left = left;\\n    \\tnode = node.next;\\n\\n    \\tTreeNode right = inorderHelper(mid + 1, end);\\n    \\ttreenode.right = right;\\n    \\t\\n    \\treturn treenode;\\n    }",
                "solutionTags": [],
                "code": "    private ListNode node;\\n    \\n    public TreeNode sortedListToBST(ListNode head) {\\n    \\tif(head == null){\\n    \\t\\treturn null;\\n    \\t}\\n    \\t\\n    \\tint size = 0;\\n    \\tListNode runner = head;\\n    \\tnode = head;\\n    \\t\\n    \\twhile(runner != null){\\n    \\t\\trunner = runner.next;\\n    \\t\\tsize ++;\\n    \\t}\\n    \\t\\n    \\treturn inorderHelper(0, size - 1);\\n    }\\n\\n    public TreeNode inorderHelper(int start, int end){\\n    \\tif(start > end){\\n    \\t\\treturn null;\\n    \\t}\\n    \\t\\n    \\tint mid = start + (end - start) / 2;\\n    \\tTreeNode left = inorderHelper(start, mid - 1);\\n    \\t\\n    \\tTreeNode treenode = new TreeNode(node.val);\\n    \\ttreenode.left = left;\\n    \\tnode = node.next;\\n\\n    \\tTreeNode right = inorderHelper(mid + 1, end);\\n    \\ttreenode.right = right;\\n    \\t\\n    \\treturn treenode;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3282028,
                "title": "java-easy-using-slow-fast-pointer-recursively",
                "content": "**Let\\'s think how can we approach this problem. One thing we can make sure of that our middle element of the sorted list will be our root. Now you will ask why? We will do this way because in the question it has stated that the bst that we will form from the list should be a height balanced bst. Now what is height balanced bst?? Height balanced bst means the difference between the heights of the left and the right subtree for any node is not more than one. So due to this condition our intuitive mind will always take the mid element of the list as the root of the bst. So to get the middle of the list I used tortoise-hare method or floyd cycle method. Here the slow starts from head and fast from head.next.next so that our slow pointer will stop at previous element of mid element of list. This will ensure that the slow\\'s next is the root and the slow itself is the part of left subtree. Doing this will help to detach the left part from remaining part of list by making the next of slow to null. We create a node of tree and assign slow\\'s next node\\'s value to it and ensured that it is the root of the tree. We then store the pointer of right subtree (here it\\'s righthalf node) by moving two step ahead because we know our right subtree will start after the root or you can say mid element of the list. After storing we make slow\\'s next to null so there will be no link with further elements of list. Now, we will start making the tree from left and right by assigning the root\\'s left as the head and root\\'s right as  righthalf node. Then this process goes on recursively again and again until we reach the base condition.**\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/2a469114-af57-494c-865a-6650b9d13bab_1678496081.7235246.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35483,
                "title": "my-accepted-c-solution",
                "content": "    class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head)\\n        {\\n        \\treturn sortedListToBST( head, NULL );\\n        }\\n        \\n    private:\\n        TreeNode *sortedListToBST(ListNode *head, ListNode *tail)\\n        {\\n        \\tif( head == tail )\\n        \\t\\treturn NULL;\\n        \\tif( head->next == tail )    // \\n        \\t{\\t\\n        \\t\\tTreeNode *root = new TreeNode( head->val );\\n        \\t\\treturn root;\\n        \\t}\\n        \\tListNode *mid = head, *temp = head;\\n        \\twhile( temp != tail && temp->next != tail )    // \\u5bfb\\u627e\\u4e2d\\u95f4\\u8282\\u70b9\\n        \\t{\\n        \\t\\tmid = mid->next;\\n        \\t\\ttemp = temp->next->next;\\n        \\t}\\n        \\tTreeNode *root = new TreeNode( mid->val );\\n        \\troot->left = sortedListToBST( head, mid );\\n        \\troot->right = sortedListToBST( mid->next, tail );\\n        \\treturn root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head)\\n        {\\n        \\treturn sortedListToBST( head, NULL );\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 596899,
                "title": "java-python-2-solutions-clean-concise-o-n-time-o-logn-space",
                "content": "**\\u2714\\uFE0F Solution 1: Convert linked list to array then do PreOrder Traversal**\\n- Convert `linked list` to `array`, then the problem become [108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\\n- Choose `arr[mid]` as a root\\n- Solve sub problem `(left, mid - 1)`, make it as left node\\n- Solve sub problem `(mid + 1, right)`, make it as right node\\n\\n<iframe src=\"https://leetcode.com/playground/Z96ZK7Tx/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Extra space: `O(N)`, because we need an extra `O(N)` space for `arr` \\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: InOrder Traversal**\\n- It\\'s a good chance to use In Order Traveral here, where we traverse Left - Root - Right.\\n- Firstly, we calculate of number of elements in the linked list, let name it `n`.\\n- We keep global `head`, in the beginning `head` points to the first element in the BST.\\n- Let `dfs(left, right)` return the root of the **height balanced BST** when building in elements from `left` to `right` of the linked list.\\n- Our answer is the root which is returned from `dfs(0, n-1)`.\\n- In `dfs(left, right)` function:\\n\\t- `mid = (left + right) / 2`\\n\\t- Firstly, we build BST left subtree, by `leftNode = dfs(left, mid-1)`, after finish building left subtree, now `head` will point to the `mid` element.\\n\\t- So we take the root value from `head.val` and move `head` to next, by `root = TreeNode(head.val); head = head.val`\\n\\t- Finally, we build the right node of the root, by `rightNode = dfs(mid+1, right)`.\\n\\n<iframe src=\"https://leetcode.com/playground/ijCqBuCC/shared\" frameBorder=\"0\" width=\"100%\" height=\"530\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Extra Space: `O(logN)`, because the depth of the `buildBST` recursion take `logN`\\n\\nPlease help to **UPVOTE** if this post is useful for you. If you have any questions, feel free to comment below. Happy coding!",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Convert linked list to array then do PreOrder Traversal**\\n- Convert `linked list` to `array`, then the problem become [108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\\n- Choose `arr[mid]` as a root\\n- Solve sub problem `(left, mid - 1)`, make it as left node\\n- Solve sub problem `(mid + 1, right)`, make it as right node\\n\\n<iframe src=\"https://leetcode.com/playground/Z96ZK7Tx/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Extra space: `O(N)`, because we need an extra `O(N)` space for `arr` \\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: InOrder Traversal**\\n- It\\'s a good chance to use In Order Traveral here, where we traverse Left - Root - Right.\\n- Firstly, we calculate of number of elements in the linked list, let name it `n`.\\n- We keep global `head`, in the beginning `head` points to the first element in the BST.\\n- Let `dfs(left, right)` return the root of the **height balanced BST** when building in elements from `left` to `right` of the linked list.\\n- Our answer is the root which is returned from `dfs(0, n-1)`.\\n- In `dfs(left, right)` function:\\n\\t- `mid = (left + right) / 2`\\n\\t- Firstly, we build BST left subtree, by `leftNode = dfs(left, mid-1)`, after finish building left subtree, now `head` will point to the `mid` element.\\n\\t- So we take the root value from `head.val` and move `head` to next, by `root = TreeNode(head.val); head = head.val`\\n\\t- Finally, we build the right node of the root, by `rightNode = dfs(mid+1, right)`.\\n\\n<iframe src=\"https://leetcode.com/playground/ijCqBuCC/shared\" frameBorder=\"0\" width=\"100%\" height=\"530\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Extra Space: `O(logN)`, because the depth of the `buildBST` recursion take `logN`\\n\\nPlease help to **UPVOTE** if this post is useful for you. If you have any questions, feel free to comment below. Happy coding!",
                "codeTag": "Unknown"
            },
            {
                "id": 35474,
                "title": "python-recursive-solution-with-detailed-comments-operate-linked-list-directly",
                "content": "        \\n    # recursively\\n    def sortedListToBST(self, head):\\n        if not head:\\n            return \\n        if not head.next:\\n            return TreeNode(head.val)\\n        # here we get the middle point,\\n        # even case, like '1234', slow points to '2',\\n        # '3' is root, '12' belongs to left, '4' is right\\n        # odd case, like '12345', slow points to '2', '12'\\n        # belongs to left, '3' is root, '45' belongs to right\\n        slow, fast = head, head.next.next\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n        # tmp points to root\\n        tmp = slow.next\\n        # cut down the left child\\n        slow.next = None\\n        root = TreeNode(tmp.val)\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(tmp.next)\\n        return root",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "        \\n    # recursively\\n    def sortedListToBST(self, head):\\n        if not head:\\n            return \\n        if not head.next:\\n            return TreeNode(head.val)\\n        # here we get the middle point,\\n        # even case, like '1234', slow points to '2',\\n        # '3' is root, '12' belongs to left, '4' is right\\n        # odd case, like '12345', slow points to '2', '12'\\n        # belongs to left, '3' is root, '45' belongs to right\\n        slow, fast = head, head.next.next\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n        # tmp points to root\\n        tmp = slow.next\\n        # cut down the left child\\n        slow.next = None\\n        root = TreeNode(tmp.val)\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(tmp.next)\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 35525,
                "title": "share-my-code-with-o-n-time-and-o-1-space",
                "content": "count is a function to calculate the size of list.\\n\\nKey words: inorder traversal.\\n\\n    class Solution {\\n    public:\\n        ListNode *list;\\n        int count(ListNode *node){\\n            int size = 0;\\n            while (node) {\\n                ++size;\\n                node = node->next;\\n            }\\n            return size;\\n        }\\n        \\n        TreeNode *generate(int n){\\n            if (n == 0)\\n                return NULL;\\n            TreeNode *node = new TreeNode(0);\\n            node->left = generate(n / 2);\\n            node->val = list->val;\\n            list = list->next;\\n            node->right = generate(n - n / 2 - 1);\\n            return node;\\n        }\\n        \\n        TreeNode *sortedListToBST(ListNode *head) {\\n            this->list = head;\\n            return generate(count(head));\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *list;\\n        int count(ListNode *node){\\n            int size = 0;\\n            while (node) {\\n                ++size;\\n                node = node->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3282118,
                "title": "image-explanation-slow-fast-pointer-recursion-complete-intuition",
                "content": "# Video Solution\\nhttps://youtu.be/cN823mo1r4k\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/e4022e7b-2e95-4f21-8e2e-74faa5dc76fa_1678501530.4593227.png)\\n![image.png](https://assets.leetcode.com/users/images/a3fe3a63-12fe-4d34-8841-9afeeabb3ec6_1678501541.154464.png)\\n![image.png](https://assets.leetcode.com/users/images/8da565b0-74e6-4b6a-b5cf-a3ef2cc00380_1678501553.1902893.png)\\n![image.png](https://assets.leetcode.com/users/images/4655f600-a847-45ce-9f46-8b27559c2ac1_1678501562.9293156.png)\\n![image.png](https://assets.leetcode.com/users/images/bb1a5509-5c97-48ef-ac55-f74c9599f864_1678501581.0625086.png)\\n![image.png](https://assets.leetcode.com/users/images/8b37776f-dca2-4485-bfe0-a914c2b8031b_1678501594.5740566.png)\\n![image.png](https://assets.leetcode.com/users/images/8056ea2c-9f10-47fd-a259-2d1054e467d5_1678501606.667109.png)\\n![image.png](https://assets.leetcode.com/users/images/8bc35695-59fc-4f00-bfbf-8ecefa91c910_1678501633.2509317.png)\\n![image.png](https://assets.leetcode.com/users/images/ac9d172a-5899-40bd-9fc4-31f3bc2fb1e2_1678501643.2698946.png)\\n![image.png](https://assets.leetcode.com/users/images/58cebc1b-d810-46d9-b167-bb1e6f67dc7a_1678501653.2449741.png)\\n![image.png](https://assets.leetcode.com/users/images/667d287d-78e5-4842-ad8f-2f153f1e5c03_1678501666.6580515.png)\\n![image.png](https://assets.leetcode.com/users/images/05dc0244-5772-4f9b-a933-f8c2834f6675_1678501673.2652276.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35470,
                "title": "recursive-bst-construction-using-slow-fast-traversal-on-linked-list",
                "content": "    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null)\\n            return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev =null; \\n        while(fast != null && fast.next != null)\\n        {\\n            fast = fast.next.next;\\n            prev =slow;\\n            slow=slow.next;\\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        if(prev != null)\\n            prev.next = null;\\n        else\\n            head  = null;\\n            \\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        return root;\\n    }\\n\\nTraverse the list to get the middle element and make that the root. left side of the list forms left sub-tree and right side of the middle element forms the right sub-tree.",
                "solutionTags": [],
                "code": "    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null)\\n            return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev =null; \\n        while(fast != null && fast.next != null)\\n        {\\n            fast = fast.next.next;\\n            prev =slow;\\n            slow=slow.next;\\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        if(prev != null)\\n            prev.next = null;\\n        else\\n            head  = null;\\n            \\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        return root;\\n    }\\n\\nTraverse the list to get the middle element and make that the root. left side of the list forms left sub-tree and right side of the middle element forms the right sub-tree.",
                "codeTag": "Unknown"
            },
            {
                "id": 3281968,
                "title": "beats-100-video-java-c-python",
                "content": "# Intuition \\nIn a balanced binary search Tree height difference b/w left and right node cannot be more than 1 or in other words they contain almost equal number of nodes. \\n\\nThis can be achieved by dividing the Linked List into 2 parts first half = left Node, middle = root and right = second half. Repeat the above process recursively to generate the BST.\\n\\nTo find middle element use 2 pointer approach: The fast moves 2 steps  and slow 1 step at a time. Hence when fast is finished, slow will be at middle.\\n\\neg: Find the middle element below = 0 and form root. The LinkedList on left of middle will form a new BST and right will form a new BST using same function. i.e -3 will be mid and left = -10 and right = -1 . \\n![image](https://assets.leetcode.com/users/images/d62c97df-6f71-4fc7-8452-752aab7ac249_1678497515.3905432.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a0653699-208d-4bf5-a27f-1d26a0e77afd_1678497561.5658028.jpeg)\\n\\n\\n# Approach \\n1. Find the middle element of the linked list.\\n2. Create a new node with the middle element as its value.\\n3. Set the left subtree of the new node to the result of recursively calling the function on the left half of the sorted list.\\n4. Set the right subtree of the new node to the result of recursively calling the function on the right half of the sorted list.\\n5. Return the new node.\\n\\nHow to find middle element:\\n\\n1. Initialize two pointers, slow and fast, to head.\\n2. Move fast two steps ahead and slow one step ahead, until fast reaches the end of the list or goes past it.\\n3. The element pointed to by slow is the middle element of the list.\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pWjxJPY-DIo\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n![image](https://assets.leetcode.com/users/images/88e7cad3-cab3-4e1f-ae9d-039ac2bccfa9_1678494974.1775608.jpeg)\\n\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next == null) return new TreeNode(head.val);\\n        ListNode middle = getMiddle(head);\\n        TreeNode root = new TreeNode(middle.val);\\n        root.right = sortedListToBST(middle.next);\\n        middle.next =null;\\n        root.left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    public ListNode getMiddle(ListNode head){\\n        //if(head == null || head.next==null) return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            prev = slow;\\n            slow = slow.next;\\n            \\n        }\\n        if(prev!=null)prev.next =null;\\n        return slow;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode* middle = getMiddle(head);\\n        TreeNode* root = new TreeNode(middle->val);\\n        root->right = sortedListToBST(middle->next);\\n        middle->next = NULL;\\n        root->left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    ListNode* getMiddle(ListNode* head){\\n        //if(head == NULL || head->next==NULL) return NULL;\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        ListNode* prev = NULL;\\n        while(fast!=NULL && fast->next!=NULL){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        if(prev!=NULL) prev->next = NULL;\\n        return slow;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head:\\n            return None\\n        if not head.next:\\n            return TreeNode(head.val)\\n        middle = self.getMiddle(head)\\n        root = TreeNode(middle.val)\\n        root.right = self.sortedListToBST(middle.next)\\n        middle.next = None\\n        root.left = self.sortedListToBST(head)\\n        return root\\n    \\n    def getMiddle(self, head: ListNode) -> ListNode:\\n        fast = head\\n        slow = head\\n        prev = None\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            prev = slow\\n            slow = slow.next\\n        if prev:\\n            prev.next = None\\n        return slow\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next == null) return new TreeNode(head.val);\\n        ListNode middle = getMiddle(head);\\n        TreeNode root = new TreeNode(middle.val);\\n        root.right = sortedListToBST(middle.next);\\n        middle.next =null;\\n        root.left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    public ListNode getMiddle(ListNode head){\\n        //if(head == null || head.next==null) return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            prev = slow;\\n            slow = slow.next;\\n            \\n        }\\n        if(prev!=null)prev.next =null;\\n        return slow;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode* middle = getMiddle(head);\\n        TreeNode* root = new TreeNode(middle->val);\\n        root->right = sortedListToBST(middle->next);\\n        middle->next = NULL;\\n        root->left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    ListNode* getMiddle(ListNode* head){\\n        //if(head == NULL || head->next==NULL) return NULL;\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        ListNode* prev = NULL;\\n        while(fast!=NULL && fast->next!=NULL){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        if(prev!=NULL) prev->next = NULL;\\n        return slow;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head:\\n            return None\\n        if not head.next:\\n            return TreeNode(head.val)\\n        middle = self.getMiddle(head)\\n        root = TreeNode(middle.val)\\n        root.right = self.sortedListToBST(middle.next)\\n        middle.next = None\\n        root.left = self.sortedListToBST(head)\\n        return root\\n    \\n    def getMiddle(self, head: ListNode) -> ListNode:\\n        fast = head\\n        slow = head\\n        prev = None\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            prev = slow\\n            slow = slow.next\\n        if prev:\\n            prev.next = None\\n        return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35555,
                "title": "clean-c-solution-recursion-o-nlogn-with-comment",
                "content": "Recursively build tree. <br>\\n1. find midpoint by fast/slow method, use middle node as root.  <br>\\n2. build left child by first half of the list  <br>\\n3. build right child by second half of the list (head is midpoint->next)\\n\\n<pre><code><cpp>\\n    class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head) {\\n            if(!head) return NULL;\\n            if(!head->next) return new TreeNode(head->val);\\n            \\n            // fast/slow pointer to find the midpoint\\n            auto slow = head;\\n            auto fast = head;\\n            auto pre = head;\\n            while(fast && fast->next) {\\n                pre = slow;\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }\\n            pre->next = 0; // break two halves \\n            \\n            // slow is the midpoint, use as root\\n            TreeNode* root = new TreeNode(slow->val);\\n            root->left = sortedListToBST(head);\\n            root->right = sortedListToBST(slow->next);\\n            \\n            return root;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head) {\\n            if(!head) return NULL;\\n            if(!head->next) return new TreeNode(head->val);\\n            \\n            // fast/slow pointer to find the midpoint\\n            auto slow = head;\\n            auto fast = head;\\n            auto pre = head;\\n            while(fast && fast->next) {\\n                pre = slow;\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 35589,
                "title": "share-my-easy-understatnd-java-solution",
                "content": "    public class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode temp=null;\\n        \\n        //find the mid node\\n        while(fast.next!=null && fast.next.next!=null){\\n            fast = fast.next.next;\\n            temp = slow;\\n            slow = slow.next;\\n        }\\n        \\n        if(temp!=null)\\n            temp.next = null; //break the link\\n        else\\n            head = null;\\n            \\n        TreeNode root = new TreeNode(slow.val);\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode temp=null;\\n        \\n        //find the mid node\\n        while(fast.next!=null && fast.next.next!=null){\\n            fast = fast.next.next;\\n            temp = slow;\\n            slow = slow.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 35526,
                "title": "python-solutions-convert-to-array-first-top-down-approach-bottom-up-approach",
                "content": "    # convert linked list to array\\n    def sortedListToBST1(self, head):\\n        ls = []\\n        while head:\\n            ls.append(head.val)\\n            head = head.next\\n        return self.helper(ls, 0, len(ls)-1)\\n\\n    def helper(self, ls, start, end):\\n        if start > end:\\n            return None\\n        if start == end:\\n            return TreeNode(ls[start])\\n        mid = (start+end) >> 1\\n        root = TreeNode(ls[mid])\\n        root.left = self.helper(ls, start, mid-1)\\n        root.right = self.helper(ls, mid+1, end)\\n        return root\\n\\n    # top-down approach, O(n*logn)\\n    def sortedListToBST2(self, head):\\n        if not head:\\n            return \\n        if not head.next:\\n            return TreeNode(head.val)\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        slow, fast = dummy, head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        root = TreeNode(slow.next.val)\\n        root.right = self.sortedListToBST(slow.next.next)\\n        slow.next = None\\n        root.left = self.sortedListToBST(head)\\n        return root\\n        \\n    # bottom-up approach, O(n)\\n    def sortedListToBST3(self, head):\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        return self.convert([head], 0, l-1)\\n        \\n    def convert(self, head, start, end):\\n        if start > end:\\n            return None\\n        mid = (start + end) >> 1\\n        l = self.convert(head, start, mid-1)\\n        root = TreeNode(head[0].val)\\n        root.left = l\\n        head[0] = head[0].next \\n        root.right = self.convert(head, mid+1, end)\\n        return root\\n    \\n    # bottom-up approach, O(n)    \\n    def sortedListToBST(self, head):\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        self.node = head\\n        return self.convert(0, l-1)\\n        \\n    def convert(self, start, end):\\n        if start > end:\\n            return None\\n        mid = (start + end) >> 1\\n        l = self.convert(start, mid-1)\\n        root = TreeNode(self.node.val)\\n        root.left = l\\n        self.node = self.node.next \\n        root.right = self.convert(mid+1, end)\\n        return root",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # convert linked list to array\\n    def sortedListToBST1(self, head):\\n        ls = []\\n        while head:\\n            ls.append(head.val)\\n            head = head.next\\n        return self.helper(ls, 0, len(ls)-1)\\n\\n    def helper(self, ls, start, end):\\n        if start > end:\\n            return None\\n        if start == end:\\n            return TreeNode(ls[start])\\n        mid = (start+end) >> 1\\n        root = TreeNode(ls[mid])\\n        root.left = self.helper(ls, start, mid-1)\\n        root.right = self.helper(ls, mid+1, end)\\n        return root\\n\\n    # top-down approach, O(n*logn)\\n    def sortedListToBST2(self, head):\\n        if not head:\\n            return \\n        if not head.next:\\n            return TreeNode(head.val)\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        slow, fast = dummy, head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        root = TreeNode(slow.next.val)\\n        root.right = self.sortedListToBST(slow.next.next)\\n        slow.next = None\\n        root.left = self.sortedListToBST(head)\\n        return root\\n        \\n    # bottom-up approach, O(n)\\n    def sortedListToBST3(self, head):\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        return self.convert([head], 0, l-1)\\n        \\n    def convert(self, head, start, end):\\n        if start > end:\\n            return None\\n        mid = (start + end) >> 1\\n        l = self.convert(head, start, mid-1)\\n        root = TreeNode(head[0].val)\\n        root.left = l\\n        head[0] = head[0].next \\n        root.right = self.convert(head, mid+1, end)\\n        return root\\n    \\n    # bottom-up approach, O(n)    \\n    def sortedListToBST(self, head):\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        self.node = head\\n        return self.convert(0, l-1)\\n        \\n    def convert(self, start, end):\\n        if start > end:\\n            return None\\n        mid = (start + end) >> 1\\n        l = self.convert(start, mid-1)\\n        root = TreeNode(self.node.val)\\n        root.left = l\\n        self.node = self.node.next \\n        root.right = self.convert(mid+1, end)\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 1194284,
                "title": "python-optimal-o-n-inorder-traversal-explained",
                "content": "There are solutions with different time/space complexities.\\n1. We can just transform everything to array and then create bst, in `O(n)` time and `O(n)` space.\\n2. Or we can not create array, but then each time we need to find middle, and time will be `O(n log n)`.\\n\\nImagine now, that we can reuse nodes of our linked list to create nodes of bst. This is not the case in this problem, but if it was the case than we can have space complexity smaller than `O(n)`. The main complexity in idea `2` is that we always need to find the middle element in list, which is quite heavy: we need to traverse all (or half) of the list. Let us use function `helper(beg, end)`, with:\\n\\n1. `(beg, end)` are indexes in original linked list we want to traverse and create BST from these elements.\\n2. Output will be the root of BST\\n3. We also keep one more piece of information: `self.head`: global variable, which will help us to have quick access to desired elements: on step `i` in inorder traversal it will point to `i`-th element in linked list. More precisely when we run `helper(beg, end)`, after execution of this code, `self.head` will point to the element with index `end + 1`. This is **invariant** of our `helper` functioun.\\n\\nNow, function will look like this:\\n1. Check if `beg > end` and if it is the case, we out of nodes, we return `None`.\\n2. Find `mid` element as `(beg + end)//2`.\\n3. Run our `helper` function recursively: `helper(beg, mid - 1)`. Note where our `self.head` is now. It is changed after we run this funtion and now points at element with index `mid`.\\n4. Create `root`: we use `self.head` for this.\\n5. Move `self.head` one step to the right.\\n6. Now, it is time to attach left subtree to our root.\\n7. Finally, attach right subtree: `helper(mid + 1, end)` to our root. Note howe `self.head` changed after this: it will point at element with index `end + 1`. So, we proved, that our **invariant** holds.\\n8. Return `root`.\\n\\n#### Complexity\\nTime complexity is `O(n)`: we traverse every node only once. Space complexity is also `O(n)`, because we need to create object with `n` elements in the end. However why this is better than creating array, is because if we allowed to modify elements of the linked list to make them directly elements of BST, then space complexity would have been `O(log n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head):\\n        def helper(beg, end):\\n            if beg > end: return None\\n            mid = (beg + end)//2\\n            left = helper(beg, mid - 1)\\n            root = TreeNode(self.head.val)\\n            self.head = self.head.next\\n            root.left = left\\n            root.right = helper(mid + 1, end)\\n            return root\\n        \\n        self.head, copy, n = head, head, 0\\n        while copy:\\n            copy = copy.next\\n            n += 1\\n            \\n        return helper(0, n-1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List",
                    "Binary Search Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def sortedListToBST(self, head):\\n        def helper(beg, end):\\n            if beg > end: return None\\n            mid = (beg + end)//2\\n            left = helper(beg, mid - 1)\\n            root = TreeNode(self.head.val)\\n            self.head = self.head.next\\n            root.left = left\\n            root.right = helper(mid + 1, end)\\n            return root\\n        \\n        self.head, copy, n = head, head, 0\\n        while copy:\\n            copy = copy.next\\n            n += 1\\n            \\n        return helper(0, n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194036,
                "title": "explained-algorithm-c-code",
                "content": "Intuition is we need to find middle and divide list in two halves and keep doing same till single node.\\n\\n**Algorithm:**\\n```\\n1. We know middle node will be our root , so we will calculate middle using findMiddle()\\n2. We should also track prev of middle to mark the end of first list before middle node.\\n3. Now we have two lists - \\n\\tlist1:  [head....middle_prev] \\n    list2: [middle_next.....lastnode]\\n4. middle is the root.\\n5. put list1 in left of root and list2 in right of root.\\n6. Repeat the process from beginning for list1 and list2.\\n7. return root\\n```\\n\\nRecursion is difficult untill you make your code dry run following ladder-structure.\\n\\n**Working Code:**\\n```\\nclass Solution {\\npublic:\\n    pair<ListNode*,ListNode*> findMiddle(ListNode *head){\\n        if(nullptr == head || nullptr == head->next)\\n            return {nullptr,head};\\n        \\n        ListNode *slow = head;\\n        ListNode *fast = head->next;\\n        ListNode *prev = nullptr;\\n        \\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        return {prev,slow};\\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(nullptr == head)\\n            return nullptr;\\n        \\n        //returning {prev_middle,middle}\\n        pair<ListNode*,ListNode*> p = findMiddle(head);\\n        \\n        ListNode* prev = p.first;\\n        ListNode* middle = p.second;\\n        \\n        TreeNode* root = new TreeNode(middle->val);\\n        \\n        if(prev){\\n            prev->next = nullptr;\\n            root->left = sortedListToBST(head);\\n        }\\n        \\n        root->right = sortedListToBST(middle->next);\\n        return root;\\n    }\\n};\\n```\\n**Time Complexity** - O(nlogn) \\n**Space Compexity** - O(logn) ---> (Not considering the space taken by output tree nodes, if consider them then O(n) )\\nwhere n is no of nodes in list\\n\\n\\n**If you find this post helpful, please help to upvote**. Thanks in advance.\\nFeel free to shoot your queries in comments.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n1. We know middle node will be our root , so we will calculate middle using findMiddle()\\n2. We should also track prev of middle to mark the end of first list before middle node.\\n3. Now we have two lists - \\n\\tlist1:  [head....middle_prev] \\n    list2: [middle_next.....lastnode]\\n4. middle is the root.\\n5. put list1 in left of root and list2 in right of root.\\n6. Repeat the process from beginning for list1 and list2.\\n7. return root\\n```\n```\\nclass Solution {\\npublic:\\n    pair<ListNode*,ListNode*> findMiddle(ListNode *head){\\n        if(nullptr == head || nullptr == head->next)\\n            return {nullptr,head};\\n        \\n        ListNode *slow = head;\\n        ListNode *fast = head->next;\\n        ListNode *prev = nullptr;\\n        \\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        return {prev,slow};\\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(nullptr == head)\\n            return nullptr;\\n        \\n        //returning {prev_middle,middle}\\n        pair<ListNode*,ListNode*> p = findMiddle(head);\\n        \\n        ListNode* prev = p.first;\\n        ListNode* middle = p.second;\\n        \\n        TreeNode* root = new TreeNode(middle->val);\\n        \\n        if(prev){\\n            prev->next = nullptr;\\n            root->left = sortedListToBST(head);\\n        }\\n        \\n        root->right = sortedListToBST(middle->next);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194228,
                "title": "js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to build a **height-balanced binary tree**, we need to ensure that roughly half of the total number of nodes are on either side of the root, and the only way to know what half of the total number of nodes is requires finding the total number of nodes first.\\n\\nWith this in mind, one easy solution would be to convert the linked list to an array, then we have handy access not only to the total length of the array, but also index-access to the node values, as well. At that point, we could define a **recursive** helper to build a tree from the middle node, recursively calling itself to build subtrees from the nodes on the left and right of the middle node. This option would take an **extra O(N) space** to complete.\\n\\nShould we not want to use up that much extra space, we could instead keep the linked list and lose the index-access nature of the array, using **Floyd\\'s Cycle Detection Algorithm** to easily find the middle node on each recursion step. This would, however, require iterating through parts of the linked list repeatedly, driving the **time complexity** from **O(N)** to **O(N log N)**.\\n\\nBut we can do even better: We can complete this problem in **O(N) time** with only **O(log N) extra space** (in excess of the output space).\\n\\nFirst, we\\'ll have to iterate once through the linked list to count the total number of nodes (**count**). Then, we can define our recursive helper (**treeify()**)using index numbers as our arguments. Even though we won\\'t be able to access the listnodes directly by index number, we can take advantage of an **inorder tree traversal** to force our access to go in iterative order.\\n\\nWe\\'ll need to have our list pointer (**curr**) have global scope in order to update properly via recursion. In an inorder traversal, we recursively process the left subtree, then process the middle node, then recursively process the right subtree. For this solution, we\\'ll just need to make sure we move **curr** to **curr.next** at the end of processing the middle node.\\n\\nWe can then **return** the full tree built by our recursive helper.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of the linked list_\\n - _**Space Complexity: O(log N)** in excess of the space needed for the input/output, due to the recursion stack_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Python, we can store our list index pointer (**curr**) in a list to give it global scope so that it will update properly.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **92ms / 43.6MB** (beats 91% / 95%).\\n```javascript\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **120ms / 20.0MB** (beats 95% / 60%).\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        curr, count = head, 0\\n        while curr:\\n            curr = curr.next\\n            count += 1\\n        def treeify(i: int, j: int) -> TreeNode:\\n            if j < i: return None\\n            mid, node = i + j >> 1, TreeNode()\\n            node.left = treeify(i, mid - 1)\\n            node.val, curr[0] = curr[0].val, curr[0].next\\n            node.right = treeify(mid + 1, j)\\n            return node\\n        curr = [head]\\n        return treeify(1, count)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 39.8MB** (beats 100% / 56%).\\n```java\\nclass Solution {\\n    ListNode curr;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr != null) {\\n            curr = curr.next;\\n            count++;\\n        }\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n    private TreeNode treeify(int i, int j) {\\n        if (j < i) return null;\\n        int mid = i + j >> 1;\\n        TreeNode node = new TreeNode();\\n        node.left = treeify(i, mid - 1);\\n        node.val = curr.val;\\n        curr = curr.next;\\n        node.right = treeify(mid + 1, j);\\n        return node;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **16ms / 30.9MB** (beats 100% / 68%).\\n```c++\\nclass Solution {\\nprivate:\\n    ListNode* curr;\\n    TreeNode* treeify(int i, int j) {\\n        if (j < i) return nullptr;\\n        int mid = (i + j) >> 1;\\n        TreeNode* node = new TreeNode();\\n        node->left = treeify(i, mid - 1);\\n        node->val = curr->val, curr = curr->next;\\n        node->right = treeify(mid + 1, j);\\n        return node;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr) curr = curr->next, count++;\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        curr, count = head, 0\\n        while curr:\\n            curr = curr.next\\n            count += 1\\n        def treeify(i: int, j: int) -> TreeNode:\\n            if j < i: return None\\n            mid, node = i + j >> 1, TreeNode()\\n            node.left = treeify(i, mid - 1)\\n            node.val, curr[0] = curr[0].val, curr[0].next\\n            node.right = treeify(mid + 1, j)\\n            return node\\n        curr = [head]\\n        return treeify(1, count)\\n```\n```java\\nclass Solution {\\n    ListNode curr;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr != null) {\\n            curr = curr.next;\\n            count++;\\n        }\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n    private TreeNode treeify(int i, int j) {\\n        if (j < i) return null;\\n        int mid = i + j >> 1;\\n        TreeNode node = new TreeNode();\\n        node.left = treeify(i, mid - 1);\\n        node.val = curr.val;\\n        curr = curr.next;\\n        node.right = treeify(mid + 1, j);\\n        return node;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\nprivate:\\n    ListNode* curr;\\n    TreeNode* treeify(int i, int j) {\\n        if (j < i) return nullptr;\\n        int mid = (i + j) >> 1;\\n        TreeNode* node = new TreeNode();\\n        node->left = treeify(i, mid - 1);\\n        node->val = curr->val, curr = curr->next;\\n        node->right = treeify(mid + 1, j);\\n        return node;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr) curr = curr->next, count++;\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35572,
                "title": "very-simple-recursive-solution-in-c-o-n-time",
                "content": "    struct ListNode * current;\\n    struct TreeNode * build_tree(int low,int up)\\n    {\\n        if(low >= up ) return NULL;\\n        struct TreeNode * tmp = malloc(sizeof(struct TreeNode));\\n        int mid = low + ((up - low)>>1);\\n        tmp -> left = build_tree(low,mid);\\n        tmp -> val = current -> val;\\n        current = current -> next;\\n        tmp -> right = build_tree(mid+1,up);\\n        return tmp;\\n    }\\n\\n    struct TreeNode* sortedListToBST(struct ListNode* head) {\\n         current = head;\\n        int len = 0;\\n        while(head) \\n            len++, head = head->next;\\n        return build_tree(0,len);\\n    }",
                "solutionTags": [],
                "code": "    struct ListNode * current;\\n    struct TreeNode * build_tree(int low,int up)\\n    {\\n        if(low >= up ) return NULL;\\n        struct TreeNode * tmp = malloc(sizeof(struct TreeNode));\\n        int mid = low + ((up - low)>>1);\\n        tmp -> left = build_tree(low,mid);\\n        tmp -> val = current -> val;\\n        current = current -> next;\\n        tmp -> right = build_tree(mid+1,up);\\n        return tmp;\\n    }\\n\\n    struct TreeNode* sortedListToBST(struct ListNode* head) {\\n         current = head;\\n        int len = 0;\\n        while(head) \\n            len++, head = head->next;\\n        return build_tree(0,len);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3281995,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconquer approach similar to how we construct a binary search tree from a sorted array. The idea is to find the middle element of the linked list, make it the root of the tree, and then recursively construct the left and right subtrees using the nodes before and after the middle element, respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the middle node of the linked list. To do this, we can use the two-pointer technique where one pointer moves one step at a time while the other pointer moves two steps at a time. When the fast pointer reaches the end of the list, the slow pointer will be at the\\nmiddle node.\\n2. Create a new TreeNode with the value of the middle node.\\n3. Recursively construct the left subtree using the nodes before the middle node and the right subtree using the nodes after the middle node.\\n4. Return the root node of the tree\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\nThe time complexity of this approach is O(nlogn) because we divide the list into two halves at each level of the recursion tree, and there are a total of logn levels. At each level, we need to traverse the entire sublist to find the middle node, which takes O(n) time. Therefore, the overall time complexity is O(nlogn).\\n\\n- Space complexity: $$O(logn)$$\\nThe space complexity of this approach is O(logn) because we use the call stack to keep track of the recursive function calls. Since the maximum depth of the recursion tree is logn, the space complexity is O(logn).\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n``` Python []\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def sortedListToBST(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[TreeNode]\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        if not head.next:\\n            return TreeNode(head.val)\\n        \\n        # Find the middle element of the linked list\\n        slow, fast = head, head.next.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Create a new TreeNode with the middle element as the root\\n        root = TreeNode(slow.next.val)\\n        \\n        # Recursively construct the left and right subtrees\\n        right_head = slow.next.next\\n        slow.next = None\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(right_head)\\n        \\n        return root\\n\\n```\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        ListNode mid = findMiddle(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        if (head == mid) {\\n            return root;\\n        }\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(mid.next);\\n        return root;\\n    }\\n    \\n    private ListNode findMiddle(ListNode head) {\\n        ListNode prev = null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        if (prev != null) {\\n            prev.next = null;\\n        }\\n        return slow;\\n    }\\n}\\n\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) {\\n            return nullptr;\\n        }\\n        ListNode* mid = findMiddle(head);\\n        TreeNode* root = new TreeNode(mid->val);\\n        if (head == mid) {\\n            return root;\\n        }\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(mid->next);\\n        return root;\\n    }\\n    \\n    ListNode* findMiddle(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        if (prev) {\\n            prev->next = nullptr;\\n        }\\n        return slow;\\n    }\\n};\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Python []\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def sortedListToBST(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[TreeNode]\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        if not head.next:\\n            return TreeNode(head.val)\\n        \\n        # Find the middle element of the linked list\\n        slow, fast = head, head.next.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Create a new TreeNode with the middle element as the root\\n        root = TreeNode(slow.next.val)\\n        \\n        # Recursively construct the left and right subtrees\\n        right_head = slow.next.next\\n        slow.next = None\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(right_head)\\n        \\n        return root\\n\\n```\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        ListNode mid = findMiddle(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        if (head == mid) {\\n            return root;\\n        }\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(mid.next);\\n        return root;\\n    }\\n    \\n    private ListNode findMiddle(ListNode head) {\\n        ListNode prev = null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        if (prev != null) {\\n            prev.next = null;\\n        }\\n        return slow;\\n    }\\n}\\n\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) {\\n            return nullptr;\\n        }\\n        ListNode* mid = findMiddle(head);\\n        TreeNode* root = new TreeNode(mid->val);\\n        if (head == mid) {\\n            return root;\\n        }\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(mid->next);\\n        return root;\\n    }\\n    \\n    ListNode* findMiddle(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        if (prev) {\\n            prev->next = nullptr;\\n        }\\n        return slow;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421697,
                "title": "faster-simpler-recursion-javascript-submission",
                "content": "**Please don\\'t forget to upvote, it only motivates me to write much better code**\\n**And, as always all the suggestions are welcomed**\\n\\n```\\nvar sortedListToBST = function(head) {\\n//     Converting LL into array\\n    let arr = getarr(head);\\n    \\n//     Now, using tree function to get an tree out of SORTED ARRAY\\n    return tree(arr);\\n    \\n};\\n\\nfunction getarr(head){\\n    if(!head) return [];\\n    let temp = head;\\n    let out = []\\n    while(temp){\\n        out.push(temp.val);\\n        temp = temp.next;\\n    }\\n    return out;\\n}\\n\\nfunction tree(nums, start=0, end = nums.length-1) {\\n    if(start<=end){\\n        let mid = Math.floor((start+end)/2);\\n        // console.log(mid, end)\\n        let root = new TreeNode(nums[mid]);\\n        root.left = tree(nums, start, mid-1);\\n        root.right = tree(nums, mid+1, end);\\n        return root;\\n    }\\n    return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar sortedListToBST = function(head) {\\n//     Converting LL into array\\n    let arr = getarr(head);\\n    \\n//     Now, using tree function to get an tree out of SORTED ARRAY\\n    return tree(arr);\\n    \\n};\\n\\nfunction getarr(head){\\n    if(!head) return [];\\n    let temp = head;\\n    let out = []\\n    while(temp){\\n        out.push(temp.val);\\n        temp = temp.next;\\n    }\\n    return out;\\n}\\n\\nfunction tree(nums, start=0, end = nums.length-1) {\\n    if(start<=end){\\n        let mid = Math.floor((start+end)/2);\\n        // console.log(mid, end)\\n        let root = new TreeNode(nums[mid]);\\n        root.left = tree(nums, start, mid-1);\\n        root.right = tree(nums, mid+1, end);\\n        return root;\\n    }\\n    return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282266,
                "title": "c-easy-solution-recursion-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFRecursion Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* func(ListNode*head,int n){\\n        //if we have the length of list 0 then we will simply return the nullptr\\n        if(n<=0){\\n            return nullptr;\\n        }\\n\\t\\t//if we are remaining with only one length then we will make node of it and return it\\n        if(n==1){\\n            return new TreeNode(head->val);\\n        }\\n        int mid=n/2;\\n        ListNode*temp=head;\\n\\t\\t//traversing to the mid of the list from head\\n        while(mid--){\\n            temp=temp->next;\\n        }\\n\\t\\t//then we will get our ans\\n        TreeNode*ans=new TreeNode(temp->val,func(head,n/2),func(temp->next,n-n/2-1));\\n\\t\\t//returning the ans\\n        return ans;\\n        \\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head){\\n            return nullptr;\\n        }\\n        int n=0;\\n\\t\\t//we are calculating the length of the linked list\\n\\t\\t//so that we can divide the linked list from middle\\n        ListNode*temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->next;\\n        }\\n\\t\\t//then we are calling the function\\n        return func(head,n);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* func(ListNode*head,int n){\\n        //if we have the length of list 0 then we will simply return the nullptr\\n        if(n<=0){\\n            return nullptr;\\n        }\\n\\t\\t//if we are remaining with only one length then we will make node of it and return it\\n        if(n==1){\\n            return new TreeNode(head->val);\\n        }\\n        int mid=n/2;\\n        ListNode*temp=head;\\n\\t\\t//traversing to the mid of the list from head\\n        while(mid--){\\n            temp=temp->next;\\n        }\\n\\t\\t//then we will get our ans\\n        TreeNode*ans=new TreeNode(temp->val,func(head,n/2),func(temp->next,n-n/2-1));\\n\\t\\t//returning the ans\\n        return ans;\\n        \\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head){\\n            return nullptr;\\n        }\\n        int n=0;\\n\\t\\t//we are calculating the length of the linked list\\n\\t\\t//so that we can divide the linked list from middle\\n        ListNode*temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->next;\\n        }\\n\\t\\t//then we are calling the function\\n        return func(head,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194033,
                "title": "convert-sorted-list-to-binary-search-tree-simple-solution-explained",
                "content": "We need to construct **height-balanced BST** using LinkedList. The main idea is,\\n```\\n-> we want height of the BST to balanced, which can be acheived by selecting mid of List as root of BST.\\n-> follow the same for both left and right trees by calling the function ToBST recursively.\\n\\t1. Left substree can be constructed by first half of List.\\n\\t2. Right subtree can be constructed ny second half of List \\n```\\n\\n**DO UPVOTE if you find it helpful!!**\\n\\n```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        return ToBST(head,NULL);\\n    }\\n    TreeNode* ToBST(ListNode* head, ListNode* tail){\\n        if(head==tail)\\n            return NULL;\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast != tail &&fast->next != tail){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=ToBST(head,slow);\\n        root->right=ToBST(slow->next,tail);\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n-> we want height of the BST to balanced, which can be acheived by selecting mid of List as root of BST.\\n-> follow the same for both left and right trees by calling the function ToBST recursively.\\n\\t1. Left substree can be constructed by first half of List.\\n\\t2. Right subtree can be constructed ny second half of List \\n```\n```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        return ToBST(head,NULL);\\n    }\\n    TreeNode* ToBST(ListNode* head, ListNode* tail){\\n        if(head==tail)\\n            return NULL;\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast != tail &&fast->next != tail){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=ToBST(head,slow);\\n        root->right=ToBST(slow->next,tail);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282693,
                "title": "c-o-1-space-using-middle-of-the-linked-list-readable-commented-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // Finds the middle of the linked list\\n    ListNode *middleNode(ListNode *head)\\n    {\\n        ListNode *slow = head, *fast = head;\\n        while (fast and fast->next)\\n            slow = slow->next, fast = fast->next->next;\\n        return slow;\\n    }\\n\\n    TreeNode *build(ListNode *head)\\n    {\\n        // If the list is empty then return null\\n        if (!head)\\n            return NULL;\\n\\n        // If the list contains only one element then return TreeNode of that value\\n        if (middleNode(head) == head)\\n            return new TreeNode(head->val);\\n\\n        // Finding the middle node\\n        ListNode *middle = middleNode(head);\\n\\n        // Making middle node as root\\n        TreeNode *root = new TreeNode(middle->val);\\n\\n        // Dividing list into to parts\\n        // 1. Left part will have elements which is left to \\'middle\\' node\\n        // 2. Right part will have elements which is right to \\'middle\\' node\\n        ListNode *ptr = head;\\n        while (ptr->next != middle)\\n            ptr = ptr->next;\\n\\n        ListNode *first = head;\\n        ListNode *second = middle->next;\\n\\n        // Removing middle from the list\\n        ptr->next = NULL;\\n        middle->next = NULL;\\n\\n        // building BST recursively\\n        root->left = build(first);\\n        root->right = build(second);\\n\\n        // returning root\\n        return root;\\n    }\\n\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        if (!head)\\n            return NULL;\\n        return build(head);\\n    }\\n};\\n```\\n\\n### [Middle Of the Linked List (LeetCode)](https://leetcode.com/problems/middle-of-the-linked-list/description/)",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Finds the middle of the linked list\\n    ListNode *middleNode(ListNode *head)\\n    {\\n        ListNode *slow = head, *fast = head;\\n        while (fast and fast->next)\\n            slow = slow->next, fast = fast->next->next;\\n        return slow;\\n    }\\n\\n    TreeNode *build(ListNode *head)\\n    {\\n        // If the list is empty then return null\\n        if (!head)\\n            return NULL;\\n\\n        // If the list contains only one element then return TreeNode of that value\\n        if (middleNode(head) == head)\\n            return new TreeNode(head->val);\\n\\n        // Finding the middle node\\n        ListNode *middle = middleNode(head);\\n\\n        // Making middle node as root\\n        TreeNode *root = new TreeNode(middle->val);\\n\\n        // Dividing list into to parts\\n        // 1. Left part will have elements which is left to \\'middle\\' node\\n        // 2. Right part will have elements which is right to \\'middle\\' node\\n        ListNode *ptr = head;\\n        while (ptr->next != middle)\\n            ptr = ptr->next;\\n\\n        ListNode *first = head;\\n        ListNode *second = middle->next;\\n\\n        // Removing middle from the list\\n        ptr->next = NULL;\\n        middle->next = NULL;\\n\\n        // building BST recursively\\n        root->left = build(first);\\n        root->right = build(second);\\n\\n        // returning root\\n        return root;\\n    }\\n\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        if (!head)\\n            return NULL;\\n        return build(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549841,
                "title": "c-dsw",
                "content": "We can apply the second part of DSW algorithm here. For more details, see a similar solution for [1382. Balance a Binary Search Tree](https://leetcode.com/problems/balance-a-binary-search-tree/discuss/541785/C%2B%2BJava-with-picture-DSW-O(n)orO(1)).\\n\\nFirst, we can create a vine (or backbone) tree directly from the linked list. Then, using left rotations, we turn the vine into the ballanced tree.\\n\\n```cpp\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}    \\nTreeNode* sortedListToBST(ListNode* head) {\\n    TreeNode grand;\\n    TreeNode *node = &grand;\\n    int cnt = 0;\\n    while (head != nullptr) {\\n        ++cnt;\\n        node->right = new TreeNode(head->val);\\n        node = node->right;\\n        head = head->next;\\n    }\\n    int m = pow(2, int(log2(cnt + 1))) - 1;\\n    compress(&grand, cnt - m);\\n    for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n    return grand.right;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(1). There is no recursion and we do create any data structure besides the tree itself.",
                "solutionTags": [],
                "code": "```cpp\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}    \\nTreeNode* sortedListToBST(ListNode* head) {\\n    TreeNode grand;\\n    TreeNode *node = &grand;\\n    int cnt = 0;\\n    while (head != nullptr) {\\n        ++cnt;\\n        node->right = new TreeNode(head->val);\\n        node = node->right;\\n        head = head->next;\\n    }\\n    int m = pow(2, int(log2(cnt + 1))) - 1;\\n    compress(&grand, cnt - m);\\n    for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n    return grand.right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282713,
                "title": "sorted-linked-list-to-balanced-bst-recursive-slow-fast-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, we see we have to balance the height so the best way to choose the root is such that there are mostly an equal number of values on both ends. Then, call the same approach for the left and right subparts of the linked list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we try to discover the base cases:\\n\\nIf the list is empty, we have to do nothing as there will be no element in the BST and we simply return NULL.\\nIf there is only one element in the list, the sole element in the list will be the root, and thus we return the node which will be assigned with head->val.\\nNow we have cleared all the base cases and move onto the real task, which is how to find the mid of the LinkedList. We use the concept of slow and fast pointers. If we want to find the mid of, for example,\\n1 2 3 4 5,\\nwe assign fast and slow pointers to head, which is the first node of the linked list, and we try to move slow one step at a time until our fast pointer reaches the last node or second last node of the list.\\n\\nFirst Iteration: Slow: 2 and Fast: 3.\\nSecond Iteration: Slow: 3 and Fast: 5.\\nWe stop here as we cannot move the fast pointer further.\\nNow we have found the mid element, which is slow, and add it to the tree:\\n\\nTreeNode *root = new TreeNode(slow->val);\\n\\nand call the SortedListToBST function for the left part of the linked list (head to prev where pre is the pointer just before slow) and the right part (from slow->next to end) as follows:\\n\\npre->next = NULL;\\nroot->left = SortedListToBST(head);\\nroot->right = SortedListToBST(slow->next);\\n\\nFinally we return the root\\n\\n\\n\\n\\n\\n# Complexity\\nTime complexity:\\nO(NlogN) where N is the size of the linked list.\\n\\nSpace complexity:\\nO(logN) as in the worst case, the maximum number of elements in the recursion tree will be logN.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return new TreeNode(head->val);\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        ListNode *prev=head;\\n        while(fast && fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode *root = new TreeNode(slow->val);\\n        prev->next=NULL;\\n        root->left=sortedListToBST(head);\\n        root->right=sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```\\n<img src=\"https://steemitimages.com/p/7ohP4GDMGPrUi4qw3TPEWfuCDmSuTPmBXGkQRjfyZswY5pR3tTkEohRmm23uDrcGV1ikBAnciRrryiVsxHVhX95oT5UG3EBrbUfY?format=match&mode=fit&width=640\" alt=\"drawing\" height=\"150\"/>\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return new TreeNode(head->val);\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        ListNode *prev=head;\\n        while(fast && fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode *root = new TreeNode(slow->val);\\n        prev->next=NULL;\\n        root->left=sortedListToBST(head);\\n        root->right=sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678147,
                "title": "c-3-different-approaches-clean-code",
                "content": "Please let me know if you have another approach for this problem or if you have suggestions for one of the existing approaches.\\n\\n\\n### Approach 1: convert to vector and recursion\\n\\nThis is maybe a bit cheating, but this is a fast solution. This is building up on the solution for problem [108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/).\\n\\n```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        vector<int> nums;\\n        while (head) {\\n            nums.push_back(head->val);\\n            head = head->next;\\n        }\\n        return sortedArrayToBST(cbegin(nums), cend(nums));\\n    }\\n    \\n    template <typename iterator>\\n    static TreeNode* sortedArrayToBST(iterator b, iterator e) {\\n        if (b == e) return nullptr;\\n        \\n        iterator mid = next(b, distance(b, e) / 2);\\n        return\\n            new TreeNode(\\n                *mid,\\n                sortedArrayToBST(b, mid),\\n                sortedArrayToBST(next(mid), e));\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$ as we need to visit each node.\\n  * Space complexity: $$O(n)$$ for the temporary vector. The stack space only grows with $$O(\\\\log n)$$, but we are also creating $$O(n)$$ ```TreeNode```s as output.\\n\\n\\n### Approach 2: repeatedly find the list midpoint, recursively\\n\\nIn this approach we are not using a temporary vector, we just find the mid point every time with a fast and slow pointer. Besides from this the approach is basically the same as approach 1.\\n\\n```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        return sortedListToBST(head, nullptr);\\n    }\\n\\n    static TreeNode* sortedListToBST(const ListNode* b, const ListNode* e) {\\n        if (b == e) return nullptr;\\n        \\n        // Find the midpoint between |b| and |e| using a fast and slow pointer.\\n        const ListNode* mid = b;\\n        const ListNode* fast = b;\\n        \\n        while (fast != e && fast->next != e) {\\n            fast = fast->next->next;\\n            mid = mid->next;\\n        }\\n        \\n        return\\n            new TreeNode(\\n                mid->val,\\n                sortedListToBST(b, mid),\\n                sortedListToBST(mid->next, e));\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n \\\\log n)$$ because the list is of length $$n$$ and we need to scan the list $$\\\\log n$$ times.\\n  * Space complexity: $$O(\\\\log n)$$ for the implict call stack, we are creating $$O(n)$$ ```TreeNode```s though as the output.\\n\\n\\n### Approach 3: simulate inorder traversal\\n\\n```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        return sortedListToBST(head, 0, listSize(head));\\n    }\\n\\n    static int listSize(const ListNode* head) {\\n        int length = 0;\\n        while (head) {\\n            head = head->next;\\n            ++length;\\n        }\\n        return length;\\n    }\\n\\n    static TreeNode* sortedListToBST(const ListNode*& node, int b, int e) {\\n        if (b == e) return nullptr;\\n        \\n        const int mid = b + (e - b) / 2;\\n\\n        // Construct the left sub-tree.\\n        TreeNode* left = sortedListToBST(node, b, mid);\\n        // Consume the next node in the list.\\n        const int val = node->val;\\n        node = node->next;\\n        // Construct the right sub-tree.\\t\\t\\n        TreeNode* right = sortedListToBST(node, mid + 1, e);\\n\\n        return new TreeNode(val, left, right);\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$ we still need to visit all the nodes.\\n  * Space complexity: $$O(\\\\log n)$$ for the call stack, but we still need $$O(n)$$ for the output.\\n\\n### Bonus Approach: custom stl iterator\\n\\nThe core logic looks like approach 1, but in reality it\\'s more like approach 2, with the down side that the ```std::distance()``` will loop over parts of the the linked list again and again. It was still fun to code this up. :)\\n\\n```cpp\\nstruct Iterator \\n{\\n    using iterator_category = std::forward_iterator_tag;\\n    using difference_type   = std::ptrdiff_t;\\n    using value_type        = int;\\n    using pointer           = value_type*;\\n    using reference         = value_type&;\\n    \\n    Iterator(ListNode* head) : curr_(head) {}\\n    \\n    reference operator*() const { return curr_->val; }\\n    pointer operator->() { return &(curr_->val); }\\n\\n    // Prefix increment\\n    Iterator& operator++() {\\n        curr_ = curr_->next;\\n        return *this;\\n    }  \\n\\n    // Postfix increment\\n    Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\\n\\n    friend bool operator== (const Iterator& a, const Iterator& b) {\\n        return a.curr_ == b.curr_;\\n    };\\n    friend bool operator!= (const Iterator& a, const Iterator& b) { return !(a == b); }\\n    \\nprivate:\\n    ListNode* curr_;\\n};\\n\\nstruct Iterator begin(ListNode* head) {\\n    return Iterator(head);\\n}\\n\\nstruct Iterator end(ListNode* head) {\\n    return Iterator(nullptr);\\n}\\n\\nclass Solution {\\npublic:\\n    static TreeNode* sortedListToBST(ListNode* head) {\\n        return sortedListToBST(begin(head), end(head));\\n    }\\n    \\n    template <typename iterator>\\n    static TreeNode* sortedListToBST(iterator b, iterator e) {\\n        if (b == e) return nullptr;\\n        \\n        iterator mid = next(b, distance(b, e) / 2);\\n        return\\n            new TreeNode(\\n                *mid,\\n                sortedArrayToBST(b, mid),\\n                sortedArrayToBST(next(mid), e));\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\nThis is basically the same as approach 2, while the constant factor is larger the time complexity doesn\\'t change.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        vector<int> nums;\\n        while (head) {\\n            nums.push_back(head->val);\\n            head = head->next;\\n        }\\n        return sortedArrayToBST(cbegin(nums), cend(nums));\\n    }\\n    \\n    template <typename iterator>\\n    static TreeNode* sortedArrayToBST(iterator b, iterator e) {\\n        if (b == e) return nullptr;\\n        \\n        iterator mid = next(b, distance(b, e) / 2);\\n        return\\n            new TreeNode(\\n                *mid,\\n                sortedArrayToBST(b, mid),\\n                sortedArrayToBST(next(mid), e));\\n    }\\n```\n```TreeNode```\n```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        return sortedListToBST(head, nullptr);\\n    }\\n\\n    static TreeNode* sortedListToBST(const ListNode* b, const ListNode* e) {\\n        if (b == e) return nullptr;\\n        \\n        // Find the midpoint between |b| and |e| using a fast and slow pointer.\\n        const ListNode* mid = b;\\n        const ListNode* fast = b;\\n        \\n        while (fast != e && fast->next != e) {\\n            fast = fast->next->next;\\n            mid = mid->next;\\n        }\\n        \\n        return\\n            new TreeNode(\\n                mid->val,\\n                sortedListToBST(b, mid),\\n                sortedListToBST(mid->next, e));\\n    }\\n```\n```TreeNode```\n```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        return sortedListToBST(head, 0, listSize(head));\\n    }\\n\\n    static int listSize(const ListNode* head) {\\n        int length = 0;\\n        while (head) {\\n            head = head->next;\\n            ++length;\\n        }\\n        return length;\\n    }\\n\\n    static TreeNode* sortedListToBST(const ListNode*& node, int b, int e) {\\n        if (b == e) return nullptr;\\n        \\n        const int mid = b + (e - b) / 2;\\n\\n        // Construct the left sub-tree.\\n        TreeNode* left = sortedListToBST(node, b, mid);\\n        // Consume the next node in the list.\\n        const int val = node->val;\\n        node = node->next;\\n        // Construct the right sub-tree.\\t\\t\\n        TreeNode* right = sortedListToBST(node, mid + 1, e);\\n\\n        return new TreeNode(val, left, right);\\n    }\\n```\n```std::distance()```\n```cpp\\nstruct Iterator \\n{\\n    using iterator_category = std::forward_iterator_tag;\\n    using difference_type   = std::ptrdiff_t;\\n    using value_type        = int;\\n    using pointer           = value_type*;\\n    using reference         = value_type&;\\n    \\n    Iterator(ListNode* head) : curr_(head) {}\\n    \\n    reference operator*() const { return curr_->val; }\\n    pointer operator->() { return &(curr_->val); }\\n\\n    // Prefix increment\\n    Iterator& operator++() {\\n        curr_ = curr_->next;\\n        return *this;\\n    }  \\n\\n    // Postfix increment\\n    Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\\n\\n    friend bool operator== (const Iterator& a, const Iterator& b) {\\n        return a.curr_ == b.curr_;\\n    };\\n    friend bool operator!= (const Iterator& a, const Iterator& b) { return !(a == b); }\\n    \\nprivate:\\n    ListNode* curr_;\\n};\\n\\nstruct Iterator begin(ListNode* head) {\\n    return Iterator(head);\\n}\\n\\nstruct Iterator end(ListNode* head) {\\n    return Iterator(nullptr);\\n}\\n\\nclass Solution {\\npublic:\\n    static TreeNode* sortedListToBST(ListNode* head) {\\n        return sortedListToBST(begin(head), end(head));\\n    }\\n    \\n    template <typename iterator>\\n    static TreeNode* sortedListToBST(iterator b, iterator e) {\\n        if (b == e) return nullptr;\\n        \\n        iterator mid = next(b, distance(b, e) / 2);\\n        return\\n            new TreeNode(\\n                *mid,\\n                sortedArrayToBST(b, mid),\\n                sortedArrayToBST(next(mid), e));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194230,
                "title": "convert-sorted-list-to-bst-js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to build a **height-balanced binary tree**, we need to ensure that roughly half of the total number of nodes are on either side of the root, and the only way to know what half of the total number of nodes is requires finding the total number of nodes first.\\n\\nWith this in mind, one easy solution would be to convert the linked list to an array, then we have handy access not only to the total length of the array, but also index-access to the node values, as well. At that point, we could define a **recursive** helper to build a tree from the middle node, recursively calling itself to build subtrees from the nodes on the left and right of the middle node. This option would take an **extra O(N) space** to complete.\\n\\nShould we not want to use up that much extra space, we could instead keep the linked list and lose the index-access nature of the array, using **Floyd\\'s Cycle Detection Algorithm** to easily find the middle node on each recursion step. This would, however, require iterating through parts of the linked list repeatedly, driving the **time complexity** from **O(N)** to **O(N log N)**.\\n\\nBut we can do even better: We can complete this problem in **O(N) time** with only **O(log N) extra space** (in excess of the output space).\\n\\nFirst, we\\'ll have to iterate once through the linked list to count the total number of nodes (**count**). Then, we can define our recursive helper (**treeify()**)using index numbers as our arguments. Even though we won\\'t be able to access the listnodes directly by index number, we can take advantage of an **inorder tree traversal** to force our access to go in iterative order.\\n\\nWe\\'ll need to have our list pointer (**curr**) have global scope in order to update properly via recursion. In an inorder traversal, we recursively process the left subtree, then process the middle node, then recursively process the right subtree. For this solution, we\\'ll just need to make sure we move **curr** to **curr.next** at the end of processing the middle node.\\n\\nWe can then **return** the full tree built by our recursive helper.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of the linked list_\\n - _**Space Complexity: O(log N)** in excess of the space needed for the input/output, due to the recursion stack_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Python, we can store our list index pointer (**curr**) in a list to give it global scope so that it will update properly.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **92ms / 43.6MB** (beats 91% / 95%).\\n```javascript\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **120ms / 20.0MB** (beats 95% / 60%).\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        curr, count = head, 0\\n        while curr:\\n            curr = curr.next\\n            count += 1\\n        def treeify(i: int, j: int) -> TreeNode:\\n            if j < i: return None\\n            mid, node = i + j >> 1, TreeNode()\\n            node.left = treeify(i, mid - 1)\\n            node.val, curr[0] = curr[0].val, curr[0].next\\n            node.right = treeify(mid + 1, j)\\n            return node\\n        curr = [head]\\n        return treeify(1, count)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 39.8MB** (beats 100% / 56%).\\n```java\\nclass Solution {\\n    ListNode curr;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr != null) {\\n            curr = curr.next;\\n            count++;\\n        }\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n    private TreeNode treeify(int i, int j) {\\n        if (j < i) return null;\\n        int mid = i + j >> 1;\\n        TreeNode node = new TreeNode();\\n        node.left = treeify(i, mid - 1);\\n        node.val = curr.val;\\n        curr = curr.next;\\n        node.right = treeify(mid + 1, j);\\n        return node;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **16ms / 30.9MB** (beats 100% / 68%).\\n```c++\\nclass Solution {\\nprivate:\\n    ListNode* curr;\\n    TreeNode* treeify(int i, int j) {\\n        if (j < i) return nullptr;\\n        int mid = (i + j) >> 1;\\n        TreeNode* node = new TreeNode();\\n        node->left = treeify(i, mid - 1);\\n        node->val = curr->val, curr = curr->next;\\n        node->right = treeify(mid + 1, j);\\n        return node;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr) curr = curr->next, count++;\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        curr, count = head, 0\\n        while curr:\\n            curr = curr.next\\n            count += 1\\n        def treeify(i: int, j: int) -> TreeNode:\\n            if j < i: return None\\n            mid, node = i + j >> 1, TreeNode()\\n            node.left = treeify(i, mid - 1)\\n            node.val, curr[0] = curr[0].val, curr[0].next\\n            node.right = treeify(mid + 1, j)\\n            return node\\n        curr = [head]\\n        return treeify(1, count)\\n```\n```java\\nclass Solution {\\n    ListNode curr;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr != null) {\\n            curr = curr.next;\\n            count++;\\n        }\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n    private TreeNode treeify(int i, int j) {\\n        if (j < i) return null;\\n        int mid = i + j >> 1;\\n        TreeNode node = new TreeNode();\\n        node.left = treeify(i, mid - 1);\\n        node.val = curr.val;\\n        curr = curr.next;\\n        node.right = treeify(mid + 1, j);\\n        return node;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\nprivate:\\n    ListNode* curr;\\n    TreeNode* treeify(int i, int j) {\\n        if (j < i) return nullptr;\\n        int mid = (i + j) >> 1;\\n        TreeNode* node = new TreeNode();\\n        node->left = treeify(i, mid - 1);\\n        node->val = curr->val, curr = curr->next;\\n        node->right = treeify(mid + 1, j);\\n        return node;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr) curr = curr->next, count++;\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684494,
                "title": "c-2-different-solutions-detailed-explanation",
                "content": "**SOLUTION 1**\\n\\nTo get a height balanced tree from sorted elements, we make the middle element as the\\nroot and recurse its left and right sides for left and right subtrees respectively.\\n\\nSince we are not working with an array, we cant access a data element directly by its position\\nand hence cant use a merge sort like logic directly. So we use tortoise-hare algo to find the middle \\nnode of linked list, use that to split the list in two parts. The next node becomes the root node and \\nthe node after that becomes the head of the second list.\\n\\nT(n) = T(n/2) + O(n)\\n\\t= O(nlogn)\\nSC: O(logn), recursive stack\\n```\\n/*\\n    https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/submissions/\\n*/\\n\\nclass Solution {\\npublic:\\n    /*****************************  SOLUTION 1 ************************************/\\n    \\n    // Finds floor(N/2), 1-based indexing\\n    ListNode* findMiddle(ListNode* head) {\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while(slow && fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    // TC: O(nlogn)\\n    TreeNode* logSolution(ListNode* head) {\\n        // base case: when 0 or 1 node\\n        if(!head)\\n            return nullptr;\\n        if(!head->next)\\n            return new TreeNode(head->val);\\n        \\n        // find the middle node, use it as the end of first list\\n        ListNode *mid = findMiddle(head);\\n        // create tree node with next of middle node\\n        TreeNode* root = new TreeNode(mid->next->val);\\n        \\n        // split the two lists\\n        ListNode *second_head = (mid->next)->next;\\n        mid->next = nullptr;\\n        \\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(second_head);\\n        \\n        return root;\\n    }\\n```\\n\\n**SOLUTION 2**\\n\\nThe main time consuming part in above solution is finding the middle each time, we\\ncan actually reduce that part. The idea is to make the current head point to the middle element \\nin each recursive call with elements from [l:r]. This can be done by making the tree in inorder fashion\\nand keep a reference to the list head across all the calls. Everytime we create a node, we traverse the\\nnode by 1 step.\\nEg: index range: [1:3] and list: 1->2->3, head=1\\nWhen we reach 1([1:1]), we create 1, update head=2\\nSo when we go to the parent recursive call with limit[1:3], our head point to middle 2 and \\ncreate a node with that, head=3.\\nIn [3:3] our head =3, which is the node req. \\n\\nT(n) = T(n/2) + O(1)\\n\\t= O(n)\\nSC: O(logn), recursive stack\\n```\\n    /*************************************** SOLUTION 2 **************************/\\n    // Finds the total number of nodes in list\\n    int listCount(ListNode* head) {\\n        ListNode *curr = head;\\n        int c = 0;\\n        \\n        while(curr) {\\n            ++c;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n    \\n    // TC: O(n)\\n    // Create the tree in inorder manner.\\n    TreeNode* linearSolution(ListNode*& head, int n) {\\n        // base case: when 0 or 1 node\\n        if(n == 0)\\n            return nullptr;\\n        \\n        TreeNode *left = linearSolution(head, n/2);\\n        \\n        // create the root node\\n        TreeNode *root = new TreeNode(head->val);\\n        // go to the next node in list, so that\\n        // it will middle node in its previous call\\n        head = head->next;\\n        root->left = left;\\n        \\n        root->right = linearSolution(head, n - n/2 - 1);\\n        return root;\\n    }\\n```\\n\\n**Driver function**\\n``` \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        //return logSolution(head);\\n        \\n        // find the number of nodes in list\\n        int n_nodes = listCount(head);\\n        return linearSolution(head, n_nodes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/submissions/\\n*/\\n\\nclass Solution {\\npublic:\\n    /*****************************  SOLUTION 1 ************************************/\\n    \\n    // Finds floor(N/2), 1-based indexing\\n    ListNode* findMiddle(ListNode* head) {\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while(slow && fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    // TC: O(nlogn)\\n    TreeNode* logSolution(ListNode* head) {\\n        // base case: when 0 or 1 node\\n        if(!head)\\n            return nullptr;\\n        if(!head->next)\\n            return new TreeNode(head->val);\\n        \\n        // find the middle node, use it as the end of first list\\n        ListNode *mid = findMiddle(head);\\n        // create tree node with next of middle node\\n        TreeNode* root = new TreeNode(mid->next->val);\\n        \\n        // split the two lists\\n        ListNode *second_head = (mid->next)->next;\\n        mid->next = nullptr;\\n        \\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(second_head);\\n        \\n        return root;\\n    }\\n```\n```\\n    /*************************************** SOLUTION 2 **************************/\\n    // Finds the total number of nodes in list\\n    int listCount(ListNode* head) {\\n        ListNode *curr = head;\\n        int c = 0;\\n        \\n        while(curr) {\\n            ++c;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n    \\n    // TC: O(n)\\n    // Create the tree in inorder manner.\\n    TreeNode* linearSolution(ListNode*& head, int n) {\\n        // base case: when 0 or 1 node\\n        if(n == 0)\\n            return nullptr;\\n        \\n        TreeNode *left = linearSolution(head, n/2);\\n        \\n        // create the root node\\n        TreeNode *root = new TreeNode(head->val);\\n        // go to the next node in list, so that\\n        // it will middle node in its previous call\\n        head = head->next;\\n        root->left = left;\\n        \\n        root->right = linearSolution(head, n - n/2 - 1);\\n        return root;\\n    }\\n```\n``` \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        //return logSolution(head);\\n        \\n        // find the number of nodes in list\\n        int n_nodes = listCount(head);\\n        return linearSolution(head, n_nodes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282008,
                "title": "explanation-with-images-easy-to-understand-simple-recursion",
                "content": "**startNode = start Node of curr Linked List\\nendNode = last Node of curr Linked List\\nnextToEndNode = next Node after end node (End of list marker)**\\n\\n![image](https://assets.leetcode.com/users/images/7b753a68-84c6-4b55-8f36-507cd2f33d10_1678497231.1457791.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* getMidNode(ListNode* start, ListNode* nextToEnd)\\n    {\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        while(fast != nextToEnd && fast->next != nextToEnd)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        return slow;\\n    }\\n    TreeNode* getRoot(ListNode* startNode, ListNode* nextToEndNode)\\n    {\\n        if (startNode == nextToEndNode) return NULL;  //Most important \\n        \\n        ListNode* midNode =  getMidNode(startNode, nextToEndNode);\\n        TreeNode* currRoot = new TreeNode(midNode->val);\\n        \\n        currRoot->left = getRoot(startNode, midNode);\\n        currRoot->right = getRoot(midNode->next, nextToEndNode);\\n        \\n        return currRoot;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head)\\n    {\\n        TreeNode* root = getRoot(head, NULL);\\n        return root;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* getMidNode(ListNode* start, ListNode* nextToEnd)\\n    {\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        while(fast != nextToEnd && fast->next != nextToEnd)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        return slow;\\n    }\\n    TreeNode* getRoot(ListNode* startNode, ListNode* nextToEndNode)\\n    {\\n        if (startNode == nextToEndNode) return NULL;  //Most important \\n        \\n        ListNode* midNode =  getMidNode(startNode, nextToEndNode);\\n        TreeNode* currRoot = new TreeNode(midNode->val);\\n        \\n        currRoot->left = getRoot(startNode, midNode);\\n        currRoot->right = getRoot(midNode->next, nextToEndNode);\\n        \\n        return currRoot;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head)\\n    {\\n        TreeNode* root = getRoot(head, NULL);\\n        return root;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779781,
                "title": "c-solutions",
                "content": "```\\n  class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head) {\\n            if(!head) return NULL;\\n            if(!head->next) return new TreeNode(head->val);\\n            \\n            // fast/slow pointer to find the midpoint\\n            auto slow = head;\\n            auto fast = head;\\n            auto pre = head;\\n            while(fast && fast->next) {\\n                pre = slow;\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }\\n            pre->next = 0; // break two halves \\n            \\n            // slow is the midpoint, use as root\\n            TreeNode* root = new TreeNode(slow->val);\\n            root->left = sortedListToBST(head);\\n            root->right = sortedListToBST(slow->next);\\n            \\n            return root;\\n        }\\n    };\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head) {\\n            if(!head) return NULL;\\n            if(!head->next) return new TreeNode(head->val);\\n            \\n            // fast/slow pointer to find the midpoint\\n            auto slow = head;\\n            auto fast = head;\\n            auto pre = head;\\n            while(fast && fast->next) {\\n                pre = slow;\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }\\n            pre->next = 0; // break two halves \\n            \\n            // slow is the midpoint, use as root\\n            TreeNode* root = new TreeNode(slow->val);\\n            root->left = sortedListToBST(head);\\n            root->right = sortedListToBST(slow->next);\\n            \\n            return root;\\n        }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753913,
                "title": "python-recursive-solution-100-speed",
                "content": "**Python, Recursive Solution | 100% Speed**\\n\\n**A) Simple Solution using Recursion**\\n\\nThe code below presents a simple Python Solution that achieves up to 99% Speed rating on LeetCode. We simply create an array with all nodes in the Linked List that we are given, and then choose the middle node as the root. We repeat this process recursively until we build our BST (Binary Search Tree).\\n\\n```\\nclass Solution:\\n    def make(self,A):\\n        if A:\\n            m       =  len(A)//2\\n            n       =  TreeNode(A[m])\\n            n.left  = self.make(A[   :m])\\n            n.right = self.make(A[m+1:] )\\n            return n\\n    def sortedListToBST(self, head):\\n        A, n = [], head\\n        while n:\\n            A.append(n.val)\\n            n = n.next\\n        return self.make(A)\\n```\\n\\n**B) Optimized Code (Array Pointers)**\\n\\nDespite the High Speed rating of Solution (A), we can note that the code copies snippets of the initial array in every function call. While this process still has O(n) time complexity overall, it\\'s more efficient to use pointers to a global array instead. The code below presents an alternative:\\n\\n```\\nclass Solution:\\n    def sortedListToBST(self, head):\\n        A, n = [], head\\n        while n:\\n            A.append(n.val)\\n            n = n.next\\n        def make(i,j):\\n            if i<=j:\\n                m       =  (i+j)//2\\n                n       = TreeNode(A[m])\\n                n.left  = make(i  ,m-1)\\n                n.right = make(m+1,j  )\\n                return n\\n        return make(0, len(A)-1)\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def make(self,A):\\n        if A:\\n            m       =  len(A)//2\\n            n       =  TreeNode(A[m])\\n            n.left  = self.make(A[   :m])\\n            n.right = self.make(A[m+1:] )\\n            return n\\n    def sortedListToBST(self, head):\\n        A, n = [], head\\n        while n:\\n            A.append(n.val)\\n            n = n.next\\n        return self.make(A)\\n```\n```\\nclass Solution:\\n    def sortedListToBST(self, head):\\n        A, n = [], head\\n        while n:\\n            A.append(n.val)\\n            n = n.next\\n        def make(i,j):\\n            if i<=j:\\n                m       =  (i+j)//2\\n                n       = TreeNode(A[m])\\n                n.left  = make(i  ,m-1)\\n                n.right = make(m+1,j  )\\n                return n\\n        return make(0, len(A)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928048,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\\n        var nums: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nums.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        return sortedArrayToBST(nums)\\n    }\\n    \\n    \\n    func sortedArrayToBST(_ nums: [ListNode]) -> TreeNode? {\\n        let count = nums.count\\n        guard count > 0 else { return nil }\\n        \\n        let rootIndex = count / 2\\n        let root = TreeNode(nums[rootIndex].val)\\n        \\n        root.left = rootIndex > 0 ? sortedArrayToBST(Array(nums[0..<rootIndex])) : nil\\n        root.right = rootIndex < count - 1 ? sortedArrayToBST(Array(nums[rootIndex + 1..<count])) : nil\\n        return root\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\\n        var nums: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nums.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        return sortedArrayToBST(nums)\\n    }\\n    \\n    \\n    func sortedArrayToBST(_ nums: [ListNode]) -> TreeNode? {\\n        let count = nums.count\\n        guard count > 0 else { return nil }\\n        \\n        let rootIndex = count / 2\\n        let root = TreeNode(nums[rootIndex].val)\\n        \\n        root.left = rootIndex > 0 ? sortedArrayToBST(Array(nums[0..<rootIndex])) : nil\\n        root.right = rootIndex < count - 1 ? sortedArrayToBST(Array(nums[rootIndex + 1..<count])) : nil\\n        return root\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35636,
                "title": "my-simple-java-solution",
                "content": "\\npublic class Solution {\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\n        if (head == null) { return null; }\\n        if (head.next == null) { return new TreeNode(head.val); }\\n\\n        ListNode mid = head;\\n        ListNode pre_mid = null;\\n        ListNode fast = head;\\n\\n        while (true) {\\n            if (fast != null && fast.next != null) {\\n                fast = fast.next.next;\\n            } else {\\n                break;\\n            }\\n            pre_mid = mid;\\n            mid = mid.next;\\n        }\\n        if (pre_mid != null)\\n            pre_mid.next = null;\\n\\n\\n        TreeNode root = new TreeNode(mid.val);\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(mid.next);\\n\\n        return root;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\n        if (head == null) { return null; }",
                "codeTag": "Java"
            },
            {
                "id": 1194192,
                "title": "visual-explanation-simple-solution-using-recursion",
                "content": "**Approach**\\nFind middle of the list using slow and fast pointer. Finding mid will ensure that left and right subtrees are balanced. \\n\\n```\\n// find mid of the list\\nwhile (fast!=tail && fast->next!=tail) {\\n     slow = slow->next;\\n     fast = fast->next->next;\\n}\\n```\\n\\nNow after this slow will point to the middle node, which can be allocated to root of the tree, and we can do same thing for left and right of subtree.\\n\\n`head to slow : Left Tree = Left half of the list`\\n`slow->next to tail : Right Tree = Right half of the list`\\n\\nWe have shown the graphical rep of left subtree construction from half of the list, Similar happens for right list --\\n\\n![image](https://assets.leetcode.com/users/images/eaa57f11-2c0e-48c7-8d4e-07a0e7904cba_1620296733.8417244.png)\\n\\n\\nSolving furthur \\n![image](https://assets.leetcode.com/users/images/2f341b50-f1ce-432f-bee4-cdfc74c5979f_1620296769.1294112.png)\\n\\nand finally - \\n![image](https://assets.leetcode.com/users/images/daf689fe-8f94-4516-9c02-b05a3103b85c_1620296797.1408124.png)\\n\\nSimilarly for Right half, and we get the required balanced tree.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* helper(ListNode* head, ListNode* tail) {\\n        \\n        if (head == tail)\\n            return NULL;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        // find mid of the list\\n        while (fast!=tail && fast->next!=tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = helper(head, slow);\\n        root->right = helper(slow->next, tail);\\n        return root;\\n        \\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return helper(head, NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// find mid of the list\\nwhile (fast!=tail && fast->next!=tail) {\\n     slow = slow->next;\\n     fast = fast->next->next;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* helper(ListNode* head, ListNode* tail) {\\n        \\n        if (head == tail)\\n            return NULL;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        // find mid of the list\\n        while (fast!=tail && fast->next!=tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = helper(head, slow);\\n        root->right = helper(slow->next, tail);\\n        return root;\\n        \\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return helper(head, NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35567,
                "title": "java-fast-slow-pointer-recursive-solution",
                "content": "        \\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null; \\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode fast = head, slow = head;\\n        if (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n        }\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        TreeNode node = new TreeNode(slow.next.val);\\n        node.right = sortedListToBST(slow.next.next);\\n        slow.next = null;\\n        node.left = sortedListToBST(head);\\n        return node;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "        \\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null; \\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode fast = head, slow = head;\\n        if (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n        }\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        TreeNode node = new TreeNode(slow.next.val);\\n        node.right = sortedListToBST(slow.next.next);\\n        slow.next = null;\\n        node.left = sortedListToBST(head);\\n        return node;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 35564,
                "title": "my-accepted-cpp-answer-clear-and-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            return buildTree(head,nullptr);\\n        }\\n        TreeNode* buildTree(ListNode* head, ListNode* afterLast){\\n            if(head==afterLast)\\n            return nullptr;\\n            ListNode* fast=head;\\n            ListNode* slow=head;\\n            while(fast!=afterLast&&fast->next!=afterLast){\\n                slow=slow->next;\\n                fast=fast->next->next;\\n            }\\n            TreeNode* root=new TreeNode(slow->val);\\n            root->left=buildTree(head,slow);\\n            root->right=buildTree(slow->next,afterLast);\\n            return root;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            return buildTree(head,nullptr);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3284395,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284126,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next == null) return new TreeNode(head.val);\\n        ListNode middle = getMiddle(head);\\n        TreeNode root = new TreeNode(middle.val);\\n        root.right = sortedListToBST(middle.next);\\n        middle.next =null;\\n        root.left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    public ListNode getMiddle(ListNode head){\\n        //if(head == null || head.next==null) return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            prev = slow;\\n            slow = slow.next;\\n            \\n        }\\n        if(prev!=null)prev.next =null;\\n        return slow;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next == null) return new TreeNode(head.val);\\n        ListNode middle = getMiddle(head);\\n        TreeNode root = new TreeNode(middle.val);\\n        root.right = sortedListToBST(middle.next);\\n        middle.next =null;\\n        root.left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    public ListNode getMiddle(ListNode head){\\n        //if(head == null || head.next==null) return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            prev = slow;\\n            slow = slow.next;\\n            \\n        }\\n        if(prev!=null)prev.next =null;\\n        return slow;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622424,
                "title": "find-middle-left-in-left-right-in-right-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(!head) return nullptr;\\n        \\n        if(!head->next) return new TreeNode(head->val);\\n        \\n        if(!head->next->next){\\n            TreeNode* r = new TreeNode(head->val);\\n            r->right = new TreeNode(head->next->val);\\n            return r;\\n        } \\n        \\n        ListNode*fast=head;\\n        ListNode*mid=head;\\n        ListNode*prev=mid;\\n        \\n        while(fast && fast->next){\\n             fast = fast->next->next;\\n             prev = mid;\\n             mid= mid->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(mid->val);\\n        prev->next = nullptr;\\n        root->left  = sortedListToBST(head);\\n        root->right = sortedListToBST(mid->next);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(!head) return nullptr;\\n        \\n        if(!head->next) return new TreeNode(head->val);\\n        \\n        if(!head->next->next){\\n            TreeNode* r = new TreeNode(head->val);\\n            r->right = new TreeNode(head->next->val);\\n            return r;\\n        } \\n        \\n        ListNode*fast=head;\\n        ListNode*mid=head;\\n        ListNode*prev=mid;\\n        \\n        while(fast && fast->next){\\n             fast = fast->next->next;\\n             prev = mid;\\n             mid= mid->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(mid->val);\\n        prev->next = nullptr;\\n        root->left  = sortedListToBST(head);\\n        root->right = sortedListToBST(mid->next);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35596,
                "title": "java-1ms-solution-easy-understood-the-main-idea-of-the-solution-is-similar-to-merge-sort",
                "content": "    //The main idea of the solution is similar to merge sort.(#148 Sort List https://leetcode.com/problems/sort-list/) \\n     //Divide the sorted list into halves. \\n     //The middle of the list is root. \\n     //The left half of the list is the left child of root. \\n     //The right half of the list is the right child of root. \\n     //Then do the same to the left child and right child recursively. \\n     //Pay attention to the type: ListNode TreeNode\\n    public class Solution {\\n        public TreeNode sortedListToBST(ListNode head) {\\n            if(head==null){\\n                return null;\\n            }\\n            if(head.next==null){\\n                TreeNode treeNode=new TreeNode(head.val);\\n                return treeNode;\\n            }\\n            ListNode slow=head;\\n            ListNode fast=head.next.next;\\n            while(fast!=null&&fast.next!=null){\\n                slow=slow.next;\\n                fast=fast.next.next;\\n            }\\n            TreeNode root=new TreeNode(slow.next.val);\\n            ListNode temp=slow.next.next;\\n            slow.next=null;\\n            root.left=sortedListToBST(head);\\n            root.right=sortedListToBST(temp);\\n            return root;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public TreeNode sortedListToBST(ListNode head) {\\n            if(head==null){\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1884288,
                "title": "c-recursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) \\n    {\\n        if(!head)\\n            return NULL;\\n        if(!head->next)\\n        {\\n            return new TreeNode(head->val);\\n        }\\n        ListNode *slow=head,*fast=head->next;\\n        while(fast->next&&fast->next->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            \\n        }\\n        ListNode *mid=slow->next;\\n        slow->next=NULL;\\n        \\n        TreeNode *root=new TreeNode(mid->val);\\n        root->left=sortedListToBST(head);\\n        root->right=sortedListToBST(mid->next);\\n        return root;\\n        \\n    }\\n};\\n// If you like the solution plz upvote",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) \\n    {\\n        if(!head)\\n            return NULL;\\n        if(!head->next)\\n        {\\n            return new TreeNode(head->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1354648,
                "title": "java-easy-approach-with-explanation-o-n-log-n-dfs-postorder",
                "content": "```\\nclass Solution \\n{\\n    public TreeNode sortedListToBST(ListNode head)\\n    {//DFS(postorder)\\n        if(head == null)//base case \\n            return null;\\n        if(head.next == null)//leaf node \\n            return new TreeNode(head.val, null, null);\\n    \\n        ListNode slow, fast, mid;\\n        mid= slow= fast= head;//intializing \\n        \\n        while(fast != null && fast.next != null)//terminating condition \\n        {\\n            mid= slow;//mid is like a previous pointer \\n            slow= slow.next;//one step\\n            fast= fast.next.next;//two step\\n        }\\n        mid.next= null;//to disconnect the list \\n        \\n        int data= slow.val;//root value \\n        \\n        //breaking into partition \\n        TreeNode left= sortedListToBST(head);//left half\\n        TreeNode right= sortedListToBST(slow.next);//right half\\n        \\n        TreeNode node= new TreeNode(data, left, right);//Root node creation as their child information has been received \\n        \\n        return node;//linking the child node with the parent node \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    public TreeNode sortedListToBST(ListNode head)\\n    {//DFS(postorder)\\n        if(head == null)//base case \\n            return null;\\n        if(head.next == null)//leaf node \\n            return new TreeNode(head.val, null, null);\\n    \\n        ListNode slow, fast, mid;\\n        mid= slow= fast= head;//intializing \\n        \\n        while(fast != null && fast.next != null)//terminating condition \\n        {\\n            mid= slow;//mid is like a previous pointer \\n            slow= slow.next;//one step\\n            fast= fast.next.next;//two step\\n        }\\n        mid.next= null;//to disconnect the list \\n        \\n        int data= slow.val;//root value \\n        \\n        //breaking into partition \\n        TreeNode left= sortedListToBST(head);//left half\\n        TreeNode right= sortedListToBST(slow.next);//right half\\n        \\n        TreeNode node= new TreeNode(data, left, right);//Root node creation as their child information has been received \\n        \\n        return node;//linking the child node with the parent node \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387324,
                "title": "easy-peasy-python-divide-and-conquer-recursive-solution",
                "content": "\\tdef sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if head is None:\\n            return None\\n        \\n        if head.next is None:\\n            return TreeNode(head.val)\\n        \\n        slow = head\\n        fast = head.next\\n        prev = None\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        if prev:\\n            prev.next = None\\n        else:\\n            head = None #means slow is still at my head\\n        \\n        node = TreeNode(slow.val)\\n        node.left = self.sortedListToBST(head)\\n        node.right = self.sortedListToBST(slow.next)\\n        \\n        return node",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "\\tdef sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if head is None:\\n            return None\\n        \\n        if head.next is None:\\n            return TreeNode(head.val)\\n        \\n        slow = head\\n        fast = head.next\\n        prev = None\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        if prev:\\n            prev.next = None\\n        else:\\n            head = None #means slow is still at my head\\n        \\n        node = TreeNode(slow.val)\\n        node.left = self.sortedListToBST(head)\\n        node.right = self.sortedListToBST(slow.next)\\n        \\n        return node",
                "codeTag": "Python3"
            },
            {
                "id": 35673,
                "title": "how-about-like-this",
                "content": "    TreeNode *sortedListToBST(ListNode *head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode *step1 = head;\\n        ListNode *step2 = head->next;\\n        while(step2->next != NULL && step2->next->next != NULL){\\n            step1 = step1->next;\\n            step2 = step2->next->next;\\n        }\\n        TreeNode *root  = new TreeNode(step1->next->val);\\n        ListNode *head2 = step1->next->next;\\n        delete step1->next;\\n        step1->next = NULL;\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(head2);\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "    TreeNode *sortedListToBST(ListNode *head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode *step1 = head;\\n        ListNode *step2 = head->next;\\n        while(step2->next != NULL && step2->next->next != NULL){\\n            step1 = step1->next;\\n            step2 = step2->next->next;\\n        }\\n        TreeNode *root  = new TreeNode(step1->next->val);\\n        ListNode *head2 = step1->next->next;\\n        delete step1->next;\\n        step1->next = NULL;\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(head2);\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3282617,
                "title": "fastest-solution",
                "content": "# Code\\n``` JAVA []\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```\\n\\n![upvote_me.jpeg](https://assets.leetcode.com/users/images/f7733362-6e4c-40a4-a904-407cf962ed31_1678512692.1215184.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282455,
                "title": "o-n-solution-using-concept-of-complete-binary-tree-c",
                "content": "# Intuition\\nWe know that binary search tree can be in the form of complete binary tree which is also height balanced ofc and we can also get the length of the list in O(n) time.\\nNow, as we know the no.of nodes in the tree and it is a complete binary tree, we can build the skeleton of the tree first in O(n) time.\\n\\nAfter completing the skeleton , as we have the sorted list(i.e inorder traversal of a binary tree), we can set the values of the nodes in the tree using NLR recursive approach\\n\\nPlease Dont forget to upvote !!!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* createTree(int index,int len){\\n\\n        if(index >= len) return NULL;\\n\\n        TreeNode* head = new TreeNode(-1);\\n\\n        head->left  =createTree(2*index + 1,len);\\n        head->right = createTree(2*index + 2,len);\\n\\n        return head;\\n\\n    }\\n    void buildTree(ListNode* &head,TreeNode* &tree){\\n\\n        if(!head) return ;\\n        if(!tree) return ;\\n\\n        buildTree(head,tree->left);\\n        tree->val = head->val;\\n        head = head->next;\\n        buildTree(head,tree->right);\\n\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n\\n        int len = 0;\\n        ListNode* ptr = head;\\n        while(ptr){\\n            len++;\\n            ptr = ptr->next;\\n        }\\n\\n        TreeNode* tree = createTree(0,len);\\n\\n        buildTree(head,tree);\\n\\n        return tree;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* createTree(int index,int len){\\n\\n        if(index >= len) return NULL;\\n\\n        TreeNode* head = new TreeNode(-1);\\n\\n        head->left  =createTree(2*index + 1,len);\\n        head->right = createTree(2*index + 2,len);\\n\\n        return head;\\n\\n    }\\n    void buildTree(ListNode* &head,TreeNode* &tree){\\n\\n        if(!head) return ;\\n        if(!tree) return ;\\n\\n        buildTree(head,tree->left);\\n        tree->val = head->val;\\n        head = head->next;\\n        buildTree(head,tree->right);\\n\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n\\n        int len = 0;\\n        ListNode* ptr = head;\\n        while(ptr){\\n            len++;\\n            ptr = ptr->next;\\n        }\\n\\n        TreeNode* tree = createTree(0,len);\\n\\n        buildTree(head,tree);\\n\\n        return tree;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433937,
                "title": "java-simple-solution",
                "content": "```\\npublic TreeNode sortedListToBST(ListNode head) {\\n        return toBST(head,null);\\n    }\\n    \\n    public TreeNode toBST(ListNode head, ListNode tail) {\\n        if(head == tail) return null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast.next != tail && fast.next.next != tail) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        TreeNode n = new TreeNode(slow.val);\\n        n.left = toBST(head, slow);\\n        n.right = toBST(slow.next, tail);\\n        return n;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic TreeNode sortedListToBST(ListNode head) {\\n        return toBST(head,null);\\n    }\\n    \\n    public TreeNode toBST(ListNode head, ListNode tail) {\\n        if(head == tail) return null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast.next != tail && fast.next.next != tail) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        TreeNode n = new TreeNode(slow.val);\\n        n.left = toBST(head, slow);\\n        n.right = toBST(slow.next, tail);\\n        return n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195125,
                "title": "c-in-order-traversal-solution-explained-100-time-70-space",
                "content": "The base idea is to find the middle of our linked list, then cut it out of said list, create a `TreeNode` with it and have as `left` and `right` branches what we would get recursively calling `sortedListToBST` with the first and second chunk of the list respectively.\\n\\nWe will also need a base case to stop our recursion, which is what we are going to do first for when we have `0 - 1` nodes, in which case we will `return`:\\n* `new TreeNode(head->val)` for when we have a sole element;\\n* just `NULL` for when we have no elements in the list.\\n\\nWith that out of the way, we can now focus on finding the middle of the list; to do so, we will need a couple more variables, both being `ListNode` pointers:\\n* `turtle` will be initialised to be `head`;\\n* `hare` will be initialised to be `head->next->next`  (since we want `turtle` to stop one step before the mid, we are giving `hare`a headstart).\\n\\nWe will then proceed to loop as long as `hare && hare->next`, advancing `turtle` by one step and `hare` by two steps.\\n\\nOnce done, we will have `turtle` pointing at the node right before the middle, so we can assign the middle itself to `hare` and then cut it out of the list; similarly, we can now assign the node right after the middle to `turtle` (since the second chunk of the list will start from there) and then again cut it out of the list.\\n\\nAll that is left to do, it so create a new `TreeNode` with `hare->val` as value for the root and the recursive calls `sortedListToBST(head)` and `sortedListToBST(turtle)` to generate its `left` and `right` branches respectively :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        // base case: 0 - 1 nodes\\n        if (!head || !head->next) return head ? new TreeNode(head->val) : NULL;\\n        // support variables\\n        ListNode *turtle = head, *hare = head->next->next;\\n        // finding the middle\\n        while (hare && hare->next) {\\n            turtle = turtle->next;\\n            hare = hare->next->next;\\n        }\\n        // turtle is no pre-mid, so we set hare to be the mid, and we cut it\\n        hare = turtle->next;\\n        turtle->next = NULL;\\n        // we now set turtle to be the head of the right branch and we cut it too\\n        turtle = hare->next;\\n        hare->next = NULL;\\n        return new TreeNode(hare->val, sortedListToBST(head), sortedListToBST(turtle));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        // base case: 0 - 1 nodes\\n        if (!head || !head->next) return head ? new TreeNode(head->val) : NULL;\\n        // support variables\\n        ListNode *turtle = head, *hare = head->next->next;\\n        // finding the middle\\n        while (hare && hare->next) {\\n            turtle = turtle->next;\\n            hare = hare->next->next;\\n        }\\n        // turtle is no pre-mid, so we set hare to be the mid, and we cut it\\n        hare = turtle->next;\\n        turtle->next = NULL;\\n        // we now set turtle to be the head of the right branch and we cut it too\\n        turtle = hare->next;\\n        hare->next = NULL;\\n        return new TreeNode(hare->val, sortedListToBST(head), sortedListToBST(turtle));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191945,
                "title": "convert-sorted-list-to-binary-search-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Find the length of the linked list.\\n2. Define a helper function that takes a start and end index and constructs a subtree from the linked list.\\n3. Recursively construct the left and right subtrees by calling the helper function with the appropriate indices.\\n4. Return the root of the constructed tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def getLength(head: ListNode) -> int:\\n            length = 0\\n            while head:\\n                length += 1\\n                head = head.next\\n            return length\\n\\n        def buildBST(start: int, end: int) -> TreeNode:\\n            nonlocal head\\n\\n            if start > end:\\n                return None\\n\\n            mid = (start + end) // 2\\n            left = buildBST(start, mid - 1)\\n            root = TreeNode(head.val)\\n            head = head.next\\n            right = buildBST(mid + 1, end)\\n            root.left = left\\n            root.right = right\\n            return root\\n\\n        length = getLength(head)\\n        return buildBST(0, length - 1)\\n\\n```\\nIn the helper function buildBST, we use the nonlocal keyword to access and modify the head variable from the enclosing function. The mid variable is computed as the average of the start and end indices, and we recursively construct the left and right subtrees by passing in the appropriate start and end indices. Finally, we create the root node and connect it to the left and right subtrees.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Divide and Conquer",
                    "Tree"
                ],
                "code": "```\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def getLength(head: ListNode) -> int:\\n            length = 0\\n            while head:\\n                length += 1\\n                head = head.next\\n            return length\\n\\n        def buildBST(start: int, end: int) -> TreeNode:\\n            nonlocal head\\n\\n            if start > end:\\n                return None\\n\\n            mid = (start + end) // 2\\n            left = buildBST(start, mid - 1)\\n            root = TreeNode(head.val)\\n            head = head.next\\n            right = buildBST(mid + 1, end)\\n            root.left = left\\n            root.right = right\\n            return root\\n\\n        length = getLength(head)\\n        return buildBST(0, length - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886094,
                "title": "turtle-and-hare-approach-100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev;\\n        while(fast!= NULL and fast->next!=NULL){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        prev->next = NULL;\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev;\\n        while(fast!= NULL and fast->next!=NULL){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        prev->next = NULL;\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670792,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head: return None\\n        if not head.next: return TreeNode(head.val)\\n        prev = slow = fast = head\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        prev.next = None \\n        return TreeNode(slow.val,self.sortedListToBST(head),self.sortedListToBST(slow.next)) \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head: return None\\n        if not head.next: return TreeNode(head.val)\\n        prev = slow = fast = head\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        prev.next = None \\n        return TreeNode(slow.val,self.sortedListToBST(head),self.sortedListToBST(slow.next)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 35582,
                "title": "13-lines-concise-and-easy-understand-c-solution",
                "content": "    class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode* fast = head, * slow = head, * pre = NULL;\\n            while(fast && fast->next){\\n                fast = fast->next->next;\\n                pre = slow;\\n                slow = slow->next;\\n            }\\n            TreeNode* root = new TreeNode(slow->val);\\n            if(pre != NULL) pre->next = NULL;\\n            else head = NULL;\\n            root->left = sortedListToBST(head);\\n            root->right = sortedListToBST(slow->next);\\n            return root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode* fast = head, * slow = head, * pre = NULL;\\n            while(fast && fast->next){\\n                fast = fast->next->next;\\n                pre = slow;\\n                slow = slow->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 35609,
                "title": "easy-java-solution",
                "content": "\\n\\n\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n        HashMap<Integer,TreeNode> map = new HashMap<Integer,TreeNode>();\\n\\t\\tListNode p ;\\n\\t\\t\\n\\t\\tint i = 0;\\n\\t\\tfor(p=head ; p!=null ; p = p.next){\\n\\t\\t\\tmap.put(i, new TreeNode(p.val));\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn buildTree(map,0,i-1);\\n    }\\n    \\n\\n    public static TreeNode buildTree(HashMap<Integer,TreeNode> map, int start , int end){\\n\\t\\tif(start<=end){\\n\\t\\t\\tint mid = (start+end)/2;\\n\\t\\t\\tTreeNode t = map.get(mid);\\n\\t\\t\\tt.left = buildTree(map,start,mid-1);\\n\\t\\t\\tt.right = buildTree(map,mid+1,end);\\n\\t\\t\\treturn t;\\n\\t\\t}\\n\\t\\telse return null;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n        HashMap<Integer,TreeNode> map = new HashMap<Integer,TreeNode>();\\n\\t\\tListNode p ;\\n\\t\\t\\n\\t\\tint i = 0;\\n\\t\\tfor(p=head ; p!=null ; p = p.next){\\n\\t\\t\\tmap.put(i, new TreeNode(p.val));\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn buildTree(map,0,i-1);\\n    }\\n    \\n\\n    public static TreeNode buildTree(HashMap<Integer,TreeNode> map, int start , int end){\\n\\t\\tif(start<=end){\\n\\t\\t\\tint mid = (start+end)/2;\\n\\t\\t\\tTreeNode t = map.get(mid);\\n\\t\\t\\tt.left = buildTree(map,start,mid-1);\\n\\t\\t\\tt.right = buildTree(map,mid+1,end);\\n\\t\\t\\treturn t;\\n\\t\\t}\\n\\t\\telse return null;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3282214,
                "title": "simple-c-fully-explained-solution-o-n-recursive",
                "content": "# Intuition\\nThe list provided is sorted in ascending order, and if we perform an inorder traversal of a binary search tree (BST), the resulting traversal will also be sorted in ascending order. This is because the in-order traversal of a BST visits the nodes in ascending order of their values. Therefore, the resulting traversal of a BST constructed from a sorted list will also be in ascending order.\\n\\n---\\n\\n\\n# Approach\\nTo construct a binary search tree (BST) from a sorted list, we can use a recursive algorithm that repeatedly divides the list into two halves using the middle element as the pivot. Within the recursive function (which we can call solver() in our case), we first find the middle point of the current list and create a new TreeNode with its value. We then call solver() again with the left part of the list as the input to construct the left subtree of the current node and the right part of the list as the input to construct the right subtree of the current node. By repeating this process recursively, we can construct the entire BST.\\n\\n- See code for further uderstanding\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(n)**\\n\\n---\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* solver(vector<int> &vect, int start, int end){\\n        if(start>end) return nullptr;\\n        int mid = (start+end)/2;\\n        TreeNode* curr = new TreeNode(vect[mid]);\\n        curr->left = solver(vect,start,mid-1);\\n        curr->right = solver(vect,mid+1,end);\\n        return curr;\\n\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int n = 0;\\n        ListNode* h = head;\\n        vector<int> vect;\\n        while(h){\\n            vect.push_back(h->val);\\n            h = h->next;\\n        }\\n        if(vect.size()==0) return nullptr;\\n        TreeNode*  res = solver(vect,0,vect.size()-1);\\n        return res;\\n    }\\n};\\n```\\n\\n\\nPlease upvote if it helped you.",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* solver(vector<int> &vect, int start, int end){\\n        if(start>end) return nullptr;\\n        int mid = (start+end)/2;\\n        TreeNode* curr = new TreeNode(vect[mid]);\\n        curr->left = solver(vect,start,mid-1);\\n        curr->right = solver(vect,mid+1,end);\\n        return curr;\\n\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int n = 0;\\n        ListNode* h = head;\\n        vector<int> vect;\\n        while(h){\\n            vect.push_back(h->val);\\n            h = h->next;\\n        }\\n        if(vect.size()==0) return nullptr;\\n        TreeNode*  res = solver(vect,0,vect.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282150,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getArray(ListNode* head){\\n        vector<int> ans;\\n        while(head){\\n            ans.push_back(head->val);\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n    TreeNode* createBinarySearchTree(TreeNode* root,vector<int>& arr,int s,int e){\\n        if(s>e) return NULL;\\n        int mid=s+(e-s)/2;\\n        root=new TreeNode(arr[mid]);\\n        root->left=createBinarySearchTree(root->left,arr,s,mid-1);\\n        root->right=createBinarySearchTree(root->right,arr,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        TreeNode* root=NULL;\\n        vector<int> arr=getArray(head);\\n        return createBinarySearchTree(root,arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Divide and Conquer",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getArray(ListNode* head){\\n        vector<int> ans;\\n        while(head){\\n            ans.push_back(head->val);\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n    TreeNode* createBinarySearchTree(TreeNode* root,vector<int>& arr,int s,int e){\\n        if(s>e) return NULL;\\n        int mid=s+(e-s)/2;\\n        root=new TreeNode(arr[mid]);\\n        root->left=createBinarySearchTree(root->left,arr,s,mid-1);\\n        root->right=createBinarySearchTree(root->right,arr,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        TreeNode* root=NULL;\\n        vector<int> arr=getArray(head);\\n        return createBinarySearchTree(root,arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281942,
                "title": "using-recusion-easiest-solution-beginner-friendly-detailed-explanation",
                "content": "# Intuition\\nUse the concept of divide and conquer.\\n# Approach\\n1. first take two linkedlist pointer head and tail, where initialize tail to NULL.\\n2. check head or next of head is null or not, if it is null then return null or create an node and return it.\\n3. find mid node in linked list, for the root of binry tree.\\n4. then create root node of mid.\\n5. for left of root, call head to mid by recursion = solve(head,mid).\\n6. for right of root, call mid->next to tail by recursion = solve(mid->next,tail).\\n7. At last return root.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(ListNode* head, ListNode* tail)\\n    {\\n        if(head == tail)\\n            return NULL;\\n        \\n        if(head->next == tail)\\n        {\\n            TreeNode* root = new TreeNode(head->val);\\n            return root;\\n        }\\n        ListNode *mid = head,*temp = head;\\n        while(temp!=tail && temp->next!=tail)\\n        {\\n            mid = mid->next;\\n            temp = temp->next->next;\\n        }\\n        TreeNode* root = new TreeNode(mid->val);\\n        root->left = solve(head,mid);\\n        root->right = solve(mid->next,tail);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) \\n    {\\n        return solve(head,NULL);    \\n    }\\n};\\n```\\n**If you feel this helpful then plz like and upvote this solution \\uD83D\\uDE0A\\nKEEP LEETCODING.............**\\n![upvote.png](https://assets.leetcode.com/users/images/28c24656-d151-49a4-aca1-8268bf2f4a69_1678493866.3012052.png)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Divide and Conquer",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(ListNode* head, ListNode* tail)\\n    {\\n        if(head == tail)\\n            return NULL;\\n        \\n        if(head->next == tail)\\n        {\\n            TreeNode* root = new TreeNode(head->val);\\n            return root;\\n        }\\n        ListNode *mid = head,*temp = head;\\n        while(temp!=tail && temp->next!=tail)\\n        {\\n            mid = mid->next;\\n            temp = temp->next->next;\\n        }\\n        TreeNode* root = new TreeNode(mid->val);\\n        root->left = solve(head,mid);\\n        root->right = solve(mid->next,tail);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) \\n    {\\n        return solve(head,NULL);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528095,
                "title": "easy-understanding-solution-c",
                "content": "Contructing tree using vector to store list values and then construct BST using the same with binary search to construct tree\\n```\\nclass Solution {\\npublic:\\n    TreeNode* maketree(vector<int>& vec, int start, int end)\\n    {\\n        if(start==end) return NULL;\\n        \\n        int mid = start + (end-start)/2;\\n        TreeNode* root = new TreeNode(vec[mid]);\\n        \\n        root->left = maketree(vec, start, mid);\\n        root->right =  maketree(vec, mid+1, end);\\n        \\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> vec;\\n        if(!head) return NULL;\\n        for(auto temp = head; temp!=NULL; temp = temp->next)\\n        {\\n            vec.push_back(temp->val);\\n        }\\n        TreeNode* root = maketree(vec, 0, vec.size());\\n        \\n        return root;\\n    }\\n};\\n```\\nPlease UPVOTE if liked the solution. Thank you",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* maketree(vector<int>& vec, int start, int end)\\n    {\\n        if(start==end) return NULL;\\n        \\n        int mid = start + (end-start)/2;\\n        TreeNode* root = new TreeNode(vec[mid]);\\n        \\n        root->left = maketree(vec, start, mid);\\n        root->right =  maketree(vec, mid+1, end);\\n        \\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> vec;\\n        if(!head) return NULL;\\n        for(auto temp = head; temp!=NULL; temp = temp->next)\\n        {\\n            vec.push_back(temp->val);\\n        }\\n        TreeNode* root = maketree(vec, 0, vec.size());\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431891,
                "title": "easy-solution-2-approach-1-using-vector-2-linked-list-c",
                "content": "**Using Vector to store elements and then convert it into BST**\\nUsing mid element and then appending it as a root , similarily for the left and right part , after that recursion will handle all the stuffs.\\n```\\nTreeNode* solve(vector<int>&v,int s ,int e){\\n        if(s>e) return nullptr;\\n        int mid  = s+(e-s)/2;\\n        TreeNode* root = new TreeNode (v[mid]);\\n        root->left = solve(v,s,mid-1);\\n        root->right = solve(v,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        int s=0;\\n        int e=v.size()-1;\\n        return solve(v,s,e);\\n    }\\n```\\n\\n**Using Linked List Fast and Slow Pointer** \\nUsing Fast and slow Pointer to find the middle element and append it as root , similarily do for right and left node and rest leave on recursion.\\n```\\nTreeNode* solve(ListNode* head, ListNode* tail){\\n        if(head==tail) return nullptr;\\n        ListNode* fast = head , * slow = head;\\n        while(fast!=tail and fast->next!=tail){\\n            fast = fast->next;\\n            if(fast->next) fast = fast->next;\\n            slow = slow->next;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = solve(head,slow);\\n        root->right = solve(slow->next,tail);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode* tail = NULL;\\n        return solve(head,tail);\\n    }\\n```\\n\\n**Do upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* solve(vector<int>&v,int s ,int e){\\n        if(s>e) return nullptr;\\n        int mid  = s+(e-s)/2;\\n        TreeNode* root = new TreeNode (v[mid]);\\n        root->left = solve(v,s,mid-1);\\n        root->right = solve(v,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        int s=0;\\n        int e=v.size()-1;\\n        return solve(v,s,e);\\n    }\\n```\n```\\nTreeNode* solve(ListNode* head, ListNode* tail){\\n        if(head==tail) return nullptr;\\n        ListNode* fast = head , * slow = head;\\n        while(fast!=tail and fast->next!=tail){\\n            fast = fast->next;\\n            if(fast->next) fast = fast->next;\\n            slow = slow->next;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = solve(head,slow);\\n        root->right = solve(slow->next,tail);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode* tail = NULL;\\n        return solve(head,tail);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2010993,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic class Solution {\\npublic TreeNode sortedListToBST(ListNode head) {\\n    if(head==null) return null;\\n    return toBST(head,null);\\n}\\npublic TreeNode toBST(ListNode head, ListNode tail){\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==tail) return null;\\n    \\n    while(fast!=tail&&fast.next!=tail){\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    TreeNode thead = new TreeNode(slow.val);\\n    thead.left = toBST(head,slow);\\n    thead.right = toBST(slow.next,tail);\\n    return thead;\\n}\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail = NULL) {\\n        if (head == tail) \\n            return NULL;\\n        \\n        ListNode* fast = head, *slow = head;\\n        while (fast != tail && fast->next != tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = sortedListToBST(head, slow);\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n    }\\n    \\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef sortedListToBST(self, head):\\n    if not head:\\n        return \\n    if not head.next:\\n        return TreeNode(head.val)\\n    # here we get the middle point,\\n    # even case, like \\'1234\\', slow points to \\'2\\',\\n    # \\'3\\' is root, \\'12\\' belongs to left, \\'4\\' is right\\n    # odd case, like \\'12345\\', slow points to \\'2\\', \\'12\\'\\n    # belongs to left, \\'3\\' is root, \\'45\\' belongs to right\\n    slow, fast = head, head.next.next\\n    while fast and fast.next:\\n        fast = fast.next.next\\n        slow = slow.next\\n    # tmp points to root\\n    tmp = slow.next\\n    # cut down the left child\\n    slow.next = None\\n    root = TreeNode(tmp.val)\\n    root.left = self.sortedListToBST(head)\\n    root.right = self.sortedListToBST(tmp.next)\\n    return root\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nfun sortedListToBST(head: ListNode?): TreeNode? {\\n        val N = size(head) // size of LL\\n        if (N == 0) return null\\n        if (N == 1) return TreeNode(head!!.`val`)\\n        val A = IntArray(N) // LL data in array\\n        populate(A, head) // fill the array\\n        return construct(head, A, 0, N - 1)\\n    }\\n    \\n    private fun construct(head: ListNode?, A: IntArray, start: Int, end: Int): TreeNode? {\\n        if (start > end) return null\\n        val mid = (start + end) / 2\\n        val root = TreeNode(A[mid])\\n        root.left = construct(head, A, start, mid - 1)\\n        root.right = construct(head, A, mid + 1, end)\\n        return root\\n    }\\n    \\n    private fun size(head: ListNode?): Int {\\n        if (head == null) return 0\\n        if (head.next == null) return 1\\n        var ans = 0\\n        var node = head\\n        while (node != null) {\\n            ans++\\n            node = node.next\\n        }\\n        return ans\\n    }\\n    \\n    private fun populate(A: IntArray, head: ListNode?) {\\n        var node = head\\n        for (i in A.indices) {\\n            A[i] = node!!.`val`\\n            node = node?.next\\n        }\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\\n        var nums: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nums.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        return sortedArrayToBST(nums)\\n    }\\n    \\n    \\n    func sortedArrayToBST(_ nums: [ListNode]) -> TreeNode? {\\n        let count = nums.count\\n        guard count > 0 else { return nil }\\n        \\n        let rootIndex = count / 2\\n        let root = TreeNode(nums[rootIndex].val)\\n        \\n        root.left = rootIndex > 0 ? sortedArrayToBST(Array(nums[0..<rootIndex])) : nil\\n        root.right = rootIndex < count - 1 ? sortedArrayToBST(Array(nums[rootIndex + 1..<count])) : nil\\n        return root\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP",
                    "Recursion"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic class Solution {\\npublic TreeNode sortedListToBST(ListNode head) {\\n    if(head==null) return null;\\n    return toBST(head,null);\\n}\\npublic TreeNode toBST(ListNode head, ListNode tail){\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==tail) return null;\\n    \\n    while(fast!=tail&&fast.next!=tail){\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    TreeNode thead = new TreeNode(slow.val);\\n    thead.left = toBST(head,slow);\\n    thead.right = toBST(slow.next,tail);\\n    return thead;\\n}\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail = NULL) {\\n        if (head == tail) \\n            return NULL;\\n        \\n        ListNode* fast = head, *slow = head;\\n        while (fast != tail && fast->next != tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = sortedListToBST(head, slow);\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n    }\\n    \\n};\\n```\n```\\n```\n```\\n```\n```\\ndef sortedListToBST(self, head):\\n    if not head:\\n        return \\n    if not head.next:\\n        return TreeNode(head.val)\\n    # here we get the middle point,\\n    # even case, like \\'1234\\', slow points to \\'2\\',\\n    # \\'3\\' is root, \\'12\\' belongs to left, \\'4\\' is right\\n    # odd case, like \\'12345\\', slow points to \\'2\\', \\'12\\'\\n    # belongs to left, \\'3\\' is root, \\'45\\' belongs to right\\n    slow, fast = head, head.next.next\\n    while fast and fast.next:\\n        fast = fast.next.next\\n        slow = slow.next\\n    # tmp points to root\\n    tmp = slow.next\\n    # cut down the left child\\n    slow.next = None\\n    root = TreeNode(tmp.val)\\n    root.left = self.sortedListToBST(head)\\n    root.right = self.sortedListToBST(tmp.next)\\n    return root\\n```\n```\\n```\n```\\n```\n```\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\n```\\n```\n```\\n```\n```\\nfun sortedListToBST(head: ListNode?): TreeNode? {\\n        val N = size(head) // size of LL\\n        if (N == 0) return null\\n        if (N == 1) return TreeNode(head!!.`val`)\\n        val A = IntArray(N) // LL data in array\\n        populate(A, head) // fill the array\\n        return construct(head, A, 0, N - 1)\\n    }\\n    \\n    private fun construct(head: ListNode?, A: IntArray, start: Int, end: Int): TreeNode? {\\n        if (start > end) return null\\n        val mid = (start + end) / 2\\n        val root = TreeNode(A[mid])\\n        root.left = construct(head, A, start, mid - 1)\\n        root.right = construct(head, A, mid + 1, end)\\n        return root\\n    }\\n    \\n    private fun size(head: ListNode?): Int {\\n        if (head == null) return 0\\n        if (head.next == null) return 1\\n        var ans = 0\\n        var node = head\\n        while (node != null) {\\n            ans++\\n            node = node.next\\n        }\\n        return ans\\n    }\\n    \\n    private fun populate(A: IntArray, head: ListNode?) {\\n        var node = head\\n        for (i in A.indices) {\\n            A[i] = node!!.`val`\\n            node = node?.next\\n        }\\n    }\\n```\n```\\n```\n```\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\\n        var nums: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nums.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        return sortedArrayToBST(nums)\\n    }\\n    \\n    \\n    func sortedArrayToBST(_ nums: [ListNode]) -> TreeNode? {\\n        let count = nums.count\\n        guard count > 0 else { return nil }\\n        \\n        let rootIndex = count / 2\\n        let root = TreeNode(nums[rootIndex].val)\\n        \\n        root.left = rootIndex > 0 ? sortedArrayToBST(Array(nums[0..<rootIndex])) : nil\\n        root.right = rootIndex < count - 1 ? sortedArrayToBST(Array(nums[rootIndex + 1..<count])) : nil\\n        return root\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315253,
                "title": "java-ez-approach-beats-100",
                "content": "Hopefully u will find it useful!\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        return listToBST(head, null);\\n    }\\n    private TreeNode listToBST(ListNode head, ListNode tail) {\\n        if (head == null || head == tail) return null;\\n        ListNode mid = findMid(head, tail);\\n        TreeNode root = new TreeNode(mid.val);\\n        root.left = listToBST(head, mid);\\n        root.right = listToBST(mid.next, tail);\\n        return root;\\n    }\\n    private ListNode findMid(ListNode head, ListNode tail) {\\n        ListNode l1 = head, l2 = head;\\n        while (l2 != tail && l2.next != tail) {\\n            l1 = l1.next;\\n            l2 = l2.next.next;\\n        }\\n        return l1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        return listToBST(head, null);\\n    }\\n    private TreeNode listToBST(ListNode head, ListNode tail) {\\n        if (head == null || head == tail) return null;\\n        ListNode mid = findMid(head, tail);\\n        TreeNode root = new TreeNode(mid.val);\\n        root.left = listToBST(head, mid);\\n        root.right = listToBST(mid.next, tail);\\n        return root;\\n    }\\n    private ListNode findMid(ListNode head, ListNode tail) {\\n        ListNode l1 = head, l2 = head;\\n        while (l2 != tail && l2.next != tail) {\\n            l1 = l1.next;\\n            l2 = l2.next.next;\\n        }\\n        return l1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502147,
                "title": "easy-to-understand-javascript-solution",
                "content": "Though this might look a bit confusing at first, I think it is ultimately easier to remember because the code is so short and nothing is ambiguous. It might be hard to imagine the traversal state on the spot though.\\n\\n1. Find the mid point by counting length of the list\\n2. Traverse left subtree using the midpoint as your upper bound\\n3. Set left subtree to the midpoint root.left\\n4. Shift head to the next element\\n5. Traverse right subtree with the new head (length of list - number of nodes in the left subtree - root)\\n6. Set right subtree to root.right\\n```\\nvar sortedListToBST = function(head) {\\n    const numOfNodes = countNodes(head)\\n    return traverse(numOfNodes)\\n    \\n    function traverse(n) {\\n        if (n <= 0) return null\\n        \\n        const left = traverse(Math.floor(n / 2))\\n        const root = new TreeNode(head.val)       \\n        root.left = left\\n        head = head.next\\n        root.right = traverse(n - Math.floor(n / 2) - 1)\\n        \\n        return root\\n    }\\n    \\n    function countNodes(node) {\\n        if (!node) return 0\\n        return 1 + countNodes(node.next)\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortedListToBST = function(head) {\\n    const numOfNodes = countNodes(head)\\n    return traverse(numOfNodes)\\n    \\n    function traverse(n) {\\n        if (n <= 0) return null\\n        \\n        const left = traverse(Math.floor(n / 2))\\n        const root = new TreeNode(head.val)       \\n        root.left = left\\n        head = head.next\\n        root.right = traverse(n - Math.floor(n / 2) - 1)\\n        \\n        return root\\n    }\\n    \\n    function countNodes(node) {\\n        if (!node) return 0\\n        return 1 + countNodes(node.next)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488205,
                "title": "javascript-solution",
                "content": "### The idea\\n1. in order to create a balanced BST from sorted numbers, the best approach is to take the middle number as the subtree root value and do so for every subtree. \\n\\n### O(NlogN) Solution\\n``` javascript\\nvar sortedListToBST1 = function(head) {\\n    \\n    let recur = function(listNode) {\\n        if (listNode == null) return null;\\n        \\n        let slow = listNode, fast = listNode, leftTail = null, leftHead = listNode;\\n        while(fast.next && fast.next.next) {\\n            leftTail = slow;\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        \\n        let root = new TreeNode(slow.val);\\n        let rightHead = slow.next;\\n\\n        if (leftTail == null) leftHead = null;\\n        else leftTail.next = null;\\n        \\n        \\n        root.left = recur(leftHead);\\n        root.right = recur(rightHead);\\n        \\n        return root;\\n    }\\n    \\n    return recur(head);\\n};\\n```\\n\\n### O(N) Solution\\n``` javascript \\nvar sortedListToBST2 = function(head) {\\n    let nums = [];\\n    while(head) {\\n        nums.push(head.val);\\n        head = head.next;\\n    }\\n    \\n    let recur = function(left, right){\\n        if (left > right) return null;\\n        let mid = left + parseInt((right - left) / 2);\\n        let root = new TreeNode(nums[mid]);\\n        if (left == right) return root;\\n        root.left = recur(left, mid - 1);\\n        root.right = recur(mid + 1, right);\\n        return root;\\n    }\\n    \\n    return recur(0, nums.length-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar sortedListToBST1 = function(head) {\\n    \\n    let recur = function(listNode) {\\n        if (listNode == null) return null;\\n        \\n        let slow = listNode, fast = listNode, leftTail = null, leftHead = listNode;\\n        while(fast.next && fast.next.next) {\\n            leftTail = slow;\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        \\n        let root = new TreeNode(slow.val);\\n        let rightHead = slow.next;\\n\\n        if (leftTail == null) leftHead = null;\\n        else leftTail.next = null;\\n        \\n        \\n        root.left = recur(leftHead);\\n        root.right = recur(rightHead);\\n        \\n        return root;\\n    }\\n    \\n    return recur(head);\\n};\\n```\n``` javascript \\nvar sortedListToBST2 = function(head) {\\n    let nums = [];\\n    while(head) {\\n        nums.push(head.val);\\n        head = head.next;\\n    }\\n    \\n    let recur = function(left, right){\\n        if (left > right) return null;\\n        let mid = left + parseInt((right - left) / 2);\\n        let root = new TreeNode(nums[mid]);\\n        if (left == right) return root;\\n        root.left = recur(left, mid - 1);\\n        root.right = recur(mid + 1, right);\\n        return root;\\n    }\\n    \\n    return recur(0, nums.length-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463758,
                "title": "2-python-solution-top-down-bottom-up-with-detailed-explanation-as-tree-traversal",
                "content": "I read some answers with top votes treat the different approach as top-down / bottom up.\\nFor the top-down method which starts from root, it is eaiser to understand: we find the mid point first and convert to a root, then place the left subtree, and finally place the right subtree.\\nA trick here I think is interesting is using the \"slow & fast pointers\", which help us avoid converting the linked list to array first.\\nThe solution I have referred to is from @caikehe: https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/discuss/35474/Python-recursive-solution-with-detailed-comments-(operate-linked-list-directly).\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head: return None\\n        if not head.next: return TreeNode(head.val)\\n        \\n        slow, fast = head, head.next.next \\n    \\n        # Note the initialization part: slow = 0, fast = 2\\n\\t\\t# we do this to make the slower pointers \\u3010stop before the mid point\\u3011\\n        # -> slow + steps = n // 2 - 1; fast + 2*steps = 2 + n - 2 = n\\n        # examples:\\n        # n = 2m:   1, 2, 3, 4 -> A[2] = 3\\n        #           slow -> (index) 1; fast -> null, exit the loop\\n        #     \\n        # n = 2m-1: 1, 2, 3, 4, 5 -> A[2] = 3\\n        #           slow -> 1; fast -> 5, fast.next == null, exit the loop\\n        \\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        tmp = slow.next\\n        # get the previous half lists off\\n        slow.next = None\\n        root = TreeNode(tmp.val)\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(tmp.next)\\n        \\n        return root\\n```\\n\\nThen I found I have difficulty in understanding what does \"bottom-up\" mean. After writing the code and seeing the test cases, I realize that it may be easier to understand \"bottom-up\" as \"pre-order\". Corresponding, \"top-down\" actually means \\'in-order\". Here is my code modified with reference to @caikehe: https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/discuss/35526/Python-solutions-(convert-to-array-first-top-down-approach-bottom-up-approach)\\n\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        \\n        def convert(start, end):\\n            if start > end:\\n                return None\\n            mid = (start + end) >> 1\\n            l = convert(start, mid - 1)\\n            nonlocal head\\n            root = TreeNode(head.val)\\n            root.left = l\\n            head = head.next\\n            root.right = convert(mid + 1, end)\\n            return root\\n        \\n        return convert(0, l - 1)\\n```\\n\\nAs the code shows, we place the left subtree first, then root, and finally the right tree. Note that \"bottom-up\" does mean we deal with leave nodes first, but it may not be the smallest node.\\nFor example, run the code with given array [-10, -3, 0, 5, 9], we will get a tree as:\\n\\n![image](https://assets.leetcode.com/users/aglover/image_1577590529.png)\\n\\nThe code will start from the range [0, 4] -> deal with the left part [0, 1], currently head= -10, then we continue to deal with the left part, finding the range change to [0, -1] since mid =0. Then we generate a new tree node -10, place the left child of node -10 to be None, move the head to -3. then deal with the right part, with the range [1, 1] In this way, we place the left subtree. Similar process for the right part.\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head: return None\\n        if not head.next: return TreeNode(head.val)\\n        \\n        slow, fast = head, head.next.next \\n    \\n        # Note the initialization part: slow = 0, fast = 2\\n\\t\\t# we do this to make the slower pointers \\u3010stop before the mid point\\u3011\\n        # -> slow + steps = n // 2 - 1; fast + 2*steps = 2 + n - 2 = n\\n        # examples:\\n        # n = 2m:   1, 2, 3, 4 -> A[2] = 3\\n        #           slow -> (index) 1; fast -> null, exit the loop\\n        #     \\n        # n = 2m-1: 1, 2, 3, 4, 5 -> A[2] = 3\\n        #           slow -> 1; fast -> 5, fast.next == null, exit the loop\\n        \\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        tmp = slow.next\\n        # get the previous half lists off\\n        slow.next = None\\n        root = TreeNode(tmp.val)\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(tmp.next)\\n        \\n        return root\\n```\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        \\n        def convert(start, end):\\n            if start > end:\\n                return None\\n            mid = (start + end) >> 1\\n            l = convert(start, mid - 1)\\n            nonlocal head\\n            root = TreeNode(head.val)\\n            root.left = l\\n            head = head.next\\n            root.right = convert(mid + 1, end)\\n            return root\\n        \\n        return convert(0, l - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169275,
                "title": "java-2-solutions-o-n-o-nlogn-solutions-with-explanation",
                "content": "Soultion-1:\\nTime Complexity O(nlogn) which n is size of the List - 1ms beats 100%\\nIn this solution, we construct from root to leaves;\\nThe first solution is using SLOW and FAST method.\\nWhenever we reach to fast==null || fast.next==null it means slow node is at the middle of the list. We keep track of the prev node which is prev.next=slow to set the prev.next==null.\\nStart to prev is going to be our left node(s) \\nSlow is going to be our Root Node\\nSlow.next to fast is going to be our right node(s)\\nWe keep doing that till read all the values in the list.\\n```\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\t\\tif(head==null) return null;\\n\\t\\tif(head.next==null) return new TreeNode(head.val);\\n\\t\\tListNode slow=head, fast=head,prev=null;\\n\\t\\twhile(fast!=null && fast.next!=null){\\n\\t\\t\\tprev=slow;\\n\\t\\t\\tslow=slow.next;\\n\\t\\t\\tfast=fast.next.next;\\n\\t\\t}\\n\\t\\tprev.next=null;\\n\\t\\tTreeNode root = new TreeNode(slow.val);\\n\\t\\troot.left=sortedListToBST(head);\\n\\t\\troot.right=sortedListToBST(slow.next);\\n\\t\\treturn root;\\n    } \\n```\\nSoultion-2:\\nTime Complexity O(n) which n is size of the List - 1ms beats 100%\\nIn this solution, we construct from leaves to root;\\nWe first count the number of nodes in our list.\\nWe build left nodes which is from 0 to n/2\\nThen after building the left side, we create the root which is n/2 node\\nand then we build the right nodes which is from n/2+1 till n\\n```\\n\\tListNode head=null;\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\t\\t int size=0;\\n\\t\\t ListNode curr = head;\\n\\t\\t while(curr!=null){\\n\\t\\t\\tsize++;\\n\\t\\t\\tcurr=curr.next;\\n\\t\\t }\\t\\t \\n\\t\\t this.head=head;\\n\\t\\t return sortedListToBST(0,size);\\n\\t } \\n\\tTreeNode sortedListToBST(int start, int end){\\n\\t\\tif(start>=end) return null; \\n\\t\\t if(start+1==end) {\\n\\t\\t\\t TreeNode node = new TreeNode(head.val);\\n\\t\\t\\t head=head.next; \\n\\t\\t\\t return node;\\n\\t\\t }\\n\\t\\tint middle = (start+end)/2; \\n\\t\\tTreeNode left = sortedListToBST(start,middle); \\n\\t\\tTreeNode root = sortedListToBST(middle, middle+1);  \\n\\t\\tTreeNode right = sortedListToBST(middle+1,end);\\n\\t\\troot.left=left; root.right=right;\\t\\t\\n\\t\\t \\n\\t\\treturn root;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\t\\tif(head==null) return null;\\n\\t\\tif(head.next==null) return new TreeNode(head.val);\\n\\t\\tListNode slow=head, fast=head,prev=null;\\n\\t\\twhile(fast!=null && fast.next!=null){\\n\\t\\t\\tprev=slow;\\n\\t\\t\\tslow=slow.next;\\n\\t\\t\\tfast=fast.next.next;\\n\\t\\t}\\n\\t\\tprev.next=null;\\n\\t\\tTreeNode root = new TreeNode(slow.val);\\n\\t\\troot.left=sortedListToBST(head);\\n\\t\\troot.right=sortedListToBST(slow.next);\\n\\t\\treturn root;\\n    } \\n```\n```\\n\\tListNode head=null;\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\t\\t int size=0;\\n\\t\\t ListNode curr = head;\\n\\t\\t while(curr!=null){\\n\\t\\t\\tsize++;\\n\\t\\t\\tcurr=curr.next;\\n\\t\\t }\\t\\t \\n\\t\\t this.head=head;\\n\\t\\t return sortedListToBST(0,size);\\n\\t } \\n\\tTreeNode sortedListToBST(int start, int end){\\n\\t\\tif(start>=end) return null; \\n\\t\\t if(start+1==end) {\\n\\t\\t\\t TreeNode node = new TreeNode(head.val);\\n\\t\\t\\t head=head.next; \\n\\t\\t\\t return node;\\n\\t\\t }\\n\\t\\tint middle = (start+end)/2; \\n\\t\\tTreeNode left = sortedListToBST(start,middle); \\n\\t\\tTreeNode root = sortedListToBST(middle, middle+1);  \\n\\t\\tTreeNode right = sortedListToBST(middle+1,end);\\n\\t\\troot.left=left; root.right=right;\\t\\t\\n\\t\\t \\n\\t\\treturn root;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35515,
                "title": "javascript-solution-using-dfs",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {TreeNode}\\n */\\nvar sortedListToBST = function(head) {\\n    if (!head) { return null; }\\n    \\n    return helper(head, null);\\n};\\n\\nvar helper = function(head, tail) {\\n    if (head === tail) { return null; }\\n    \\n    let slow = head;\\n    let fast = head;\\n    while (fast !== tail && fast.next !== tail) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    \\n    let root = new TreeNode(slow.val);\\n    root.left = helper(head, slow);\\n    root.right = helper(slow.next, tail);\\n\\n    return root; \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {TreeNode}\\n */\\nvar sortedListToBST = function(head) {\\n    if (!head) { return null; }\\n    \\n    return helper(head, null);\\n};\\n\\nvar helper = function(head, tail) {\\n    if (head === tail) { return null; }\\n    \\n    let slow = head;\\n    let fast = head;\\n    while (fast !== tail && fast.next !== tail) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    \\n    let root = new TreeNode(slow.val);\\n    root.left = helper(head, slow);\\n    root.right = helper(slow.next, tail);\\n\\n    return root; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35586,
                "title": "o-n-c-code-without-breakdowning-listnode-into-two-halves",
                "content": "   we can use variable `size` to control the subtree size, and use in-order traversal to construct the BST.\\n\\n     class Solution {\\n        public:\\n            TreeNode* sortedListToBST(ListNode* head) {\\n                int size=0;\\n                ListNode *save=head;\\n                while(head){\\n                    size++;\\n                    head = head->next;\\n                }\\n                head = save;\\n                TreeNode* root = helper(head,size);\\n        \\t\\treturn root;\\n            }\\n            TreeNode* helper(ListNode*& head,int size){\\n                if(head==NULL ||size<=0) return NULL;\\n        \\t\\tint rightSize = (size-1)/2; \\n        \\t\\tTreeNode* left = helper(head,size-1-rightSize);\\n        \\t\\tTreeNode* root = new TreeNode(head->val);\\n        \\t\\thead = head->next;\\n        \\t\\troot->left = left;\\n        \\t\\troot->right = helper(head,rightSize);\\n                return root;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            TreeNode* sortedListToBST(ListNode* head) {\\n                int size=0;\\n                ListNode *save=head;\\n                while(head){\\n                    size++;\\n                    head = head->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3283377,
                "title": "python-divide-in-middle-and-recursion-of-left-and-right-parts",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert form middle of list\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDivide list in middle\\nCreate `TreeNode` with middle and recursion of left and right part\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#   def __init__(self, val=0, next=None):\\n#     self.val = val\\n#     self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#   def __init__(self, val=0, left=None, right=None):\\n#     self.val = val\\n#     self.left = left\\n#     self.right = right\\n\\nclass Solution:\\n  def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\\n    if not head: return None\\n    prev = node = mid = head\\n    while node and node.next:\\n      prev = mid\\n      mid = mid.next\\n      node = node.next.next\\n    if head == mid:\\n      return TreeNode(mid.val)\\n    prev.next = None # cul left part of List\\n    return TreeNode(mid.val, self.sortedListToBST(head), self.sortedListToBST(mid.next))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#   def __init__(self, val=0, next=None):\\n#     self.val = val\\n#     self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#   def __init__(self, val=0, left=None, right=None):\\n#     self.val = val\\n#     self.left = left\\n#     self.right = right\\n\\nclass Solution:\\n  def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\\n    if not head: return None\\n    prev = node = mid = head\\n    while node and node.next:\\n      prev = mid\\n      mid = mid.next\\n      node = node.next.next\\n    if head == mid:\\n      return TreeNode(mid.val)\\n    prev.next = None # cul left part of List\\n    return TreeNode(mid.val, self.sortedListToBST(head), self.sortedListToBST(mid.next))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282812,
                "title": "approach-explained-with-example-divide-conquer-bst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne way to solve this problem is by recursively dividing the linked list into two halves and assigning the middle element as the root of the BST. \\n\\n# Example\\n\\n```\\n linked list: -10 -> -7 -> -4 -> 0 -> 5 -> 8 -> 10\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b1870610-10b1-4b8b-a27f-9d1a35a399d6_1678516149.0537305.png)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function takes a linked list as input and returns a pointer to the root of the BST. It first checks if the input head is NULL. If it is, then the function returns NULL. If the head points to the last element in the list, then the function creates a new node with the value of the head and returns it.\\n\\nIf the list has more than one element, then the function uses a two-pointer technique to find the middle element of the list. The fast pointer moves two nodes at a time, while the slow pointer moves one node at a time. When the fast pointer reaches the end of the list, the slow pointer points to the middle element. The function creates a new node with the value of the middle element and assigns it to the root of the BST.\\n\\nThe function then recursively constructs the left subtree of the BST using the help function with the first half of the linked list. Similarly, the function recursively constructs the right subtree of the BST using the help function with the second half of the linked list.\\n\\nFinally, the function returns the root of the constructed BST.\\n\\n# Complexity\\n- Time complexity: The time complexity is **O(nlogn)**, where n is the number of nodes in the linked list. This is because the function recursively constructs a balanced BST, where each node is visited only once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the is **O(logn)**, where n is the number of nodes in the linked list. This is because the function recursively constructs a balanced BST, where the maximum height of the BST is logn.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* help(ListNode* head){\\n        if(!head)return NULL;\\n        if(!head->next) return new TreeNode(head->val);\\n\\n        ListNode *pre=NULL, *slow=head, *fast=head; //slow is to store the middle value\\n\\n        while(fast and fast->next){\\n            pre=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        pre->next=NULL; // this breaks the linkedlist into two parts\\n        TreeNode* root=new TreeNode(slow->val); // mid value is assigned to the root\\n        root->left=help(head); //recursively build the left subtree using head to mid-1\\n        root->right=help(slow->next); //recursively build the right subtree using mid+1 to end\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return help(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n linked list: -10 -> -7 -> -4 -> 0 -> 5 -> 8 -> 10\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* help(ListNode* head){\\n        if(!head)return NULL;\\n        if(!head->next) return new TreeNode(head->val);\\n\\n        ListNode *pre=NULL, *slow=head, *fast=head; //slow is to store the middle value\\n\\n        while(fast and fast->next){\\n            pre=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        pre->next=NULL; // this breaks the linkedlist into two parts\\n        TreeNode* root=new TreeNode(slow->val); // mid value is assigned to the root\\n        root->left=help(head); //recursively build the left subtree using head to mid-1\\n        root->right=help(slow->next); //recursively build the right subtree using mid+1 to end\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return help(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282006,
                "title": "awesome-logic-and-made-me-passionate-on-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if head==None:\\n            return None\\n        if head.next==None:\\n            return TreeNode(head.val)\\n        slow,fast=head,head.next\\n        while fast.next and fast.next.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        mid=slow.next\\n        slow.next=None\\n        root=TreeNode(mid.val)\\n        root.left=self.sortedListToBST(head)\\n        root.right=self.sortedListToBST(mid.next)\\n        return root\\n    #please upvote me it would encourage me alot\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if head==None:\\n            return None\\n        if head.next==None:\\n            return TreeNode(head.val)\\n        slow,fast=head,head.next\\n        while fast.next and fast.next.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        mid=slow.next\\n        slow.next=None\\n        root=TreeNode(mid.val)\\n        root.left=self.sortedListToBST(head)\\n        root.right=self.sortedListToBST(mid.next)\\n        return root\\n    #please upvote me it would encourage me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455904,
                "title": "python-recursive",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        \\n        def root(l):\\n            if l != []:\\n                mid =len(l)//2\\n                node = TreeNode(l[mid])\\n                node.left = root(l[:mid])\\n                node.right = root(l[mid+1:])\\n                return node\\n            else:\\n                return None\\n            \\n        l = []\\n        while(head):\\n            l.append(head.val)\\n            head = head.next\\n        return root(l)`\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        \\n        def root(l):\\n            if l != []:\\n                mid =len(l)//2\\n                node = TreeNode(l[mid])\\n                node.left = root(l[:mid])\\n                node.right = root(l[mid+1:])\\n                return node\\n            else:\\n                return None\\n            \\n        l = []\\n        while(head):\\n            l.append(head.val)\\n            head = head.next\\n        return root(l)`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295332,
                "title": "c-cleanest-code-easiest-to-understand",
                "content": "Saw a lot of solutions which are not beginner friendly and a beginner might easily stumble upon these solutions and feel overwhelmed.So,I wrote a beginner friendly code which is easiest to understand.\\n**Method:**\\nUse the method of fast and slow pointer fast/slow to locate to the midpoint of the chain table, which is the root node, and then cut the ListNode before the midpoint. The left subtree of the root node can call sortedListToBST(head) recursively, and the right subtree can call sortedListToBST(slow-next) recursively.\\n**Edge cases:**\\nIn order to break the ListNode before the midpoint, you need to set a temp to hold the old value of the slow pointer.\\nNote the recursive boundary conditions too,\\nfirstly **(head==NULL)** must be handled separately.\\nSecondly **(head->next==NULL)** also need to be treated separately\\nThe last **(head->next->next==NULL)** also needs to be handled separately *because in this case the fast pointer cannot be advanced and the midpoint of the chain table cannot be located.*\\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n\\t//edge cases\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return new TreeNode(head->val);\\n        }\\n        if(head->next->next==NULL){\\n             TreeNode* root=new TreeNode(head->val);\\n            root->right=new TreeNode(head->next->val);\\n            return root;\\n        }\\n\\t\\t//main code\\n        ListNode *fast,*slow,*temp;\\n        fast=head,slow=head;\\n        while(fast->next and fast->next->next){\\n            temp=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        temp->next=NULL;\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=sortedListToBST(head);\\n        root->right=sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n\\t//edge cases\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return new TreeNode(head->val);\\n        }\\n        if(head->next->next==NULL){\\n             TreeNode* root=new TreeNode(head->val);\\n            root->right=new TreeNode(head->next->val);\\n            return root;\\n        }\\n\\t\\t//main code\\n        ListNode *fast,*slow,*temp;\\n        fast=head,slow=head;\\n        while(fast->next and fast->next->next){\\n            temp=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        temp->next=NULL;\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=sortedListToBST(head);\\n        root->right=sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652776,
                "title": "100-fast-java",
                "content": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next==null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = head;\\n        while(fast!=null && fast.next!=null){\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        prev.next = null;\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        return root;\\n    }\\n}\\n```\\n\\nIf you are looking for solution: <a href = \"https://github.com/Devn913/leetcode\">GIthub Repo</a>\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next==null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = head;\\n        while(fast!=null && fast.next!=null){\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        prev.next = null;\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525470,
                "title": "using-recursion-and-slow-fast-approach-in-c",
                "content": "class Solution {\\npublic:\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return makebst(head,NULL);\\n    }\\n    TreeNode* makebst(ListNode* head, ListNode* tail){\\n        if(head==tail){\\n            return NULL;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast != tail &&fast->next != tail){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=makebst(head,slow);\\n        root->right=makebst(slow->next,tail);\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return makebst(head,NULL);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1416071,
                "title": "recursion-c-easy-and-straight-forward-asked-in-google-interview",
                "content": "This question has been asked in google interview.\\n\\n* First i found the middle element in the list using floyd algorithm.\\n* then i kept a track of node one before the middle element *say temp*\\n* i made a treeNode with the middle element *say root*\\n* then root->left =function(temp);\\n\\troot->right=function(tortoise->next);\\n\\t\\n\\t\\n\\n\\n\\n```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)\\n        {\\n            TreeNode* t=new TreeNode(head->val);\\n            return t;\\n        }   \\n        ListNode* hare=head;\\n        ListNode* temp=head;\\n        ListNode* tortoise=head;\\n        while(hare!=NULL && hare->next!=NULL )\\n        {\\n            hare=hare->next->next;\\n            temp=tortoise;\\n            tortoise=tortoise->next;\\n        }\\n        temp->next=NULL;\\n        TreeNode* root=new TreeNode(tortoise->val);\\n        root->left=sortedListToBST(head);        \\n       root->right=sortedListToBST(tortoise->next);\\n        return root;\\n    }\\n```\\n\\n\\n**please upvote if you liked my solution.\\n#happy_coding**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)\\n        {\\n            TreeNode* t=new TreeNode(head->val);\\n            return t;\\n        }   \\n        ListNode* hare=head;\\n        ListNode* temp=head;\\n        ListNode* tortoise=head;\\n        while(hare!=NULL && hare->next!=NULL )\\n        {\\n            hare=hare->next->next;\\n            temp=tortoise;\\n            tortoise=tortoise->next;\\n        }\\n        temp->next=NULL;\\n        TreeNode* root=new TreeNode(tortoise->val);\\n        root->left=sortedListToBST(head);        \\n       root->right=sortedListToBST(tortoise->next);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388255,
                "title": "java-0ms-easy-to-understand-solution",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n    if(head == null) return null;\\n    ListNode slow = head, fast = head, slowPre = null;\\n    while(fast.next != null && fast.next.next != null){\\n      slowPre = slow;\\n      slow = slow.next;\\n      fast = fast.next.next;\\n    }\\n\\n    if(slowPre != null) slowPre.next = null;\\n    if(slow == null) return null;\\n    TreeNode node = new TreeNode(slow.val);\\n    if(head != slow)node.left = sortedListToBST(head);\\n    node.right = sortedListToBST(slow.next);\\n    return node;\\n  }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n    if(head == null) return null;\\n    ListNode slow = head, fast = head, slowPre = null;\\n    while(fast.next != null && fast.next.next != null){\\n      slowPre = slow;\\n      slow = slow.next;\\n      fast = fast.next.next;\\n    }\\n\\n    if(slowPre != null) slowPre.next = null;\\n    if(slow == null) return null;\\n    TreeNode node = new TreeNode(slow.val);\\n    if(head != slow)node.left = sortedListToBST(head);\\n    node.right = sortedListToBST(slow.next);\\n    return node;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370438,
                "title": "golang-recursive-solution-o-n-o-1",
                "content": "``` go\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n    if head == nil {\\n        return nil\\n    }\\n    \\n    prev, turtle, hare := head, head, head\\n\\n    for hare != nil && hare.Next != nil {\\n        hare = hare.Next.Next\\n        prev = turtle\\n        turtle = turtle.Next\\n    }\\n\\n    res := &TreeNode{ Val : turtle.Val, }\\n    \\n    if turtle.Next != nil {\\n        res.Right = sortedListToBST(turtle.Next)\\n    }\\n\\n    if prev.Next != nil {\\n        prev.Next = nil\\n        res.Left = sortedListToBST(head)\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "``` go\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n    if head == nil {\\n        return nil\\n    }\\n    \\n    prev, turtle, hare := head, head, head\\n\\n    for hare != nil && hare.Next != nil {\\n        hare = hare.Next.Next\\n        prev = turtle\\n        turtle = turtle.Next\\n    }\\n\\n    res := &TreeNode{ Val : turtle.Val, }\\n    \\n    if turtle.Next != nil {\\n        res.Right = sortedListToBST(turtle.Next)\\n    }\\n\\n    if prev.Next != nil {\\n        prev.Next = nil\\n        res.Left = sortedListToBST(head)\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229306,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return newBST(head,NULL);\\n    }\\n    TreeNode* newBST(ListNode* head, ListNode* tail){\\n        if(head==tail)\\n            return NULL;\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast != tail &&fast->next != tail){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=newBST(head,slow);\\n        root->right=newBST(slow->next,tail);\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return newBST(head,NULL);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1195386,
                "title": "java-simple-and-easy-to-understand-solution-t-o-n-s-o-n-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        //covert lindked list to Array List\\n        List<Integer> list = getList(head);\\n        \\n        return getTree(list, 0, list.size() - 1);\\n    }\\n    \\n    private List<Integer> getList(ListNode head){\\n        List<Integer> list = new ArrayList();\\n        \\n        ListNode curr = head;\\n        while(curr != null){\\n            list.add(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private TreeNode getTree(List<Integer> list, int l, int r){\\n        //Invalid case\\n        if(l > r) return null;\\n        \\n        //Leaf node, no child\\n        if(l == r) return new TreeNode(list.get(l));\\n        \\n        //Mid index\\n        int mid = l + ((r - l) / 2);\\n        \\n        //Create node using mid value\\n        TreeNode root = new TreeNode(list.get(mid));\\n        \\n        //Left child\\n        root.left = getTree(list, l, mid - 1);\\n        \\n        //Right child\\n        root.right = getTree(list, mid + 1, r);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        //covert lindked list to Array List\\n        List<Integer> list = getList(head);\\n        \\n        return getTree(list, 0, list.size() - 1);\\n    }\\n    \\n    private List<Integer> getList(ListNode head){\\n        List<Integer> list = new ArrayList();\\n        \\n        ListNode curr = head;\\n        while(curr != null){\\n            list.add(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private TreeNode getTree(List<Integer> list, int l, int r){\\n        //Invalid case\\n        if(l > r) return null;\\n        \\n        //Leaf node, no child\\n        if(l == r) return new TreeNode(list.get(l));\\n        \\n        //Mid index\\n        int mid = l + ((r - l) / 2);\\n        \\n        //Create node using mid value\\n        TreeNode root = new TreeNode(list.get(mid));\\n        \\n        //Left child\\n        root.left = getTree(list, l, mid - 1);\\n        \\n        //Right child\\n        root.right = getTree(list, mid + 1, r);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194315,
                "title": "rust-recursive-solution",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        let mut len = 0;\\n        let mut node = &head;\\n        while let Some(n) = node {\\n            len += 1;\\n            node = &n.next;\\n        }\\n        let mut head = head;\\n        Self::helper(&mut head, len)\\n    }\\n    fn helper(list: &mut Option<Box<ListNode>>, len: usize) -> Option<Rc<RefCell<TreeNode>>> {\\n        if len == 0 {\\n            return None;\\n        }\\n        let left = Self::helper(list, len / 2);\\n        if let Some(head) = list {\\n            let mut node = TreeNode::new(head.val);\\n            *list = head.next.take();\\n            node.left = left;\\n            node.right = Self::helper(list, len - len / 2 - 1);\\n            Some(Rc::new(RefCell::new(node)))\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        let mut len = 0;\\n        let mut node = &head;\\n        while let Some(n) = node {\\n            len += 1;\\n            node = &n.next;\\n        }\\n        let mut head = head;\\n        Self::helper(&mut head, len)\\n    }\\n    fn helper(list: &mut Option<Box<ListNode>>, len: usize) -> Option<Rc<RefCell<TreeNode>>> {\\n        if len == 0 {\\n            return None;\\n        }\\n        let left = Self::helper(list, len / 2);\\n        if let Some(head) = list {\\n            let mut node = TreeNode::new(head.val);\\n            *list = head.next.take();\\n            node.left = left;\\n            node.right = Self::helper(list, len - len / 2 - 1);\\n            Some(Rc::new(RefCell::new(node)))\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540242,
                "title": "avl-tree-solution",
                "content": "it\\'s a bit weird in this way ,but somehow intresting too:)\\nAVL tree remains balance by  four kind of roations during insertion or deletion,what rotation we choose is based on the position relationship of the unbalanced node and the inserted node.\\n## in the problem we always insert to the tree with a increasing sequence,so just need a simple left rotation to rebalance the tree.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int> heights;//the given node has not height attribute\\n    \\n    TreeNode* leftRotation(TreeNode* A){\\n        TreeNode* B=A->right;\\n        A->right=B->left;\\n        B->left=A;\\n        updateHeight(A);\\n        updateHeight(B);\\n        return B;\\n    }\\n    int getHeight(TreeNode* t){\\n        if(!t) return -1;\\n        return heights[t];\\n    }\\n    int updateHeight(TreeNode* t){\\n       return heights[t]=max(getHeight(t->left),getHeight(t->right))+1;\\n    }\\n    TreeNode* insert(TreeNode* root,int x){\\n        if(!root){\\n            auto ans = new TreeNode(x);\\n            heights[ans]=0;\\n            return ans;\\n        }\\n        else if(x>root->val){\\n            root->right=insert(root->right,x);\\n            if(getHeight(root->right)-getHeight(root->left)==2){\\n                root=leftRotation(root);\\n            }\\n        }\\n        updateHeight(root);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        auto p=head;\\n        TreeNode* root=NULL;\\n        while(p){\\n            root=insert(root,p->val);\\n            p=p->next;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int> heights;//the given node has not height attribute\\n    \\n    TreeNode* leftRotation(TreeNode* A){\\n        TreeNode* B=A->right;\\n        A->right=B->left;\\n        B->left=A;\\n        updateHeight(A);\\n        updateHeight(B);\\n        return B;\\n    }\\n    int getHeight(TreeNode* t){\\n        if(!t) return -1;\\n        return heights[t];\\n    }\\n    int updateHeight(TreeNode* t){\\n       return heights[t]=max(getHeight(t->left),getHeight(t->right))+1;\\n    }\\n    TreeNode* insert(TreeNode* root,int x){\\n        if(!root){\\n            auto ans = new TreeNode(x);\\n            heights[ans]=0;\\n            return ans;\\n        }\\n        else if(x>root->val){\\n            root->right=insert(root->right,x);\\n            if(getHeight(root->right)-getHeight(root->left)==2){\\n                root=leftRotation(root);\\n            }\\n        }\\n        updateHeight(root);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        auto p=head;\\n        TreeNode* root=NULL;\\n        while(p){\\n            root=insert(root,p->val);\\n            p=p->next;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199162,
                "title": "javascript-97",
                "content": "https://www.geeksforgeeks.org/sorted-array-to-balanced-bst/\\n\\nBasic idea is traverse the linked list and create an array, then use binary search algorithm to recursively generate the left and right nodes...\\n\\n```\\nvar sortedListToBST = function(head) {\\n    if(!head) return null;\\n    \\n    const sorted = [];\\n    \\n    let cur = head;\\n    \\n    while(cur) {\\n        sorted.push(cur.val);\\n        \\n        cur = cur.next;\\n    }\\n    \\n    const generate = (l, r) => {\\n        if(l > r) return null;\\n        \\n        const mid = Math.floor((r+l)/2);\\n    \\n        let val = sorted[mid];\\n        \\n        const node = new TreeNode(val);\\n\\n        node.left = generate(l, mid-1);\\n        node.right = generate(mid + 1, r);\\n        \\n        return node;\\n    };\\n    \\n    return generate(0, sorted.length-1);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sortedListToBST = function(head) {\\n    if(!head) return null;\\n    \\n    const sorted = [];\\n    \\n    let cur = head;\\n    \\n    while(cur) {\\n        sorted.push(cur.val);\\n        \\n        cur = cur.next;\\n    }\\n    \\n    const generate = (l, r) => {\\n        if(l > r) return null;\\n        \\n        const mid = Math.floor((r+l)/2);\\n    \\n        let val = sorted[mid];\\n        \\n        const node = new TreeNode(val);\\n\\n        node.left = generate(l, mid-1);\\n        node.right = generate(mid + 1, r);\\n        \\n        return node;\\n    };\\n    \\n    return generate(0, sorted.length-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35588,
                "title": "sharing-my-28ms-c-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            else if(head->next == NULL)\\n                return (new TreeNode(head->val));\\n            \\n            ListNode* fast = head->next->next;\\n            ListNode* slow = head;\\n            while(fast && fast->next)\\n            {\\n                fast = fast->next->next;\\n                slow = slow->next;\\n            }\\n            \\n            TreeNode* tree = new TreeNode(slow->next->val);\\n            tree->right = sortedListToBST(slow->next->next);\\n            slow->next = NULL;\\n            tree->left = sortedListToBST(head);\\n            \\n            return tree;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            else if(head->next == NULL)\\n                return (new TreeNode(head->val));\\n            \\n            ListNode* fast = head->next->next;\\n            ListNode* slow = head;\\n            while(fast && fast->next)\\n            {\\n                fast = fast->next->next;\\n                slow = slow->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 35558,
                "title": "divide-conquer-java-solution-complexity",
                "content": "The question is what is time complexity? \\n\\n    public class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val);\\n        \\n        ListNode slow = head, fast = head.next;\\n        while(fast!=null&&fast.next!=null&&fast.next.next!=null){\\n            fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        \\n        TreeNode root = new TreeNode(slow.next.val);\\n        \\n        \\n        ListNode second=slow.next.next;\\n        slow.next=null;\\n        \\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(second);\\n        \\n        return root;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val);\\n        \\n        ListNode slow = head, fast = head.next;\\n        while(fast!=null&&fast.next!=null&&fast.next.next!=null){\\n            fast=fast.next.next;\\n            slow=slow.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3513899,
                "title": "c-easy-solution-beats-82-4-time-35-50-space",
                "content": "![image.png](https://assets.leetcode.com/users/images/cf5f4ba5-2a84-47cb-af10-3d36c8a18112_1683842127.922867.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        if (head == nullptr)\\n        {\\n            return nullptr;\\n        }\\n        vector<int> result = LinkedList_TO_Array(head);\\n\\n        return TreeBuilder(result, 0, result.size() - 1);\\n    }\\n\\n    vector<int> LinkedList_TO_Array(ListNode *head)\\n    {\\n        vector<int> result;\\n        while (head != nullptr)\\n        {\\n            result.push_back(head->val);\\n            head = head->next;\\n        }\\n        return result;\\n    }\\n\\n    TreeNode *TreeBuilder(vector<int> &array, int left, int right)\\n    {\\n        if (left > right)\\n        {\\n            return nullptr;\\n        }\\n        int mid = (left + right) / 2;\\n        TreeNode *root = new TreeNode(array[mid]);\\n        root->left = TreeBuilder(array, left, mid - 1);\\n        root->right = TreeBuilder(array, mid + 1, right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        if (head == nullptr)\\n        {\\n            return nullptr;\\n        }\\n        vector<int> result = LinkedList_TO_Array(head);\\n\\n        return TreeBuilder(result, 0, result.size() - 1);\\n    }\\n\\n    vector<int> LinkedList_TO_Array(ListNode *head)\\n    {\\n        vector<int> result;\\n        while (head != nullptr)\\n        {\\n            result.push_back(head->val);\\n            head = head->next;\\n        }\\n        return result;\\n    }\\n\\n    TreeNode *TreeBuilder(vector<int> &array, int left, int right)\\n    {\\n        if (left > right)\\n        {\\n            return nullptr;\\n        }\\n        int mid = (left + right) / 2;\\n        TreeNode *root = new TreeNode(array[mid]);\\n        root->left = TreeBuilder(array, left, mid - 1);\\n        root->right = TreeBuilder(array, mid + 1, right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364616,
                "title": "java-easy-solution-using-slow-fast-concept-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode convert(ListNode head){\\n          if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val) ;\\n        \\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        \\n        TreeNode root=new TreeNode(slow.next.val);\\n        ListNode right1=slow.next.next;\\n        slow.next=null;\\n        root.left=convert(head);\\n        root.right=convert(right1);\\n        return root;\\n    }\\n    public TreeNode sortedListToBST(ListNode head) {\\n        TreeNode root=convert(head);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode convert(ListNode head){\\n          if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val) ;\\n        \\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        \\n        TreeNode root=new TreeNode(slow.next.val);\\n        ListNode right1=slow.next.next;\\n        slow.next=null;\\n        root.left=convert(head);\\n        root.right=convert(right1);\\n        return root;\\n    }\\n    public TreeNode sortedListToBST(ListNode head) {\\n        TreeNode root=convert(head);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285353,
                "title": "c-fully-explained-simple-divide-and-conquer",
                "content": "```\\n/*\\nIntution Algorithm : Recursion to make BST with Divide and conquer technique\\n\\nFirst thing need to understand is there is multiple answer available because we do not have to make complete BST we just have to make BST that\\'s said which follows the rule for basic BST like parent should be greater than child and left child shuld smaller than parent and right child should be greater than its parent.\\nSteps:\\n    1. We divide whole array in two parts and mid one will our root like eg. [1,-10,-3,0,4,5,9]  0 out root and {1,-10, -3} on left, and {4,5,9} on right\\n    2. Now again if we take left {1, -10, -3} which connected from its parent 0, the root of left will again same procedure the root is -10 and {1} on left and {-3} on right\\n    3. Now again if we go right side we have {1} which itself be a root and no other left or right after making next call it will fall into base case and return null as left and right of 1\\n    4. Same procedures right sides nodes\\n\\nIf you finds my solution useFull please do upvote\\n\\n */\\n/* ====>>> Solution for Leetcode <<<=====  */\\n\\n//  Definition for singly-linked list.\\n/*  struct ListNode {\\n     int val;\\n     ListNode *next;\\n     ListNode() : val(0), next(nullptr) {}\\n     ListNode(int x) : val(x), next(nullptr) {}\\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n };\\n\\n// Definition for a binary tree node.\\n struct TreeNode {\\n     int val;\\n     TreeNode *left;\\n     TreeNode *right;\\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n }; */\\n\\nclass Solution\\n{\\npublic:\\n    TreeNode *makeBst(vector<int> &nodes, int l, int h)\\n    {\\n        if (l > h)\\n            return NULL;\\n        int mid = l + (h - l) / 2;\\n        TreeNode *root = new TreeNode(nodes[mid]);\\n        root->left = makeBst(nodes, l, mid - 1);\\n        root->right = makeBst(nodes, mid + 1, h);\\n        return root;\\n    }\\n\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        vector<int> nodes;\\n        ListNode *curr = head;\\n        while (curr)\\n        {\\n            nodes.emplace_back(curr->val);\\n            curr = curr->next;\\n        }\\n        return makeBst(nodes, 0, nodes.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/*\\nIntution Algorithm : Recursion to make BST with Divide and conquer technique\\n\\nFirst thing need to understand is there is multiple answer available because we do not have to make complete BST we just have to make BST that\\'s said which follows the rule for basic BST like parent should be greater than child and left child shuld smaller than parent and right child should be greater than its parent.\\nSteps:\\n    1. We divide whole array in two parts and mid one will our root like eg. [1,-10,-3,0,4,5,9]  0 out root and {1,-10, -3} on left, and {4,5,9} on right\\n    2. Now again if we take left {1, -10, -3} which connected from its parent 0, the root of left will again same procedure the root is -10 and {1} on left and {-3} on right\\n    3. Now again if we go right side we have {1} which itself be a root and no other left or right after making next call it will fall into base case and return null as left and right of 1\\n    4. Same procedures right sides nodes\\n\\nIf you finds my solution useFull please do upvote\\n\\n */\\n/* ====>>> Solution for Leetcode <<<=====  */\\n\\n//  Definition for singly-linked list.\\n/*  struct ListNode {\\n     int val;\\n     ListNode *next;\\n     ListNode() : val(0), next(nullptr) {}\\n     ListNode(int x) : val(x), next(nullptr) {}\\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n };\\n\\n// Definition for a binary tree node.\\n struct TreeNode {\\n     int val;\\n     TreeNode *left;\\n     TreeNode *right;\\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n }; */\\n\\nclass Solution\\n{\\npublic:\\n    TreeNode *makeBst(vector<int> &nodes, int l, int h)\\n    {\\n        if (l > h)\\n            return NULL;\\n        int mid = l + (h - l) / 2;\\n        TreeNode *root = new TreeNode(nodes[mid]);\\n        root->left = makeBst(nodes, l, mid - 1);\\n        root->right = makeBst(nodes, mid + 1, h);\\n        return root;\\n    }\\n\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        vector<int> nodes;\\n        ListNode *curr = head;\\n        while (curr)\\n        {\\n            nodes.emplace_back(curr->val);\\n            curr = curr->next;\\n        }\\n        return makeBst(nodes, 0, nodes.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284878,
                "title": "easy-solution-and-implementation-of-fully-explained-approach",
                "content": "# Intuition\\nTo convert a singly linked list to a height-balanced binary search tree, we need to find the middle element of the list and use it as the root of the tree. We can recursively apply this process to the left and right halves of the list to construct the left and right subtrees of the root.\\n\\n# Approach\\nIn this implementation, we use two pointers slow and fast to find the middle element of the list. We also keep track of the previous node prev so that we can split the list into two halves.\\n\\nOnce we have found the middle element, we create a new TreeNode with its value and recursively construct the left and right subtrees using the left and right halves of the list.\\n\\nNote that we handle the base cases where the list is empty or contains only one element separately, since in these cases the tree has only one node.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return nullptr;\\n        if (!head->next) return new TreeNode(head->val);\\n\\n        // Find the middle element of the list\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        // Split the list in two halves\\n        prev->next = nullptr;\\n\\n        // Create the root of the tree\\n        TreeNode* root = new TreeNode(slow->val);\\n\\n        // Recursively construct the left and right subtrees\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return nullptr;\\n        if (!head->next) return new TreeNode(head->val);\\n\\n        // Find the middle element of the list\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        // Split the list in two halves\\n        prev->next = nullptr;\\n\\n        // Create the root of the tree\\n        TreeNode* root = new TreeNode(slow->val);\\n\\n        // Recursively construct the left and right subtrees\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284224,
                "title": "c-easy-recursive-solution-o-n-time-complexity",
                "content": "# Intuition\\nBST is a Tree in which the left children are smaller than the root and right children are greater than the root. We can convert the linked list into a array and traverse it recursively using two pointers.\\n\\n# Approach\\nWe convert the Linkedlist into a array and we use two pointers `l` and `r` to split the array into two parts. We convert the middle element into a node of BST. We then recursively traverse the two splits and make them the left and right child respectively for our `mid` node.We return when `l`\\'s position becomes greater than `r`.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n\\n- Space complexity:O(N)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& nums,int l,int r){\\n        if(r<l) return NULL;\\n        int mid = l + (r-l)/2;\\n        TreeNode* root = new TreeNode(nums[mid]);\\n        root->left = helper(nums,l,mid-1);\\n        root->right = helper(nums,mid+1,r);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> nums;\\n        while(head!=NULL){\\n            nums.push_back(head->val);\\n            head=head->next;\\n        }\\n\\n        return helper(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& nums,int l,int r){\\n        if(r<l) return NULL;\\n        int mid = l + (r-l)/2;\\n        TreeNode* root = new TreeNode(nums[mid]);\\n        root->left = helper(nums,l,mid-1);\\n        root->right = helper(nums,mid+1,r);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> nums;\\n        while(head!=NULL){\\n            nums.push_back(head->val);\\n            head=head->next;\\n        }\\n\\n        return helper(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283965,
                "title": "go-python-o-n-log-n-time-o-log-n-time",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n*log(n))$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n    if head == nil{\\n        return nil\\n    }\\n    if head.Next == nil{\\n        return &TreeNode{head.Val,nil,nil}\\n    }\\n    prev := head\\n    slow := head.Next\\n    fast := head.Next.Next\\n    \\n    for fast != nil && fast.Next != nil{\\n        prev = slow\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n\\n    prev.Next = nil\\n    root := TreeNode{slow.Val,nil,nil}\\n\\n    root.Left = sortedListToBST(head)\\n    root.Right = sortedListToBST(slow.Next)\\n    return &root\\n}\\n```\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head:\\n            return None\\n        if not head.next:\\n            return TreeNode(head.val)\\n\\n        prev = head\\n        slow = head.next\\n        fast = head.next.next\\n\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        prev.next = None\\n        root = TreeNode(slow.val)\\n\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(slow.next)\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Two Pointers",
                    "Divide and Conquer",
                    "Binary Search Tree"
                ],
                "code": "```golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n    if head == nil{\\n        return nil\\n    }\\n    if head.Next == nil{\\n        return &TreeNode{head.Val,nil,nil}\\n    }\\n    prev := head\\n    slow := head.Next\\n    fast := head.Next.Next\\n    \\n    for fast != nil && fast.Next != nil{\\n        prev = slow\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n\\n    prev.Next = nil\\n    root := TreeNode{slow.Val,nil,nil}\\n\\n    root.Left = sortedListToBST(head)\\n    root.Right = sortedListToBST(slow.Next)\\n    return &root\\n}\\n```\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head:\\n            return None\\n        if not head.next:\\n            return TreeNode(head.val)\\n\\n        prev = head\\n        slow = head.next\\n        fast = head.next.next\\n\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        prev.next = None\\n        root = TreeNode(slow.val)\\n\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(slow.next)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283668,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while(fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        if(prev) prev -> next = nullptr;\\n        if(slow == head) head = nullptr;\\n        TreeNode* node = new TreeNode(slow->val);\\n        node -> left = buildBST(head);\\n        node -> right = buildBST(slow->next);\\n        return node;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return buildBST(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while(fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        if(prev) prev -> next = nullptr;\\n        if(slow == head) head = nullptr;\\n        TreeNode* node = new TreeNode(slow->val);\\n        node -> left = buildBST(head);\\n        node -> right = buildBST(slow->next);\\n        return node;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return buildBST(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282489,
                "title": "c-recursive-use-of-slow-fast-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind middle of list and create node\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn) recursive stack space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* helper(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            TreeNode* root=new TreeNode(head->val);\\n            return root;\\n        }\\n        \\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        ListNode* prev=slow;\\n        while(fast && fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        prev->next=NULL;\\n        \\n        root->left=helper(head);\\n        root->right=helper(slow->next);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return helper(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* helper(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            TreeNode* root=new TreeNode(head->val);\\n            return root;\\n        }\\n        \\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        ListNode* prev=slow;\\n        while(fast && fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        prev->next=NULL;\\n        \\n        root->left=helper(head);\\n        root->right=helper(slow->next);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return helper(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282203,
                "title": "java-simple-recursion-7-lines-o-n-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<Integer> list = new ArrayList<>();\\n\\n  private TreeNode createBst(int l, int r) {\\n    if (l > r) return null;\\n\\n    var m = l + (r-l) / 2;\\n    return new TreeNode(list.get(m), createBst(l, m-1), createBst(m+1, r));\\n  }\\n\\n  public TreeNode sortedListToBST(ListNode head) {\\n    for (; head != null; head = head.next)\\n      list.add(head.val);\\n\\n    return createBst(0, list.size() - 1);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  List<Integer> list = new ArrayList<>();\\n\\n  private TreeNode createBst(int l, int r) {\\n    if (l > r) return null;\\n\\n    var m = l + (r-l) / 2;\\n    return new TreeNode(list.get(m), createBst(l, m-1), createBst(m+1, r));\\n  }\\n\\n  public TreeNode sortedListToBST(ListNode head) {\\n    for (; head != null; head = head.next)\\n      list.add(head.val);\\n\\n    return createBst(0, list.size() - 1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281940,
                "title": "recursion-easy-explained-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N) time complexity\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N) space complexity\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(int i,int j, vector<int>& help)\\n    {\\n        if(i>j) return NULL; // if starting index is greater than ending index simply return NULL;\\n        int mid=i+(j-i)/2;// calculating mid \\n        TreeNode* root=new TreeNode(help[mid]);// making a node with the value of the mid of the vector\\n// as the vector is sorted , element smaller than the mid will be at the left side of the mid and larger element will be at the right side\\n        root->left=solve(i,mid-1,help);// for left children\\n        root->right=solve(mid+1,j,help);// for right children\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n         vector<int>help; // creating a vector help in which all the value of node will be inserted.\\n         while(head)\\n         {\\n            // pushing all the value of the linked list into the vector\\n             help.push_back(head->val);\\n             head=head->next;\\n         }\\n         int n=help.size(); \\n         // here solve(starting index, ending index, vector)\\n         return solve(0,n-1,help);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(int i,int j, vector<int>& help)\\n    {\\n        if(i>j) return NULL; // if starting index is greater than ending index simply return NULL;\\n        int mid=i+(j-i)/2;// calculating mid \\n        TreeNode* root=new TreeNode(help[mid]);// making a node with the value of the mid of the vector\\n// as the vector is sorted , element smaller than the mid will be at the left side of the mid and larger element will be at the right side\\n        root->left=solve(i,mid-1,help);// for left children\\n        root->right=solve(mid+1,j,help);// for right children\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n         vector<int>help; // creating a vector help in which all the value of node will be inserted.\\n         while(head)\\n         {\\n            // pushing all the value of the linked list into the vector\\n             help.push_back(head->val);\\n             head=head->next;\\n         }\\n         int n=help.size(); \\n         // here solve(starting index, ending index, vector)\\n         return solve(0,n-1,help);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281920,
                "title": "daily-leetcoding-challenge-march-day-11",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion + Conversion to Array\n\n  \n**Approach 3:** Inorder Simulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3035288,
                "title": "c-recursion-linked-list-slow-fast-pointer",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(ListNode* head) {\\n        if(!head) return nullptr;\\n\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n \\n        while(fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        if(prev) prev -> next = nullptr;\\n        if(slow == head) head = nullptr;\\n\\n        TreeNode* node = new TreeNode(slow->val);\\n\\n        node -> left = buildBST(head);\\n        node -> right = buildBST(slow->next);\\n\\n        return node;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return buildBST(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(ListNode* head) {\\n        if(!head) return nullptr;\\n\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n \\n        while(fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        if(prev) prev -> next = nullptr;\\n        if(slow == head) head = nullptr;\\n\\n        TreeNode* node = new TreeNode(slow->val);\\n\\n        node -> left = buildBST(head);\\n        node -> right = buildBST(slow->next);\\n\\n        return node;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return buildBST(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009324,
                "title": "well-detailed-linear-time-complexity-algorithm",
                "content": "# Intuition\\nThe intuition behind this approach is to closely mimic the convert sorted array into a BST.\\n\\n# Approach\\nThe approach is based on the Ionrder Traversal of a Binary tree. First, we find the midpoint of the tree. We then recursively call the function on the left division. Once the base condition is reached, we have just passed the leftmost child. Hence, it returns null and go back to the leftmost child. Now, we are guaranteed that the head (root) will be pointing at the leftmost child. root.left will now be the result of our function on the left division. \\n\\nThe head is then advanced and the function is called on the last part.\\n\\n# Complexity\\n- Time complexity:\\nT(n) = O(n)\\n\\n- Space complexity:\\nT(n) = (logn)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private ListNode node;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) return null;\\n        int n = 0;\\n        ListNode current = head;\\n        node = head;\\n        while (current != null) {\\n            n++;\\n            current = current.next;\\n        }\\n\\n        return helper(0, n - 1);   \\n    }\\n\\n    private TreeNode helper(int start, int end) {\\n        if (start > end) return null;           // is linked list is empty?\\n        int mid = start + (end - start) / 2;\\n\\n        TreeNode leftSubtree = helper(start, mid - 1);\\n        // Recursion is now at the head.\\n\\n        TreeNode root = new TreeNode(node.val);\\n        root.left = leftSubtree;\\n\\n        node = node.next;\\n\\n        TreeNode rightSubtree = helper(mid + 1, end);\\n        root.right = rightSubtree;\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private ListNode node;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) return null;\\n        int n = 0;\\n        ListNode current = head;\\n        node = head;\\n        while (current != null) {\\n            n++;\\n            current = current.next;\\n        }\\n\\n        return helper(0, n - 1);   \\n    }\\n\\n    private TreeNode helper(int start, int end) {\\n        if (start > end) return null;           // is linked list is empty?\\n        int mid = start + (end - start) / 2;\\n\\n        TreeNode leftSubtree = helper(start, mid - 1);\\n        // Recursion is now at the head.\\n\\n        TreeNode root = new TreeNode(node.val);\\n        root.left = leftSubtree;\\n\\n        node = node.next;\\n\\n        TreeNode rightSubtree = helper(mid + 1, end);\\n        root.right = rightSubtree;\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767308,
                "title": "python-beats-86-recursive-solution",
                "content": "```\\nclass Solution:\\n    l = \\'left\\'\\n    r = \\'right\\'\\n    \\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head: return None\\n        \\n        nums = []\\n        while head:\\n            nums.append(head.val)\\n            head = head.next\\n        \\n        mid = len(nums) // 2\\n        treeNode = TreeNode(nums[mid])\\n        \\n        self.binarySearchTree(nums[:mid], self.l, treeNode)\\n        self.binarySearchTree(nums[(mid + 1):], self.r, treeNode)\\n        \\n        return treeNode\\n            \\n            \\n    def binarySearchTree(self, nums, direction, treeNode):\\n        if len(nums) <= 0: return\\n        \\n        mid = len(nums) // 2\\n        left, right = nums[:mid], nums[(mid + 1):]\\n        \\n        if direction == self.l:\\n            treeNode.left = TreeNode(nums[mid])\\n            self.binarySearchTree(left, self.l, treeNode.left)\\n            self.binarySearchTree(right, self.r, treeNode.left)\\n        else:\\n            treeNode.right = TreeNode(nums[mid])\\n            self.binarySearchTree(left, self.l, treeNode.right)\\n            self.binarySearchTree(right, self.r, treeNode.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    l = \\'left\\'\\n    r = \\'right\\'\\n    \\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head: return None\\n        \\n        nums = []\\n        while head:\\n            nums.append(head.val)\\n            head = head.next\\n        \\n        mid = len(nums) // 2\\n        treeNode = TreeNode(nums[mid])\\n        \\n        self.binarySearchTree(nums[:mid], self.l, treeNode)\\n        self.binarySearchTree(nums[(mid + 1):], self.r, treeNode)\\n        \\n        return treeNode\\n            \\n            \\n    def binarySearchTree(self, nums, direction, treeNode):\\n        if len(nums) <= 0: return\\n        \\n        mid = len(nums) // 2\\n        left, right = nums[:mid], nums[(mid + 1):]\\n        \\n        if direction == self.l:\\n            treeNode.left = TreeNode(nums[mid])\\n            self.binarySearchTree(left, self.l, treeNode.left)\\n            self.binarySearchTree(right, self.r, treeNode.left)\\n        else:\\n            treeNode.right = TreeNode(nums[mid])\\n            self.binarySearchTree(left, self.l, treeNode.right)\\n            self.binarySearchTree(right, self.r, treeNode.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414212,
                "title": "convert-sorted-list-to-binary-search-tree-using-recursion-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* construct_tree(ListNode* start, ListNode* end){\\n\\t // base case\\n        if(start==end) return NULL;\\n        \\n           // find the mid using slow and fast pointer\\n        \\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        \\n        while(fast!=end && fast->next!=end){\\n            slow = slow ->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        //slow poimter will retuen mid val \\n        \\n        // create a node and put slow -> val as value\\n        \\n        TreeNode* root = new TreeNode(slow -> val);\\n        root->left = construct_tree(start, slow);\\n        \\n        root->right = construct_tree(slow->next,end);\\n        \\n        \\n        return root;\\n        \\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n         return construct_tree(head, NULL);\\n    }\\n};\\n```\\nIf it helps, please do **Upvote**\\nHappy coding :)",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* construct_tree(ListNode* start, ListNode* end){\\n\\t // base case\\n        if(start==end) return NULL;\\n        \\n           // find the mid using slow and fast pointer\\n        \\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        \\n        while(fast!=end && fast->next!=end){\\n            slow = slow ->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        //slow poimter will retuen mid val \\n        \\n        // create a node and put slow -> val as value\\n        \\n        TreeNode* root = new TreeNode(slow -> val);\\n        root->left = construct_tree(start, slow);\\n        \\n        root->right = construct_tree(slow->next,end);\\n        \\n        \\n        return root;\\n        \\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n         return construct_tree(head, NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240775,
                "title": "c-simple-and-short-recursive-solution-o-n-time-and-o-1-space",
                "content": "**If you find this is helpfull**\\n**Please Upvote it!!**\\n```\\n  TNode* sortedListToBST(LNode *head , LNode *tail = NULL) {\\n        //code here\\n        if(head == tail) return NULL;\\n        \\n        LNode *slow = head , *fast = head;\\n        \\n        while(fast != tail and fast->next != tail){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TNode *root = new TNode(slow->data);\\n        root->left = sortedListToBST(head , slow);\\n        root->right = sortedListToBST(slow->next , tail);\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n  TNode* sortedListToBST(LNode *head , LNode *tail = NULL) {\\n        //code here\\n        if(head == tail) return NULL;\\n        \\n        LNode *slow = head , *fast = head;\\n        \\n        while(fast != tail and fast->next != tail){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TNode *root = new TNode(slow->data);\\n        root->left = sortedListToBST(head , slow);\\n        root->right = sortedListToBST(slow->next , tail);\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230434,
                "title": "python-easy-and-simple",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        lst = []\\n        \\n        if head == None:\\n            return head\\n        \\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n            \\n        \\n        return self.BST(lst)\\n    \\n    def BST(self,lst):\\n      \\n        if not lst:\\n            return None\\n        \\n        mid = len(lst)//2\\n        \\n        root = TreeNode(lst[mid])\\n        \\n        root.left = self.BST(lst[:mid])\\n        root.right = self.BST(lst[mid+1:])\\n        \\n        return root\\n```\\nIf you like please upvote my solution. :)",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        lst = []\\n        \\n        if head == None:\\n            return head\\n        \\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n            \\n        \\n        return self.BST(lst)\\n    \\n    def BST(self,lst):\\n      \\n        if not lst:\\n            return None\\n        \\n        mid = len(lst)//2\\n        \\n        root = TreeNode(lst[mid])\\n        \\n        root.left = self.BST(lst[:mid])\\n        root.right = self.BST(lst[mid+1:])\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190381,
                "title": "c-recursive-solution-simple-approach-explained",
                "content": "The Approach to the problem is very simple.\\nStep 1. Find the mid of the list.\\nStep 2. Make a new node of the tree(say N) with the same value as the mid element found(mid->val).\\nStep 3. Divide the list into two parts from the mid element i.e. a left part and a right part.\\nAfter dividing the list into two make the left of the node(N->left) equal to the mid of the left list and similarly make the right of the node(N->right) equal to the mid of the right list.\\n\\nKeep repeating this process until all elements of the List are traversed.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(head==NULL)\\n            return NULL;\\n        \\n        if(head->next==NULL)\\n            return new TreeNode(head->val);\\n        \\n        ListNode *prev = NULL;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n\\t\\t\\n        //Step 1. Find the mid of the list.\\n\\n        while(fast!=NULL && fast->next!=NULL){\\n            \\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n        }\\n        prev->next = NULL;\\n        //Step 2. Make a new node of the tree(say N) with the same value as the mid element found(mid->val).\\n        TreeNode *root = new TreeNode(slow->val);\\n\\t\\t\\n\\t\\t//Step 3. Divide the list into two parts from the mid element i.e. a left part and a right part.\\n\\t\\t //After dividing the list into two make the left of the node(N->left) equal to the mid of //the left list and similarly make the right of the node(N->right) equal to the mid of the right list.\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n      \\n        return root;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(head==NULL)\\n            return NULL;\\n        \\n        if(head->next==NULL)\\n            return new TreeNode(head->val);\\n        \\n        ListNode *prev = NULL;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n\\t\\t\\n        //Step 1. Find the mid of the list.\\n\\n        while(fast!=NULL && fast->next!=NULL){\\n            \\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n        }\\n        prev->next = NULL;\\n        //Step 2. Make a new node of the tree(say N) with the same value as the mid element found(mid->val).\\n        TreeNode *root = new TreeNode(slow->val);\\n\\t\\t\\n\\t\\t//Step 3. Divide the list into two parts from the mid element i.e. a left part and a right part.\\n\\t\\t //After dividing the list into two make the left of the node(N->left) equal to the mid of //the left list and similarly make the right of the node(N->right) equal to the mid of the right list.\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n      \\n        return root;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845418,
                "title": "c-solution-in-o-n-time",
                "content": "```class Solution {\\npublic:\\n    TreeNode * helper(ListNode *head,ListNode *tail=NULL)\\n    {\\n        if(head==tail)\\n            return NULL;\\n        ListNode *slow=head,*fast=head;\\n        while(fast!=tail&&fast->next!=tail)\\n        {\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            \\n        }\\n        TreeNode * node=new TreeNode(slow->val);\\n        node->left=helper(head,slow);\\n        node->right=helper(slow->next,tail);\\n            return node;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        ListNode *tail=head;\\n        while(tail)\\n        {\\n            tail=tail->next;\\n        }\\n     \\n         return     helper(head,tail);      \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode * helper(ListNode *head,ListNode *tail=NULL)\\n    {\\n        if(head==tail)\\n            return NULL;\\n        ListNode *slow=head,*fast=head;\\n        while(fast!=tail&&fast->next!=tail)\\n        {\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1690438,
                "title": "c-eassy-to-understand-simple-code",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructBST(vector<int> &v,int s,int e)\\n    {\\n        if(s>e)\\n        return NULL;\\n        \\n        int mid=(s+e)/2;\\n        int rootData=v[mid];\\n        TreeNode* root=new TreeNode(rootData);\\n        root->left=constructBST(v,s,mid-1);\\n        root->right=constructBST(v,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> sortedArray;\\n        while(head)\\n        {\\n            sortedArray.push_back(head->val);\\n            head=head->next;\\n        }\\n        return constructBST(sortedArray,0,sortedArray.size()-1);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructBST(vector<int> &v,int s,int e)\\n    {\\n        if(s>e)\\n        return NULL;\\n        \\n        int mid=(s+e)/2;\\n        int rootData=v[mid];\\n        TreeNode* root=new TreeNode(rootData);\\n        root->left=constructBST(v,s,mid-1);\\n        root->right=constructBST(v,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> sortedArray;\\n        while(head)\\n        {\\n            sortedArray.push_back(head->val);\\n            head=head->next;\\n        }\\n        return constructBST(sortedArray,0,sortedArray.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508547,
                "title": "small-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode **slow = &head, **fast = &head;\\n\\t\\t\\n\\t\\t// Get the middle\\n        while((*fast) && (*fast)->next) {\\n            slow = &(*slow)->next;\\n            fast = &(*fast)->next->next;\\n        }\\n\\t\\t\\n\\t\\t// isolate the middle and the left and the right part\\n        ListNode *right = (*slow)->next;\\n        ListNode *cur = (*slow);\\n        (*slow) = nullptr;\\n        cur->next = nullptr;\\n\\t\\t\\n\\t\\t// recursively make the ans\\n        TreeNode *root = new TreeNode(cur->val, sortedListToBST(head), sortedListToBST(right));\\n\\t\\t\\n\\t\\t//fix the list\\n        cur->next = right;\\n        (*slow) = cur;\\n\\t\\t\\n\\t\\t// return ans\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode **slow = &head, **fast = &head;\\n\\t\\t\\n\\t\\t// Get the middle\\n        while((*fast) && (*fast)->next) {\\n            slow = &(*slow)->next;\\n            fast = &(*fast)->next->next;\\n        }\\n\\t\\t\\n\\t\\t// isolate the middle and the left and the right part\\n        ListNode *right = (*slow)->next;\\n        ListNode *cur = (*slow);\\n        (*slow) = nullptr;\\n        cur->next = nullptr;\\n\\t\\t\\n\\t\\t// recursively make the ans\\n        TreeNode *root = new TreeNode(cur->val, sortedListToBST(head), sortedListToBST(right));\\n\\t\\t\\n\\t\\t//fix the list\\n        cur->next = right;\\n        (*slow) = cur;\\n\\t\\t\\n\\t\\t// return ans\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376926,
                "title": "simple-and-efficient-solution-c-faster-than-92",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return createTree(head,NULL,NULL);\\n    }\\n    TreeNode* createTree(ListNode* l,ListNode* r,TreeNode* root){\\n        if(l==r)\\n            return root;\\n        ListNode* mid=findMid(l,r);\\n        if(root==NULL){\\n            root=new TreeNode(mid->val);\\n        }\\n        root->left=createTree(l,mid,root->left);\\n        root->right=createTree(mid->next,r,root->right);\\n        return root;\\n    }\\n    \\n    ListNode* findMid(ListNode * head,ListNode* endNode){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!=NULL&&fast!=endNode&&fast->next!=endNode){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        return slow;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return createTree(head,NULL,NULL);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1358727,
                "title": "c-short-and-easy",
                "content": "```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return NULL;\\n        TreeNode *new_node = new TreeNode();\\n        ListNode *lo = head, *hi = head, *prev;\\n\\t\\t\\n        while(hi -> next && hi -> next -> next) {\\n            hi = hi -> next -> next;\\n            prev = lo;\\n            lo = lo -> next;\\n        }\\n\\t\\t\\n        new_node -> val = lo -> val;\\n        if(prev) {\\n            prev -> next = NULL;\\n            new_node -> left = sortedListToBST(head);\\n        }\\n        if(lo -> next) {\\n            new_node -> right = sortedListToBST(lo -> next);\\n        }\\n\\t\\t\\n        return new_node;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return NULL;\\n        TreeNode *new_node = new TreeNode();\\n        ListNode *lo = head, *hi = head, *prev;\\n\\t\\t\\n        while(hi -> next && hi -> next -> next) {\\n            hi = hi -> next -> next;\\n            prev = lo;\\n            lo = lo -> next;\\n        }\\n\\t\\t\\n        new_node -> val = lo -> val;\\n        if(prev) {\\n            prev -> next = NULL;\\n            new_node -> left = sortedListToBST(head);\\n        }\\n        if(lo -> next) {\\n            new_node -> right = sortedListToBST(lo -> next);\\n        }\\n\\t\\t\\n        return new_node;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1244022,
                "title": "python-o-n-iterative-with-stack-need-not-to-convert-to-array",
                "content": "Code First\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head:\\n            return None\\n        self.head = head\\n        curr = head\\n        cnt = 0\\n        while curr:\\n            cnt += 1\\n            curr = curr.next\\n        \\n        root = TreeNode(float(\\'inf\\'))\\n        stack = [[0, cnt-1, root, False]]\\n\\n        while stack:\\n            start, end, node, status = stack.pop()\\n            \\n            mid = (start + end) >> 1\\n            \\n            if status is False:\\n                if mid+1 <= end:\\n                    node.right = TreeNode(-1)\\n                    stack.append([mid+1, end, node.right, False])\\n\\n                stack.append([start, end, node, True])\\n                \\n                if start <= mid-1:\\n                    node.left = TreeNode(-1)\\n                    stack.append([start, mid-1, node.left, False])\\n            else:\\n                node.val = head.val\\n                head = head.next\\n        \\n        return root\\n```\\n\\nFirstly we need to understand how to in-order traverse with stack. Let\\'s solve an easier problem - https://leetcode.com/problems/binary-tree-inorder-traversal with the following sample code. \\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        ans = []\\n        if not root:\\n            return ans\\n        \\n        stack = [[root, False]]\\n        \\n        while stack:\\n            node, status = stack.pop()\\n            \\n            if status is False:\\n                if node.right:\\n                    stack.append([node.right, False])\\n                stack.append([node, True])\\n                if node.left:\\n                    stack.append([node.left, False])\\n            else:\\n                ans.append(node.val)\\n        \\n        return ans\\n```\\n\\nThe idea is: when we push a node to a stack, we not only save the node itself, but also saves a bool variable - `status`. The rule is\\n\\n  * We always push a node to stack with `status = False`, at first time\\n  * When we retrieve a node with `status = False`, we push left/right child following rule1. At the same time, in the middle of left/right child, we push a `<node, True>`\\n  * When we retrieve a node with `status = True`, we are ready to add the `node.val` to answer list. \\n\\nWe just follow the template and make a little modification. Remember, when we traverse, we use the left/right pointer to get more nodes and push it to stack. When we build (the reverse process of traverse), we need to create left/right pointers, but still push them to stack.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head:\\n            return None\\n        self.head = head\\n        curr = head\\n        cnt = 0\\n        while curr:\\n            cnt += 1\\n            curr = curr.next\\n        \\n        root = TreeNode(float(\\'inf\\'))\\n        stack = [[0, cnt-1, root, False]]\\n\\n        while stack:\\n            start, end, node, status = stack.pop()\\n            \\n            mid = (start + end) >> 1\\n            \\n            if status is False:\\n                if mid+1 <= end:\\n                    node.right = TreeNode(-1)\\n                    stack.append([mid+1, end, node.right, False])\\n\\n                stack.append([start, end, node, True])\\n                \\n                if start <= mid-1:\\n                    node.left = TreeNode(-1)\\n                    stack.append([start, mid-1, node.left, False])\\n            else:\\n                node.val = head.val\\n                head = head.next\\n        \\n        return root\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        ans = []\\n        if not root:\\n            return ans\\n        \\n        stack = [[root, False]]\\n        \\n        while stack:\\n            node, status = stack.pop()\\n            \\n            if status is False:\\n                if node.right:\\n                    stack.append([node.right, False])\\n                stack.append([node, True])\\n                if node.left:\\n                    stack.append([node.left, False])\\n            else:\\n                ans.append(node.val)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241291,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail=NULL) {\\n        if (head == tail) \\n            return NULL;\\n        \\n        ListNode* fast = head, *slow = head;\\n        while (fast != tail && fast->next != tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = sortedListToBST(head, slow);\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail=NULL) {\\n        if (head == tail) \\n            return NULL;\\n        \\n        ListNode* fast = head, *slow = head;\\n        while (fast != tail && fast->next != tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = sortedListToBST(head, slow);\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226248,
                "title": "c-o-n-solution-no-mid-node-calculation-faster-than-92-time",
                "content": "**Approach**-we construct from leaves to root. The idea is to insert nodes in BST in the same order as they appear in Linked List so that the tree can be constructed in O(n) time complexity. We first count the number of nodes in the given Linked List. Let the count be n. After counting nodes, we take left n/2 nodes and recursively construct the left subtree. After left subtree is constructed, we allocate memory for root and link the left subtree with root. Finally, we recursively construct the right subtree and link it with root.\\nWhile constructing the BST, we also keep moving the list head pointer to next so that we have the appropriate pointer in each recursive call.\\n\\n**please upvote if you liked it**\\n\\n**Code** \\n```\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        ListNode* temp = head ;\\n        int l=0 ;\\n        while(temp){\\n            temp=temp->next ;\\n            l++ ;\\n        }\\n        \\n        return l ;\\n    }\\n\\t\\n    TreeNode* helper(ListNode **head , int n){\\n        if(n<=0) return NULL ;\\n        \\n        TreeNode* left = helper(head,n/2) ;\\n        TreeNode* root = new TreeNode((*head)->val) ;\\n        root->left = left ;\\n        \\n\\t\\t/* Change head pointer of Linked List\\n    for parent recursive calls */\\n        (*head)=(*head)->next ;\\n        \\n\\t\\t/* Recursively construct the right \\n        subtree and link it with root \\n        The number of nodes in right subtree\\n        is total nodes - nodes in \\n        left subtree - 1 (for root) which is n-n/2-1*/\\n\\t\\t\\n        root->right = helper(head , n-n/2-1) ;\\n        return root ;\\n        \\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int n = length(head) ;\\n        \\n        return helper(&head, n) ;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        ListNode* temp = head ;\\n        int l=0 ;\\n        while(temp){\\n            temp=temp->next ;\\n            l++ ;\\n        }\\n        \\n        return l ;\\n    }\\n\\t\\n    TreeNode* helper(ListNode **head , int n){\\n        if(n<=0) return NULL ;\\n        \\n        TreeNode* left = helper(head,n/2) ;\\n        TreeNode* root = new TreeNode((*head)->val) ;\\n        root->left = left ;\\n        \\n\\t\\t/* Change head pointer of Linked List\\n    for parent recursive calls */\\n        (*head)=(*head)->next ;\\n        \\n\\t\\t/* Recursively construct the right \\n        subtree and link it with root \\n        The number of nodes in right subtree\\n        is total nodes - nodes in \\n        left subtree - 1 (for root) which is n-n/2-1*/\\n\\t\\t\\n        root->right = helper(head , n-n/2-1) ;\\n        return root ;\\n        \\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int n = length(head) ;\\n        \\n        return helper(&head, n) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203579,
                "title": "3-liner",
                "content": "**Recursive**\\n**time: `O(NlogN)`, space: `O(logN)`**\\n\\n```\\nTreeNode* sortedListToBST(ListNode* h, ListNode* t=nullptr) \\n{ \\n\\tauto p{h};\\n\\tfor(auto q{h}; q!=t and q->next!=t; p=p->next, q=q->next->next);\\n\\treturn p!=t ? new TreeNode(p->val, sortedListToBST(h, p), sortedListToBST(p->next, t)) : nullptr;\\n}\\n```\\n`h` - head, `t` - tail, `p` - \"tortoise\", `q`  - \"hair\".\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/366fce31-4e61-406d-b8c7-9fe77c220f6e_1620778812.8718257.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nTreeNode* sortedListToBST(ListNode* h, ListNode* t=nullptr) \\n{ \\n\\tauto p{h};\\n\\tfor(auto q{h}; q!=t and q->next!=t; p=p->next, q=q->next->next);\\n\\treturn p!=t ? new TreeNode(p->val, sortedListToBST(h, p), sortedListToBST(p->next, t)) : nullptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195009,
                "title": "python-clean-simple",
                "content": "1. Extract to an array\\n\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        arr = []\\n        while head:\\n            arr.append(head.val)\\n            head = head.next\\n\\t\\t\\n        def dfs(l, r):\\n            if l > r: return None\\n            mid = l + (r - l) // 2\\n            return TreeNode(arr[mid], dfs(l, mid-1), dfs(mid+1, r))\\n\\t\\t\\n        return dfs(0, len(arr)-1)\\n```\\n\\n2. Slow fast pointers\\n\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def dfs(head, tail):\\n            if head == tail: return None\\n            slow = fast = head\\n            while fast != tail and fast.next != tail:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return TreeNode(slow.val, dfs(head, slow), dfs(slow.next, tail))\\n\\t\\t\\n        return dfs(head, None)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        arr = []\\n        while head:\\n            arr.append(head.val)\\n            head = head.next\\n\\t\\t\\n        def dfs(l, r):\\n            if l > r: return None\\n            mid = l + (r - l) // 2\\n            return TreeNode(arr[mid], dfs(l, mid-1), dfs(mid+1, r))\\n\\t\\t\\n        return dfs(0, len(arr)-1)\\n```\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def dfs(head, tail):\\n            if head == tail: return None\\n            slow = fast = head\\n            while fast != tail and fast.next != tail:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return TreeNode(slow.val, dfs(head, slow), dfs(slow.next, tail))\\n\\t\\t\\n        return dfs(head, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194985,
                "title": "c-using-binary-search-property-easy-approach-commented",
                "content": "```\\n  TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> vec;\\n        while(head)\\n        {\\n            vec.push_back(head->val);       //store values in vector for easy navigation\\n            head = head->next;\\n        }\\n        int l, r;\\n        l=0; r = vec.size()-1;\\n        TreeNode *root;\\n        root= generateBST(vec, l, r);      \\n        return root;\\n    }\\n    \\n    TreeNode * generateBST(vector<int> &vec, int l, int r)\\n    {\\n        if(l>r)\\n            return NULL;\\n        int mid = l+(r-l)/2;        // find middle node and make it root\\n        TreeNode *newNode = new TreeNode(vec[mid]);\\n        \\n        newNode->left = generateBST(vec, l, mid-1);     // root->left = binary search on left half vector\\n        newNode->right = generateBST(vec, mid+1, r);    //root->right = binary search on right half vector\\n        \\n        return newNode;\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n  TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> vec;\\n        while(head)\\n        {\\n            vec.push_back(head->val);       //store values in vector for easy navigation\\n            head = head->next;\\n        }\\n        int l, r;\\n        l=0; r = vec.size()-1;\\n        TreeNode *root;\\n        root= generateBST(vec, l, r);      \\n        return root;\\n    }\\n    \\n    TreeNode * generateBST(vector<int> &vec, int l, int r)\\n    {\\n        if(l>r)\\n            return NULL;\\n        int mid = l+(r-l)/2;        // find middle node and make it root\\n        TreeNode *newNode = new TreeNode(vec[mid]);\\n        \\n        newNode->left = generateBST(vec, l, mid-1);     // root->left = binary search on left half vector\\n        newNode->right = generateBST(vec, mid+1, r);    //root->right = binary search on right half vector\\n        \\n        return newNode;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194900,
                "title": "c-simple-recursive-and-short-solution",
                "content": "Please feel free to ask questions if there is any difficulty understanding the code!\\n\\n```\\nclass Solution {\\npublic:\\n\\t// initialize an array which is used to store the list values as we \\n\\t// can\\'t afford to traverse everytime we require a value\\n    vector<int> v; \\n    \\n\\t// helper function to take care of the tree values\\n    TreeNode* helper(int st, int en){\\n\\t\\t// let recursion do the hectic work \\n\\t\\t// and we focus only on end points\\n        if(st>en)\\n            return NULL;\\n        else if(st==en)\\n            return new TreeNode(v[st]);\\n        int mid=(st+en)/2;\\n\\t\\t\\n\\t\\t// using the TreeNode constructor to provide value\\n\\t\\t// and both the pointer values which we get by recursion\\n        return new TreeNode(v[mid], helper(st,mid-1), helper(mid+1,en));\\n    }\\n    \\n\\t// set our vector v according to the linked list provided\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }    \\n        return helper(0,v.size()-1);\\n    }\\n};\\n```\\n\\nPlease upvote if you like my code!",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// initialize an array which is used to store the list values as we \\n\\t// can\\'t afford to traverse everytime we require a value\\n    vector<int> v; \\n    \\n\\t// helper function to take care of the tree values\\n    TreeNode* helper(int st, int en){\\n\\t\\t// let recursion do the hectic work \\n\\t\\t// and we focus only on end points\\n        if(st>en)\\n            return NULL;\\n        else if(st==en)\\n            return new TreeNode(v[st]);\\n        int mid=(st+en)/2;\\n\\t\\t\\n\\t\\t// using the TreeNode constructor to provide value\\n\\t\\t// and both the pointer values which we get by recursion\\n        return new TreeNode(v[mid], helper(st,mid-1), helper(mid+1,en));\\n    }\\n    \\n\\t// set our vector v according to the linked list provided\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }    \\n        return helper(0,v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194780,
                "title": "java-clean-concise-optimal-code-two-pointer-technique-100-beats-solution",
                "content": "```\\nclass Solution {\\n    \\n    public ListNode middleOfLinkedList (ListNode head, ListNode tail) {\\n        \\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while (fast != tail && fast.next != tail) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n    public TreeNode constructBST (ListNode head, ListNode tail) {\\n        \\n        if (head == tail) {\\n            return null;\\n        }\\n        \\n        ListNode middle = middleOfLinkedList (head, tail);\\n        \\n        TreeNode root = new TreeNode (middle.val);\\n        root.left = constructBST (head, middle);\\n        root.right = constructBST (middle.next, tail);\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode sortedListToBST(ListNode head) {\\n        \\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        return constructBST (head, null);\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public ListNode middleOfLinkedList (ListNode head, ListNode tail) {\\n        \\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while (fast != tail && fast.next != tail) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n    public TreeNode constructBST (ListNode head, ListNode tail) {\\n        \\n        if (head == tail) {\\n            return null;\\n        }\\n        \\n        ListNode middle = middleOfLinkedList (head, tail);\\n        \\n        TreeNode root = new TreeNode (middle.val);\\n        root.left = constructBST (head, middle);\\n        root.right = constructBST (middle.next, tail);\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode sortedListToBST(ListNode head) {\\n        \\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        return constructBST (head, null);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194021,
                "title": "c-recursion",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail = NULL) \\n    {\\n        // further tree can\\'t be constructed\\n        if (head == tail) \\n            return NULL;\\n        \\n        // slow is used to divide the current list into two equal parts\\n        // fast is just used to ensure that list is appropriately divided\\n        ListNode* fast = head, *slow = head;\\n        \\n        while (fast != tail && fast->next != tail) \\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        // slow is the root of current subtree\\n        TreeNode* root = new TreeNode(slow->val);\\n        \\n        // left subtree is the list from head to slow-1\\n        root->left = sortedListToBST(head, slow);\\n        \\n        // right subtree is the list from slow->next to tail-1\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail = NULL) \\n    {\\n        // further tree can\\'t be constructed\\n        if (head == tail) \\n            return NULL;\\n        \\n        // slow is used to divide the current list into two equal parts\\n        // fast is just used to ensure that list is appropriately divided\\n        ListNode* fast = head, *slow = head;\\n        \\n        while (fast != tail && fast->next != tail) \\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        // slow is the root of current subtree\\n        TreeNode* root = new TreeNode(slow->val);\\n        \\n        // left subtree is the list from head to slow-1\\n        root->left = sortedListToBST(head, slow);\\n        \\n        // right subtree is the list from slow->next to tail-1\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063345,
                "title": "javascript-convert-to-array-and-recursion-time-and-space-o-n",
                "content": "```\\nvar sortedListToBST = function (head) {\\n\\n  if (head === null) {\\n    return null;\\n  }\\n\\n  const list = [];\\n  while (head !== null) {\\n    list.push(head.val);\\n    head = head.next;\\n  }\\n\\n  return findHead(0, list.length - 1);\\n\\n  function findHead(start, end) {\\n\\n    if (start > end) {\\n      return null;\\n    }\\n    const middle = Math.ceil((start + end) / 2);\\n\\n    const left = findHead(start, middle - 1);\\n    const right = findHead(middle + 1, end);\\n\\n    return new TreeNode(list[middle], left, right);\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar sortedListToBST = function (head) {\\n\\n  if (head === null) {\\n    return null;\\n  }\\n\\n  const list = [];\\n  while (head !== null) {\\n    list.push(head.val);\\n    head = head.next;\\n  }\\n\\n  return findHead(0, list.length - 1);\\n\\n  function findHead(start, end) {\\n\\n    if (start > end) {\\n      return null;\\n    }\\n    const middle = Math.ceil((start + end) / 2);\\n\\n    const left = findHead(start, middle - 1);\\n    const right = findHead(middle + 1, end);\\n\\n    return new TreeNode(list[middle], left, right);\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 787041,
                "title": "python-3-recursive-solution-convert-to-array-first-124ms",
                "content": "Approach:\\n1. The linked list is traversed and its elements are appended into an array ```L```.\\n2. Because this array is sorted, it becomes **similar** to problem [108. Convert Sorted Array to BST](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\\n3. The middle element ```mid``` is calculated which **becomes the root**.\\n4. The values of the left and right nodes are `recursively` calculated.\\n\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        L = []\\n        while (head != None):\\n            L.append(head.val)\\n            head = head.next\\n\\t\\t\\t\\n        def createBST(L):\\n            if not L:\\n                return None\\n            else:\\n                mid = len(L) // 2\\n                root = TreeNode(L[mid])\\n                root.left, root.right = createBST(L[:mid]), createBST(L[mid+1:])\\n            return root\\n        return createBST(L)\\n#32/32 test cases passed.\\n```\\n![image](https://assets.leetcode.com/users/images/f0c3ec5c-2c8e-4423-b92d-d45bf858483f_1597210618.4942033.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```L```\n```mid```\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        L = []\\n        while (head != None):\\n            L.append(head.val)\\n            head = head.next\\n\\t\\t\\t\\n        def createBST(L):\\n            if not L:\\n                return None\\n            else:\\n                mid = len(L) // 2\\n                root = TreeNode(L[mid])\\n                root.left, root.right = createBST(L[:mid]), createBST(L[mid+1:])\\n            return root\\n        return createBST(L)\\n#32/32 test cases passed.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720615,
                "title": "python-3-sorted-linkedlist-sorted-list-binary-search-tree",
                "content": "```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def traverseList(head):\\n            while head:\\n                linkedListVal.append(head.val)\\n                head = head.next\\n        def constructBST(arr):\\n            if not arr:\\n                return None\\n            mid = len(arr) // 2\\n            tree = TreeNode(arr[mid])\\n            tree.left = constructBST(arr[ : mid])\\n            tree.right = constructBST(arr[mid + 1 : ])     \\n            return tree\\n        linkedListVal = []\\n        traverseList(head)\\n        print(linkedListVal)\\n        root = constructBST(linkedListVal)\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def traverseList(head):\\n            while head:\\n                linkedListVal.append(head.val)\\n                head = head.next\\n        def constructBST(arr):\\n            if not arr:\\n                return None\\n            mid = len(arr) // 2\\n            tree = TreeNode(arr[mid])\\n            tree.left = constructBST(arr[ : mid])\\n            tree.right = constructBST(arr[mid + 1 : ])     \\n            return tree\\n        linkedListVal = []\\n        traverseList(head)\\n        print(linkedListVal)\\n        root = constructBST(linkedListVal)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331051,
                "title": "python3-solution-with-slow-fast-pointer",
                "content": "\\tclass Solution:\\n\\t\\tdef sortedListToBST(self, head: ListNode) -> TreeNode:\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\tif not head.next:\\n\\t\\t\\t\\treturn TreeNode(head.val)\\n\\t\\t\\tmid=self.findMid(head)\\n\\t\\t\\troot=TreeNode(mid.val)\\n\\t\\t\\troot.left=self.sortedListToBST(head)\\n\\t\\t\\troot.right=self.sortedListToBST(mid.next)\\n\\t\\t\\treturn root\\n\\n\\t\\tdef findMid(self,head):\\n\\t\\t\\tfast=slow=head\\n\\t\\t\\tpre=None\\n\\t\\t\\twhile fast and fast.next:\\n\\t\\t\\t\\tpre=slow\\n\\t\\t\\t\\tslow=slow.next\\n\\t\\t\\t\\tfast=fast.next.next\\n\\t\\t\\tpre.next=None\\n\\t\\t\\treturn slow",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef sortedListToBST(self, head: ListNode) -> TreeNode:\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\tif not head.next:\\n\\t\\t\\t\\treturn TreeNode(head.val)\\n\\t\\t\\tmid=self.findMid(head)\\n\\t\\t\\troot=TreeNode(mid.val)\\n\\t\\t\\troot.left=self.sortedListToBST(head)\\n\\t\\t\\troot.right=self.sortedListToBST(mid.next)\\n\\t\\t\\treturn root\\n\\n\\t\\tdef findMid(self,head):\\n\\t\\t\\tfast=slow=head\\n\\t\\t\\tpre=None\\n\\t\\t\\twhile fast and fast.next:\\n\\t\\t\\t\\tpre=slow\\n\\t\\t\\t\\tslow=slow.next\\n\\t\\t\\t\\tfast=fast.next.next\\n\\t\\t\\tpre.next=None\\n\\t\\t\\treturn slow",
                "codeTag": "Java"
            },
            {
                "id": 138146,
                "title": "python-231-ms-recursive-solution-beat-97-1",
                "content": "My solution is very straight forward, convert the linkedlist to list. And making use of recursion to build the tree. But I got confused, what does the interviewer want to see from this problem ? Should we still retain the linkedlist ? Should we not to use extra O(n) space ? Well, I tried the one from @caikehe, but now it`s no longer accepted by the OJ because some new test cases added. https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/discuss/35555/Clean-C++-solution.-Recursion.-O(nlogn).-With-comment\\nAnyway, here is my code:\\n```\\n        tree = []\\n        while head:\\n            tree.append(head.val)\\n            head = head.next\\n        root = self.constructTree(tree)        \\n        return root\\n    \\n    def constructTree(self, tree):\\n        if not tree:\\n            return\\n        mid = len(tree)/2\\n        root = TreeNode(tree[mid])\\n        root.left = self.constructTree(tree[:mid])\\n        root.right = self.constructTree(tree[mid+1:])\\n        return root\\n ```",
                "solutionTags": [],
                "code": "```\\n        tree = []\\n        while head:\\n            tree.append(head.val)\\n            head = head.next\\n        root = self.constructTree(tree)        \\n        return root\\n    \\n    def constructTree(self, tree):\\n        if not tree:\\n            return\\n        mid = len(tree)/2\\n        root = TreeNode(tree[mid])\\n        root.left = self.constructTree(tree[:mid])\\n        root.right = self.constructTree(tree[mid+1:])\\n        return root\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 35488,
                "title": "simple-c-divide-conquer-o-1-space",
                "content": "```\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return NULL;\\n        if(!head->next) return new TreeNode(head->val);\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        ListNode* pre = new ListNode(0);\\n        pre->next = slow;\\n        // Root is the mid position of the linked list\\n        while(fast){\\n            slow = slow->next;\\n            pre = pre->next;\\n            fast = fast->next ? fast->next->next : NULL;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        pre->next = NULL;\\n        // Call recursively to left and right part of linked list\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "```\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return NULL;\\n        if(!head->next) return new TreeNode(head->val);\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        ListNode* pre = new ListNode(0);\\n        pre->next = slow;\\n        // Root is the mid position of the linked list\\n        while(fast){\\n            slow = slow->next;\\n            pre = pre->next;\\n            fast = fast->next ? fast->next->next : NULL;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        pre->next = NULL;\\n        // Call recursively to left and right part of linked list\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35565,
                "title": "javascript-solution",
                "content": "    function sortedListToBST(head) {\\n        if (!head) {\\n            return null;\\n        }\\n        \\n        if (!head.next) {\\n            return new TreeNode(head.val);\\n        }\\n        \\n        var m = head;\\n        var prev = head;\\n        var tail = head;\\n        \\n        // head, prev, m -> ... -> null\\n        while (tail && tail.next) {\\n            tail = tail.next.next;\\n            prev = m;\\n            m = m.next;\\n        }\\n        // head -> ... -> prev -> m -> ... -> null\\n        \\n        prev.next = null;\\n        \\n        var n = new TreeNode(m.val);\\n        n.left = sortedListToBST(head);\\n        n.right = sortedListToBST(m.next);\\n        return n;\\n    }",
                "solutionTags": [],
                "code": "    function sortedListToBST(head) {\\n        if (!head) {\\n            return null;\\n        }\\n        \\n        if (!head.next) {\\n            return new TreeNode(head.val);\\n        }\\n        \\n        var m = head;\\n        var prev = head;\\n        var tail = head;\\n        \\n        // head, prev, m -> ... -> null\\n        while (tail && tail.next) {\\n            tail = tail.next.next;\\n            prev = m;\\n            m = m.next;\\n        }\\n        // head -> ... -> prev -> m -> ... -> null\\n        \\n        prev.next = null;\\n        \\n        var n = new TreeNode(m.val);\\n        n.left = sortedListToBST(head);\\n        n.right = sortedListToBST(m.next);\\n        return n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 35571,
                "title": "clear-and-easy-c-solution",
                "content": "    TreeNode* sortedListToBST(ListNode* head) {\\n    \\tint len = 0;\\n    \\tListNode *cur = head;\\n    \\twhile (cur) {\\n    \\t\\tlen++;\\n    \\t\\tcur = cur->next;\\n    \\t}\\n    \\treturn help(head, len);\\n    }\\n    TreeNode* help(ListNode* head, int len) {\\n    \\tif (len <= 0)\\n    \\t\\treturn NULL;\\n    \\tListNode *cur = head;\\n    \\tint mid = len / 2;\\n    \\twhile (mid) {\\n    \\t\\tcur = cur->next;\\n    \\t\\tmid--;\\n    \\t}\\n    \\tTreeNode *root = new TreeNode(cur->val);\\n    \\troot->left = help(head, len/2);\\n    \\troot->right = help(cur->next, len-len/2-1);\\n    \\treturn root;\\n    }",
                "solutionTags": [],
                "code": "    TreeNode* sortedListToBST(ListNode* head) {\\n    \\tint len = 0;\\n    \\tListNode *cur = head;\\n    \\twhile (cur) {\\n    \\t\\tlen++;\\n    \\t\\tcur = cur->next;\\n    \\t}\\n    \\treturn help(head, len);\\n    }\\n    TreeNode* help(ListNode* head, int len) {\\n    \\tif (len <= 0)\\n    \\t\\treturn NULL;\\n    \\tListNode *cur = head;\\n    \\tint mid = len / 2;\\n    \\twhile (mid) {\\n    \\t\\tcur = cur->next;\\n    \\t\\tmid--;\\n    \\t}\\n    \\tTreeNode *root = new TreeNode(cur->val);\\n    \\troot->left = help(head, len/2);\\n    \\troot->right = help(cur->next, len-len/2-1);\\n    \\treturn root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4056958,
                "title": "similar-as-convert-sorted-array-to-binary-search-tree",
                "content": "###### Same as [https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/solutions/4027619/easy-solution/]\\n\\n\\n# Intuition\\n### we use here List and store element we know in quetion it is given that  linkedlist is sorted\\n### And we know that in BST left element is smaller then root and right is greater \\n\\n### so we find here middle of list \\n### put node.left = middle -1\\n### node.right = middle+1;\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)return null;\\n        List<Integer>ans= new ArrayList<>();\\n         \\n        while(head!=null){\\n            ans.add(head.val);\\n            head=head.next;\\n        }\\n         return f(ans,0,ans.size()-1);\\n    }\\n    public TreeNode f(List<Integer>nums,int l,int h){\\n        if(l>h)return null;\\n        int mid=(l+h)/2;\\n        TreeNode node=new TreeNode(nums.get(mid));\\n        node.left=f(nums,l,mid-1);\\n        node.right=f(nums,mid+1,h);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)return null;\\n        List<Integer>ans= new ArrayList<>();\\n         \\n        while(head!=null){\\n            ans.add(head.val);\\n            head=head.next;\\n        }\\n         return f(ans,0,ans.size()-1);\\n    }\\n    public TreeNode f(List<Integer>nums,int l,int h){\\n        if(l>h)return null;\\n        int mid=(l+h)/2;\\n        TreeNode node=new TreeNode(nums.get(mid));\\n        node.left=f(nums,l,mid-1);\\n        node.right=f(nums,mid+1,h);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994172,
                "title": "easiest-clean-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return nullptr;\\n        if (!head->next) return new TreeNode (head->val);\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        prev->next = nullptr;\\n        TreeNode *node = new TreeNode (slow->val);\\n        node->left = sortedListToBST(head);\\n        node->right = sortedListToBST(slow->next);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return nullptr;\\n        if (!head->next) return new TreeNode (head->val);\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        prev->next = nullptr;\\n        TreeNode *node = new TreeNode (slow->val);\\n        node->left = sortedListToBST(head);\\n        node->right = sortedListToBST(slow->next);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979949,
                "title": "best-c-solution-simple-linked-list-approach-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode *sortedListToBST(ListNode *head){\\n    \\treturn create( head, NULL );\\n    }\\n\\n    TreeNode *create(ListNode *head, ListNode *tail){\\n    \\t// base case\\n        if(head == tail)\\n    \\t\\treturn NULL;\\n\\n        // find middle of LL\\n    \\tListNode *mid = head, *temp = head;\\n    \\twhile( temp != tail && temp->next != tail ) {\\n    \\t\\tmid = mid->next;\\n    \\t\\ttemp = temp->next->next;\\n    \\t}\\n\\n        // Create new node with mid->val and recursively find its left and right subtree\\n    \\tTreeNode *root = new TreeNode( mid->val );\\n    \\troot->left = create( head, mid );\\n    \\troot->right = create( mid->next, tail );\\n    \\treturn root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *sortedListToBST(ListNode *head){\\n    \\treturn create( head, NULL );\\n    }\\n\\n    TreeNode *create(ListNode *head, ListNode *tail){\\n    \\t// base case\\n        if(head == tail)\\n    \\t\\treturn NULL;\\n\\n        // find middle of LL\\n    \\tListNode *mid = head, *temp = head;\\n    \\twhile( temp != tail && temp->next != tail ) {\\n    \\t\\tmid = mid->next;\\n    \\t\\ttemp = temp->next->next;\\n    \\t}\\n\\n        // Create new node with mid->val and recursively find its left and right subtree\\n    \\tTreeNode *root = new TreeNode( mid->val );\\n    \\troot->left = create( head, mid );\\n    \\troot->right = create( mid->next, tail );\\n    \\treturn root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973266,
                "title": "easy-to-understand-code-with-high-efficiency",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void create(TreeNode* &root, vector<int> &arr, int s, int e){\\n        if(s>e) return;\\n        int mid = (s+e)/2;\\n        root = new TreeNode(arr[mid]);\\n        create(root->left, arr, s, mid-1);\\n        create(root->right, arr, mid+1 , e);\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        TreeNode* root = NULL;\\n        vector<int> arr;\\n        while(head) {\\n        arr.push_back(head->val);\\n        head=head->next;}\\n        create(root, arr, 0, arr.size()-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void create(TreeNode* &root, vector<int> &arr, int s, int e){\\n        if(s>e) return;\\n        int mid = (s+e)/2;\\n        root = new TreeNode(arr[mid]);\\n        create(root->left, arr, s, mid-1);\\n        create(root->right, arr, mid+1 , e);\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        TreeNode* root = NULL;\\n        vector<int> arr;\\n        while(head) {\\n        arr.push_back(head->val);\\n        head=head->next;}\\n        create(root, arr, 0, arr.size()-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873221,
                "title": "a-c-solution",
                "content": "recursive solution you basically want every mid point of a sub link list to have its left child to be the mid of its left and the right to be the mid of its right\\n(help me clean up my code i know its quite bad)\\n# Code\\n```\\nstruct TreeNode* sortedListToBST(struct ListNode* head){\\n    if(!head) return NULL;\\n    if(!head->next) {\\n        struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n        node->val = head->val;\\n        node->left = NULL;\\n        node->right = NULL;\\n        return node;\\n    }\\n\\n    struct ListNode* slow = head;\\n    struct ListNode* fast = head;\\n    struct ListNode* prev = head;\\n\\n    while(fast && fast->next) {\\n        fast = fast->next->next;\\n        prev = slow;\\n        slow = slow->next;\\n    }\\n\\n    prev->next = NULL;\\n\\n    struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n    node->val = slow->val;\\n    node->left = sortedListToBST(head);\\n    node->right = sortedListToBST(slow->next);\\n\\n    return node;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct TreeNode* sortedListToBST(struct ListNode* head){\\n    if(!head) return NULL;\\n    if(!head->next) {\\n        struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n        node->val = head->val;\\n        node->left = NULL;\\n        node->right = NULL;\\n        return node;\\n    }\\n\\n    struct ListNode* slow = head;\\n    struct ListNode* fast = head;\\n    struct ListNode* prev = head;\\n\\n    while(fast && fast->next) {\\n        fast = fast->next->next;\\n        prev = slow;\\n        slow = slow->next;\\n    }\\n\\n    prev->next = NULL;\\n\\n    struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n    node->val = slow->val;\\n    node->left = sortedListToBST(head);\\n    node->right = sortedListToBST(slow->next);\\n\\n    return node;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3535639,
                "title": "east-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* findmid(ListNode* head){\\n        if(head->next == NULL) return head;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = NULL;\\n        \\n        while(slow  != NULL && fast != NULL && fast->next != NULL) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast=fast->next->next;\\n        }\\n        if(prev !=  NULL) prev->next = NULL; // DISCONNECT LINK PREV OF THE MIDDLE  \\n        return slow;\\n    }\\n    TreeNode* solve(ListNode* head){\\n        // BASE CASE \\n        if(head == NULL) return NULL;\\n       \\n        // IF WE HAVE ONLY ONE NODE THEN CREATE TREE AND RETURN \\n        if(head->next == NULL){\\n           TreeNode*root = new TreeNode(head->val);\\n           return root;\\n        }\\n        // FIND MIDDLE NODE OF THE LINK LIST\\n        ListNode*mid = findmid(head);\\n        TreeNode*root = NULL;\\n\\n        // IF MID NULL RETURN NULL\\n        if(mid == NULL ) return NULL;\\n        else root = new TreeNode(mid->val); // ELSE CREATE TREE NODE\\n    \\n         root->left = solve(head); // SOLVE LEFT PART\\n         root->right = solve(mid->next); // SOLVE RIGHT PART\\n         return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n       \\n        if(head == NULL) return NULL;\\n        return solve(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* findmid(ListNode* head){\\n        if(head->next == NULL) return head;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = NULL;\\n        \\n        while(slow  != NULL && fast != NULL && fast->next != NULL) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast=fast->next->next;\\n        }\\n        if(prev !=  NULL) prev->next = NULL; // DISCONNECT LINK PREV OF THE MIDDLE  \\n        return slow;\\n    }\\n    TreeNode* solve(ListNode* head){\\n        // BASE CASE \\n        if(head == NULL) return NULL;\\n       \\n        // IF WE HAVE ONLY ONE NODE THEN CREATE TREE AND RETURN \\n        if(head->next == NULL){\\n           TreeNode*root = new TreeNode(head->val);\\n           return root;\\n        }\\n        // FIND MIDDLE NODE OF THE LINK LIST\\n        ListNode*mid = findmid(head);\\n        TreeNode*root = NULL;\\n\\n        // IF MID NULL RETURN NULL\\n        if(mid == NULL ) return NULL;\\n        else root = new TreeNode(mid->val); // ELSE CREATE TREE NODE\\n    \\n         root->left = solve(head); // SOLVE LEFT PART\\n         root->right = solve(mid->next); // SOLVE RIGHT PART\\n         return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n       \\n        if(head == NULL) return NULL;\\n        return solve(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418157,
                "title": "java-inorder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince the give list is sorted which is equivalent to inorder traversal of binary search tree that is left root right.\\nso it is clear that the root is the middle node of sorted list so using this intuition we are gonna come up with the solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is very simple just always find the middle element in the list using fast and slow pointers.\\nAfter finding the root node that is middle element in the given sorted list we will have to cut the link in order to find the nodes left and right since they are nothing but middle elements in left and right half of the list.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: recursive stack space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val);\\n        ListNode mid=null;\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null)\\n        {\\n            mid=slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode node=new TreeNode(slow.val);\\n        mid.next=null;\\n        node.left=sortedListToBST(head);\\n        node.right=sortedListToBST(slow.next);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val);\\n        ListNode mid=null;\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null)\\n        {\\n            mid=slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode node=new TreeNode(slow.val);\\n        mid.next=null;\\n        node.left=sortedListToBST(head);\\n        node.right=sortedListToBST(slow.next);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370795,
                "title": "solve-3-questions-with-this-approach-easy-java-fast",
                "content": "```\\n// Que 1382  --> 108--> 109 are same logic based \\nclass Solution {\\n    List<Integer> ls=new ArrayList<>();\\n    public TreeNode sortedListToBST(ListNode head) {\\n        \\n        \\n        while(head!=null){\\n            ls.add(head.val);\\n            head=head.next;\\n        }\\n        int start=0;\\n        int end=ls.size()-1;\\n        return createBBST(start,end);\\n        \\n    }\\n    \\n      public TreeNode createBBST(int start,int end){\\n        if(start>end){\\n            return null;\\n        }\\n        int mid=start+(end-start)/2;\\n        TreeNode root=new TreeNode(ls.get(mid));\\n        root.left=createBBST(start,mid-1);\\n        root.right=createBBST(mid+1,end);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Que 1382  --> 108--> 109 are same logic based \\nclass Solution {\\n    List<Integer> ls=new ArrayList<>();\\n    public TreeNode sortedListToBST(ListNode head) {\\n        \\n        \\n        while(head!=null){\\n            ls.add(head.val);\\n            head=head.next;\\n        }\\n        int start=0;\\n        int end=ls.size()-1;\\n        return createBBST(start,end);\\n        \\n    }\\n    \\n      public TreeNode createBBST(int start,int end){\\n        if(start>end){\\n            return null;\\n        }\\n        int mid=start+(end-start)/2;\\n        TreeNode root=new TreeNode(ls.get(mid));\\n        root.left=createBBST(start,mid-1);\\n        root.right=createBBST(mid+1,end);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287287,
                "title": "my-short-and-concise-java-solution-0ms-and-100-accuracy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private TreeNode f(ListNode head,ListNode tail){\\n        if(head==tail ) return null;\\n         ListNode slow = head;\\n        ListNode fast =head;\\n       \\n         while(fast!=null && fast.next!=null&& fast != tail&& fast.next!=tail){\\n            slow = slow.next;\\n           \\n            fast = fast.next.next;\\n           \\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left =f(head,slow);\\n        root.right = f(slow.next,tail);\\n\\n        return root;\\n    }\\n    public TreeNode sortedListToBST(ListNode head) {\\n       \\n        return f(head,null);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private TreeNode f(ListNode head,ListNode tail){\\n        if(head==tail ) return null;\\n         ListNode slow = head;\\n        ListNode fast =head;\\n       \\n         while(fast!=null && fast.next!=null&& fast != tail&& fast.next!=tail){\\n            slow = slow.next;\\n           \\n            fast = fast.next.next;\\n           \\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left =f(head,slow);\\n        root.right = f(slow.next,tail);\\n\\n        return root;\\n    }\\n    public TreeNode sortedListToBST(ListNode head) {\\n       \\n        return f(head,null);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286859,
                "title": "recursive-approach-fast-n-slow-pointer-for-mid-easy-approach",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate mid and consider it as root,then using recursion traverse to the right and left of the list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* middle(ListNode* head,ListNode* node){\\n        if(!head|| head==node )\\n        return NULL;\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast!=node && fast->next!=node){\\n             \\n              slow=slow->next;\\n              fast=fast->next->next;\\n        }\\n        return slow;\\n\\n    }\\n    \\n  \\n    TreeNode* solve(ListNode* head,ListNode* node){\\n        if(!head|| head==node )\\n        return NULL;\\n       ListNode* mid=middle(head,node);\\n       TreeNode* root=new TreeNode(mid->val);\\n        root->left=solve(head,mid);\\n        root->right=solve(mid->next,node);\\n        return root;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(head==NULL)\\n        return NULL;\\n        return solve(head,NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* middle(ListNode* head,ListNode* node){\\n        if(!head|| head==node )\\n        return NULL;\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast!=node && fast->next!=node){\\n             \\n              slow=slow->next;\\n              fast=fast->next->next;\\n        }\\n        return slow;\\n\\n    }\\n    \\n  \\n    TreeNode* solve(ListNode* head,ListNode* node){\\n        if(!head|| head==node )\\n        return NULL;\\n       ListNode* mid=middle(head,node);\\n       TreeNode* root=new TreeNode(mid->val);\\n        root->left=solve(head,mid);\\n        root->right=solve(mid->next,node);\\n        return root;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(head==NULL)\\n        return NULL;\\n        return solve(head,NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285640,
                "title": "ultra-simple-dart-solution-o-1-space-how",
                "content": "# Intuition\\nGet the len and the split the list in the middle\\n\\n# Approach\\nThe helper function is needed, because I don\\'t want to modify the start list\\n\\n# Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n  TreeNode? _sortedListToBSTHelper(ListNode? head, int len) {\\n      // recursion exit\\n      if (len == 0) {\\n          return null;\\n      }\\n\\n      // go to middle\\n      var middle = head!;\\n      for (int i = 0; i < len ~/ 2; i++) {\\n          middle = middle.next!;\\n      }\\n\\n      var leftSubtree = _sortedListToBSTHelper(head, len ~/ 2);\\n      var rightSubtree = _sortedListToBSTHelper(middle.next, len ~/ 2 - 1 + len % 2);\\n      return new TreeNode(middle.val, leftSubtree, rightSubtree);\\n  }\\n\\n  TreeNode? sortedListToBST(ListNode? head) {\\n      var current = head;\\n\\n      // count len\\n      int len = 0;\\n      while (current != null) {\\n          len++;\\n          current = current.next;\\n      }\\n\\n      return _sortedListToBSTHelper(head, len);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nclass Solution {\\n  TreeNode? _sortedListToBSTHelper(ListNode? head, int len) {\\n      // recursion exit\\n      if (len == 0) {\\n          return null;\\n      }\\n\\n      // go to middle\\n      var middle = head!;\\n      for (int i = 0; i < len ~/ 2; i++) {\\n          middle = middle.next!;\\n      }\\n\\n      var leftSubtree = _sortedListToBSTHelper(head, len ~/ 2);\\n      var rightSubtree = _sortedListToBSTHelper(middle.next, len ~/ 2 - 1 + len % 2);\\n      return new TreeNode(middle.val, leftSubtree, rightSubtree);\\n  }\\n\\n  TreeNode? sortedListToBST(ListNode? head) {\\n      var current = head;\\n\\n      // count len\\n      int len = 0;\\n      while (current != null) {\\n          len++;\\n          current = current.next;\\n      }\\n\\n      return _sortedListToBSTHelper(head, len);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285060,
                "title": "beats-100-0ms-fast-slow-pointer-recursion-java-detailed-explanation",
                "content": "# Intuition\\nThe problem requires us to convert a singly linked list to a height-balanced binary search tree. A binary search tree (BST) is a binary tree in which each node has at most two children, and the left subtree of a node contains only nodes with values less than the node\\'s value, and the right subtree contains only nodes with values greater than the node\\'s value. A height-balanced binary search tree is a binary search tree in which the difference in height between the left and right subtrees of any node is at most 1.\\n\\nThe problem seems daunting at first, but it can be solved by using a recursive approach. The key insight is to find the middle element of the linked list and use it as the root of the BST. Since the linked list is sorted in ascending order, the middle element will be the median element, and all the elements to the left of it will be smaller, and all the elements to the right of it will be larger.\\n\\nTo find the middle element of the linked list, we can use the two-pointer approach. We initialize two pointers, slow and fast, to the head of the list. The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. When the fast pointer reaches the end of the list, the slow pointer points to the middle element.\\n\\nOnce we have the middle element, we create a new node with its value and make it the root of the BST. We then recursively build the left subtree and right subtree of the root node. The left subtree will be built using the elements to the left of the middle element, and the right subtree will be built using the elements to the right of the middle element.\\n\\nThe recursive function should return the root node of the BST. The base cases for the recursion are when the linked list is empty or has only one element. If the linked list is empty, we return null, and if it has only one element, we create a new node with its value and return it.\\n\\nOverall, the problem requires a good understanding of linked lists and binary search trees. The recursive approach can be a bit tricky to implement, but once we understand the intuition behind it, the implementation becomes straightforward.\\n# Approach\\nFirst, we need to check the base cases. If the head is null, return null. If the head has only one element, create a new TreeNode with the value of the head and return it.\\n\\nIf the list has more than one element, we can find the middle element of the list using the two-pointer approach. We initialize two pointers, slow and fast, to the head of the list. The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. When the fast pointer reaches the end of the list, the slow pointer points to the middle element.\\n\\nNow, we create a new TreeNode with the value of the middle element. We set the left child of the new TreeNode to the result of recursively calling the function on the left half of the list (from the head to the element before the middle element). We set the right child of the new TreeNode to the result of recursively calling the function on the right half of the list (from the element after the middle element to the end of the list).\\n\\nFinally, we return the new TreeNode.\\n\\n# Complexity\\n- Time complexity:  $$O(N)$$\\nThe algorithm visits every node in the linked list once to find the middle element, and every node in the BST once to insert it. Therefore, the time complexity of the algorithm is O(n), where n is the number of nodes in the linked list.\\n\\n- Space complexity: $$O(N)$$\\nThe algorithm uses O(log n) space on the call stack due to the recursive calls. The maximum depth of the call stack is log n since the height of the BST is balanced. In addition, the algorithm uses O(n) space to store the BST, where n is the number of nodes in the linked list, since each node in the linked list becomes a node in the BST. Therefore, the overall space complexity of the algorithm is O(n + log n), which simplifies to O(n) since O(n) is greater than O(log n).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/28e4e843-4e64-4b0f-88f2-2c9b6987c802_1678555457.6311016.png)\\n\\n---\\n\\n# Connect\\nLinkedIn : www.linkedin.com/in/akashjana\\n\\n---\\n#### Please consider upvoting if you find this helpful. Thank You :)\\n![image.png](https://assets.leetcode.com/users/images/f36a288e-bdb7-4264-b2d5-8d7275e29330_1678259367.2213438.png)",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284875,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284844,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOur task is to convert the sorted linked list into binary search tree.\\nTo meet our requirement we have to first find the middle of the linked list which is root of our subtree.\\nThen we create a subtree for first half as for the second half as well. \\nIf any place we find left == right that means we are already done with this node then simply return the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Find the middle node of the current linked list then make it root of the subtree (Note:- https://leetcode.com/problems/middle-of-the-linked-list/submissions/863862488/ *Find middle node of linked list*).\\n* After that do recursive call to build\\n    * left subtree\\n    * right subtree\\n* Return root of the subtree\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n# Code\\n```C++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructBST(ListNode *leftSubtree, ListNode *rightSubtree) {\\n        if (leftSubtree == rightSubtree)\\n            return nullptr;\\n        ListNode *slow = leftSubtree, *fast = leftSubtree;\\n        while (fast != rightSubtree && fast -> next != rightSubtree) {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        TreeNode *root = new TreeNode(slow -> val);\\n        root -> left = constructBST(leftSubtree, slow);\\n        root -> right = constructBST(slow -> next, rightSubtree);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (head == nullptr)\\n            return nullptr;\\n        if (head -> next == nullptr) {\\n            TreeNode *root = new TreeNode(head -> val);\\n            return root;\\n        }\\n        return constructBST(head, nullptr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructBST(ListNode *leftSubtree, ListNode *rightSubtree) {\\n        if (leftSubtree == rightSubtree)\\n            return nullptr;\\n        ListNode *slow = leftSubtree, *fast = leftSubtree;\\n        while (fast != rightSubtree && fast -> next != rightSubtree) {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        TreeNode *root = new TreeNode(slow -> val);\\n        root -> left = constructBST(leftSubtree, slow);\\n        root -> right = constructBST(slow -> next, rightSubtree);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (head == nullptr)\\n            return nullptr;\\n        if (head -> next == nullptr) {\\n            TreeNode *root = new TreeNode(head -> val);\\n            return root;\\n        }\\n        return constructBST(head, nullptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284699,
                "title": "python-3-one-line-bonus-day-stout-warren-dsw",
                "content": "One line (list expansion):\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        return (f:=lambda i,j:None if i>j else TreeNode(v[(m:=(i+j)//2)],f(i,m-1),f(m+1,j)))(0,len(v:=(g:=lambda x:x and[x.val]+g(x.next)or[])(head))-1)\\n```\\nDSW (taken from wiki verbatim): https://en.wikipedia.org/wiki/Day%E2%80%93Stout%E2%80%93Warren_algorithm\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def list_to_vine(head):\\n            size = 0\\n            curr = root = TreeNode()\\n            while head:\\n                curr.right = TreeNode(head.val)\\n                curr = curr.right\\n                head = head.next\\n                size += 1\\n            return root, size\\n\\n        def vine_to_tree(root, size):\\n            leaves = size + 1 - int(2**int(log2(size+1)))\\n            compress(root, leaves)\\n            size -= leaves\\n            while size > 1:\\n                size //= 2\\n                compress(root, size)\\n\\n        def compress(root, count):\\n            scanner = root\\n            for _ in range(count):\\n                child = scanner.right\\n                scanner.right = child.right\\n                scanner = scanner.right\\n                child.right = scanner.left\\n                scanner.left = child\\n\\n        root, size = list_to_vine(head)\\n        vine_to_tree(root, size)\\n        return root.right\\n```\\nThe latter is O(1) memory considering we still need to allocate a tree.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        return (f:=lambda i,j:None if i>j else TreeNode(v[(m:=(i+j)//2)],f(i,m-1),f(m+1,j)))(0,len(v:=(g:=lambda x:x and[x.val]+g(x.next)or[])(head))-1)\\n```\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def list_to_vine(head):\\n            size = 0\\n            curr = root = TreeNode()\\n            while head:\\n                curr.right = TreeNode(head.val)\\n                curr = curr.right\\n                head = head.next\\n                size += 1\\n            return root, size\\n\\n        def vine_to_tree(root, size):\\n            leaves = size + 1 - int(2**int(log2(size+1)))\\n            compress(root, leaves)\\n            size -= leaves\\n            while size > 1:\\n                size //= 2\\n                compress(root, size)\\n\\n        def compress(root, count):\\n            scanner = root\\n            for _ in range(count):\\n                child = scanner.right\\n                scanner.right = child.right\\n                scanner = scanner.right\\n                child.right = scanner.left\\n                scanner.left = child\\n\\n        root, size = list_to_vine(head)\\n        vine_to_tree(root, size)\\n        return root.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284181,
                "title": "solved-using-recursion-java-divide-and-conquer",
                "content": "# Intuition\\nDivide the list in 2 lists and a node in middle and then make binary tree using that node are root and 1st list before that node as left part of tree and 2nd list after that middle node as right part of the tree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null )\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode fst = head;\\n        ListNode snd = head.next.next;\\n        while(snd!=null && snd.next!=null){\\n            fst=fst.next;\\n            snd=snd.next.next;\\n        }\\n        TreeNode node = new TreeNode(fst.next.val);\\n        ListNode rhalf = fst.next.next;\\n        fst.next=null;\\n        node.left = sortedListToBST(head);\\n        node.right = sortedListToBST(rhalf);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null )\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode fst = head;\\n        ListNode snd = head.next.next;\\n        while(snd!=null && snd.next!=null){\\n            fst=fst.next;\\n            snd=snd.next.next;\\n        }\\n        TreeNode node = new TreeNode(fst.next.val);\\n        ListNode rhalf = fst.next.next;\\n        fst.next=null;\\n        node.left = sortedListToBST(head);\\n        node.right = sortedListToBST(rhalf);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283888,
                "title": "java-solution-using-slow-and-fast-pointer",
                "content": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        if(head.next==null){\\n            return new TreeNode(head.val);\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode slowPrevious = null;\\n        \\n        while(fast!=null && fast.next!=null){\\n            slowPrevious = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        slowPrevious.next = null;\\n        \\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        \\n        return root;\\n    }\\n}\\n```\\n\\n\\uD83D\\uDC46 vote if you like it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        if(head.next==null){\\n            return new TreeNode(head.val);\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode slowPrevious = null;\\n        \\n        while(fast!=null && fast.next!=null){\\n            slowPrevious = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        slowPrevious.next = null;\\n        \\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283095,
                "title": "best-java-solution-for-easy-understand-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse recursion method approach here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nStep 1] Create ArrayList.\\nStep 2] Count of the element in the linked list.\\nStep 3] Create method with start and end index with ArrayList.\\nStep 4] if (start > end) return null;\\nStep 5] Get mid by mid formula.\\nStep 6] Add into treeNode as root.\\nStep 7] Do recursion for root.left for (0 to mid-1).\\nStep 8] Do recursion for root.right for (mid+1 to end).\\nStep 9] return root to created method.\\nStep 10] return recursive method.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\n        ArrayList<Integer> list = new ArrayList<>();\\n\\n        while(head != null)\\n        {\\n            list.add(head.val); \\n            head = head.next;\\n        }\\n\\n        return BST(0,list,list.size()-1);\\n    }\\n\\n    public TreeNode BST(int start, ArrayList<Integer> list, int end)\\n    {\\n        if(start > end)\\n        {\\n            return null;\\n        }\\n\\n        int mid = (start + end + 1)/2;\\n\\n        TreeNode root = new TreeNode(list.get(mid));\\n\\n        root.left = BST(start, list , mid-1);\\n        \\n        root.right = BST(mid+1, list , end);\\n\\n        return root;\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\n        ArrayList<Integer> list = new ArrayList<>();\\n\\n        while(head != null)\\n        {\\n            list.add(head.val); \\n            head = head.next;\\n        }\\n\\n        return BST(0,list,list.size()-1);\\n    }\\n\\n    public TreeNode BST(int start, ArrayList<Integer> list, int end)\\n    {\\n        if(start > end)\\n        {\\n            return null;\\n        }\\n\\n        int mid = (start + end + 1)/2;\\n\\n        TreeNode root = new TreeNode(list.get(mid));\\n\\n        root.left = BST(start, list , mid-1);\\n        \\n        root.right = BST(mid+1, list , end);\\n\\n        return root;\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283019,
                "title": "share-my-java-solution-easy-and-beginner-friend-bina",
                "content": "# Intitution\\nDivide linked into two parts start to mid and mid to end.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. find mid of linkedList\\n2. mid point is root node of tree.\\n3. divide problem into sub problem like head to mid of linked list is left side of tree and mid + 1 to tail of linkedlist is right side of tree.\\n4. find mid point in left side and right side.\\n5. Repeat step 2, 3 and 4. till head and tail both are equal.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        return toBst(head, null);\\n    }\\n\\n    private TreeNode toBst(ListNode head, ListNode tail) {\\n        if (head == tail) {\\n            return null;\\n        }\\n\\n        ListNode slow = head, fast = head;\\n        while (fast != tail && fast.next != tail) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left = toBst(head, slow);\\n        root.right = toBst(slow.next, tail);\\n        return root;\\n    }\\n}\\n```\\n\\n# Deep Explanation In Hindi\\nhttps://youtu.be/kHyfyzYC7vA",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        return toBst(head, null);\\n    }\\n\\n    private TreeNode toBst(ListNode head, ListNode tail) {\\n        if (head == tail) {\\n            return null;\\n        }\\n\\n        ListNode slow = head, fast = head;\\n        while (fast != tail && fast.next != tail) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left = toBst(head, slow);\\n        root.right = toBst(slow.next, tail);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282944,
                "title": "plz-don-t-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n       \\n\\t    \\t\\n\\t    \\tif(head == null)\\n\\t    \\t\\treturn null;\\n            if(head.next==null) {\\n\\t\\t\\tTreeNode node = new TreeNode(head.val);\\n\\t\\t\\treturn node;\\n\\t\\t}\\n\\t    \\t\\n\\t    \\tListNode mid = findMid(head);\\n\\t    \\tTreeNode node = new TreeNode(mid.val);\\n\\t    \\tnode.left = sortedListToBST(head);\\n\\t    \\tnode.right = sortedListToBST(mid.next);\\n\\t    \\t\\n\\t        return node;\\n\\t     \\n    }\\n\\n      public ListNode findMid(ListNode start) {\\n\\t    \\t\\n\\t    \\tListNode fast = start;\\n\\t    \\tListNode prev = start;\\n\\t    \\t\\n\\t    \\twhile(fast!=null && fast.next!=null) {\\n\\t    \\t\\tprev = start;\\n\\t    \\t\\tstart = start.next;\\n\\t    \\t\\tfast=fast.next.next;\\n\\t    \\t}\\n\\t    \\tprev.next = null;\\n\\t    \\treturn start;\\n\\t    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n       \\n\\t    \\t\\n\\t    \\tif(head == null)\\n\\t    \\t\\treturn null;\\n            if(head.next==null) {\\n\\t\\t\\tTreeNode node = new TreeNode(head.val);\\n\\t\\t\\treturn node;\\n\\t\\t}\\n\\t    \\t\\n\\t    \\tListNode mid = findMid(head);\\n\\t    \\tTreeNode node = new TreeNode(mid.val);\\n\\t    \\tnode.left = sortedListToBST(head);\\n\\t    \\tnode.right = sortedListToBST(mid.next);\\n\\t    \\t\\n\\t        return node;\\n\\t     \\n    }\\n\\n      public ListNode findMid(ListNode start) {\\n\\t    \\t\\n\\t    \\tListNode fast = start;\\n\\t    \\tListNode prev = start;\\n\\t    \\t\\n\\t    \\twhile(fast!=null && fast.next!=null) {\\n\\t    \\t\\tprev = start;\\n\\t    \\t\\tstart = start.next;\\n\\t    \\t\\tfast=fast.next.next;\\n\\t    \\t}\\n\\t    \\tprev.next = null;\\n\\t    \\treturn start;\\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282805,
                "title": "c-binary-search-clean-code",
                "content": "# Intuition\\nList is sorted so we can take an element as a root then left side element of we can say smaller element should be in the left subtree and greater element should be in the right of the root .Similarly we can proceed for all the element .Just like we do in binary search we find the mid then again we solve for its left and right .\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwe can choose any element as a root .If we will choose middle element as a root then height of the BST will be minimum because left and right subtree will have almost same element whereas if we will not choose the middle element as a root then one subtree have mre number of node then the other leads to larger height.\\n\\nSo here i have used binary search approach.First of all store the element of list in a vector , now we will find the mid of the vector this will be the root for example([0,1,4,9,23]) mid = (0 + 5)/2 i.e 2.\\nso index 2 will be the mid this will be the root ,  [0,1] will be in left subtree and [9,23] will in the right subtree again solve for [0,1] and [9,23] separately\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n) where n is the size of the list \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n) where n is the size of the list \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode *ans = NULL;\\n    void solve(vector<int>&v , int l , int r , TreeNode *root , int side){\\n        if(l > r)return;\\n\\n        int mid = (l+r)/2;\\n        TreeNode *temp = new TreeNode(v[mid]);\\n        if(root == NULL){\\n            ans = temp;//if root is Null it means it is root of the tree\\n            root = temp;\\n        }else{\\n            //side variable i have used to recognize child\\n            //-1 means left child and +1 means right child\\n            if(side == -1){\\n                root->left = temp;\\n            }else{\\n                root->right = temp;\\n            }\\n        }\\n\\n        //solve for left subtree\\n        solve(v , l , mid-1 , temp , -1);\\n\\n        //solve for right subtree\\n        solve(v , mid + 1 , r , temp , 1);\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        //we can use the divide and conquer method \\n        vector<int>v;\\n        ListNode *temp = head;\\n        while(temp){\\n            v.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        //now we got the sorted vector\\n        TreeNode *node = NULL;\\n        int n = v.size();\\n        solve(v , 0 , n-1 , node , 0);\\n        return ans;\\n    }\\n};\\n upvote if it was helpful\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode *ans = NULL;\\n    void solve(vector<int>&v , int l , int r , TreeNode *root , int side){\\n        if(l > r)return;\\n\\n        int mid = (l+r)/2;\\n        TreeNode *temp = new TreeNode(v[mid]);\\n        if(root == NULL){\\n            ans = temp;//if root is Null it means it is root of the tree\\n            root = temp;\\n        }else{\\n            //side variable i have used to recognize child\\n            //-1 means left child and +1 means right child\\n            if(side == -1){\\n                root->left = temp;\\n            }else{\\n                root->right = temp;\\n            }\\n        }\\n\\n        //solve for left subtree\\n        solve(v , l , mid-1 , temp , -1);\\n\\n        //solve for right subtree\\n        solve(v , mid + 1 , r , temp , 1);\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        //we can use the divide and conquer method \\n        vector<int>v;\\n        ListNode *temp = head;\\n        while(temp){\\n            v.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        //now we got the sorted vector\\n        TreeNode *node = NULL;\\n        int n = v.size();\\n        solve(v , 0 , n-1 , node , 0);\\n        return ans;\\n    }\\n};\\n upvote if it was helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282679,
                "title": "rust-two-pointer-solution",
                "content": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n\\n\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        Self::_sorted_list_to_bst(head.as_ref(), None)\\n    }\\n\\n    fn _sorted_list_to_bst(\\n        head: Option<&Box<ListNode>>,\\n        tail: Option<&Box<ListNode>>,\\n    ) -> Option<Rc<RefCell<TreeNode>>> {\\n        // 1. head is None\\n        // 2. head is tail node\\n        if head == tail {\\n            return None;\\n        }\\n        // two pointer\\n        let mut slow = head;\\n        let mut fast = head;\\n\\n        // fast is not None or tail node\\n        while fast != tail {\\n            let fast_next = fast.and_then(|n| n.next.as_ref());\\n            if fast_next == tail {\\n                break;\\n            }\\n            // move one step\\n            slow = slow.and_then(|n| n.next.as_ref());\\n            // move  two step\\n            fast = fast_next.and_then(|n| n.next.as_ref());\\n        }\\n        let mut tree_node = TreeNode::new(slow.unwrap().val);\\n        tree_node.left = Self::_sorted_list_to_bst(head, slow);\\n        tree_node.right = Self::_sorted_list_to_bst(slow.unwrap().next.as_ref(), tail);\\n\\n        Some(Rc::new(RefCell::new(tree_node)))\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n\\n\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        Self::_sorted_list_to_bst(head.as_ref(), None)\\n    }\\n\\n    fn _sorted_list_to_bst(\\n        head: Option<&Box<ListNode>>,\\n        tail: Option<&Box<ListNode>>,\\n    ) -> Option<Rc<RefCell<TreeNode>>> {\\n        // 1. head is None\\n        // 2. head is tail node\\n        if head == tail {\\n            return None;\\n        }\\n        // two pointer\\n        let mut slow = head;\\n        let mut fast = head;\\n\\n        // fast is not None or tail node\\n        while fast != tail {\\n            let fast_next = fast.and_then(|n| n.next.as_ref());\\n            if fast_next == tail {\\n                break;\\n            }\\n            // move one step\\n            slow = slow.and_then(|n| n.next.as_ref());\\n            // move  two step\\n            fast = fast_next.and_then(|n| n.next.as_ref());\\n        }\\n        let mut tree_node = TreeNode::new(slow.unwrap().val);\\n        tree_node.left = Self::_sorted_list_to_bst(head, slow);\\n        tree_node.right = Self::_sorted_list_to_bst(slow.unwrap().next.as_ref(), tail);\\n\\n        Some(Rc::new(RefCell::new(tree_node)))\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282633,
                "title": "solution-with-explanation-golang-recursive-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo to be sorted array with height balanced sorted tree, we need to take middle number from already sorted list of numbers and put it to the base of the tree; Numbers of the left from middle would be on the left of the base and The numbers on the right from middle should be on the right of the base. \\nExample: -5,-2,0,1,3,5,7,9,10\\n```\\n                3   \\n        0       |           9    \\n    -2  |    1  |       7   |    10\\n-5      |       |   5       |\\n```\\nso the heights are equal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is to take the numbers from linked list and store them in a slice. Then construct height balanced binary tree from that slice of numbers(int). I assumed that given linked list is already sorted and there is no need to sort slice after getting numbers. If it is not sorted, just use standart library to sort. Ofc there is a way to construct height balanced binary tree from not sorted list of numbers using rotations.\\nNow we have our list of numbers, wecan recursively add numbers to Tree.\\n\\n```\\nfunc sortedArrayToBST(nums []int) *TreeNode\\n```\\n1. Construct Binary Search Tree Node - `bnode`\\n2. `if len(nums)` equal to zero then - we reached the end of Tree return nil\\n3. `if len(nums) == 1` then we reached end of Tree then just return that number\\n4. `If len(nums) > 1` then add value in the middle of nums to bnode\\n5. Call this function with numbers to the left of the middle `nums[:mid]` and assign it `bnode.Left`\\n6. Call this function with numbers to the right of the middle `nums[mid:]` and assign it `bnode.Right`\\n7. Return `bnode`\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n- Space complexity:` O(n)`\\n\\n\\n\\n# Code\\n```Golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc sortedArrayToBST(nums []int) *TreeNode {\\n\\tbnode := &TreeNode{}\\n\\tif len(nums) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\tif len(nums) == 1 {\\n\\t\\tbnode.Val = nums[0]\\n\\t\\treturn bnode\\n\\t}\\n\\tmid := len(nums) / 2\\n\\tbnode.Val = nums[mid]\\n\\tbnode.Left = sortedArrayToBST(nums[:mid])\\n\\tbnode.Right = sortedArrayToBST(nums[mid+1:])\\n\\treturn bnode\\n\\n}\\n\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n\\tnumbers := []int{}\\n\\n\\tfor head != nil {\\n\\t\\tnumbers = append(numbers, head.Val)\\n\\t\\thead = head.Next\\n\\t}\\n\\treturn sortedArrayToBST(numbers)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n                3   \\n        0       |           9    \\n    -2  |    1  |       7   |    10\\n-5      |       |   5       |\\n```\n```\\nfunc sortedArrayToBST(nums []int) *TreeNode\\n```\n```Golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc sortedArrayToBST(nums []int) *TreeNode {\\n\\tbnode := &TreeNode{}\\n\\tif len(nums) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\tif len(nums) == 1 {\\n\\t\\tbnode.Val = nums[0]\\n\\t\\treturn bnode\\n\\t}\\n\\tmid := len(nums) / 2\\n\\tbnode.Val = nums[mid]\\n\\tbnode.Left = sortedArrayToBST(nums[:mid])\\n\\tbnode.Right = sortedArrayToBST(nums[mid+1:])\\n\\treturn bnode\\n\\n}\\n\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n\\tnumbers := []int{}\\n\\n\\tfor head != nil {\\n\\t\\tnumbers = append(numbers, head.Val)\\n\\t\\thead = head.Next\\n\\t}\\n\\treturn sortedArrayToBST(numbers)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282616,
                "title": "explained-with-pic-begineer-freindly-o-log-n-2-ways",
                "content": "# IF U LIKE EXPLAINATION ==> PLZ UPVOTE\\n![bst1.jpeg](https://assets.leetcode.com/users/images/366eaeca-4ee9-46fe-ac4d-b78dde84e422_1678513492.1197546.jpeg)\\n\\n\\nA. Solution 1: Convert linked list to array then do PreOrder Traversal\\n\\n1. Convert linked list to PRIMATIVE INT array\\n2. Choose A[mid] as a root\\n3. Solve sub problem (left, mid - 1), make it as left node\\n4. Solve sub problem (mid + 1, right), make it as right node\\n5. USING PRIMATIVES INT ARRAY RANDOM ACCESS IS CONSTANT O(1);\\n\\n![bst2.jpeg](https://assets.leetcode.com/users/images/4067be1d-3f4e-4009-8869-83e10710e2f9_1678513499.681521.jpeg)\\n\\nB. Solution : InOrder Traversal\\n\\n1. It\\'s a good chance to use In Order Traveral here, where we traverse Left - Root - Right.\\n2. Firstly, we calculate of number of elements in the linked list, let name it n.\\n3. We keep global head, in the beginning root points to the first element in the BST.\\n4. Let dfs(left, right) return the root of the height balanced BST when building in elements from left to right of the linked list.\\nOur answer is the root which is returned from dfs(0, n-1).\\n5. In dfs(left, right) function:\\nmid = (left + (right-left) / 2)\\n6. Firstly, we build BST left subtree, by leftNode = dfs(left, mid-1), after finish building left subtree, now root will point to the mid element.\\n7. So we take the root value from head.val and move head to next, by root = TreeNode(root.val); root = root.val\\nFinally, we build the right node of the root, by rightNode = dfs(mid+1, right).\\n\\n# Code\\n```SOLUTION_A []\\nprivate int[] A;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int len=0;\\n        if(head==null) return null;\\n        ListNode tem=head;\\n        while(tem!=null){\\n            len++;\\n            tem=tem.next;\\n        }\\n        this.A = new int[len];\\n        int i=0;\\n        ListNode root=head;\\n        while(root!=null){\\n            A[i++]=root.val;\\n            root=root.next;\\n        }\\n        return bst(0,len-1);\\n    }\\nprivate TreeNode bst(int left,int right){\\n        if(left>right) return null;\\n        int mid = left+(right-left)/2;\\n        TreeNode ans = new TreeNode(A[mid]);\\n        ans.left=bst(left,mid-1);\\n        ans.right=bst(mid+1,right);\\n        return ans;\\n    }\\n```\\n```SOLUTION_B []\\nprivate ListNode root;\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        this.root=head;\\n        int len=0;\\n        while(head!=null){\\n            len++;\\n            head=head.next;\\n        }\\n        return dfs(0,len-1);\\n    }\\nprivate TreeNode dfs(int left,int right){\\n        if(left>right) return null;\\n        int mid = left+(right-left)/2;\\n        TreeNode leftNode =dfs(left,mid-1);\\n        TreeNode ans = new TreeNode(root.val);\\n        root=root.next;\\n        ans.left=leftNode;\\n        ans.right=dfs(mid+1,right);\\n        return ans;\\n    }\\n```\\n\\n# Complexity\\n- Time complexity: s1=s2==O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) FOR INT ARRAY, s2=(logN) for rec call stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![MEME.png](https://assets.leetcode.com/users/images/457ac5b7-bb2f-4d6b-bdc6-6e415dd82708_1678511465.7266335.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Tree"
                ],
                "code": "```SOLUTION_A []\\nprivate int[] A;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int len=0;\\n        if(head==null) return null;\\n        ListNode tem=head;\\n        while(tem!=null){\\n            len++;\\n            tem=tem.next;\\n        }\\n        this.A = new int[len];\\n        int i=0;\\n        ListNode root=head;\\n        while(root!=null){\\n            A[i++]=root.val;\\n            root=root.next;\\n        }\\n        return bst(0,len-1);\\n    }\\nprivate TreeNode bst(int left,int right){\\n        if(left>right) return null;\\n        int mid = left+(right-left)/2;\\n        TreeNode ans = new TreeNode(A[mid]);\\n        ans.left=bst(left,mid-1);\\n        ans.right=bst(mid+1,right);\\n        return ans;\\n    }\\n```\n```SOLUTION_B []\\nprivate ListNode root;\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        this.root=head;\\n        int len=0;\\n        while(head!=null){\\n            len++;\\n            head=head.next;\\n        }\\n        return dfs(0,len-1);\\n    }\\nprivate TreeNode dfs(int left,int right){\\n        if(left>right) return null;\\n        int mid = left+(right-left)/2;\\n        TreeNode leftNode =dfs(left,mid-1);\\n        TreeNode ans = new TreeNode(root.val);\\n        root=root.next;\\n        ans.left=leftNode;\\n        ans.right=dfs(mid+1,right);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282471,
                "title": "python-short-and-clean-beats-99-5-runtime-functional-programming",
                "content": "# Approach\\n1. Find the length `n` of the `LinkedList`.\\n\\n2. A balanced BST of `n` nodes would have, say `[nl, 1, nr]` nodes for `[left_BST, root, right_BST]` respecitively.\\n\\n3. `1` out of `n` is used for `root`.\\n    The remaining `n - 1` nodes are divided into:\\n    `nl = (n - 1) // 2`,\\n    `nr = (n - 1) - nl`\\n\\n4. Recursively construct the `BST` by:\\n    Consuming first `nl` nodes of the `LinkedList` to construct `left_BST`.\\n    Consuming `1` node for `root`.\\n    Consuming remaining `nr` nodes of the `LinkedList` to construct `right_BST`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(log(n))$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\\n        def iter_LL(ll: ListNode | None) -> Iterator[ListNode]:\\n            while ll: yield ll; ll = ll.next\\n        \\n        def len_LL(ll: ListNode | None) -> int:\\n            return sum(1 for _ in iter_LL(ll))\\n        \\n        def sorted_iter_to_BST(xs: Iterator, n: int) -> TreeNode | None:\\n            if n == 0: return None\\n\\n            nl = (n - 1) // 2\\n            nr = (n - 1) - nl\\n\\n            l_bst = sorted_iter_to_BST(xs, nl)\\n            val = next(xs)\\n            r_bst = sorted_iter_to_BST(xs, nr)\\n\\n            return TreeNode(val, l_bst, r_bst)\\n        \\n        return sorted_iter_to_BST((x.val for x in iter_LL(head)), len_LL(head))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Divide and Conquer",
                    "Binary Search Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\\n        def iter_LL(ll: ListNode | None) -> Iterator[ListNode]:\\n            while ll: yield ll; ll = ll.next\\n        \\n        def len_LL(ll: ListNode | None) -> int:\\n            return sum(1 for _ in iter_LL(ll))\\n        \\n        def sorted_iter_to_BST(xs: Iterator, n: int) -> TreeNode | None:\\n            if n == 0: return None\\n\\n            nl = (n - 1) // 2\\n            nr = (n - 1) - nl\\n\\n            l_bst = sorted_iter_to_BST(xs, nl)\\n            val = next(xs)\\n            r_bst = sorted_iter_to_BST(xs, nr)\\n\\n            return TreeNode(val, l_bst, r_bst)\\n        \\n        return sorted_iter_to_BST((x.val for x in iter_LL(head)), len_LL(head))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282466,
                "title": "o-nlogn-solution",
                "content": "**1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.**\\n\\n**2.Create a new node with the value of the middle element, and make it the root of the binary search tree.**\\n\\n**3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.**\\n\\n**4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.**\\n\\n**5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.**\\n\\n**6.Return the root of the binary search tree.**\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        // find the middle element of the linked list\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = null;\\n        while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        // create a new node with the value of the middle element\\n        TreeNode root = new TreeNode(slow.val);\\n        // recursively convert the left half of the linked list to the left subtree of the root\\n        if (prev != null) {\\n            prev.next = null;\\n            root.left = sortedListToBST(head);\\n        }\\n        // recursively convert the right half of the linked list to the right subtree of the root\\n        root.right = sortedListToBST(slow.next);\\n        return root;  \\n    }\\n}\\n```\\n# UPVOTING IS MUCH APPRECIATED",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        // find the middle element of the linked list\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = null;\\n        while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        // create a new node with the value of the middle element\\n        TreeNode root = new TreeNode(slow.val);\\n        // recursively convert the left half of the linked list to the left subtree of the root\\n        if (prev != null) {\\n            prev.next = null;\\n            root.left = sortedListToBST(head);\\n        }\\n        // recursively convert the right half of the linked list to the right subtree of the root\\n        root.right = sortedListToBST(slow.next);\\n        return root;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282438,
                "title": "recursive-approach-py",
                "content": "# Code\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if head is None:return head\\n        if head.next is None:return TreeNode(head.val)\\n        slow,fast=head,head.next.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        data,right,slow.next=slow.next.val,slow.next.next,None\\n        return TreeNode(val=data,left=self.sortedListToBST(head), \\n\\t\\t    right=self.sortedListToBST(right))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if head is None:return head\\n        if head.next is None:return TreeNode(head.val)\\n        slow,fast=head,head.next.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        data,right,slow.next=slow.next.val,slow.next.next,None\\n        return TreeNode(val=data,left=self.sortedListToBST(head), \\n\\t\\t    right=self.sortedListToBST(right))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282339,
                "title": "solution-and-explanation-to-the-problem-convert-sorted-list-to-bst-java-code",
                "content": "# Intuition\\nIt is easy to oserve that there must be nearly equal number of elements in the left and right subtree to make it height balanced so in a list of sorted elements the middle element can act as the most appropritate root value and the elements to the left will form the left subtree and the elements to the right will form the right subtree.\\n\\n# Approach\\nThe entire problem can be broken into 2 parts:-\\n1) Storing the list in such a way that its elements can be accessed in O(1) time.\\n2) Use the above created data structure to find the root node at each level and the elements which should be in the left and right subtree respectively.\\n3) Create the node which we are currently at and recussively call the function for the left half and the right half until no element is left.\\n\\n# Complexity\\n- Time complexity:\\nAll the nodes are visited once and the left and right subtree is computed accordingly. The time complexity is O(n).\\n\\n- Space complexity:\\n Space Complexity is O(n) since we use an extra array to store the elements of the list.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode sortedListToBST(ListNode head) {\\n        \\n        ArrayList<Integer> l1=new ArrayList<>();\\n        while(head!=null)\\n        {\\n            l1.add(head.val);\\n            head=head.next;\\n        }\\n        return func(l1,0,l1.size()-1);\\n    }\\n    public static TreeNode func(ArrayList<Integer> l1,int lo,int hi)\\n    {\\n        if(lo>hi) return null;\\n\\n        int mid=(lo+hi)/2;\\n        TreeNode t1=new TreeNode(l1.get(mid));\\n        t1.left=func(l1,lo,mid-1);\\n        t1.right=func(l1,mid+1,hi);\\n        return t1;\\n    }\\n}\\n\\n```\\n# PLEASE DO UPVOTE THE SOLUTION !! :)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode sortedListToBST(ListNode head) {\\n        \\n        ArrayList<Integer> l1=new ArrayList<>();\\n        while(head!=null)\\n        {\\n            l1.add(head.val);\\n            head=head.next;\\n        }\\n        return func(l1,0,l1.size()-1);\\n    }\\n    public static TreeNode func(ArrayList<Integer> l1,int lo,int hi)\\n    {\\n        if(lo>hi) return null;\\n\\n        int mid=(lo+hi)/2;\\n        TreeNode t1=new TreeNode(l1.get(mid));\\n        t1.left=func(l1,lo,mid-1);\\n        t1.right=func(l1,mid+1,hi);\\n        return t1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1828890,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1568047,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828583,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828578,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828562,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828726,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1568930,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828659,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1571228,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828892,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828890,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1568047,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828583,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828578,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828562,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828726,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1568930,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828659,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1571228,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828892,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828869,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1828650,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1828617,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1572339,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1571229,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1571230,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 2005692,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1956587,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1933728,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1839218,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1833046,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1831818,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829650,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829447,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829427,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829403,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829400,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829314,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829216,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829092,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829068,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828842,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828802,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828655,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828628,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828623,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828606,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828586,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1826481,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1688043,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Size Subarray Sum",
        "question_content": "<p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return <em>the <strong>minimal length</strong> of a </em><span data-keyword=\"subarray-nonempty\"><em>subarray</em></span><em> whose sum is greater than or equal to</em> <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 7, nums = [2,3,1,2,4,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The subarray [4,3] has the minimal length under the problem constraint.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 4, nums = [1,4,4]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 11, nums = [1,1,1,1,1,1,1,1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution of which the time complexity is <code>O(n log(n))</code>.",
        "solutions": [
            {
                "id": 59078,
                "title": "accepted-clean-java-o-n-solution-two-pointers",
                "content": "    public int minSubArrayLen(int s, int[] a) {\\n      if (a == null || a.length == 0)\\n        return 0;\\n      \\n      int i = 0, j = 0, sum = 0, min = Integer.MAX_VALUE;\\n      \\n      while (j < a.length) {\\n        sum += a[j++];\\n        \\n        while (sum >= s) {\\n          min = Math.min(min, j - i);\\n          sum -= a[i++];\\n        }\\n      }\\n      \\n      return min == Integer.MAX_VALUE ? 0 : min;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "    public int minSubArrayLen(int s, int[] a) {\\n      if (a == null || a.length == 0)\\n        return 0;\\n      \\n      int i = 0, j = 0, sum = 0, min = Integer.MAX_VALUE;\\n      \\n      while (j < a.length) {\\n        sum += a[j++];\\n        \\n        while (sum >= s) {\\n          min = Math.min(min, j - i);\\n          sum -= a[i++];\\n        }\\n      }\\n      \\n      return min == Integer.MAX_VALUE ? 0 : min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 59090,
                "title": "c-o-n-and-o-nlogn",
                "content": "The `O(n)` solution is to use two pointers: `l` and `r`. First we move `r` until we get a `sum  >= s`, then we move `l` to the right until `sum < s`. In this process, store the minimum length between `l` and `r`. Since each element in `nums` will be visited by `l` and `r` for at most once. This algorithm is of `O(n)` time.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        int l = 0, r = 0, n = nums.size(), sum = 0, len = INT_MAX;\\n        while (r < n) {\\n            sum += nums[r++];\\n            while (sum >= s) {\\n                len = min(len, r - l);\\n                sum -= nums[l++];\\n            }\\n        }\\n        return len == INT_MAX ? 0 : len;\\n    }\\n};\\n```\\n\\nThen comes the `O(nlogn)` solution. This less efficient one turns out to be more difficult to come up with.\\n\\nFirst, we maintain an array of accumulated sums of elements in `nums` according to the following two equations.\\n\\n1. `sums[0] = 0`\\n2. `sums[i] = nums[0] + ... + nums[i - 1]` for `i > 0`\\n\\nThen, for each `sums[i] >= s`, we search for the first `sums[j] > sums[i] - s (j < i)` using binary search. In this case, we also have `sums[j - 1] <= sums[i] - s`. If we plug in the definition for `sums`, we have\\n\\n* `nums[0] + ... + nums[j - 1] > nums[0] + ... + nums[j - 1] + nums[j] + ... + nums[i - 1] - s`\\n* `nums[0] + ... + nums[j - 2] <= nums[0] + ... + nums[j - 2] + nums[j - 1] + ... + nums[i - 1] - s`\\n\\nIf we minus the left-hand side from both inequalities, we have\\n\\n* `0 > nums[j] + ... + nums[i - 1] - s`\\n* `0 <= nums[j - 1] + ... + nums[i - 1] - s`\\n\\nSo, we have `nums[j - 1] + ... + nums[i - 1] >= s` but `nums[j] + ... + nums[i - 1] < s`. So `nums[j-1..i-1]` is the shortest subarray with sum not less than `s` **ending at `i - 1`**. After traversing all possible `i`, we will find out the shortest subarray with sum not less than `s`.\\n\\nBy the way, a `0` is added to the head of `sums` to account for cases like `nums = [3], s = 3`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        int n = nums.size(), len = INT_MAX;\\n        vector<int> sums(n + 1, 0);\\n        for (int i = 1; i <= n; i++) {\\n            sums[i] = sums[i - 1] + nums[i - 1];\\n        }\\n        for (int i = n; i >= 0 && sums[i] >= s; i--) {\\n            int j = upper_bound(sums.begin(), sums.end(), sums[i] - s) - sums.begin();\\n            len = min(len, i - j + 1);\\n        }\\n        return len == INT_MAX ? 0 : len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        int l = 0, r = 0, n = nums.size(), sum = 0, len = INT_MAX;\\n        while (r < n) {\\n            sum += nums[r++];\\n            while (sum >= s) {\\n                len = min(len, r - l);\\n                sum -= nums[l++];\\n            }\\n        }\\n        return len == INT_MAX ? 0 : len;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        int n = nums.size(), len = INT_MAX;\\n        vector<int> sums(n + 1, 0);\\n        for (int i = 1; i <= n; i++) {\\n            sums[i] = sums[i - 1] + nums[i - 1];\\n        }\\n        for (int i = n; i >= 0 && sums[i] >= s; i--) {\\n            int j = upper_bound(sums.begin(), sums.end(), sums[i] - s) - sums.begin();\\n            len = min(len, i - j + 1);\\n        }\\n        return len == INT_MAX ? 0 : len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433123,
                "title": "java-c-python-sliding-window",
                "content": "# **Intuition**\\n862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\nActually I did this first, the same prolem but have negatives.\\nI suggest solving this prolem first then take 862 as a follow-up.\\n<br>\\n\\n# **Explanation**\\nThe result is initialized as `res = n + 1`.\\nOne pass, remove the value from sum `s` by doing `s -= A[j]`.\\nIf `s <= 0`, it means the total sum of `A[i] + ... + A[j] >= sum` that we want.\\nThen we update the `res = min(res, j - i + 1)`\\nFinally we return the result `res`\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int minSubArrayLen(int s, int[] A) {\\n        int i = 0, n = A.length, res = n + 1;\\n        for (int j = 0; j < n; ++j) {\\n            s -= A[j];\\n            while (s <= 0) {\\n                res = Math.min(res, j - i + 1);\\n                s += A[i++];\\n            }\\n        }\\n        return res % (n + 1);\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int minSubArrayLen(int s, vector<int>& A) {\\n        int i = 0, n = A.size(), res = n + 1;\\n        for (int j = 0; j < n; ++j) {\\n            s -= A[j];\\n            while (s <= 0) {\\n                res = min(res, j - i + 1);\\n                s += A[i++];\\n            }\\n        }\\n        return res % (n + 1);\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def minSubArrayLen(self, s, A):\\n        i, res = 0, len(A) + 1\\n        for j in xrange(len(A)):\\n            s -= A[j]\\n            while s <= 0:\\n                res = min(res, j - i + 1)\\n                s += A[i]\\n                i += 1\\n        return res % (len(A) + 1)\\n```\\n<br>\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\nSliding window:\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int minSubArrayLen(int s, int[] A) {\\n        int i = 0, n = A.length, res = n + 1;\\n        for (int j = 0; j < n; ++j) {\\n            s -= A[j];\\n            while (s <= 0) {\\n                res = Math.min(res, j - i + 1);\\n                s += A[i++];\\n            }\\n        }\\n        return res % (n + 1);\\n    }\\n```\n```cpp\\n    int minSubArrayLen(int s, vector<int>& A) {\\n        int i = 0, n = A.size(), res = n + 1;\\n        for (int j = 0; j < n; ++j) {\\n            s -= A[j];\\n            while (s <= 0) {\\n                res = min(res, j - i + 1);\\n                s += A[i++];\\n            }\\n        }\\n        return res % (n + 1);\\n    }\\n```\n```py\\n    def minSubArrayLen(self, s, A):\\n        i, res = 0, len(A) + 1\\n        for j in xrange(len(A)):\\n            s -= A[j]\\n            while s <= 0:\\n                res = min(res, j - i + 1)\\n                s += A[i]\\n                i += 1\\n        return res % (len(A) + 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 59103,
                "title": "two-ac-solutions-in-java-with-time-complexity-of-n-and-nlogn-with-explanation",
                "content": "    public class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            return solveNLogN(s, nums);\\n        }\\n        \\n        private int solveN(int s, int[] nums) {\\n            int start = 0, end = 0, sum = 0, minLen = Integer.MAX_VALUE;\\n            while (end < nums.length) {\\n                while (end < nums.length && sum < s) sum += nums[end++];\\n                if (sum < s) break;\\n                while (start < end && sum >= s) sum -= nums[start++];\\n                if (end - start + 1 < minLen) minLen = end - start + 1;\\n            }\\n            return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n        }\\n    \\n        private int solveNLogN(int s, int[] nums) {\\n            int[] sums = new int[nums.length + 1];\\n            for (int i = 1; i < sums.length; i++) sums[i] = sums[i - 1] + nums[i - 1];\\n            int minLen = Integer.MAX_VALUE;\\n            for (int i = 0; i < sums.length; i++) {\\n                int end = binarySearch(i + 1, sums.length - 1, sums[i] + s, sums);\\n                if (end == sums.length) break;\\n                if (end - i < minLen) minLen = end - i;\\n            }\\n            return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n        }\\n        \\n        private int binarySearch(int lo, int hi, int key, int[] sums) {\\n            while (lo <= hi) {\\n               int mid = (lo + hi) / 2;\\n               if (sums[mid] >= key){\\n                   hi = mid - 1;\\n               } else {\\n                   lo = mid + 1;\\n               }\\n            }\\n            return lo;\\n        }\\n    }\\n\\nSince the given array contains only positive integers, the subarray sum can only increase by including more elements. Therefore, you don't have to include more elements once the current subarray already has a sum large enough. This gives the linear time complexity solution by maintaining a minimum window with a two indices.\\n\\nAs to NLogN solution, logN immediately reminds you of binary search. In this case, you cannot sort as the current order actually matters. How does one get an ordered array then? Since all elements are positive, the cumulative sum must be strictly increasing. Then, a subarray sum can expressed as the difference between two cumulative sum. Hence, given a start index for the cumulative sum array, the other end index can be searched using binary search.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            return solveNLogN(s, nums);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 59123,
                "title": "o-n-o-nlogn-solutions-both-o-1-space",
                "content": "O(N) - keep a moving window expand until sum>=s, then shrink util sum<s. Each time after shrinking, update length. (similar to other solutions, just removed unnecessary min value assignment)\\n\\n    public class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            int i = 0, j = 0, sum = 0, min = Integer.MAX_VALUE;\\n            while (j < nums.length) {\\n                while (sum < s && j < nums.length) sum += nums[j++];\\n                if(sum>=s){\\n                    while (sum >= s && i < j) sum -= nums[i++];\\n                    min = Math.min(min, j - i + 1);\\n                }\\n            }\\n            return min == Integer.MAX_VALUE ? 0 : min;\\n        }\\n    }\\n\\n\\n\\n\\nO(NLogN) - search if a window of size k exists that satisfy the condition\\n\\n    public class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            int i = 1, j = nums.length, min = 0;\\n            while (i <= j) {\\n                int mid = (i + j) / 2;\\n                if (windowExist(mid, nums, s)) {\\n                    j = mid - 1;\\n                    min = mid;\\n                } else i = mid + 1;\\n            }\\n            return min;\\n        }\\n    \\n    \\n        private boolean windowExist(int size, int[] nums, int s) {\\n            int sum = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (i >= size) sum -= nums[i - size];\\n                sum += nums[i];\\n                if (sum >= s) return true;\\n            }\\n            return false;\\n        }\\n    }\\n\\n\\nAnother O(NLogN) solution that first calculate cumulative sum and then for each starting point binary search for end position. This uses O(N) space\\n\\n    public class Solution {\\n     public int minSubArrayLen(int s, int[] nums) {\\n            int sum = 0, min = Integer.MAX_VALUE;\\n    \\n            int[] sums = new int[nums.length];\\n            for (int i = 0; i < nums.length; i++)\\n                sums[i] = nums[i] + (i == 0 ? 0 : sums[i - 1]);\\n    \\n            for (int i = 0; i < nums.length; i++) {\\n                int j = findWindowEnd(i, sums, s);\\n                if (j == nums.length) break;\\n                min = Math.min(j - i + 1, min);\\n            }\\n            \\n            return min == Integer.MAX_VALUE ? 0 : min;\\n        }\\n    \\n        private int findWindowEnd(int start, int[] sums, int s) {\\n            int i = start, j = sums.length - 1, offset = start == 0 ? 0 : sums[start - 1];\\n            while (i <= j) {\\n                int m = (i + j) / 2;\\n                int sum = sums[m] - offset;\\n            if (sum >= s) j = m - 1;\\n            else i = m + 1;\\n        }\\n        return i;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            int i = 0, j = 0, sum = 0, min = Integer.MAX_VALUE;\\n            while (j < nums.length) {\\n                while (sum < s && j < nums.length) sum += nums[j++];\\n                if(sum>=s){\\n                    while (sum >= s && i < j) sum -= nums[i++];\\n                    min = Math.min(min, j - i + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 59110,
                "title": "o-n-template-for-minimum-size-subarray-sum-minimum-window-substring-longest-substring-without-repeating-characters",
                "content": "First , I will show you the solution of this problem,\\n\\n    class Solution {\\n    public:\\n        int minSubArrayLen(int s, vector<int>& nums) {\\n            int start=0, end=0;\\n            int minLen=INT_MAX, sum=0;\\n            while(end<nums.size()){\\n                if(sum<s) sum+=nums[end];\\n                end++;\\n                while(sum>=s){\\n                    if(end-start<minLen)\\n                        minLen=end-start;\\n                    sum-=nums[start];\\n                    start++;\\n                }\\n            }\\n            return minLen==INT_MAX ? 0 : minLen;\\n        }\\n    };\\n\\nNext, let me show you the solution to the problem \"Minimum Window Substring\"\\n\\n    class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            vector<int> v(128, 0);\\n            for(auto c:t) v[c]++;\\n            int start=0, end=0, counter=t.size();\\n            int m_start=0, m_len=INT_MAX;\\n            while(end<s.size()){\\n                if(v[s[end]]>0)  counter--;\\n                v[s[end]]--;\\n                end++;\\n                /** loop from start to check whether we can find more short string **/\\n                while(counter==0){\\n                    if(m_len>end-start){\\n                        m_start=start;\\n                        m_len=end-start;\\n                    }\\n                    v[s[start]]++;\\n                    if(v[s[start]]>0) counter++;\\n                    start++;\\n                }\\n            }\\n            return m_len==INT_MAX ? \"\" : s.substr(m_start, m_len);\\n        }\\n    };\\n\\nThe solution for the problem \"Longest Substring Without Repeating Characters\" can also be solved in the \\n\\nsame pattern .\\n\\nHere is the solution for \"Longest Substring Without Repeating Characters\"\\n\\n    class Solution {\\n    public:\\n        int lengthOfLongestSubstring(string s) {\\n            vector<int> v(128, 0);\\n            int start=0, end=0;\\n            int m_len=INT_MIN;\\n            while(end<s.size()){\\n                if(v[s[end]]==0) m_len=max(m_len, end-start+1);\\n                v[s[end]]++;\\n                end++;\\n                while(v[s[end]]>0){\\n                    v[s[start]]--;\\n                    start++;\\n                }\\n            }\\n            return m_len==INT_MIN ? 0 : m_len;\\n        }\\n    };\\n\\nAs you can see, they all follow the same pattern !\\n\\nThis post deserves your up vote!",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minSubArrayLen(int s, vector<int>& nums) {\\n            int start=0, end=0;\\n            int minLen=INT_MAX, sum=0;\\n            while(end<nums.size()){\\n                if(sum<s) sum+=nums[end];\\n                end++;\\n                while(sum>=s){\\n                    if(end-start<minLen)\\n                        minLen=end-start;\\n                    sum-=nums[start];\\n                    start++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 59093,
                "title": "python-o-n-and-o-n-log-n-solution",
                "content": "    class Solution:\\n\\n    def minSubArrayLen(self, s, nums):\\n        total = left = 0\\n        result = len(nums) + 1\\n        for right, n in enumerate(nums):\\n            total += n\\n            while total >= s:\\n                result = min(result, right - left + 1)\\n                total -= nums[left]\\n                left += 1\\n        return result if result <= len(nums) else 0\\n\\n\\nO(n log n)\\n\\n    class Solution:\\n\\n    def minSubArrayLen(self, target, nums):\\n        result = len(nums) + 1\\n        for idx, n in enumerate(nums[1:], 1):\\n            nums[idx] = nums[idx - 1] + n\\n        left = 0\\n        for right, n in enumerate(nums):\\n            if n >= target:\\n                left = self.find_left(left, right, nums, target, n)\\n                result = min(result, right - left + 1)\\n        return result if result <= len(nums) else 0\\n\\n    def find_left(self, left, right, nums, target, n):\\n        while left < right:\\n            mid = (left + right) // 2\\n            if n - nums[mid] >= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left",
                "solutionTags": [],
                "code": "    class Solution:\\n\\n    def minSubArrayLen(self, s, nums):\\n        total = left = 0\\n        result = len(nums) + 1\\n        for right, n in enumerate(nums):\\n            total += n\\n            while total >= s:\\n                result = min(result, right - left + 1)\\n                total -= nums[left]\\n                left += 1\\n        return result if result <= len(nums) else 0\\n\\n\\nO(n log n)\\n\\n    class Solution:\\n\\n    def minSubArrayLen(self, target, nums):\\n        result = len(nums) + 1\\n        for idx, n in enumerate(nums[1:], 1):\\n            nums[idx] = nums[idx - 1] + n\\n        left = 0\\n        for right, n in enumerate(nums):\\n            if n >= target:\\n                left = self.find_left(left, right, nums, target, n)\\n                result = min(result, right - left + 1)\\n        return result if result <= len(nums) else 0\\n\\n    def find_left(self, left, right, nums, target, n):\\n        while left < right:\\n            mid = (left + right) // 2\\n            if n - nums[mid] >= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left",
                "codeTag": "Java"
            },
            {
                "id": 3724641,
                "title": "2-approaches-100-fast-binary-serarch-sliding-window-easy-line-by-line-video-explanation",
                "content": "# Approach\\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtu.be/0tZ-9dIAY_Q\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\nor\\nsearch \\uD83D\\uDC49`Minimum size subarray sum by Let\\'s Code Together` on youtube\\n\\n# Sliding Window Approach\\n\\n1. Initialize two pointers, `i` and `j`, to track the start and end of the current subarray, respectively. Set `i` and `j` to 0 initially.\\n2. Initialize a variable `sum` to keep track of the current sum of elements in the subarray.\\n3. Initialize a variable `mn` to store the minimum length found so far. Set it to the maximum possible integer value (`INT_MAX`).\\n4. Start a while loop that continues until the `j` pointer reaches the end of the array `nums`.\\n5. Inside the loop, add the element at index `j` to the `sum` variable.\\n6. Check if the `sum` is greater than or equal to the target value.\\n7. If the condition is true, enter another while loop. This loop will handle the case where the current subarray sum is equal to or greater than the target.\\n   a. Decrement the `sum` by subtracting the element at index `i`.\\n   b. Update `mn` with the minimum length found so far (`j - i + 1`).\\n   c. Increment the `i` pointer to move the window to the right.\\n   d. Repeat steps a-c until the `sum` is no longer greater than or equal to the target value.\\n8. Increment the `j` pointer to move the window to the right.\\n9. Repeat steps 5-8 until the `j` pointer reaches the end of the array.\\n10. After the loop, check if the value of `mn` is still `INT_MAX`, indicating that no subarray was found. In this case, return 0.\\n11. Otherwise, return the value of `mn`, which represents the minimum length of a subarray whose sum is greater than or equal to the target.\\n\\nThe sliding window technique allows us to efficiently search for the minimum length subarray that satisfies the given condition. By maintaining two pointers and adjusting the window based on the sum of elements, we can avoid unnecessary computations and achieve a time complexity of O(N), where N is the size of the input array `nums`.\\n\\n# Code1 Sliding Window\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int i=0;\\n        int j=0;\\n        int sum=0;\\n        int mn=INT_MAX;\\n        while(j<nums.size()){\\n            sum+=nums[j];\\n            while(sum>=target){\\n                sum-=nums[i];\\n                mn=min(j-i+1,mn);\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(mn==INT_MAX){\\n            return 0;\\n        }\\n        return mn;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$  \\n- Space complexity: O(1)\\n# Code2 Binary Search\\n\\n# Binary Search Approach\\n\\n1. The `windowfind` function checks if there exists a subarray of a given size whose sum is greater than or equal to the target.\\n2. It uses the sliding window technique to iterate through the array and maintain a window of the specified size.\\n3. If the sum of the elements in the window is greater than or equal to the target, it returns `true`.\\n4. Otherwise, it returns `false`.\\n\\nThe `minSubArrayLen` function finds the minimum length of a subarray whose sum is greater than or equal to the target using binary search.\\n1. It initializes a range from 1 to the size of the input array.\\n2. It repeatedly divides the range in half and checks if a subarray of the mid-point length satisfies the condition using the `windowfind` function.\\n3. If a valid subarray is found, it updates the upper bound of the range to mid-1 and stores the mid-point length as the minimum length found so far.\\n4. If a valid subarray is not found, it updates the lower bound of the range to mid+1.\\n5. The search continues until the lower bound is no longer less than or equal to the upper bound.\\n6. Finally, it returns the minimum length of the subarray.\\n\\nThe code efficiently utilizes the sliding window technique and binary search to find the minimum length subarray satisfying the given condition.\\n```\\nclass Solution {\\npublic:\\n      bool windowfind(int size, vector<int>&nums, int target) {\\n        int sum = 0;\\n        int i=0;\\n        int j=0;\\n        int mx=INT_MIN;\\n        int n=nums.size();\\n        while(j<n){\\n            sum+=nums[j];\\n            if(j-i+1==size){\\n              mx=max(sum,mx);\\n              sum-=nums[i];\\n              i++;\\n            }\\n            j++;\\n        }\\n        if(mx>=target)\\n        return true;\\n        return false;\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int low = 1, high = nums.size(), mn = 0;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (windowfind(mid, nums, target)) {\\n                high = mid-1;\\n                mn = mid;\\n            } else low = mid + 1;\\n        }\\n        return mn;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(n logn)$$ \\n- Space complexity: O(1)\\n\\n![upvote-this-you.jpg](https://assets.leetcode.com/users/images/75d2a342-7b1b-4a68-8112-7d4d2353765c_1688631425.0458076.jpeg)\\n\\nPlease Upvote \\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int i=0;\\n        int j=0;\\n        int sum=0;\\n        int mn=INT_MAX;\\n        while(j<nums.size()){\\n            sum+=nums[j];\\n            while(sum>=target){\\n                sum-=nums[i];\\n                mn=min(j-i+1,mn);\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(mn==INT_MAX){\\n            return 0;\\n        }\\n        return mn;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n      bool windowfind(int size, vector<int>&nums, int target) {\\n        int sum = 0;\\n        int i=0;\\n        int j=0;\\n        int mx=INT_MIN;\\n        int n=nums.size();\\n        while(j<n){\\n            sum+=nums[j];\\n            if(j-i+1==size){\\n              mx=max(sum,mx);\\n              sum-=nums[i];\\n              i++;\\n            }\\n            j++;\\n        }\\n        if(mx>=target)\\n        return true;\\n        return false;\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int low = 1, high = nums.size(), mn = 0;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (windowfind(mid, nums, target)) {\\n                high = mid-1;\\n                mn = mid;\\n            } else low = mid + 1;\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241108,
                "title": "java-easy-two-approaches-sliding-window-binary-search",
                "content": "**Approach 1 :- Using Fixed Size Sliding Window + Binary Search (O(NlogN)**\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int low=1;\\n        int high=nums.length+1;\\n        boolean flag=false;\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(fixsw(mid,nums,target)==true){\\n                flag=true;\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        if(!flag)\\n            return 0;\\n        return low;\\n    }\\n    public boolean fixsw(int size,int[] nums,int target){\\n        int i=0;\\n        int j=0;\\n        int sum=0;\\n        int max=Integer.MIN_VALUE;\\n        while(j<nums.length){\\n            sum+=nums[j];\\n            if(j-i+1==size){\\n                max=Math.max(max,sum);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(max>=target){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Approach 2 :- Using variable size sliding window (O(N) Optimized)**\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int i=0;\\n        int j=0;\\n        int min=Integer.MAX_VALUE;\\n        int sum=0;\\n        while(j<nums.length){\\n            sum+=nums[j];\\n            if(sum>=target){\\n                while(sum>=target){\\n                    min=Math.min(min,j-i+1);\\n                    sum-=nums[i];\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(min==Integer.MAX_VALUE)\\n            return 0;\\n        else\\n            return min;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/103d9178-6d7e-4482-a9e6-c49f20fed608_1677608068.0664108.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search Tree",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int low=1;\\n        int high=nums.length+1;\\n        boolean flag=false;\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(fixsw(mid,nums,target)==true){\\n                flag=true;\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        if(!flag)\\n            return 0;\\n        return low;\\n    }\\n    public boolean fixsw(int size,int[] nums,int target){\\n        int i=0;\\n        int j=0;\\n        int sum=0;\\n        int max=Integer.MIN_VALUE;\\n        while(j<nums.length){\\n            sum+=nums[j];\\n            if(j-i+1==size){\\n                max=Math.max(max,sum);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(max>=target){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int i=0;\\n        int j=0;\\n        int min=Integer.MAX_VALUE;\\n        int sum=0;\\n        while(j<nums.length){\\n            sum+=nums[j];\\n            if(sum>=target){\\n                while(sum>=target){\\n                    min=Math.min(min,j-i+1);\\n                    sum-=nums[i];\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(min==Integer.MAX_VALUE)\\n            return 0;\\n        else\\n            return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59247,
                "title": "python-easy-to-understand-solution-with-comments",
                "content": "        \\n    # O(n) time\\n    # we scan from left to right, \"total\" tracks the \\n    # sum of the subarray. If the sum is less than s,\\n    # right moves forward one step, else left moves forward\\n    # one step, left and right form a window.\\n    def minSubArrayLen(self, s, nums):\\n        total = left = right = 0\\n        res = len(nums) + 1\\n        while right < len(nums):\\n            total += nums[right]\\n            while total >= s:\\n                res = min(res, right-left+1)\\n                total -= nums[left]\\n                left += 1\\n            right += 1\\n        return res if res <= len(nums) else 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    # O(n) time\\n    # we scan from left to right, \"total\" tracks the \\n    # sum of the subarray. If the sum is less than s,\\n    # right moves forward one step, else left moves forward\\n    # one step, left and right form a window.\\n    def minSubArrayLen(self, s, nums):\\n        total = left = right = 0\\n        res = len(nums) + 1\\n        while right < len(nums):\\n            total += nums[right]\\n            while total >= s:\\n                res = min(res, right-left+1)\\n                total -= nums[left]\\n                left += 1\\n            right += 1\\n        return res if res <= len(nums) else 0",
                "codeTag": "Python3"
            },
            {
                "id": 59091,
                "title": "c-simple-o-n-solution",
                "content": "    class Solution {\\n    public:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        int firstPos = 0, sum = 0, minLength = INT_MAX;\\n        for(int i = 0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            while(sum >= s) {\\n                minLength = min(minLength, i - firstPos + 1);\\n                sum -= nums[firstPos++];\\n            }\\n        }\\n        \\n        return minLength == INT_MAX? 0 : minLength;\\n      }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        int firstPos = 0, sum = 0, minLength = INT_MAX;\\n        for(int i = 0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            while(sum >= s) {\\n                minLength = min(minLength, i - firstPos + 1);\\n                sum -= nums[firstPos++];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1249381,
                "title": "python-sliding-window-o-n-clean-concise",
                "content": "**Idea**\\n- The idea is that we keep 2 points `l` (initial value = 0) point to the left most of window, `r` point to current index of nums.\\n- We use `windowSum` (initial value = 0) to keep the sum of numbers in the window range.\\n- Iterating `r` in `[0...n-1]`,\\n\\t- `windowSum += nums[r]`.\\n\\t- While `windowSum > target`:\\n\\t\\t- Update answer as minimum length of sliding window length by `ans = min(ans, r-l+1)`.\\n\\t\\t- Slide `l` by one by `windowSum -= nums[l]`, `l += 1`.\\n- This question is same with this problem **[713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/)** try to solve it yourself.\\n```python\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        n = len(nums)\\n        INF = n + 1\\n        windowSum, l, ans = 0, 0, INF\\n        for r in range(n):\\n            windowSum += nums[r]\\n            while windowSum >= target:\\n                ans = min(ans, r - l + 1)\\n                windowSum -= nums[l]\\n                l += 1\\n        return ans if ans != INF else 0\\n```\\nComplexity:\\n - Time: `O(N)`, where `N` is number of elements in array `nums`.\\n - Space: `O(1)`.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        n = len(nums)\\n        INF = n + 1\\n        windowSum, l, ans = 0, 0, INF\\n        for r in range(n):\\n            windowSum += nums[r]\\n            while windowSum >= target:\\n                ans = min(ans, r - l + 1)\\n                windowSum -= nums[l]\\n                l += 1\\n        return ans if ans != INF else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 277445,
                "title": "python-sliding-window-approach-with-comments",
                "content": "**Sliding Window Approach**\\n\\n**Reasoning:** All values are positive, so once a contiguous sum exceeds or equals `s`, we don\\'t need to add to the current subarray. Adding would increase the length of a subarray which already satisfies the problem constraint. \\n\\nWe can keep track of two indices (`left` and `i`) and increment either. We alter `total` if the sum is `<`  or `>=` or equal to `s`.\\n\\n- Initialize `res`, `left`, and `total`\\n- Iterate through `nums`, for each iteration, increment `total` by `nums[i]`\\n- Within each iteration of `i` in `len(nums)`, while `total` is greater than or equal to `s`, set `res` to the `min` of `res` or `i - left + 1`, decrement `total`\\'s value by `nums[left]`, and increment `left`\\n- Return `res` if `res != maxsize` otherwise return 0\\n\\n```\\nfrom sys import maxsize\\n   \\ndef minSubArrayLen(s, nums):\\n\\tres = maxsize\\n\\tleft, total = 0, 0\\n\\t\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += nums[i]\\n\\t\\twhile total >= s:\\n\\t\\t\\tres = min(res, i - left + 1)\\n\\t\\t\\ttotal -= nums[left]\\n\\t\\t\\tleft += 1\\n\\t\\n\\treturn res if res != maxsize else 0\\n```\\n\\n\\n```\\n[2,3,1,2,4,3] total = 0,  left = 0, i = 0, res = maxsize\\n ^\\n[2,3,1,2,4,3] total = 5,  left = 0, i = 1, res = maxsize\\n ^ ^\\n[2,3,1,2,4,3] total = 6,  left = 0, i = 2, res = maxsize\\n ^   ^\\n[2,3,1,2,4,3] total = 8,  left = 0, i = 3, res = 4\\n ^     ^\\n[2,3,1,2,4,3] total = 6,  left = 1, i = 3, res = 4\\n   ^   ^\\n[2,3,1,2,4,3] total = 10, left = 1, i = 4, res = 4\\n   ^     ^\\n[2,3,1,2,4,3] total = 7,  left = 2, i = 4, res = 4\\n     ^   ^\\n[2,3,1,2,4,3] total = 6,  left = 3, i = 4, res = 4\\n       ^ ^\\n[2,3,1,2,4,3] total = 9,  left = 3, i = 5, res = 4\\n       ^   ^\\n[2,3,1,2,4,3] total = 7,  left = 4, i = 5, res = 2\\n         ^ ^\\n```\\n\\n15 / 15 test cases passed.\\nStatus: Accepted\\nRuntime: 48 ms\\nMemory Usage: 14.5 MB\\n\\nhttps://leetcode.com/submissions/detail/223395367/",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nfrom sys import maxsize\\n   \\ndef minSubArrayLen(s, nums):\\n\\tres = maxsize\\n\\tleft, total = 0, 0\\n\\t\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += nums[i]\\n\\t\\twhile total >= s:\\n\\t\\t\\tres = min(res, i - left + 1)\\n\\t\\t\\ttotal -= nums[left]\\n\\t\\t\\tleft += 1\\n\\t\\n\\treturn res if res != maxsize else 0\\n```\n```\\n[2,3,1,2,4,3] total = 0,  left = 0, i = 0, res = maxsize\\n ^\\n[2,3,1,2,4,3] total = 5,  left = 0, i = 1, res = maxsize\\n ^ ^\\n[2,3,1,2,4,3] total = 6,  left = 0, i = 2, res = maxsize\\n ^   ^\\n[2,3,1,2,4,3] total = 8,  left = 0, i = 3, res = 4\\n ^     ^\\n[2,3,1,2,4,3] total = 6,  left = 1, i = 3, res = 4\\n   ^   ^\\n[2,3,1,2,4,3] total = 10, left = 1, i = 4, res = 4\\n   ^     ^\\n[2,3,1,2,4,3] total = 7,  left = 2, i = 4, res = 4\\n     ^   ^\\n[2,3,1,2,4,3] total = 6,  left = 3, i = 4, res = 4\\n       ^ ^\\n[2,3,1,2,4,3] total = 9,  left = 3, i = 5, res = 4\\n       ^   ^\\n[2,3,1,2,4,3] total = 7,  left = 4, i = 5, res = 2\\n         ^ ^\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1429685,
                "title": "sliding-window-solution-with-explanation",
                "content": "If you\\'re slow at following some of these solutions like me then you might appreciate this. \\n\\n*p.s I know this isn\\'t the most optimal solution but sliding door is still important to understand.*\\n\\nThe general approach/algorithm of sliding door is: \\n1. Use two pointers to represent your window. \"start\" & \"end\"\\n2. Keep moving the end pointer until your condition is true or in other words; the window is valid.\\n3. Start to condense your window by moving your start pointer while also simultaneously making sure your window is still valid. \\n\\nHere is the top voted solution using sliding window (two pointers) in Java courtesy of @jeantimex \\nI have just renamed some of the variables for readability and included comments.\\n\\n``` \\npublic int minSubArrayLen(int target, int[] nums) {\\n// basic constraint checking\\n  if (nums == null || nums.length == 0)\\n    return 0;\\n  \\n  // initialization of the start & end index of your sliding window \\n  int start = 0,  end = 0,  sum = 0,  minLength = Integer.MAX_VALUE;\\n  \\n  while (end < nums.length) {\\n    // keep a running sum as the end pointer expands your window\\n    sum += nums[end++];\\n\\t\\n    // this while loop will be skipped until your window meets the condition that \\n\\t// the running sum is equal or greater than the int \\'s\\' passed in. aka the window\\n\\t// is valid\\n    while (sum >= target) {\\n\\t// now you want to condense your window to find the minimum window as the \\n\\t// problem wants\\n\\t\\n\\t  // updates the min length\\n      minLength = Math.min(minLength, end - start);\\n\\t  \\n\\t  // this moves your start index by one condensing your window and \\n\\t  // decreasing the sum to make sure that it\\'s still valid\\n      sum -= nums[start++];\\n    }\\n  }\\n  \\n  // if no min is found, return 0 or else return the min length you found above. \\n  return minLength == Integer.MAX_VALUE ? 0 : minLength;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "``` \\npublic int minSubArrayLen(int target, int[] nums) {\\n// basic constraint checking\\n  if (nums == null || nums.length == 0)\\n    return 0;\\n  \\n  // initialization of the start & end index of your sliding window \\n  int start = 0,  end = 0,  sum = 0,  minLength = Integer.MAX_VALUE;\\n  \\n  while (end < nums.length) {\\n    // keep a running sum as the end pointer expands your window\\n    sum += nums[end++];\\n\\t\\n    // this while loop will be skipped until your window meets the condition that \\n\\t// the running sum is equal or greater than the int \\'s\\' passed in. aka the window\\n\\t// is valid\\n    while (sum >= target) {\\n\\t// now you want to condense your window to find the minimum window as the \\n\\t// problem wants\\n\\t\\n\\t  // updates the min length\\n      minLength = Math.min(minLength, end - start);\\n\\t  \\n\\t  // this moves your start index by one condensing your window and \\n\\t  // decreasing the sum to make sure that it\\'s still valid\\n      sum -= nums[start++];\\n    }\\n  }\\n  \\n  // if no min is found, return 0 or else return the min length you found above. \\n  return minLength == Integer.MAX_VALUE ? 0 : minLength;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59144,
                "title": "1-ms-o-n-time-solution-in-java-dynamic-sliding-window",
                "content": "We will maintain a window that grows until sum reach the given sum. Once the window grows to sum at least s then we can start shirking the window from left with the hope to find a smaller window. We shrink until sum falls below s. Then we can grow the window on right again and so on. We keep this procedure of growing-shrinking until the window start reaches the end of the array. Below is the implementation of the above idea which runs in O(n) time and O(1) space. \\n\\n\\n\\n    public class Solution {\\n        public int minSubArrayLen(int sum, int[] nums) {\\n            int minlen = Integer.MAX_VALUE;\\n    \\t\\tint curSum = 0;\\n    \\t\\tint start = 0;\\n    \\t\\tint end = 0;\\n    \\t\\t\\n    \\t\\twhile(start < nums.length){\\n    \\t\\t\\t//if current window doesn't add up to the given sum then \\n    \\t\\t\\t//strech the window to right\\n    \\t\\t\\tif(curSum < sum && end < nums.length){\\n    \\t\\t\\t\\tcurSum += nums[end];\\n    \\t\\t\\t\\tend++;\\n    \\t\\t\\t}\\n    \\t\\t\\t//if current window adds up to at least given sum then\\n    \\t\\t\\t//we can shrink the window \\n    \\t\\t\\telse if(curSum >= sum){\\n    \\t\\t\\t\\tminlen = Math.min(minlen, end-start);\\n    \\t\\t\\t\\tcurSum -= nums[start];\\n    \\t\\t\\t\\tstart++;\\n    \\t\\t\\t}\\n    \\t\\t\\t//cur sum less than required sum but we reach the end \\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn (minlen == Integer.MAX_VALUE) ? 0 : minlen;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minSubArrayLen(int sum, int[] nums) {\\n            int minlen = Integer.MAX_VALUE;\\n    \\t\\tint curSum = 0;\\n    \\t\\tint start = 0;\\n    \\t\\tint end = 0;\\n    \\t\\t\\n    \\t\\twhile(start < nums.length){\\n    \\t\\t\\t//if current window doesn't add up to the given sum then \\n    \\t\\t\\t//strech the window to right\\n    \\t\\t\\tif(curSum < sum && end < nums.length){\\n    \\t\\t\\t\\tcurSum += nums[end];\\n    \\t\\t\\t\\tend++;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1328175,
                "title": "two-pointer-approach-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=0;\\n        int minlen=INT_MAX;\\n        int sum=0;\\n        while(right<nums.size())\\n        {\\n            sum+=nums[right++];\\n            while(sum>=target)\\n            {\\n                minlen=min(minlen,right - left);\\n                sum-=nums[left++];\\n            }\\n        }\\n        return(minlen==INT_MAX)?0:minlen;  \\n    }\\n};\\n```\\n**please upvote if you like the solution and comment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=0;\\n        int minlen=INT_MAX;\\n        int sum=0;\\n        while(right<nums.size())\\n        {\\n            sum+=nums[right++];\\n            while(sum>=target)\\n            {\\n                minlen=min(minlen,right - left);\\n                sum-=nums[left++];\\n            }\\n        }\\n        return(minlen==INT_MAX)?0:minlen;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500877,
                "title": "java-both-o-n-o-n-logn-solutions-with-o-1-space-sliding-window-binary-search-solutions",
                "content": "**Sliding Window Solution**\\n```java\\n/**\\n * This solution only works if there are only positive numbers. If there are\\n * negative numbers too, then see solution for\\n * https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\\n *\\n * Time Complexity: O(N). Each element of array is visited maximum twice.\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        if (nums == null || target < 0) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        int start = 0;\\n        int end = 0;\\n        int minLen = len + 1;\\n\\n        while (end < len) {\\n            target -= nums[end];\\n            end++;\\n\\n            while (target <= 0) {\\n                minLen = Math.min(minLen, end - start);\\n                target += nums[start];\\n                start++;\\n            }\\n        }\\n\\n        return minLen % (len + 1);\\n    }\\n}\\n```\\n\\n---\\n**Binary Search Solution**\\n```java\\n/**\\n * This solution uses binary search method on window size and tries to find if a\\n * window of size is available in the nums array or not.\\n *\\n * This solution only works if there are only positive numbers.\\n *\\n * T(k) = T(k/2) + O(N) ==> T(k) = O(N log(k)). Here k is N. Thus the time\\n * complexity will be O(N log(N)).\\n *\\n * Time Complexity: O(N log(N))\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        if (nums == null || target < 0) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        int start = 1;\\n        int end = len;\\n        int minLen = len + 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            int foundWindowSize = windowExists(nums, target, mid);\\n            if (foundWindowSize > 0) {\\n                end = foundWindowSize - 1;\\n                minLen = foundWindowSize;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return minLen % (len + 1);\\n    }\\n\\n    private int windowExists(int[] nums, int target, int maxWindowSize) {\\n        int foundWindowSize = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            target -= nums[i];\\n            foundWindowSize++;\\n\\n            if (i >= maxWindowSize) {\\n                foundWindowSize--;\\n                target += nums[i - maxWindowSize];\\n            }\\n\\n            if (target <= 0) {\\n                return foundWindowSize;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Sliding Window questions on LeetCode:\\n- [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/1496754/Java-or-TC:-O(S+T)-or-SC:-O(T)-or-Space-optimized-Sliding-Window-using-Two-Pointers)\\n- [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/1496838/Java-or-TC:-O(N)-or-SC:-O(K)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/1496840/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/1500039/Java-or-TC:-O(S+P)-or-SC:-O(1)-or-Sliding-window-solution)\\n- [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1500874/Java-or-TC:-O(N)-or-SC:-O(1)-or-Sliding-Window-using-HashMap-and-Two-Pointers)\\n- [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/1500887/Java-or-TC:-O(N)-or-SC:-O(min(N-K))-or-Sliding-Window-using-HashSet)\\n- [220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/discuss/1500895/Java-or-TC:-O(N)-or-SC:-O(min(NK))-or-Sliding-Window-using-Buckets)\\n- [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/discuss/1500902/Java-or-TC:-O(S2)-or-SC:-O(1)-or-Constant-space-Sliding-Window-solution)\\n- [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/discuss/1506048/Java-or-TC:-O(N)-or-SC:-O(K)-or-Using-Deque-as-Sliding-Window)\\n- [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/discuss/1507981/Java-or-TC:-O(N*logK)-or-SC:-(K)-or-Optimized-sliding-window-using-TreeSet)\\n- [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1508045/Java-or-TC:-O(N)-or-SC:-O(1)-or-Four-solutions-with-Follow-up-handled)\\n- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1508044/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Optimized-Sliding-Window)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```java\\n/**\\n * This solution only works if there are only positive numbers. If there are\\n * negative numbers too, then see solution for\\n * https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\\n *\\n * Time Complexity: O(N). Each element of array is visited maximum twice.\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        if (nums == null || target < 0) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        int start = 0;\\n        int end = 0;\\n        int minLen = len + 1;\\n\\n        while (end < len) {\\n            target -= nums[end];\\n            end++;\\n\\n            while (target <= 0) {\\n                minLen = Math.min(minLen, end - start);\\n                target += nums[start];\\n                start++;\\n            }\\n        }\\n\\n        return minLen % (len + 1);\\n    }\\n}\\n```\n```java\\n/**\\n * This solution uses binary search method on window size and tries to find if a\\n * window of size is available in the nums array or not.\\n *\\n * This solution only works if there are only positive numbers.\\n *\\n * T(k) = T(k/2) + O(N) ==> T(k) = O(N log(k)). Here k is N. Thus the time\\n * complexity will be O(N log(N)).\\n *\\n * Time Complexity: O(N log(N))\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        if (nums == null || target < 0) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        int start = 1;\\n        int end = len;\\n        int minLen = len + 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            int foundWindowSize = windowExists(nums, target, mid);\\n            if (foundWindowSize > 0) {\\n                end = foundWindowSize - 1;\\n                minLen = foundWindowSize;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return minLen % (len + 1);\\n    }\\n\\n    private int windowExists(int[] nums, int target, int maxWindowSize) {\\n        int foundWindowSize = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            target -= nums[i];\\n            foundWindowSize++;\\n\\n            if (i >= maxWindowSize) {\\n                foundWindowSize--;\\n                target += nums[i - maxWindowSize];\\n            }\\n\\n            if (target <= 0) {\\n                return foundWindowSize;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232367,
                "title": "c-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0,s=0;\\n        int res=INT_MAX;\\n        while(j<n)\\n        {\\n            s=s+nums[j];\\n            if(s<target)\\n                j++;      \\n           else\\n            {\\n                while(s>=target)\\n                {\\n                    res=min(res,j-i+1);\\n                    s=s-nums[i];\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        if(res==INT_MAX)\\n            return 0;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0,s=0;\\n        int res=INT_MAX;\\n        while(j<n)\\n        {\\n            s=s+nums[j];\\n            if(s<target)\\n                j++;      \\n           else\\n            {\\n                while(s>=target)\\n                {\\n                    res=min(res,j-i+1);\\n                    s=s-nums[i];\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        if(res==INT_MAX)\\n            return 0;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438975,
                "title": "all-java-solutions-brute-force-treemap-binary-search-two-pointers-explanation",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/minimum-size-subarray-sum/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n\\n\\n## Problem\\n\\n> Given an array of `n` positive integers and a positive integer `s`, find the minimal length of a contiguous subarray of which the `sum \\u2265 s`. If there isn\\'t one, return `0` instead.\\n\\n**Example:** \\n\\n```java\\nInput: s = 7, nums = [2,3,1,2,4,3]\\nOutput: 2\\nExplanation: the subarray [4,3] has the minimal length under the problem constraint.\\n```\\n\\n**Follow up:** If you have figured out the `O(N)` solution, try coding another solution of which the time complexity is `O(N\\\\log{N})`.\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\n**Note:** Be careful of the initialization.\\n\\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  int minLen = Integer.MAX_VALUE;\\n  \\n  for (int i = 0; i < n; ++i) {\\n    int sum = 0;\\n    for (int j = i; j < n; ++j) {\\n      sum += nums[j];\\n      if (sum >= s) {\\n        minLen = Math.min(minLen, j - i + 1);\\n      }\\n    }\\n  }\\n  \\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(1)`\\n\\n\\n\\n### TreeMap\\n\\nMy TreeMap Post: [TreeSet/TreeMap Usage & binarySearch()](http://junhaow.com/lc/notes/treeset-treemap-usage-and-binarySearch.html)\\n\\nBased on the idea in `325. Maximum Size Subarray Sum Equals K`, we can use a tree map for solving this problem.\\n\\n**Modification:**\\n\\nWhen we have duplicate prefix sums, we update the index. It is because in this problem we want the minimum size. **However**, since the problem statement says there are all positive integers, there won\\'t be duplicate prefix sums.\\n\\n```java\\n  x      s\\n-----> ------>\\n------------->\\n     sum\\n```\\n\\nAlso, in this problem we want the sum greater than or equal to `s`, so we cannot use hash map. Instead, we use a tree map. In the example above, when we have a prefix sum `sum`, we check if there is an `x` such that `sum - x >= s`. In other words, we want `x <= sum - s`. It is to find the greatest `x` that satisfies the equation. This can be achieved by using `floorKey(K)` in TreeMap.\\n\\n**Try it by hand with an example!**\\n\\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  TreeMap<Integer, Integer> map = new TreeMap<>(); // <prefixSum, index>\\n  map.put(0, -1);\\n  \\n  int minLen = Integer.MAX_VALUE;\\n  \\n  int sum = 0;\\n  for (int i = 0; i < n; ++i) {\\n    sum += nums[i];\\n    \\n    if (map.floorKey(sum - s) != null) {\\n      int size = i - map.get(map.floorKey(sum - s)); // or floorEntry(K).getValue()\\n      minLen = Math.min(minLen, size);\\n    }\\n    \\n    map.put(sum, i); // update to the latest index\\n  }\\n  \\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\\n\\n**Time:** `O(N\\\\log{N})`\\n**Space:** `O(N)`\\n\\n\\n\\n### Binary Search\\n\\nBased on the same idea, we can implement the binary search by ourselves. We don\\'t need a tree map here because we have positive elements such that prefix sums are always increasing; in other words, as we build the array, it is always sorted in ascending order.\\n\\nIn this solution, we apply upper-bound binary search (FYI: [Binary Search Template Notes](https://www.junhaow.com/lc/notes/binary-search-template-notes.html)).\\n\\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  int[] prefix = new int[n + 1];\\n  prefix[0] = 0; // corresponding to map.put(0, -1), but index starts from 0\\n  // prefix[0] = 0, prefix[1] = nums[0], prefix[2] = nums[0] + nums[1], ...\\n  \\n  int minLen = Integer.MAX_VALUE;\\n  \\n  int sum = 0;\\n  for (int i = 0; i < n; ++i) {\\n    sum += nums[i];\\n    \\n    int result = binarySearch(prefix, 0, i, sum - s);\\n    if (result != -1) { // <= sum - s\\n      int size = i - result + 1;\\n      minLen = Math.min(minLen, size);\\n    }\\n\\n    prefix[i + 1] = sum;\\n  }\\n  \\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n\\n// To find the one (<= key)\\n// we use upper-bound BS to find (> key)\\n// exists:     lo - 1 --> existing item\\n// not exists: lo - 1 --> greatest item < key\\nprivate int binarySearch(int[] nums, int lo, int hi, int key) {\\n  int oldLo = lo;\\n  int oldHi = hi;\\n  while (lo <= hi) {\\n    int mid = lo + (hi - lo) / 2;\\n    if (nums[mid] > key) {\\n      hi = mid - 1;\\n    } else {\\n      lo = mid + 1;\\n    }\\n  }\\n  lo -= 1;\\n  if (lo >= oldLo && lo <= oldHi) return lo;\\n  else return -1;\\n}\\n```\\n\\n**Time:** `O(N\\\\log{N})`\\n**Space:** `O(N)`\\n\\n\\n\\n### Two Pointers\\n\\n```java\\ns = 0, nums = [0] // this is an invalid input\\n```\\n\\nInstead of having the starting index fixed, we update it when it no longer contributes to a solution.\\n\\n```java\\ns = 7, nums = [2, 3, 1, 2, 4, 3]  // output: 2\\n              i/j (2)             // i = start, j = end\\n               i  j (5)\\n               i     j (6)\\n               i        j (8) // increasing j does not give us a better solution\\n                  i     j (6)\\n                  i        j (10)\\n                     i     j (7)\\n                        i  j (6)\\n                        i     j (9)\\n                           i  j (7)\\n                             i/j (3)\\n\\n```\\n\\nMy Version: (initialize `sum` as `nums[0]`)\\n\\n**Note:** The subarray is `[start, end]`.\\n\\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  if (n == 0) {\\n    return 0;\\n  }\\n  int sum = nums[0];\\n  int minLen = Integer.MAX_VALUE;\\n  int start = 0, end = 0; // [start, end]\\n\\n  while (end < n) {\\n    if (sum < s) {\\n      ++end;\\n      if (end == n) break;\\n      sum += nums[end];\\n    } else { // sum >= s\\n      minLen = Math.min(minLen, end - start + 1);\\n      sum -= nums[start];\\n      ++start;\\n    }\\n  }\\n\\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\\n\\nWe can also use `while` to update `start` until it satisfies the condition:\\n\\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  if (n == 0) {\\n    return 0;\\n  }\\n  int sum = nums[0];\\n  int minLen = Integer.MAX_VALUE;\\n  int start = 0, end = 0; // [start, end]\\n\\n  while (end < n) {\\n    if (sum < s) {\\n      ++end;\\n      if (end == n) break;\\n      sum += nums[end];\\n    }\\n    while (sum >= s) { // nums[] can\\'t be 0\\n      minLen = Math.min(minLen, end - start + 1);\\n      sum -= nums[start];\\n      ++start;\\n    }\\n  }\\n\\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\\n\\n\\nOther:\\n\\n**Note:** The subarray is `[start, end)`.\\n\\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  int sum = 0;\\n  int minLen = Integer.MAX_VALUE;\\n  int start = 0, end = 0;\\n\\n  while (end < n) {\\n    sum += nums[end];\\n    ++end;\\n    if (sum >= s) {\\n      minLen = Math.min(minLen, end - start);\\n      --end;\\n      sum -= nums[end]; // restore\\n      sum -= nums[start]; ++start;\\n    } // sum < s\\n  }\\n  \\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\\n\\nUse `while`:\\n\\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  int sum = 0;\\n  int minLen = Integer.MAX_VALUE;\\n  int start = 0, end = 0;\\n\\n  while (end < n) {\\n    sum += nums[end];\\n    ++end;\\n    while (sum >= s) {\\n      minLen = Math.min(minLen, end - start);\\n      sum -= nums[start];\\n      ++start;\\n    }\\n  }\\n  \\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\\n\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/sdeez.png)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```java\\nInput: s = 7, nums = [2,3,1,2,4,3]\\nOutput: 2\\nExplanation: the subarray [4,3] has the minimal length under the problem constraint.\\n```\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  int minLen = Integer.MAX_VALUE;\\n  \\n  for (int i = 0; i < n; ++i) {\\n    int sum = 0;\\n    for (int j = i; j < n; ++j) {\\n      sum += nums[j];\\n      if (sum >= s) {\\n        minLen = Math.min(minLen, j - i + 1);\\n      }\\n    }\\n  }\\n  \\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\n```java\\n  x      s\\n-----> ------>\\n------------->\\n     sum\\n```\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  TreeMap<Integer, Integer> map = new TreeMap<>(); // <prefixSum, index>\\n  map.put(0, -1);\\n  \\n  int minLen = Integer.MAX_VALUE;\\n  \\n  int sum = 0;\\n  for (int i = 0; i < n; ++i) {\\n    sum += nums[i];\\n    \\n    if (map.floorKey(sum - s) != null) {\\n      int size = i - map.get(map.floorKey(sum - s)); // or floorEntry(K).getValue()\\n      minLen = Math.min(minLen, size);\\n    }\\n    \\n    map.put(sum, i); // update to the latest index\\n  }\\n  \\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  int[] prefix = new int[n + 1];\\n  prefix[0] = 0; // corresponding to map.put(0, -1), but index starts from 0\\n  // prefix[0] = 0, prefix[1] = nums[0], prefix[2] = nums[0] + nums[1], ...\\n  \\n  int minLen = Integer.MAX_VALUE;\\n  \\n  int sum = 0;\\n  for (int i = 0; i < n; ++i) {\\n    sum += nums[i];\\n    \\n    int result = binarySearch(prefix, 0, i, sum - s);\\n    if (result != -1) { // <= sum - s\\n      int size = i - result + 1;\\n      minLen = Math.min(minLen, size);\\n    }\\n\\n    prefix[i + 1] = sum;\\n  }\\n  \\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n\\n// To find the one (<= key)\\n// we use upper-bound BS to find (> key)\\n// exists:     lo - 1 --> existing item\\n// not exists: lo - 1 --> greatest item < key\\nprivate int binarySearch(int[] nums, int lo, int hi, int key) {\\n  int oldLo = lo;\\n  int oldHi = hi;\\n  while (lo <= hi) {\\n    int mid = lo + (hi - lo) / 2;\\n    if (nums[mid] > key) {\\n      hi = mid - 1;\\n    } else {\\n      lo = mid + 1;\\n    }\\n  }\\n  lo -= 1;\\n  if (lo >= oldLo && lo <= oldHi) return lo;\\n  else return -1;\\n}\\n```\n```java\\ns = 0, nums = [0] // this is an invalid input\\n```\n```java\\ns = 7, nums = [2, 3, 1, 2, 4, 3]  // output: 2\\n              i/j (2)             // i = start, j = end\\n               i  j (5)\\n               i     j (6)\\n               i        j (8) // increasing j does not give us a better solution\\n                  i     j (6)\\n                  i        j (10)\\n                     i     j (7)\\n                        i  j (6)\\n                        i     j (9)\\n                           i  j (7)\\n                             i/j (3)\\n\\n```\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  if (n == 0) {\\n    return 0;\\n  }\\n  int sum = nums[0];\\n  int minLen = Integer.MAX_VALUE;\\n  int start = 0, end = 0; // [start, end]\\n\\n  while (end < n) {\\n    if (sum < s) {\\n      ++end;\\n      if (end == n) break;\\n      sum += nums[end];\\n    } else { // sum >= s\\n      minLen = Math.min(minLen, end - start + 1);\\n      sum -= nums[start];\\n      ++start;\\n    }\\n  }\\n\\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  if (n == 0) {\\n    return 0;\\n  }\\n  int sum = nums[0];\\n  int minLen = Integer.MAX_VALUE;\\n  int start = 0, end = 0; // [start, end]\\n\\n  while (end < n) {\\n    if (sum < s) {\\n      ++end;\\n      if (end == n) break;\\n      sum += nums[end];\\n    }\\n    while (sum >= s) { // nums[] can\\'t be 0\\n      minLen = Math.min(minLen, end - start + 1);\\n      sum -= nums[start];\\n      ++start;\\n    }\\n  }\\n\\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  int sum = 0;\\n  int minLen = Integer.MAX_VALUE;\\n  int start = 0, end = 0;\\n\\n  while (end < n) {\\n    sum += nums[end];\\n    ++end;\\n    if (sum >= s) {\\n      minLen = Math.min(minLen, end - start);\\n      --end;\\n      sum -= nums[end]; // restore\\n      sum -= nums[start]; ++start;\\n    } // sum < s\\n  }\\n  \\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```\n```java\\npublic int minSubArrayLen(int s, int[] nums) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  int sum = 0;\\n  int minLen = Integer.MAX_VALUE;\\n  int start = 0, end = 0;\\n\\n  while (end < n) {\\n    sum += nums[end];\\n    ++end;\\n    while (sum >= s) {\\n      minLen = Math.min(minLen, end - start);\\n      sum -= nums[start];\\n      ++start;\\n    }\\n  }\\n  \\n  return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 658110,
                "title": "javascript-clean-o-n-sliding-window-solution",
                "content": "```javascript\\nvar minSubArrayLen = function(s, nums) {\\n    let left = 0;\\n    let right = 0;\\n    let sum = 0;\\n    let result = 0;\\n    \\n    while(right < nums.length) {\\n        sum += nums[right];\\n        \\n        while(sum >= s) {\\n            let len = right - left +1;\\n            if(result === 0 || len < result) result = len;\\n            sum -= nums[left];\\n            left++\\n        }\\n        right++;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```javascript\\nvar minSubArrayLen = function(s, nums) {\\n    let left = 0;\\n    let right = 0;\\n    let sum = 0;\\n    let result = 0;\\n    \\n    while(right < nums.length) {\\n        sum += nums[right];\\n        \\n        while(sum >= s) {\\n            let len = right - left +1;\\n            if(result === 0 || len < result) result = len;\\n            sum -= nums[left];\\n            left++\\n        }\\n        right++;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59151,
                "title": "c-6ms-solution-sliding-window",
                "content": "Any elegant way to replace do-while loop ? Look like it's the most fitting....\\n\\n    class Solution {\\n    public:\\n        int minSubArrayLen(int s, vector<int>& nums) {\\n            int num_len= nums.size();\\n            int left=0, right=0, total=0, min_len= num_len+1;\\n            while (right < num_len) {\\n                // move right silder forward till total >= s\\n                do { total += nums[right++]; } while (right<num_len && total< s);\\n                // move left slider forward while maintaining total >= s\\n                while (left<right && total-nums[left]>=s) total -= nums[left++];\\n                // record if it's the minimum\\n                if (total>=s && min_len> right- left) \\n                    min_len= right- left;\\n            }\\n            return min_len<=num_len ? min_len: 0;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int minSubArrayLen(int s, vector<int>& nums) {\\n            int num_len= nums.size();\\n            int left=0, right=0, total=0, min_len= num_len+1;\\n            while (right < num_len) {\\n                // move right silder forward till total >= s\\n                do { total += nums[right++]; }",
                "codeTag": "Java"
            },
            {
                "id": 1037095,
                "title": "python-3-two-pointer-while-loop-illustrated",
                "content": "Using 2-pointer. c is the min length, and t is the sum of the subarray. Move one pointer at each while-loop. See the illustration below.\\n![image](https://assets.leetcode.com/users/images/e1468cd7-faee-4b00-ab77-ae45c25bbd46_1611728068.6225245.png)\\n![image](https://assets.leetcode.com/users/images/cae958b2-6180-4b02-b173-5a73506c1dc3_1611728084.3222067.png)\\n![image](https://assets.leetcode.com/users/images/fc44b2c5-b7cf-428a-bfbe-63b28423e394_1611728092.826835.png)\\n![image](https://assets.leetcode.com/users/images/ed6d52c9-f985-461c-a6e0-482c85db0514_1611728097.1885233.png)\\n\\n\\n~~~\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        if len(nums) == 0: return 0\\n        i, j = 0, 0\\n        c, t = float(\"inf\"), nums[0]\\n        while j <= len(nums)-1:\\n            if t < s:\\n                j += 1\\n                if j <= len(nums)-1:\\n                    t += nums[j]\\n            elif t >= s:\\n                c = min(j - i + 1, c)\\n                t -= nums[i]\\n                i += 1\\n        return c if c != float(\"inf\") else 0\\n~~~\\n\\n#Runtime: 92 ms, faster than 22.31% of Python3 online submissions for Minimum Size Subarray Sum.\\n#Memory Usage: 16.6 MB, less than 79.67% of Python3 online submissions for Minimum Size Subarray Sum.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Using 2-pointer. c is the min length, and t is the sum of the subarray. Move one pointer at each while-loop. See the illustration below.\\n![image](https://assets.leetcode.com/users/images/e1468cd7-faee-4b00-ab77-ae45c25bbd46_1611728068.6225245.png)\\n![image](https://assets.leetcode.com/users/images/cae958b2-6180-4b02-b173-5a73506c1dc3_1611728084.3222067.png)\\n![image](https://assets.leetcode.com/users/images/fc44b2c5-b7cf-428a-bfbe-63b28423e394_1611728092.826835.png)\\n![image](https://assets.leetcode.com/users/images/ed6d52c9-f985-461c-a6e0-482c85db0514_1611728097.1885233.png)\\n\\n\\n~~~\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        if len(nums) == 0: return 0\\n        i, j = 0, 0\\n        c, t = float(\"inf\"), nums[0]\\n        while j <= len(nums)-1:\\n            if t < s:\\n                j += 1\\n                if j <= len(nums)-1:\\n                    t += nums[j]\\n            elif t >= s:\\n                c = min(j - i + 1, c)\\n                t -= nums[i]\\n                i += 1\\n        return c if c != float(\"inf\") else 0\\n~~~\\n\\n#Runtime: 92 ms, faster than 22.31% of Python3 online submissions for Minimum Size Subarray Sum.\\n#Memory Usage: 16.6 MB, less than 79.67% of Python3 online submissions for Minimum Size Subarray Sum.\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 553837,
                "title": "intuitive-javascript-solution-with-two-pointers",
                "content": "```\\n/**\\n * @param {number} s\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSubArrayLen = function(s, nums) {\\n    let distance = Number.MAX_SAFE_INTEGER;\\n    let left = 0;\\n    let sum = 0;\\n    // left pointer and right pointer defines the window. \\n    // the goal is to find the smallest window that has a sum of s or larger.\\n    for (let right = 0; right < nums.length; right++) {\\n        sum += nums[right]; \\n        while (sum >= s) {\\n            distance = Math.min(distance, right - left + 1);\\n            sum -= nums[left];\\n            left += 1;\\n        }\\n    }\\n\\n    return distance === Number.MAX_SAFE_INTEGER ? 0 : distance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number} s\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSubArrayLen = function(s, nums) {\\n    let distance = Number.MAX_SAFE_INTEGER;\\n    let left = 0;\\n    let sum = 0;\\n    // left pointer and right pointer defines the window. \\n    // the goal is to find the smallest window that has a sum of s or larger.\\n    for (let right = 0; right < nums.length; right++) {\\n        sum += nums[right]; \\n        while (sum >= s) {\\n            distance = Math.min(distance, right - left + 1);\\n            sum -= nums[left];\\n            left += 1;\\n        }\\n    }\\n\\n    return distance === Number.MAX_SAFE_INTEGER ? 0 : distance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2657137,
                "title": "sliding-window-dynamic-approach-o-n-o-n-k-javascript",
                "content": "# ** Explanation\\nFrom the problem we need to acheive.,\\nto find : *\" a subarray length from the given `nums` must be as minimum as possible \"*\\ncondition : *\" sum of the elements of subarray is greater than or equal to given `target` \"*\\n\\n**Sliding window approach** best suits the scenario, as we just need to find the minimal arbitrary length of a subarray that satisfies the given condition.\\n\\n# *Why specifically window sliding technique?*\\n\\n**Naive Approach =>** (Brute Force Approach)\\n\\nWe start with the first index and sum till the **kth** element where the condition is satisfied. Need to be done for all possible consecutive blocks or groups of `k elements`. This method requires a inner loop, the outer loop starts with the starting element of the block of `k elements`, and the inner or the nested will add up till the **kth** element\\n\\n# O(n*k) - k represents the subarray\\n```\\n\\tlet start = 0;\\n    let subarraySum = 0;\\n    let minValue = Infinity;\\n    for(let end=0; end<nums.length; end++){\\n        subarraySum += nums[end];\\n        while(subarraySum >= target){\\n            minValue = Math.min(minValue, end-start+1);\\n            subarraySum -= nums[start];\\n            start++;\\n        }\\n    }\\n    return minValue === Infinity ? 0 : minValue;\\n```\\n\\n**Window Sliding Technique =>**\\n\\nIt is a computational technique that aims to reduce the use of nested loops and replace it with a single loop, thereby reducing the time complexity.\\n\\nThis approach can be done in a very specific scenario, where the **\\'size of the window\\'** for computation merely depends on the `target`, so it is **fixed** on the target value, which results in a subarray of arbitrary length.\\n\\n# *How to use a sliding window technique in general?*\\n**(1) Find the size of the window required (depends on target value)**\\n\\n**(2) Compute the result for 1st window, from the start of the data structure**\\n\\n**(3) Then use a loop to slide the window by 1, and keep computing the result window by window**\\n\\n# O(n)\\n```\\n// initialize the start and end of the window from starting point\\n\\tlet start = 0;\\n    let end = 0;\\n// consider the minValue to be infinity,\\n// just to define the variable \\n    let minValue = Infinity;\\n// sum of subarray initialized to initial array value\\n    let subarraySum = nums[0];\\n\\n// slide the window upto array length\\n// start of the window always be less than or may be equal to end\\n    while(start <= end && end < nums.length){\\n    // if sum satisfies the condition\\n        if(subarraySum >= target){\\n        // extract the minimum subarray length\\n        // end-start+1 => end >= start (always greater or equal)\\n        // when end === start, then end - start === 0\\n        // but window stays atleast on one element (+1) of array \\n            minValue = Math.min(minValue, end-start+1);\\n        // move the start of window by one element\\n        // and remove last start element from sub array sum\\n            subarraySum -= nums[start];\\n            start++;\\n        } else {\\n    // if sum didn\\'t satisfies the condition, drag the window end\\n    // till the sum >= target\\n            end++;\\n            subarraySum += nums[end];\\n        }\\n    }\\n    // return 0, as no subarray satisfies the given condition\\n    return minValue === Infinity ? 0 : minValue;\\n```\\n\\n***please upvote***",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n\\tlet start = 0;\\n    let subarraySum = 0;\\n    let minValue = Infinity;\\n    for(let end=0; end<nums.length; end++){\\n        subarraySum += nums[end];\\n        while(subarraySum >= target){\\n            minValue = Math.min(minValue, end-start+1);\\n            subarraySum -= nums[start];\\n            start++;\\n        }\\n    }\\n    return minValue === Infinity ? 0 : minValue;\\n```\n```\\n// initialize the start and end of the window from starting point\\n\\tlet start = 0;\\n    let end = 0;\\n// consider the minValue to be infinity,\\n// just to define the variable \\n    let minValue = Infinity;\\n// sum of subarray initialized to initial array value\\n    let subarraySum = nums[0];\\n\\n// slide the window upto array length\\n// start of the window always be less than or may be equal to end\\n    while(start <= end && end < nums.length){\\n    // if sum satisfies the condition\\n        if(subarraySum >= target){\\n        // extract the minimum subarray length\\n        // end-start+1 => end >= start (always greater or equal)\\n        // when end === start, then end - start === 0\\n        // but window stays atleast on one element (+1) of array \\n            minValue = Math.min(minValue, end-start+1);\\n        // move the start of window by one element\\n        // and remove last start element from sub array sum\\n            subarraySum -= nums[start];\\n            start++;\\n        } else {\\n    // if sum didn\\'t satisfies the condition, drag the window end\\n    // till the sum >= target\\n            end++;\\n            subarraySum += nums[end];\\n        }\\n    }\\n    // return 0, as no subarray satisfies the given condition\\n    return minValue === Infinity ? 0 : minValue;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2583961,
                "title": "sliding-window-approach-aditya-verma-technique-c",
                "content": "```\\n**If you like the Code do upvote \\uD83D\\uDC46\\uD83E\\uDEE1**\\nclass Solution\\n{\\n    public:\\n        int minSubArrayLen(int target, vector<int> &nums)\\n        {\\n\\n            int i = 0;\\n            int j = 0;\\n            int sum = 0;\\n            int minlength = INT_MAX;\\n            while (j < nums.size())\\n            {\\n\\n                sum += nums[j]; // updating our sum everytime \\n                \\n                if (sum < target)\\n                {\\n                    j++;\\n                }\\n                if (sum >= target)\\n                {\\n\\n                    while (sum >= target)\\n                    {\\n                        minlength = min(minlength, j - i + 1);\\t// update out minlength whenever we hit the target\\n                        sum -= nums[i];\\n                        i++;\\n                    }\\n                    j++;\\n                }\\n            }\\n\\n            return (minlength == INT_MAX) ? 0 : minlength;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n**If you like the Code do upvote \\uD83D\\uDC46\\uD83E\\uDEE1**\\nclass Solution\\n{\\n    public:\\n        int minSubArrayLen(int target, vector<int> &nums)\\n        {\\n\\n            int i = 0;\\n            int j = 0;\\n            int sum = 0;\\n            int minlength = INT_MAX;\\n            while (j < nums.size())\\n            {\\n\\n                sum += nums[j]; // updating our sum everytime \\n                \\n                if (sum < target)\\n                {\\n                    j++;\\n                }\\n                if (sum >= target)\\n                {\\n\\n                    while (sum >= target)\\n                    {\\n                        minlength = min(minlength, j - i + 1);\\t// update out minlength whenever we hit the target\\n                        sum -= nums[i];\\n                        i++;\\n                    }\\n                    j++;\\n                }\\n            }\\n\\n            return (minlength == INT_MAX) ? 0 : minlength;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224520,
                "title": "209-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we can use a sliding window approach. We can initialize two pointers, left and right, both at index 0. We will move the right pointer until the sum of the subarray between left and right is greater than or equal to the target. Then, we can update the minimum length found so far and move the left pointer to the right until the sum is no longer greater than or equal to the target. We repeat this process until the end of the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        # initialize pointers and sum\\n        left, right, total = 0, 0, 0\\n        # initialize minimum length to be the length of the array plus 1 (invalid)\\n        min_len = len(nums) + 1\\n        \\n        # loop through the array\\n        while right < len(nums):\\n            # add current number to the sum\\n            total += nums[right]\\n            # move right pointer\\n            right += 1\\n            \\n            # check if the sum is greater than or equal to target\\n            while total >= target:\\n                # update minimum length if necessary\\n                min_len = min(min_len, right - left)\\n                # subtract left number from the sum and move left pointer\\n                total -= nums[left]\\n                left += 1\\n        \\n        # if minimum length is still the initialized value, there is no valid subarray\\n        if min_len == len(nums) + 1:\\n            return 0\\n        else:\\n            return min_len\\n\\n```\\nWe initialize the pointers left and right to 0 and the variable total to 0 to keep track of the sum of the subarray. We also initialize min_len to be one more than the length of the array because this is an invalid value that we will use to check if we have found a valid subarray. We then loop through the array using the while loop and move the right pointer until the sum of the subarray between left and right is greater than or equal to the target. Once we have found a valid subarray, we update the minimum length found so far and move the left pointer to the right until the sum is no longer greater than or equal to the target. We repeat this process until the end of the array.\\n\\nAt the end of the loop, if min_len is still the initialized value, then there is no valid subarray, so we return 0. Otherwise, we return the minimum length found.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        # initialize pointers and sum\\n        left, right, total = 0, 0, 0\\n        # initialize minimum length to be the length of the array plus 1 (invalid)\\n        min_len = len(nums) + 1\\n        \\n        # loop through the array\\n        while right < len(nums):\\n            # add current number to the sum\\n            total += nums[right]\\n            # move right pointer\\n            right += 1\\n            \\n            # check if the sum is greater than or equal to target\\n            while total >= target:\\n                # update minimum length if necessary\\n                min_len = min(min_len, right - left)\\n                # subtract left number from the sum and move left pointer\\n                total -= nums[left]\\n                left += 1\\n        \\n        # if minimum length is still the initialized value, there is no valid subarray\\n        if min_len == len(nums) + 1:\\n            return 0\\n        else:\\n            return min_len\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799877,
                "title": "python-o-n-by-sliding-window-w-comment",
                "content": "Python O(n) by sliding window\\n\\n---\\n\\n```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        \\n        window_start = 0\\n        min_size = float(\\'inf\\')\\n\\t\\t\\n\\t\\t# summation of subarray\\n        summation = 0\\n        \\n        # use sliding window to update min_size of of valid subarray\\n        for window_end, number in enumerate(nums):\\n            \\n            summation += number\\n            \\n            while summation >= s:\\n                \\n                # keep shrinking window size if summation is valid\\n                min_size = min( min_size, window_end - window_start + 1)\\n                \\n                # update subarray sum\\n                summation -= nums[window_start]\\n                \\n                window_start += 1\\n                \\n        \\n        if min_size == float(\\'inf\\'):\\n            \\n            # no solution\\n            return 0\\n        \\n        else:\\n            \\n            return min_size\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        \\n        window_start = 0\\n        min_size = float(\\'inf\\')\\n\\t\\t\\n\\t\\t# summation of subarray\\n        summation = 0\\n        \\n        # use sliding window to update min_size of of valid subarray\\n        for window_end, number in enumerate(nums):\\n            \\n            summation += number\\n            \\n            while summation >= s:\\n                \\n                # keep shrinking window size if summation is valid\\n                min_size = min( min_size, window_end - window_start + 1)\\n                \\n                # update subarray sum\\n                summation -= nums[window_start]\\n                \\n                window_start += 1\\n                \\n        \\n        if min_size == float(\\'inf\\'):\\n            \\n            # no solution\\n            return 0\\n        \\n        else:\\n            \\n            return min_size\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 59233,
                "title": "o-nlgn-is-not-that-easy-here-is-my-java-code",
                "content": "Use sums[i] store the sum of nums from 0 to i, then sums is a sorted array, and then we can use binary search.\\n\\n    public class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            if (nums.length == 0) return 0;\\n            \\n            int[] sums = new int[nums.length];\\n            sums[0] = nums[0];\\n            for (int i = 1; i < nums.length; i++) {\\n                sums[i] = sums[i - 1] + nums[i];\\n            }\\n            if (sums[nums.length - 1] < s) return 0;\\n            \\n            int ans = Integer.MAX_VALUE;\\n            for (int i = 0; i < nums.length; i++) {\\n                int l = i;\\n                int r = nums.length - 1;\\n                while (l <= r) {\\n                    int mid = l + (r - l)/2;\\n                    if (sums[mid] - sums[i] + nums[i] == s) {\\n                        l = mid;\\n                        break;\\n                    } else if (sums[mid] - sums[i] + nums[i] < s) {\\n                        l = mid + 1;\\n                    } else {\\n                        r = mid - 1;\\n                    }\\n                }\\n                if (l >= sums.length) break;\\n                ans = Math.min(ans, l - i + 1);\\n            }\\n            \\n            return (ans == Integer.MAX_VALUE ? 0 : ans);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            if (nums.length == 0) return 0;\\n            \\n            int[] sums = new int[nums.length];\\n            sums[0] = nums[0];\\n            for (int i = 1; i < nums.length; i++) {\\n                sums[i] = sums[i - 1] + nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3724672,
                "title": "beats-100-video-java-c-python",
                "content": "The code uses a sliding window technique with two pointers to find the shortest subarray in the given array whose sum is equal to or greater than the target value. It expands the window by moving the right pointer, finds the minimum length by adjusting the left pointer, and keeps track of the smallest length encountered so far. \\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/-Ksr0FX9hJI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int i = 0; int j = 0;\\n        int sum = 0; int ans = 1000000;\\n        while(j<A.length){\\n            sum+=A[j];\\n            while(sum>=target){\\n                ans = Math.min(ans, j-i+1);\\n                sum -= A[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n        return ans==1000000?0:ans;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, std::vector<int>& A) {\\n        int i = 0;\\n        int j = 0;\\n        int sum = 0;\\n        int ans = 1000000;\\n        \\n        while (j < A.size()) {\\n            sum += A[j];\\n            \\n            while (sum >= target) {\\n                ans = std::min(ans, j - i + 1);\\n                sum -= A[i];\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return (ans == 1000000) ? 0 : ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, A: List[int]) -> int:\\n        i = 0\\n        j = 0\\n        sum = 0\\n        ans = 1000000\\n        \\n        while j < len(A):\\n            sum += A[j]\\n            \\n            while sum >= target:\\n                ans = min(ans, j - i + 1)\\n                sum -= A[i]\\n                i += 1\\n            \\n            j += 1\\n        \\n        return 0 if ans == 1000000 else ans\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int i = 0; int j = 0;\\n        int sum = 0; int ans = 1000000;\\n        while(j<A.length){\\n            sum+=A[j];\\n            while(sum>=target){\\n                ans = Math.min(ans, j-i+1);\\n                sum -= A[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n        return ans==1000000?0:ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, std::vector<int>& A) {\\n        int i = 0;\\n        int j = 0;\\n        int sum = 0;\\n        int ans = 1000000;\\n        \\n        while (j < A.size()) {\\n            sum += A[j];\\n            \\n            while (sum >= target) {\\n                ans = std::min(ans, j - i + 1);\\n                sum -= A[i];\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return (ans == 1000000) ? 0 : ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, A: List[int]) -> int:\\n        i = 0\\n        j = 0\\n        sum = 0\\n        ans = 1000000\\n        \\n        while j < len(A):\\n            sum += A[j]\\n            \\n            while sum >= target:\\n                ans = min(ans, j - i + 1)\\n                sum -= A[i]\\n                i += 1\\n            \\n            j += 1\\n        \\n        return 0 if ans == 1000000 else ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712881,
                "title": "clean-python-sliding-window-solution-with-explanation",
                "content": "# Intuition\\nThis problem naturally suggests a \"sliding window\" approach. The idea is to maintain a subarray of the given array such that the sum of elements in the subarray is always greater than or equal to the given target. We then try to minimize the length of such subarray.\\n\\n# Approach\\n1. We initialize two pointers, `left` and `right` pointers, both at the beginning of the array, and a variable `sum_of_subarray` to hold the sum of the current subarray, which is initially 0.\\n2. We also initialize a variable `min_length` to infinity which is used to keep track of the minimum length of the subarray found so far.\\n3. For every element pointed to by the `right`, we add it to `sum_of_subarray`.\\n4. After adding a new element to `sum_of_subarray`, we check if the sum is greater than or equal to the target. If it is, we try to shrink the subarray from the left (i.e., increment `left`) as long as the sum remains greater than or equal to the target, each time updating `min_length` if the current length of the subarray is smaller.\\n5. The process continues until `right` has gone through every element in the array.\\n6. If `min_length` remains infinity, it means no valid subarray was found, so we return 0. Otherwise, we return `min_length`.\\n\\n# Complexity\\n- Time complexity: The time complexity of the algorithm is O(n), where n is the length of the input array. This is because in the worst case, each element in the array will be visited at most twice, once by the `right` and once by the `left`.\\n\\n- Space complexity: The space complexity is O(1), as we only use a constant amount of extra space to store our pointers and variables, which does not increase with the size of the input array.\\nsli\\n# Code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        left = 0\\n        sum_of_subarray = 0\\n        min_length = float(\\'inf\\')\\n        \\n        for right in range(len(nums)):\\n            sum_of_subarray += nums[right]\\n            \\n            while sum_of_subarray >= target:\\n                min_length = min(min_length, right - left + 1)\\n                sum_of_subarray -= nums[left]\\n                left += 1\\n\\n        if min_length == float(\\'inf\\'):\\n            return 0\\n\\n        return min_length\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        left = 0\\n        sum_of_subarray = 0\\n        min_length = float(\\'inf\\')\\n        \\n        for right in range(len(nums)):\\n            sum_of_subarray += nums[right]\\n            \\n            while sum_of_subarray >= target:\\n                min_length = min(min_length, right - left + 1)\\n                sum_of_subarray -= nums[left]\\n                left += 1\\n\\n        if min_length == float(\\'inf\\'):\\n            return 0\\n\\n        return min_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498091,
                "title": "python3-sliding-window-with-prefix-sum-beats-98-o-n",
                "content": "```python3 []\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        res, curSum, l = len(nums)+1, 0, 0\\n        \\n        for r, n in enumerate(nums):\\n            curSum += n\\n            while curSum >= target and l <= r:\\n                res = min(res, r - l + 1)\\n                curSum -= nums[l]\\n                l += 1\\n\\n        return res % (len(nums)+1)\\n```\\n![Screenshot 2023-07-06 at 12.41.51.png](https://assets.leetcode.com/users/images/5239b964-86cd-45e8-89da-f694394138c1_1688636543.9575014.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        res, curSum, l = len(nums)+1, 0, 0\\n        \\n        for r, n in enumerate(nums):\\n            curSum += n\\n            while curSum >= target and l <= r:\\n                res = min(res, r - l + 1)\\n                curSum -= nums[l]\\n                l += 1\\n\\n        return res % (len(nums)+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725423,
                "title": "c-o-n-using-sliding-window-o-nlogn-using-prefix-sum",
                "content": "# Approach-1: Sliding Window\\n1. Initialize two pointers, `left` and `right`, both pointing to the start of the array `nums`.\\n2. Initialize the variables `minLen` to store the minimum length of the subarray and `sum` to store the current sum of elements within the window.\\n\\n3. Start iterating the array using the `right` pointer:\\n   - Add the element at the `right` pointer to the `sum`.\\n   - While the `sum` is greater than or equal to the target:\\n     - Update `minLen` by comparing it with the length of the current window (which is `right - left + 1`).\\n     - Subtract the element at the `left` pointer from the `sum`.\\n     - Move the `left` pointer to the right.\\n\\n4. Repeat step 3 until the `right` pointer reaches the end of the array.\\n\\n5. Finally, return `minLen`. If no valid subarray is found, return 0.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums)\\n    {\\n        int left=0, sum=0, minLen=INT_MAX;\\n\\n        for(int right=0; right<nums.size(); right++)\\n        {\\n            sum += nums[right];\\n            \\n            while(sum >= target)\\n            {\\n                minLen = min(minLen, right-left+1);\\n                sum -= nums[left];\\n                left++;\\n            }\\n        }\\n\\n        return (minLen == INT_MAX) ? 0 : minLen;\\n    }\\n};\\n\\n```\\n\\n# Approach-2: Prefix Sum\\n1. Initialize the `prefixSum` array to store the cumulative sums of the input array nums. The `prefixSum[i]` represents the sum of the elements from `nums[0]` to `nums[i-1]`.\\n\\n2. Set the initial minimum length `minLen` to INT_MAX\\n\\n3. Iterate over each starting index `i` of the subarray:\\n   - Initialize `left` as `i + 1` and `right` as the last index of the array.\\n   - Use binary search to find the smallest ending index, `mid`, such that the sum of elements from `nums[i]` to `nums[mid-1]` is greater than or equal to the target.\\n   - If such an ending index is found, update the `minLen` to be the minimum of its current value and the length (mid - i) of the subarray.\\n   - Adjust the search range by updating `left` or `right` based on the comparison of the sum with the target.\\n\\n4. Return the `minLen`. If no subarray is found, return 0.\\n\\n# Complexity\\n- Time Complexity: O(nlogn)\\n- Space Complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        vector<int> prefixSum(n+1, 0);\\n        int minLen = INT_MAX;\\n\\n        for(int i=1; i<=n; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i-1];\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int left = i+1, right = n;\\n\\n            while(left <= right)\\n            {\\n                int mid = left+(right-left)/2;\\n                int sum = prefixSum[mid] - prefixSum[i];\\n\\n                if(sum >= target)\\n                {\\n                    minLen = min(minLen, mid-i);\\n                    right = mid - 1;\\n                }\\n                else\\n                    left = mid+1;\\n            }\\n        }\\n\\n        return (minLen == INT_MAX) ? (0) : (minLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums)\\n    {\\n        int left=0, sum=0, minLen=INT_MAX;\\n\\n        for(int right=0; right<nums.size(); right++)\\n        {\\n            sum += nums[right];\\n            \\n            while(sum >= target)\\n            {\\n                minLen = min(minLen, right-left+1);\\n                sum -= nums[left];\\n                left++;\\n            }\\n        }\\n\\n        return (minLen == INT_MAX) ? 0 : minLen;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        vector<int> prefixSum(n+1, 0);\\n        int minLen = INT_MAX;\\n\\n        for(int i=1; i<=n; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i-1];\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int left = i+1, right = n;\\n\\n            while(left <= right)\\n            {\\n                int mid = left+(right-left)/2;\\n                int sum = prefixSum[mid] - prefixSum[i];\\n\\n                if(sum >= target)\\n                {\\n                    minLen = min(minLen, mid-i);\\n                    right = mid - 1;\\n                }\\n                else\\n                    left = mid+1;\\n            }\\n        }\\n\\n        return (minLen == INT_MAX) ? (0) : (minLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59223,
                "title": "java-concise-solution-with-o-n-complexity",
                "content": "    public int minSubArrayLen(int s, int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n\\t\\t    return 0;\\n\\t    }\\n\\t    int minLen = Integer.MAX_VALUE;\\n\\t    int start = 0;\\n\\t    int localSum = 0;\\n\\t    for (int end = 0; end < nums.length; end++) {\\n\\t\\t    localSum += nums[end];\\n\\t\\t    while (localSum >= s) {\\n\\t\\t\\t    minLen = Math.min(minLen, end - start + 1);\\n\\t\\t\\t    localSum -= nums[start++];\\n\\t\\t    }\\n\\t    }\\n\\t    return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int minSubArrayLen(int s, int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n\\t\\t    return 0;\\n\\t    }\\n\\t    int minLen = Integer.MAX_VALUE;\\n\\t    int start = 0;\\n\\t    int localSum = 0;\\n\\t    for (int end = 0; end < nums.length; end++) {\\n\\t\\t    localSum += nums[end];\\n\\t\\t    while (localSum >= s) {\\n\\t\\t\\t    minLen = Math.min(minLen, end - start + 1);\\n\\t\\t\\t    localSum -= nums[start++];\\n\\t\\t    }\\n\\t    }\\n\\t    return minLen == Integer.MAX_VALUE ? 0 : minLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 59304,
                "title": "java-ac-solution-using-two-pointers",
                "content": "Using two pointers to solve this question\\n\\n    public class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            if(nums.length == 0)return 0;       \\n            int first = 0;\\n            int second = 0;\\n            int min = nums.length+1;\\n            int sum = nums[0];\\n            while(first<nums.length && second<=first)\\n            {\\n                \\n                if(sum<s){\\n                    first++;\\n                    if(first<nums.length)\\n                    sum+= nums[first];\\n                }\\n                else {\\n                    min = Math.min(first-second+1, min);\\n                    sum-=nums[second];\\n                    second++;\\n                    \\n                }\\n            }\\n            \\n            if(min == nums.length+1)return 0;\\n            return min;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            if(nums.length == 0)return 0;       \\n            int first = 0;\\n            int second = 0;\\n            int min = nums.length+1;\\n            int sum = nums[0];\\n            while(first<nums.length && second<=first)\\n            {\\n                \\n                if(sum<s){\\n                    first++;\\n                    if(first<nums.length)\\n                    sum+= nums[first];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3725068,
                "title": "simple-solution-beginner-friendly-easy-to-understand-cjava-python-3-c-koylin-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUses a two-pointer approach to find the minimum subarray length whose sum is greater than or equal to the target value. The two pointers, l and r, represent the left and right boundaries of the subarray, respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize l, r, res (result), and s (current sum) to appropriate initial values.\\n- Iterate through the array nums using the right pointer r.\\n- Update the current sum s by adding the element at r to it.\\n- Check if the current sum s is greater than or equal to the target value. If true, proceed to the next steps. Otherwise, continue to the next iteration.\\n- Enter a while loop to shrink the subarray from the left side. Subtract the element at l from the current sum s and increment l by 1. This step is done to find the minimum length subarray.\\n- Update the result res by taking the minimum between its current value and the length of the subarray from l to r plus 1 (adding 1 because the indices are 0-based).\\n- Repeat steps 5 and 6 until the current sum s is less than the target value.\\n- After the loop ends, check if the result res is still equal to its initial value, Integer.MAX_VALUE. If true, it means no subarray was found with a sum greater than or equal to the target value, so return 0.\\n- Return the minimum length of the subarray found.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```java []\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int l=0,r=0,res=Integer.MAX_VALUE,s=0;\\n        for(r=0;r<nums.length;r++){\\n              s+=nums[r];\\n              while(s>=target){\\n                  s-=nums[l];\\n                  res = Math.min(res,r-l+1);\\n                  l++;\\n              }\\n        }\\n        if(res==Integer.MAX_VALUE)\\n        return 0;\\n        return res;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n         int l = 0, r = 0, res = std::numeric_limits<int>::max(), s = 0;\\n        for (r = 0; r < nums.size(); r++) {\\n            s += nums[r];\\n            while (s >= target) {\\n                s -= nums[l];\\n                res = std::min(res, r - l + 1);\\n                l++;\\n            }\\n        }\\n        if (res == std::numeric_limits<int>::max())\\n            return 0;\\n        return res;\\n    }\\n};\\n```\\n```python3 []\\n\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        l = 0\\n        res = float(\\'inf\\')\\n        s = 0\\n        \\n        for r in range(len(nums)):\\n            s += nums[r]\\n            \\n            while s >= target:\\n                res = min(res, r - l + 1)\\n                s -= nums[l]\\n                l += 1\\n        \\n        return res if res != float(\\'inf\\') else 0\\n```\\n```Javascript []\\n/**\\n * @param {number} target\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSubArrayLen = function(target, nums) {\\n    let l = 0;\\n    let res = Infinity;\\n    let s = 0;\\n\\n    for (let r = 0; r < nums.length; r++) {\\n        s += nums[r];\\n\\n        while (s >= target) {\\n            res = Math.min(res, r - l + 1);\\n            s -= nums[l];\\n            l++;\\n        }\\n    }\\n\\n    return res !== Infinity ? res : 0;\\n};\\n```\\n```Kotlin []\\nclass Solution {\\n    fun minSubArrayLen(target: Int, nums: IntArray): Int {\\n         var l = 0\\n        var res = Int.MAX_VALUE\\n        var s = 0\\n\\n        for (r in nums.indices) {\\n            s += nums[r]\\n\\n            while (s >= target) {\\n                res = minOf(res, r - l + 1)\\n                s -= nums[l]\\n                l++\\n            }\\n        }\\n\\n        return if (res != Int.MAX_VALUE) res else 0\\n    }\\n}\\n```\\n```C# []\\npublic class Solution {\\n    public int MinSubArrayLen(int target, int[] nums) {\\n        int l = 0;\\n        int res = int.MaxValue;\\n        int s = 0;\\n\\n        for (int r = 0; r < nums.Length; r++) {\\n            s += nums[r];\\n\\n            while (s >= target) {\\n                res = Math.Min(res, r - l + 1);\\n                s -= nums[l];\\n                l++;\\n            }\\n        }\\n\\n        return res != int.MaxValue ? res : 0;\\n    }\\n}\\n```\\n```php []\\nclass Solution {\\n\\n    /**\\n     * @param Integer $target\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function minSubArrayLen($target, $nums) {\\n        $l = 0;\\n        $res = PHP_INT_MAX;\\n        $s = 0;\\n\\n        for ($r = 0; $r < count($nums); $r++) {\\n            $s += $nums[$r];\\n\\n            while ($s >= $target) {\\n                $res = min($res, $r - $l + 1);\\n                $s -= $nums[$l];\\n                $l++;\\n            }\\n        }\\n\\n        return $res != PHP_INT_MAX ? $res : 0;\\n    }\\n}\\n```\\n```c []\\nint minSubArrayLen(int target, int* nums, int numsSize) {\\n    int l = 0, r = 0, res = INT_MAX, s = 0;\\n    for (r = 0; r < numsSize; r++) {\\n        s += nums[r];\\n        while (s >= target) {\\n            s -= nums[l];\\n            res = (res < r - l + 1) ? res : r - l + 1;\\n            l++;\\n        }\\n    }\\n    if (res == INT_MAX)\\n        return 0;\\n    return res;\\n}\\n```\\n```TypeScript []\\nfunction minSubArrayLen(target: number, nums: number[]): number {\\n let l = 0;\\n    let res = Infinity;\\n    let s = 0;\\n\\n    for (let r = 0; r < nums.length; r++) {\\n        s += nums[r];\\n\\n        while (s >= target) {\\n            res = Math.min(res, r - l + 1);\\n            s -= nums[l];\\n            l++;\\n        }\\n    }\\n\\n    return res !== Infinity ? res : 0;\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "Kotlin"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int l=0,r=0,res=Integer.MAX_VALUE,s=0;\\n        for(r=0;r<nums.length;r++){\\n              s+=nums[r];\\n              while(s>=target){\\n                  s-=nums[l];\\n                  res = Math.min(res,r-l+1);\\n                  l++;\\n              }\\n        }\\n        if(res==Integer.MAX_VALUE)\\n        return 0;\\n        return res;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n         int l = 0, r = 0, res = std::numeric_limits<int>::max(), s = 0;\\n        for (r = 0; r < nums.size(); r++) {\\n            s += nums[r];\\n            while (s >= target) {\\n                s -= nums[l];\\n                res = std::min(res, r - l + 1);\\n                l++;\\n            }\\n        }\\n        if (res == std::numeric_limits<int>::max())\\n            return 0;\\n        return res;\\n    }\\n};\\n```\n```python3 []\\n\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        l = 0\\n        res = float(\\'inf\\')\\n        s = 0\\n        \\n        for r in range(len(nums)):\\n            s += nums[r]\\n            \\n            while s >= target:\\n                res = min(res, r - l + 1)\\n                s -= nums[l]\\n                l += 1\\n        \\n        return res if res != float(\\'inf\\') else 0\\n```\n```Javascript []\\n/**\\n * @param {number} target\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSubArrayLen = function(target, nums) {\\n    let l = 0;\\n    let res = Infinity;\\n    let s = 0;\\n\\n    for (let r = 0; r < nums.length; r++) {\\n        s += nums[r];\\n\\n        while (s >= target) {\\n            res = Math.min(res, r - l + 1);\\n            s -= nums[l];\\n            l++;\\n        }\\n    }\\n\\n    return res !== Infinity ? res : 0;\\n};\\n```\n```Kotlin []\\nclass Solution {\\n    fun minSubArrayLen(target: Int, nums: IntArray): Int {\\n         var l = 0\\n        var res = Int.MAX_VALUE\\n        var s = 0\\n\\n        for (r in nums.indices) {\\n            s += nums[r]\\n\\n            while (s >= target) {\\n                res = minOf(res, r - l + 1)\\n                s -= nums[l]\\n                l++\\n            }\\n        }\\n\\n        return if (res != Int.MAX_VALUE) res else 0\\n    }\\n}\\n```\n```C# []\\npublic class Solution {\\n    public int MinSubArrayLen(int target, int[] nums) {\\n        int l = 0;\\n        int res = int.MaxValue;\\n        int s = 0;\\n\\n        for (int r = 0; r < nums.Length; r++) {\\n            s += nums[r];\\n\\n            while (s >= target) {\\n                res = Math.Min(res, r - l + 1);\\n                s -= nums[l];\\n                l++;\\n            }\\n        }\\n\\n        return res != int.MaxValue ? res : 0;\\n    }\\n}\\n```\n```php []\\nclass Solution {\\n\\n    /**\\n     * @param Integer $target\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function minSubArrayLen($target, $nums) {\\n        $l = 0;\\n        $res = PHP_INT_MAX;\\n        $s = 0;\\n\\n        for ($r = 0; $r < count($nums); $r++) {\\n            $s += $nums[$r];\\n\\n            while ($s >= $target) {\\n                $res = min($res, $r - $l + 1);\\n                $s -= $nums[$l];\\n                $l++;\\n            }\\n        }\\n\\n        return $res != PHP_INT_MAX ? $res : 0;\\n    }\\n}\\n```\n```c []\\nint minSubArrayLen(int target, int* nums, int numsSize) {\\n    int l = 0, r = 0, res = INT_MAX, s = 0;\\n    for (r = 0; r < numsSize; r++) {\\n        s += nums[r];\\n        while (s >= target) {\\n            s -= nums[l];\\n            res = (res < r - l + 1) ? res : r - l + 1;\\n            l++;\\n        }\\n    }\\n    if (res == INT_MAX)\\n        return 0;\\n    return res;\\n}\\n```\n```TypeScript []\\nfunction minSubArrayLen(target: number, nums: number[]): number {\\n let l = 0;\\n    let res = Infinity;\\n    let s = 0;\\n\\n    for (let r = 0; r < nums.length; r++) {\\n        s += nums[r];\\n\\n        while (s >= target) {\\n            res = Math.min(res, r - l + 1);\\n            s -= nums[l];\\n            l++;\\n        }\\n    }\\n\\n    return res !== Infinity ? res : 0;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724579,
                "title": "python-3-9-lines-sliding-window-t-m-100-100",
                "content": "Here\\'s how the code works:\\n\\n1. We check an edge case. If the `sum(nums)` is less than `target`, then there is no subarray that satisfies the condition, so we return 0.\\n\\n2. We initialize three variables: `s` for keeping track of the current sum, `l` as the left index of the sliding window, and `ans` to update the minimal length of the subarray during the iteration.\\n\\n1. We iterate over`nums` to move the right ptr, and use the inner `while` loopto update`s`, `l`, and`ans` as necessary.\\n\\n1. We return`ans`, which represents the length of the subarray whose sum is greater than or equal to`target`.\\n\\n\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: list[int]) -> int:\\n\\n        if sum(nums) < target: return 0               # <-- 1\\n\\n        s, l, ans = 0, 0, len(nums)                   # <-- 2\\n        \\n        for r,val in enumerate(nums):                 # \\n            s+= val                                   #\\n            while s >= target:                        # <-- 3\\n                s-= nums[l]                           #\\n                ans = min(ans, r - l + 1)             #\\n                l+= 1                                 #\\n\\n        return ans                                    # <-- 4\\n```\\n[https://leetcode.com/problems/minimum-size-subarray-sum/submissions/603708786/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: list[int]) -> int:\\n\\n        if sum(nums) < target: return 0               # <-- 1\\n\\n        s, l, ans = 0, 0, len(nums)                   # <-- 2\\n        \\n        for r,val in enumerate(nums):                 # \\n            s+= val                                   #\\n            while s >= target:                        # <-- 3\\n                s-= nums[l]                           #\\n                ans = min(ans, r - l + 1)             #\\n                l+= 1                                 #\\n\\n        return ans                                    # <-- 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138534,
                "title": "c-clean-and-concise-code-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int start=0,end=0,n=nums.size(),sum=0;\\n        int ans=n+1;\\n        while(end<n)\\n        {\\n            sum+=nums[end++];\\n              while(sum>=target)\\n              {\\n                  ans=min(end-start,ans);\\n                  sum-=nums[start++];\\n              }\\n        }\\n        if(ans==n+1) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int start=0,end=0,n=nums.size(),sum=0;\\n        int ans=n+1;\\n        while(end<n)\\n        {\\n            sum+=nums[end++];\\n              while(sum>=target)\\n              {\\n                  ans=min(end-start,ans);\\n                  sum-=nums[start++];\\n              }\\n        }\\n        if(ans==n+1) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254759,
                "title": "python-brute-force-sliding-window",
                "content": "# Approaches\\n## Problem #209 Minimum Size Subarray Sum\\n### I will be covering the following approaches \\n\\n- 1. Brute Force\\n- 2. Sliding Window\\n\\n\\n## Approach 1. Brute Force(TLE)\\n\\n### Intuition\\nThe primary concept here is that we  can just generate all of the subarrays and see of those who equal target, have the smallest length. Its a very basic algorithm but also very slow. I think covering the brute force can be important for defining some bigger steps of our algorithm however so we will still cover it. \\n\\n#### Breakdown Of Algorithm\\n1. Check for our edgecases and possible O(1) solutions to the problem. (Reusable for Sliding Window Approach)\\n2.  Define our variables that we will use to count the smallest window\\n3.  Our Brute force that uses double for loops to generate the sum of all subarrays\\n4.  return minimum if valid else return 0\\n```python\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        if nums == None or len(nums) == 0:\\n            return 0\\n        if nums[0] >= target:\\n            return 1\\n\\n        minimum = float(\"inf\")\\n        for i in range(len(nums)):\\n            subarray_sum = 0\\n            for j in range(i,len(nums)):\\n                subarray_sum += nums[j]\\n                if j - i < minimum and subarray_sum == target:\\n                    minimum = j - i + 1\\n                \\n        if minimum == float(\"inf\"):\\n            return 0\\n        else:\\n            return minimum\\n\\n```\\n\\n\\n## Approach 2. Sliding Window\\n\\n### Intuition\\n\\nThe idea here is that we can take two pointers and create a window, and keep track of the sum of that window. We also want to find which of these windows is the smallest that is also equal to our target number.\\n\\n#### Breakdown of algorithm\\n\\n1. Check for edgecases like if we have an empty array or arent provided one\\n2. Declare all of our pointers (start, end, window_sum, minimum)\\n3. Iterate through list while our start pointer hasn\\'t reached the end\\n3a. check to see if our window sum is less than our target sum. If it is we want to increase our window sum and move forward our end pointer\\n3b. inner while loop that moves forward our start pointer while our window_sum is greater than or equal to target. We want to check if our current window is smaller than our minimum each iteration and move forward our start pointer\\n\\n4. We now will have looped through the entire array. Lets check to make sure we found a valid window. If we did return the smallest window. Else return 0\\n\\n```python\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        if nums == None or len(nums) == 0:\\n            return 0\\n        if nums[0] >= target:\\n            return 1\\n        \\n        start = 0\\n        end = 0 \\n        window_sum = 0\\n        minimum = 10 ** 10000\\n        \\n        while end < len(nums):\\n            if window_sum < target:\\n                window_sum += nums[end]\\n                end += 1\\n            while window_sum >= target:\\n                if end - start < minimum:\\n                    minimum = end - start\\n                window_sum -= nums[start]\\n                start += 1\\n                \\n        if minimum == 10 ** 10000:\\n            return 0\\n        else:\\n            return minimum\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        if nums == None or len(nums) == 0:\\n            return 0\\n        if nums[0] >= target:\\n            return 1\\n\\n        minimum = float(\"inf\")\\n        for i in range(len(nums)):\\n            subarray_sum = 0\\n            for j in range(i,len(nums)):\\n                subarray_sum += nums[j]\\n                if j - i < minimum and subarray_sum == target:\\n                    minimum = j - i + 1\\n                \\n        if minimum == float(\"inf\"):\\n            return 0\\n        else:\\n            return minimum\\n\\n```\n```python\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        if nums == None or len(nums) == 0:\\n            return 0\\n        if nums[0] >= target:\\n            return 1\\n        \\n        start = 0\\n        end = 0 \\n        window_sum = 0\\n        minimum = 10 ** 10000\\n        \\n        while end < len(nums):\\n            if window_sum < target:\\n                window_sum += nums[end]\\n                end += 1\\n            while window_sum >= target:\\n                if end - start < minimum:\\n                    minimum = end - start\\n                window_sum -= nums[start]\\n                start += 1\\n                \\n        if minimum == 10 ** 10000:\\n            return 0\\n        else:\\n            return minimum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59225,
                "title": "290-ms-super-simple-java-solution",
                "content": "    public class Solution {\\n        \\n        public int minSubArrayLen(int targetSum, int[] nums) {\\n            int minLength = Integer.MAX_VALUE;\\n            \\n            int left=0, right=0;\\n            int slidingSum = 0;\\n            int n = nums.length;\\n            \\n            while(right < n) {\\n                if(slidingSum  + nums[right] < targetSum) {\\n                    slidingSum += nums[right];\\n                    right += 1;\\n                } else {\\n                    minLength = Math.min(minLength, right - left + 1);\\n                    slidingSum -= nums[left];\\n                    left += 1;\\n                }\\n            }\\n            \\n            return minLength == Integer.MAX_VALUE ? 0 : minLength;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        public int minSubArrayLen(int targetSum, int[] nums) {\\n            int minLength = Integer.MAX_VALUE;\\n            \\n            int left=0, right=0;\\n            int slidingSum = 0;\\n            int n = nums.length;\\n            \\n            while(right < n) {\\n                if(slidingSum  + nums[right] < targetSum) {\\n                    slidingSum += nums[right];\\n                    right += 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3724657,
                "title": "mastering-sliding-window-technique-a-comprehensive-guide",
                "content": "**The sliding window technique** is a problem-solving technique that is used to \\n\\n**1.Running Average:** Use a sliding window to efficiently calculate the average of a fixed-size window as new elements arrive in a stream of data.\\n\\n**2.Formulating Adjacent Pairs:** Sliding windows are useful when you need to process adjacent pairs of elements in an ordered data structure, allowing you to easily access and operate on neighboring elements.\\n\\n**3.Target Value Identification:** When you want to find a specific target value or combination of values in an array, a sliding window can help by adjusting the window size and efficiently searching for the desired value or subarrays that meet specific criteria.\\n\\n**4.Longest/Shortest/Most Optimal Sequence:** Sliding windows are handy when you need to find the longest, shortest, or most optimal sequence that satisfies a given condition in a collection. By sliding a window through the collection and tracking relevant information within it, you can identify the desired sequence more efficiently than scanning the entire collection.\\n\\nThe main idea behind the sliding window technique is to convert **two nested loops into a single loop**. Usually, the technique helps us to reduce the time complexity from **O(n\\xB2) or O(n\\xB3) to O(n)**.\\nThis is done by **maintaining a sliding window**, which is a **subarray of the original array** that is of a fixed size. The algorithm then iterates over the original array, updating the sliding window as it goes. This allows the algorithm to keep track of a contiguous sequence of elements in the original array, **without having to iterate over the entire array multiple times.**\\n\\n\\n **Both fixed and variable window sliding window problems** can use the techniques of hashing, two pointers, and sliding window optimization.\\n**a.Hashing** is a common technique for tracking the elements in a sliding window. This is because a hash table can quickly and efficiently look up the presence of an element in the window.\\n**b.Two pointers is another common technique** for tracking the elements in a sliding window. This is because two pointers can easily track the start and end of the window.\\n**c.Sliding window optimization** is a technique that combines hashing and two pointers to improve the performance of the sliding window algorithm. This is done by using hashing to quickly look up the presence of an element in the window, and using two pointers to track the start and end of the window.\\n**The choice of technique for solving a sliding window problem depends on the specific problem and the constraints of the problem.** For example, if the sliding window is small, then hashing may be a good choice. However, if the sliding window is large, then two pointers may be a better choice.\\n\\n**Lets discuss How to identify Fixed and variable size Window**\\n\\n**1.Fixed Window:**\\n\\nIn a fixed window problem, **we have a predefined window size that remains constant** throughout the problem-solving process.\\nThe template for solving a fixed window problem involves maintaining two pointers, **low and high, that represent the indices of the current window.**\\nThe process involves iterating over the array or sequence, adjusting the window as necessary, and performing computations or operations on the elements within the window.\\nHere\\'s the template\\n```\\nfixed_window()\\n{\\n    int low = 0, high = 0, windowsize = k;\\n    while (i < sizeofarray)\\n    {\\n        // Step 1: Create a window that is one element smaller than the desired window size\\n        if (high - low + 1 < windowsize)\\n        {\\n            // Generate the window by increasing the high index\\n            high++;\\n        }\\n        // Step 2: Process the window\\n        else\\n        {\\n            // Window size is now equal to the desired window size\\n            // Step 2a: Calculate the answer based on the elements in the window\\n            // Step 2b: Remove the oldest element (at low index) from the window for the next window\\n\\n            // Proceed to the next window by incrementing the low and high indices\\n        }\\n    }\\n}\\n```\\n\\n# Example on above Format \\n**Q->Given an array arr[] and an integer K, the task is to calculate the sum of \\nall subarrays of size K.**\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n, k;\\n    cin >> n >> k;\\n\\n    // Input array\\n    vector<int> v(n, 0);\\n    for (int i = 0; i < n; i++)\\n        cin >> v[i];\\n\\n    int i = 0, j = 0; // Window indices\\n    int sum = 0; // Current window sum\\n\\n    while (j < n)\\n    {\\n        if (j - i + 1 < k)\\n        {\\n            // Expand the window by adding element at index j to the sum\\n            sum += v[j];\\n            j++;\\n        }\\n        else\\n        {\\n            // Window size is now equal to the desired window size\\n            // Calculate the answer for the window\\n            sum += v[j];\\n            cout << sum << endl;\\n\\n            // Move the window by incrementing indices i and j\\n            sum -= v[i];\\n            i++, j++;\\n        }\\n    }\\n}\\n```\\n\\n**2 variable window**\\n\\nIn a variable window problem,**the window size is not fixed and can change dynamically based on certain conditions or criteria**. The template for solving a variable window problem involves maintaining two pointers, start and end, which represent the indices of the current window.\\n\\nInitialize the window indices: Start by initializing the start and end pointers to the first element of the sequence or array.\\n\\n**Expand the window:** Check a condition to determine whether to expand the window. If the condition is satisfied, increment the end pointer to expand the window size.\\n\\n**Process the window:** Once the window size meets the desired criteria or condition, perform the required computations or operations on the elements within the window.\\n\\n**Adjust the window size:** If the window size exceeds the desired criteria, adjust the window by moving the start pointer. Iterate or loop until the window size matches the desired criteria, and update the window accordingly.\\n\\n```\\nvariable_window()\\n{\\n    int start = 0, end = 0;\\n    while (end < n)\\n    {\\n        // Perform calculations or operations within the window\\n\\n        /* Case 1: Expand the window\\n           If the window size is less than the desired value (k), increase the end index\\n        */\\n        if (end - start + 1 < k)\\n        {\\n            end++;\\n        }\\n\\n        /* Case 2: Window of desired size\\n           If the window size is equal to the desired value (k), process the window and calculate the answer\\n        */\\n        else if (end - start + 1 == k)\\n        {\\n            // Perform the required calculations or operations to obtain the answer\\n            // Store the answer in a variable (ans)\\n\\n            end++;\\n        }\\n\\n        /* Case 3: Reduce the window size\\n           If the window size is greater than the desired value (k), adjust the window by moving the start index\\n        */\\n        else if (end - start + 1 > k)\\n        {\\n            while (end - start + 1 > k)\\n            {\\n                // Remove calculations or operations involving the element at the start index\\n\\n                start++;\\n            }\\n\\n            // Check if the window size becomes equal to the desired value (k) after adjustment\\n            if (end - start + 1 == k)\\n            {\\n                // Perform calculations or operations and store the answer if necessary\\n            }\\n\\n            end++;\\n        }\\n    }\\n\\n    // Return the final answer (ans)\\n}\\n```\\n# Eg on Above format \\n**1. [longest-substring-without-repeating-characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)**\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n        int i = 0, j = 0, ans = 0;\\n        map<char, int> m; // Map to track characters in the current window\\n\\n        while (j < s.size()) {\\n            m[s[j]]++; // Add current character to the map\\n            int windowSize = j - i + 1; // Calculate the current window size\\n\\n            if (m.size() == windowSize) {\\n                ans = max(ans, windowSize); // Update the maximum length of the substring\\n                j++; // Expand the window by moving the end pointer\\n            }\\n            else {\\n                while (m.size() < windowSize) {\\n                    m[s[i]]--; // Remove characters from the start of the window\\n                    if (m[s[i]] == 0)\\n                        m.erase(s[i]);\\n                    i++; // Move the start pointer to adjust the window\\n                    windowSize = j - i + 1; // Update the window size\\n                }\\n\\n                if (m.size() == windowSize) {\\n                    ans = max(ans, windowSize); // Update the maximum length of the substring\\n                }\\n\\n                j++; // Expand the window by moving the end pointer\\n            }\\n        }\\n\\n        return ans; // Return the length of the longest substring\\n    }\\n};\\n\\n```\\n**Sol of minSubArrayLen**\\n\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n        int sum=0,i=0,j=0,res=INT_MAX,n=nums.size();\\n        while(i<n)\\n        {\\n            sum+=nums[i];\\n            // Expand window\\n            if(sum<target)i++;\\n            // cal ans\\n            else if(sum==target)\\n            {\\n                res=min(res,i-j+1);\\n                i++;\\n            }\\n            // compress window\\n            else\\n            {\\n                while(sum>=target)\\n                {\\n                    sum-=nums[j];\\n                    res=min(res,i-j+1);\\n                    j++;\\n                }\\n                i++;\\n            }  \\n        }\\n        if(res==INT_MAX)return 0;\\n        return res;\\n    }\\n};\\n```\\n\\n\\n**Questions On Fixed window size**\\n1. [Substrings-of-size-three-with-distinct-characters](https://leetcode.com/problems/substrings-of-size-three-with-distinct-characters/description/)\\n2. [Substring-with-concatenation-of-all-words](https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/)\\n3. [Maximum-number-of-vowels-in-a-substring-of-given-length](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)\\n4. [Maximum-number-of-occurrences-of-a-substrin](https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/description/)\\n5. [Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)\\n6. [Maximum Points You Can Obtain from Cards](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/description/)\\n7. [Find-all-anagrams-in-a-string](https://leetcode.com/problems/find-all-anagrams-in-a-string/description/)\\n8. [K Radius Subarray Averages](https://leetcode.com/problems/k-radius-subarray-averages/description/)\\n9. [Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold](https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/solutions/1772628/Java-or-Sliding-Window-template-or-Explained/)\\n\\n**Questions On  variable window size**\\n\\n1. [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)\\n2. [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/description/)\\n3. [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/description/)\\n4. [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/description/)\\n 5. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/)\\n6. [Minimum Consecutive Cards to Pick Up](https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/)\\n7. [Maximum Erasure Value](https://leetcode.com/problems/maximum-erasure-value/description/)\\n 8. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/description/)\\n9. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/description/)\\n10. [Arithmetic Slices](https://leetcode.com/problems/arithmetic-slices/description/)\\n11. [Subarrays-with-k-different-integers](https://leetcode.com/problems/subarrays-with-k-different-integers/description/)\\n\\n\\n**If you want to master Two pointer Must do  these patterns**\\n# 1. Running from both ends of an array\\n    a. 2 Sum problem \\n\\tb. Trapping Water \\n\\tc. Next Permutation \\n\\td. Reversing / Swapping \\n\\tf. Others\\n# 2. Slow & Fast Pointers\\n    a.Linked List Operations\\n\\tb.Cyclic Detection\\n\\tc.Sliding Window/Caterpillar Method\\n\\td.Rotation\\n\\te.Remove Duplicate\\n# 3. Running from beginning of 2 arrays / Merging 2 arrays\\n    a. Sorted arrays\\n    b. Intersections/LCA like\\n    c. Meet-in-the-middle / Binary Search\\n    d. Median Finder\\n    e. SubString\\n# 4. Split & Merge of an array / Divide & Conquer\\n      a. Partition\\n\\t  b. Sorting\\nThese are standard Two pointer pattern  discussed above :-> You can follow his article\\n**[All-Type of-two-pointers-problems-Link](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days)**\\n\\n\\n\\n\\n**My Other post:**\\nIf you stuck in bits I must say follow this \\n**a.[All-types-of-patterns-for-bits-manipulations-and-how-to-use-it](https://leetcode.com/discuss/interview-question/3695233/all-types-of-patterns-for-bits-manipulations-and-how-to-use-it)**\\n 27 questions that are **exact similar to the classic Two Sum problem** , with slight variations.\\n**b. [27-variations-of-two-sum-question](https://leetcode.com/discuss/interview-question/3685049/25-variations-of-two-sum-question)**\\n\\n\\n**If you found it helpful, please upvote. If you have any questions or comments, please feel free to leave them below. I\\'d love to hear your thoughts.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfixed_window()\\n{\\n    int low = 0, high = 0, windowsize = k;\\n    while (i < sizeofarray)\\n    {\\n        // Step 1: Create a window that is one element smaller than the desired window size\\n        if (high - low + 1 < windowsize)\\n        {\\n            // Generate the window by increasing the high index\\n            high++;\\n        }\\n        // Step 2: Process the window\\n        else\\n        {\\n            // Window size is now equal to the desired window size\\n            // Step 2a: Calculate the answer based on the elements in the window\\n            // Step 2b: Remove the oldest element (at low index) from the window for the next window\\n\\n            // Proceed to the next window by incrementing the low and high indices\\n        }\\n    }\\n}\\n```\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n, k;\\n    cin >> n >> k;\\n\\n    // Input array\\n    vector<int> v(n, 0);\\n    for (int i = 0; i < n; i++)\\n        cin >> v[i];\\n\\n    int i = 0, j = 0; // Window indices\\n    int sum = 0; // Current window sum\\n\\n    while (j < n)\\n    {\\n        if (j - i + 1 < k)\\n        {\\n            // Expand the window by adding element at index j to the sum\\n            sum += v[j];\\n            j++;\\n        }\\n        else\\n        {\\n            // Window size is now equal to the desired window size\\n            // Calculate the answer for the window\\n            sum += v[j];\\n            cout << sum << endl;\\n\\n            // Move the window by incrementing indices i and j\\n            sum -= v[i];\\n            i++, j++;\\n        }\\n    }\\n}\\n```\n```\\nvariable_window()\\n{\\n    int start = 0, end = 0;\\n    while (end < n)\\n    {\\n        // Perform calculations or operations within the window\\n\\n        /* Case 1: Expand the window\\n           If the window size is less than the desired value (k), increase the end index\\n        */\\n        if (end - start + 1 < k)\\n        {\\n            end++;\\n        }\\n\\n        /* Case 2: Window of desired size\\n           If the window size is equal to the desired value (k), process the window and calculate the answer\\n        */\\n        else if (end - start + 1 == k)\\n        {\\n            // Perform the required calculations or operations to obtain the answer\\n            // Store the answer in a variable (ans)\\n\\n            end++;\\n        }\\n\\n        /* Case 3: Reduce the window size\\n           If the window size is greater than the desired value (k), adjust the window by moving the start index\\n        */\\n        else if (end - start + 1 > k)\\n        {\\n            while (end - start + 1 > k)\\n            {\\n                // Remove calculations or operations involving the element at the start index\\n\\n                start++;\\n            }\\n\\n            // Check if the window size becomes equal to the desired value (k) after adjustment\\n            if (end - start + 1 == k)\\n            {\\n                // Perform calculations or operations and store the answer if necessary\\n            }\\n\\n            end++;\\n        }\\n    }\\n\\n    // Return the final answer (ans)\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n        int i = 0, j = 0, ans = 0;\\n        map<char, int> m; // Map to track characters in the current window\\n\\n        while (j < s.size()) {\\n            m[s[j]]++; // Add current character to the map\\n            int windowSize = j - i + 1; // Calculate the current window size\\n\\n            if (m.size() == windowSize) {\\n                ans = max(ans, windowSize); // Update the maximum length of the substring\\n                j++; // Expand the window by moving the end pointer\\n            }\\n            else {\\n                while (m.size() < windowSize) {\\n                    m[s[i]]--; // Remove characters from the start of the window\\n                    if (m[s[i]] == 0)\\n                        m.erase(s[i]);\\n                    i++; // Move the start pointer to adjust the window\\n                    windowSize = j - i + 1; // Update the window size\\n                }\\n\\n                if (m.size() == windowSize) {\\n                    ans = max(ans, windowSize); // Update the maximum length of the substring\\n                }\\n\\n                j++; // Expand the window by moving the end pointer\\n            }\\n        }\\n\\n        return ans; // Return the length of the longest substring\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n        int sum=0,i=0,j=0,res=INT_MAX,n=nums.size();\\n        while(i<n)\\n        {\\n            sum+=nums[i];\\n            // Expand window\\n            if(sum<target)i++;\\n            // cal ans\\n            else if(sum==target)\\n            {\\n                res=min(res,i-j+1);\\n                i++;\\n            }\\n            // compress window\\n            else\\n            {\\n                while(sum>=target)\\n                {\\n                    sum-=nums[j];\\n                    res=min(res,i-j+1);\\n                    j++;\\n                }\\n                i++;\\n            }  \\n        }\\n        if(res==INT_MAX)return 0;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3724624,
                "title": "c-o-n-2-pointer-sliding-window",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& a) {\\n        int n=a.size();\\n\\t\\t\\n        int i,j,sum, minlen=n+1;\\n        i=j=sum=0;\\n\\t\\t\\n        while(j<n){\\n            sum+=a[j]; // acquiring rear element\\n\\t\\t\\t\\n            while(i<=j && sum>=target){\\n                minlen = min(minlen,j-i+1);\\n                sum-=a[i]; // releasing front element\\n                i++;\\n            }\\n\\t\\t\\t\\n            j++;\\n        }\\n        \\n        return (minlen==n+1 ? 0:minlen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& a) {\\n        int n=a.size();\\n\\t\\t\\n        int i,j,sum, minlen=n+1;\\n        i=j=sum=0;\\n\\t\\t\\n        while(j<n){\\n            sum+=a[j]; // acquiring rear element\\n\\t\\t\\t\\n            while(i<=j && sum>=target){\\n                minlen = min(minlen,j-i+1);\\n                sum-=a[i]; // releasing front element\\n                i++;\\n            }\\n\\t\\t\\t\\n            j++;\\n        }\\n        \\n        return (minlen==n+1 ? 0:minlen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348029,
                "title": "python-easy-sliding-window-with-explanation",
                "content": "**Upvote for a cookie**\\n\\n---\\nWe create a sliding window of the current subarray, checking if its sum is greater than the target:\\n- If it is, we calculate the new minSubArrayLen and push the left boundary of the window\\n- If it is not, we push the right boundary of the window\\nWe continue this process until we\\'ve checked all numbers in nums as the left starting index\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target, nums):\\n\\t\\t# Init left pointer and answer\\n        l, ans = 0, len(nums) + 1\\n\\t\\t# Init sum of subarray\\n        s = 0 \\n\\t\\t# Iterate through all numbers as right subarray \\n        for r in range(len(nums)):\\n\\t\\t\\t# Add right number to sum\\n            s += nums[r]\\n\\t\\t\\t# Check for subarray greater than or equal to target\\n            while s >= target:\\n\\t\\t\\t\\t# Calculate new min\\n                ans = min(ans, r - l + 1)\\n\\t\\t\\t\\t# Remove current left nubmer from sum\\n                s -= nums[l]\\n\\t\\t\\t\\t# Move left index up one\\n                l += 1\\n\\t\\t# No solution\\n        if ans == len(nums) + 1:\\n            return 0\\n\\t\\t# Solution\\n        return ans \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target, nums):\\n\\t\\t# Init left pointer and answer\\n        l, ans = 0, len(nums) + 1\\n\\t\\t# Init sum of subarray\\n        s = 0 \\n\\t\\t# Iterate through all numbers as right subarray \\n        for r in range(len(nums)):\\n\\t\\t\\t# Add right number to sum\\n            s += nums[r]\\n\\t\\t\\t# Check for subarray greater than or equal to target\\n            while s >= target:\\n\\t\\t\\t\\t# Calculate new min\\n                ans = min(ans, r - l + 1)\\n\\t\\t\\t\\t# Remove current left nubmer from sum\\n                s -= nums[l]\\n\\t\\t\\t\\t# Move left index up one\\n                l += 1\\n\\t\\t# No solution\\n        if ans == len(nums) + 1:\\n            return 0\\n\\t\\t# Solution\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774062,
                "title": "python-explanation-of-sliding-window-using-comments",
                "content": "Hope this helps someone\\n\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        \\n        left = 0 # keep track of left pointer\\n        rsum = 0 # keep the running sum\\n        res = None # Answer we will return\\n        \\n        # Iterate through the array, the index will be your right pointer\\n        for right in range(len(nums)):\\n            \\n            # Add the current value to the running sum\\n            rsum += nums[right]\\n            \\n            # Once you reach a value at or equal to the target you\\n            # can use a while loop to start subtracting the values from left\\n            # to right so that you can produce the minimum size subarray\\n            while rsum >= target:\\n                \\n                # The result is either the current result you have, \\n                # or the count of numbers from the current left position \\n                # to the rightmost position. You need it to be right + 1 \\n                # because index starts at 0 (if you based the right as the \\n                # last index it would be 4 or len(nums) - 1)\\n                \\n                # If res is None we compare it against the max float, \\n                # saves us from having an if/else\\n                res = min(res or float(\\'inf\\'), right + 1 - left)\\n                \\n                # Subtract the number to see if we can continue subtracting based\\n                # on the while loop case and increment the left pointer\\n                rsum -= nums[left]\\n                left += 1\\n\\n        return res or 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        \\n        left = 0 # keep track of left pointer\\n        rsum = 0 # keep the running sum\\n        res = None # Answer we will return\\n        \\n        # Iterate through the array, the index will be your right pointer\\n        for right in range(len(nums)):\\n            \\n            # Add the current value to the running sum\\n            rsum += nums[right]\\n            \\n            # Once you reach a value at or equal to the target you\\n            # can use a while loop to start subtracting the values from left\\n            # to right so that you can produce the minimum size subarray\\n            while rsum >= target:\\n                \\n                # The result is either the current result you have, \\n                # or the count of numbers from the current left position \\n                # to the rightmost position. You need it to be right + 1 \\n                # because index starts at 0 (if you based the right as the \\n                # last index it would be 4 or len(nums) - 1)\\n                \\n                # If res is None we compare it against the max float, \\n                # saves us from having an if/else\\n                res = min(res or float(\\'inf\\'), right + 1 - left)\\n                \\n                # Subtract the number to see if we can continue subtracting based\\n                # on the while loop case and increment the left pointer\\n                rsum -= nums[left]\\n                left += 1\\n\\n        return res or 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59294,
                "title": "python-3-different-ac-solutions",
                "content": "Two pointers:\\n\\n    def minSubArrayLen(self, s, nums):\\n        if not nums:\\n            return 0\\n        l = len(nums)\\n        if not l:\\n            return 0\\n        sum = 0\\n        i = 0\\n        j = 0\\n        res = l + 1\\n        while sum < s:\\n            sum += nums[j]\\n            j += 1\\n            while sum >= s:\\n                if j - i < res:\\n                    res = j - i\\n                sum -= nums[i]\\n                i += 1\\n            if j == l:\\n                break\\n        if res > l:\\n            return 0\\n        return res\\n\\nPrecalculated sums saved at the same list:\\n\\n    def minSubArrayLen(self, s, nums):\\n        sm = sum(nums)\\n        if sm < s:\\n            return 0\\n        l = len(nums)\\n        for i in xrange(l):\\n            nums[i], sm = sm, sm - nums[i]\\n        res = l\\n        nums.append(0)\\n        for i in xrange(l - 1, -1, -1):\\n            if nums[i] >= s:\\n                b = min(l, i + res - 1)\\n                while nums[i] - nums[b] >= s:\\n                    res = b - i\\n                    b -= 1\\n        return res\\n\\nUsing binary search:\\n\\n    def minSubArrayLen(self, s, nums):\\n        sm = sum(nums)\\n        if sm < s:\\n            return 0\\n        l = len(nums)\\n        for i in xrange(l):\\n            nums[i], sm = sm, sm - nums[i]\\n        res = l\\n        nums.append(0)\\n        for i in xrange(l - 1, -1, -1):\\n            e = min(l, i + res - 1)\\n            while nums[i] - nums[e] >= s:\\n                if res > e - i:\\n                    res = e - i\\n                b = (i + e) / 2\\n                while nums[i] - nums[b] < s and b < e - 1:\\n                    b = (b + e) / 2\\n                if b == e:\\n                    break\\n                e = b\\n        return res\\n\\nThe running time for all three solutions is between 45 - 65 ms.",
                "solutionTags": [
                    "Python"
                ],
                "code": "Two pointers:\\n\\n    def minSubArrayLen(self, s, nums):\\n        if not nums:\\n            return 0\\n        l = len(nums)\\n        if not l:\\n            return 0\\n        sum = 0\\n        i = 0\\n        j = 0\\n        res = l + 1\\n        while sum < s:\\n            sum += nums[j]\\n            j += 1\\n            while sum >= s:\\n                if j - i < res:\\n                    res = j - i\\n                sum -= nums[i]\\n                i += 1\\n            if j == l:\\n                break\\n        if res > l:\\n            return 0\\n        return res\\n\\nPrecalculated sums saved at the same list:\\n\\n    def minSubArrayLen(self, s, nums):\\n        sm = sum(nums)\\n        if sm < s:\\n            return 0\\n        l = len(nums)\\n        for i in xrange(l):\\n            nums[i], sm = sm, sm - nums[i]\\n        res = l\\n        nums.append(0)\\n        for i in xrange(l - 1, -1, -1):\\n            if nums[i] >= s:\\n                b = min(l, i + res - 1)\\n                while nums[i] - nums[b] >= s:\\n                    res = b - i\\n                    b -= 1\\n        return res\\n\\nUsing binary search:\\n\\n    def minSubArrayLen(self, s, nums):\\n        sm = sum(nums)\\n        if sm < s:\\n            return 0\\n        l = len(nums)\\n        for i in xrange(l):\\n            nums[i], sm = sm, sm - nums[i]\\n        res = l\\n        nums.append(0)\\n        for i in xrange(l - 1, -1, -1):\\n            e = min(l, i + res - 1)\\n            while nums[i] - nums[e] >= s:\\n                if res > e - i:\\n                    res = e - i\\n                b = (i + e) / 2\\n                while nums[i] - nums[b] < s and b < e - 1:\\n                    b = (b + e) / 2\\n                if b == e:\\n                    break\\n                e = b\\n        return res\\n\\nThe running time for all three solutions is between 45 - 65 ms.",
                "codeTag": "Python3"
            },
            {
                "id": 3728554,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int ans=nums.length+1,j=0,sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum=sum+nums[i];\\n            if(sum>=target)\\n            {\\n                while(sum>=target)\\n                {\\n                    sum-=nums[j++];\\n                }\\n                ans=Math.min(ans,i-j+2);\\n            }\\n        }\\n        return ans == nums.length+1 ? 0 : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int ans=nums.length+1,j=0,sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum=sum+nums[i];\\n            if(sum>=target)\\n            {\\n                while(sum>=target)\\n                {\\n                    sum-=nums[j++];\\n                }\\n                ans=Math.min(ans,i-j+2);\\n            }\\n        }\\n        return ans == nums.length+1 ? 0 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725466,
                "title": "c-sliding-window-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int mx=INT_MAX,current=0;\\n        int i=0,j=0;\\n        while(j<nums.size()){\\n            current += nums[j];\\n                while(current>=target){\\n                    mx = min(mx,j-i+1);\\n                    current -= nums[i];\\n                    i++;\\n                }\\n            j++;\\n        }\\n        if(mx==INT_MAX)return 0;\\n        else return mx;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/72c0e110-ed9f-4d8f-988b-49d552dceeda_1688622694.982345.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int mx=INT_MAX,current=0;\\n        int i=0,j=0;\\n        while(j<nums.size()){\\n            current += nums[j];\\n                while(current>=target){\\n                    mx = min(mx,j-i+1);\\n                    current -= nums[i];\\n                    i++;\\n                }\\n            j++;\\n        }\\n        if(mx==INT_MAX)return 0;\\n        else return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725961,
                "title": "classic-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        s, e, sm = 0, 0, 0\\n        ans = math.inf\\n        for e in range(len(nums)):\\n            sm += nums[e]\\n            while sm >= target:\\n                ans = min(ans, e-s+1)\\n                sm -= nums[s]\\n                s += 1\\n\\n        return ans if ans != math.inf else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        s, e, sm = 0, 0, 0\\n        ans = math.inf\\n        for e in range(len(nums)):\\n            sm += nums[e]\\n            while sm >= target:\\n                ans = min(ans, e-s+1)\\n                sm -= nums[s]\\n                s += 1\\n\\n        return ans if ans != math.inf else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724839,
                "title": "java-100-faster-1ms-sliding-window-easy-solution",
                "content": "# Java Sliding Window Easy Solution\\n![image](https://assets.leetcode.com/users/images/714ec869-4c30-4290-8f00-e2b50c4c9cc4_1688613147.6794262.jpeg)\\n\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int ans = nums.length+1;\\n        int sum = 0;\\n        int st = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            while(sum >= target && st <= i){\\n                ans = Math.min(ans , i - st + 1);\\n                sum -= nums[st++];\\n            }  \\n        }\\n        return ans==nums.length+1?0:ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int ans = nums.length+1;\\n        int sum = 0;\\n        int st = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            while(sum >= target && st <= i){\\n                ans = Math.min(ans , i - st + 1);\\n                sum -= nums[st++];\\n            }  \\n        }\\n        return ans==nums.length+1?0:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356490,
                "title": "simple-java-1ms-beats-100-easy-to-understand-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# ***simple sliding window approach***\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n         int start = 0,  end = 0,  sum = 0,  minLength = Integer.MAX_VALUE;\\n         if (nums == null || nums.length == 0)\\n        return 0;\\n  \\n  while (end < nums.length) {\\n    sum += nums[end];\\n    end++;\\n    while (sum >= target) {\\n      minLength = Math.min(minLength, end - start);\\n      sum -= nums[start];\\n      start++;\\n    }\\n  }\\n  if(minLength == Integer.MAX_VALUE) \\n  return 0 ;\\n  return minLength;\\n    }\\n}\\n```\\n# ****If this solution helped you, give it an up-vote to help others![download.jfif](https://assets.leetcode.com/users/images/1a6c9ae6-4772-4a79-901b-aca9177b8ffe_1680110476.0519047.jpeg)****\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n         int start = 0,  end = 0,  sum = 0,  minLength = Integer.MAX_VALUE;\\n         if (nums == null || nums.length == 0)\\n        return 0;\\n  \\n  while (end < nums.length) {\\n    sum += nums[end];\\n    end++;\\n    while (sum >= target) {\\n      minLength = Math.min(minLength, end - start);\\n      sum -= nums[start];\\n      start++;\\n    }\\n  }\\n  if(minLength == Integer.MAX_VALUE) \\n  return 0 ;\\n  return minLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983464,
                "title": "simple-binary-search-on-answer-and-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo if u clearly see despite of not having a sorted array we can do binary search on answer becuase our answer can lie between 1 and n otherwise that will not be a subarray present. So do binary search from  1 to n and check for each mid if it will give us subarray having sum target and continue decreasing it by doing hi=mid-1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search On Answer and Sliding window for checker function to calculate that given mid is sufficient to give a subarray of sum k\\n# Complexity\\n- Time complexity:\\n- O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool checker(vector<int>&arr,int k,int mid){\\n        int sum=0;\\n        for(int i=0;i<mid;i++)sum+=arr[i];\\n        int l=0,r=mid;\\n        int maxi=sum;\\n        while(r<arr.size()){\\n            sum-=arr[l++];\\n            sum+=arr[r++];\\n            maxi=max(sum,maxi);\\n        }\\n        return maxi>=k;\\n    }\\n    int minSubArrayLen(int k, vector<int>& arr) {\\n          int n=arr.size();\\n         int low=1,high= n;\\n         int ans=0;\\n         while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(checker(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n         }\\n         return ans;\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool checker(vector<int>&arr,int k,int mid){\\n        int sum=0;\\n        for(int i=0;i<mid;i++)sum+=arr[i];\\n        int l=0,r=mid;\\n        int maxi=sum;\\n        while(r<arr.size()){\\n            sum-=arr[l++];\\n            sum+=arr[r++];\\n            maxi=max(sum,maxi);\\n        }\\n        return maxi>=k;\\n    }\\n    int minSubArrayLen(int k, vector<int>& arr) {\\n          int n=arr.size();\\n         int low=1,high= n;\\n         int ans=0;\\n         while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(checker(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n         }\\n         return ans;\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875287,
                "title": "c-sliding-window-o-n",
                "content": "```\\npublic class Solution {\\n    public int MinSubArrayLen(int target, int[] nums) {\\n        int result = int.MaxValue, runningSum = 0, left = 0;\\n        for (var right = 0; right < nums.Length; right++){\\n            runningSum += nums[right];\\n            while (runningSum >= target) {\\n                result = Math.Min(result, right-left+1);\\n                runningSum -= nums[left];\\n                left++;\\n            }\\n        }\\n        return result == int.MaxValue ? 0 : result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSubArrayLen(int target, int[] nums) {\\n        int result = int.MaxValue, runningSum = 0, left = 0;\\n        for (var right = 0; right < nums.Length; right++){\\n            runningSum += nums[right];\\n            while (runningSum >= target) {\\n                result = Math.Min(result, right-left+1);\\n                runningSum -= nums[left];\\n                left++;\\n            }\\n        }\\n        return result == int.MaxValue ? 0 : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325418,
                "title": "simple-c-solution-o-nlogn-binary-search",
                "content": "Uses binary search to find the length of the subarray.\\nCheck is used to find the maximum sum of the subarray of given length.\\n**Please up vote( if useful )**\\n```\\nclass Solution {\\npublic:\\n  int check(std::vector<int> nums, int len)\\n  {\\n    int ma = 0;\\n    int start = 0;\\n    int end = start + len - 1;\\n    for (int i = start; i <= end; ++i)\\n    {\\n      ma += nums[i];\\n    }\\n    int sum = ma;\\n    while (end < nums.size())\\n    {\\n      end++;\\n      if (end >= nums.size())\\n        break;\\n      sum -= nums[start++];\\n      sum += nums[end];\\n      ma = max(ma, sum);\\n    }\\n    return ma;\\n  }\\n  int minSubArrayLen(int s, vector<int>& nums) {\\n    int mi = 1;\\n    int ma = nums.size();\\n    int res = nums.size() + 1;\\n    // debug(check(nums, 2));\\n    while (mi <= ma)\\n    {\\n      int mid_size = (mi + ma) / 2;\\n      int sum = check(nums, mid_size);\\n      if (sum >= s)\\n      {\\n        ma = mid_size - 1;\\n        res = min(res, mid_size);\\n      }\\n      else\\n        mi = mid_size + 1;\\n    }\\n    return (res == nums.size() + 1) ? 0 : res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int check(std::vector<int> nums, int len)\\n  {\\n    int ma = 0;\\n    int start = 0;\\n    int end = start + len - 1;\\n    for (int i = start; i <= end; ++i)\\n    {\\n      ma += nums[i];\\n    }\\n    int sum = ma;\\n    while (end < nums.size())\\n    {\\n      end++;\\n      if (end >= nums.size())\\n        break;\\n      sum -= nums[start++];\\n      sum += nums[end];\\n      ma = max(ma, sum);\\n    }\\n    return ma;\\n  }\\n  int minSubArrayLen(int s, vector<int>& nums) {\\n    int mi = 1;\\n    int ma = nums.size();\\n    int res = nums.size() + 1;\\n    // debug(check(nums, 2));\\n    while (mi <= ma)\\n    {\\n      int mid_size = (mi + ma) / 2;\\n      int sum = check(nums, mid_size);\\n      if (sum >= s)\\n      {\\n        ma = mid_size - 1;\\n        res = min(res, mid_size);\\n      }\\n      else\\n        mi = mid_size + 1;\\n    }\\n    return (res == nums.size() + 1) ? 0 : res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006949,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        left = total = 0\\n        res = len(nums) + 1\\n        for i in range(len(nums)):\\n            total = total + nums[i]\\n            while total >= s:\\n                res = min(res,i-left+1)\\n                total = total - nums[left]\\n                left = left+1\\n        return res if res <= len(nums) else 0\\n```\\n\\nWe just need to move the left pointer; till the time we have total reduced to s (The expected Total)\\nIf the left pointer is reduced, then we have to reduce the count of elements as well.\\n\\n\\n#### Runtime: 64 ms, faster than 97.50% of Python3 online submissions for Minimum Size Subarray Sum.\\n#### Memory Usage: 16.7 MB, less than 43.64% of Python3 online submissions for Minimum Size Subarray Sum.",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        left = total = 0\\n        res = len(nums) + 1\\n        for i in range(len(nums)):\\n            total = total + nums[i]\\n            while total >= s:\\n                res = min(res,i-left+1)\\n                total = total - nums[left]\\n                left = left+1\\n        return res if res <= len(nums) else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59182,
                "title": "simple-javascript-solution",
                "content": "    function minSubArrayLen(s, nums) {\\n        var min = Number.MAX_VALUE;\\n        \\n        // boundaries\\n        var l = 0;\\n        var r = -1;\\n        \\n        // current sum\\n        var sum = 0;\\n        \\n        while (r < nums.length) {\\n            if (sum >= s) {\\n                min = Math.min(min, r - l + 1);\\n                sum -= nums[l];\\n                l++;\\n            } else {\\n                r++;\\n                sum += nums[r];\\n            }\\n        }\\n        \\n        return min === Number.MAX_VALUE ? 0 : min;\\n    }",
                "solutionTags": [],
                "code": "    function minSubArrayLen(s, nums) {\\n        var min = Number.MAX_VALUE;\\n        \\n        // boundaries\\n        var l = 0;\\n        var r = -1;\\n        \\n        // current sum\\n        var sum = 0;\\n        \\n        while (r < nums.length) {\\n            if (sum >= s) {\\n                min = Math.min(min, r - l + 1);\\n                sum -= nums[l];\\n                l++;\\n            } else {\\n                r++;\\n                sum += nums[r];\\n            }\\n        }\\n        \\n        return min === Number.MAX_VALUE ? 0 : min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2625891,
                "title": "c-95-faster-99-space-sliding-window",
                "content": "[**209. Minimum Size Subarray Sum**](https://leetcode.com/problems/minimum-size-subarray-sum/)\\n\\n**`Time Complexity : O(n)`**\\n**`Space Complexity : O(1)`**\\n\\n```\\nint minSubArrayLen(int target, vector<int>& nums) {\\n        int i=0, j=0, sum=0, ans=nums.size()+1;\\n        while(j<nums.size()){\\n            sum+=nums[j++];\\n            while(sum>=target){\\n                ans=min(ans, j-i);\\n                sum-=nums[i++];\\n            }\\n        }\\n        return ans%(nums.size()+1);\\n    }\\n```\\n***Happy Coding :)***\\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```\\n![image](https://assets.leetcode.com/users/images/23bda89e-bf70-4d42-9a23-79aa629c3023_1664180019.0811465.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minSubArrayLen(int target, vector<int>& nums) {\\n        int i=0, j=0, sum=0, ans=nums.size()+1;\\n        while(j<nums.size()){\\n            sum+=nums[j++];\\n            while(sum>=target){\\n                ans=min(ans, j-i);\\n                sum-=nums[i++];\\n            }\\n        }\\n        return ans%(nums.size()+1);\\n    }\\n```\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1779829,
                "title": "c-easiest-sliding-window-solution",
                "content": "```\\n    int minSubArrayLen(int target, vector<int>& arr) {\\n        int ans = INT_MAX, i = 0, j = 0, n = arr.size(), sum = 0;\\n        while(j < n){\\n            sum += arr[j];\\n            while(sum >= target){\\n                ans = min(ans, (j-i)+1);\\n                sum -= arr[i++];\\n            }\\n            j++;\\n        }\\n        if(ans > n+1) return 0;\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    int minSubArrayLen(int target, vector<int>& arr) {\\n        int ans = INT_MAX, i = 0, j = 0, n = arr.size(), sum = 0;\\n        while(j < n){\\n            sum += arr[j];\\n            while(sum >= target){\\n                ans = min(ans, (j-i)+1);\\n                sum -= arr[i++];\\n            }\\n            j++;\\n        }\\n        if(ans > n+1) return 0;\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538414,
                "title": "sliding-window-approach-easy-to-understand-in-c",
                "content": "class Solution {\\npublic:\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0,s=0;\\n        int res=INT_MAX;\\n        while(j<n)\\n        {\\n            s=s+nums[j];\\n            if(s<target)\\n                j++;      \\n           else\\n            {\\n                while(s>=target)\\n                {\\n                    res=min(res,j-i+1);\\n                    s=s-nums[i];\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        if(res==INT_MAX){\\n            return 0;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0,s=0;\\n        int res=INT_MAX;\\n        while(j<n)\\n        {\\n            s=s+nums[j];\\n            if(s<target)\\n                j++;      \\n           else\\n            {\\n                while(s>=target)\\n                {\\n                    res=min(res,j-i+1);\\n                    s=s-nums[i];\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1251226,
                "title": "javascript-solution-binary-search-approach",
                "content": "I thought it would be interesting to try to do the binary search approach.\\n\\n```\\nvar minSubArrayLen = function(target, nums) {\\n    const MAX = Number.MAX_SAFE_INTEGER;\\n    const n = nums.length;\\n     \\n    let min = MAX;\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (i > 0) nums[i] += nums[i - 1];\\n        if (nums[i] < target) continue; // if the total we have so far is less than target, then we continue\\n         \\n        const closest_index = binarySearch(0, i, nums[i]);\\n             \\n        min = Math.min(min, i - closest_index + 1);\\n    }\\n    \\n    return min == MAX ? 0 : min;\\n    \\n\\n    function binarySearch(left, right, tot_so_far) {\\n        while (left <= right) {\\n            const mid = left + Math.floor((right - left) / 2);\\n            \\n            const diff = tot_so_far - nums[mid];\\n            \\n            // If diff equals target, we cannot try to further decrease the size of the subarray since\\n            // any diff value obtained afterwards will be less than target\\n            if (diff === target) return mid + 1;\\n            \\n            if (diff > target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n    \\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar minSubArrayLen = function(target, nums) {\\n    const MAX = Number.MAX_SAFE_INTEGER;\\n    const n = nums.length;\\n     \\n    let min = MAX;\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (i > 0) nums[i] += nums[i - 1];\\n        if (nums[i] < target) continue; // if the total we have so far is less than target, then we continue\\n         \\n        const closest_index = binarySearch(0, i, nums[i]);\\n             \\n        min = Math.min(min, i - closest_index + 1);\\n    }\\n    \\n    return min == MAX ? 0 : min;\\n    \\n\\n    function binarySearch(left, right, tot_so_far) {\\n        while (left <= right) {\\n            const mid = left + Math.floor((right - left) / 2);\\n            \\n            const diff = tot_so_far - nums[mid];\\n            \\n            // If diff equals target, we cannot try to further decrease the size of the subarray since\\n            // any diff value obtained afterwards will be less than target\\n            if (diff === target) return mid + 1;\\n            \\n            if (diff > target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n    \\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480984,
                "title": "javascript-solution-sliding-window",
                "content": "### The idea\\n1. Set two pointers `left` and `right`, where `right - left + 1` will be the length of valid subarray\\n2. Keep expanding `right` pointer, when the condition is met `sum >= s`, start shrinking `left` to find the minimum length of subarray\\n``` javascript\\n/**\\n * @param {number} s\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSubArrayLen = function(s, nums) {\\n    if (nums.length==0) return 0;\\n    let left = 0, right = 0, sum = 0, min = Infinity;\\n    while (right != nums.length) {\\n        sum+=nums[right];\\n        \\n        while (sum >= s) {\\n            min = Math.min(min, right - left + 1);\\n            sum-=nums[left];\\n            left++;\\n        }\\n\\n        right++;\\n    }\\n    if (min == Infinity) return 0;\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number} s\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSubArrayLen = function(s, nums) {\\n    if (nums.length==0) return 0;\\n    let left = 0, right = 0, sum = 0, min = Infinity;\\n    while (right != nums.length) {\\n        sum+=nums[right];\\n        \\n        while (sum >= s) {\\n            min = Math.min(min, right - left + 1);\\n            sum-=nums[left];\\n            left++;\\n        }\\n\\n        right++;\\n    }\\n    if (min == Infinity) return 0;\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325170,
                "title": "python-sliding-window-o-n-solution-99-71",
                "content": "```\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        windowSum, windowStart = 0,0\\n        minLength = math.inf\\n        for windowEnd in range(len(nums)):\\n            windowSum+=nums[windowEnd]\\n            while windowSum >= s:\\n                minLength = min(minLength, windowEnd - windowStart + 1)\\n                windowSum -= nums[windowStart]\\n                windowStart+=1\\n        if minLength == math.inf:\\n            return 0\\n        return minLength\\n                \\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        windowSum, windowStart = 0,0\\n        minLength = math.inf\\n        for windowEnd in range(len(nums)):\\n            windowSum+=nums[windowEnd]\\n            while windowSum >= s:\\n                minLength = min(minLength, windowEnd - windowStart + 1)\\n                windowSum -= nums[windowStart]\\n                windowStart+=1\\n        if minLength == math.inf:\\n            return 0\\n        return minLength\\n                \\n",
                "codeTag": "Python3"
            },
            {
                "id": 203547,
                "title": "wrong-test-case",
                "content": "The test case fails for non contiguous subarray :\\n\\nInput:\\n11\\n[1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3\\nMy observation:\\n2,4,5 are not contiguous subarrays.\\nHere is my code:\\n\\n```\\ndef minSubArrayLen(self, s, nums):\\n        \"\"\"\\n        :type s: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        sum = 0 \\n        map = {}\\n        minlen = sys.maxsize\\n        if len(nums) < 1:\\n            return 0\\n        for i,e in enumerate(nums):\\n            sum += e\\n            if sum == s:\\n                minlen = i+1\\n            if sum not in map:\\n                map[sum] = i\\n            if sum-s in map:\\n                if minlen > i-map[sum-s]:\\n                    minlen = i-map[sum-s]\\n            print map\\n        if minlen == sys.maxsize:\\n            return 0\\n        else:\\n            return minlen\\n```",
                "solutionTags": [],
                "code": "```\\ndef minSubArrayLen(self, s, nums):\\n        \"\"\"\\n        :type s: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        sum = 0 \\n        map = {}\\n        minlen = sys.maxsize\\n        if len(nums) < 1:\\n            return 0\\n        for i,e in enumerate(nums):\\n            sum += e\\n            if sum == s:\\n                minlen = i+1\\n            if sum not in map:\\n                map[sum] = i\\n            if sum-s in map:\\n                if minlen > i-map[sum-s]:\\n                    minlen = i-map[sum-s]\\n            print map\\n        if minlen == sys.maxsize:\\n            return 0\\n        else:\\n            return minlen\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 59166,
                "title": "6-liner-in-python-o-n",
                "content": "```\\nclass Solution(object):\\n    def minSubArrayLen(self, k, nums):\\n        count, i, j, n, res = 0, 0, 0, len(nums), float('inf')\\n        for j in range(len(nums)):\\n            count += nums[j]\\n            while i <= j and count >= k:\\n                res, count, i = min(res, j - i + 1),\\\\\\n                                count - nums[i],\\\\\\n                                i + 1\\n        return res if res < float('inf') else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSubArrayLen(self, k, nums):\\n        count, i, j, n, res = 0, 0, 0, len(nums), float('inf')\\n        for j in range(len(nums)):\\n            count += nums[j]\\n            while i <= j and count >= k:\\n                res, count, i = min(res, j - i + 1),\\\\\\n                                count - nums[i],\\\\\\n                                i + 1\\n        return res if res < float('inf') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59242,
                "title": "10-line-c-o-n-solution",
                "content": "Just the windowing technique.\\n\\n    class Solution {\\n    public:\\n        int minSubArrayLen(int s, vector<int>& nums) {\\n            int sum=0,front=0,back=0,res=INT_MAX;\\n            while(front<nums.size()||sum>=s) {\\n                if(sum<s&&front<nums.size())\\n                    sum+=nums[front++];\\n                if(sum>=s) {\\n                    res=min(res,front-back);\\n                    sum-=nums[back++];\\n                }\\n            } \\n            return res==INT_MAX?0:res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minSubArrayLen(int s, vector<int>& nums) {\\n            int sum=0,front=0,back=0,res=INT_MAX;\\n            while(front<nums.size()||sum>=s) {\\n                if(sum<s&&front<nums.size())\\n                    sum+=nums[front++];\\n                if(sum>=s) {\\n                    res=min(res,front-back);\\n                    sum-=nums[back++];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3728082,
                "title": "python-java-c-easy-solution-with-explanation-time-complexity-o-n",
                "content": "# Approach\\nTo solve this problem, we can use the two-pointer technique. We\\'ll maintain two pointers, left and right, which define the current subarray under consideration. Initially, both pointers will point to the start of the array.\\n\\nHere\\'s the step-by-step algorithm for the solution:\\n\\n1. Initialize the left and right pointers to 0 and set the sum variable to 0.\\n2. Iterate the right pointer over the array, moving it one step at a time, until it reaches the end of the array.\\n3. Add `nums[right]` to the sum.\\n4. Check if the sum is greater than or equal to the target. If so, calculate the current subarray length as ``` right - left + 1 ``` and update the min_length if it\\'s smaller than the previous min_length.\\n5. If the sum is greater than or equal to the target, move the left pointer one step to the right and subtract nums[left] from the sum.\\n6. Repeat steps 3-5 until the right pointer reaches the end of the array.\\n7. After the loop, if min_length is still the initial value (indicating no valid subarray was found), return 0. Otherwise, return min_length.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Video Explanation\\nhttps://youtu.be/wKkDyEnRr2M\\n# Code\\n```python []\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        left,right = 0,0\\n        sumWindow = 0\\n        res = float(\\'inf\\')\\n\\n        for right in range(len(nums)):\\n            sumWindow += nums[right]\\n\\n            while sumWindow >= target:\\n                res = min(res, right-left+1)\\n                sumWindow -= nums[left]\\n                left += 1\\n        return res if res != float(\\'inf\\') else 0\\n```\\n```java []\\npublic int minSubArrayLen(int target, int[] nums) {\\n    int left = 0;\\n    int sum = 0;\\n    int minLength = Integer.MAX_VALUE;\\n    \\n    for (int right = 0; right < nums.length; right++) {\\n        sum += nums[right];\\n        \\n        while (sum >= target) {\\n            minLength = Math.min(minLength, right - left + 1);\\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n    \\n    return minLength != Integer.MAX_VALUE ? minLength : 0;\\n}\\n\\n```\\n```cpp []\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int left = 0;\\n    int sum = 0;\\n    int minLength = INT_MAX;\\n    \\n    for (int right = 0; right < nums.size(); right++) {\\n        sum += nums[right];\\n        \\n        while (sum >= target) {\\n            minLength = min(minLength, right - left + 1);\\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n    \\n    return minLength != INT_MAX ? minLength : 0;\\n}\\n\\n```\\n\\n#### An upvote would be really appreciated \\uD83D\\uDC4D\\uD83C\\uDFFB\\uD83D\\uDE00",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "``` right - left + 1 ```\n```python []\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        left,right = 0,0\\n        sumWindow = 0\\n        res = float(\\'inf\\')\\n\\n        for right in range(len(nums)):\\n            sumWindow += nums[right]\\n\\n            while sumWindow >= target:\\n                res = min(res, right-left+1)\\n                sumWindow -= nums[left]\\n                left += 1\\n        return res if res != float(\\'inf\\') else 0\\n```\n```java []\\npublic int minSubArrayLen(int target, int[] nums) {\\n    int left = 0;\\n    int sum = 0;\\n    int minLength = Integer.MAX_VALUE;\\n    \\n    for (int right = 0; right < nums.length; right++) {\\n        sum += nums[right];\\n        \\n        while (sum >= target) {\\n            minLength = Math.min(minLength, right - left + 1);\\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n    \\n    return minLength != Integer.MAX_VALUE ? minLength : 0;\\n}\\n\\n```\n```cpp []\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int left = 0;\\n    int sum = 0;\\n    int minLength = INT_MAX;\\n    \\n    for (int right = 0; right < nums.size(); right++) {\\n        sum += nums[right];\\n        \\n        while (sum >= target) {\\n            minLength = min(minLength, right - left + 1);\\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n    \\n    return minLength != INT_MAX ? minLength : 0;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727109,
                "title": "beats-100-java-python-c-1-ms",
                "content": "Simple Sliding window Technique : \\n---\\n```java []\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] arr) {\\n        int n = arr.length;\\n        int low = 0;\\n        int high = 0;\\n        int sum = 0;\\n        int result = Integer.MAX_VALUE;\\n        for(high = 0;high<n;high++)\\n        {\\n            sum+=arr[high];\\n            while(sum >= target)\\n            {\\n                sum-=arr[low];\\n                result = Math.min(result,high-low+1);\\n                low++;\\n            }\\n        }\\n        return result == Integer.MAX_VALUE?0:result;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def minSubArrayLen(self, target, arr):\\n        n = len(arr)\\n        low = 0\\n        high = 0\\n        _sum = 0\\n        result = float(\\'inf\\')\\n        while high < n:\\n            _sum += arr[high]\\n            while _sum >= target:\\n                result = min(result, high - low + 1)\\n                _sum -= arr[low]\\n                low += 1\\n            high += 1\\n        return 0 if result == float(\\'inf\\') else result\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& arr) {\\n        int n = arr.size();\\n        int low = 0;\\n        int high = 0;\\n        int _sum = 0;\\n        int result = INT_MAX;\\n        while (high < n) {\\n            _sum += arr[high];\\n            while (_sum >= target) {\\n                result = min(result, high - low + 1);\\n                _sum -= arr[low];\\n                low++;\\n            }\\n            high++;\\n        }\\n        return result == INT_MAX ? 0 : result;\\n    }\\n};\\n\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\uD83D\\uDD25\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] arr) {\\n        int n = arr.length;\\n        int low = 0;\\n        int high = 0;\\n        int sum = 0;\\n        int result = Integer.MAX_VALUE;\\n        for(high = 0;high<n;high++)\\n        {\\n            sum+=arr[high];\\n            while(sum >= target)\\n            {\\n                sum-=arr[low];\\n                result = Math.min(result,high-low+1);\\n                low++;\\n            }\\n        }\\n        return result == Integer.MAX_VALUE?0:result;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def minSubArrayLen(self, target, arr):\\n        n = len(arr)\\n        low = 0\\n        high = 0\\n        _sum = 0\\n        result = float(\\'inf\\')\\n        while high < n:\\n            _sum += arr[high]\\n            while _sum >= target:\\n                result = min(result, high - low + 1)\\n                _sum -= arr[low]\\n                low += 1\\n            high += 1\\n        return 0 if result == float(\\'inf\\') else result\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& arr) {\\n        int n = arr.size();\\n        int low = 0;\\n        int high = 0;\\n        int _sum = 0;\\n        int result = INT_MAX;\\n        while (high < n) {\\n            _sum += arr[high];\\n            while (_sum >= target) {\\n                result = min(result, high - low + 1);\\n                _sum -= arr[low];\\n                low++;\\n            }\\n            high++;\\n        }\\n        return result == INT_MAX ? 0 : result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725982,
                "title": "ordinary-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        res, curSum, l = len(nums)+1, 0, 0\\n        \\n        for r, n in enumerate(nums):\\n            curSum += n\\n            while curSum >= target and l <= r:\\n                res = min(res, r-l+1)\\n                curSum -= nums[l]\\n                l += 1\\n\\n        return res%(len(nums)+1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        res, curSum, l = len(nums)+1, 0, 0\\n        \\n        for r, n in enumerate(nums):\\n            curSum += n\\n            while curSum >= target and l <= r:\\n                res = min(res, r-l+1)\\n                curSum -= nums[l]\\n                l += 1\\n\\n        return res%(len(nums)+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724782,
                "title": "c-sliding-window-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon analyzing the problem, my initial thoughts on solving it involve utilizing a sliding window approach. Here\\'s a step-by-step outline of my approach:\\n\\n1. Initialize two pointers, `left` and `right`, to track the current subarray window. Set them both to 0 initially.\\n2. Initialize variables `sum` to keep track of the sum of elements within the current window and `minLen` to store the minimum length of subarrays found so far. Set `sum` to 0 and `minLen` to a value that represents infinity (e.g., INT_MAX).\\n3. Start a loop that iterates while the `right` pointer is within the array bounds.\\n4. Inside the loop, add the element at the `right` index to the `sum` and increment the `right` pointer.\\n5. Check if the `sum` is greater than or equal to the given target value `s`. If it is, move the `left` pointer towards the right until the sum is no longer greater than or equal to `s`. At each step, update the `minLen` if a shorter subarray is found.\\n6. Repeat steps 4-5 until the `right` pointer reaches the end of the array.\\n7. After the loop, check if a valid subarray was found (i.e., `minLen` is still the initial value of infinity). If it is, return 0 to indicate that no such subarray exists. Otherwise, return `minLen` as the minimum length of a subarray with a sum greater than or equal to `s`.\\n\\nBy using the sliding window technique and updating the `sum` and `minLen` variables appropriately, this approach should be able to find the minimum length of a subarray with a sum greater than or equal to the given target value efficiently.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->My approach to solving the problem involves using a sliding window technique. Here\\'s a step-by-step description of the approach:\\n\\n1. Initialize two pointers, `l` and `r`, to keep track of the current subarray window. Set them both to 0 initially.\\n2. Initialize variables `sum` to track the sum of elements within the current window and `len` to store the minimum length of subarrays found so far. Set `sum` to 0 and `len` to the maximum possible value (INT_MAX) to ensure it gets updated in subsequent steps.\\n3. Start a while loop that continues until the right pointer `r` reaches the end of the input array `nums`.\\n4. Inside the loop, add the current element at index `r` to the `sum` by incrementing `sum` with `nums[r]`. Then, increment `r` to move the right pointer.\\n5. Check if the `sum` is greater than or equal to the target value `s`. If it is, enter a nested while loop.\\n6. Inside the nested while loop, update the `len` variable by taking the minimum between its current value and the difference between the right and left pointers (`r - l`). This ensures that `len` always stores the minimum length found so far.\\n7. Subtract the leftmost element of the current window from the `sum` by incrementing `l` and subtracting `nums[l]` from `sum`. This step effectively moves the left pointer `l` towards the right, shrinking the window.\\n8. Repeat steps 6-7 until the `sum` is no longer greater than or equal to `s`.\\n9. After exiting the nested while loop, continue the outer while loop until the right pointer `r` reaches the end of the array.\\n10. Finally, outside the loop, check if a valid subarray was found by comparing `len` with the initial maximum value (`INT_MAX`). If `len` remains unchanged, it means no subarray with a sum greater than or equal to `s` was found. In that case, return 0. Otherwise, return `len` as the minimum length of a subarray with a sum greater than or equal to `s`.\\n\\nBy maintaining the sliding window and updating the `sum`, `len`, and the two pointers appropriately, this approach efficiently finds the minimum length of a subarray with a sum greater than or equal to the given target value `s`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        int l = 0; // left pointer\\n        int r = 0; // right pointer\\n        int n = nums.size(); // size of the input array\\n        int sum = 0; // current sum of elements\\n        int len = INT_MAX; // minimum subarray length, initialized to maximum possible value\\n\\n        while (r < n) { // iterate through the array\\n            sum += nums[r++]; // add the current element to the sum and move the right pointer\\n\\n            while (sum >= s) { // check if the sum is greater than or equal to the target value\\n                len = min(len, r - l); // update the minimum subarray length if necessary\\n\\n                sum -= nums[l++]; // subtract the leftmost element from the sum and move the left pointer\\n            }\\n        }\\n\\n        return len == INT_MAX ? 0 : len; // return 0 if no subarray is found, otherwise return the minimum subarray length\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/ea1c25c4-18dc-4ead-9e4e-b9c49e656b13_1688611696.4584267.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        int l = 0; // left pointer\\n        int r = 0; // right pointer\\n        int n = nums.size(); // size of the input array\\n        int sum = 0; // current sum of elements\\n        int len = INT_MAX; // minimum subarray length, initialized to maximum possible value\\n\\n        while (r < n) { // iterate through the array\\n            sum += nums[r++]; // add the current element to the sum and move the right pointer\\n\\n            while (sum >= s) { // check if the sum is greater than or equal to the target value\\n                len = min(len, r - l); // update the minimum subarray length if necessary\\n\\n                sum -= nums[l++]; // subtract the leftmost element from the sum and move the left pointer\\n            }\\n        }\\n\\n        return len == INT_MAX ? 0 : len; // return 0 if no subarray is found, otherwise return the minimum subarray length\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724581,
                "title": "c-elegant-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int mini = INT_MAX;\\n        int curr=0;\\n        int prev=0;\\n        for(int i = 0; i<nums.size(); i++){\\n            curr+=nums[i];\\n            while(curr>=target){\\n                mini=min(mini,i-prev+1);\\n                curr-=nums[prev];\\n                prev++;\\n            }\\n        }\\n        return mini==INT_MAX?0:mini;\\n    }\\n};\\n```\\n```\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int mini = INT_MAX;\\n        int curr=0;\\n        int prev=0;\\n        for(int i = 0; i<nums.size(); i++){\\n            curr+=nums[i];\\n            while(curr>=target){\\n                mini=min(mini,i-prev+1);\\n                curr-=nums[prev];\\n                prev++;\\n            }\\n        }\\n        return mini==INT_MAX?0:mini;\\n    }\\n};\\n```\n```\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277630,
                "title": "java-solution-1ms-runtime-beats-100-sliding-window-approach",
                "content": "**Problem Link** : https://leetcode.com/problems/minimum-size-subarray-sum/description/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to take a sliding window and keep track of sum of taken elements and count of total elements.\\nNow if the `sum` exceeds the `target` , the window size decreces by one discarding the first element of the window. \\nMeanwhile `ans` will be minimum of all the counts we will get.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int i = -1,j = 0;\\n        int sum = 0;\\n        int ans = Integer.MAX_VALUE;\\n        int c = 0;\\n        while(i < nums.length){\\n            if(sum >= target){\\n                ans = Math.min(ans,c);\\n                sum -= nums[j];\\n                j++;\\n                c--;\\n            }\\n            else{\\n                i++;\\n                if(i < nums.length){\\n                    sum+=nums[i];\\n                    c++;\\n                }\\n            }\\n        }   \\n        ans = ans == Integer.MAX_VALUE ? 0 : ans;\\n        return ans;\\n    }\\n}\\n```\\n\\n**Please Do Upvote !!**\\n\\nIf any doubts or suggestions, Please do comment !!\\n\\nThank You",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int i = -1,j = 0;\\n        int sum = 0;\\n        int ans = Integer.MAX_VALUE;\\n        int c = 0;\\n        while(i < nums.length){\\n            if(sum >= target){\\n                ans = Math.min(ans,c);\\n                sum -= nums[j];\\n                j++;\\n                c--;\\n            }\\n            else{\\n                i++;\\n                if(i < nums.length){\\n                    sum+=nums[i];\\n                    c++;\\n                }\\n            }\\n        }   \\n        ans = ans == Integer.MAX_VALUE ? 0 : ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126104,
                "title": "solution-in-java",
                "content": "PLEASE UPVOTE\\n\\n```class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n      int result=Integer.MAX_VALUE;\\n      int left=0;\\n      int sum=0;\\n      for(int i=0;i<nums.length;i++){\\n        sum+=nums[i];\\n         while(sum>=target){\\n             result=Math.min(result,i+1-left);\\n             sum-=nums[left];\\n             left++;\\n         }\\n      }\\n         return result!=Integer.MAX_VALUE? result:0;\\n      }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n      int result=Integer.MAX_VALUE;\\n      int left=0;\\n      int sum=0;\\n      for(int i=0;i<nums.length;i++){\\n        sum+=nums[i];\\n         while(sum>=target){\\n             result=Math.min(result,i+1-left);\\n             sum-=nums[left];\\n             left++;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3097857,
                "title": "clean-python-o-n-solution-using-sliding-window-with-explaination",
                "content": "**Explaination to question :**\\nIn the question statement it is clearly mentioned that  we need the length of a subarray which is minimum and has sum equal to greater than given target value.\\nIf this is not possible then return 0\\n\\n**Intuition:**\\nTo get the minimum length of the subarray we have to check all the possible subarray of the given list.\\nAnd we have to calculate the sum of each subarray individually.\\nFor the calculation of the subarray and summation it will require O(n^2) complexity.\\n\\nSo we require a optimized solution to this problem.\\nWe will apply sliding window technique,and occasionally we will increase the size of the window whenever required\\nas there is no upper bound for the size of the window so the size of the window will be variable.\\nTill now we have drawn inference \\n1. use sliding window\\n2. the window size is variable\\n\\n**Explaination and code:**\\n\\n\\n\\n```\\n\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        i=0\\n        j=0\\n        maxi=sys.maxsize\\n        sums=0\\n        n=len(nums)\\n        while(j<n):                             #iterate until j reaches to the last element of the nums list\\n            \\n            sums+=nums[j]                  #calculation of sum using elements included in window\\n\\t\\t\\twhile sums>=target:         #iterate until the value of sum is greater than target\\n                maxi=min(maxi,j-i+1)   #store the minimal value \\n                sums-=nums[i]\\n                i+=1\\n            j+=1\\n\\n        return maxi if maxi!=sys.maxsize else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        i=0\\n        j=0\\n        maxi=sys.maxsize\\n        sums=0\\n        n=len(nums)\\n        while(j<n):                             #iterate until j reaches to the last element of the nums list\\n            \\n            sums+=nums[j]                  #calculation of sum using elements included in window\\n\\t\\t\\twhile sums>=target:         #iterate until the value of sum is greater than target\\n                maxi=min(maxi,j-i+1)   #store the minimal value \\n                sums-=nums[i]\\n                i+=1\\n            j+=1\\n\\n        return maxi if maxi!=sys.maxsize else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045280,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int l=0, h=0;\\n        int s=0, ans=nums.size();\\n        for(int i:nums)\\n        s+=i;\\n        if(s<target)\\n        return 0;\\n        s=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s+=nums[i];\\n            while(s-nums[l]>=target)\\n            s-=nums[l++];\\n            if(s>=target)\\n            ans=min(ans, i-l+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int l=0, h=0;\\n        int s=0, ans=nums.size();\\n        for(int i:nums)\\n        s+=i;\\n        if(s<target)\\n        return 0;\\n        s=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s+=nums[i];\\n            while(s-nums[l]>=target)\\n            s-=nums[l++];\\n            if(s>=target)\\n            ans=min(ans, i-l+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038404,
                "title": "java-sol-with-comments",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //length of array\\n        int n=nums.length;\\n        int left=0; //left pointer\\n        int right=0; //right pointer\\n        int sum=0; //for storing the sum value\\n        int min=Integer.MAX_VALUE; //for storing the subarray size\\n        //run untill right ptr goes out of bound\\n        while(right<n)\\n        {\\n          //add the right value to sum\\n          sum+=nums[right];\\n\\n          //check if currentsum >=target\\n          if(sum>=target){ //when sum goes greater than  target compress left ptr\\n            while(sum>=target){\\n               sum-=nums[left]; \\n               left++;\\n             }\\n            min=Math.min(min,right-left+2); //right-left+2 to find the window size\\n           }\\n          right++;\\n        }\\n        return min==Integer.MAX_VALUE?0:min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //length of array\\n        int n=nums.length;\\n        int left=0; //left pointer\\n        int right=0; //right pointer\\n        int sum=0; //for storing the sum value\\n        int min=Integer.MAX_VALUE; //for storing the subarray size\\n        //run untill right ptr goes out of bound\\n        while(right<n)\\n        {\\n          //add the right value to sum\\n          sum+=nums[right];\\n\\n          //check if currentsum >=target\\n          if(sum>=target){ //when sum goes greater than  target compress left ptr\\n            while(sum>=target){\\n               sum-=nums[left]; \\n               left++;\\n             }\\n            min=Math.min(min,right-left+2); //right-left+2 to find the window size\\n           }\\n          right++;\\n        }\\n        return min==Integer.MAX_VALUE?0:min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645403,
                "title": "java-solution-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int i=0;\\n        int j=0;\\n        int sum=0;\\n\\t\\twhile(j<nums.length)\\n        {\\n            sum+=nums[j];\\n            if(sum<target)\\n            {\\n                j++;\\n            }\\n            if(sum>=target)\\n            {\\n                int win=j-i+1;\\n                if(win<min)\\n                    min=win;\\n                while(sum>target)\\n                {\\n                    sum-=nums[i];\\n                    i++;\\n                    if(sum>=target)\\n                    {\\n                        if(j-i+1<min)\\n                            min=j-i+1;\\n                    }\\n                }\\n                j++;\\n            }\\n        }\\n        return min==Integer.MAX_VALUE?0:min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int i=0;\\n        int j=0;\\n        int sum=0;\\n\\t\\twhile(j<nums.length)\\n        {\\n            sum+=nums[j];\\n            if(sum<target)\\n            {\\n                j++;\\n            }\\n            if(sum>=target)\\n            {\\n                int win=j-i+1;\\n                if(win<min)\\n                    min=win;\\n                while(sum>target)\\n                {\\n                    sum-=nums[i];\\n                    i++;\\n                    if(sum>=target)\\n                    {\\n                        if(j-i+1<min)\\n                            min=j-i+1;\\n                    }\\n                }\\n                j++;\\n            }\\n        }\\n        return min==Integer.MAX_VALUE?0:min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365459,
                "title": "java-binary-search-solution",
                "content": "just translate **jianchao-li\\'s** cpp solution to java form. Original Link : https://leetcode.com/problems/minimum-size-subarray-sum/discuss/59090/C%2B%2B-O(n)-and-O(nlogn), writen by https://leetcode.com/jianchao-li/.\\n```\\nclass Solution {\\n    public int binarySearch(int target, int beg, int end, int[] nums){\\n        //find the index of first element that is bigger than or equals target\\n        int left = beg;\\n        int right = end;\\n        while(left<right){\\n            int mid = (left+right)/2;\\n            if(nums[mid]>=target) right = mid;\\n            else left = mid +1 ;\\n        }\\n        if(right==nums.length-1&&nums[right]<target) return -1;\\n        return right;\\n        \\n    }\\n    public int minSubArrayLen(int s, int[] nums) {\\n        int n = nums.length;\\n        if(n==0) return 0;\\n        int res = Integer.MAX_VALUE;\\n        int[] sum = new int[n+1];\\n        sum[0] = 0;\\n        for(int i = 1; i<=n; i++) sum[i] = sum[i-1] + nums[i-1];\\n        for(int i = 0; i<n; i++){\\n            int target = s + sum[i];\\n            int border = binarySearch(target,0,n,sum);\\n            if(border>0) res = Math.min(res,border-i);\\n        }\\n        return (res!=Integer.MAX_VALUE?res:0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int binarySearch(int target, int beg, int end, int[] nums){\\n        //find the index of first element that is bigger than or equals target\\n        int left = beg;\\n        int right = end;\\n        while(left<right){\\n            int mid = (left+right)/2;\\n            if(nums[mid]>=target) right = mid;\\n            else left = mid +1 ;\\n        }\\n        if(right==nums.length-1&&nums[right]<target) return -1;\\n        return right;\\n        \\n    }\\n    public int minSubArrayLen(int s, int[] nums) {\\n        int n = nums.length;\\n        if(n==0) return 0;\\n        int res = Integer.MAX_VALUE;\\n        int[] sum = new int[n+1];\\n        sum[0] = 0;\\n        for(int i = 1; i<=n; i++) sum[i] = sum[i-1] + nums[i-1];\\n        for(int i = 0; i<n; i++){\\n            int target = s + sum[i];\\n            int border = binarySearch(target,0,n,sum);\\n            if(border>0) res = Math.min(res,border-i);\\n        }\\n        return (res!=Integer.MAX_VALUE?res:0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59121,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/78556/python-solution-with-detailed-explanation\\n\\n**Minimum Size Subarray Sum** https://leetcode.com/problems/minimum-size-subarray-sum/\\n\\n**Algorithm 1**\\n1. Brute force solution will test every subarray. This will be an O(N^2) solution.\\n2. Optimized solution uses the two pointer trick and gives a O(N) solution.\\n3. Initialize the two pointers to 0. Call them start and end.\\n4. Now the idea is to move the end pointer until the point we have a solution. \\n5. At this point we want to shrink the solution by moving the start pointer right.\\n6. Check the code pattern for this question. It is hard to get it bug free -- good idea to memorize the pattern\\n\\n```\\nclass Solution(object):\\n    def minSubArrayLen(self, s, nums):\\n        \"\"\"\\n        :type s: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        st, end = 0, 0\\n        min_len, sum_so_far = len(nums)+1, 0\\n        for end in range(len(nums)):\\n            sum_so_far += nums[end]\\n            while sum_so_far >= s:\\n                min_len = min(min_len, end-st+1)\\n                sum_so_far -= nums[st]\\n                st += 1\\n        return 0 if min_len == len(nums)+1 else min_len\\n\\n```\\n\\n**Algorithm 2**\\n1. N * lg(N) solution will use binary search along with traversing the entire array.\\n2. Binary search needs a sorted array. But in this problem the order matters. The problem talks about subarray sum. This gives us a hint of using cumulative array - that is sorted for positive integers.\\n3. Now the minimum subarray sum can start at index 0 to len(nums)-1. Therefore we will do a binary search from low (0 to N-1) to N-1.\\n4. Find the minimum index idx from low to high such that sum(low..idx) >=s.\\n5. Complexity is N * lg(N).\\n```\\nclass Solution(object):\\n    def minSubArrayLen(self, s, nums):\\n        \"\"\"\\n        :type s: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if nums == []:\\n            return 0\\n        cums = [nums[0]]\\n        for i in range(1, len(nums)):\\n            cums.append(cums[-1]+nums[i])\\n        if cums[-1] < s:\\n            return 0\\n        minimal_len = len(nums)\\n        for i in range(len(nums)):\\n            low, high = i, len(nums)-1\\n            while low <= high:\\n                mid = low + int((high-low)/2)\\n                sum_so_far = cums[mid]-cums[i] + nums[i]\\n                if sum_so_far >= s:\\n                    minimal_len = min(minimal_len, mid-i+1)\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n        return minimal_len\\n```\\n\\nhttps://discuss.leetcode.com/topic/13749/two-ac-solutions-in-java-with-time-complexity-of-n-and-nlogn-with-explanation",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSubArrayLen(self, s, nums):\\n        \"\"\"\\n        :type s: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        st, end = 0, 0\\n        min_len, sum_so_far = len(nums)+1, 0\\n        for end in range(len(nums)):\\n            sum_so_far += nums[end]\\n            while sum_so_far >= s:\\n                min_len = min(min_len, end-st+1)\\n                sum_so_far -= nums[st]\\n                st += 1\\n        return 0 if min_len == len(nums)+1 else min_len\\n\\n```\n```\\nclass Solution(object):\\n    def minSubArrayLen(self, s, nums):\\n        \"\"\"\\n        :type s: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if nums == []:\\n            return 0\\n        cums = [nums[0]]\\n        for i in range(1, len(nums)):\\n            cums.append(cums[-1]+nums[i])\\n        if cums[-1] < s:\\n            return 0\\n        minimal_len = len(nums)\\n        for i in range(len(nums)):\\n            low, high = i, len(nums)-1\\n            while low <= high:\\n                mid = low + int((high-low)/2)\\n                sum_so_far = cums[mid]-cums[i] + nums[i]\\n                if sum_so_far >= s:\\n                    minimal_len = min(minimal_len, mid-i+1)\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n        return minimal_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59187,
                "title": "super-simple-easy-to-understand-o-n-solution",
                "content": "    public int minSubArrayLen(int s, int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        int res = Integer.MAX_VALUE;\\n        int low = 0, high = 0;\\n        int temp = 0;\\n        boolean flag = false;\\n        while (high < nums.length) {\\n            temp += nums[high];\\n            while (temp >= s && (low <= high)) {\\n                res = Math.min(res, high - low + 1);\\n                flag = true;\\n                temp -= nums[low++];\\n            }\\n            high++;\\n        }\\n        return flag ? res : 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int minSubArrayLen(int s, int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        int res = Integer.MAX_VALUE;\\n        int low = 0, high = 0;\\n        int temp = 0;\\n        boolean flag = false;\\n        while (high < nums.length) {\\n            temp += nums[high];\\n            while (temp >= s && (low <= high)) {\\n                res = Math.min(res, high - low + 1);\\n                flag = true;\\n                temp -= nums[low++];\\n            }\\n            high++;\\n        }\\n        return flag ? res : 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 59209,
                "title": "easy-java-o-n-solution",
                "content": "    public class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            if(nums==null || nums.length<1)\\n                return 0;\\n            \\n            int start=0, end=0, sum=0, min=Integer.MAX_VALUE;\\n            \\n            while(end<nums.length){\\n                sum+=nums[end];\\n                \\n                //optimize the array\\n                while(sum>=s){\\n                    min=Math.min(min, end-start+1);\\n                    sum-=nums[start++];\\n                }\\n                end++;\\n            }\\n            return min== Integer.MAX_VALUE ? 0 : min;\\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int minSubArrayLen(int s, int[] nums) {\\n            if(nums==null || nums.length<1)\\n                return 0;\\n            \\n            int start=0, end=0, sum=0, min=Integer.MAX_VALUE;\\n            \\n            while(end<nums.length){\\n                sum+=nums[end];\\n                \\n                //optimize the array\\n                while(sum>=s){\\n                    min=Math.min(min, end-start+1);\\n                    sum-=nums[start++];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 59291,
                "title": "clear-o-n-java-solution",
                "content": "Here is a O(N) running time Java solution that uses O(1) extra space.\\n\\n    public class Solution {\\n    public int minSubArrayLen(int s, int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n\\n        int lo = 0;\\n        int hi = 0;\\n        int sum = 0;\\n\\n        int min = Integer.MAX_VALUE;\\n\\n        while (hi < nums.length) {\\n\\n            sum += nums[hi];\\n            if (sum >= s) {\\n                while (lo <= hi && sum - nums[lo] >= s) {\\n                    sum -= nums[lo];\\n                    lo++;\\n                }\\n                min = Math.min(min, hi - lo + 1);\\n            }\\n            hi++;\\n        }\\n\\n        return min != Integer.MAX_VALUE ? min : 0;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSubArrayLen(int s, int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 59293,
                "title": "c-solution-both-o-n-o-nlogn",
                "content": "O(n):\\n\\n    int minSubArrayLen(int s, int * nums, int numsSize) {\\n    \\tint sum = nums[0], head = 0, tail = 0, minL = numsSize + 1;\\n    \\twhile (tail < numsSize) {\\n    \\t\\tif (tail - head + 1 < minL && sum >= s) minL = tail - head + 1;\\n    \\t\\tif (sum >= s) sum -= nums[head++];\\n    \\t\\telse sum += nums[++tail];\\n    \\t\\tif (head > tail) tail = head;\\n    \\t}\\n    \\treturn minL == numsSize + 1 ? 0 : minL;\\n    }\\n\\nO(nLogn):\\n\\n    // \\u5728\\u4e0d\\u4e0b\\u964d\\u7684\\u5e8f\\u5217\\u4e2d\\u5bfb\\u627e\\u6070\\u597d\\u6bd4target\\u5c0f\\u7684\\u6570\\u51fa\\u73b0\\u4f4d\\u7f6e\\uff0c\\u4e5f\\u5373\\u6700\\u540e\\u4e00\\u4e2a\\u6bd4target\\u5c0f\\u7684\\u6570\\u51fa\\u73b0\\u7684\\u4f4d\\u7f6e\\n    // search a number that is exactly less than 'target', which means the last number less than 'target'\\n    int binarySearchIncreaseLastSmaller(int l, int r, int target, int * nums) {  \\n    \\tif (l >= r) return -1;\\n    \\twhile (l < r - 1) {\\n    \\t\\tint m = l + ((r - l) >> 1);\\n    \\t\\tif (nums[m] < target) l = m;\\n    \\t\\telse r = m - 1;\\n    \\t}\\n    \\tif (nums[r] < target) return r;\\n    \\telse if (nums[l] < target) return l;\\n    \\telse return -1;\\n    }\\n    \\n    int minSubArrayLen(int s, int * nums, int numsSize) {\\n    \\tint * Sum = (int*)malloc(sizeof(int) * (numsSize + 1)), minL = numsSize + 1;\\n    \\tSum[0] = 0;\\n    \\tfor (int i = 1; i <= numsSize; i++) Sum[i] = Sum[i - 1] + nums[i - 1];\\n    \\tfor (int i = 1; i <= numsSize; i++) {\\n    \\t\\tif (Sum[i] >= s) {\\n    \\t\\t\\tint k = Sum[i];\\n    \\t\\t\\tint BeforePos = binarySearchIncreaseLastSmaller(0, i, Sum[i] - s + 1, Sum);\\n    \\t\\t\\tif (BeforePos != -1 && i - BeforePos < minL) minL = i - BeforePos;\\n    \\t\\t}\\n    \\t}\\n    \\treturn minL == numsSize + 1 ? 0 : minL;\\n    }",
                "solutionTags": [],
                "code": "O(n):\\n\\n    int minSubArrayLen(int s, int * nums, int numsSize) {\\n    \\tint sum = nums[0], head = 0, tail = 0, minL = numsSize + 1;\\n    \\twhile (tail < numsSize) {\\n    \\t\\tif (tail - head + 1 < minL && sum >= s) minL = tail - head + 1;\\n    \\t\\tif (sum >= s) sum -= nums[head++];\\n    \\t\\telse sum += nums[++tail];\\n    \\t\\tif (head > tail) tail = head;\\n    \\t}\\n    \\treturn minL == numsSize + 1 ? 0 : minL;\\n    }\\n\\nO(nLogn):\\n\\n    // \\u5728\\u4e0d\\u4e0b\\u964d\\u7684\\u5e8f\\u5217\\u4e2d\\u5bfb\\u627e\\u6070\\u597d\\u6bd4target\\u5c0f\\u7684\\u6570\\u51fa\\u73b0\\u4f4d\\u7f6e\\uff0c\\u4e5f\\u5373\\u6700\\u540e\\u4e00\\u4e2a\\u6bd4target\\u5c0f\\u7684\\u6570\\u51fa\\u73b0\\u7684\\u4f4d\\u7f6e\\n    // search a number that is exactly less than 'target', which means the last number less than 'target'\\n    int binarySearchIncreaseLastSmaller(int l, int r, int target, int * nums) {  \\n    \\tif (l >= r) return -1;\\n    \\twhile (l < r - 1) {\\n    \\t\\tint m = l + ((r - l) >> 1);\\n    \\t\\tif (nums[m] < target) l = m;\\n    \\t\\telse r = m - 1;\\n    \\t}\\n    \\tif (nums[r] < target) return r;\\n    \\telse if (nums[l] < target) return l;\\n    \\telse return -1;\\n    }\\n    \\n    int minSubArrayLen(int s, int * nums, int numsSize) {\\n    \\tint * Sum = (int*)malloc(sizeof(int) * (numsSize + 1)), minL = numsSize + 1;\\n    \\tSum[0] = 0;\\n    \\tfor (int i = 1; i <= numsSize; i++) Sum[i] = Sum[i - 1] + nums[i - 1];\\n    \\tfor (int i = 1; i <= numsSize; i++) {\\n    \\t\\tif (Sum[i] >= s) {\\n    \\t\\t\\tint k = Sum[i];\\n    \\t\\t\\tint BeforePos = binarySearchIncreaseLastSmaller(0, i, Sum[i] - s + 1, Sum);\\n    \\t\\t\\tif (BeforePos != -1 && i - BeforePos < minL) minL = i - BeforePos;\\n    \\t\\t}\\n    \\t}\\n    \\treturn minL == numsSize + 1 ? 0 : minL;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 59280,
                "title": "my-c-moving-window-solution-o-n-time-o-1-space-another-binary-search-version-added-o-nlogn-time",
                "content": "1) O(n) time, O(1) space moving window method\\nusing a moving window [start,end] to calculate the sum, first move end forward to get a sub-array with sum>=s, then move start forward to make sum < s, then move end again,..., until end reach the end of array.\\n\\n\\n    class Solution {\\n    public:\\n        int minSubArrayLen(int s, vector<int>& nums) {\\n            int start=0, end=0, sum=0, len = nums.size(), res;\\n            while(end<len)\\n            {\\n                while(sum<s && end<len) sum += nums[end++];\\n                while(sum>=s) sum -=nums[start++];\\n                res = min(res, end-start + 1);\\n            }\\n            return res>len?0:res;\\n        }\\n    };\\n\\n2) O(nlogn) time, O(n) space version, binary search method\\n\\n\\n    class Solution {\\n    public:\\n        int binary_search(vector<int>&sum, int left, int target)\\n        {\\n            int right = sum.size()-1, mid;\\n            while(left<=right)\\n            {\\n                mid = (left+right)>>1;\\n                if(sum[mid]>=target) right = mid-1;\\n                else left = mid+1;\\n            }\\n            return (left<sum.size()?left:-1);\\n        }\\n        \\n        int minSubArrayLen(int s, vector<int>& nums) {\\n        int len = nums.size();\\n        vector<int> sum(len+1,0);\\n        int i, start = 0, end;\\n        int res = len+1;\\n        \\n        if(len>0)\\n        {\\n            for(i=1;i<=len;i++) sum[i] =sum[i-1] + nums[i-1];\\n            while(start<len && (end = binary_search(sum, start+1, s+sum[start]))>=0 )\\n            {\\n                res = min(res, end-start);\\n                start++;\\n            }\\n        }\\n        return res>len?0:res;",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minSubArrayLen(int s, vector<int>& nums) {\\n            int start=0, end=0, sum=0, len = nums.size(), res;\\n            while(end<len)\\n            {\\n                while(sum<s && end<len) sum += nums[end++];\\n                while(sum>=s) sum -=nums[start++];\\n                res = min(res, end-start + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3781322,
                "title": "c-sliding-window-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We use sliding window approach for solving this problem\\n- While iterating over the array we keep subtracting the num[i] till the k becomes non positive integer which means we achived our goal\\n- After attaining it we move the window forward and keep repeating till the end\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int k, vector<int>& arr) {\\n        int i = 0, n = arr.size(), ans = n+1;\\n\\n        for(int j = 0;j < n;j++){\\n            k -= arr[j];\\n            while(k <= 0){\\n                ans = min(ans, j - i + 1);\\n                k += arr[i++];\\n            } \\n        }\\n        return ans % (n+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int k, vector<int>& arr) {\\n        int i = 0, n = arr.size(), ans = n+1;\\n\\n        for(int j = 0;j < n;j++){\\n            k -= arr[j];\\n            while(k <= 0){\\n                ans = min(ans, j - i + 1);\\n                k += arr[i++];\\n            } \\n        }\\n        return ans % (n+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726879,
                "title": "easy-cpp-solution-explained-stepwise-algo-and-approach-using-sliding-window-approach",
                "content": "# Intuition\\nBy looking at contiguous and subarray, I figured out to apply Sliding Window Approach.\\n# Approach \\nThe overall approach of the code is to use a sliding window technique to find the minimum window size that satisfies the given condition. The window is expanded by adding elements to the `sum` until the sum becomes greater than or equal to the `target`. Then, the window is shrunk from the left by subtracting elements from the `sum` until the sum is no longer greater than or equal to the `target`. The process is repeated until all elements in the `nums` array are processed, and the minimum window size is obtained.\\n# Algorithm\\nSure! Here\\'s the stepwise explanation of the approach used in the given code:\\n\\n1. Initialize variables `start` and `windowSize` to track the starting index and the minimum window size, respectively. Set `start` to 0 and `windowSize` to the maximum possible value (`INT_MAX`).\\n\\n2. Initialize a variable `sum` to keep track of the current sum of elements.\\n\\n3. Iterate over the `nums` array using a for loop.\\n\\n4. Inside the loop, add the current element `nums[i]` to the `sum` variable.\\n\\n5. Check if the `sum` is greater than or equal to the `target`. If it is, enter the while loop.\\n\\n6. Inside the while loop, update the `windowSize` by taking the minimum of its current value and `i - start + 1`. This calculates the size of the current window.\\n\\n7. Subtract the value of `nums[start]` from the `sum` and increment `start` by 1. This step is to shrink the window from the left by removing the element at the `start` index.\\n\\n8. Repeat steps 5-7 until the `sum` is no longer greater than or equal to the `target`. At this point, the while loop exits, and the code continues with the next iteration of the for loop.\\n\\n9. After the for loop finishes, check if the `windowSize` is still equal to its initial value (`INT_MAX`). If it is, it means no window was found with a sum greater than or equal to the `target`, so return 0.\\n\\n10. Otherwise, return the `windowSize`, which represents the minimum window size with a sum greater than or equal to the `target`.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int start=0,windowsize=INT_MAX,sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           sum+=nums[i];\\n            while(sum>=target)\\n            {   \\n                windowsize=min(windowsize,i-start+1);\\n                sum-=nums[start++];       \\n            }          \\n        }\\n        if(windowsize==INT_MAX)return 0;\\n        return windowsize;\\n    }\\n};\\n```\\n# Please upvote and ask if you are confused!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int start=0,windowsize=INT_MAX,sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           sum+=nums[i];\\n            while(sum>=target)\\n            {   \\n                windowsize=min(windowsize,i-start+1);\\n                sum-=nums[start++];       \\n            }          \\n        }\\n        if(windowsize==INT_MAX)return 0;\\n        return windowsize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725989,
                "title": "python-beats-97",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        l=0     #declaring a left variable starting at 0\\n        ans=len(nums)+1  #setting a defult value of ans\\n        s=0     #initial sum of the subarrays\\n        for r in range(len(nums)):   #iterating the right till last\\n            s+=nums[r]   # will add the right element to the sum\\n            if s>=target:   #add to answer if target is fulfilled\\n                ans=min(ans,r-l+1)   #minimum of answer is taken\\n            while s>target:  #we will shift the right till targetnot satisfied\\n                s-=nums[l]\\n                l+=1\\n                if s>=target:\\n                    ans=min(ans,r-l+1)   #will add the target fulfilled\\n        return ans if ans<len(nums)+1 else 0\\n\\n##Upvote if you find the solution helpful\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        l=0     #declaring a left variable starting at 0\\n        ans=len(nums)+1  #setting a defult value of ans\\n        s=0     #initial sum of the subarrays\\n        for r in range(len(nums)):   #iterating the right till last\\n            s+=nums[r]   # will add the right element to the sum\\n            if s>=target:   #add to answer if target is fulfilled\\n                ans=min(ans,r-l+1)   #minimum of answer is taken\\n            while s>target:  #we will shift the right till targetnot satisfied\\n                s-=nums[l]\\n                l+=1\\n                if s>=target:\\n                    ans=min(ans,r-l+1)   #will add the target fulfilled\\n        return ans if ans<len(nums)+1 else 0\\n\\n##Upvote if you find the solution helpful\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724808,
                "title": "c-sliding-window-simple-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n\\n        int i=0;\\n        int ans = INT_MAX;\\n        int sum=0;\\n\\n        for(int j=0;j<nums.size();j++){\\n\\n             sum += nums[j];\\n             while(sum >= target && j<nums.size()){\\n\\n                 ans = min(ans,j-i+1);\\n                 sum -= nums[i];\\n                 i++;\\n             }\\n\\n        }\\n        return ans == INT_MAX ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n\\n        int i=0;\\n        int ans = INT_MAX;\\n        int sum=0;\\n\\n        for(int j=0;j<nums.size();j++){\\n\\n             sum += nums[j];\\n             while(sum >= target && j<nums.size()){\\n\\n                 ans = min(ans,j-i+1);\\n                 sum -= nums[i];\\n                 i++;\\n             }\\n\\n        }\\n        return ans == INT_MAX ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611455,
                "title": "sliding-window-approach-beats-100-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs subarray was given and a condition was given so variable size sliding window was clearly visible .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Approach is simple we will be keep adding the values until sum become>= target \\n2. when sum becomes greater than or equal , we know that now this may be the answer so we store in res and each time we get the min of that\\n3. when we got the sum > target we simply just store that res but now there may be chances that we may get even shorter answer as condition is of sum==target also , so we will remove i from sum , and each time we are updating res . \\n4. in the end if res value is still Integer.MaxValue means we dont get any value as res has not been updated so simply return 0 \\n\\nI hope this soultion finds you well , May God Bless you all and Happy Coding !!!!!!\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n- o(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int i=0;\\n        int j=0;\\n        int sum =0;\\n        int res =Integer.MAX_VALUE;\\n        while(j<nums.length)\\n        {\\n            sum=sum+nums[j];\\n            if(sum<target)\\n            {\\n                j++;\\n            }\\n            else if(sum==target)\\n            {\\n                res=Math.min(res,j-i+1);\\n                j++;\\n            }\\n            else if(sum>target)\\n            {\\n                while(sum>target)\\n                {\\n                    res=Math.min(res,j-i+1);\\n                    sum=sum-nums[i];\\n                    i++;\\n                }\\n                if(sum==target)\\n                {\\n                    res=Math.min(res,j-i+1);\\n                }\\n                j++;\\n            }\\n        }\\n        if(res==Integer.MAX_VALUE)\\n        {\\n            return 0;\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int i=0;\\n        int j=0;\\n        int sum =0;\\n        int res =Integer.MAX_VALUE;\\n        while(j<nums.length)\\n        {\\n            sum=sum+nums[j];\\n            if(sum<target)\\n            {\\n                j++;\\n            }\\n            else if(sum==target)\\n            {\\n                res=Math.min(res,j-i+1);\\n                j++;\\n            }\\n            else if(sum>target)\\n            {\\n                while(sum>target)\\n                {\\n                    res=Math.min(res,j-i+1);\\n                    sum=sum-nums[i];\\n                    i++;\\n                }\\n                if(sum==target)\\n                {\\n                    res=Math.min(res,j-i+1);\\n                }\\n                j++;\\n            }\\n        }\\n        if(res==Integer.MAX_VALUE)\\n        {\\n            return 0;\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225144,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        int l = 0, r = 0, n = nums.size(), sum = 0, len = INT_MAX;\\n        while (r < n) {\\n            sum += nums[r++];\\n            while (sum >= s) {\\n                len = min(len, r - l);\\n                sum -= nums[l++];\\n            }\\n        }\\n        return len == INT_MAX ? 0 : len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        int l = 0, r = 0, n = nums.size(), sum = 0, len = INT_MAX;\\n        while (r < n) {\\n            sum += nums[r++];\\n            while (sum >= s) {\\n                len = min(len, r - l);\\n                sum -= nums[l++];\\n            }\\n        }\\n        return len == INT_MAX ? 0 : len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180583,
                "title": "easy-c-code-binary-search",
                "content": "# Complexity\\n- Time complexity: **O(nlog(n))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n        vector<ll>v(n+1,0);\\n        for(int i=0;i<n;i++){\\n            v[i+1]=v[i] + nums[i];\\n        }\\n        ll ans = INT_MAX;\\n       for(int i=0;i<n;i++){\\n           ll sm = target + v[i];\\n           ll in = lower_bound(v.begin(),v.end(),sm) - v.begin();\\n           if(in!=n+1)ans=min(ans,in-i);\\n       }\\n       if(ans==INT_MAX)ans=0;\\n       return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/5909d30c-e3b6-4363-8385-e0c0a7d2b9ac_1677408016.5373929.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n        vector<ll>v(n+1,0);\\n        for(int i=0;i<n;i++){\\n            v[i+1]=v[i] + nums[i];\\n        }\\n        ll ans = INT_MAX;\\n       for(int i=0;i<n;i++){\\n           ll sm = target + v[i];\\n           ll in = lower_bound(v.begin(),v.end(),sm) - v.begin();\\n           if(in!=n+1)ans=min(ans,in-i);\\n       }\\n       if(ans==INT_MAX)ans=0;\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029858,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n      int result=Integer.MAX_VALUE;\\n      int left=0;\\n      int sum=0;\\n      for(int i=0;i<nums.length;i++){\\n        sum+=nums[i];\\n         while(sum>=target){\\n             result=Math.min(result,i+1-left);\\n             sum-=nums[left];\\n             left++;\\n         }\\n      }\\n         return result!=Integer.MAX_VALUE? result:0;\\n      }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n      int result=Integer.MAX_VALUE;\\n      int left=0;\\n      int sum=0;\\n      for(int i=0;i<nums.length;i++){\\n        sum+=nums[i];\\n         while(sum>=target){\\n             result=Math.min(result,i+1-left);\\n             sum-=nums[left];\\n             left++;\\n         }\\n      }\\n         return result!=Integer.MAX_VALUE? result:0;\\n      }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983525,
                "title": "simple-c-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply add elements until sum >=k then try to decremnt lower elemnts and check minimum difference b/w the left and right pointers .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple Sliding Window in which we set pointers l and r and first add elements in sum until sum>=k i.e arr[r++] values  and then subtract lower elemnts of array i.e arr[l++] values and check minimum difference between r and l and that is the answer .\\nActually we ahve the window whose sum = target but length should be as less as possible so we did a simple slidinf window and check which one smallest and whose sum=target .\\nFor more understanding look at the code line by line.\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minSubArrayLen(int k, vector<int>& arr) {\\n          int l=0,r=0;\\n        int sum=0;\\n        int mini=INT_MAX;\\n        while(r<n){\\n            sum+=arr[r++];\\n            while(sum>=k){\\n               sum-=arr[l++];\\n               mini=min(mini,r-l+1);\\n            }\\n        }\\n        if(mini<INT_MAX)\\n        return mini;\\n        else return 0;\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minSubArrayLen(int k, vector<int>& arr) {\\n          int l=0,r=0;\\n        int sum=0;\\n        int mini=INT_MAX;\\n        while(r<n){\\n            sum+=arr[r++];\\n            while(sum>=k){\\n               sum-=arr[l++];\\n               mini=min(mini,r-l+1);\\n            }\\n        }\\n        if(mini<INT_MAX)\\n        return mini;\\n        else return 0;\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816733,
                "title": "simple-and-short-o-n-solution-in-python-faster-than-90",
                "content": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        sum=nums[0]\\n        minSize= sys.maxsize\\n        i,j=0,0\\n        while j<len(nums) and i<len(nums):\\n            if sum<target:\\n                j=j+1\\n                if j==len(nums): break\\n                sum=sum+nums[j]\\n            elif sum>=target:\\n                if j-i+1<minSize: minSize=j-i+1\\n                sum=sum-nums[i]\\n                i=i+1\\n        return 0 if minSize== sys.maxsize else minSize\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        sum=nums[0]\\n        minSize= sys.maxsize\\n        i,j=0,0\\n        while j<len(nums) and i<len(nums):\\n            if sum<target:\\n                j=j+1\\n                if j==len(nums): break\\n                sum=sum+nums[j]\\n            elif sum>=target:\\n                if j-i+1<minSize: minSize=j-i+1\\n                sum=sum-nums[i]\\n                i=i+1\\n        return 0 if minSize== sys.maxsize else minSize\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802486,
                "title": "python-easy-sliding-window",
                "content": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=j=0\\n        s=nums[0]\\n        m=9999999\\n        while j<n and i<=j:\\n            if s>=target:   \\n                m=min(m,j-i+1)\\n                s-=nums[i]\\n                i+=1\\n            else:\\n                j+=1\\n                if j<n:\\n                    s+=nums[j]\\n        if m!=9999999:\\n            return m\\n        return 0\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=j=0\\n        s=nums[0]\\n        m=9999999\\n        while j<n and i<=j:\\n            if s>=target:   \\n                m=min(m,j-i+1)\\n                s-=nums[i]\\n                i+=1\\n            else:\\n                j+=1\\n                if j<n:\\n                    s+=nums[j]\\n        if m!=9999999:\\n            return m\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532976,
                "title": "javascript-sliding-window-with-heavy-comments",
                "content": "```\\n/**\\n * @param {number} target\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst minSubArrayLen = (target, nums) => {\\n    // Sliding window\\n    let minLen = Infinity; // We will use this to hold min window\\n    let curSum = 0; // Hold the sum of the current window\\n    let l = 0; // Pointers for window\\n    let r = 0;\\n    \\n    while(r < nums.length) {\\n        curSum += nums[r]; // Add num[r] to our running curSum\\n        \\n        while(curSum >= target) { // Enter inner while loop if we meet condition\\n            minLen = Math.min(minLen, r - l + 1); // If we meet condition, check if length is shorter  \\n            // Since we know we hit the condition, try to remove num at left pointer to make it shorter\\n            curSum -= nums[l];\\n            // Then check again\\n            minLen = Math.min(minLen, r - l + 1); // If we meet condition, check if length is shorter  \\n            // Move up left pointer\\n            l++;\\n        }\\n        \\n        r++; // Move up right pointer after all the tests\\n    }\\n    \\n    return minLen === Infinity ? 0 : minLen; // If we get here and minLen is still Infinity, return 0 cause we didnt find an answer\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number} target\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst minSubArrayLen = (target, nums) => {\\n    // Sliding window\\n    let minLen = Infinity; // We will use this to hold min window\\n    let curSum = 0; // Hold the sum of the current window\\n    let l = 0; // Pointers for window\\n    let r = 0;\\n    \\n    while(r < nums.length) {\\n        curSum += nums[r]; // Add num[r] to our running curSum\\n        \\n        while(curSum >= target) { // Enter inner while loop if we meet condition\\n            minLen = Math.min(minLen, r - l + 1); // If we meet condition, check if length is shorter  \\n            // Since we know we hit the condition, try to remove num at left pointer to make it shorter\\n            curSum -= nums[l];\\n            // Then check again\\n            minLen = Math.min(minLen, r - l + 1); // If we meet condition, check if length is shorter  \\n            // Move up left pointer\\n            l++;\\n        }\\n        \\n        r++; // Move up right pointer after all the tests\\n    }\\n    \\n    return minLen === Infinity ? 0 : minLen; // If we get here and minLen is still Infinity, return 0 cause we didnt find an answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909117,
                "title": "o-n-2-go-solution",
                "content": "```\\nfunc minSubArrayLen(target int, nums []int) int {\\n    if len(nums) == 0 {\\n        return 0\\n    }\\n    \\n    result := 1 << 32\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] >= target {\\n            return 1\\n        }\\n        \\n        sum := nums[i]\\n        \\n        for j := i + 1; j < len(nums); j++ {\\n            sum += nums[j]\\n            \\n            if sum >= target {\\n                result = min(result, j - i + 1)\\n            }\\n        }\\n    }\\n    \\n    if result != 1 << 32 {\\n        return result\\n    }\\n    \\n    return 0\\n}\\n\\nfunc min (a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minSubArrayLen(target int, nums []int) int {\\n    if len(nums) == 0 {\\n        return 0\\n    }\\n    \\n    result := 1 << 32\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] >= target {\\n            return 1\\n        }\\n        \\n        sum := nums[i]\\n        \\n        for j := i + 1; j < len(nums); j++ {\\n            sum += nums[j]\\n            \\n            if sum >= target {\\n                result = min(result, j - i + 1)\\n            }\\n        }\\n    }\\n    \\n    if result != 1 << 32 {\\n        return result\\n    }\\n    \\n    return 0\\n}\\n\\nfunc min (a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829696,
                "title": "python3-binary-search-solution",
                "content": "One of the solution improved from brute force method.\\nI\\'m aware that there is a prominently known better solution with two pointers sliding window method which gives linear time complexity,\\nbut just for reference and sharing.\\n\\nBelow are two methods using prefix sum : \\n\\n#####  1. Iterate through the prefix sum array and check subarray sum between *ith* and *jth* by subtracting sum until *jth* with sum until *ith* : \\n```\\nimport sys\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        result = sys.maxsize\\n        # Use an additional array to store prefix sum\\n        sumarray = [0] * (len(nums)+1)\\n        for i in range(1, len(sumarray)):\\n            sumarray[i] = sumarray[i-1] + nums[i-1]\\n        \\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                # Get subarray sum by subtracting prefix sum\\n                subsum = sumarray[j+1] - sumarray[i]\\n                if subsum >= target:\\n                    result = min(result, j-i+1)\\n                    break\\n        \\n        return 0 if result == sys.maxsize else result\\n```\\n* Time complexity : O(n^2)\\n* Space complexity : O(n)\\n!! Note that the above script will give a **TIME LIMIT EXCEEDED**.\\n\\n\\n#####  2. Use binary search for the inner loop to reduce its time complexity from O(n) to O(logn) : \\n```\\nimport sys\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        result = sys.maxsize\\n        # Use an additional array to store prefix sum\\n        sumarray = [0] * (len(nums)+1)\\n        for i in range(1, len(sumarray)):\\n            sumarray[i] = sumarray[i-1] + nums[i-1]\\n        \\n\\t\\t# Iterate on prefix array instead.\\n        for i in range(1,len(sumarray)):\\n\\t\\t    # Substitute the inner loop with binary search\\n            # Use binary search to find lower bound (value greater or equal \\n            # to target value.\\n            tofind = target + sumarray[i-1]\\n            l, r = i, len(sumarray)-1\\n            while l <= r:\\n                mid = (l+r) // 2\\n                if sumarray[mid] < tofind:\\n                    l = mid+1\\n                else:\\n                    result = min(result, mid-i+1)\\n                    r = mid-1\\n        return 0 if result == sys.maxsize else result\\n```\\n* Time complexity : O(nlogn)\\n* Space complexity : O(n)\\n\\nThe above method is not quite trivial than the two pointer sliding unless being familiar with binary search.",
                "solutionTags": [],
                "code": "```\\nimport sys\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        result = sys.maxsize\\n        # Use an additional array to store prefix sum\\n        sumarray = [0] * (len(nums)+1)\\n        for i in range(1, len(sumarray)):\\n            sumarray[i] = sumarray[i-1] + nums[i-1]\\n        \\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                # Get subarray sum by subtracting prefix sum\\n                subsum = sumarray[j+1] - sumarray[i]\\n                if subsum >= target:\\n                    result = min(result, j-i+1)\\n                    break\\n        \\n        return 0 if result == sys.maxsize else result\\n```\n```\\nimport sys\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        result = sys.maxsize\\n        # Use an additional array to store prefix sum\\n        sumarray = [0] * (len(nums)+1)\\n        for i in range(1, len(sumarray)):\\n            sumarray[i] = sumarray[i-1] + nums[i-1]\\n        \\n\\t\\t# Iterate on prefix array instead.\\n        for i in range(1,len(sumarray)):\\n\\t\\t    # Substitute the inner loop with binary search\\n            # Use binary search to find lower bound (value greater or equal \\n            # to target value.\\n            tofind = target + sumarray[i-1]\\n            l, r = i, len(sumarray)-1\\n            while l <= r:\\n                mid = (l+r) // 2\\n                if sumarray[mid] < tofind:\\n                    l = mid+1\\n                else:\\n                    result = min(result, mid-i+1)\\n                    r = mid-1\\n        return 0 if result == sys.maxsize else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671777,
                "title": "simple-and-easy-to-understand-python-solution-using-two-pointers",
                "content": "\\tdef minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        \\n        # Two pointer approach\\n        \\n        left = 0 # Initializing the left pointer to zero\\n        result = sys.maxsize # Setting the result to maximum value so that we can get the minimum value when we compute it\\n        curr_sum = 0 # Current sum will be initialized to zero and will be used to keep track of the running sum\\n        \\n        for i in range(len(nums)): # Looping through all the elements of the array nums and then adding that to the current sum\\n            curr_sum += nums[i]\\n            \\n            while curr_sum >= target: # IF current sum is found to be greater than or equal to the target then we get the minimum of result\\n                result = min(result, i + 1 - left) # This is the heart of the code where we get the minimum of result and i+1 - left\\n                # In our case of example 1 the window will be 3+1 -0 = 4\\n                curr_sum -= nums[left] # Then we remove the first element from that window because we have to find the minimum length of subarray\\n                left += 1 # After that we increment the left pointer so now we have 3 elements in our window and it will go on until the current sum is found to be less than target \\n        \\n        # THere is also a case where we need to return 0 when there is no subarray\\n        if result != sys.maxsize: # HEnce if the subarray is nothaving the max size then we just return the result which we found\\n            return result\\n        else: # OTherwise we return 0\\n            return 0\\n\\t\\n![image](https://assets.leetcode.com/users/images/19ffa2fa-2b53-4145-bd80-dbce3484c9e0_1641510618.1473594.png)\\n\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "\\tdef minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        \\n        # Two pointer approach\\n        \\n        left = 0 # Initializing the left pointer to zero\\n        result = sys.maxsize # Setting the result to maximum value so that we can get the minimum value when we compute it\\n        curr_sum = 0 # Current sum will be initialized to zero and will be used to keep track of the running sum\\n        \\n        for i in range(len(nums)): # Looping through all the elements of the array nums and then adding that to the current sum\\n            curr_sum += nums[i]\\n            \\n            while curr_sum >= target: # IF current sum is found to be greater than or equal to the target then we get the minimum of result\\n                result = min(result, i + 1 - left) # This is the heart of the code where we get the minimum of result and i+1 - left\\n                # In our case of example 1 the window will be 3+1 -0 = 4\\n                curr_sum -= nums[left] # Then we remove the first element from that window because we have to find the minimum length of subarray\\n                left += 1 # After that we increment the left pointer so now we have 3 elements in our window and it will go on until the current sum is found to be less than target \\n        \\n        # THere is also a case where we need to return 0 when there is no subarray\\n        if result != sys.maxsize: # HEnce if the subarray is nothaving the max size then we just return the result which we found\\n            return result\\n        else: # OTherwise we return 0\\n            return 0\\n\\t\\n![image](https://assets.leetcode.com/users/images/19ffa2fa-2b53-4145-bd80-dbce3484c9e0_1641510618.1473594.png)\\n\\n        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1643117,
                "title": "accepted-c-o-n-sliding-window-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        // sliding window O(N) time O(1) space\\n        \\n        /* at first we are going to iterate through vector, in \"sum\" veriable we are going to add\\n        every element of vector, if \"sum\" is samller than our TARGET then we are going to\\n        inrease our \"tail\", else while  \"sum\" gets equal or larger then we are going to store minimum\\n        of \"answer\" or \"windowSize\" in \"windowSize\" & also going to subtract nums[head] from \"sum\"\\n        and move head one step forward & we are going to move \"tail\" one step forward,\\n        if \"answer\"==INT_MAX then we are going to RETURN 0 else RETURN \"answer\"\\n        */\\n        \\n        int head=0,tail=0,len=nums.size(),answer=INT_MAX,sum=0;\\n         \\n        while(tail<len){\\n            // processing window\\n            sum+=nums[tail];\\n            // expanding window\\n            if(sum<target){\\n                tail++;\\n            }\\n            // contracting the window\\n            else{\\n                while(sum>=target){\\n                    int windowSize=tail-head+1;\\n                    answer=min(answer,windowSize);\\n                    sum-=nums[head];\\n                    head++;\\n                }\\n                tail++;  \\n            }\\n            \\n           \\n        }\\n        \\n     if(answer==INT_MAX)return 0;\\n            else return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        // sliding window O(N) time O(1) space\\n        \\n        /* at first we are going to iterate through vector, in \"sum\" veriable we are going to add\\n        every element of vector, if \"sum\" is samller than our TARGET then we are going to\\n        inrease our \"tail\", else while  \"sum\" gets equal or larger then we are going to store minimum\\n        of \"answer\" or \"windowSize\" in \"windowSize\" & also going to subtract nums[head] from \"sum\"\\n        and move head one step forward & we are going to move \"tail\" one step forward,\\n        if \"answer\"==INT_MAX then we are going to RETURN 0 else RETURN \"answer\"\\n        */\\n        \\n        int head=0,tail=0,len=nums.size(),answer=INT_MAX,sum=0;\\n         \\n        while(tail<len){\\n            // processing window\\n            sum+=nums[tail];\\n            // expanding window\\n            if(sum<target){\\n                tail++;\\n            }\\n            // contracting the window\\n            else{\\n                while(sum>=target){\\n                    int windowSize=tail-head+1;\\n                    answer=min(answer,windowSize);\\n                    sum-=nums[head];\\n                    head++;\\n                }\\n                tail++;  \\n            }\\n            \\n           \\n        }\\n        \\n     if(answer==INT_MAX)return 0;\\n            else return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946709,
                "title": "java-prefix-sum-treemap",
                "content": "This question is simliar to https://leetcode.com/problems/subarray-sum-equals-k/, i.e. using prefixSum logic. The reason to use a TreeMap is we have to find an entry in the map to meet: `prefixSum - s >= entry in the map`, i.e. to find a lower bound of `prefixSum - s `.\\n```\\nclass Solution {\\n    public int minSubArrayLen(int s, int[] nums) {\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        int min_length = Integer.MAX_VALUE;\\n        int prefixSum = 0;\\n        map.put(0, -1);\\n        for(int i=0; i<nums.length; i++) {\\n            prefixSum += nums[i];\\n            map.put(prefixSum, i);\\n            if(map.floorEntry(prefixSum-s) != null) {\\n                min_length = Math.min(min_length, i-map.floorEntry(prefixSum-s).getValue());\\n            }\\n        }\\n        return min_length == Integer.MAX_VALUE ? 0 : min_length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int s, int[] nums) {\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        int min_length = Integer.MAX_VALUE;\\n        int prefixSum = 0;\\n        map.put(0, -1);\\n        for(int i=0; i<nums.length; i++) {\\n            prefixSum += nums[i];\\n            map.put(prefixSum, i);\\n            if(map.floorEntry(prefixSum-s) != null) {\\n                min_length = Math.min(min_length, i-map.floorEntry(prefixSum-s).getValue());\\n            }\\n        }\\n        return min_length == Integer.MAX_VALUE ? 0 : min_length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915080,
                "title": "sliding-window-and-accelerated-by-binary-search",
                "content": "This problem is much easier than #862. Due to all elements in `nums` >= 0, thus the prefix sum of nums is always increasing.\\nMy first sotion is get prefix sum list of nums, than move `le` and `ri` to find the shortest window.\\n```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        if not nums: return 0\\n        cum = [0] * (len(nums) + 1)\\n        cum[0] = 0\\n        for i in range(1, len(cum)):\\n            cum[i] = cum[i-1] + nums[i-1]\\n        i, j = 0, 1\\n        ret = float(\\'inf\\')\\n        while j < len(cum):\\n            while cum[j] - cum[i] >= s:\\n                ret = min(ret, j - i)\\n                i += 1\\n            j += 1\\n        return 0 if ret == float(\\'inf\\') else ret\\n```\\nA better sliding window solution only need to traverse `nums` one time.\\n```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        le = 0\\n        ret = float(\\'inf\\')\\n        for ri, v in enumerate(nums):\\n            s -= v\\n            while s <= 0:\\n                ret = min(ret, ri - le + 1)\\n                s += nums[le]\\n                le += 1\\n        return 0 if ret == float(\\'inf\\') else ret\\n```\\nDue to the prefix sum of nums is always increasing, we can use binary search to \"accelerate\" finding the right side of window.\\n```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        def bi_search(A, target):\\n            le, ri = 0, len(A) - 1\\n            while le <= ri:\\n                mid = le + (ri - le >> 1)\\n                if target == A[mid]:\\n                    return mid\\n                if target < A[mid]:\\n                    ri = mid - 1\\n                elif target > A[mid]:\\n                    le = mid + 1\\n            return le\\n        \\n        ret = float(\\'inf\\')\\n        # get prefix sum for nums\\n        cum = [0] * len(nums) + [0]\\n        cum[0] = 0\\n        for i in range(1, len(cum)):\\n            cum[i] = cum[i-1] + nums[i-1]\\n        for le, v in enumerate(cum):\\n            # use binary search to locate \\'ri\\' index\\n            ri = bi_search(cum, v + s)\\n            if ri < len(cum):\\n                ret = min(ret, ri - le)\\n        return 0 if ret == float(\\'inf\\') else ret  \\n```\\nWe can use the `bisect.bisect_left` instead of the binary search fuction written by ourself.\\n```\\nimport bisect\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        ret = float(\\'inf\\')\\n        # get prefix sum for nums\\n        cum = [0] * len(nums) + [0]\\n        cum[0] = 0\\n        for i in range(1, len(cum)):\\n            cum[i] = cum[i-1] + nums[i-1]\\n        for le, v in enumerate(cum):\\n            # use binary search to locate \\'ri\\' index\\n            ri = bisect.bisect_left(cum, v + s)\\n            if ri < len(cum):\\n                ret = min(ret, ri - le)\\n        return 0 if ret == float(\\'inf\\') else ret  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        if not nums: return 0\\n        cum = [0] * (len(nums) + 1)\\n        cum[0] = 0\\n        for i in range(1, len(cum)):\\n            cum[i] = cum[i-1] + nums[i-1]\\n        i, j = 0, 1\\n        ret = float(\\'inf\\')\\n        while j < len(cum):\\n            while cum[j] - cum[i] >= s:\\n                ret = min(ret, j - i)\\n                i += 1\\n            j += 1\\n        return 0 if ret == float(\\'inf\\') else ret\\n```\n```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        le = 0\\n        ret = float(\\'inf\\')\\n        for ri, v in enumerate(nums):\\n            s -= v\\n            while s <= 0:\\n                ret = min(ret, ri - le + 1)\\n                s += nums[le]\\n                le += 1\\n        return 0 if ret == float(\\'inf\\') else ret\\n```\n```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        def bi_search(A, target):\\n            le, ri = 0, len(A) - 1\\n            while le <= ri:\\n                mid = le + (ri - le >> 1)\\n                if target == A[mid]:\\n                    return mid\\n                if target < A[mid]:\\n                    ri = mid - 1\\n                elif target > A[mid]:\\n                    le = mid + 1\\n            return le\\n        \\n        ret = float(\\'inf\\')\\n        # get prefix sum for nums\\n        cum = [0] * len(nums) + [0]\\n        cum[0] = 0\\n        for i in range(1, len(cum)):\\n            cum[i] = cum[i-1] + nums[i-1]\\n        for le, v in enumerate(cum):\\n            # use binary search to locate \\'ri\\' index\\n            ri = bi_search(cum, v + s)\\n            if ri < len(cum):\\n                ret = min(ret, ri - le)\\n        return 0 if ret == float(\\'inf\\') else ret  \\n```\n```\\nimport bisect\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        ret = float(\\'inf\\')\\n        # get prefix sum for nums\\n        cum = [0] * len(nums) + [0]\\n        cum[0] = 0\\n        for i in range(1, len(cum)):\\n            cum[i] = cum[i-1] + nums[i-1]\\n        for le, v in enumerate(cum):\\n            # use binary search to locate \\'ri\\' index\\n            ri = bisect.bisect_left(cum, v + s)\\n            if ri < len(cum):\\n                ret = min(ret, ri - le)\\n        return 0 if ret == float(\\'inf\\') else ret  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 854549,
                "title": "java-clean-code-o-n-time-complexity-using-sliding-window-approach",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic int minSubArrayLen (int s, int[] nums) {\\n\\t\\t\\t\\n\\t\\tint minLen = Integer.MAX_VALUE;\\n\\t\\tint sum = 0;\\n\\t\\tint start = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\twhile (sum >= s) {\\n\\t\\t\\t\\tminLen = Math.min (minLen, i - start + 1);\\n\\t\\t\\t\\tsum -= nums[start++];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn minLen != Integer.MAX_VALUE ? minLen : 0;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic int minSubArrayLen (int s, int[] nums) {\\n\\t\\t\\t\\n\\t\\tint minLen = Integer.MAX_VALUE;\\n\\t\\tint sum = 0;\\n\\t\\tint start = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\twhile (sum >= s) {\\n\\t\\t\\t\\tminLen = Math.min (minLen, i - start + 1);\\n\\t\\t\\t\\tsum -= nums[start++];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn minLen != Integer.MAX_VALUE ? minLen : 0;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811476,
                "title": "python3-prefix-sum-binary-search",
                "content": "We know the important property of prefix sum array `pre` is `pre[i] - pre[j] = sum(arr[j+1:i])`, where `arr` is the original array. The problem asks us to find the subarray whose sum is no less than `s`, in other words, we need to find the index `i` such that `pre[i] - pre[j] >= s` (i.e `pre[j] + s <= pre[i]`). Since `pre` is a non-decsreasing sequence, we can use binary search to find such upper bound.\\n```\\ndef minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n\\tdef search(arr, target, start, end):\\n\\t\\tlo, hi = start, end\\n\\t\\twhile lo < hi:\\n\\t\\t\\tmid = (lo + hi) // 2\\n\\t\\t\\tif arr[mid] < target:  # the first elem >= target\\n\\t\\t\\t\\tlo = mid + 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\thi = mid\\n\\t\\treturn lo\\n\\n\\tn = len(nums)\\n\\tpre = [0] * (n+1)\\n\\tfor i in range(1, n+1):\\n\\t\\tpre[i] = pre[i-1] + nums[i-1]\\n\\n\\tINF = float(\"inf\")\\n\\tans = INF\\n\\n\\tfor i, elem in enumerate(pre):\\n\\t\\tj = min(search(pre, elem+s, 0, n+1), n)  # j could be (n+1), use min to avoid index out of range\\n\\t\\tif pre[j] >= elem + s:\\n\\t\\t\\tans = min(ans, j - i)\\n\\n\\treturn ans if ans != INF else 0\\n```",
                "solutionTags": [],
                "code": "```\\ndef minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n\\tdef search(arr, target, start, end):\\n\\t\\tlo, hi = start, end\\n\\t\\twhile lo < hi:\\n\\t\\t\\tmid = (lo + hi) // 2\\n\\t\\t\\tif arr[mid] < target:  # the first elem >= target\\n\\t\\t\\t\\tlo = mid + 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\thi = mid\\n\\t\\treturn lo\\n\\n\\tn = len(nums)\\n\\tpre = [0] * (n+1)\\n\\tfor i in range(1, n+1):\\n\\t\\tpre[i] = pre[i-1] + nums[i-1]\\n\\n\\tINF = float(\"inf\")\\n\\tans = INF\\n\\n\\tfor i, elem in enumerate(pre):\\n\\t\\tj = min(search(pre, elem+s, 0, n+1), n)  # j could be (n+1), use min to avoid index out of range\\n\\t\\tif pre[j] >= elem + s:\\n\\t\\t\\tans = min(ans, j - i)\\n\\n\\treturn ans if ans != INF else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 693241,
                "title": "python-sliding-window-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : SLIDING WINDOW ##\\n        ## LOGIC ##\\n        ## 1. First increase windowsize till sum >= s ##\\n        ## 2. once you find it, shrink the window size by incrementing the left pointer\\n        ## 3. when it breaks, continue incrementing the right pointer, (where window start will be left pointer not from index 0)\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        windowSum, windowStart = 0, 0\\n        minLength = math.inf\\n        for windowEnd in range(len(nums)):\\n            windowSum+=nums[windowEnd]\\n            while windowSum >= s:\\n                minLength = min(minLength, windowEnd - windowStart + 1)\\n                windowSum -= nums[windowStart]\\n                windowStart+=1\\n        if minLength == math.inf:\\n            return 0\\n        return minLength\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : SLIDING WINDOW ##\\n        ## LOGIC ##\\n        ## 1. First increase windowsize till sum >= s ##\\n        ## 2. once you find it, shrink the window size by incrementing the left pointer\\n        ## 3. when it breaks, continue incrementing the right pointer, (where window start will be left pointer not from index 0)\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        windowSum, windowStart = 0, 0\\n        minLength = math.inf\\n        for windowEnd in range(len(nums)):\\n            windowSum+=nums[windowEnd]\\n            while windowSum >= s:\\n                minLength = min(minLength, windowEnd - windowStart + 1)\\n                windowSum -= nums[windowStart]\\n                windowStart+=1\\n        if minLength == math.inf:\\n            return 0\\n        return minLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473099,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int MinSubArrayLen(int s, int[] nums)\\n    {\\n        if (nums.Length == 0)\\n        {\\n            return 0;\\n        }\\n\\n        int res = int.MaxValue;\\n        int left = 0;\\n        int sum = nums[0];\\n        int right = 0;\\n\\n        while (left != nums.Length)\\n        {\\n            if (sum < s)\\n            {\\n                if (right < nums.Length - 1)\\n                {\\n                    right++;\\n                    sum += nums[right];\\n                }\\n                else\\n                {\\n                    sum -= nums[left];\\n                    left++;\\n                }\\n\\n                continue;\\n            }\\n\\n            res = Math.Min(right - left + 1, res);\\n            sum -= nums[left];\\n            left++;\\n        }\\n\\n        return res == int.MaxValue ? 0 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MinSubArrayLen(int s, int[] nums)\\n    {\\n        if (nums.Length == 0)\\n        {\\n            return 0;\\n        }\\n\\n        int res = int.MaxValue;\\n        int left = 0;\\n        int sum = nums[0];\\n        int right = 0;\\n\\n        while (left != nums.Length)\\n        {\\n            if (sum < s)\\n            {\\n                if (right < nums.Length - 1)\\n                {\\n                    right++;\\n                    sum += nums[right];\\n                }\\n                else\\n                {\\n                    sum -= nums[left];\\n                    left++;\\n                }\\n\\n                continue;\\n            }\\n\\n            res = Math.Min(right - left + 1, res);\\n            sum -= nums[left];\\n            left++;\\n        }\\n\\n        return res == int.MaxValue ? 0 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344476,
                "title": "simple-python-two-pointer-solution-80-ms-beat-97-06",
                "content": "Please see and vote for my solutions for these similar problems.\\n[1208. Get Equal Substrings Within Budget](https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/392901/Simple-Python-moving-window)\\n[3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/348137/Simple-Python-two-pointer-solution-(52ms-beat-97.94))\\n[159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/348157/Simple-Python-two-pointer-solution)\\n[340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/348216/Simple-Python-two-pointer-solution-(72-ms-beat-94.93))\\n[992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/348984/Different-Python-two-pointer-solutions)\\n[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/discuss/363071/Simple-Python-two-pointer-solution)\\n[209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/344476/Simple-Python-two-pointer-solution)\\n[713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/discuss/344245/Simple-Python-solution-(beat-94.59))\\n[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/344533/Simple-Python-two-pointer-solution)\\n\\nKeep a moving window expand until curr_s >= s, then shrink util curr_s < s. \\nEach time after shrinking, update the minimal length. \\n\\n```\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        res = float(\\'inf\\')\\n        left = 0\\n        curr_s = 0\\n        for right in range(len(nums)):\\n            curr_s += nums[right]\\n            while curr_s >= s:\\n                res = min(res, right - left + 1)\\n                curr_s -= nums[left]\\n                left += 1\\n        return res if res != float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        res = float(\\'inf\\')\\n        left = 0\\n        curr_s = 0\\n        for right in range(len(nums)):\\n            curr_s += nums[right]\\n            while curr_s >= s:\\n                res = min(res, right - left + 1)\\n                curr_s -= nums[left]\\n                left += 1\\n        return res if res != float(\\'inf\\') else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 180113,
                "title": "c-o-n-works-for-both-negative-and-positive-elements-easy-to-explain-and-impl-in-5mins-cheers",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int K, vector<int>& A) {        \\n        int n = A.size();\\n\\n        vector<int> pres(n + 1, 0);\\n        for (int i = 1; i < n + 1; ++i) {\\n            pres[i] = pres[i - 1] + A[i - 1];\\n        }\\n\\n        int res = n + 1;\\n        deque<int> q;\\n        q.push_back(0);\\n\\n        for (int i = 1; i < n + 1; ++i) {\\n            while (!q.empty() && pres[i] - pres[q.front()] >= K) {\\n                res = min(res, i - q.front());\\n                q.pop_front();\\n            }\\n            while (!q.empty() && pres[q.back()] >= pres[i]) {\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n        }\\n\\n        return res == n + 1 ? 0 : res;     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int K, vector<int>& A) {        \\n        int n = A.size();\\n\\n        vector<int> pres(n + 1, 0);\\n        for (int i = 1; i < n + 1; ++i) {\\n            pres[i] = pres[i - 1] + A[i - 1];\\n        }\\n\\n        int res = n + 1;\\n        deque<int> q;\\n        q.push_back(0);\\n\\n        for (int i = 1; i < n + 1; ++i) {\\n            while (!q.empty() && pres[i] - pres[q.front()] >= K) {\\n                res = min(res, i - q.front());\\n                q.pop_front();\\n            }\\n            while (!q.empty() && pres[q.back()] >= pres[i]) {\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n        }\\n\\n        return res == n + 1 ? 0 : res;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167540,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def minSubArrayLen(self, s, nums):\\n        \"\"\"\\n        :type s: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i = j = curSum = 0\\n        mini = math.inf\\n        \\n        while j < len(nums):\\n            if curSum + nums[j] < s:\\n                curSum = curSum + nums[j]\\n                j += 1\\n            else:\\n                mini = min(j-i+1, mini)\\n                curSum = curSum - nums[i]                   \\n                i += 1\\n                                          \\n        return mini if mini != math.inf else 0\\n```\\n\\nThe idea/framework behind this was Kadane\\'s Algorithm and it might be the most feasible solution i could come up with during an interview.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, s, nums):\\n        \"\"\"\\n        :type s: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i = j = curSum = 0\\n        mini = math.inf\\n        \\n        while j < len(nums):\\n            if curSum + nums[j] < s:\\n                curSum = curSum + nums[j]\\n                j += 1\\n            else:\\n                mini = min(j-i+1, mini)\\n                curSum = curSum - nums[i]                   \\n                i += 1\\n                                          \\n        return mini if mini != math.inf else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59196,
                "title": "c-4ms-solution-o-n-time-o-1-space",
                "content": "    class Solution {\\n    public:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int res=INT_MAX;\\n        int i=0,j=0,sum=nums[0];\\n        \\n        while(j<nums.size()){\\n            if(sum>=s){\\n                res = min(res,j-i+1);\\n                if (res==1) return res;\\n                sum-=nums[i++];\\n            }else {\\n                j++;\\n                if (j<nums.size()) sum+=nums[j];\\n            }\\n        }\\n        if (res==INT_MAX) return 0;\\n        else return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int minSubArrayLen(int s, vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int res=INT_MAX;\\n        int i=0,j=0,sum=nums[0];\\n        \\n        while(j<nums.size()){\\n            if(sum>=s){\\n                res = min(res,j-i+1);\\n                if (res==1) return res;\\n                sum-=nums[i++];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 59292,
                "title": "c-o-n-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        int minSubArrayLen(int s, vector<int>& nums) {\\n            const int n = nums.size();\\n            int left = 0, right = 0, sum = 0, result = INT_MAX;\\n            while (right < n) {\\n                while (right < n && sum < s) {  // expend [left,right] to make sum >= s, notice that right is just at right of index where sum >= s;\\n                    sum += nums[right];\\n                    ++right;\\n                }\\n                while (left < right && sum >= s) {   // shrink [left, right] to make  it  as small as possible\\n                    result = min(result, right - left);  // there we don't use right - left + 1, because right is just at right of index where sum >= s;\\n                    sum -= nums[left];\\n                    ++left;\\n                }\\n                \\n            }\\n            \\n            return result == INT_MAX ? 0 : result;\\n        \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minSubArrayLen(int s, vector<int>& nums) {\\n            const int n = nums.size();\\n            int left = 0, right = 0, sum = 0, result = INT_MAX;\\n            while (right < n) {\\n                while (right < n && sum < s) {  // expend [left,right] to make sum >= s, notice that right is just at right of index where sum >= s;\\n                    sum += nums[right];\\n                    ++right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4052594,
                "title": "two-pointer-solution-easy-to-understand-o-1-space-please-upvote",
                "content": "# Problem Description\\n\\nYou are given an array `nums` of positive integers and an integer `target`. Your goal is to find the minimum subarray length such that the sum of the subarray is greater than or equal to `target`. If no such subarray exists, return 0.\\n\\n# Intuition\\n\\nThis problem involves finding the minimum subarray length with a given sum. The intuition here is to use a sliding window technique to efficiently traverse the array, keeping track of the sum of elements within the window and updating the minimum subarray length when the sum meets the target.\\n\\n# Approach\\n\\nTo solve this problem optimally, we can follow this approach:\\n1. Initialize two pointers, `left` and `right`, both initially pointing to the beginning of the array. Also, initialize `min` to `Integer.MAX_VALUE` to keep track of the minimum subarray length.\\n2. Initialize a variable `sum` to track the sum of elements within the sliding window.\\n3. While `right` is within the bounds of the array:\\n   - If the current `sum` is less than `target`, expand the window by moving `right` to the right and adding the element at `right` to the `sum`.\\n   - If the current `sum` is greater than or equal to `target`, update `min` with the minimum of the current subarray length (`right - left + 1`) and the current `min`. Then, remove the left element from the window by moving `left` to the right and subtracting the element at `left` from the `sum`.\\n4. Continue this process until `right` reaches the end of the array.\\n5. After the loop, if `min` remains `Integer.MAX_VALUE`, return 0 to indicate that no subarray met the target sum.\\n6. Otherwise, return `min` as the minimum subarray length that satisfies the target sum.\\n\\n# Complexity Analysis\\n\\n- Time complexity: O(n), where `n` is the length of the `nums` array. We traverse the array once with the sliding window approach.\\n- Space complexity: O(1), as we use only a constant amount of additional space for pointers and variables.\\n\\nThis efficient approach ensures that the minimum subarray length with a sum greater than or equal to the target is calculated optimally.\\n\\nShare this elegant solution with your fellow LeetCode enthusiasts and help them understand how to solve subarray sum problems efficiently using the sliding window technique. Happy coding!\\n\\nCode by : Vrund R Patel\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int left =0;\\n        int right =0;\\n        int min = Integer.MAX_VALUE;\\n        int sum=0;\\n\\n        while(right<nums.length){\\n            if(sum < target){\\n                sum+=nums[right];\\n                //System.out.println(left + \" \" + right + \" \"+ sum);\\n            }\\n            else{\\n                sum+=nums[right];\\n                while(sum>= target){\\n                \\n               // System.out.println(left + \" \" + right + \" \"+ sum);\\n                    min = Math.min(right - left + 1, min);\\n                    if((sum - nums[left]) >= target)\\n                    {\\n                        sum-= nums[left++];\\n                    }\\n                    else\\n                        break;\\n                }\\n            }\\n            while(sum>= target){\\n                //System.out.println(left + \" \" + right + \" \"+ sum);\\n                min = Math.min(right - left + 1, min);\\n                if((sum - nums[left]) >= target)\\n                {\\n                    sum-= nums[left++];\\n                }\\n                else\\n                    break;\\n            }\\n            right++;\\n        }\\n\\n        if(min == Integer.MAX_VALUE)\\n            return 0;\\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int left =0;\\n        int right =0;\\n        int min = Integer.MAX_VALUE;\\n        int sum=0;\\n\\n        while(right<nums.length){\\n            if(sum < target){\\n                sum+=nums[right];\\n                //System.out.println(left + \" \" + right + \" \"+ sum);\\n            }\\n            else{\\n                sum+=nums[right];\\n                while(sum>= target){\\n                \\n               // System.out.println(left + \" \" + right + \" \"+ sum);\\n                    min = Math.min(right - left + 1, min);\\n                    if((sum - nums[left]) >= target)\\n                    {\\n                        sum-= nums[left++];\\n                    }\\n                    else\\n                        break;\\n                }\\n            }\\n            while(sum>= target){\\n                //System.out.println(left + \" \" + right + \" \"+ sum);\\n                min = Math.min(right - left + 1, min);\\n                if((sum - nums[left]) >= target)\\n                {\\n                    sum-= nums[left++];\\n                }\\n                else\\n                    break;\\n            }\\n            right++;\\n        }\\n\\n        if(min == Integer.MAX_VALUE)\\n            return 0;\\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729467,
                "title": "java-sliding-window-beats-100-11-lines-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minSubArrayLen(int target, int[] nums) {\\n    int n = nums.length;\\n    int min = Integer.MAX_VALUE, l = 0, r = 0, sum = 0;\\n\\n    while (true) {\\n      while (r < n && sum < target) {\\n        sum += nums[r++];\\n      }\\n      if (sum >= target) min = Math.min(min, r-l+1);\\n\\n      while (l <= r && sum >= target) {\\n        sum -= nums[l++];\\n        min = Math.min(min, r-l+1);\\n      }\\n      if (r == n) break;\\n    }\\n    return min == Integer.MAX_VALUE ? 0 : min;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n  public int minSubArrayLen(int target, int[] nums) {\\n    int n = nums.length;\\n    int min = Integer.MAX_VALUE, l = 0, r = 0, sum = 0;\\n\\n    while (true) {\\n      while (r < n && sum < target) {\\n        sum += nums[r++];\\n      }\\n      if (sum >= target) min = Math.min(min, r-l+1);\\n\\n      while (l <= r && sum >= target) {\\n        sum -= nums[l++];\\n        min = Math.min(min, r-l+1);\\n      }\\n      if (r == n) break;\\n    }\\n    return min == Integer.MAX_VALUE ? 0 : min;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727542,
                "title": "easy-c-solution-using-sliding-window-two-pointers",
                "content": "# Intuition\\nThe given problem requires finding the minimum length of a subarray in the nums vector whose sum is greater than or equal to the target value.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize variables: i and j as pointers to track the window, sum to store the current sum, and ans as the minimum length of the subarray initialized to INT8_MAX.\\n2. Use a while loop to iterate through the array until the window reaches the end.\\n3. Inside the loop, add the value of nums[j] to sum.\\n4. Check if the sum is greater than or equal to the target.\\n - If true, enter a nested while loop.\\n    - While the sum is still greater than or equal to the target, update the answer as the minimum between the current answer and the window length (j - i) + 1.\\n    -  Subtract nums[i] from the sum and increment i to slide the window.\\n- If false, continue to the next iteration of the outer loop.\\n5. Increment j to expand the window.\\n6. Once the loop ends, check if the answer remains unchanged (still INT8_MAX). If so, return 0 since no subarray satisfies the condition.\\n7. Otherwise, return the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity:  $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    if(n == 1){ // base case\\n        if(nums[0] <  target) return 0;\\n        else return 1;\\n    }\\n\\n    int i =0;  // i & j are two pointers for sliding window\\n    int j = 0;\\n    int sum  = 0; // keep the total current sum\\n    int ans = INT_MAX; // actual window size required\\n    while(i <= j && j <n){ // ultill j reaches end\\n        sum += nums[j];         // keep adding element of array in window\\n\\n        if(sum >= target) {  // onces sum of all elements in window is greater than target then keep removing first elements of window .. to minisize size of window\\n     \\n            while(sum >= target){\\n                ans  = min(ans , (j-i)+1); // calculate the size of window\\n        \\n                sum -= nums[i]; // rempve first elements of window from current sum\\n\\n                i++; // moving front pointer of window forward\\n            }\\n        }\\n         j++; // keep adding new elements in window\\n    }\\n    if(ans == INT_MAX) return 0; // if no subarrray found then check whether ans is updated or not.. if not means output is 0\\n    return ans; // return min size subarray\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    if(n == 1){ // base case\\n        if(nums[0] <  target) return 0;\\n        else return 1;\\n    }\\n\\n    int i =0;  // i & j are two pointers for sliding window\\n    int j = 0;\\n    int sum  = 0; // keep the total current sum\\n    int ans = INT_MAX; // actual window size required\\n    while(i <= j && j <n){ // ultill j reaches end\\n        sum += nums[j];         // keep adding element of array in window\\n\\n        if(sum >= target) {  // onces sum of all elements in window is greater than target then keep removing first elements of window .. to minisize size of window\\n     \\n            while(sum >= target){\\n                ans  = min(ans , (j-i)+1); // calculate the size of window\\n        \\n                sum -= nums[i]; // rempve first elements of window from current sum\\n\\n                i++; // moving front pointer of window forward\\n            }\\n        }\\n         j++; // keep adding new elements in window\\n    }\\n    if(ans == INT_MAX) return 0; // if no subarrray found then check whether ans is updated or not.. if not means output is 0\\n    return ans; // return min size subarray\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726612,
                "title": "potd-minimum-subarray-length-easy-sliding-window-approach",
                "content": "# Intuition\\nClassic Sliding Window problem.\\nIf you go through the solution then you will understand the approach thouroughly.\\nAnd please upvote if you like the solution, it takes Nothing.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n1. Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n        int right=0;\\n        int left=0;\\n        int sum=0;\\n        int res=INT_MAX;\\n        while(right<n){\\n            sum+=nums[right];\\n            if(sum<target){\\n                right++;\\n            }\\n            else {\\n                while(sum>=target){\\n                sum-=nums[left];\\n                res=min(res,right-left+1);\\n                left++;\\n            }\\n            right++;\\n            }\\n        }\\n        return res==INT_MAX?0:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n        int right=0;\\n        int left=0;\\n        int sum=0;\\n        int res=INT_MAX;\\n        while(right<n){\\n            sum+=nums[right];\\n            if(sum<target){\\n                right++;\\n            }\\n            else {\\n                while(sum>=target){\\n                sum-=nums[left];\\n                res=min(res,right-left+1);\\n                left++;\\n            }\\n            right++;\\n            }\\n        }\\n        return res==INT_MAX?0:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726598,
                "title": "c-2-pointer-appproach-c-easy-solution-o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will follow two pointer approach here.\\n2. Declare two starting index pointer variables i and j and a mini variable to store minimum subarray length , a variable s to store continuous sum.\\n3. Loop through the array and store continuous sum in a variable s if at any instance s is greater than equal to target then decrease the total sum array by index pointer i\\'s value and keep storing minimum length in variable mini with the help of expression **mini=min(mini,i-j+1)**  keep on traversing through the list till end.\\n4. Return answer if mini value is not equal to INT_MAX i.e. a sum greater than or equal to target was found.\\n5. Else return 0\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n                        //Please UPVOTE\\n    int minSubArrayLen(int t, vector<int>& arr) {\\n    int i=0,j=0,mini=INT_MAX;int s=0,n=arr.size();\\n    while(i<n)\\n    {\\n        s=s+arr[i];\\n        while(s>=t)\\n        {\\n            mini=min(mini,i-j+1);\\n            s=s-arr[j];\\n            j++;\\n        }\\n        \\n        i++;\\n    }\\n    if(mini!=INT_MAX)\\n    return mini;\\n    else\\n    return 0;\\n    }\\n                        //Please UPVOTE\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n                        //Please UPVOTE\\n    int minSubArrayLen(int t, vector<int>& arr) {\\n    int i=0,j=0,mini=INT_MAX;int s=0,n=arr.size();\\n    while(i<n)\\n    {\\n        s=s+arr[i];\\n        while(s>=t)\\n        {\\n            mini=min(mini,i-j+1);\\n            s=s-arr[j];\\n            j++;\\n        }\\n        \\n        i++;\\n    }\\n    if(mini!=INT_MAX)\\n    return mini;\\n    else\\n    return 0;\\n    }\\n                        //Please UPVOTE\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726067,
                "title": "just-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0, right = 0, sumOfCurrentWindow = 0;\\n        int res = INT_MAX;\\n\\n        for(right = 0; right < nums.size(); right++) {\\n            sumOfCurrentWindow += nums[right];\\n\\n            while (sumOfCurrentWindow >= target) {\\n                res = min(res, right - left + 1);\\n                sumOfCurrentWindow -= nums[left];\\n                left++;\\n            }\\n        }\\n\\n        return res == INT_MAX ? 0 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0, right = 0, sumOfCurrentWindow = 0;\\n        int res = INT_MAX;\\n\\n        for(right = 0; right < nums.size(); right++) {\\n            sumOfCurrentWindow += nums[right];\\n\\n            while (sumOfCurrentWindow >= target) {\\n                res = min(res, right - left + 1);\\n                sumOfCurrentWindow -= nums[left];\\n                left++;\\n            }\\n        }\\n\\n        return res == INT_MAX ? 0 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725903,
                "title": "optimal-solution-using-sliding-windows-and-prefix-sum-with-explanation-c-and-java-code",
                "content": "\\n\\n# Explanation\\nThis solution uses a sliding window approach to find the minimal length of a subarray whose sum is greater than or equal to the target. The left and right pointers define the current subarray, and the sum keeps track of the sum of elements in the window.\\n\\nWe iterate through the array with the right pointer and add the current element to the sum. If the sum becomes greater than or equal to the target, we update the minLength if necessary and then move the left pointer to the right while the sum is still greater than or equal to the target. This ensures that we find the minimal length subarray.\\n\\nFinally, we return the minLength if it has been updated, otherwise return 0 to indicate that no subarray was found.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n = nums.size();\\n        int minLength = n + 1; \\n        int left = 0; \\n        int sum = 0;  \\n        for (int right = 0; right < n; right++) {\\n            sum += nums[right]; \\n            while (sum >= target) {\\n                int currentLength = right - left + 1; \\n                minLength = min(minLength, currentLength); \\n                sum -= nums[left]; \\n                left++; \\n            }\\n        } \\n        return (minLength != n + 1) ? minLength : 0; \\n    }\\n};\\n\\n```\\n# Java Code\\n```\\n\\n\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minLength = n + 1;\\n        int left = 0; \\n        int sum = 0;    \\n        for (int right = 0; right < n; right++) {\\n            sum += nums[right];      \\n            while (sum >= target) {\\n                int currentLength = right - left + 1; \\n                minLength = Math.min(minLength, currentLength); \\n                sum -= nums[left]; \\n                left++; \\n            }\\n        }  \\n        return (minLength != n + 1) ? minLength : 0;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n = nums.size();\\n        int minLength = n + 1; \\n        int left = 0; \\n        int sum = 0;  \\n        for (int right = 0; right < n; right++) {\\n            sum += nums[right]; \\n            while (sum >= target) {\\n                int currentLength = right - left + 1; \\n                minLength = min(minLength, currentLength); \\n                sum -= nums[left]; \\n                left++; \\n            }\\n        } \\n        return (minLength != n + 1) ? minLength : 0; \\n    }\\n};\\n\\n```\n```\\n\\n\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minLength = n + 1;\\n        int left = 0; \\n        int sum = 0;    \\n        for (int right = 0; right < n; right++) {\\n            sum += nums[right];      \\n            while (sum >= target) {\\n                int currentLength = right - left + 1; \\n                minLength = Math.min(minLength, currentLength); \\n                sum -= nums[left]; \\n                left++; \\n            }\\n        }  \\n        return (minLength != n + 1) ? minLength : 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725802,
                "title": "sliding-window-technique-t-c-o-n-s-c-o-1-easy-explanation",
                "content": "# Intuition\\nThe intuition behind this algorithm is to use a sliding window approach to find the minimum length subarray with a sum greater than or equal to the target value.\\n\\n# Approach\\n\\nVariable created in this solution is ---> **i ,j , ans, val**\\n\\n\\nThe algorithm maintains two pointers, **i** and **j**, which define the current subarray window **[i, j)**. It starts with an empty window and gradually expands the window by moving the right pointer j and adding the corresponding element to the sum **val**.\\n\\nOnce the sum **val** becomes greater than or equal to the target value, it means we have a potential subarray that satisfies the condition. ***However, this subarray might not be the minimum length subarray, so we try to shrink the window from the left side by incrementing the left pointer **i** and subtracting the corresponding element from the sum val***. This process continues until the sum becomes less than the target value.\\n\\nAt each step, we update the minimum subarray length **ans** if a smaller length is found. By doing this, we ensure that **ans** stores the minimum length subarray encountered so far that satisfies the condition.\\n\\nThe algorithm repeats this process until the right pointer **j** reaches the end of the array. After the loop finishes, we check if ans remains unchanged (**equal to INT_MAX**). If so, it means no subarray was found, and we **return 0**. ***Otherwise, we return the minimum subarray length stored in *ans***.\\n\\nDRY RUN on the Example 1 of the question\\n![solution1.png](https://assets.leetcode.com/users/images/b7726e62-c85b-4255-8709-5783ba013a6b_1688626316.3641093.png)\\n\\n![solution2.png](https://assets.leetcode.com/users/images/2e2e2f8f-67cf-4d5f-b583-4bdc836e7f31_1688626334.269957.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        \\n     int i=0,j=0;\\n     int val=0;\\n     int ans = INT_MAX;\\n     while(j<nums.size())\\n     {\\n        val+=nums[j++];\\n        while(val>=target)\\n        {\\n            val-=nums[i++];\\n            ans=min(ans,j-i+1);\\n        }\\n       \\n     }\\n     if(ans==INT_MAX)\\n     {\\n         return 0;\\n     }\\n     return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        \\n     int i=0,j=0;\\n     int val=0;\\n     int ans = INT_MAX;\\n     while(j<nums.size())\\n     {\\n        val+=nums[j++];\\n        while(val>=target)\\n        {\\n            val-=nums[i++];\\n            ans=min(ans,j-i+1);\\n        }\\n       \\n     }\\n     if(ans==INT_MAX)\\n     {\\n         return 0;\\n     }\\n     return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725759,
                "title": "two-pointer-5-lines-code-c",
                "content": "two pointer approach\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int k, vector<int>& nums) {\\n        int n=nums.size(),s=0,j=0,ans=INT_MAX,i=0;s=nums[0];\\n        while(i<n&&j<n){\\n            if(s>=k){ans=min(ans,i-j+1);s-=nums[j];j++;}\\n            else{i++;if(i>=n){continue;}s+=nums[i];}\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int k, vector<int>& nums) {\\n        int n=nums.size(),s=0,j=0,ans=INT_MAX,i=0;s=nums[0];\\n        while(i<n&&j<n){\\n            if(s>=k){ans=min(ans,i-j+1);s-=nums[j];j++;}\\n            else{i++;if(i>=n){continue;}s+=nums[i];}\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725375,
                "title": "sliding-window-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use the sliding window approach where the sum of elements in the window is considered at every iteration. If the sum >= target we update our answer, yet since we need the minimum possible size, we keep decreasing the size of the window as much as possible from the left to get the minimum length subarray. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe set the `minlen`(minimum window size) to `float(\\'inf\\')` which is the maximum possible value. Next we initialize left boundary of our window `l` to `0`. `sum` is the variable that calculates the sum of numbers in each window and we compare it with the `target`. We iterate over `r`, the right boundary of the window. Hence our window size is `r-l+1`. For each `r` we add `nums[r]` to the  `sum`. If `sum >= target` we update `minlen`. But, we might get a smaller window size as well where the condition `sum >= target` suffices. Hence, we reduce the window size, by increasing `l` by `1` and subtracting `nums[l]` from `sum` and updating `minlen` as long as the condition holds. Now, if there is no such subarray,`minlen` still has the value  `float(\\'inf\\')`. So, we return `0` in this case, otherwise we return `minlen`.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        minlen = float(\\'inf\\')\\n        l,sum =0,0\\n        for r in range(len(nums)):\\n            sum += nums[r]\\n            while sum >= target:\\n                minlen = min(minlen, r-l+1)\\n                sum -= nums[l]\\n                l += 1\\n        return minlen if minlen<=len(nums) else 0\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        minlen = float(\\'inf\\')\\n        l,sum =0,0\\n        for r in range(len(nums)):\\n            sum += nums[r]\\n            while sum >= target:\\n                minlen = min(minlen, r-l+1)\\n                sum -= nums[l]\\n                l += 1\\n        return minlen if minlen<=len(nums) else 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725322,
                "title": "simple-c-solution",
                "content": "\\n# Approach\\n1. Just move forward in the array and add the number to the sum\\n2. If the sum goes greater than target, move the ```second pointer``` forward to reduce the sum\\n## why reduce the sum?\\n>We want minimum length of subarray so if sum crosses target just reduce the sum while it is greater than the target.\\nwhile reducing the sum, we reduce the size of subarray and thus find the optimal answer.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(1)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int sum = 0;\\n        int j = 0;\\n        int mini = INT_MAX;\\n        for(int i = 0; i < nums.size(); ++i){\\n            sum += nums[i];\\n            while(sum >= target){\\n                mini = min(mini,i-j+1);\\n                sum -= nums[j++];\\n            }\\n        }\\n        return mini==INT_MAX?0:mini;\\n    }\\n};\\n```\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/500b692a-7c10-4f39-bc6d-31bf507d0ffd_1688621268.692774.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```second pointer```\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int sum = 0;\\n        int j = 0;\\n        int mini = INT_MAX;\\n        for(int i = 0; i < nums.size(); ++i){\\n            sum += nums[i];\\n            while(sum >= target){\\n                mini = min(mini,i-j+1);\\n                sum -= nums[j++];\\n            }\\n        }\\n        return mini==INT_MAX?0:mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725180,
                "title": "c-easy-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding window\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile traversing array, we are checking if sum of current window is greater than target, then we are updating result as minimum of current result and result obtained now and incrementing i pointer(left pointer). If it\\'s not greater then we are updating window by incrementing j pointer(right pointer)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int sum=0;\\n        if(nums.size()==1)\\n        {\\n            if(nums[0]>=target)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        int ans=INT_MAX;\\n        int i=0,j=0;\\n        while(j<nums.size())\\n        {\\n            if(sum+nums[j]>=target)\\n            {\\n                ans=min(ans,j-i+1);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            else\\n            {\\n                sum=sum+nums[j];\\n                j++;\\n            }\\n        }\\n        if(ans==INT_MAX)\\n            return 0;\\n        \\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you liked solution",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int sum=0;\\n        if(nums.size()==1)\\n        {\\n            if(nums[0]>=target)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        int ans=INT_MAX;\\n        int i=0,j=0;\\n        while(j<nums.size())\\n        {\\n            if(sum+nums[j]>=target)\\n            {\\n                ans=min(ans,j-i+1);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            else\\n            {\\n                sum=sum+nums[j];\\n                j++;\\n            }\\n        }\\n        if(ans==INT_MAX)\\n            return 0;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725126,
                "title": "minimum-size-subarray-sum-sliding-window-c-easy-explanation",
                "content": "# Intuition\\nwhenever such questions appears start thinking of sliding window.\\nthe intuition to use sliding window increases more if the number given are positive, because if the numbers are negative then sliding window for calculating sum cannot be used and hence giving wrong results.\\n\\n# Approach\\nCreate 3 integer variables j,len and sum . The variables i(declared for the loop) and j form a subarray by pointing to the starting and ending indices of the current subarray (or window), and sum stores the sum of this window. Intialize all of them with 0 while intialize len with INT_MAX.\\nWe iterate over nums using right starting from i = 0 till nums.length - 1 incrementing i by 1 after each iteration wth help of for loop . We perform the following inside this iteration:\\nAdd element at index right to the current window, incrementing sum by nums[i].\\nWe check if sum >= target. If so, we have a subarray that satisfies our condition. As a result, we attempt to update our len variable with the length of this subarray. We perform res = min(len, i - j + 1). We then remove the first element from this window by reducing sumOfCurrentWindow by nums[j] and incrementing j by 1. This step is repeated in an inner loop as long as sum >= target.\\nThe current window\\'s sum is now smaller than target. We need to add more elements to it. As a result, i is incremented by 1.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int j = 0 ; // ending point of subarray\\n        int n = nums.size();\\n        int len = INT_MAX;\\n        int sum = 0; // sum of current subarray\\n        for(int i = 0 ; i < n; ){\\n            sum += nums[i];\\n            if(sum<target){\\n                i++;\\n            }else{\\n                while(sum>=target){\\n                    len = min(len,i-j+1);\\n                    sum -= nums[j];\\n                    j++;\\n                }\\n                i++;\\n            }\\n        }\\n        return len==INT_MAX?0:len;\\n    }\\n};\\n```\\n\\n\\n\\nIf you like this solution, I\\'m happy if you give this post a vote.\\nHappy coding! <3",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int j = 0 ; // ending point of subarray\\n        int n = nums.size();\\n        int len = INT_MAX;\\n        int sum = 0; // sum of current subarray\\n        for(int i = 0 ; i < n; ){\\n            sum += nums[i];\\n            if(sum<target){\\n                i++;\\n            }else{\\n                while(sum>=target){\\n                    len = min(len,i-j+1);\\n                    sum -= nums[j];\\n                    j++;\\n                }\\n                i++;\\n            }\\n        }\\n        return len==INT_MAX?0:len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725089,
                "title": "easy-sliding-window-solution-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe needed to find the subarray of minimum length whose elements sum up more than or equal to the target.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt each step we change the size of the window and calculate the sum of the elements of the window. \\n\\n# Python Code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        s,e,sm = 0,0,0\\n        ans = math.inf\\n        n = len(nums)\\n        for e in range(n):\\n            sm += nums[e]\\n            while sm>=target:\\n                ans = min(ans,e-s+1)\\n                sm -= nums[s]\\n                s += 1\\n        return ans if ans!=math.inf else 0\\n```\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0, right = 0, sumOfCurrentWindow = 0;\\n        int res = INT_MAX;\\n\\n        for(right = 0; right < nums.size(); right++) {\\n            sumOfCurrentWindow += nums[right];\\n\\n            while (sumOfCurrentWindow >= target) {\\n                res = min(res, right - left + 1);\\n                sumOfCurrentWindow -= nums[left];\\n                left++;\\n            }\\n        }\\n\\n        return res == INT_MAX ? 0 : res;\\n    }\\n};\\n```\\n# Java Code\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int left = 0, right = 0, sumOfCurrentWindow = 0;\\n        int res = Integer.MAX_VALUE;\\n\\n        for(right = 0; right < nums.length; right++) {\\n            sumOfCurrentWindow += nums[right];\\n\\n            while (sumOfCurrentWindow >= target) {\\n                res = Math.min(res, right - left + 1);\\n                sumOfCurrentWindow -= nums[left++];\\n            }\\n        }\\n\\n        return res == Integer.MAX_VALUE ? 0 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        s,e,sm = 0,0,0\\n        ans = math.inf\\n        n = len(nums)\\n        for e in range(n):\\n            sm += nums[e]\\n            while sm>=target:\\n                ans = min(ans,e-s+1)\\n                sm -= nums[s]\\n                s += 1\\n        return ans if ans!=math.inf else 0\\n```\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0, right = 0, sumOfCurrentWindow = 0;\\n        int res = INT_MAX;\\n\\n        for(right = 0; right < nums.size(); right++) {\\n            sumOfCurrentWindow += nums[right];\\n\\n            while (sumOfCurrentWindow >= target) {\\n                res = min(res, right - left + 1);\\n                sumOfCurrentWindow -= nums[left];\\n                left++;\\n            }\\n        }\\n\\n        return res == INT_MAX ? 0 : res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int left = 0, right = 0, sumOfCurrentWindow = 0;\\n        int res = Integer.MAX_VALUE;\\n\\n        for(right = 0; right < nums.length; right++) {\\n            sumOfCurrentWindow += nums[right];\\n\\n            while (sumOfCurrentWindow >= target) {\\n                res = Math.min(res, right - left + 1);\\n                sumOfCurrentWindow -= nums[left++];\\n            }\\n        }\\n\\n        return res == Integer.MAX_VALUE ? 0 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724895,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n = (int)nums.size();\\n        int sum = 0, j = 0;\\n        int res = INT_MAX;\\n        \\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            while (sum >= target) {\\n                res = min(res, i - j + 1);\\n                sum -= nums[j++];\\n            }\\n        }\\n        \\n        return res == INT_MAX ? 0 : res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n = (int)nums.size();\\n        int sum = 0, j = 0;\\n        int res = INT_MAX;\\n        \\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            while (sum >= target) {\\n                res = min(res, i - j + 1);\\n                sum -= nums[j++];\\n            }\\n        }\\n        \\n        return res == INT_MAX ? 0 : res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724848,
                "title": "simple-c-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        \\n        int i=0,j=0;\\n        int ans=INT_MAX;\\n        int t=0;\\n        int n=nums.size();\\n        while(j<n && i<n){\\n            t+=nums[j];\\n            while(t>=target && i<=j)\\n            {\\n                ans=min(ans,j-i+1);\\n                t-=nums[i];\\n                i++;\\n            }\\n            j++;\\n\\n        }\\n        if(ans==INT_MAX) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        \\n        int i=0,j=0;\\n        int ans=INT_MAX;\\n        int t=0;\\n        int n=nums.size();\\n        while(j<n && i<n){\\n            t+=nums[j];\\n            while(t>=target && i<=j)\\n            {\\n                ans=min(ans,j-i+1);\\n                t-=nums[i];\\n                i++;\\n            }\\n            j++;\\n\\n        }\\n        if(ans==INT_MAX) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724522,
                "title": "min-subarray-length-java-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the minimal length of a subarray whose sum is greater than or equal to the target, we can use the sliding window technique. By maintaining two pointers, left and right, we can keep track of the current subarray. We start with the window size of 1 and move the right pointer to the right until the sum of the elements in the window is greater than or equal to the target. Then, we update the minimum subarray length if necessary and move the left pointer to the right to shrink the window. We repeat this process until the right pointer reaches the end of the array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. Initialize the left pointer to 0, the right pointer to 0, the current sum to 0, and the minimum subarray length to infinity.\\n    Iterate while the right pointer is less than the length of  the array:\\n\\n    2.Add the element at the right pointer to the current sum.\\n    While the current sum is greater than or equal to the target:\\n    Update the minimum subarray length if necessary.\\n    Subtract the element at the left pointer from the current sum.\\n\\n 3  Move the left pointer to the right.\\n    Move the right pointer to the right.\\n    If the minimum subarray length is still infinity, return 0; otherwise, return the minimum subarray length.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int left = 0;\\n        int sum = 0;\\n        int minLength = Integer.MAX_VALUE;\\n\\n        for (int right = 0; right < n; right++) {\\n            sum += nums[right];\\n\\n            while (sum >= target) {\\n                minLength = Math.min(minLength, right - left + 1);\\n                sum -= nums[left];\\n                left++;\\n            }\\n        }\\n\\n        return (minLength != Integer.MAX_VALUE) ? minLength : 0;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int left = 0;\\n        int sum = 0;\\n        int minLength = Integer.MAX_VALUE;\\n\\n        for (int right = 0; right < n; right++) {\\n            sum += nums[right];\\n\\n            while (sum >= target) {\\n                minLength = Math.min(minLength, right - left + 1);\\n                sum -= nums[left];\\n                left++;\\n            }\\n        }\\n\\n        return (minLength != Integer.MAX_VALUE) ? minLength : 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724506,
                "title": "easy-c-python-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code finds the minimum length of a subarray in an array \\'nums\\' whose sum is greater than or equal to \\'target\\'. It uses a sliding window approach to iteratively adjust the window size and track the minimum length. The minimum length is returned, or 0 if no valid subarray is found.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n#  C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n        int wsum=0, l=0, r;\\n        int ans=INT_MAX;\\n        for(r=0; r<n; r++){\\n            wsum+=nums[r];\\n            while(wsum>=target){\\n                wsum-=nums[l];\\n                ans=min(ans, r-l+1);\\n                l++;\\n            }\\n        }\\n        return ans==INT_MAX? 0: ans;\\n    }\\n};\\n```\\n# Python code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        n=len(nums)\\n        wsum=0\\n        l=0\\n        ans=2**31\\n        for r in range(n):\\n            wsum+=nums[r]\\n            while wsum>=target:\\n                wsum-=nums[l]\\n                ans=min(ans, r-l+1)\\n                l+=1\\n        if ans==2**31:\\n            return 0\\n        else:\\n            return ans\\n```\\n# Code with Explanation in Comments\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        # Calculate the length of the input array\\n        n = len(nums)\\n        \\n        # Initialize variables\\n        wsum = 0   # current window sum\\n        l = 0      # left pointer of the sliding window\\n        ans = 2**31  # answer (initialized with a large value)\\n        \\n        # Iterate over each element in the array\\n        for r in range(n):\\n            # Add the current element to the window sum\\n            wsum += nums[r]\\n            \\n            # Check if the window sum is greater than or equal to the target\\n            while wsum >= target:\\n                # Update the answer if the current window size is smaller\\n                ans = min(ans, r - l + 1)\\n                \\n                # Remove the leftmost element from the window\\n                wsum -= nums[l]\\n                \\n                # Move the left pointer to the right\\n                l += 1\\n        \\n        # If no valid window was found, return 0. Otherwise, return the minimum window size.\\n        if ans == 2**31:\\n            return 0\\n        else:\\n            return ans\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n        int wsum=0, l=0, r;\\n        int ans=INT_MAX;\\n        for(r=0; r<n; r++){\\n            wsum+=nums[r];\\n            while(wsum>=target){\\n                wsum-=nums[l];\\n                ans=min(ans, r-l+1);\\n                l++;\\n            }\\n        }\\n        return ans==INT_MAX? 0: ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        n=len(nums)\\n        wsum=0\\n        l=0\\n        ans=2**31\\n        for r in range(n):\\n            wsum+=nums[r]\\n            while wsum>=target:\\n                wsum-=nums[l]\\n                ans=min(ans, r-l+1)\\n                l+=1\\n        if ans==2**31:\\n            return 0\\n        else:\\n            return ans\\n```\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        # Calculate the length of the input array\\n        n = len(nums)\\n        \\n        # Initialize variables\\n        wsum = 0   # current window sum\\n        l = 0      # left pointer of the sliding window\\n        ans = 2**31  # answer (initialized with a large value)\\n        \\n        # Iterate over each element in the array\\n        for r in range(n):\\n            # Add the current element to the window sum\\n            wsum += nums[r]\\n            \\n            # Check if the window sum is greater than or equal to the target\\n            while wsum >= target:\\n                # Update the answer if the current window size is smaller\\n                ans = min(ans, r - l + 1)\\n                \\n                # Remove the leftmost element from the window\\n                wsum -= nums[l]\\n                \\n                # Move the left pointer to the right\\n                l += 1\\n        \\n        # If no valid window was found, return 0. Otherwise, return the minimum window size.\\n        if ans == 2**31:\\n            return 0\\n        else:\\n            return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459741,
                "title": "detailed-explanation-using-sliding-window-c-code-beats-85",
                "content": "# Intuition\\nWe see that we have to give the minimum length of the subarray with sum as target. We can use the concept of a variable sliding window as the window size is not defined but the sum of the subarray is defined.\\n\\n# Approach\\nWe start by taking window_sum = 0 and two pointers window_start and window_end and initialize them by 0. We also take a min_length = INT_MAX since we have to find the minimum length subarray. While the window end is less than the size of the array we add it to the window_sum since that is what the window size is. If(window_sum < target) then we will increment the window end since we have to add and check for the target. Else if(window_sum >= target) then while it happens we will update the min_length and decrease the window_sum from the element at window_start and increment the window_start. After this we will increment the window_end to shift the window.\\nThen simply return the min_length.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int window_sum = 0;\\n        int n = nums.size();\\n        int window_start=0, window_end=0;\\n        int min_length = INT_MAX;\\n        while(window_end < n){\\n            window_sum += nums[window_end];\\n            if(window_sum < target){\\n                window_end++;\\n            }\\n            else if(window_sum >= target){\\n                while(window_sum >= target){\\n                    min_length = min(min_length, window_end - window_start + 1);\\n                    window_sum = window_sum - nums[window_start];\\n                    window_start++;\\n                }\\n                window_end++;\\n            }\\n        }\\n        if(min_length == INT_MAX){\\n            return 0;\\n        }\\n        return min_length;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int window_sum = 0;\\n        int n = nums.size();\\n        int window_start=0, window_end=0;\\n        int min_length = INT_MAX;\\n        while(window_end < n){\\n            window_sum += nums[window_end];\\n            if(window_sum < target){\\n                window_end++;\\n            }\\n            else if(window_sum >= target){\\n                while(window_sum >= target){\\n                    min_length = min(min_length, window_end - window_start + 1);\\n                    window_sum = window_sum - nums[window_start];\\n                    window_start++;\\n                }\\n                window_end++;\\n            }\\n        }\\n        if(min_length == INT_MAX){\\n            return 0;\\n        }\\n        return min_length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355816,
                "title": "easy-solution-c-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nadd the values untill sum >=target \\nif you get sum>=target then check if it is possible to decrease the length \\ndecrease the length if sum>=target then add next values of nums and check for the same \\n\\nevery time when you get sum>=target update the ans with minimum length \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n       int sum=0;\\n       int ans=n+1;\\n       int j=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            if(sum>=target){\\n                ans=min(ans,(i-j+1));\\n                while(sum>=target){\\n                    sum-=nums[j];\\n                   \\n                    ans=min(ans,(i-j+1));\\n                    j++;\\n                }\\n             \\n            }\\n \\n        }\\n        if(ans==n+1) ans=0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n=nums.size();\\n       int sum=0;\\n       int ans=n+1;\\n       int j=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            if(sum>=target){\\n                ans=min(ans,(i-j+1));\\n                while(sum>=target){\\n                    sum-=nums[j];\\n                   \\n                    ans=min(ans,(i-j+1));\\n                    j++;\\n                }\\n             \\n            }\\n \\n        }\\n        if(ans==n+1) ans=0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230675,
                "title": "binary-search-intuition-and-solution",
                "content": "# Intuition\\nSums array is strictly increasing because all elements of nums will be positive. Since sums array is already sorted, we can apply binary search instead of linear search to find the ending index of a valid window.\\n# Complexity\\n- Time complexity: $O(n)$ to compute sums. $O(n)$ to iterate over sums and $O(\\\\log n)$ to conduct binary search in each iteration. The overall time complexity is $O(n \\\\log n)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ to store sums array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        if target == 0 or not len(nums):\\n            return 0\\n\\n        n = len(nums)\\n        minLen = float(\"inf\")\\n        sums = [nums[0]]\\n\\n        for i in range(1, n):\\n            sums.append(sums[i-1] + nums[i])\\n\\n        for i in range(0, n):\\n            left = i\\n            right = n-1\\n            newTarget = target + sums[i] - nums[i]\\n\\n            while left <= right:\\n                mid = (left + right) // 2\\n                if sums[mid] < newTarget:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n            if left < n and sums[left] >= newTarget:\\n                minLen = min(minLen, left - i + 1)\\n\\n        return 0 if minLen == float(\"inf\") else minLen\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        if target == 0 or not len(nums):\\n            return 0\\n\\n        n = len(nums)\\n        minLen = float(\"inf\")\\n        sums = [nums[0]]\\n\\n        for i in range(1, n):\\n            sums.append(sums[i-1] + nums[i])\\n\\n        for i in range(0, n):\\n            left = i\\n            right = n-1\\n            newTarget = target + sums[i] - nums[i]\\n\\n            while left <= right:\\n                mid = (left + right) // 2\\n                if sums[mid] < newTarget:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n            if left < n and sums[left] >= newTarget:\\n                minLen = min(minLen, left - i + 1)\\n\\n        return 0 if minLen == float(\"inf\") else minLen\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210155,
                "title": "c-fast-and-easy-solution-sliding-window",
                "content": "Upvote Please!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int tar, vector<int>& nums) {\\n        long long sum=0;\\n        int i=0,j=0, ans=INT_MAX;\\n        int n = nums.size();\\n        while(j<n and i<n)\\n        {\\n            while(sum<tar and j<n)\\n            {\\n                sum+=nums[j];\\n                j++;\\n            }\\n            if(sum>=tar)\\n            {\\n                ans=min(ans, j-i);\\n                sum-=nums[i];\\n                i++;\\n                if(sum>=tar)\\n                ans=min(ans, j-i);\\n            }\\n        }\\n        while(i<n and sum>tar and sum-nums[i]>=tar)\\n        {sum-=nums[i]; i++; ans=min(ans, j-i);}\\n        \\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int tar, vector<int>& nums) {\\n        long long sum=0;\\n        int i=0,j=0, ans=INT_MAX;\\n        int n = nums.size();\\n        while(j<n and i<n)\\n        {\\n            while(sum<tar and j<n)\\n            {\\n                sum+=nums[j];\\n                j++;\\n            }\\n            if(sum>=tar)\\n            {\\n                ans=min(ans, j-i);\\n                sum-=nums[i];\\n                i++;\\n                if(sum>=tar)\\n                ans=min(ans, j-i);\\n            }\\n        }\\n        while(i<n and sum>tar and sum-nums[i]>=tar)\\n        {sum-=nums[i]; i++; ans=min(ans, j-i);}\\n        \\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180489,
                "title": "c-code-sliding-window",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        ll ans = 10000000000;\\n        int n = nums.size();\\n        ll l = 0, r = 0;\\n        ll sm = 0;\\n        while (true)\\n        {\\n            if (sm < target)\\n            {\\n                if (r == n)\\n                    break;\\n                sm += nums[r];\\n                r++;\\n            }\\n            else\\n            {\\n                ans = min(ans, r - l);\\n                sm -= nums[l];\\n                l++;\\n            }\\n            cout << l << \" \" << r << endl;\\n        }\\n        if (ans == 10000000000)\\n            return 0;\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/89279f06-2c2f-49d9-a005-2882bec8788d_1677408338.9247246.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        ll ans = 10000000000;\\n        int n = nums.size();\\n        ll l = 0, r = 0;\\n        ll sm = 0;\\n        while (true)\\n        {\\n            if (sm < target)\\n            {\\n                if (r == n)\\n                    break;\\n                sm += nums[r];\\n                r++;\\n            }\\n            else\\n            {\\n                ans = min(ans, r - l);\\n                sm -= nums[l];\\n                l++;\\n            }\\n            cout << l << \" \" << r << endl;\\n        }\\n        if (ans == 10000000000)\\n            return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3167393,
                "title": "easy-sliding-window-maximum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int i=0,j=0,sum=0,mn=INT_MAX,flag=0;\\n        while(j<=nums.size()-1){\\n            sum+=nums[j];\\n            if(sum>=target){\\n                int x=j-i+1;\\n                flag=1;\\n                mn=min(mn,x);\\n         sum-=nums[i];\\n         i++;}\\n         while(sum>=target){\\n             mn=min(mn,j-i+1);\\n             sum-=nums[i];\\n             i++;\\n         }\\n         j++;\\n        }\\n        if(flag==0) return 0;\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int i=0,j=0,sum=0,mn=INT_MAX,flag=0;\\n        while(j<=nums.size()-1){\\n            sum+=nums[j];\\n            if(sum>=target){\\n                int x=j-i+1;\\n                flag=1;\\n                mn=min(mn,x);\\n         sum-=nums[i];\\n         i++;}\\n         while(sum>=target){\\n             mn=min(mn,j-i+1);\\n             sum-=nums[i];\\n             i++;\\n         }\\n         j++;\\n        }\\n        if(flag==0) return 0;\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094090,
                "title": "c-simple-solutions-2-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# This Solution I wrote today \\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int k, vector<int>& nums) {\\n        long  sum=0;\\n        int ans=INT_MAX,j=0,i=0;\\n        int n=nums.size();\\n        \\n        while(i<n){\\n            sum+=nums[i++];\\n            while(sum>=k)\\n            {\\n                ans=min(ans,i-j);\\n                sum-=nums[j++]; }\\n             }\\n\\n  if(ans==INT_MAX){return 0;}\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# This Solution I wrote  when I started coding in january \\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int k, vector<int>& nums) {\\n        long int sum=0;\\n        int m=INT_MAX,j=0,i=0;\\n        int n=nums.size();\\n        \\n        while(i<n)\\n               {\\n               if(sum<k){\\n                     sum+=nums[i++];\\n                } // END OF If\\n               if(sum==k)\\n                {\\n                 m=min(m,i-j);\\n                 sum+=nums[i++];\\n                } // END OF If\\n          while(sum>=k&&j<n)\\n                  {\\n                    m=min(m,i-j);\\n                    sum-=nums[j++];\\n                }//inner While\\n    \\n        } //outer While\\n\\n   if(m==INT_MAX){return 0;}\\n\\n        return m;\\n    }\\n};\\n```\\nYou can see the difference that\\'s what practice can do for you.\\n# keep practicing keep coding GOOD LUCK\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int k, vector<int>& nums) {\\n        long  sum=0;\\n        int ans=INT_MAX,j=0,i=0;\\n        int n=nums.size();\\n        \\n        while(i<n){\\n            sum+=nums[i++];\\n            while(sum>=k)\\n            {\\n                ans=min(ans,i-j);\\n                sum-=nums[j++]; }\\n             }\\n\\n  if(ans==INT_MAX){return 0;}\\n\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int k, vector<int>& nums) {\\n        long int sum=0;\\n        int m=INT_MAX,j=0,i=0;\\n        int n=nums.size();\\n        \\n        while(i<n)\\n               {\\n               if(sum<k){\\n                     sum+=nums[i++];\\n                } // END OF If\\n               if(sum==k)\\n                {\\n                 m=min(m,i-j);\\n                 sum+=nums[i++];\\n                } // END OF If\\n          while(sum>=k&&j<n)\\n                  {\\n                    m=min(m,i-j);\\n                    sum-=nums[j++];\\n                }//inner While\\n    \\n        } //outer While\\n\\n   if(m==INT_MAX){return 0;}\\n\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068865,
                "title": "binary-search-prefix-sum-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int ans = INT_MAX;\\n        int n = nums.size();\\n\\n        for(int i = 1 ; i < n ; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i]-target >= 0){\\n                int ind = upper_bound(nums.begin(), nums.end(), nums[i]-target) - nums.begin();\\n                ans = min(ans, i-ind+1);\\n            }\\n        }\\n\\n        return ans == INT_MAX ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int ans = INT_MAX;\\n        int n = nums.size();\\n\\n        for(int i = 1 ; i < n ; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i]-target >= 0){\\n                int ind = upper_bound(nums.begin(), nums.end(), nums[i]-target) - nums.begin();\\n                ans = min(ans, i-ind+1);\\n            }\\n        }\\n\\n        return ans == INT_MAX ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873750,
                "title": "o-n-log-n-java-solution-with-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int lo = 1;\\n        int hi = nums.length;\\n        int result = 0;\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo)/2;\\n            if(isPossible(nums, target, mid)){\\n                hi = mid - 1;\\n                result = mid;\\n            }\\n            else lo = mid + 1;\\n        }\\n        return result;\\n    }\\n    boolean isPossible(int[] nums, int target, int size) {\\n        int sum = 0;\\n        int i = 0, j = 0;\\n        for(i = 0; i < size; i++) {\\n            sum += nums[i];\\n            if(sum >= target) return true;\\n        }\\n        while(i < nums.length) {\\n            sum = sum + nums[i++] - nums[j++];\\n            if(sum >= target)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int lo = 1;\\n        int hi = nums.length;\\n        int result = 0;\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo)/2;\\n            if(isPossible(nums, target, mid)){\\n                hi = mid - 1;\\n                result = mid;\\n            }\\n            else lo = mid + 1;\\n        }\\n        return result;\\n    }\\n    boolean isPossible(int[] nums, int target, int size) {\\n        int sum = 0;\\n        int i = 0, j = 0;\\n        for(i = 0; i < size; i++) {\\n            sum += nums[i];\\n            if(sum >= target) return true;\\n        }\\n        while(i < nums.length) {\\n            sum = sum + nums[i++] - nums[j++];\\n            if(sum >= target)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799126,
                "title": "easy-python-solution-sliding-window-prefix-sum",
                "content": "This is a simple solution that is easy to understand. The steps are as followed :\\n1, do the prefix sum of the array \\n2, add zero in front of the array to make the next process easier\\n3, use two pointers to go through the array \\n4, when ever the sum of the subarray if equal to or greater than the target move the left\\npointer forward because we are looking for the shortest subarray length\\n5. stop the loop when the right pointer reachs the end of the array.\\n\\nclass Solution:\\n    \\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        \\n        #prefix sum\\n        for idx in range(1, len(nums)):\\n            nums[idx] += nums[idx-1]\\n        nums = [0]+nums\\n        \\n        left, right = 1, 1\\n        min_len = len(nums)+1\\n        \\n        for right in range(1, len(nums)):\\n            while nums[right]-nums[left-1] >= target:\\n                min_len = min(min_len, right-left+1)\\n                left+=1\\n        \\n        if min_len == len(nums)+1:\\n            return 0\\n        return min_len",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "This is a simple solution that is easy to understand. The steps are as followed :\\n1, do the prefix sum of the array \\n2, add zero in front of the array to make the next process easier\\n3, use two pointers to go through the array \\n4, when ever the sum of the subarray if equal to or greater than the target move the left\\npointer forward because we are looking for the shortest subarray length\\n5. stop the loop when the right pointer reachs the end of the array.\\n\\nclass Solution:\\n    \\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        \\n        #prefix sum\\n        for idx in range(1, len(nums)):\\n            nums[idx] += nums[idx-1]\\n        nums = [0]+nums\\n        \\n        left, right = 1, 1\\n        min_len = len(nums)+1\\n        \\n        for right in range(1, len(nums)):\\n            while nums[right]-nums[left-1] >= target:\\n                min_len = min(min_len, right-left+1)\\n                left+=1\\n        \\n        if min_len == len(nums)+1:\\n            return 0\\n        return min_len",
                "codeTag": "Java"
            },
            {
                "id": 2687737,
                "title": "c-all-possible-solutions-prefix-array-binary-search-sliding-window-2-pointer",
                "content": "**1. Prefix Array Solution -> O(N^2)**\\n```\\nint minSubArrayLen(int target, vector<int> &nums)\\n{\\n    int len = INT_MAX;\\n    vector<int> prefix(nums.size() + 1, 0);\\n\\n    for (int i = 0; i < nums.size(); i++){\\n        prefix[i + 1] = prefix[i] + nums[i];\\n    }\\n    int previndex = 0;\\n    for (int i = 0; i < prefix.size(); i++){\\n        if (prefix[i] >= target){\\n            while (prefix[previndex] <= prefix[i] - target){\\n                previndex++;\\n            }\\n            len = min(len, i - previndex + 1);\\n        }\\n    }\\n    return (len < INT_MAX) ? len : 0;\\n}\\n```\\n\\n**2. Binary Search on Answer -> O(N*log(N))**\\n*In this solution we are using binary search on all possible answers we can have from 1 to n  and  for each k (mid) checking if there exist any window of size k whose sum>=target or not*\\n```\\n//this function is to check if there exist any window of size k whose sum>= target\\nbool windowExist(vector<int> &nums, int k, int target){\\n    int sum = 0;\\n    for (int i = 0; i < k; i++){\\n        sum += nums[i];\\n    }\\n    if (sum >= target)\\n        return true;\\n    int left = 0;\\n    int curr = k;\\n    while (curr < nums.size()){\\n        sum += nums[curr++];\\n        sum -= nums[left++];\\n        if (sum >= target){\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n//now we are applying binary search on all possible answers and trying to find minimum Len\\nint minSubArrayLen(int target, vector<int> &nums){\\n    int l = 0;\\n    int h = nums.size() + 1;\\n    bool flag = false;\\n    while (l < h){\\n        int mid = l + (h - l) / 2;\\n        if (windowExist(nums, mid, target)){\\n            flag = true;\\n            h = mid;\\n        }\\n        else{\\n            l = mid + 1;\\n        }\\n    }\\n    return (flag == true) ? l : 0;\\n}\\n```\\n\\n**3. Sliding Window/2 Pointer -> O(N)**\\n*in this technique we are maintaining two ptrs Left and right  when our sum becomes  >= target we are incrementing left ptr and checking if there exist another minimum length window of sum>= target inside it or not and stroring the min len in the answer*\\n\\n```\\nint minSubArrayLen(int target, vector<int> &nums)\\n{\\n    int len = INT_MAX;\\n    int left = 0, right = 0,sum = 0;\\n\\t\\n    while (right < nums.size()){\\n        sum += nums[right++];\\n        while (sum >= target){\\n            len = min(len, right - left);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (len < INT_MAX) ? len : 0;\\n}",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nint minSubArrayLen(int target, vector<int> &nums)\\n{\\n    int len = INT_MAX;\\n    vector<int> prefix(nums.size() + 1, 0);\\n\\n    for (int i = 0; i < nums.size(); i++){\\n        prefix[i + 1] = prefix[i] + nums[i];\\n    }\\n    int previndex = 0;\\n    for (int i = 0; i < prefix.size(); i++){\\n        if (prefix[i] >= target){\\n            while (prefix[previndex] <= prefix[i] - target){\\n                previndex++;\\n            }\\n            len = min(len, i - previndex + 1);\\n        }\\n    }\\n    return (len < INT_MAX) ? len : 0;\\n}\\n```\n```\\n//this function is to check if there exist any window of size k whose sum>= target\\nbool windowExist(vector<int> &nums, int k, int target){\\n    int sum = 0;\\n    for (int i = 0; i < k; i++){\\n        sum += nums[i];\\n    }\\n    if (sum >= target)\\n        return true;\\n    int left = 0;\\n    int curr = k;\\n    while (curr < nums.size()){\\n        sum += nums[curr++];\\n        sum -= nums[left++];\\n        if (sum >= target){\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n//now we are applying binary search on all possible answers and trying to find minimum Len\\nint minSubArrayLen(int target, vector<int> &nums){\\n    int l = 0;\\n    int h = nums.size() + 1;\\n    bool flag = false;\\n    while (l < h){\\n        int mid = l + (h - l) / 2;\\n        if (windowExist(nums, mid, target)){\\n            flag = true;\\n            h = mid;\\n        }\\n        else{\\n            l = mid + 1;\\n        }\\n    }\\n    return (flag == true) ? l : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652466,
                "title": "javascript-sliding-window-solution",
                "content": "```\\n/**\\n * @param {number} target\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSubArrayLen = function(target, nums) {\\n    \\n    \\n    let minSize = Infinity;\\n    \\n    \\n    let slow = 0 , fast = 0;\\n    let counter = 0;\\n    while(fast !== nums.length){\\n        \\n        counter += nums[fast];\\n        \\n        while(counter >= target){\\n            \\n            minSize = Math.min(minSize, fast - slow + 1);\\n            counter -= nums[slow];\\n            slow++\\n        }\\n        \\n        fast++;\\n        \\n    }\\n    \\n    return minSize == Infinity ? 0 : minSize;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} target\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSubArrayLen = function(target, nums) {\\n    \\n    \\n    let minSize = Infinity;\\n    \\n    \\n    let slow = 0 , fast = 0;\\n    let counter = 0;\\n    while(fast !== nums.length){\\n        \\n        counter += nums[fast];\\n        \\n        while(counter >= target){\\n            \\n            minSize = Math.min(minSize, fast - slow + 1);\\n            counter -= nums[slow];\\n            slow++\\n        }\\n        \\n        fast++;\\n        \\n    }\\n    \\n    return minSize == Infinity ? 0 : minSize;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648645,
                "title": "sliding-window-cpp",
                "content": "**Approach**\\n* Search for a subarray whose sum of all elements is greater than orr equal to given target\\n\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0, right=0, n=nums.size() ;\\n        int currSum=0, minLen= INT_MAX ;\\n        bool found =false ;\\n        \\n        while(right < n){\\n            currSum += nums[right] ;\\n            \\n            while(currSum >= target){\\n                found =true ;\\n                minLen = min(minLen, right-left+1) ;\\n                currSum -= nums[left] ;\\n                left++ ;\\n            }\\n            \\n            right++ ;\\n        }\\n        \\n        if(!found)\\n            return 0 ;\\n        return minLen ;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0, right=0, n=nums.size() ;\\n        int currSum=0, minLen= INT_MAX ;\\n        bool found =false ;\\n        \\n        while(right < n){\\n            currSum += nums[right] ;\\n            \\n            while(currSum >= target){\\n                found =true ;\\n                minLen = min(minLen, right-left+1) ;\\n                currSum -= nums[left] ;\\n                left++ ;\\n            }\\n            \\n            right++ ;\\n        }\\n        \\n        if(!found)\\n            return 0 ;\\n        return minLen ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600317,
                "title": "using-recursion-c",
                "content": "here the problem statement says minimal subarray having sum same or greater than the target and my solution giving answer 7 to this case \\n213\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\nbut answer is showing 8 not understanding how and why??\\n\\nclass Solution {\\npublic:\\n    int test(int i,int target,vector<int> &nums, vector<int> &ds, int ans)\\n    {\\n        \\n        if(target == 0)\\n                return ds.size();\\n        \\n         if(target < 0)\\n            return ds.size();\\n        if(i >= nums.size())\\n            return INT_MAX;\\n\\t\\t\\t\\n        ds.push_back(nums[i]);\\n        int l = test(i+1,target-nums[i],nums,ds,ans);\\n        ds.pop_back();\\n        int r = test(i+1,target,nums,ds,ans);\\n        \\n        return min(l,r);\\n    }\\n    \\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        vector<int> ds;\\n        int ans = INT_MAX;\\n       int res = test(0,target,nums,ds,ans);\\n        \\n        return res == INT_MAX?0:res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int test(int i,int target,vector<int> &nums, vector<int> &ds, int ans)\\n    {\\n        \\n        if(target == 0)\\n                return ds.size();\\n        \\n         if(target < 0)\\n            return ds.size();\\n        if(i >= nums.size())\\n            return INT_MAX;\\n\\t\\t\\t\\n        ds.push_back(nums[i]);\\n        int l = test(i+1,target-nums[i],nums,ds,ans);\\n        ds.pop_back();\\n        int r = test(i+1,target,nums,ds,ans);\\n        \\n        return min(l,r);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2418287,
                "title": "100-faster-easy-to-understand-java-solution",
                "content": "```\\n    public int minSubArrayLen(int target, int[] arr) {\\n        int i=0;\\n        int j=0;\\n        int sum=0;\\n        int min = Integer.MAX_VALUE;\\n\\n        while(i<arr.length && j<arr.length){\\n            sum += arr[j++];\\n            while(sum>=target){\\n                int length = j-i;\\n                min = Math.min(min,length);\\n                sum -= arr[i++];\\n            }\\n        }\\n\\n        if(min == Integer.MAX_VALUE){\\n            return 0;\\n        }\\n        return min;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n    public int minSubArrayLen(int target, int[] arr) {\\n        int i=0;\\n        int j=0;\\n        int sum=0;\\n        int min = Integer.MAX_VALUE;\\n\\n        while(i<arr.length && j<arr.length){\\n            sum += arr[j++];\\n            while(sum>=target){\\n                int length = j-i;\\n                min = Math.min(min,length);\\n                sum -= arr[i++];\\n            }\\n        }\\n\\n        if(min == Integer.MAX_VALUE){\\n            return 0;\\n        }\\n        return min;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2342846,
                "title": "c-java-python-easy-to-understand-sliding-window",
                "content": "\\u2714 Time complexity: O(n)\\n\\u2714 Space complexity: O(1)\\n\\nImplementations -\\n\\n\\u2611 C++:\\n\\n```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n = nums.size(), currentSum = 0, minSubArr = INT_MAX;\\n        int i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            currentSum += nums[j];\\n            while(currentSum >= target) {\\n                minSubArr = min(minSubArr, j - i + 1);\\n                currentSum -= nums[i];\\n                i++;\\n            }\\n        }\\n        return minSubArr == INT_MAX ? 0 : minSubArr; \\n    }\\n};\\n```\\n\\n\\n\\u2611 Python:\\n\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        n, currentSum, minSubArr, i = len(nums), 0, 1e7, 0\\n        for j in range(n):\\n            currentSum += nums[j];\\n            while currentSum >= target: \\n                minSubArr = min(minSubArr, j - i + 1);\\n                currentSum -= nums[i];\\n                i += 1\\n        if minSubArr == 1e7: return 0\\n        else: return minSubArr\\n```\\n\\n\\n\\u2611 Java:\\n\\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length, currentSum = 0, minSubArr = Integer.MAX_VALUE;\\n        int i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            currentSum += nums[j];\\n            while(currentSum >= target) {\\n                minSubArr = Math.min(minSubArr, j - i + 1);\\n                currentSum -= nums[i];\\n                i++;\\n            }\\n        }\\n        return minSubArr == Integer.MAX_VALUE ? 0 : minSubArr;\\n    }\\n}\\n```\\n\\n\\n\\uD83D\\uDCAF Thanks for reading.\\nAn upvote would be appreciated! ^_^",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int n = nums.size(), currentSum = 0, minSubArr = INT_MAX;\\n        int i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            currentSum += nums[j];\\n            while(currentSum >= target) {\\n                minSubArr = min(minSubArr, j - i + 1);\\n                currentSum -= nums[i];\\n                i++;\\n            }\\n        }\\n        return minSubArr == INT_MAX ? 0 : minSubArr; \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        n, currentSum, minSubArr, i = len(nums), 0, 1e7, 0\\n        for j in range(n):\\n            currentSum += nums[j];\\n            while currentSum >= target: \\n                minSubArr = min(minSubArr, j - i + 1);\\n                currentSum -= nums[i];\\n                i += 1\\n        if minSubArr == 1e7: return 0\\n        else: return minSubArr\\n```\n```\\nclass Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length, currentSum = 0, minSubArr = Integer.MAX_VALUE;\\n        int i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            currentSum += nums[j];\\n            while(currentSum >= target) {\\n                minSubArr = Math.min(minSubArr, j - i + 1);\\n                currentSum -= nums[i];\\n                i++;\\n            }\\n        }\\n        return minSubArr == Integer.MAX_VALUE ? 0 : minSubArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323795,
                "title": "c-binary-search-o-nlogn-solution-with-explanation",
                "content": "***//BINARY SEARCH SOLUTION T.C=O(NlogN);\\n//APPROACH\\n// we all know basic binary search but here the trick is to find the target.\\n// lets say sumarr for the element is  [2,5,6,8,12,15] it is sorted so we can aplly binary search.\\n// Now what we have to find? lets see so we have to find out the min subarry such that its sum is greater than or equal to  given target.\\n// we can say that our final target is sumarr[j]-sumarr[i]>=target. \\n//  [2,5,6,8,12,15] here sumarr[5]-sumarr[0]=15-2=13>=7(target) so j-i i.e 5-0 is our one answer.\\n// if we go in this way than for each element i have to serach in the array for sumarr[j]-sumarr[i]>=target that will make the time complexity O(N^2).\\n//so for searching purpose we will use binary search for each element .\\n  // [2,5,6,8,12,15] \\n    //low =i and high=n-1 =>mid=low+(high-low)/2\\n    // low=0            high=5           mid=2\\n    // Now apply the condition here our j will be mid element i.e sumarr[mid]-sumarr[i]>=s then we store the answer and proceed high=mid-1 else low=mid+1;\\n    // And our answer will be mid-i like above i.e j-i.***\\n    \\n   \\n*\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n   int minSubArrayLen(int target, vector<int>& nums) {\\n   \\n        int n=nums.size();\\n        int ans=INT_MAX;\\n        vector<int>sumarr;\\n        int sumt=0;\\n        for(int i=0;i<n;i++){\\n            sumt+=nums[i];\\n           \\n            sumarr.push_back(sumt);\\n            \\n        }\\n        \\n      \\n        if(target>sumt)return 0;\\n        \\n        //Traverse the array \\n     \\n        for(int i=0;i<n;i++){  \\n            if(sumarr[i]>=target)ans=min(ans,i+1);//we are using i+1 since the minmum length for the sum will be two elements.\\n            //now use the binary search to find the sumarr[j]-sumarr[i]>=target;\\n            \\n            int low=i;\\n            int high=n-1; //we have to find index high;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                \\n                if(sumarr[mid]-sumarr[i]>=target){\\n                    ans=min(ans,mid-i);\\n                    high=mid-1;\\n                }\\n                else{\\n                    low=mid+1;\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        \\n       \\n       return ans == INT_MAX ? 0 : ans;\\n        \\n        \\n    }\\n};\\n\\n\\n**UPVOTE THE ANSWER IF HELPFUL**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n   int minSubArrayLen(int target, vector<int>& nums) {\\n   \\n        int n=nums.size();\\n        int ans=INT_MAX;\\n        vector<int>sumarr;\\n        int sumt=0;\\n        for(int i=0;i<n;i++){\\n            sumt+=nums[i];\\n           \\n            sumarr.push_back(sumt);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2236481,
                "title": "100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public int minSubArrayLen(int t, int[] num) {\\n        int i,n=num.length,sum=0,lptr=0,len=Integer.MAX_VALUE;\\n        for(i=0;i<n;i++){\\n            sum+=num[i];\\n            while(sum>=t){\\n                len=Math.min(len,i-lptr+1);\\n                sum-=num[lptr];\\n                lptr++;\\n            }\\n        }\\n        return len==Integer.MAX_VALUE?0:len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int t, int[] num) {\\n        int i,n=num.length,sum=0,lptr=0,len=Integer.MAX_VALUE;\\n        for(i=0;i<n;i++){\\n            sum+=num[i];\\n            while(sum>=t){\\n                len=Math.min(len,i-lptr+1);\\n                sum-=num[lptr];\\n                lptr++;\\n            }\\n        }\\n        return len==Integer.MAX_VALUE?0:len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228805,
                "title": "java-o-n",
                "content": "````    \\npublic int minSubArrayLen(int target, int[] nums) {\\n        int l=0;\\n        int r=0;\\n        int rl =0;\\n        int rr = 0;\\n        int len = Integer.MAX_VALUE;\\n        int sum =0;\\n        while(r<nums.length){\\n            sum += nums[r];\\n            while(sum>=target){\\n                if(len > r - l +1){\\n                    rl = l;\\n                    rr = r;\\n                    len = r - l +1;\\n                }\\n                sum-=nums[l];\\n                l++;\\n            }\\n            r++;\\n        }\\n        return len==Integer.MAX_VALUE? 0: rr-rl+1;\\n    }",
                "solutionTags": [],
                "code": "````    \\npublic int minSubArrayLen(int target, int[] nums) {\\n        int l=0;\\n        int r=0;\\n        int rl =0;\\n        int rr = 0;\\n        int len = Integer.MAX_VALUE;\\n        int sum =0;\\n        while(r<nums.length){\\n            sum += nums[r];\\n            while(sum>=target){\\n                if(len > r - l +1){\\n                    rl = l;\\n                    rr = r;\\n                    len = r - l +1;\\n                }\\n                sum-=nums[l];\\n                l++;\\n            }\\n            r++;\\n        }\\n        return len==Integer.MAX_VALUE? 0: rr-rl+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2146965,
                "title": "clean-sliding-window-o-n-detailed-explanation-intuition-building",
                "content": "# Intuition\\nWe need to look for the minimum contiguous subarray that is `>= target`.\\nThe brute force will be to generate all subarrays and then check if their sum is bigger or equal to the target. That will take `O(n^2)`. We can do better.\\n\\nSince we are looking for a `contiguous subarray` we can solve it using a sliding window.\\nThe explanation is as follows:\\n\\nAssume `x3+x4 >= target` and other elements are not big enough to impact the equation.\\nIf we have an array: `[x1,x2,x3,x4,x5]` we start by expanding our window until we reach the first time the sum is bigger (or equal) to the target, it will be `[x1,x2,x3,x4]`.\\nBut we know that `x3+x4 >= target` so whenever we reach a contiguous subarray that is bigger than target we can start reducing it\\'s left side until it no longer holds that property. So having `[x1,x2,x3,x4]` we will remove `[x1,x2]` and it will be become `[x3,x4]`. \\n\\nNext time we remove `x3` our subarray will become smaller than target, so we need to start adding elements again to check if we have a better solution.\\n\\n# Code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        n = len(nums)\\n        running_sum = 0\\n        left = 0\\n        best = float(\\'inf\\')\\n        \\n        for right in range(n):\\n            running_sum += nums[right]\\n            \\n            while running_sum >= target:\\n                best = min(best, right - left + 1)\\n                running_sum -= nums[left]\\n                left += 1\\n            \\n        return best if best != float(\\'inf\\') else 0\\n```\\n\\n# Complexity Analysis\\n### Time\\n`O(n)` - we are iterating over the array at most 2 times (left and right). `O(2n) => O(n)`\\n\\n### Space\\n`O(1)` - we only use constant variables as auxiliary",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        n = len(nums)\\n        running_sum = 0\\n        left = 0\\n        best = float(\\'inf\\')\\n        \\n        for right in range(n):\\n            running_sum += nums[right]\\n            \\n            while running_sum >= target:\\n                best = min(best, right - left + 1)\\n                running_sum -= nums[left]\\n                left += 1\\n            \\n        return best if best != float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098897,
                "title": "c-step-by-step-o-n-sliding-window",
                "content": "```\\n   int minSubArrayLen(int target, vector<int>& nums) {\\n        // Sliding Window\\n        // Time Complexity: O(N)\\n        // Space Complexity: O(N)\\n        \\n        // STEP 1: Increment our current sum with the number at the right\\n        // pointer as we slide that pointer across the nums array.\\n        \\n        // STEP 2: If the current sum is greater than or equal to \\n        // the target, this means our current window is valid. Check\\n        // to see if current window length is SMALLER than minimum\\n        // window length found so far, if so then update minimum window length\\n        \\n        // STEP 3: Decrement the current sum by the value where the left pointer\\n        // current is at. Then shift the left pointer to the right. Keep doing this\\n        // until the current sum is no longer greater than or equal to the target.\\n        \\n        // Repeat STEPS 1-3 until the right pointer reaches the end of the array\\n        \\n        // STEP 4: Before returning minimum length, check to see if it is still N+1\\n        // if so that means that a valid window lenght was NOT found so return 0\\n\\n        int N=nums.size();  // length of our nums array\\n        \\n        int l=0, r=0;       // window pointers\\n        \\n        int minLen=N+1;     // minimum window length found so far\\n                            // default value larger than N so we know if no \\n                            // valid minimum length was found\\n        \\n        int curSum=0,       // current sum \\n            curLen=N+1;     // current window length \\n        \\n        // O(N) - itereating through entire array once\\n        while( r<N)\\n        {\\n            curSum += nums[r];\\n            while( curSum >= target) \\n            {\\n                curLen=r-l+1;\\n                if( curLen<minLen)\\n                    minLen=curLen;\\n                curSum -= nums[l];\\n                ++l;\\n            }\\n            ++r;\\n        }\\n        return minLen==N+1 ? 0 : minLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n   int minSubArrayLen(int target, vector<int>& nums) {\\n        // Sliding Window\\n        // Time Complexity: O(N)\\n        // Space Complexity: O(N)\\n        \\n        // STEP 1: Increment our current sum with the number at the right\\n        // pointer as we slide that pointer across the nums array.\\n        \\n        // STEP 2: If the current sum is greater than or equal to \\n        // the target, this means our current window is valid. Check\\n        // to see if current window length is SMALLER than minimum\\n        // window length found so far, if so then update minimum window length\\n        \\n        // STEP 3: Decrement the current sum by the value where the left pointer\\n        // current is at. Then shift the left pointer to the right. Keep doing this\\n        // until the current sum is no longer greater than or equal to the target.\\n        \\n        // Repeat STEPS 1-3 until the right pointer reaches the end of the array\\n        \\n        // STEP 4: Before returning minimum length, check to see if it is still N+1\\n        // if so that means that a valid window lenght was NOT found so return 0\\n\\n        int N=nums.size();  // length of our nums array\\n        \\n        int l=0, r=0;       // window pointers\\n        \\n        int minLen=N+1;     // minimum window length found so far\\n                            // default value larger than N so we know if no \\n                            // valid minimum length was found\\n        \\n        int curSum=0,       // current sum \\n            curLen=N+1;     // current window length \\n        \\n        // O(N) - itereating through entire array once\\n        while( r<N)\\n        {\\n            curSum += nums[r];\\n            while( curSum >= target) \\n            {\\n                curLen=r-l+1;\\n                if( curLen<minLen)\\n                    minLen=curLen;\\n                curSum -= nums[l];\\n                ++l;\\n            }\\n            ++r;\\n        }\\n        return minLen==N+1 ? 0 : minLen;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936486,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minSubArrayLen(int t, int[] n) {\\n        int k=n.length,l=0,m=Integer.MAX_VALUE,s=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            s+=n[i];\\n            while(s>=t)\\n            {\\n                s-=n[l];\\n                l++;\\n                if(s<t)\\n                {\\n                    m=Math.min(m,(i-l+2));\\n                }\\n            }\\n        }\\n        return m==Integer.MAX_VALUE ? 0 : m;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSubArrayLen(int t, int[] n) {\\n        int k=n.length,l=0,m=Integer.MAX_VALUE,s=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            s+=n[i];\\n            while(s>=t)\\n            {\\n                s-=n[l];\\n                l++;\\n                if(s<t)\\n                {\\n                    m=Math.min(m,(i-l+2));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1935623,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minSubArrayLen(int t, int[] n) {\\n        int k=n.length,j=0,a=k+1;\\n        for(int i=0;i<k;i++)\\n        {\\n            t-=n[i];\\n            while(t<=0)\\n            {\\n                a=Math.min(a,i-j+1);\\n                t+=n[j];\\n                j++;\\n            }\\n        }\\n        k++;\\n        return a%k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSubArrayLen(int t, int[] n) {\\n        int k=n.length,j=0,a=k+1;\\n        for(int i=0;i<k;i++)\\n        {\\n            t-=n[i];\\n            while(t<=0)\\n            {\\n                a=Math.min(a,i-j+1);\\n                t+=n[j];\\n                j++;\\n            }\\n        }\\n        k++;\\n        return a%k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856325,
                "title": "go-single-loop-solution",
                "content": "```\\nfunc minSubArrayLen(target int, nums []int) int {\\n\\tj, sum, count, min := 0,0,0,math.MaxInt64\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] == target{\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\n\\t\\tif nums[i] + sum >= target {\\n\\t\\t\\tif count < min {\\n\\t\\t\\t\\tmin = count\\n\\t\\t\\t}\\n\\t\\t\\tsum -= nums[j]\\n\\t\\t\\tj++\\n\\t\\t\\ti--\\n\\t\\t\\tcount--\\n\\t\\t}else {\\n\\t\\t\\tsum += nums[i]\\n\\t\\t\\tcount ++\\n\\t\\t}\\n\\t}\\n\\n\\tif min == math.MaxInt64 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\treturn min+1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minSubArrayLen(target int, nums []int) int {\\n\\tj, sum, count, min := 0,0,0,math.MaxInt64\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] == target{\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\n\\t\\tif nums[i] + sum >= target {\\n\\t\\t\\tif count < min {\\n\\t\\t\\t\\tmin = count\\n\\t\\t\\t}\\n\\t\\t\\tsum -= nums[j]\\n\\t\\t\\tj++\\n\\t\\t\\ti--\\n\\t\\t\\tcount--\\n\\t\\t}else {\\n\\t\\t\\tsum += nums[i]\\n\\t\\t\\tcount ++\\n\\t\\t}\\n\\t}\\n\\n\\tif min == math.MaxInt64 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\treturn min+1\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564840,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1575005,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1958269,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1794131,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1565606,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1575480,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1835124,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1815853,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1958030,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1574426,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1564840,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1575005,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1958269,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1794131,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1565606,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1575480,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1835124,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1815853,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1958030,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1574426,
                "content": [
                    {
                        "username": "iryan",
                        "content": "\\n\\nFor array [1,2,3,4,5],  obviously, there is no sub array  whose sum equal 11.\\n\\nSo I think there answer is 0. \\n\\n\\nconsecutive sub array , right ?"
                    },
                    {
                        "username": "wafiiscool",
                        "content": "greater than OR equal too, it messed me up for a while too"
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "bro the statement says sum>=target ,hence 3 4 5 is the subarray\\n "
                    },
                    {
                        "username": "thakurjatinx",
                        "content": "yes there is no concecutive sub array for 11 in this array."
                    },
                    {
                        "username": "tamik",
                        "content": "[@_vedant](/_vedant) no, lol, it\\'s 12"
                    },
                    {
                        "username": "_vedant",
                        "content": "[3,4,5]>=11 "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@sparklingness](/sparklingness) oh Thanks. I need to read the questions carefully from now."
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "jonathanlamheihung",
                        "content": "![image](https://assets.leetcode.com/users/images/6321d165-cf53-4546-a74b-347324d48399_1615043089.1968756.png)\\nCould anyone tell me why the answer is 8 instead of 7?\\n\\nThanks so much!"
                    },
                    {
                        "username": "frissky",
                        "content": "[@SSHshadow2222](/SSHshadow2222)  Would you like to explain further please? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You are asked to find a **subarray** (contiguous elements), not a **subsequence**. "
                    },
                    {
                        "username": "Tejas_A_Kumar",
                        "content": "report it "
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "i am stuck on this  too,  i debugged this  and i got then closest sum of 213 with length 7 "
                    },
                    {
                        "username": "LisongHe",
                        "content": "This is what exactly what I am stuck with lol. I think we are correct and there are some problems with the answer. I tried code in from the solutions and they output 8 instead of 7 so I have no earthly idea what is going on. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "[@ae1ankudinov](/ae1ankudinov) I did exactly like that "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "[@KondratovRoman](/KondratovRoman) thanks for clarification"
                    },
                    {
                        "username": "ae1ankudinov",
                        "content": "Does it mean that we\\'re not allowed to sort the array?\\nBecause if we sort [12,28,83,4,25,26,25,2,25,25,25,12] => [2, 4, 12, 12, 25, 25, 25, 25, 25, 26, 28, 83].\\nAnd if we go from the end, we only need 7 elements to get sum of equal or greater than target."
                    },
                    {
                        "username": "XavierPivan",
                        "content": "83+28+26+25+25+25+25=237\\n\\nIt\\'s 7 positive integers so yes even doing in manually I wouldn\\'t find 8..."
                    },
                    {
                        "username": "sudianskyi",
                        "content": "[@ImmortalMerlin](/ImmortalMerlin) use sliding window"
                    },
                    {
                        "username": "KondratovRoman",
                        "content": "A *subarray* is a contiguous non-empty sequence of elements within an array"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "I got the same problem!\\nI used greedy algorithm, but I got wrong answer!"
                    },
                    {
                        "username": "DXDE443",
                        "content": "Good to know I\\'m not the only one that misunderstood the question."
                    },
                    {
                        "username": "rk_agrawal",
                        "content": "Even I had the same problem. Thanks for pointing it out on discussion section."
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "[@naomiacat95](/naomiacat95)  Exactly, I also got stuck here assuming elements can be non neighbors and wasted an hour to figure out why this testcase failed, When I hover on highlighted \"subarray\" text , it showed as \"contiguous sub array\" in info box. LOL, I should read the highlighted text properly. "
                    },
                    {
                        "username": "naomiacat95",
                        "content": "I got the same problem first.\\nBut later, I found out that the description  says -- return the minimal length of a \"contiguous subarray\"."
                    },
                    {
                        "username": "adarsh_sgh",
                        "content": ">  Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).\\n\\nThis is follow up or follow down ?"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Isn\\'t O(n) linear better then O(nlogn) ?\\nWhy should the follow up be more slower then the previous solution?"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "[@autf](/autf) Idk man I first came up with the n log n solution, and then the sliding window one."
                    },
                    {
                        "username": "autf",
                        "content": "Because the `Sliding Window` solution is easier to think and implement than `Prefix Sum + Binary Search` one."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am also confused about it my solution already beating 100% without using binary search."
                    },
                    {
                        "username": "ziyitony",
                        "content": "dude I got confused here too, might be O(n^2)..."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If I was the interviewer, I would probably ask this next to make sure the answer is not memorized/ templated. Having an intuitive understanding also helps me personally in remembering and applying it in some other problem.\\n\\nFrom my understanding the O(N) sliding window approach where neither pointer is ever decremented works because:\\n1. Increasing the size of the window keeps or breaks the \"constraint\" in one direction (the new sum can only be >= previous window)\\n2. Decreasing the size of the window keeps or breaks the constraint in the opposite direction of increasing it (the new sum can only be <= previous window)\\n\\nIf any of those don\\'t apply the solution wont work, which is the case for negative numbers (anything could happen with the sum depending on specific values). So for negative windows we must reset the end of the window to start of the window (so try window size 1,2,...n at each index) each time we increment start for an O(N^2) solution.\\n\\nDo you have a better way to articulate this?"
                    },
                    {
                        "username": "user2575jO",
                        "content": "I think this can still be solved in O(n) time, but also in O(n) memory, for negative numbers. Check it out: https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-o-n-time-memory/"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Yeah, there was this same problem I did with negative numbers but I used a running pre sum hash map to search the difference between target and pre sum in the previous results."
                    },
                    {
                        "username": "anya509",
                        "content": "Yes, with negative numbers - this could be an interesting problem."
                    },
                    {
                        "username": "vishalmangalassery",
                        "content": "for input \\n11\\n[1,2,3,4,5]\\n\\nThe expected answer is 3. But my solution is giving the answer as 0 since there is no such **contiguous sub array**  of length 3 that can sum to 11\\n\\n1+2+3 = 6\\n2+3+4 = 9\\n3+4+5 = 12\\n\\ncan someone help me understand this?"
                    },
                    {
                        "username": "aditid_27",
                        "content": "[@shivakrishnareddy17](/shivakrishnareddy17) 2 4 5 is not a subarray"
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "Read the question again. \\nreturn the minimal length of a\\nsubarray\\nwhose sum is greater than or equal to target"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "there is a possibility, that is 2+4+5 = 11\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "glebuzheg",
                        "content": "i have wrong answer after tests\\nInput\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nUse Testcase\\nOutput 7\\nExpected 8\\n\\nmy algorithm found subarray (12, 28, 83, 25, 26, 25, 25) sum = 224 which >= 213 and have 7 elemets.\\nI dont understend why is it wrong"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "because you sorted the elements and then you did this hence you got the answer as 7, but they wanted that the subarray should be continuous\\n"
                    },
                    {
                        "username": "nitinkmsri",
                        "content": "They want continuous elements"
                    },
                    {
                        "username": "pete88pete",
                        "content": "Wait if we found the solution in 0(n) time why would we want to do it in O(n log(n)) time?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using sliding window is more intuitive than using binary search to solve this problem.\\nThere are many approaches!"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@nethajirasineni](/nethajirasineni) That\\'s a good question, what my intuition says that whenever you have to optimize the answer and you have some constraint that your answer should support, then in that case (mostly) binary search solution always exists (but you have to also confirm the monotonicity of the problem).\\nIn this problem, you have to optimize or minimize the length of the subarray (which is my answer) and that subarray should have a sum of greater than or equal to \"target\" (which is my constraint over here).\\nMore formally, this type of problems come under the category of \"Binary Search on Answer\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@nethajirasineni](/nethajirasineni) save the prefix sum and apply binary search"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "how can you use the Binary search? explain me"
                    },
                    {
                        "username": "janacm",
                        "content": "![image](https://assets.leetcode.com/users/images/d2138da3-8c01-439d-aa3f-c2e6c99fe516_1601407102.1677907.png)\\n\\nHi All, in order to understand this question and similar ones, you need to deeply understand what the sliding window algorithm is. You can find a detailed explanation of that here: https://medium.com/@7anac/what-is-the-sliding-window-algorithm-f9fcfe92b853 \\n\\nOnce you are familiar with that, you can find the 100% faster Java solution to this LeetCode question here: https://medium.com/@7anac/minimum-size-subarray-sum-leetcode-209-explanation-and-solution-ac713a226bc2\\n"
                    },
                    {
                        "username": "glebret",
                        "content": "useless answer, medium is not free"
                    }
                ]
            },
            {
                "id": 1571428,
                "content": [
                    {
                        "username": "mingki",
                        "content": "The system shows that my code failed this test case, but I could not see a sub array with a length of 3 that can give a sum of 11.\\n\\nInput: 11, [1,2,3,4,5]\\n\\nOutput: 0\\n\\nExpected: 3\\n\\nCould someone please confirm whether these is an error with the test case?"
                    },
                    {
                        "username": "kunika_jain04",
                        "content": "yes, we are not getting in this case exactly 11 but the question ask us to return greater than equal to target so we are returning 3 as ,[3,4,5] giving us 12 and is the shortest subarray ."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Follow up: \"If you\\'ve coded an optimal solution, try to code in worse time complexity\". Okay bruh."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "I think they meant n^2 someone have to correct it"
                    },
                    {
                        "username": "aryaman",
                        "content": "Some test cases fail if that assumption isn't made."
                    },
                    {
                        "username": "GoCarl",
                        "content": "Hint for those codes that seem to be O(n) but TLE: \\n1. Don\\'t compute the sum of the sliding window, try accumulation instead: sum += arr[right] or sum -= arr[left]. \\n2. Don\\'t compute the length of the sliding window, try (right - left) instead"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**The  window is sliding on 2nd consecutive day. Let's see how far the window can  go sliding? before it stops :xd**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Wait for a few more days buddy, If July would be anything like June, they will start dropping HARDs pretty soon and the window will become a hole which would neither slide nor let anybody pass through. \\uD83D\\uDE25"
                    },
                    {
                        "username": "Rantoul",
                        "content": "What does shortest subarray that its sum >= s mean?\\nfor example this testcase\\n64\\n[2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65]\\nwhy the anwser is 0 rather than 1\\ncuz {65} is a subarray and 65>= 64 ?\\nCould anyone elaborate this for me ? Really appreciate it!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"shortest subarray that its sum >= s\" means that you are trying to find the smallest length of the contiguous subarray (i.e., a sequence of numbers next to each other in the array) whose sum is greater than or equal to a given number \\'s\\'.\\n\\nIn your test case, the sum is given as 64, and the array is [2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65].\\n\\nA subarray is a contiguous sequence of elements within an array. So, for instance, [3, 1, 2] is a subarray of your input, but [2, 1, 3] is not because even though these numbers exist in your array, they are not contiguous in the order presented.\\n\\nNow, the subarray [65] indeed sums to 65 which is greater than 64. Therefore, the length of the shortest subarray whose sum is greater than or equal to 64 is indeed 1 in this case.\\n\\nIf you got an answer of 0, there might have been an error in the code that was used to solve the problem. The length of a subarray can\\'t be 0 because a subarray must contain at least one element. In this case, the subarray [65] is the correct answer, and its length is 1."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "In such questions for sliding window, it is better to have a dry run on a page or code editor, which gives you a clear idea of when to increment the pointers, and when to expand or shorten the window."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "Can somebody help me \\nin this question there is a testcase \\nwhere\\ntarget = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\nin this if we sort it it becomes\\nnums = [2,4,12,12,25,25,25,25,25,26,28,83]\\nright\\nbut my output is 7 == 83 + 28 + 26 + 25 + 25 +25+25 --> 237 which is bigger than target\\nbut expected is 8 \\nso did i do wrong or i did get the question"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the \"minimum size subarray\" with a sum that is greater than or equal to a given target. In this context, a subarray is a contiguous portion of an array, and sorting the array would disrupt the original order of elements. Therefore, sorting would change the positions of the elements and make it impossible to correctly identify the original subarray that meets the problem\\'s requirements.\\n\\nFurthermore, the problem is asking for a subarray, not a subset. A subset of an array could include any elements from the array in any order, while a subarray is always a sequence of elements in their original order. Therefore, we infer from the use of the word \"subarray\" that maintaining the original order of elements is important.\\n\\nLastly, the nature of this problem \\u2013 finding a contiguous subarray with a certain property (in this case, a sum greater than or equal to a target) \\u2013 is a common type of problem that often involves techniques such as the sliding window approach, which operates on the array in its original order.\\n\\nSo, from the use of terms like \"subarray\", the requirement for a contiguous sequence of elements, and the nature of this type of problem, we can infer that we should not sort the array."
                    },
                    {
                        "username": "naomiacat95",
                        "content": "This array should not be sorted.\\n\\nBecause the anser is ask we to find the min length of SUBARRAY.\\n\\nAnd here is the define of subarray:\\nA subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nSo you can try other methods to solve the problem."
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Question says topic include binary search but arr not sorted ?wtt"
                    },
                    {
                        "username": "nandakumararaja",
                        "content": "Are the 209 and 862 problems the same"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rcomesan](/rcomesan) Yes, you\\'re correct. The problems 209 (\"Minimum Size Subarray Sum\") and 862 (\"Shortest Subarray with Sum at Least K\") on LeetCode are similar in their overall goal \\u2013 both problems ask for the shortest (or minimum size) subarray that meets a certain sum condition. However, they have different constraints, which affect the solution strategies.\\n\\nProblem 209 deals with an array of positive integers and a target sum, and the task is to find the smallest contiguous subarray with a sum that is equal to or greater than the target sum. Because all the integers in the array are positive, we can use a two-pointer or sliding window strategy to solve this problem efficiently.\\n\\nOn the other hand, problem 862 involves an array that can contain both positive and negative integers, and the task is to find the shortest subarray with a sum that is at least K. The presence of negative integers in this problem means that a simple two-pointer or sliding window strategy will not work, as the sum of a \"window\" of numbers can decrease even when we add numbers to it. This makes problem 862 more complex than problem 209.\\n\\nSo, while the two problems share a similar overall goal, the constraints and therefore the solution strategies are quite different. It\\'s a great observation that tackling both can provide a deeper understanding of how similar problem statements can require different approaches due to their specific conditions and constraints."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They are not. #209 contains only positive integers. #862 can also include negative integers so, it requires a whole different approach. It\\'s a good idea to solve both of them to understand the reason why a technique can or cannot be applied in each particular case."
                    }
                ]
            },
            {
                "id": 1958023,
                "content": [
                    {
                        "username": "mingki",
                        "content": "The system shows that my code failed this test case, but I could not see a sub array with a length of 3 that can give a sum of 11.\\n\\nInput: 11, [1,2,3,4,5]\\n\\nOutput: 0\\n\\nExpected: 3\\n\\nCould someone please confirm whether these is an error with the test case?"
                    },
                    {
                        "username": "kunika_jain04",
                        "content": "yes, we are not getting in this case exactly 11 but the question ask us to return greater than equal to target so we are returning 3 as ,[3,4,5] giving us 12 and is the shortest subarray ."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Follow up: \"If you\\'ve coded an optimal solution, try to code in worse time complexity\". Okay bruh."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "I think they meant n^2 someone have to correct it"
                    },
                    {
                        "username": "aryaman",
                        "content": "Some test cases fail if that assumption isn't made."
                    },
                    {
                        "username": "GoCarl",
                        "content": "Hint for those codes that seem to be O(n) but TLE: \\n1. Don\\'t compute the sum of the sliding window, try accumulation instead: sum += arr[right] or sum -= arr[left]. \\n2. Don\\'t compute the length of the sliding window, try (right - left) instead"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**The  window is sliding on 2nd consecutive day. Let's see how far the window can  go sliding? before it stops :xd**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Wait for a few more days buddy, If July would be anything like June, they will start dropping HARDs pretty soon and the window will become a hole which would neither slide nor let anybody pass through. \\uD83D\\uDE25"
                    },
                    {
                        "username": "Rantoul",
                        "content": "What does shortest subarray that its sum >= s mean?\\nfor example this testcase\\n64\\n[2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65]\\nwhy the anwser is 0 rather than 1\\ncuz {65} is a subarray and 65>= 64 ?\\nCould anyone elaborate this for me ? Really appreciate it!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"shortest subarray that its sum >= s\" means that you are trying to find the smallest length of the contiguous subarray (i.e., a sequence of numbers next to each other in the array) whose sum is greater than or equal to a given number \\'s\\'.\\n\\nIn your test case, the sum is given as 64, and the array is [2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65].\\n\\nA subarray is a contiguous sequence of elements within an array. So, for instance, [3, 1, 2] is a subarray of your input, but [2, 1, 3] is not because even though these numbers exist in your array, they are not contiguous in the order presented.\\n\\nNow, the subarray [65] indeed sums to 65 which is greater than 64. Therefore, the length of the shortest subarray whose sum is greater than or equal to 64 is indeed 1 in this case.\\n\\nIf you got an answer of 0, there might have been an error in the code that was used to solve the problem. The length of a subarray can\\'t be 0 because a subarray must contain at least one element. In this case, the subarray [65] is the correct answer, and its length is 1."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "In such questions for sliding window, it is better to have a dry run on a page or code editor, which gives you a clear idea of when to increment the pointers, and when to expand or shorten the window."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "Can somebody help me \\nin this question there is a testcase \\nwhere\\ntarget = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\nin this if we sort it it becomes\\nnums = [2,4,12,12,25,25,25,25,25,26,28,83]\\nright\\nbut my output is 7 == 83 + 28 + 26 + 25 + 25 +25+25 --> 237 which is bigger than target\\nbut expected is 8 \\nso did i do wrong or i did get the question"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the \"minimum size subarray\" with a sum that is greater than or equal to a given target. In this context, a subarray is a contiguous portion of an array, and sorting the array would disrupt the original order of elements. Therefore, sorting would change the positions of the elements and make it impossible to correctly identify the original subarray that meets the problem\\'s requirements.\\n\\nFurthermore, the problem is asking for a subarray, not a subset. A subset of an array could include any elements from the array in any order, while a subarray is always a sequence of elements in their original order. Therefore, we infer from the use of the word \"subarray\" that maintaining the original order of elements is important.\\n\\nLastly, the nature of this problem \\u2013 finding a contiguous subarray with a certain property (in this case, a sum greater than or equal to a target) \\u2013 is a common type of problem that often involves techniques such as the sliding window approach, which operates on the array in its original order.\\n\\nSo, from the use of terms like \"subarray\", the requirement for a contiguous sequence of elements, and the nature of this type of problem, we can infer that we should not sort the array."
                    },
                    {
                        "username": "naomiacat95",
                        "content": "This array should not be sorted.\\n\\nBecause the anser is ask we to find the min length of SUBARRAY.\\n\\nAnd here is the define of subarray:\\nA subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nSo you can try other methods to solve the problem."
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Question says topic include binary search but arr not sorted ?wtt"
                    },
                    {
                        "username": "nandakumararaja",
                        "content": "Are the 209 and 862 problems the same"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rcomesan](/rcomesan) Yes, you\\'re correct. The problems 209 (\"Minimum Size Subarray Sum\") and 862 (\"Shortest Subarray with Sum at Least K\") on LeetCode are similar in their overall goal \\u2013 both problems ask for the shortest (or minimum size) subarray that meets a certain sum condition. However, they have different constraints, which affect the solution strategies.\\n\\nProblem 209 deals with an array of positive integers and a target sum, and the task is to find the smallest contiguous subarray with a sum that is equal to or greater than the target sum. Because all the integers in the array are positive, we can use a two-pointer or sliding window strategy to solve this problem efficiently.\\n\\nOn the other hand, problem 862 involves an array that can contain both positive and negative integers, and the task is to find the shortest subarray with a sum that is at least K. The presence of negative integers in this problem means that a simple two-pointer or sliding window strategy will not work, as the sum of a \"window\" of numbers can decrease even when we add numbers to it. This makes problem 862 more complex than problem 209.\\n\\nSo, while the two problems share a similar overall goal, the constraints and therefore the solution strategies are quite different. It\\'s a great observation that tackling both can provide a deeper understanding of how similar problem statements can require different approaches due to their specific conditions and constraints."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They are not. #209 contains only positive integers. #862 can also include negative integers so, it requires a whole different approach. It\\'s a good idea to solve both of them to understand the reason why a technique can or cannot be applied in each particular case."
                    }
                ]
            },
            {
                "id": 1567914,
                "content": [
                    {
                        "username": "mingki",
                        "content": "The system shows that my code failed this test case, but I could not see a sub array with a length of 3 that can give a sum of 11.\\n\\nInput: 11, [1,2,3,4,5]\\n\\nOutput: 0\\n\\nExpected: 3\\n\\nCould someone please confirm whether these is an error with the test case?"
                    },
                    {
                        "username": "kunika_jain04",
                        "content": "yes, we are not getting in this case exactly 11 but the question ask us to return greater than equal to target so we are returning 3 as ,[3,4,5] giving us 12 and is the shortest subarray ."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Follow up: \"If you\\'ve coded an optimal solution, try to code in worse time complexity\". Okay bruh."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "I think they meant n^2 someone have to correct it"
                    },
                    {
                        "username": "aryaman",
                        "content": "Some test cases fail if that assumption isn't made."
                    },
                    {
                        "username": "GoCarl",
                        "content": "Hint for those codes that seem to be O(n) but TLE: \\n1. Don\\'t compute the sum of the sliding window, try accumulation instead: sum += arr[right] or sum -= arr[left]. \\n2. Don\\'t compute the length of the sliding window, try (right - left) instead"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**The  window is sliding on 2nd consecutive day. Let's see how far the window can  go sliding? before it stops :xd**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Wait for a few more days buddy, If July would be anything like June, they will start dropping HARDs pretty soon and the window will become a hole which would neither slide nor let anybody pass through. \\uD83D\\uDE25"
                    },
                    {
                        "username": "Rantoul",
                        "content": "What does shortest subarray that its sum >= s mean?\\nfor example this testcase\\n64\\n[2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65]\\nwhy the anwser is 0 rather than 1\\ncuz {65} is a subarray and 65>= 64 ?\\nCould anyone elaborate this for me ? Really appreciate it!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"shortest subarray that its sum >= s\" means that you are trying to find the smallest length of the contiguous subarray (i.e., a sequence of numbers next to each other in the array) whose sum is greater than or equal to a given number \\'s\\'.\\n\\nIn your test case, the sum is given as 64, and the array is [2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65].\\n\\nA subarray is a contiguous sequence of elements within an array. So, for instance, [3, 1, 2] is a subarray of your input, but [2, 1, 3] is not because even though these numbers exist in your array, they are not contiguous in the order presented.\\n\\nNow, the subarray [65] indeed sums to 65 which is greater than 64. Therefore, the length of the shortest subarray whose sum is greater than or equal to 64 is indeed 1 in this case.\\n\\nIf you got an answer of 0, there might have been an error in the code that was used to solve the problem. The length of a subarray can\\'t be 0 because a subarray must contain at least one element. In this case, the subarray [65] is the correct answer, and its length is 1."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "In such questions for sliding window, it is better to have a dry run on a page or code editor, which gives you a clear idea of when to increment the pointers, and when to expand or shorten the window."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "Can somebody help me \\nin this question there is a testcase \\nwhere\\ntarget = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\nin this if we sort it it becomes\\nnums = [2,4,12,12,25,25,25,25,25,26,28,83]\\nright\\nbut my output is 7 == 83 + 28 + 26 + 25 + 25 +25+25 --> 237 which is bigger than target\\nbut expected is 8 \\nso did i do wrong or i did get the question"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the \"minimum size subarray\" with a sum that is greater than or equal to a given target. In this context, a subarray is a contiguous portion of an array, and sorting the array would disrupt the original order of elements. Therefore, sorting would change the positions of the elements and make it impossible to correctly identify the original subarray that meets the problem\\'s requirements.\\n\\nFurthermore, the problem is asking for a subarray, not a subset. A subset of an array could include any elements from the array in any order, while a subarray is always a sequence of elements in their original order. Therefore, we infer from the use of the word \"subarray\" that maintaining the original order of elements is important.\\n\\nLastly, the nature of this problem \\u2013 finding a contiguous subarray with a certain property (in this case, a sum greater than or equal to a target) \\u2013 is a common type of problem that often involves techniques such as the sliding window approach, which operates on the array in its original order.\\n\\nSo, from the use of terms like \"subarray\", the requirement for a contiguous sequence of elements, and the nature of this type of problem, we can infer that we should not sort the array."
                    },
                    {
                        "username": "naomiacat95",
                        "content": "This array should not be sorted.\\n\\nBecause the anser is ask we to find the min length of SUBARRAY.\\n\\nAnd here is the define of subarray:\\nA subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nSo you can try other methods to solve the problem."
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Question says topic include binary search but arr not sorted ?wtt"
                    },
                    {
                        "username": "nandakumararaja",
                        "content": "Are the 209 and 862 problems the same"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rcomesan](/rcomesan) Yes, you\\'re correct. The problems 209 (\"Minimum Size Subarray Sum\") and 862 (\"Shortest Subarray with Sum at Least K\") on LeetCode are similar in their overall goal \\u2013 both problems ask for the shortest (or minimum size) subarray that meets a certain sum condition. However, they have different constraints, which affect the solution strategies.\\n\\nProblem 209 deals with an array of positive integers and a target sum, and the task is to find the smallest contiguous subarray with a sum that is equal to or greater than the target sum. Because all the integers in the array are positive, we can use a two-pointer or sliding window strategy to solve this problem efficiently.\\n\\nOn the other hand, problem 862 involves an array that can contain both positive and negative integers, and the task is to find the shortest subarray with a sum that is at least K. The presence of negative integers in this problem means that a simple two-pointer or sliding window strategy will not work, as the sum of a \"window\" of numbers can decrease even when we add numbers to it. This makes problem 862 more complex than problem 209.\\n\\nSo, while the two problems share a similar overall goal, the constraints and therefore the solution strategies are quite different. It\\'s a great observation that tackling both can provide a deeper understanding of how similar problem statements can require different approaches due to their specific conditions and constraints."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They are not. #209 contains only positive integers. #862 can also include negative integers so, it requires a whole different approach. It\\'s a good idea to solve both of them to understand the reason why a technique can or cannot be applied in each particular case."
                    }
                ]
            },
            {
                "id": 2031796,
                "content": [
                    {
                        "username": "mingki",
                        "content": "The system shows that my code failed this test case, but I could not see a sub array with a length of 3 that can give a sum of 11.\\n\\nInput: 11, [1,2,3,4,5]\\n\\nOutput: 0\\n\\nExpected: 3\\n\\nCould someone please confirm whether these is an error with the test case?"
                    },
                    {
                        "username": "kunika_jain04",
                        "content": "yes, we are not getting in this case exactly 11 but the question ask us to return greater than equal to target so we are returning 3 as ,[3,4,5] giving us 12 and is the shortest subarray ."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Follow up: \"If you\\'ve coded an optimal solution, try to code in worse time complexity\". Okay bruh."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "I think they meant n^2 someone have to correct it"
                    },
                    {
                        "username": "aryaman",
                        "content": "Some test cases fail if that assumption isn't made."
                    },
                    {
                        "username": "GoCarl",
                        "content": "Hint for those codes that seem to be O(n) but TLE: \\n1. Don\\'t compute the sum of the sliding window, try accumulation instead: sum += arr[right] or sum -= arr[left]. \\n2. Don\\'t compute the length of the sliding window, try (right - left) instead"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**The  window is sliding on 2nd consecutive day. Let's see how far the window can  go sliding? before it stops :xd**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Wait for a few more days buddy, If July would be anything like June, they will start dropping HARDs pretty soon and the window will become a hole which would neither slide nor let anybody pass through. \\uD83D\\uDE25"
                    },
                    {
                        "username": "Rantoul",
                        "content": "What does shortest subarray that its sum >= s mean?\\nfor example this testcase\\n64\\n[2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65]\\nwhy the anwser is 0 rather than 1\\ncuz {65} is a subarray and 65>= 64 ?\\nCould anyone elaborate this for me ? Really appreciate it!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"shortest subarray that its sum >= s\" means that you are trying to find the smallest length of the contiguous subarray (i.e., a sequence of numbers next to each other in the array) whose sum is greater than or equal to a given number \\'s\\'.\\n\\nIn your test case, the sum is given as 64, and the array is [2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65].\\n\\nA subarray is a contiguous sequence of elements within an array. So, for instance, [3, 1, 2] is a subarray of your input, but [2, 1, 3] is not because even though these numbers exist in your array, they are not contiguous in the order presented.\\n\\nNow, the subarray [65] indeed sums to 65 which is greater than 64. Therefore, the length of the shortest subarray whose sum is greater than or equal to 64 is indeed 1 in this case.\\n\\nIf you got an answer of 0, there might have been an error in the code that was used to solve the problem. The length of a subarray can\\'t be 0 because a subarray must contain at least one element. In this case, the subarray [65] is the correct answer, and its length is 1."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "In such questions for sliding window, it is better to have a dry run on a page or code editor, which gives you a clear idea of when to increment the pointers, and when to expand or shorten the window."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "Can somebody help me \\nin this question there is a testcase \\nwhere\\ntarget = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\nin this if we sort it it becomes\\nnums = [2,4,12,12,25,25,25,25,25,26,28,83]\\nright\\nbut my output is 7 == 83 + 28 + 26 + 25 + 25 +25+25 --> 237 which is bigger than target\\nbut expected is 8 \\nso did i do wrong or i did get the question"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the \"minimum size subarray\" with a sum that is greater than or equal to a given target. In this context, a subarray is a contiguous portion of an array, and sorting the array would disrupt the original order of elements. Therefore, sorting would change the positions of the elements and make it impossible to correctly identify the original subarray that meets the problem\\'s requirements.\\n\\nFurthermore, the problem is asking for a subarray, not a subset. A subset of an array could include any elements from the array in any order, while a subarray is always a sequence of elements in their original order. Therefore, we infer from the use of the word \"subarray\" that maintaining the original order of elements is important.\\n\\nLastly, the nature of this problem \\u2013 finding a contiguous subarray with a certain property (in this case, a sum greater than or equal to a target) \\u2013 is a common type of problem that often involves techniques such as the sliding window approach, which operates on the array in its original order.\\n\\nSo, from the use of terms like \"subarray\", the requirement for a contiguous sequence of elements, and the nature of this type of problem, we can infer that we should not sort the array."
                    },
                    {
                        "username": "naomiacat95",
                        "content": "This array should not be sorted.\\n\\nBecause the anser is ask we to find the min length of SUBARRAY.\\n\\nAnd here is the define of subarray:\\nA subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nSo you can try other methods to solve the problem."
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Question says topic include binary search but arr not sorted ?wtt"
                    },
                    {
                        "username": "nandakumararaja",
                        "content": "Are the 209 and 862 problems the same"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rcomesan](/rcomesan) Yes, you\\'re correct. The problems 209 (\"Minimum Size Subarray Sum\") and 862 (\"Shortest Subarray with Sum at Least K\") on LeetCode are similar in their overall goal \\u2013 both problems ask for the shortest (or minimum size) subarray that meets a certain sum condition. However, they have different constraints, which affect the solution strategies.\\n\\nProblem 209 deals with an array of positive integers and a target sum, and the task is to find the smallest contiguous subarray with a sum that is equal to or greater than the target sum. Because all the integers in the array are positive, we can use a two-pointer or sliding window strategy to solve this problem efficiently.\\n\\nOn the other hand, problem 862 involves an array that can contain both positive and negative integers, and the task is to find the shortest subarray with a sum that is at least K. The presence of negative integers in this problem means that a simple two-pointer or sliding window strategy will not work, as the sum of a \"window\" of numbers can decrease even when we add numbers to it. This makes problem 862 more complex than problem 209.\\n\\nSo, while the two problems share a similar overall goal, the constraints and therefore the solution strategies are quite different. It\\'s a great observation that tackling both can provide a deeper understanding of how similar problem statements can require different approaches due to their specific conditions and constraints."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They are not. #209 contains only positive integers. #862 can also include negative integers so, it requires a whole different approach. It\\'s a good idea to solve both of them to understand the reason why a technique can or cannot be applied in each particular case."
                    }
                ]
            },
            {
                "id": 1958014,
                "content": [
                    {
                        "username": "mingki",
                        "content": "The system shows that my code failed this test case, but I could not see a sub array with a length of 3 that can give a sum of 11.\\n\\nInput: 11, [1,2,3,4,5]\\n\\nOutput: 0\\n\\nExpected: 3\\n\\nCould someone please confirm whether these is an error with the test case?"
                    },
                    {
                        "username": "kunika_jain04",
                        "content": "yes, we are not getting in this case exactly 11 but the question ask us to return greater than equal to target so we are returning 3 as ,[3,4,5] giving us 12 and is the shortest subarray ."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Follow up: \"If you\\'ve coded an optimal solution, try to code in worse time complexity\". Okay bruh."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "I think they meant n^2 someone have to correct it"
                    },
                    {
                        "username": "aryaman",
                        "content": "Some test cases fail if that assumption isn't made."
                    },
                    {
                        "username": "GoCarl",
                        "content": "Hint for those codes that seem to be O(n) but TLE: \\n1. Don\\'t compute the sum of the sliding window, try accumulation instead: sum += arr[right] or sum -= arr[left]. \\n2. Don\\'t compute the length of the sliding window, try (right - left) instead"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**The  window is sliding on 2nd consecutive day. Let's see how far the window can  go sliding? before it stops :xd**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Wait for a few more days buddy, If July would be anything like June, they will start dropping HARDs pretty soon and the window will become a hole which would neither slide nor let anybody pass through. \\uD83D\\uDE25"
                    },
                    {
                        "username": "Rantoul",
                        "content": "What does shortest subarray that its sum >= s mean?\\nfor example this testcase\\n64\\n[2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65]\\nwhy the anwser is 0 rather than 1\\ncuz {65} is a subarray and 65>= 64 ?\\nCould anyone elaborate this for me ? Really appreciate it!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"shortest subarray that its sum >= s\" means that you are trying to find the smallest length of the contiguous subarray (i.e., a sequence of numbers next to each other in the array) whose sum is greater than or equal to a given number \\'s\\'.\\n\\nIn your test case, the sum is given as 64, and the array is [2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65].\\n\\nA subarray is a contiguous sequence of elements within an array. So, for instance, [3, 1, 2] is a subarray of your input, but [2, 1, 3] is not because even though these numbers exist in your array, they are not contiguous in the order presented.\\n\\nNow, the subarray [65] indeed sums to 65 which is greater than 64. Therefore, the length of the shortest subarray whose sum is greater than or equal to 64 is indeed 1 in this case.\\n\\nIf you got an answer of 0, there might have been an error in the code that was used to solve the problem. The length of a subarray can\\'t be 0 because a subarray must contain at least one element. In this case, the subarray [65] is the correct answer, and its length is 1."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "In such questions for sliding window, it is better to have a dry run on a page or code editor, which gives you a clear idea of when to increment the pointers, and when to expand or shorten the window."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "Can somebody help me \\nin this question there is a testcase \\nwhere\\ntarget = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\nin this if we sort it it becomes\\nnums = [2,4,12,12,25,25,25,25,25,26,28,83]\\nright\\nbut my output is 7 == 83 + 28 + 26 + 25 + 25 +25+25 --> 237 which is bigger than target\\nbut expected is 8 \\nso did i do wrong or i did get the question"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the \"minimum size subarray\" with a sum that is greater than or equal to a given target. In this context, a subarray is a contiguous portion of an array, and sorting the array would disrupt the original order of elements. Therefore, sorting would change the positions of the elements and make it impossible to correctly identify the original subarray that meets the problem\\'s requirements.\\n\\nFurthermore, the problem is asking for a subarray, not a subset. A subset of an array could include any elements from the array in any order, while a subarray is always a sequence of elements in their original order. Therefore, we infer from the use of the word \"subarray\" that maintaining the original order of elements is important.\\n\\nLastly, the nature of this problem \\u2013 finding a contiguous subarray with a certain property (in this case, a sum greater than or equal to a target) \\u2013 is a common type of problem that often involves techniques such as the sliding window approach, which operates on the array in its original order.\\n\\nSo, from the use of terms like \"subarray\", the requirement for a contiguous sequence of elements, and the nature of this type of problem, we can infer that we should not sort the array."
                    },
                    {
                        "username": "naomiacat95",
                        "content": "This array should not be sorted.\\n\\nBecause the anser is ask we to find the min length of SUBARRAY.\\n\\nAnd here is the define of subarray:\\nA subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nSo you can try other methods to solve the problem."
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Question says topic include binary search but arr not sorted ?wtt"
                    },
                    {
                        "username": "nandakumararaja",
                        "content": "Are the 209 and 862 problems the same"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rcomesan](/rcomesan) Yes, you\\'re correct. The problems 209 (\"Minimum Size Subarray Sum\") and 862 (\"Shortest Subarray with Sum at Least K\") on LeetCode are similar in their overall goal \\u2013 both problems ask for the shortest (or minimum size) subarray that meets a certain sum condition. However, they have different constraints, which affect the solution strategies.\\n\\nProblem 209 deals with an array of positive integers and a target sum, and the task is to find the smallest contiguous subarray with a sum that is equal to or greater than the target sum. Because all the integers in the array are positive, we can use a two-pointer or sliding window strategy to solve this problem efficiently.\\n\\nOn the other hand, problem 862 involves an array that can contain both positive and negative integers, and the task is to find the shortest subarray with a sum that is at least K. The presence of negative integers in this problem means that a simple two-pointer or sliding window strategy will not work, as the sum of a \"window\" of numbers can decrease even when we add numbers to it. This makes problem 862 more complex than problem 209.\\n\\nSo, while the two problems share a similar overall goal, the constraints and therefore the solution strategies are quite different. It\\'s a great observation that tackling both can provide a deeper understanding of how similar problem statements can require different approaches due to their specific conditions and constraints."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They are not. #209 contains only positive integers. #862 can also include negative integers so, it requires a whole different approach. It\\'s a good idea to solve both of them to understand the reason why a technique can or cannot be applied in each particular case."
                    }
                ]
            },
            {
                "id": 1572709,
                "content": [
                    {
                        "username": "mingki",
                        "content": "The system shows that my code failed this test case, but I could not see a sub array with a length of 3 that can give a sum of 11.\\n\\nInput: 11, [1,2,3,4,5]\\n\\nOutput: 0\\n\\nExpected: 3\\n\\nCould someone please confirm whether these is an error with the test case?"
                    },
                    {
                        "username": "kunika_jain04",
                        "content": "yes, we are not getting in this case exactly 11 but the question ask us to return greater than equal to target so we are returning 3 as ,[3,4,5] giving us 12 and is the shortest subarray ."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Follow up: \"If you\\'ve coded an optimal solution, try to code in worse time complexity\". Okay bruh."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "I think they meant n^2 someone have to correct it"
                    },
                    {
                        "username": "aryaman",
                        "content": "Some test cases fail if that assumption isn't made."
                    },
                    {
                        "username": "GoCarl",
                        "content": "Hint for those codes that seem to be O(n) but TLE: \\n1. Don\\'t compute the sum of the sliding window, try accumulation instead: sum += arr[right] or sum -= arr[left]. \\n2. Don\\'t compute the length of the sliding window, try (right - left) instead"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**The  window is sliding on 2nd consecutive day. Let's see how far the window can  go sliding? before it stops :xd**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Wait for a few more days buddy, If July would be anything like June, they will start dropping HARDs pretty soon and the window will become a hole which would neither slide nor let anybody pass through. \\uD83D\\uDE25"
                    },
                    {
                        "username": "Rantoul",
                        "content": "What does shortest subarray that its sum >= s mean?\\nfor example this testcase\\n64\\n[2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65]\\nwhy the anwser is 0 rather than 1\\ncuz {65} is a subarray and 65>= 64 ?\\nCould anyone elaborate this for me ? Really appreciate it!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"shortest subarray that its sum >= s\" means that you are trying to find the smallest length of the contiguous subarray (i.e., a sequence of numbers next to each other in the array) whose sum is greater than or equal to a given number \\'s\\'.\\n\\nIn your test case, the sum is given as 64, and the array is [2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65].\\n\\nA subarray is a contiguous sequence of elements within an array. So, for instance, [3, 1, 2] is a subarray of your input, but [2, 1, 3] is not because even though these numbers exist in your array, they are not contiguous in the order presented.\\n\\nNow, the subarray [65] indeed sums to 65 which is greater than 64. Therefore, the length of the shortest subarray whose sum is greater than or equal to 64 is indeed 1 in this case.\\n\\nIf you got an answer of 0, there might have been an error in the code that was used to solve the problem. The length of a subarray can\\'t be 0 because a subarray must contain at least one element. In this case, the subarray [65] is the correct answer, and its length is 1."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "In such questions for sliding window, it is better to have a dry run on a page or code editor, which gives you a clear idea of when to increment the pointers, and when to expand or shorten the window."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "Can somebody help me \\nin this question there is a testcase \\nwhere\\ntarget = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\nin this if we sort it it becomes\\nnums = [2,4,12,12,25,25,25,25,25,26,28,83]\\nright\\nbut my output is 7 == 83 + 28 + 26 + 25 + 25 +25+25 --> 237 which is bigger than target\\nbut expected is 8 \\nso did i do wrong or i did get the question"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the \"minimum size subarray\" with a sum that is greater than or equal to a given target. In this context, a subarray is a contiguous portion of an array, and sorting the array would disrupt the original order of elements. Therefore, sorting would change the positions of the elements and make it impossible to correctly identify the original subarray that meets the problem\\'s requirements.\\n\\nFurthermore, the problem is asking for a subarray, not a subset. A subset of an array could include any elements from the array in any order, while a subarray is always a sequence of elements in their original order. Therefore, we infer from the use of the word \"subarray\" that maintaining the original order of elements is important.\\n\\nLastly, the nature of this problem \\u2013 finding a contiguous subarray with a certain property (in this case, a sum greater than or equal to a target) \\u2013 is a common type of problem that often involves techniques such as the sliding window approach, which operates on the array in its original order.\\n\\nSo, from the use of terms like \"subarray\", the requirement for a contiguous sequence of elements, and the nature of this type of problem, we can infer that we should not sort the array."
                    },
                    {
                        "username": "naomiacat95",
                        "content": "This array should not be sorted.\\n\\nBecause the anser is ask we to find the min length of SUBARRAY.\\n\\nAnd here is the define of subarray:\\nA subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nSo you can try other methods to solve the problem."
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Question says topic include binary search but arr not sorted ?wtt"
                    },
                    {
                        "username": "nandakumararaja",
                        "content": "Are the 209 and 862 problems the same"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rcomesan](/rcomesan) Yes, you\\'re correct. The problems 209 (\"Minimum Size Subarray Sum\") and 862 (\"Shortest Subarray with Sum at Least K\") on LeetCode are similar in their overall goal \\u2013 both problems ask for the shortest (or minimum size) subarray that meets a certain sum condition. However, they have different constraints, which affect the solution strategies.\\n\\nProblem 209 deals with an array of positive integers and a target sum, and the task is to find the smallest contiguous subarray with a sum that is equal to or greater than the target sum. Because all the integers in the array are positive, we can use a two-pointer or sliding window strategy to solve this problem efficiently.\\n\\nOn the other hand, problem 862 involves an array that can contain both positive and negative integers, and the task is to find the shortest subarray with a sum that is at least K. The presence of negative integers in this problem means that a simple two-pointer or sliding window strategy will not work, as the sum of a \"window\" of numbers can decrease even when we add numbers to it. This makes problem 862 more complex than problem 209.\\n\\nSo, while the two problems share a similar overall goal, the constraints and therefore the solution strategies are quite different. It\\'s a great observation that tackling both can provide a deeper understanding of how similar problem statements can require different approaches due to their specific conditions and constraints."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They are not. #209 contains only positive integers. #862 can also include negative integers so, it requires a whole different approach. It\\'s a good idea to solve both of them to understand the reason why a technique can or cannot be applied in each particular case."
                    }
                ]
            },
            {
                "id": 1958281,
                "content": [
                    {
                        "username": "mingki",
                        "content": "The system shows that my code failed this test case, but I could not see a sub array with a length of 3 that can give a sum of 11.\\n\\nInput: 11, [1,2,3,4,5]\\n\\nOutput: 0\\n\\nExpected: 3\\n\\nCould someone please confirm whether these is an error with the test case?"
                    },
                    {
                        "username": "kunika_jain04",
                        "content": "yes, we are not getting in this case exactly 11 but the question ask us to return greater than equal to target so we are returning 3 as ,[3,4,5] giving us 12 and is the shortest subarray ."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Follow up: \"If you\\'ve coded an optimal solution, try to code in worse time complexity\". Okay bruh."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "I think they meant n^2 someone have to correct it"
                    },
                    {
                        "username": "aryaman",
                        "content": "Some test cases fail if that assumption isn't made."
                    },
                    {
                        "username": "GoCarl",
                        "content": "Hint for those codes that seem to be O(n) but TLE: \\n1. Don\\'t compute the sum of the sliding window, try accumulation instead: sum += arr[right] or sum -= arr[left]. \\n2. Don\\'t compute the length of the sliding window, try (right - left) instead"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**The  window is sliding on 2nd consecutive day. Let's see how far the window can  go sliding? before it stops :xd**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Wait for a few more days buddy, If July would be anything like June, they will start dropping HARDs pretty soon and the window will become a hole which would neither slide nor let anybody pass through. \\uD83D\\uDE25"
                    },
                    {
                        "username": "Rantoul",
                        "content": "What does shortest subarray that its sum >= s mean?\\nfor example this testcase\\n64\\n[2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65]\\nwhy the anwser is 0 rather than 1\\ncuz {65} is a subarray and 65>= 64 ?\\nCould anyone elaborate this for me ? Really appreciate it!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"shortest subarray that its sum >= s\" means that you are trying to find the smallest length of the contiguous subarray (i.e., a sequence of numbers next to each other in the array) whose sum is greater than or equal to a given number \\'s\\'.\\n\\nIn your test case, the sum is given as 64, and the array is [2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65].\\n\\nA subarray is a contiguous sequence of elements within an array. So, for instance, [3, 1, 2] is a subarray of your input, but [2, 1, 3] is not because even though these numbers exist in your array, they are not contiguous in the order presented.\\n\\nNow, the subarray [65] indeed sums to 65 which is greater than 64. Therefore, the length of the shortest subarray whose sum is greater than or equal to 64 is indeed 1 in this case.\\n\\nIf you got an answer of 0, there might have been an error in the code that was used to solve the problem. The length of a subarray can\\'t be 0 because a subarray must contain at least one element. In this case, the subarray [65] is the correct answer, and its length is 1."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "In such questions for sliding window, it is better to have a dry run on a page or code editor, which gives you a clear idea of when to increment the pointers, and when to expand or shorten the window."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "Can somebody help me \\nin this question there is a testcase \\nwhere\\ntarget = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\nin this if we sort it it becomes\\nnums = [2,4,12,12,25,25,25,25,25,26,28,83]\\nright\\nbut my output is 7 == 83 + 28 + 26 + 25 + 25 +25+25 --> 237 which is bigger than target\\nbut expected is 8 \\nso did i do wrong or i did get the question"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the \"minimum size subarray\" with a sum that is greater than or equal to a given target. In this context, a subarray is a contiguous portion of an array, and sorting the array would disrupt the original order of elements. Therefore, sorting would change the positions of the elements and make it impossible to correctly identify the original subarray that meets the problem\\'s requirements.\\n\\nFurthermore, the problem is asking for a subarray, not a subset. A subset of an array could include any elements from the array in any order, while a subarray is always a sequence of elements in their original order. Therefore, we infer from the use of the word \"subarray\" that maintaining the original order of elements is important.\\n\\nLastly, the nature of this problem \\u2013 finding a contiguous subarray with a certain property (in this case, a sum greater than or equal to a target) \\u2013 is a common type of problem that often involves techniques such as the sliding window approach, which operates on the array in its original order.\\n\\nSo, from the use of terms like \"subarray\", the requirement for a contiguous sequence of elements, and the nature of this type of problem, we can infer that we should not sort the array."
                    },
                    {
                        "username": "naomiacat95",
                        "content": "This array should not be sorted.\\n\\nBecause the anser is ask we to find the min length of SUBARRAY.\\n\\nAnd here is the define of subarray:\\nA subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nSo you can try other methods to solve the problem."
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Question says topic include binary search but arr not sorted ?wtt"
                    },
                    {
                        "username": "nandakumararaja",
                        "content": "Are the 209 and 862 problems the same"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rcomesan](/rcomesan) Yes, you\\'re correct. The problems 209 (\"Minimum Size Subarray Sum\") and 862 (\"Shortest Subarray with Sum at Least K\") on LeetCode are similar in their overall goal \\u2013 both problems ask for the shortest (or minimum size) subarray that meets a certain sum condition. However, they have different constraints, which affect the solution strategies.\\n\\nProblem 209 deals with an array of positive integers and a target sum, and the task is to find the smallest contiguous subarray with a sum that is equal to or greater than the target sum. Because all the integers in the array are positive, we can use a two-pointer or sliding window strategy to solve this problem efficiently.\\n\\nOn the other hand, problem 862 involves an array that can contain both positive and negative integers, and the task is to find the shortest subarray with a sum that is at least K. The presence of negative integers in this problem means that a simple two-pointer or sliding window strategy will not work, as the sum of a \"window\" of numbers can decrease even when we add numbers to it. This makes problem 862 more complex than problem 209.\\n\\nSo, while the two problems share a similar overall goal, the constraints and therefore the solution strategies are quite different. It\\'s a great observation that tackling both can provide a deeper understanding of how similar problem statements can require different approaches due to their specific conditions and constraints."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They are not. #209 contains only positive integers. #862 can also include negative integers so, it requires a whole different approach. It\\'s a good idea to solve both of them to understand the reason why a technique can or cannot be applied in each particular case."
                    }
                ]
            },
            {
                "id": 1958266,
                "content": [
                    {
                        "username": "mingki",
                        "content": "The system shows that my code failed this test case, but I could not see a sub array with a length of 3 that can give a sum of 11.\\n\\nInput: 11, [1,2,3,4,5]\\n\\nOutput: 0\\n\\nExpected: 3\\n\\nCould someone please confirm whether these is an error with the test case?"
                    },
                    {
                        "username": "kunika_jain04",
                        "content": "yes, we are not getting in this case exactly 11 but the question ask us to return greater than equal to target so we are returning 3 as ,[3,4,5] giving us 12 and is the shortest subarray ."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Follow up: \"If you\\'ve coded an optimal solution, try to code in worse time complexity\". Okay bruh."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "I think they meant n^2 someone have to correct it"
                    },
                    {
                        "username": "aryaman",
                        "content": "Some test cases fail if that assumption isn't made."
                    },
                    {
                        "username": "GoCarl",
                        "content": "Hint for those codes that seem to be O(n) but TLE: \\n1. Don\\'t compute the sum of the sliding window, try accumulation instead: sum += arr[right] or sum -= arr[left]. \\n2. Don\\'t compute the length of the sliding window, try (right - left) instead"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**The  window is sliding on 2nd consecutive day. Let's see how far the window can  go sliding? before it stops :xd**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Wait for a few more days buddy, If July would be anything like June, they will start dropping HARDs pretty soon and the window will become a hole which would neither slide nor let anybody pass through. \\uD83D\\uDE25"
                    },
                    {
                        "username": "Rantoul",
                        "content": "What does shortest subarray that its sum >= s mean?\\nfor example this testcase\\n64\\n[2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65]\\nwhy the anwser is 0 rather than 1\\ncuz {65} is a subarray and 65>= 64 ?\\nCould anyone elaborate this for me ? Really appreciate it!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"shortest subarray that its sum >= s\" means that you are trying to find the smallest length of the contiguous subarray (i.e., a sequence of numbers next to each other in the array) whose sum is greater than or equal to a given number \\'s\\'.\\n\\nIn your test case, the sum is given as 64, and the array is [2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65].\\n\\nA subarray is a contiguous sequence of elements within an array. So, for instance, [3, 1, 2] is a subarray of your input, but [2, 1, 3] is not because even though these numbers exist in your array, they are not contiguous in the order presented.\\n\\nNow, the subarray [65] indeed sums to 65 which is greater than 64. Therefore, the length of the shortest subarray whose sum is greater than or equal to 64 is indeed 1 in this case.\\n\\nIf you got an answer of 0, there might have been an error in the code that was used to solve the problem. The length of a subarray can\\'t be 0 because a subarray must contain at least one element. In this case, the subarray [65] is the correct answer, and its length is 1."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "In such questions for sliding window, it is better to have a dry run on a page or code editor, which gives you a clear idea of when to increment the pointers, and when to expand or shorten the window."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "Can somebody help me \\nin this question there is a testcase \\nwhere\\ntarget = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\nin this if we sort it it becomes\\nnums = [2,4,12,12,25,25,25,25,25,26,28,83]\\nright\\nbut my output is 7 == 83 + 28 + 26 + 25 + 25 +25+25 --> 237 which is bigger than target\\nbut expected is 8 \\nso did i do wrong or i did get the question"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the \"minimum size subarray\" with a sum that is greater than or equal to a given target. In this context, a subarray is a contiguous portion of an array, and sorting the array would disrupt the original order of elements. Therefore, sorting would change the positions of the elements and make it impossible to correctly identify the original subarray that meets the problem\\'s requirements.\\n\\nFurthermore, the problem is asking for a subarray, not a subset. A subset of an array could include any elements from the array in any order, while a subarray is always a sequence of elements in their original order. Therefore, we infer from the use of the word \"subarray\" that maintaining the original order of elements is important.\\n\\nLastly, the nature of this problem \\u2013 finding a contiguous subarray with a certain property (in this case, a sum greater than or equal to a target) \\u2013 is a common type of problem that often involves techniques such as the sliding window approach, which operates on the array in its original order.\\n\\nSo, from the use of terms like \"subarray\", the requirement for a contiguous sequence of elements, and the nature of this type of problem, we can infer that we should not sort the array."
                    },
                    {
                        "username": "naomiacat95",
                        "content": "This array should not be sorted.\\n\\nBecause the anser is ask we to find the min length of SUBARRAY.\\n\\nAnd here is the define of subarray:\\nA subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nSo you can try other methods to solve the problem."
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Question says topic include binary search but arr not sorted ?wtt"
                    },
                    {
                        "username": "nandakumararaja",
                        "content": "Are the 209 and 862 problems the same"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rcomesan](/rcomesan) Yes, you\\'re correct. The problems 209 (\"Minimum Size Subarray Sum\") and 862 (\"Shortest Subarray with Sum at Least K\") on LeetCode are similar in their overall goal \\u2013 both problems ask for the shortest (or minimum size) subarray that meets a certain sum condition. However, they have different constraints, which affect the solution strategies.\\n\\nProblem 209 deals with an array of positive integers and a target sum, and the task is to find the smallest contiguous subarray with a sum that is equal to or greater than the target sum. Because all the integers in the array are positive, we can use a two-pointer or sliding window strategy to solve this problem efficiently.\\n\\nOn the other hand, problem 862 involves an array that can contain both positive and negative integers, and the task is to find the shortest subarray with a sum that is at least K. The presence of negative integers in this problem means that a simple two-pointer or sliding window strategy will not work, as the sum of a \"window\" of numbers can decrease even when we add numbers to it. This makes problem 862 more complex than problem 209.\\n\\nSo, while the two problems share a similar overall goal, the constraints and therefore the solution strategies are quite different. It\\'s a great observation that tackling both can provide a deeper understanding of how similar problem statements can require different approaches due to their specific conditions and constraints."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They are not. #209 contains only positive integers. #862 can also include negative integers so, it requires a whole different approach. It\\'s a good idea to solve both of them to understand the reason why a technique can or cannot be applied in each particular case."
                    }
                ]
            },
            {
                "id": 1830045,
                "content": [
                    {
                        "username": "mingki",
                        "content": "The system shows that my code failed this test case, but I could not see a sub array with a length of 3 that can give a sum of 11.\\n\\nInput: 11, [1,2,3,4,5]\\n\\nOutput: 0\\n\\nExpected: 3\\n\\nCould someone please confirm whether these is an error with the test case?"
                    },
                    {
                        "username": "kunika_jain04",
                        "content": "yes, we are not getting in this case exactly 11 but the question ask us to return greater than equal to target so we are returning 3 as ,[3,4,5] giving us 12 and is the shortest subarray ."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Follow up: \"If you\\'ve coded an optimal solution, try to code in worse time complexity\". Okay bruh."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "I think they meant n^2 someone have to correct it"
                    },
                    {
                        "username": "aryaman",
                        "content": "Some test cases fail if that assumption isn't made."
                    },
                    {
                        "username": "GoCarl",
                        "content": "Hint for those codes that seem to be O(n) but TLE: \\n1. Don\\'t compute the sum of the sliding window, try accumulation instead: sum += arr[right] or sum -= arr[left]. \\n2. Don\\'t compute the length of the sliding window, try (right - left) instead"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**The  window is sliding on 2nd consecutive day. Let's see how far the window can  go sliding? before it stops :xd**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Wait for a few more days buddy, If July would be anything like June, they will start dropping HARDs pretty soon and the window will become a hole which would neither slide nor let anybody pass through. \\uD83D\\uDE25"
                    },
                    {
                        "username": "Rantoul",
                        "content": "What does shortest subarray that its sum >= s mean?\\nfor example this testcase\\n64\\n[2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65]\\nwhy the anwser is 0 rather than 1\\ncuz {65} is a subarray and 65>= 64 ?\\nCould anyone elaborate this for me ? Really appreciate it!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"shortest subarray that its sum >= s\" means that you are trying to find the smallest length of the contiguous subarray (i.e., a sequence of numbers next to each other in the array) whose sum is greater than or equal to a given number \\'s\\'.\\n\\nIn your test case, the sum is given as 64, and the array is [2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65].\\n\\nA subarray is a contiguous sequence of elements within an array. So, for instance, [3, 1, 2] is a subarray of your input, but [2, 1, 3] is not because even though these numbers exist in your array, they are not contiguous in the order presented.\\n\\nNow, the subarray [65] indeed sums to 65 which is greater than 64. Therefore, the length of the shortest subarray whose sum is greater than or equal to 64 is indeed 1 in this case.\\n\\nIf you got an answer of 0, there might have been an error in the code that was used to solve the problem. The length of a subarray can\\'t be 0 because a subarray must contain at least one element. In this case, the subarray [65] is the correct answer, and its length is 1."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "In such questions for sliding window, it is better to have a dry run on a page or code editor, which gives you a clear idea of when to increment the pointers, and when to expand or shorten the window."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "Can somebody help me \\nin this question there is a testcase \\nwhere\\ntarget = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\nin this if we sort it it becomes\\nnums = [2,4,12,12,25,25,25,25,25,26,28,83]\\nright\\nbut my output is 7 == 83 + 28 + 26 + 25 + 25 +25+25 --> 237 which is bigger than target\\nbut expected is 8 \\nso did i do wrong or i did get the question"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the \"minimum size subarray\" with a sum that is greater than or equal to a given target. In this context, a subarray is a contiguous portion of an array, and sorting the array would disrupt the original order of elements. Therefore, sorting would change the positions of the elements and make it impossible to correctly identify the original subarray that meets the problem\\'s requirements.\\n\\nFurthermore, the problem is asking for a subarray, not a subset. A subset of an array could include any elements from the array in any order, while a subarray is always a sequence of elements in their original order. Therefore, we infer from the use of the word \"subarray\" that maintaining the original order of elements is important.\\n\\nLastly, the nature of this problem \\u2013 finding a contiguous subarray with a certain property (in this case, a sum greater than or equal to a target) \\u2013 is a common type of problem that often involves techniques such as the sliding window approach, which operates on the array in its original order.\\n\\nSo, from the use of terms like \"subarray\", the requirement for a contiguous sequence of elements, and the nature of this type of problem, we can infer that we should not sort the array."
                    },
                    {
                        "username": "naomiacat95",
                        "content": "This array should not be sorted.\\n\\nBecause the anser is ask we to find the min length of SUBARRAY.\\n\\nAnd here is the define of subarray:\\nA subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nSo you can try other methods to solve the problem."
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Question says topic include binary search but arr not sorted ?wtt"
                    },
                    {
                        "username": "nandakumararaja",
                        "content": "Are the 209 and 862 problems the same"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rcomesan](/rcomesan) Yes, you\\'re correct. The problems 209 (\"Minimum Size Subarray Sum\") and 862 (\"Shortest Subarray with Sum at Least K\") on LeetCode are similar in their overall goal \\u2013 both problems ask for the shortest (or minimum size) subarray that meets a certain sum condition. However, they have different constraints, which affect the solution strategies.\\n\\nProblem 209 deals with an array of positive integers and a target sum, and the task is to find the smallest contiguous subarray with a sum that is equal to or greater than the target sum. Because all the integers in the array are positive, we can use a two-pointer or sliding window strategy to solve this problem efficiently.\\n\\nOn the other hand, problem 862 involves an array that can contain both positive and negative integers, and the task is to find the shortest subarray with a sum that is at least K. The presence of negative integers in this problem means that a simple two-pointer or sliding window strategy will not work, as the sum of a \"window\" of numbers can decrease even when we add numbers to it. This makes problem 862 more complex than problem 209.\\n\\nSo, while the two problems share a similar overall goal, the constraints and therefore the solution strategies are quite different. It\\'s a great observation that tackling both can provide a deeper understanding of how similar problem statements can require different approaches due to their specific conditions and constraints."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They are not. #209 contains only positive integers. #862 can also include negative integers so, it requires a whole different approach. It\\'s a good idea to solve both of them to understand the reason why a technique can or cannot be applied in each particular case."
                    }
                ]
            },
            {
                "id": 1572518,
                "content": [
                    {
                        "username": "mingki",
                        "content": "The system shows that my code failed this test case, but I could not see a sub array with a length of 3 that can give a sum of 11.\\n\\nInput: 11, [1,2,3,4,5]\\n\\nOutput: 0\\n\\nExpected: 3\\n\\nCould someone please confirm whether these is an error with the test case?"
                    },
                    {
                        "username": "kunika_jain04",
                        "content": "yes, we are not getting in this case exactly 11 but the question ask us to return greater than equal to target so we are returning 3 as ,[3,4,5] giving us 12 and is the shortest subarray ."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Follow up: \"If you\\'ve coded an optimal solution, try to code in worse time complexity\". Okay bruh."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "I think they meant n^2 someone have to correct it"
                    },
                    {
                        "username": "aryaman",
                        "content": "Some test cases fail if that assumption isn't made."
                    },
                    {
                        "username": "GoCarl",
                        "content": "Hint for those codes that seem to be O(n) but TLE: \\n1. Don\\'t compute the sum of the sliding window, try accumulation instead: sum += arr[right] or sum -= arr[left]. \\n2. Don\\'t compute the length of the sliding window, try (right - left) instead"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**The  window is sliding on 2nd consecutive day. Let's see how far the window can  go sliding? before it stops :xd**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Wait for a few more days buddy, If July would be anything like June, they will start dropping HARDs pretty soon and the window will become a hole which would neither slide nor let anybody pass through. \\uD83D\\uDE25"
                    },
                    {
                        "username": "Rantoul",
                        "content": "What does shortest subarray that its sum >= s mean?\\nfor example this testcase\\n64\\n[2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65]\\nwhy the anwser is 0 rather than 1\\ncuz {65} is a subarray and 65>= 64 ?\\nCould anyone elaborate this for me ? Really appreciate it!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"shortest subarray that its sum >= s\" means that you are trying to find the smallest length of the contiguous subarray (i.e., a sequence of numbers next to each other in the array) whose sum is greater than or equal to a given number \\'s\\'.\\n\\nIn your test case, the sum is given as 64, and the array is [2,3,1,2,4,3,1,2,3,4,0,-2,-34,3,65].\\n\\nA subarray is a contiguous sequence of elements within an array. So, for instance, [3, 1, 2] is a subarray of your input, but [2, 1, 3] is not because even though these numbers exist in your array, they are not contiguous in the order presented.\\n\\nNow, the subarray [65] indeed sums to 65 which is greater than 64. Therefore, the length of the shortest subarray whose sum is greater than or equal to 64 is indeed 1 in this case.\\n\\nIf you got an answer of 0, there might have been an error in the code that was used to solve the problem. The length of a subarray can\\'t be 0 because a subarray must contain at least one element. In this case, the subarray [65] is the correct answer, and its length is 1."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "In such questions for sliding window, it is better to have a dry run on a page or code editor, which gives you a clear idea of when to increment the pointers, and when to expand or shorten the window."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "Can somebody help me \\nin this question there is a testcase \\nwhere\\ntarget = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\nin this if we sort it it becomes\\nnums = [2,4,12,12,25,25,25,25,25,26,28,83]\\nright\\nbut my output is 7 == 83 + 28 + 26 + 25 + 25 +25+25 --> 237 which is bigger than target\\nbut expected is 8 \\nso did i do wrong or i did get the question"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the \"minimum size subarray\" with a sum that is greater than or equal to a given target. In this context, a subarray is a contiguous portion of an array, and sorting the array would disrupt the original order of elements. Therefore, sorting would change the positions of the elements and make it impossible to correctly identify the original subarray that meets the problem\\'s requirements.\\n\\nFurthermore, the problem is asking for a subarray, not a subset. A subset of an array could include any elements from the array in any order, while a subarray is always a sequence of elements in their original order. Therefore, we infer from the use of the word \"subarray\" that maintaining the original order of elements is important.\\n\\nLastly, the nature of this problem \\u2013 finding a contiguous subarray with a certain property (in this case, a sum greater than or equal to a target) \\u2013 is a common type of problem that often involves techniques such as the sliding window approach, which operates on the array in its original order.\\n\\nSo, from the use of terms like \"subarray\", the requirement for a contiguous sequence of elements, and the nature of this type of problem, we can infer that we should not sort the array."
                    },
                    {
                        "username": "naomiacat95",
                        "content": "This array should not be sorted.\\n\\nBecause the anser is ask we to find the min length of SUBARRAY.\\n\\nAnd here is the define of subarray:\\nA subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nSo you can try other methods to solve the problem."
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Question says topic include binary search but arr not sorted ?wtt"
                    },
                    {
                        "username": "nandakumararaja",
                        "content": "Are the 209 and 862 problems the same"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rcomesan](/rcomesan) Yes, you\\'re correct. The problems 209 (\"Minimum Size Subarray Sum\") and 862 (\"Shortest Subarray with Sum at Least K\") on LeetCode are similar in their overall goal \\u2013 both problems ask for the shortest (or minimum size) subarray that meets a certain sum condition. However, they have different constraints, which affect the solution strategies.\\n\\nProblem 209 deals with an array of positive integers and a target sum, and the task is to find the smallest contiguous subarray with a sum that is equal to or greater than the target sum. Because all the integers in the array are positive, we can use a two-pointer or sliding window strategy to solve this problem efficiently.\\n\\nOn the other hand, problem 862 involves an array that can contain both positive and negative integers, and the task is to find the shortest subarray with a sum that is at least K. The presence of negative integers in this problem means that a simple two-pointer or sliding window strategy will not work, as the sum of a \"window\" of numbers can decrease even when we add numbers to it. This makes problem 862 more complex than problem 209.\\n\\nSo, while the two problems share a similar overall goal, the constraints and therefore the solution strategies are quite different. It\\'s a great observation that tackling both can provide a deeper understanding of how similar problem statements can require different approaches due to their specific conditions and constraints."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They are not. #209 contains only positive integers. #862 can also include negative integers so, it requires a whole different approach. It\\'s a good idea to solve both of them to understand the reason why a technique can or cannot be applied in each particular case."
                    }
                ]
            },
            {
                "id": 1958340,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "Those who were asking about how to binary search on this as this is not sorted or binary search will be even slower\nFirst of all leetcode knows that thinking of Sliding Window is simpler and it want us to think of all possible solutions.\nSecondly, Binary Search is possible on this nums(even it is unsorted and we aren't allowed to solve it ) as we have to find subarray of nums which is >= tar, and SINCE ALL THE NUMBER ARE POSITIVE SO PREFIX SUM OF NUMbs will be always in increasing order\n\nSteps : \nStart s = 0, e = n-1;\nget mid\nif(isValid(mid, tar, nums)) ans = mid +1, e = mid -1;\nelse s = mid +1;\n\nHere Think it like this:\nint mid = s + (e - s)/2;  // we are selecting a window of size m\n if(isValid(mid, target, pref, nums)){ // checking if any subarray is possible of wiindow size mid\n                res = mid + 1;\n                e = mid -1;   // if yes then trydecreasing window size\n    }\n     else s = mid +1;   // if no then try increasing window size\n\nhere isValid is a function which check all subarray sum of size mid.\n\nPS : IT won.t work if array contains negative elements\ngive it a try : https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\nI hope it helps."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) have you checked out today\\'s POTD ? see the editorial,, the first approach they have given is same as I\\'ve described above,, that is nlogn.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@bparanj](/bparanj) You don\\'t seem to understand very well what distinguishes a binary search from a linear one. The size of your search area is not halved as in binary search, but decreased by 1 as in linear search, which it is."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct that the binary search approach can be used in this problem, particularly because the array has all positive integers, which guarantees the prefix sum array will always be in increasing order.\\n\\nTo simplify the explanation:\\n\\nThe binary search here is not used to find an element in an array like in classic use-cases. Instead, it\\'s used to find the minimal length of a subarray whose sum is equal or greater than a given target.\\n\\nThe binary search range is the possible length of the subarray, from 1 to the length of the input array. \\n\\n- Start with two pointers s = 0 (start) and e = n-1 (end), where n is the length of the array.\\n- For each iteration, calculate the middle point \\'mid\\' and check if there exists a subarray of length \\'mid\\' whose sum is equal or greater than the target (using the \\'isValid\\' function). \\n- If such a subarray exists, update the answer to \\'mid\\' and then move the \\'end\\' pointer to \\'mid - 1\\' to continue searching for a smaller subarray length. \\n- If no such subarray exists, move the \\'start\\' pointer to \\'mid + 1\\' to search for a longer subarray length. \\n\\nThis approach continues until the binary search process finishes. This algorithm is indeed more complicated than the sliding window approach. \\n\\nIt\\'s important to note that the binary search approach wouldn\\'t work if the array contains negative elements since the prefix sum array will no longer be strictly increasing. In those cases, other techniques, such as maintaining a deque as in problem 862 on LeetCode (\"Shortest Subarray with Sum at Least K\"), are needed. \\n\\nApplying binary search in this way demonstrates the flexibility of this algorithmic strategy beyond simple sorted array search tasks.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "`e = mid -1;`\\n`else s = mid +1;`\\nThat\\'s linear search, not binary"
                    },
                    {
                        "username": "divy_kant",
                        "content": "SLIDING WINDOW WEEK \\noptimized the code from O(N^2) to O(N)."
                    },
                    {
                        "username": "sunny8080",
                        "content": "In the first glance, it seems to **Two Pointers** approach"
                    },
                    {
                        "username": "vanni1212",
                        "content": "Could you please post some suggestions about negative numbers as well ?\\n\\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/ \\nThis is the problem variant I am referring to"
                    },
                    {
                        "username": "Luffy_Tse",
                        "content": "The problem I see right now is \\n\\nsum ? s\\n\\n, which is so confusing. I thought ? was ==, but not until several failure attempts then I found that it should be >."
                    },
                    {
                        "username": "dingli",
                        "content": "hi all,\\n\\nDo you have this case? And  I think below case is wrong!!\\n\\nInput:\\n11, [1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3"
                    },
                    {
                        "username": "akash_ry",
                        "content": "Test Case:-\\n**11\\n[1,2,3,4,5]**\\n\\n**Expected Output: 3**\\nwhich in my opinion is not possible in this context\\n**Edit: This is one of this problem\\'s test case.**"
                    },
                    {
                        "username": "_vedant",
                        "content": "It\\'s mentioned that sum is greater then equal to \\n[3,4,5]>=11 which is true"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "stym7905",
                        "content": "target =\\n20\\nnums =\\n[2,16,14,15]\\n\\n\\nhow is it possible"
                    },
                    {
                        "username": "Shamim_Enamul",
                        "content": " `\\n\\nfunc minSubArrayLen(target int, nums []int) int {\\n    // sort the array\\n    sort.Ints(nums) // o(logn)\\n    // treverse through the whole array\\n    sum := 0\\n    for _, val := range nums{\\n       fmt.Println(val)\\n        sum += val\\n    }\\n    l := 0\\n    r := len(nums) - 1\\n    min_len := 0\\n    for l <= r{\\n        if sum >= target{\\n            min_len = (r - l) + 1\\n            sum -= nums[l]\\n            l++\\n        }else{\\n           break\\n        }\\n      \\n    }\\n   \\n    // check the target and update  \\n    return min_len  \\n}\\n`\\n\\ntest case: [12,28,83,4,25,26,25,2,25,25,25,12] and target = 213\\nGot : 7\\nExpected : 8\\nBut this test should return 7 as minimum length of subarray. I am struggling to understand why the expected output is 8"
                    },
                    {
                        "username": "abhishekrule9821",
                        "content": "One can use Window sliding to solve it, but it is. possible just because the problem input don\\'t involve negative numbers. If negative numbers is involved then window approach will be broken & we need to use hashing.\\n\\nIf disagree, please explain."
                    },
                    {
                        "username": "user2575jO",
                        "content": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-on-timememory/"
                    }
                ]
            },
            {
                "id": 1958131,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "Those who were asking about how to binary search on this as this is not sorted or binary search will be even slower\nFirst of all leetcode knows that thinking of Sliding Window is simpler and it want us to think of all possible solutions.\nSecondly, Binary Search is possible on this nums(even it is unsorted and we aren't allowed to solve it ) as we have to find subarray of nums which is >= tar, and SINCE ALL THE NUMBER ARE POSITIVE SO PREFIX SUM OF NUMbs will be always in increasing order\n\nSteps : \nStart s = 0, e = n-1;\nget mid\nif(isValid(mid, tar, nums)) ans = mid +1, e = mid -1;\nelse s = mid +1;\n\nHere Think it like this:\nint mid = s + (e - s)/2;  // we are selecting a window of size m\n if(isValid(mid, target, pref, nums)){ // checking if any subarray is possible of wiindow size mid\n                res = mid + 1;\n                e = mid -1;   // if yes then trydecreasing window size\n    }\n     else s = mid +1;   // if no then try increasing window size\n\nhere isValid is a function which check all subarray sum of size mid.\n\nPS : IT won.t work if array contains negative elements\ngive it a try : https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\nI hope it helps."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) have you checked out today\\'s POTD ? see the editorial,, the first approach they have given is same as I\\'ve described above,, that is nlogn.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@bparanj](/bparanj) You don\\'t seem to understand very well what distinguishes a binary search from a linear one. The size of your search area is not halved as in binary search, but decreased by 1 as in linear search, which it is."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct that the binary search approach can be used in this problem, particularly because the array has all positive integers, which guarantees the prefix sum array will always be in increasing order.\\n\\nTo simplify the explanation:\\n\\nThe binary search here is not used to find an element in an array like in classic use-cases. Instead, it\\'s used to find the minimal length of a subarray whose sum is equal or greater than a given target.\\n\\nThe binary search range is the possible length of the subarray, from 1 to the length of the input array. \\n\\n- Start with two pointers s = 0 (start) and e = n-1 (end), where n is the length of the array.\\n- For each iteration, calculate the middle point \\'mid\\' and check if there exists a subarray of length \\'mid\\' whose sum is equal or greater than the target (using the \\'isValid\\' function). \\n- If such a subarray exists, update the answer to \\'mid\\' and then move the \\'end\\' pointer to \\'mid - 1\\' to continue searching for a smaller subarray length. \\n- If no such subarray exists, move the \\'start\\' pointer to \\'mid + 1\\' to search for a longer subarray length. \\n\\nThis approach continues until the binary search process finishes. This algorithm is indeed more complicated than the sliding window approach. \\n\\nIt\\'s important to note that the binary search approach wouldn\\'t work if the array contains negative elements since the prefix sum array will no longer be strictly increasing. In those cases, other techniques, such as maintaining a deque as in problem 862 on LeetCode (\"Shortest Subarray with Sum at Least K\"), are needed. \\n\\nApplying binary search in this way demonstrates the flexibility of this algorithmic strategy beyond simple sorted array search tasks.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "`e = mid -1;`\\n`else s = mid +1;`\\nThat\\'s linear search, not binary"
                    },
                    {
                        "username": "divy_kant",
                        "content": "SLIDING WINDOW WEEK \\noptimized the code from O(N^2) to O(N)."
                    },
                    {
                        "username": "sunny8080",
                        "content": "In the first glance, it seems to **Two Pointers** approach"
                    },
                    {
                        "username": "vanni1212",
                        "content": "Could you please post some suggestions about negative numbers as well ?\\n\\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/ \\nThis is the problem variant I am referring to"
                    },
                    {
                        "username": "Luffy_Tse",
                        "content": "The problem I see right now is \\n\\nsum ? s\\n\\n, which is so confusing. I thought ? was ==, but not until several failure attempts then I found that it should be >."
                    },
                    {
                        "username": "dingli",
                        "content": "hi all,\\n\\nDo you have this case? And  I think below case is wrong!!\\n\\nInput:\\n11, [1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3"
                    },
                    {
                        "username": "akash_ry",
                        "content": "Test Case:-\\n**11\\n[1,2,3,4,5]**\\n\\n**Expected Output: 3**\\nwhich in my opinion is not possible in this context\\n**Edit: This is one of this problem\\'s test case.**"
                    },
                    {
                        "username": "_vedant",
                        "content": "It\\'s mentioned that sum is greater then equal to \\n[3,4,5]>=11 which is true"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "stym7905",
                        "content": "target =\\n20\\nnums =\\n[2,16,14,15]\\n\\n\\nhow is it possible"
                    },
                    {
                        "username": "Shamim_Enamul",
                        "content": " `\\n\\nfunc minSubArrayLen(target int, nums []int) int {\\n    // sort the array\\n    sort.Ints(nums) // o(logn)\\n    // treverse through the whole array\\n    sum := 0\\n    for _, val := range nums{\\n       fmt.Println(val)\\n        sum += val\\n    }\\n    l := 0\\n    r := len(nums) - 1\\n    min_len := 0\\n    for l <= r{\\n        if sum >= target{\\n            min_len = (r - l) + 1\\n            sum -= nums[l]\\n            l++\\n        }else{\\n           break\\n        }\\n      \\n    }\\n   \\n    // check the target and update  \\n    return min_len  \\n}\\n`\\n\\ntest case: [12,28,83,4,25,26,25,2,25,25,25,12] and target = 213\\nGot : 7\\nExpected : 8\\nBut this test should return 7 as minimum length of subarray. I am struggling to understand why the expected output is 8"
                    },
                    {
                        "username": "abhishekrule9821",
                        "content": "One can use Window sliding to solve it, but it is. possible just because the problem input don\\'t involve negative numbers. If negative numbers is involved then window approach will be broken & we need to use hashing.\\n\\nIf disagree, please explain."
                    },
                    {
                        "username": "user2575jO",
                        "content": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-on-timememory/"
                    }
                ]
            },
            {
                "id": 1958101,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "Those who were asking about how to binary search on this as this is not sorted or binary search will be even slower\nFirst of all leetcode knows that thinking of Sliding Window is simpler and it want us to think of all possible solutions.\nSecondly, Binary Search is possible on this nums(even it is unsorted and we aren't allowed to solve it ) as we have to find subarray of nums which is >= tar, and SINCE ALL THE NUMBER ARE POSITIVE SO PREFIX SUM OF NUMbs will be always in increasing order\n\nSteps : \nStart s = 0, e = n-1;\nget mid\nif(isValid(mid, tar, nums)) ans = mid +1, e = mid -1;\nelse s = mid +1;\n\nHere Think it like this:\nint mid = s + (e - s)/2;  // we are selecting a window of size m\n if(isValid(mid, target, pref, nums)){ // checking if any subarray is possible of wiindow size mid\n                res = mid + 1;\n                e = mid -1;   // if yes then trydecreasing window size\n    }\n     else s = mid +1;   // if no then try increasing window size\n\nhere isValid is a function which check all subarray sum of size mid.\n\nPS : IT won.t work if array contains negative elements\ngive it a try : https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\nI hope it helps."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) have you checked out today\\'s POTD ? see the editorial,, the first approach they have given is same as I\\'ve described above,, that is nlogn.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@bparanj](/bparanj) You don\\'t seem to understand very well what distinguishes a binary search from a linear one. The size of your search area is not halved as in binary search, but decreased by 1 as in linear search, which it is."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct that the binary search approach can be used in this problem, particularly because the array has all positive integers, which guarantees the prefix sum array will always be in increasing order.\\n\\nTo simplify the explanation:\\n\\nThe binary search here is not used to find an element in an array like in classic use-cases. Instead, it\\'s used to find the minimal length of a subarray whose sum is equal or greater than a given target.\\n\\nThe binary search range is the possible length of the subarray, from 1 to the length of the input array. \\n\\n- Start with two pointers s = 0 (start) and e = n-1 (end), where n is the length of the array.\\n- For each iteration, calculate the middle point \\'mid\\' and check if there exists a subarray of length \\'mid\\' whose sum is equal or greater than the target (using the \\'isValid\\' function). \\n- If such a subarray exists, update the answer to \\'mid\\' and then move the \\'end\\' pointer to \\'mid - 1\\' to continue searching for a smaller subarray length. \\n- If no such subarray exists, move the \\'start\\' pointer to \\'mid + 1\\' to search for a longer subarray length. \\n\\nThis approach continues until the binary search process finishes. This algorithm is indeed more complicated than the sliding window approach. \\n\\nIt\\'s important to note that the binary search approach wouldn\\'t work if the array contains negative elements since the prefix sum array will no longer be strictly increasing. In those cases, other techniques, such as maintaining a deque as in problem 862 on LeetCode (\"Shortest Subarray with Sum at Least K\"), are needed. \\n\\nApplying binary search in this way demonstrates the flexibility of this algorithmic strategy beyond simple sorted array search tasks.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "`e = mid -1;`\\n`else s = mid +1;`\\nThat\\'s linear search, not binary"
                    },
                    {
                        "username": "divy_kant",
                        "content": "SLIDING WINDOW WEEK \\noptimized the code from O(N^2) to O(N)."
                    },
                    {
                        "username": "sunny8080",
                        "content": "In the first glance, it seems to **Two Pointers** approach"
                    },
                    {
                        "username": "vanni1212",
                        "content": "Could you please post some suggestions about negative numbers as well ?\\n\\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/ \\nThis is the problem variant I am referring to"
                    },
                    {
                        "username": "Luffy_Tse",
                        "content": "The problem I see right now is \\n\\nsum ? s\\n\\n, which is so confusing. I thought ? was ==, but not until several failure attempts then I found that it should be >."
                    },
                    {
                        "username": "dingli",
                        "content": "hi all,\\n\\nDo you have this case? And  I think below case is wrong!!\\n\\nInput:\\n11, [1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3"
                    },
                    {
                        "username": "akash_ry",
                        "content": "Test Case:-\\n**11\\n[1,2,3,4,5]**\\n\\n**Expected Output: 3**\\nwhich in my opinion is not possible in this context\\n**Edit: This is one of this problem\\'s test case.**"
                    },
                    {
                        "username": "_vedant",
                        "content": "It\\'s mentioned that sum is greater then equal to \\n[3,4,5]>=11 which is true"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "stym7905",
                        "content": "target =\\n20\\nnums =\\n[2,16,14,15]\\n\\n\\nhow is it possible"
                    },
                    {
                        "username": "Shamim_Enamul",
                        "content": " `\\n\\nfunc minSubArrayLen(target int, nums []int) int {\\n    // sort the array\\n    sort.Ints(nums) // o(logn)\\n    // treverse through the whole array\\n    sum := 0\\n    for _, val := range nums{\\n       fmt.Println(val)\\n        sum += val\\n    }\\n    l := 0\\n    r := len(nums) - 1\\n    min_len := 0\\n    for l <= r{\\n        if sum >= target{\\n            min_len = (r - l) + 1\\n            sum -= nums[l]\\n            l++\\n        }else{\\n           break\\n        }\\n      \\n    }\\n   \\n    // check the target and update  \\n    return min_len  \\n}\\n`\\n\\ntest case: [12,28,83,4,25,26,25,2,25,25,25,12] and target = 213\\nGot : 7\\nExpected : 8\\nBut this test should return 7 as minimum length of subarray. I am struggling to understand why the expected output is 8"
                    },
                    {
                        "username": "abhishekrule9821",
                        "content": "One can use Window sliding to solve it, but it is. possible just because the problem input don\\'t involve negative numbers. If negative numbers is involved then window approach will be broken & we need to use hashing.\\n\\nIf disagree, please explain."
                    },
                    {
                        "username": "user2575jO",
                        "content": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-on-timememory/"
                    }
                ]
            },
            {
                "id": 1572014,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "Those who were asking about how to binary search on this as this is not sorted or binary search will be even slower\nFirst of all leetcode knows that thinking of Sliding Window is simpler and it want us to think of all possible solutions.\nSecondly, Binary Search is possible on this nums(even it is unsorted and we aren't allowed to solve it ) as we have to find subarray of nums which is >= tar, and SINCE ALL THE NUMBER ARE POSITIVE SO PREFIX SUM OF NUMbs will be always in increasing order\n\nSteps : \nStart s = 0, e = n-1;\nget mid\nif(isValid(mid, tar, nums)) ans = mid +1, e = mid -1;\nelse s = mid +1;\n\nHere Think it like this:\nint mid = s + (e - s)/2;  // we are selecting a window of size m\n if(isValid(mid, target, pref, nums)){ // checking if any subarray is possible of wiindow size mid\n                res = mid + 1;\n                e = mid -1;   // if yes then trydecreasing window size\n    }\n     else s = mid +1;   // if no then try increasing window size\n\nhere isValid is a function which check all subarray sum of size mid.\n\nPS : IT won.t work if array contains negative elements\ngive it a try : https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\nI hope it helps."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) have you checked out today\\'s POTD ? see the editorial,, the first approach they have given is same as I\\'ve described above,, that is nlogn.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@bparanj](/bparanj) You don\\'t seem to understand very well what distinguishes a binary search from a linear one. The size of your search area is not halved as in binary search, but decreased by 1 as in linear search, which it is."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct that the binary search approach can be used in this problem, particularly because the array has all positive integers, which guarantees the prefix sum array will always be in increasing order.\\n\\nTo simplify the explanation:\\n\\nThe binary search here is not used to find an element in an array like in classic use-cases. Instead, it\\'s used to find the minimal length of a subarray whose sum is equal or greater than a given target.\\n\\nThe binary search range is the possible length of the subarray, from 1 to the length of the input array. \\n\\n- Start with two pointers s = 0 (start) and e = n-1 (end), where n is the length of the array.\\n- For each iteration, calculate the middle point \\'mid\\' and check if there exists a subarray of length \\'mid\\' whose sum is equal or greater than the target (using the \\'isValid\\' function). \\n- If such a subarray exists, update the answer to \\'mid\\' and then move the \\'end\\' pointer to \\'mid - 1\\' to continue searching for a smaller subarray length. \\n- If no such subarray exists, move the \\'start\\' pointer to \\'mid + 1\\' to search for a longer subarray length. \\n\\nThis approach continues until the binary search process finishes. This algorithm is indeed more complicated than the sliding window approach. \\n\\nIt\\'s important to note that the binary search approach wouldn\\'t work if the array contains negative elements since the prefix sum array will no longer be strictly increasing. In those cases, other techniques, such as maintaining a deque as in problem 862 on LeetCode (\"Shortest Subarray with Sum at Least K\"), are needed. \\n\\nApplying binary search in this way demonstrates the flexibility of this algorithmic strategy beyond simple sorted array search tasks.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "`e = mid -1;`\\n`else s = mid +1;`\\nThat\\'s linear search, not binary"
                    },
                    {
                        "username": "divy_kant",
                        "content": "SLIDING WINDOW WEEK \\noptimized the code from O(N^2) to O(N)."
                    },
                    {
                        "username": "sunny8080",
                        "content": "In the first glance, it seems to **Two Pointers** approach"
                    },
                    {
                        "username": "vanni1212",
                        "content": "Could you please post some suggestions about negative numbers as well ?\\n\\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/ \\nThis is the problem variant I am referring to"
                    },
                    {
                        "username": "Luffy_Tse",
                        "content": "The problem I see right now is \\n\\nsum ? s\\n\\n, which is so confusing. I thought ? was ==, but not until several failure attempts then I found that it should be >."
                    },
                    {
                        "username": "dingli",
                        "content": "hi all,\\n\\nDo you have this case? And  I think below case is wrong!!\\n\\nInput:\\n11, [1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3"
                    },
                    {
                        "username": "akash_ry",
                        "content": "Test Case:-\\n**11\\n[1,2,3,4,5]**\\n\\n**Expected Output: 3**\\nwhich in my opinion is not possible in this context\\n**Edit: This is one of this problem\\'s test case.**"
                    },
                    {
                        "username": "_vedant",
                        "content": "It\\'s mentioned that sum is greater then equal to \\n[3,4,5]>=11 which is true"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "stym7905",
                        "content": "target =\\n20\\nnums =\\n[2,16,14,15]\\n\\n\\nhow is it possible"
                    },
                    {
                        "username": "Shamim_Enamul",
                        "content": " `\\n\\nfunc minSubArrayLen(target int, nums []int) int {\\n    // sort the array\\n    sort.Ints(nums) // o(logn)\\n    // treverse through the whole array\\n    sum := 0\\n    for _, val := range nums{\\n       fmt.Println(val)\\n        sum += val\\n    }\\n    l := 0\\n    r := len(nums) - 1\\n    min_len := 0\\n    for l <= r{\\n        if sum >= target{\\n            min_len = (r - l) + 1\\n            sum -= nums[l]\\n            l++\\n        }else{\\n           break\\n        }\\n      \\n    }\\n   \\n    // check the target and update  \\n    return min_len  \\n}\\n`\\n\\ntest case: [12,28,83,4,25,26,25,2,25,25,25,12] and target = 213\\nGot : 7\\nExpected : 8\\nBut this test should return 7 as minimum length of subarray. I am struggling to understand why the expected output is 8"
                    },
                    {
                        "username": "abhishekrule9821",
                        "content": "One can use Window sliding to solve it, but it is. possible just because the problem input don\\'t involve negative numbers. If negative numbers is involved then window approach will be broken & we need to use hashing.\\n\\nIf disagree, please explain."
                    },
                    {
                        "username": "user2575jO",
                        "content": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-on-timememory/"
                    }
                ]
            },
            {
                "id": 1571427,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "Those who were asking about how to binary search on this as this is not sorted or binary search will be even slower\nFirst of all leetcode knows that thinking of Sliding Window is simpler and it want us to think of all possible solutions.\nSecondly, Binary Search is possible on this nums(even it is unsorted and we aren't allowed to solve it ) as we have to find subarray of nums which is >= tar, and SINCE ALL THE NUMBER ARE POSITIVE SO PREFIX SUM OF NUMbs will be always in increasing order\n\nSteps : \nStart s = 0, e = n-1;\nget mid\nif(isValid(mid, tar, nums)) ans = mid +1, e = mid -1;\nelse s = mid +1;\n\nHere Think it like this:\nint mid = s + (e - s)/2;  // we are selecting a window of size m\n if(isValid(mid, target, pref, nums)){ // checking if any subarray is possible of wiindow size mid\n                res = mid + 1;\n                e = mid -1;   // if yes then trydecreasing window size\n    }\n     else s = mid +1;   // if no then try increasing window size\n\nhere isValid is a function which check all subarray sum of size mid.\n\nPS : IT won.t work if array contains negative elements\ngive it a try : https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\nI hope it helps."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) have you checked out today\\'s POTD ? see the editorial,, the first approach they have given is same as I\\'ve described above,, that is nlogn.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@bparanj](/bparanj) You don\\'t seem to understand very well what distinguishes a binary search from a linear one. The size of your search area is not halved as in binary search, but decreased by 1 as in linear search, which it is."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct that the binary search approach can be used in this problem, particularly because the array has all positive integers, which guarantees the prefix sum array will always be in increasing order.\\n\\nTo simplify the explanation:\\n\\nThe binary search here is not used to find an element in an array like in classic use-cases. Instead, it\\'s used to find the minimal length of a subarray whose sum is equal or greater than a given target.\\n\\nThe binary search range is the possible length of the subarray, from 1 to the length of the input array. \\n\\n- Start with two pointers s = 0 (start) and e = n-1 (end), where n is the length of the array.\\n- For each iteration, calculate the middle point \\'mid\\' and check if there exists a subarray of length \\'mid\\' whose sum is equal or greater than the target (using the \\'isValid\\' function). \\n- If such a subarray exists, update the answer to \\'mid\\' and then move the \\'end\\' pointer to \\'mid - 1\\' to continue searching for a smaller subarray length. \\n- If no such subarray exists, move the \\'start\\' pointer to \\'mid + 1\\' to search for a longer subarray length. \\n\\nThis approach continues until the binary search process finishes. This algorithm is indeed more complicated than the sliding window approach. \\n\\nIt\\'s important to note that the binary search approach wouldn\\'t work if the array contains negative elements since the prefix sum array will no longer be strictly increasing. In those cases, other techniques, such as maintaining a deque as in problem 862 on LeetCode (\"Shortest Subarray with Sum at Least K\"), are needed. \\n\\nApplying binary search in this way demonstrates the flexibility of this algorithmic strategy beyond simple sorted array search tasks.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "`e = mid -1;`\\n`else s = mid +1;`\\nThat\\'s linear search, not binary"
                    },
                    {
                        "username": "divy_kant",
                        "content": "SLIDING WINDOW WEEK \\noptimized the code from O(N^2) to O(N)."
                    },
                    {
                        "username": "sunny8080",
                        "content": "In the first glance, it seems to **Two Pointers** approach"
                    },
                    {
                        "username": "vanni1212",
                        "content": "Could you please post some suggestions about negative numbers as well ?\\n\\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/ \\nThis is the problem variant I am referring to"
                    },
                    {
                        "username": "Luffy_Tse",
                        "content": "The problem I see right now is \\n\\nsum ? s\\n\\n, which is so confusing. I thought ? was ==, but not until several failure attempts then I found that it should be >."
                    },
                    {
                        "username": "dingli",
                        "content": "hi all,\\n\\nDo you have this case? And  I think below case is wrong!!\\n\\nInput:\\n11, [1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3"
                    },
                    {
                        "username": "akash_ry",
                        "content": "Test Case:-\\n**11\\n[1,2,3,4,5]**\\n\\n**Expected Output: 3**\\nwhich in my opinion is not possible in this context\\n**Edit: This is one of this problem\\'s test case.**"
                    },
                    {
                        "username": "_vedant",
                        "content": "It\\'s mentioned that sum is greater then equal to \\n[3,4,5]>=11 which is true"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "stym7905",
                        "content": "target =\\n20\\nnums =\\n[2,16,14,15]\\n\\n\\nhow is it possible"
                    },
                    {
                        "username": "Shamim_Enamul",
                        "content": " `\\n\\nfunc minSubArrayLen(target int, nums []int) int {\\n    // sort the array\\n    sort.Ints(nums) // o(logn)\\n    // treverse through the whole array\\n    sum := 0\\n    for _, val := range nums{\\n       fmt.Println(val)\\n        sum += val\\n    }\\n    l := 0\\n    r := len(nums) - 1\\n    min_len := 0\\n    for l <= r{\\n        if sum >= target{\\n            min_len = (r - l) + 1\\n            sum -= nums[l]\\n            l++\\n        }else{\\n           break\\n        }\\n      \\n    }\\n   \\n    // check the target and update  \\n    return min_len  \\n}\\n`\\n\\ntest case: [12,28,83,4,25,26,25,2,25,25,25,12] and target = 213\\nGot : 7\\nExpected : 8\\nBut this test should return 7 as minimum length of subarray. I am struggling to understand why the expected output is 8"
                    },
                    {
                        "username": "abhishekrule9821",
                        "content": "One can use Window sliding to solve it, but it is. possible just because the problem input don\\'t involve negative numbers. If negative numbers is involved then window approach will be broken & we need to use hashing.\\n\\nIf disagree, please explain."
                    },
                    {
                        "username": "user2575jO",
                        "content": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-on-timememory/"
                    }
                ]
            },
            {
                "id": 1569023,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "Those who were asking about how to binary search on this as this is not sorted or binary search will be even slower\nFirst of all leetcode knows that thinking of Sliding Window is simpler and it want us to think of all possible solutions.\nSecondly, Binary Search is possible on this nums(even it is unsorted and we aren't allowed to solve it ) as we have to find subarray of nums which is >= tar, and SINCE ALL THE NUMBER ARE POSITIVE SO PREFIX SUM OF NUMbs will be always in increasing order\n\nSteps : \nStart s = 0, e = n-1;\nget mid\nif(isValid(mid, tar, nums)) ans = mid +1, e = mid -1;\nelse s = mid +1;\n\nHere Think it like this:\nint mid = s + (e - s)/2;  // we are selecting a window of size m\n if(isValid(mid, target, pref, nums)){ // checking if any subarray is possible of wiindow size mid\n                res = mid + 1;\n                e = mid -1;   // if yes then trydecreasing window size\n    }\n     else s = mid +1;   // if no then try increasing window size\n\nhere isValid is a function which check all subarray sum of size mid.\n\nPS : IT won.t work if array contains negative elements\ngive it a try : https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\nI hope it helps."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) have you checked out today\\'s POTD ? see the editorial,, the first approach they have given is same as I\\'ve described above,, that is nlogn.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@bparanj](/bparanj) You don\\'t seem to understand very well what distinguishes a binary search from a linear one. The size of your search area is not halved as in binary search, but decreased by 1 as in linear search, which it is."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct that the binary search approach can be used in this problem, particularly because the array has all positive integers, which guarantees the prefix sum array will always be in increasing order.\\n\\nTo simplify the explanation:\\n\\nThe binary search here is not used to find an element in an array like in classic use-cases. Instead, it\\'s used to find the minimal length of a subarray whose sum is equal or greater than a given target.\\n\\nThe binary search range is the possible length of the subarray, from 1 to the length of the input array. \\n\\n- Start with two pointers s = 0 (start) and e = n-1 (end), where n is the length of the array.\\n- For each iteration, calculate the middle point \\'mid\\' and check if there exists a subarray of length \\'mid\\' whose sum is equal or greater than the target (using the \\'isValid\\' function). \\n- If such a subarray exists, update the answer to \\'mid\\' and then move the \\'end\\' pointer to \\'mid - 1\\' to continue searching for a smaller subarray length. \\n- If no such subarray exists, move the \\'start\\' pointer to \\'mid + 1\\' to search for a longer subarray length. \\n\\nThis approach continues until the binary search process finishes. This algorithm is indeed more complicated than the sliding window approach. \\n\\nIt\\'s important to note that the binary search approach wouldn\\'t work if the array contains negative elements since the prefix sum array will no longer be strictly increasing. In those cases, other techniques, such as maintaining a deque as in problem 862 on LeetCode (\"Shortest Subarray with Sum at Least K\"), are needed. \\n\\nApplying binary search in this way demonstrates the flexibility of this algorithmic strategy beyond simple sorted array search tasks.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "`e = mid -1;`\\n`else s = mid +1;`\\nThat\\'s linear search, not binary"
                    },
                    {
                        "username": "divy_kant",
                        "content": "SLIDING WINDOW WEEK \\noptimized the code from O(N^2) to O(N)."
                    },
                    {
                        "username": "sunny8080",
                        "content": "In the first glance, it seems to **Two Pointers** approach"
                    },
                    {
                        "username": "vanni1212",
                        "content": "Could you please post some suggestions about negative numbers as well ?\\n\\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/ \\nThis is the problem variant I am referring to"
                    },
                    {
                        "username": "Luffy_Tse",
                        "content": "The problem I see right now is \\n\\nsum ? s\\n\\n, which is so confusing. I thought ? was ==, but not until several failure attempts then I found that it should be >."
                    },
                    {
                        "username": "dingli",
                        "content": "hi all,\\n\\nDo you have this case? And  I think below case is wrong!!\\n\\nInput:\\n11, [1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3"
                    },
                    {
                        "username": "akash_ry",
                        "content": "Test Case:-\\n**11\\n[1,2,3,4,5]**\\n\\n**Expected Output: 3**\\nwhich in my opinion is not possible in this context\\n**Edit: This is one of this problem\\'s test case.**"
                    },
                    {
                        "username": "_vedant",
                        "content": "It\\'s mentioned that sum is greater then equal to \\n[3,4,5]>=11 which is true"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "stym7905",
                        "content": "target =\\n20\\nnums =\\n[2,16,14,15]\\n\\n\\nhow is it possible"
                    },
                    {
                        "username": "Shamim_Enamul",
                        "content": " `\\n\\nfunc minSubArrayLen(target int, nums []int) int {\\n    // sort the array\\n    sort.Ints(nums) // o(logn)\\n    // treverse through the whole array\\n    sum := 0\\n    for _, val := range nums{\\n       fmt.Println(val)\\n        sum += val\\n    }\\n    l := 0\\n    r := len(nums) - 1\\n    min_len := 0\\n    for l <= r{\\n        if sum >= target{\\n            min_len = (r - l) + 1\\n            sum -= nums[l]\\n            l++\\n        }else{\\n           break\\n        }\\n      \\n    }\\n   \\n    // check the target and update  \\n    return min_len  \\n}\\n`\\n\\ntest case: [12,28,83,4,25,26,25,2,25,25,25,12] and target = 213\\nGot : 7\\nExpected : 8\\nBut this test should return 7 as minimum length of subarray. I am struggling to understand why the expected output is 8"
                    },
                    {
                        "username": "abhishekrule9821",
                        "content": "One can use Window sliding to solve it, but it is. possible just because the problem input don\\'t involve negative numbers. If negative numbers is involved then window approach will be broken & we need to use hashing.\\n\\nIf disagree, please explain."
                    },
                    {
                        "username": "user2575jO",
                        "content": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-on-timememory/"
                    }
                ]
            },
            {
                "id": 1575594,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "Those who were asking about how to binary search on this as this is not sorted or binary search will be even slower\nFirst of all leetcode knows that thinking of Sliding Window is simpler and it want us to think of all possible solutions.\nSecondly, Binary Search is possible on this nums(even it is unsorted and we aren't allowed to solve it ) as we have to find subarray of nums which is >= tar, and SINCE ALL THE NUMBER ARE POSITIVE SO PREFIX SUM OF NUMbs will be always in increasing order\n\nSteps : \nStart s = 0, e = n-1;\nget mid\nif(isValid(mid, tar, nums)) ans = mid +1, e = mid -1;\nelse s = mid +1;\n\nHere Think it like this:\nint mid = s + (e - s)/2;  // we are selecting a window of size m\n if(isValid(mid, target, pref, nums)){ // checking if any subarray is possible of wiindow size mid\n                res = mid + 1;\n                e = mid -1;   // if yes then trydecreasing window size\n    }\n     else s = mid +1;   // if no then try increasing window size\n\nhere isValid is a function which check all subarray sum of size mid.\n\nPS : IT won.t work if array contains negative elements\ngive it a try : https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\nI hope it helps."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) have you checked out today\\'s POTD ? see the editorial,, the first approach they have given is same as I\\'ve described above,, that is nlogn.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@bparanj](/bparanj) You don\\'t seem to understand very well what distinguishes a binary search from a linear one. The size of your search area is not halved as in binary search, but decreased by 1 as in linear search, which it is."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct that the binary search approach can be used in this problem, particularly because the array has all positive integers, which guarantees the prefix sum array will always be in increasing order.\\n\\nTo simplify the explanation:\\n\\nThe binary search here is not used to find an element in an array like in classic use-cases. Instead, it\\'s used to find the minimal length of a subarray whose sum is equal or greater than a given target.\\n\\nThe binary search range is the possible length of the subarray, from 1 to the length of the input array. \\n\\n- Start with two pointers s = 0 (start) and e = n-1 (end), where n is the length of the array.\\n- For each iteration, calculate the middle point \\'mid\\' and check if there exists a subarray of length \\'mid\\' whose sum is equal or greater than the target (using the \\'isValid\\' function). \\n- If such a subarray exists, update the answer to \\'mid\\' and then move the \\'end\\' pointer to \\'mid - 1\\' to continue searching for a smaller subarray length. \\n- If no such subarray exists, move the \\'start\\' pointer to \\'mid + 1\\' to search for a longer subarray length. \\n\\nThis approach continues until the binary search process finishes. This algorithm is indeed more complicated than the sliding window approach. \\n\\nIt\\'s important to note that the binary search approach wouldn\\'t work if the array contains negative elements since the prefix sum array will no longer be strictly increasing. In those cases, other techniques, such as maintaining a deque as in problem 862 on LeetCode (\"Shortest Subarray with Sum at Least K\"), are needed. \\n\\nApplying binary search in this way demonstrates the flexibility of this algorithmic strategy beyond simple sorted array search tasks.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "`e = mid -1;`\\n`else s = mid +1;`\\nThat\\'s linear search, not binary"
                    },
                    {
                        "username": "divy_kant",
                        "content": "SLIDING WINDOW WEEK \\noptimized the code from O(N^2) to O(N)."
                    },
                    {
                        "username": "sunny8080",
                        "content": "In the first glance, it seems to **Two Pointers** approach"
                    },
                    {
                        "username": "vanni1212",
                        "content": "Could you please post some suggestions about negative numbers as well ?\\n\\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/ \\nThis is the problem variant I am referring to"
                    },
                    {
                        "username": "Luffy_Tse",
                        "content": "The problem I see right now is \\n\\nsum ? s\\n\\n, which is so confusing. I thought ? was ==, but not until several failure attempts then I found that it should be >."
                    },
                    {
                        "username": "dingli",
                        "content": "hi all,\\n\\nDo you have this case? And  I think below case is wrong!!\\n\\nInput:\\n11, [1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3"
                    },
                    {
                        "username": "akash_ry",
                        "content": "Test Case:-\\n**11\\n[1,2,3,4,5]**\\n\\n**Expected Output: 3**\\nwhich in my opinion is not possible in this context\\n**Edit: This is one of this problem\\'s test case.**"
                    },
                    {
                        "username": "_vedant",
                        "content": "It\\'s mentioned that sum is greater then equal to \\n[3,4,5]>=11 which is true"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "stym7905",
                        "content": "target =\\n20\\nnums =\\n[2,16,14,15]\\n\\n\\nhow is it possible"
                    },
                    {
                        "username": "Shamim_Enamul",
                        "content": " `\\n\\nfunc minSubArrayLen(target int, nums []int) int {\\n    // sort the array\\n    sort.Ints(nums) // o(logn)\\n    // treverse through the whole array\\n    sum := 0\\n    for _, val := range nums{\\n       fmt.Println(val)\\n        sum += val\\n    }\\n    l := 0\\n    r := len(nums) - 1\\n    min_len := 0\\n    for l <= r{\\n        if sum >= target{\\n            min_len = (r - l) + 1\\n            sum -= nums[l]\\n            l++\\n        }else{\\n           break\\n        }\\n      \\n    }\\n   \\n    // check the target and update  \\n    return min_len  \\n}\\n`\\n\\ntest case: [12,28,83,4,25,26,25,2,25,25,25,12] and target = 213\\nGot : 7\\nExpected : 8\\nBut this test should return 7 as minimum length of subarray. I am struggling to understand why the expected output is 8"
                    },
                    {
                        "username": "abhishekrule9821",
                        "content": "One can use Window sliding to solve it, but it is. possible just because the problem input don\\'t involve negative numbers. If negative numbers is involved then window approach will be broken & we need to use hashing.\\n\\nIf disagree, please explain."
                    },
                    {
                        "username": "user2575jO",
                        "content": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-on-timememory/"
                    }
                ]
            },
            {
                "id": 2070628,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "Those who were asking about how to binary search on this as this is not sorted or binary search will be even slower\nFirst of all leetcode knows that thinking of Sliding Window is simpler and it want us to think of all possible solutions.\nSecondly, Binary Search is possible on this nums(even it is unsorted and we aren't allowed to solve it ) as we have to find subarray of nums which is >= tar, and SINCE ALL THE NUMBER ARE POSITIVE SO PREFIX SUM OF NUMbs will be always in increasing order\n\nSteps : \nStart s = 0, e = n-1;\nget mid\nif(isValid(mid, tar, nums)) ans = mid +1, e = mid -1;\nelse s = mid +1;\n\nHere Think it like this:\nint mid = s + (e - s)/2;  // we are selecting a window of size m\n if(isValid(mid, target, pref, nums)){ // checking if any subarray is possible of wiindow size mid\n                res = mid + 1;\n                e = mid -1;   // if yes then trydecreasing window size\n    }\n     else s = mid +1;   // if no then try increasing window size\n\nhere isValid is a function which check all subarray sum of size mid.\n\nPS : IT won.t work if array contains negative elements\ngive it a try : https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\nI hope it helps."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) have you checked out today\\'s POTD ? see the editorial,, the first approach they have given is same as I\\'ve described above,, that is nlogn.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@bparanj](/bparanj) You don\\'t seem to understand very well what distinguishes a binary search from a linear one. The size of your search area is not halved as in binary search, but decreased by 1 as in linear search, which it is."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct that the binary search approach can be used in this problem, particularly because the array has all positive integers, which guarantees the prefix sum array will always be in increasing order.\\n\\nTo simplify the explanation:\\n\\nThe binary search here is not used to find an element in an array like in classic use-cases. Instead, it\\'s used to find the minimal length of a subarray whose sum is equal or greater than a given target.\\n\\nThe binary search range is the possible length of the subarray, from 1 to the length of the input array. \\n\\n- Start with two pointers s = 0 (start) and e = n-1 (end), where n is the length of the array.\\n- For each iteration, calculate the middle point \\'mid\\' and check if there exists a subarray of length \\'mid\\' whose sum is equal or greater than the target (using the \\'isValid\\' function). \\n- If such a subarray exists, update the answer to \\'mid\\' and then move the \\'end\\' pointer to \\'mid - 1\\' to continue searching for a smaller subarray length. \\n- If no such subarray exists, move the \\'start\\' pointer to \\'mid + 1\\' to search for a longer subarray length. \\n\\nThis approach continues until the binary search process finishes. This algorithm is indeed more complicated than the sliding window approach. \\n\\nIt\\'s important to note that the binary search approach wouldn\\'t work if the array contains negative elements since the prefix sum array will no longer be strictly increasing. In those cases, other techniques, such as maintaining a deque as in problem 862 on LeetCode (\"Shortest Subarray with Sum at Least K\"), are needed. \\n\\nApplying binary search in this way demonstrates the flexibility of this algorithmic strategy beyond simple sorted array search tasks.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "`e = mid -1;`\\n`else s = mid +1;`\\nThat\\'s linear search, not binary"
                    },
                    {
                        "username": "divy_kant",
                        "content": "SLIDING WINDOW WEEK \\noptimized the code from O(N^2) to O(N)."
                    },
                    {
                        "username": "sunny8080",
                        "content": "In the first glance, it seems to **Two Pointers** approach"
                    },
                    {
                        "username": "vanni1212",
                        "content": "Could you please post some suggestions about negative numbers as well ?\\n\\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/ \\nThis is the problem variant I am referring to"
                    },
                    {
                        "username": "Luffy_Tse",
                        "content": "The problem I see right now is \\n\\nsum ? s\\n\\n, which is so confusing. I thought ? was ==, but not until several failure attempts then I found that it should be >."
                    },
                    {
                        "username": "dingli",
                        "content": "hi all,\\n\\nDo you have this case? And  I think below case is wrong!!\\n\\nInput:\\n11, [1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3"
                    },
                    {
                        "username": "akash_ry",
                        "content": "Test Case:-\\n**11\\n[1,2,3,4,5]**\\n\\n**Expected Output: 3**\\nwhich in my opinion is not possible in this context\\n**Edit: This is one of this problem\\'s test case.**"
                    },
                    {
                        "username": "_vedant",
                        "content": "It\\'s mentioned that sum is greater then equal to \\n[3,4,5]>=11 which is true"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "stym7905",
                        "content": "target =\\n20\\nnums =\\n[2,16,14,15]\\n\\n\\nhow is it possible"
                    },
                    {
                        "username": "Shamim_Enamul",
                        "content": " `\\n\\nfunc minSubArrayLen(target int, nums []int) int {\\n    // sort the array\\n    sort.Ints(nums) // o(logn)\\n    // treverse through the whole array\\n    sum := 0\\n    for _, val := range nums{\\n       fmt.Println(val)\\n        sum += val\\n    }\\n    l := 0\\n    r := len(nums) - 1\\n    min_len := 0\\n    for l <= r{\\n        if sum >= target{\\n            min_len = (r - l) + 1\\n            sum -= nums[l]\\n            l++\\n        }else{\\n           break\\n        }\\n      \\n    }\\n   \\n    // check the target and update  \\n    return min_len  \\n}\\n`\\n\\ntest case: [12,28,83,4,25,26,25,2,25,25,25,12] and target = 213\\nGot : 7\\nExpected : 8\\nBut this test should return 7 as minimum length of subarray. I am struggling to understand why the expected output is 8"
                    },
                    {
                        "username": "abhishekrule9821",
                        "content": "One can use Window sliding to solve it, but it is. possible just because the problem input don\\'t involve negative numbers. If negative numbers is involved then window approach will be broken & we need to use hashing.\\n\\nIf disagree, please explain."
                    },
                    {
                        "username": "user2575jO",
                        "content": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-on-timememory/"
                    }
                ]
            },
            {
                "id": 2068066,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "Those who were asking about how to binary search on this as this is not sorted or binary search will be even slower\nFirst of all leetcode knows that thinking of Sliding Window is simpler and it want us to think of all possible solutions.\nSecondly, Binary Search is possible on this nums(even it is unsorted and we aren't allowed to solve it ) as we have to find subarray of nums which is >= tar, and SINCE ALL THE NUMBER ARE POSITIVE SO PREFIX SUM OF NUMbs will be always in increasing order\n\nSteps : \nStart s = 0, e = n-1;\nget mid\nif(isValid(mid, tar, nums)) ans = mid +1, e = mid -1;\nelse s = mid +1;\n\nHere Think it like this:\nint mid = s + (e - s)/2;  // we are selecting a window of size m\n if(isValid(mid, target, pref, nums)){ // checking if any subarray is possible of wiindow size mid\n                res = mid + 1;\n                e = mid -1;   // if yes then trydecreasing window size\n    }\n     else s = mid +1;   // if no then try increasing window size\n\nhere isValid is a function which check all subarray sum of size mid.\n\nPS : IT won.t work if array contains negative elements\ngive it a try : https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\nI hope it helps."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) have you checked out today\\'s POTD ? see the editorial,, the first approach they have given is same as I\\'ve described above,, that is nlogn.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@bparanj](/bparanj) You don\\'t seem to understand very well what distinguishes a binary search from a linear one. The size of your search area is not halved as in binary search, but decreased by 1 as in linear search, which it is."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct that the binary search approach can be used in this problem, particularly because the array has all positive integers, which guarantees the prefix sum array will always be in increasing order.\\n\\nTo simplify the explanation:\\n\\nThe binary search here is not used to find an element in an array like in classic use-cases. Instead, it\\'s used to find the minimal length of a subarray whose sum is equal or greater than a given target.\\n\\nThe binary search range is the possible length of the subarray, from 1 to the length of the input array. \\n\\n- Start with two pointers s = 0 (start) and e = n-1 (end), where n is the length of the array.\\n- For each iteration, calculate the middle point \\'mid\\' and check if there exists a subarray of length \\'mid\\' whose sum is equal or greater than the target (using the \\'isValid\\' function). \\n- If such a subarray exists, update the answer to \\'mid\\' and then move the \\'end\\' pointer to \\'mid - 1\\' to continue searching for a smaller subarray length. \\n- If no such subarray exists, move the \\'start\\' pointer to \\'mid + 1\\' to search for a longer subarray length. \\n\\nThis approach continues until the binary search process finishes. This algorithm is indeed more complicated than the sliding window approach. \\n\\nIt\\'s important to note that the binary search approach wouldn\\'t work if the array contains negative elements since the prefix sum array will no longer be strictly increasing. In those cases, other techniques, such as maintaining a deque as in problem 862 on LeetCode (\"Shortest Subarray with Sum at Least K\"), are needed. \\n\\nApplying binary search in this way demonstrates the flexibility of this algorithmic strategy beyond simple sorted array search tasks.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "`e = mid -1;`\\n`else s = mid +1;`\\nThat\\'s linear search, not binary"
                    },
                    {
                        "username": "divy_kant",
                        "content": "SLIDING WINDOW WEEK \\noptimized the code from O(N^2) to O(N)."
                    },
                    {
                        "username": "sunny8080",
                        "content": "In the first glance, it seems to **Two Pointers** approach"
                    },
                    {
                        "username": "vanni1212",
                        "content": "Could you please post some suggestions about negative numbers as well ?\\n\\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/ \\nThis is the problem variant I am referring to"
                    },
                    {
                        "username": "Luffy_Tse",
                        "content": "The problem I see right now is \\n\\nsum ? s\\n\\n, which is so confusing. I thought ? was ==, but not until several failure attempts then I found that it should be >."
                    },
                    {
                        "username": "dingli",
                        "content": "hi all,\\n\\nDo you have this case? And  I think below case is wrong!!\\n\\nInput:\\n11, [1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3"
                    },
                    {
                        "username": "akash_ry",
                        "content": "Test Case:-\\n**11\\n[1,2,3,4,5]**\\n\\n**Expected Output: 3**\\nwhich in my opinion is not possible in this context\\n**Edit: This is one of this problem\\'s test case.**"
                    },
                    {
                        "username": "_vedant",
                        "content": "It\\'s mentioned that sum is greater then equal to \\n[3,4,5]>=11 which is true"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "stym7905",
                        "content": "target =\\n20\\nnums =\\n[2,16,14,15]\\n\\n\\nhow is it possible"
                    },
                    {
                        "username": "Shamim_Enamul",
                        "content": " `\\n\\nfunc minSubArrayLen(target int, nums []int) int {\\n    // sort the array\\n    sort.Ints(nums) // o(logn)\\n    // treverse through the whole array\\n    sum := 0\\n    for _, val := range nums{\\n       fmt.Println(val)\\n        sum += val\\n    }\\n    l := 0\\n    r := len(nums) - 1\\n    min_len := 0\\n    for l <= r{\\n        if sum >= target{\\n            min_len = (r - l) + 1\\n            sum -= nums[l]\\n            l++\\n        }else{\\n           break\\n        }\\n      \\n    }\\n   \\n    // check the target and update  \\n    return min_len  \\n}\\n`\\n\\ntest case: [12,28,83,4,25,26,25,2,25,25,25,12] and target = 213\\nGot : 7\\nExpected : 8\\nBut this test should return 7 as minimum length of subarray. I am struggling to understand why the expected output is 8"
                    },
                    {
                        "username": "abhishekrule9821",
                        "content": "One can use Window sliding to solve it, but it is. possible just because the problem input don\\'t involve negative numbers. If negative numbers is involved then window approach will be broken & we need to use hashing.\\n\\nIf disagree, please explain."
                    },
                    {
                        "username": "user2575jO",
                        "content": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-on-timememory/"
                    }
                ]
            },
            {
                "id": 2035228,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "Those who were asking about how to binary search on this as this is not sorted or binary search will be even slower\nFirst of all leetcode knows that thinking of Sliding Window is simpler and it want us to think of all possible solutions.\nSecondly, Binary Search is possible on this nums(even it is unsorted and we aren't allowed to solve it ) as we have to find subarray of nums which is >= tar, and SINCE ALL THE NUMBER ARE POSITIVE SO PREFIX SUM OF NUMbs will be always in increasing order\n\nSteps : \nStart s = 0, e = n-1;\nget mid\nif(isValid(mid, tar, nums)) ans = mid +1, e = mid -1;\nelse s = mid +1;\n\nHere Think it like this:\nint mid = s + (e - s)/2;  // we are selecting a window of size m\n if(isValid(mid, target, pref, nums)){ // checking if any subarray is possible of wiindow size mid\n                res = mid + 1;\n                e = mid -1;   // if yes then trydecreasing window size\n    }\n     else s = mid +1;   // if no then try increasing window size\n\nhere isValid is a function which check all subarray sum of size mid.\n\nPS : IT won.t work if array contains negative elements\ngive it a try : https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\nI hope it helps."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) have you checked out today\\'s POTD ? see the editorial,, the first approach they have given is same as I\\'ve described above,, that is nlogn.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@bparanj](/bparanj) You don\\'t seem to understand very well what distinguishes a binary search from a linear one. The size of your search area is not halved as in binary search, but decreased by 1 as in linear search, which it is."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct that the binary search approach can be used in this problem, particularly because the array has all positive integers, which guarantees the prefix sum array will always be in increasing order.\\n\\nTo simplify the explanation:\\n\\nThe binary search here is not used to find an element in an array like in classic use-cases. Instead, it\\'s used to find the minimal length of a subarray whose sum is equal or greater than a given target.\\n\\nThe binary search range is the possible length of the subarray, from 1 to the length of the input array. \\n\\n- Start with two pointers s = 0 (start) and e = n-1 (end), where n is the length of the array.\\n- For each iteration, calculate the middle point \\'mid\\' and check if there exists a subarray of length \\'mid\\' whose sum is equal or greater than the target (using the \\'isValid\\' function). \\n- If such a subarray exists, update the answer to \\'mid\\' and then move the \\'end\\' pointer to \\'mid - 1\\' to continue searching for a smaller subarray length. \\n- If no such subarray exists, move the \\'start\\' pointer to \\'mid + 1\\' to search for a longer subarray length. \\n\\nThis approach continues until the binary search process finishes. This algorithm is indeed more complicated than the sliding window approach. \\n\\nIt\\'s important to note that the binary search approach wouldn\\'t work if the array contains negative elements since the prefix sum array will no longer be strictly increasing. In those cases, other techniques, such as maintaining a deque as in problem 862 on LeetCode (\"Shortest Subarray with Sum at Least K\"), are needed. \\n\\nApplying binary search in this way demonstrates the flexibility of this algorithmic strategy beyond simple sorted array search tasks.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "`e = mid -1;`\\n`else s = mid +1;`\\nThat\\'s linear search, not binary"
                    },
                    {
                        "username": "divy_kant",
                        "content": "SLIDING WINDOW WEEK \\noptimized the code from O(N^2) to O(N)."
                    },
                    {
                        "username": "sunny8080",
                        "content": "In the first glance, it seems to **Two Pointers** approach"
                    },
                    {
                        "username": "vanni1212",
                        "content": "Could you please post some suggestions about negative numbers as well ?\\n\\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/ \\nThis is the problem variant I am referring to"
                    },
                    {
                        "username": "Luffy_Tse",
                        "content": "The problem I see right now is \\n\\nsum ? s\\n\\n, which is so confusing. I thought ? was ==, but not until several failure attempts then I found that it should be >."
                    },
                    {
                        "username": "dingli",
                        "content": "hi all,\\n\\nDo you have this case? And  I think below case is wrong!!\\n\\nInput:\\n11, [1,2,3,4,5]\\nOutput:\\n0\\nExpected:\\n3"
                    },
                    {
                        "username": "akash_ry",
                        "content": "Test Case:-\\n**11\\n[1,2,3,4,5]**\\n\\n**Expected Output: 3**\\nwhich in my opinion is not possible in this context\\n**Edit: This is one of this problem\\'s test case.**"
                    },
                    {
                        "username": "_vedant",
                        "content": "It\\'s mentioned that sum is greater then equal to \\n[3,4,5]>=11 which is true"
                    },
                    {
                        "username": "sparklingness",
                        "content": "In the body of the problem, they mentioned `sum is greater than or equal to target\\'. So, the answer is 3. (sum([3,4,5]) >= 11)"
                    },
                    {
                        "username": "stym7905",
                        "content": "target =\\n20\\nnums =\\n[2,16,14,15]\\n\\n\\nhow is it possible"
                    },
                    {
                        "username": "Shamim_Enamul",
                        "content": " `\\n\\nfunc minSubArrayLen(target int, nums []int) int {\\n    // sort the array\\n    sort.Ints(nums) // o(logn)\\n    // treverse through the whole array\\n    sum := 0\\n    for _, val := range nums{\\n       fmt.Println(val)\\n        sum += val\\n    }\\n    l := 0\\n    r := len(nums) - 1\\n    min_len := 0\\n    for l <= r{\\n        if sum >= target{\\n            min_len = (r - l) + 1\\n            sum -= nums[l]\\n            l++\\n        }else{\\n           break\\n        }\\n      \\n    }\\n   \\n    // check the target and update  \\n    return min_len  \\n}\\n`\\n\\ntest case: [12,28,83,4,25,26,25,2,25,25,25,12] and target = 213\\nGot : 7\\nExpected : 8\\nBut this test should return 7 as minimum length of subarray. I am struggling to understand why the expected output is 8"
                    },
                    {
                        "username": "abhishekrule9821",
                        "content": "One can use Window sliding to solve it, but it is. possible just because the problem input don\\'t involve negative numbers. If negative numbers is involved then window approach will be broken & we need to use hashing.\\n\\nIf disagree, please explain."
                    },
                    {
                        "username": "user2575jO",
                        "content": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3725912/generalization-for-negative-numbers-on-timememory/"
                    }
                ]
            },
            {
                "id": 2027963,
                "content": [
                    {
                        "username": "Ly403",
                        "content": "This is easy actually."
                    },
                    {
                        "username": "mlivingston",
                        "content": "Think this is another one where some of the extremely long test cases and getting TLE errors is unreasonable.... this solution should totally be accepatable\\nhttps://gist.github.com/mlivingston40/0bf6bf7a71516d2a887e0e828511c775"
                    },
                    {
                        "username": "MohanKrishna5",
                        "content": "[1,2,3,4,5] how the output is 3 if target is 11"
                    },
                    {
                        "username": "sameena_yp",
                        "content": "I don't understand why the answer for the following inputs should be 8 instead of 7. Am I missing something? Looks like this question has been asked before and no one has responded from LeetCode yet. Can someone from LeetCode please review your answers for this question, so some of us can submit our responses? Thank you.\n\ntarget =\n213\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n"
                    },
                    {
                        "username": "ahrix268",
                        "content": "can you show me any subarray with length = 7 whose sum >= 213 ?!\\nactually, there\\'s none of it.\\nalso, there\\'re several subarrays with length = 8 whose sum >= 213. therefore, the answer is 8 in this case"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There is a bug in this question for [12,28,83,4,25,26,25,2,25,25,25,12] answer should be 7 as reported in this discussion earlier too. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@SoNiceCoder](/SoNiceCoder) It should be 7 but Leetcode incorrectly failed the test case asking for 8\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is target value for this specific tc ?\\n "
                    },
                    {
                        "username": "xtrezzes",
                        "content": " `int minLen = Int32.MaxValue;\nint currLen = 0, leftPointer = 0, tempTarget = target;\n\n            while (leftPointer < nums.Length)\n            {\n                for (int i = leftPointer; i < nums.Length && tempTarget > 0; i++)\n                {\n                    tempTarget -= nums[i];\n                    currLen++;\n                }\n\n                if (tempTarget <= 0)\n                {\n                    if (currLen < minLen)\n                        minLen = currLen;\n                }\n\n                currLen = 0;\n                leftPointer++;\n                tempTarget = target;\n            }\n\n            return (minLen < Int32.MaxValue) ? minLen : 0;\n`\n\nHi all, please, help with my decision. Doesn't pass because TLE with a test case where there are 100000 elements with a value of 10000 and the target is 1 billion =). I looked at the solutions and saw a brute-force with three loops and O(n^3) complexity, which is also not suitable due to TLE. Also, in the solutions, I found an improved brute-force with O(n^2) complexity, which passes the tests. But my code is much faster (if only because there are not 3, but 2 loops, and because of the conditions in the second loop, it will not be executed n times, which means that the total complexity is even less than even O(n^2) )."
                    },
                    {
                        "username": "satyaso",
                        "content": "I am not able to understand, How can the expected result be 2 for this testcase? . Can anyone explain? target =20, nums=[2,16,14,15], my output is 0 , But it\\'s wrong. Expected is 2.\\n"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "It\\'s greater than or equal to. so 16 + 14 = 30 => 20 ."
                    },
                    {
                        "username": "saurya_k_gupta",
                        "content": "Solve using Sliding Window concept."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "void helper(int i,vector<int>&Nums,vector<vector<int>>&h,vector<int>& k)\\n    {\\n         if(i==Nums.size())\\n         {\\n             h.push_back(k);\\n             return;\\n         }\\n         k.push_back(Nums[i]);\\n         helper(i+1,Nums,h,k);\\n         k.pop_back();\\n         helper(i+1,Nums,h,k);\\n         \\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n      vector<vector<int>>ans;\\n      vector<vector<int>>G;\\n      vector<int>h;\\n      helper(0,nums,G,h);\\n      int size=INT_MAX;\\n      for(int i=0;i<G.size();i++)\\n      {\\n          int sum=0;\\n          for(int j=0;j<G[i].size();j++)\\n          {\\n              sum=sum+G[i][j];\\n          }\\n          if(sum>=target)\\n          { \\n            int size1=G[i].size();\\n            size=min(size,size1);\\n          }\\n      }\\n      if(size==INT_MAX)\\n      {\\n        return 0;\\n      }\\n      return size;\\n      \\n    }\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\noutput:7\\nexpected:8\\nWhy i am getting the wrong answer in this case?\\nPlease anybody tell me .\\n"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "[@bparanj](/bparanj)  Thank you Sir,it  is  a nice approach.Now it\\'s clear."
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve shared is an implementation of a brute force solution to find the smallest length subarray with a sum greater than or equal to a given target. This approach generates all possible subarrays and checks each one to see if its sum is greater than or equal to the target.\\n\\nThe problem is that the code doesn\\'t guarantee that the minimum length subarray found is contiguous (i.e., its elements are in consecutive positions in the original array). In your code, you are considering all subsets of the array, not just the contiguous subarrays.\\n\\nLet\\'s consider the array [12,28,83,4,25,26,25,2,25,25,25,12] and the target value 213. The smallest contiguous subarray that sums up to 213 or more is [83,4,25,26,25,2,25,25], which is 8 elements long. However, your code might return a non-contiguous subarray [83,4,25,26,25,2,25], which is 7 elements long.\\n\\nYou need to change your approach to solve this problem. An efficient solution is to use a two-pointer (or sliding window) technique. This approach maintains a window of elements and adjusts its size and position based on the sum of its elements compared to the target. This guarantees that you are only considering contiguous subarrays. Here\\'s a simple implementation:\\n\\n```cpp\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    int left = 0, sum = 0, minLen = INT_MAX;\\n    for (int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while (sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (minLen != INT_MAX) ? minLen : 0;\\n}\\n```\\nIn this code, we continuously add elements to `sum` until it is greater than or equal to `target`. Once `sum` is large enough, we subtract elements from the left side of the window until `sum` is less than `target` again. We repeat this process, maintaining the smallest window size (`minLen`) seen so far. If no subarray meets the condition, the function returns 0. This approach has a time complexity of O(n), making it much more efficient for large inputs."
                    },
                    {
                        "username": "haoyukwok",
                        "content": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //To check if sum of the entire array is greater than or equal to target\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        if(sum < target) {\\n            return 0;\\n        }\\n        \\n        //If sum is big enough\\n        int k = 1;\\n        int max_sum = 0;\\n        while(max_sum < target) {\\n            for(int i = 0; i < k; i++) {\\n                max_sum += nums[i];\\n            }\\n            if(max_sum >= target)\\n                return k;\\n\\n            int window_sum = max_sum;\\n            for(int i = k; i < nums.length; i++) {\\n                window_sum += nums[i] - nums[i - k];\\n                max_sum = Math.max(window_sum,max_sum);\\n            }\\n            if(max_sum >= target)\\n                return k;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n\\n\\nHello guys, I want to know why my program will output 2 instead of 2 when it deals with [1,2,3,4,5] target = 11."
                    }
                ]
            },
            {
                "id": 2004747,
                "content": [
                    {
                        "username": "Ly403",
                        "content": "This is easy actually."
                    },
                    {
                        "username": "mlivingston",
                        "content": "Think this is another one where some of the extremely long test cases and getting TLE errors is unreasonable.... this solution should totally be accepatable\\nhttps://gist.github.com/mlivingston40/0bf6bf7a71516d2a887e0e828511c775"
                    },
                    {
                        "username": "MohanKrishna5",
                        "content": "[1,2,3,4,5] how the output is 3 if target is 11"
                    },
                    {
                        "username": "sameena_yp",
                        "content": "I don't understand why the answer for the following inputs should be 8 instead of 7. Am I missing something? Looks like this question has been asked before and no one has responded from LeetCode yet. Can someone from LeetCode please review your answers for this question, so some of us can submit our responses? Thank you.\n\ntarget =\n213\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n"
                    },
                    {
                        "username": "ahrix268",
                        "content": "can you show me any subarray with length = 7 whose sum >= 213 ?!\\nactually, there\\'s none of it.\\nalso, there\\'re several subarrays with length = 8 whose sum >= 213. therefore, the answer is 8 in this case"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There is a bug in this question for [12,28,83,4,25,26,25,2,25,25,25,12] answer should be 7 as reported in this discussion earlier too. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@SoNiceCoder](/SoNiceCoder) It should be 7 but Leetcode incorrectly failed the test case asking for 8\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is target value for this specific tc ?\\n "
                    },
                    {
                        "username": "xtrezzes",
                        "content": " `int minLen = Int32.MaxValue;\nint currLen = 0, leftPointer = 0, tempTarget = target;\n\n            while (leftPointer < nums.Length)\n            {\n                for (int i = leftPointer; i < nums.Length && tempTarget > 0; i++)\n                {\n                    tempTarget -= nums[i];\n                    currLen++;\n                }\n\n                if (tempTarget <= 0)\n                {\n                    if (currLen < minLen)\n                        minLen = currLen;\n                }\n\n                currLen = 0;\n                leftPointer++;\n                tempTarget = target;\n            }\n\n            return (minLen < Int32.MaxValue) ? minLen : 0;\n`\n\nHi all, please, help with my decision. Doesn't pass because TLE with a test case where there are 100000 elements with a value of 10000 and the target is 1 billion =). I looked at the solutions and saw a brute-force with three loops and O(n^3) complexity, which is also not suitable due to TLE. Also, in the solutions, I found an improved brute-force with O(n^2) complexity, which passes the tests. But my code is much faster (if only because there are not 3, but 2 loops, and because of the conditions in the second loop, it will not be executed n times, which means that the total complexity is even less than even O(n^2) )."
                    },
                    {
                        "username": "satyaso",
                        "content": "I am not able to understand, How can the expected result be 2 for this testcase? . Can anyone explain? target =20, nums=[2,16,14,15], my output is 0 , But it\\'s wrong. Expected is 2.\\n"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "It\\'s greater than or equal to. so 16 + 14 = 30 => 20 ."
                    },
                    {
                        "username": "saurya_k_gupta",
                        "content": "Solve using Sliding Window concept."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "void helper(int i,vector<int>&Nums,vector<vector<int>>&h,vector<int>& k)\\n    {\\n         if(i==Nums.size())\\n         {\\n             h.push_back(k);\\n             return;\\n         }\\n         k.push_back(Nums[i]);\\n         helper(i+1,Nums,h,k);\\n         k.pop_back();\\n         helper(i+1,Nums,h,k);\\n         \\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n      vector<vector<int>>ans;\\n      vector<vector<int>>G;\\n      vector<int>h;\\n      helper(0,nums,G,h);\\n      int size=INT_MAX;\\n      for(int i=0;i<G.size();i++)\\n      {\\n          int sum=0;\\n          for(int j=0;j<G[i].size();j++)\\n          {\\n              sum=sum+G[i][j];\\n          }\\n          if(sum>=target)\\n          { \\n            int size1=G[i].size();\\n            size=min(size,size1);\\n          }\\n      }\\n      if(size==INT_MAX)\\n      {\\n        return 0;\\n      }\\n      return size;\\n      \\n    }\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\noutput:7\\nexpected:8\\nWhy i am getting the wrong answer in this case?\\nPlease anybody tell me .\\n"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "[@bparanj](/bparanj)  Thank you Sir,it  is  a nice approach.Now it\\'s clear."
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve shared is an implementation of a brute force solution to find the smallest length subarray with a sum greater than or equal to a given target. This approach generates all possible subarrays and checks each one to see if its sum is greater than or equal to the target.\\n\\nThe problem is that the code doesn\\'t guarantee that the minimum length subarray found is contiguous (i.e., its elements are in consecutive positions in the original array). In your code, you are considering all subsets of the array, not just the contiguous subarrays.\\n\\nLet\\'s consider the array [12,28,83,4,25,26,25,2,25,25,25,12] and the target value 213. The smallest contiguous subarray that sums up to 213 or more is [83,4,25,26,25,2,25,25], which is 8 elements long. However, your code might return a non-contiguous subarray [83,4,25,26,25,2,25], which is 7 elements long.\\n\\nYou need to change your approach to solve this problem. An efficient solution is to use a two-pointer (or sliding window) technique. This approach maintains a window of elements and adjusts its size and position based on the sum of its elements compared to the target. This guarantees that you are only considering contiguous subarrays. Here\\'s a simple implementation:\\n\\n```cpp\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    int left = 0, sum = 0, minLen = INT_MAX;\\n    for (int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while (sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (minLen != INT_MAX) ? minLen : 0;\\n}\\n```\\nIn this code, we continuously add elements to `sum` until it is greater than or equal to `target`. Once `sum` is large enough, we subtract elements from the left side of the window until `sum` is less than `target` again. We repeat this process, maintaining the smallest window size (`minLen`) seen so far. If no subarray meets the condition, the function returns 0. This approach has a time complexity of O(n), making it much more efficient for large inputs."
                    },
                    {
                        "username": "haoyukwok",
                        "content": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //To check if sum of the entire array is greater than or equal to target\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        if(sum < target) {\\n            return 0;\\n        }\\n        \\n        //If sum is big enough\\n        int k = 1;\\n        int max_sum = 0;\\n        while(max_sum < target) {\\n            for(int i = 0; i < k; i++) {\\n                max_sum += nums[i];\\n            }\\n            if(max_sum >= target)\\n                return k;\\n\\n            int window_sum = max_sum;\\n            for(int i = k; i < nums.length; i++) {\\n                window_sum += nums[i] - nums[i - k];\\n                max_sum = Math.max(window_sum,max_sum);\\n            }\\n            if(max_sum >= target)\\n                return k;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n\\n\\nHello guys, I want to know why my program will output 2 instead of 2 when it deals with [1,2,3,4,5] target = 11."
                    }
                ]
            },
            {
                "id": 2000561,
                "content": [
                    {
                        "username": "Ly403",
                        "content": "This is easy actually."
                    },
                    {
                        "username": "mlivingston",
                        "content": "Think this is another one where some of the extremely long test cases and getting TLE errors is unreasonable.... this solution should totally be accepatable\\nhttps://gist.github.com/mlivingston40/0bf6bf7a71516d2a887e0e828511c775"
                    },
                    {
                        "username": "MohanKrishna5",
                        "content": "[1,2,3,4,5] how the output is 3 if target is 11"
                    },
                    {
                        "username": "sameena_yp",
                        "content": "I don't understand why the answer for the following inputs should be 8 instead of 7. Am I missing something? Looks like this question has been asked before and no one has responded from LeetCode yet. Can someone from LeetCode please review your answers for this question, so some of us can submit our responses? Thank you.\n\ntarget =\n213\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n"
                    },
                    {
                        "username": "ahrix268",
                        "content": "can you show me any subarray with length = 7 whose sum >= 213 ?!\\nactually, there\\'s none of it.\\nalso, there\\'re several subarrays with length = 8 whose sum >= 213. therefore, the answer is 8 in this case"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There is a bug in this question for [12,28,83,4,25,26,25,2,25,25,25,12] answer should be 7 as reported in this discussion earlier too. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@SoNiceCoder](/SoNiceCoder) It should be 7 but Leetcode incorrectly failed the test case asking for 8\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is target value for this specific tc ?\\n "
                    },
                    {
                        "username": "xtrezzes",
                        "content": " `int minLen = Int32.MaxValue;\nint currLen = 0, leftPointer = 0, tempTarget = target;\n\n            while (leftPointer < nums.Length)\n            {\n                for (int i = leftPointer; i < nums.Length && tempTarget > 0; i++)\n                {\n                    tempTarget -= nums[i];\n                    currLen++;\n                }\n\n                if (tempTarget <= 0)\n                {\n                    if (currLen < minLen)\n                        minLen = currLen;\n                }\n\n                currLen = 0;\n                leftPointer++;\n                tempTarget = target;\n            }\n\n            return (minLen < Int32.MaxValue) ? minLen : 0;\n`\n\nHi all, please, help with my decision. Doesn't pass because TLE with a test case where there are 100000 elements with a value of 10000 and the target is 1 billion =). I looked at the solutions and saw a brute-force with three loops and O(n^3) complexity, which is also not suitable due to TLE. Also, in the solutions, I found an improved brute-force with O(n^2) complexity, which passes the tests. But my code is much faster (if only because there are not 3, but 2 loops, and because of the conditions in the second loop, it will not be executed n times, which means that the total complexity is even less than even O(n^2) )."
                    },
                    {
                        "username": "satyaso",
                        "content": "I am not able to understand, How can the expected result be 2 for this testcase? . Can anyone explain? target =20, nums=[2,16,14,15], my output is 0 , But it\\'s wrong. Expected is 2.\\n"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "It\\'s greater than or equal to. so 16 + 14 = 30 => 20 ."
                    },
                    {
                        "username": "saurya_k_gupta",
                        "content": "Solve using Sliding Window concept."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "void helper(int i,vector<int>&Nums,vector<vector<int>>&h,vector<int>& k)\\n    {\\n         if(i==Nums.size())\\n         {\\n             h.push_back(k);\\n             return;\\n         }\\n         k.push_back(Nums[i]);\\n         helper(i+1,Nums,h,k);\\n         k.pop_back();\\n         helper(i+1,Nums,h,k);\\n         \\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n      vector<vector<int>>ans;\\n      vector<vector<int>>G;\\n      vector<int>h;\\n      helper(0,nums,G,h);\\n      int size=INT_MAX;\\n      for(int i=0;i<G.size();i++)\\n      {\\n          int sum=0;\\n          for(int j=0;j<G[i].size();j++)\\n          {\\n              sum=sum+G[i][j];\\n          }\\n          if(sum>=target)\\n          { \\n            int size1=G[i].size();\\n            size=min(size,size1);\\n          }\\n      }\\n      if(size==INT_MAX)\\n      {\\n        return 0;\\n      }\\n      return size;\\n      \\n    }\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\noutput:7\\nexpected:8\\nWhy i am getting the wrong answer in this case?\\nPlease anybody tell me .\\n"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "[@bparanj](/bparanj)  Thank you Sir,it  is  a nice approach.Now it\\'s clear."
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve shared is an implementation of a brute force solution to find the smallest length subarray with a sum greater than or equal to a given target. This approach generates all possible subarrays and checks each one to see if its sum is greater than or equal to the target.\\n\\nThe problem is that the code doesn\\'t guarantee that the minimum length subarray found is contiguous (i.e., its elements are in consecutive positions in the original array). In your code, you are considering all subsets of the array, not just the contiguous subarrays.\\n\\nLet\\'s consider the array [12,28,83,4,25,26,25,2,25,25,25,12] and the target value 213. The smallest contiguous subarray that sums up to 213 or more is [83,4,25,26,25,2,25,25], which is 8 elements long. However, your code might return a non-contiguous subarray [83,4,25,26,25,2,25], which is 7 elements long.\\n\\nYou need to change your approach to solve this problem. An efficient solution is to use a two-pointer (or sliding window) technique. This approach maintains a window of elements and adjusts its size and position based on the sum of its elements compared to the target. This guarantees that you are only considering contiguous subarrays. Here\\'s a simple implementation:\\n\\n```cpp\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    int left = 0, sum = 0, minLen = INT_MAX;\\n    for (int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while (sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (minLen != INT_MAX) ? minLen : 0;\\n}\\n```\\nIn this code, we continuously add elements to `sum` until it is greater than or equal to `target`. Once `sum` is large enough, we subtract elements from the left side of the window until `sum` is less than `target` again. We repeat this process, maintaining the smallest window size (`minLen`) seen so far. If no subarray meets the condition, the function returns 0. This approach has a time complexity of O(n), making it much more efficient for large inputs."
                    },
                    {
                        "username": "haoyukwok",
                        "content": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //To check if sum of the entire array is greater than or equal to target\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        if(sum < target) {\\n            return 0;\\n        }\\n        \\n        //If sum is big enough\\n        int k = 1;\\n        int max_sum = 0;\\n        while(max_sum < target) {\\n            for(int i = 0; i < k; i++) {\\n                max_sum += nums[i];\\n            }\\n            if(max_sum >= target)\\n                return k;\\n\\n            int window_sum = max_sum;\\n            for(int i = k; i < nums.length; i++) {\\n                window_sum += nums[i] - nums[i - k];\\n                max_sum = Math.max(window_sum,max_sum);\\n            }\\n            if(max_sum >= target)\\n                return k;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n\\n\\nHello guys, I want to know why my program will output 2 instead of 2 when it deals with [1,2,3,4,5] target = 11."
                    }
                ]
            },
            {
                "id": 2000093,
                "content": [
                    {
                        "username": "Ly403",
                        "content": "This is easy actually."
                    },
                    {
                        "username": "mlivingston",
                        "content": "Think this is another one where some of the extremely long test cases and getting TLE errors is unreasonable.... this solution should totally be accepatable\\nhttps://gist.github.com/mlivingston40/0bf6bf7a71516d2a887e0e828511c775"
                    },
                    {
                        "username": "MohanKrishna5",
                        "content": "[1,2,3,4,5] how the output is 3 if target is 11"
                    },
                    {
                        "username": "sameena_yp",
                        "content": "I don't understand why the answer for the following inputs should be 8 instead of 7. Am I missing something? Looks like this question has been asked before and no one has responded from LeetCode yet. Can someone from LeetCode please review your answers for this question, so some of us can submit our responses? Thank you.\n\ntarget =\n213\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n"
                    },
                    {
                        "username": "ahrix268",
                        "content": "can you show me any subarray with length = 7 whose sum >= 213 ?!\\nactually, there\\'s none of it.\\nalso, there\\'re several subarrays with length = 8 whose sum >= 213. therefore, the answer is 8 in this case"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There is a bug in this question for [12,28,83,4,25,26,25,2,25,25,25,12] answer should be 7 as reported in this discussion earlier too. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@SoNiceCoder](/SoNiceCoder) It should be 7 but Leetcode incorrectly failed the test case asking for 8\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is target value for this specific tc ?\\n "
                    },
                    {
                        "username": "xtrezzes",
                        "content": " `int minLen = Int32.MaxValue;\nint currLen = 0, leftPointer = 0, tempTarget = target;\n\n            while (leftPointer < nums.Length)\n            {\n                for (int i = leftPointer; i < nums.Length && tempTarget > 0; i++)\n                {\n                    tempTarget -= nums[i];\n                    currLen++;\n                }\n\n                if (tempTarget <= 0)\n                {\n                    if (currLen < minLen)\n                        minLen = currLen;\n                }\n\n                currLen = 0;\n                leftPointer++;\n                tempTarget = target;\n            }\n\n            return (minLen < Int32.MaxValue) ? minLen : 0;\n`\n\nHi all, please, help with my decision. Doesn't pass because TLE with a test case where there are 100000 elements with a value of 10000 and the target is 1 billion =). I looked at the solutions and saw a brute-force with three loops and O(n^3) complexity, which is also not suitable due to TLE. Also, in the solutions, I found an improved brute-force with O(n^2) complexity, which passes the tests. But my code is much faster (if only because there are not 3, but 2 loops, and because of the conditions in the second loop, it will not be executed n times, which means that the total complexity is even less than even O(n^2) )."
                    },
                    {
                        "username": "satyaso",
                        "content": "I am not able to understand, How can the expected result be 2 for this testcase? . Can anyone explain? target =20, nums=[2,16,14,15], my output is 0 , But it\\'s wrong. Expected is 2.\\n"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "It\\'s greater than or equal to. so 16 + 14 = 30 => 20 ."
                    },
                    {
                        "username": "saurya_k_gupta",
                        "content": "Solve using Sliding Window concept."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "void helper(int i,vector<int>&Nums,vector<vector<int>>&h,vector<int>& k)\\n    {\\n         if(i==Nums.size())\\n         {\\n             h.push_back(k);\\n             return;\\n         }\\n         k.push_back(Nums[i]);\\n         helper(i+1,Nums,h,k);\\n         k.pop_back();\\n         helper(i+1,Nums,h,k);\\n         \\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n      vector<vector<int>>ans;\\n      vector<vector<int>>G;\\n      vector<int>h;\\n      helper(0,nums,G,h);\\n      int size=INT_MAX;\\n      for(int i=0;i<G.size();i++)\\n      {\\n          int sum=0;\\n          for(int j=0;j<G[i].size();j++)\\n          {\\n              sum=sum+G[i][j];\\n          }\\n          if(sum>=target)\\n          { \\n            int size1=G[i].size();\\n            size=min(size,size1);\\n          }\\n      }\\n      if(size==INT_MAX)\\n      {\\n        return 0;\\n      }\\n      return size;\\n      \\n    }\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\noutput:7\\nexpected:8\\nWhy i am getting the wrong answer in this case?\\nPlease anybody tell me .\\n"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "[@bparanj](/bparanj)  Thank you Sir,it  is  a nice approach.Now it\\'s clear."
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve shared is an implementation of a brute force solution to find the smallest length subarray with a sum greater than or equal to a given target. This approach generates all possible subarrays and checks each one to see if its sum is greater than or equal to the target.\\n\\nThe problem is that the code doesn\\'t guarantee that the minimum length subarray found is contiguous (i.e., its elements are in consecutive positions in the original array). In your code, you are considering all subsets of the array, not just the contiguous subarrays.\\n\\nLet\\'s consider the array [12,28,83,4,25,26,25,2,25,25,25,12] and the target value 213. The smallest contiguous subarray that sums up to 213 or more is [83,4,25,26,25,2,25,25], which is 8 elements long. However, your code might return a non-contiguous subarray [83,4,25,26,25,2,25], which is 7 elements long.\\n\\nYou need to change your approach to solve this problem. An efficient solution is to use a two-pointer (or sliding window) technique. This approach maintains a window of elements and adjusts its size and position based on the sum of its elements compared to the target. This guarantees that you are only considering contiguous subarrays. Here\\'s a simple implementation:\\n\\n```cpp\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    int left = 0, sum = 0, minLen = INT_MAX;\\n    for (int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while (sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (minLen != INT_MAX) ? minLen : 0;\\n}\\n```\\nIn this code, we continuously add elements to `sum` until it is greater than or equal to `target`. Once `sum` is large enough, we subtract elements from the left side of the window until `sum` is less than `target` again. We repeat this process, maintaining the smallest window size (`minLen`) seen so far. If no subarray meets the condition, the function returns 0. This approach has a time complexity of O(n), making it much more efficient for large inputs."
                    },
                    {
                        "username": "haoyukwok",
                        "content": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //To check if sum of the entire array is greater than or equal to target\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        if(sum < target) {\\n            return 0;\\n        }\\n        \\n        //If sum is big enough\\n        int k = 1;\\n        int max_sum = 0;\\n        while(max_sum < target) {\\n            for(int i = 0; i < k; i++) {\\n                max_sum += nums[i];\\n            }\\n            if(max_sum >= target)\\n                return k;\\n\\n            int window_sum = max_sum;\\n            for(int i = k; i < nums.length; i++) {\\n                window_sum += nums[i] - nums[i - k];\\n                max_sum = Math.max(window_sum,max_sum);\\n            }\\n            if(max_sum >= target)\\n                return k;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n\\n\\nHello guys, I want to know why my program will output 2 instead of 2 when it deals with [1,2,3,4,5] target = 11."
                    }
                ]
            },
            {
                "id": 1998342,
                "content": [
                    {
                        "username": "Ly403",
                        "content": "This is easy actually."
                    },
                    {
                        "username": "mlivingston",
                        "content": "Think this is another one where some of the extremely long test cases and getting TLE errors is unreasonable.... this solution should totally be accepatable\\nhttps://gist.github.com/mlivingston40/0bf6bf7a71516d2a887e0e828511c775"
                    },
                    {
                        "username": "MohanKrishna5",
                        "content": "[1,2,3,4,5] how the output is 3 if target is 11"
                    },
                    {
                        "username": "sameena_yp",
                        "content": "I don't understand why the answer for the following inputs should be 8 instead of 7. Am I missing something? Looks like this question has been asked before and no one has responded from LeetCode yet. Can someone from LeetCode please review your answers for this question, so some of us can submit our responses? Thank you.\n\ntarget =\n213\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n"
                    },
                    {
                        "username": "ahrix268",
                        "content": "can you show me any subarray with length = 7 whose sum >= 213 ?!\\nactually, there\\'s none of it.\\nalso, there\\'re several subarrays with length = 8 whose sum >= 213. therefore, the answer is 8 in this case"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There is a bug in this question for [12,28,83,4,25,26,25,2,25,25,25,12] answer should be 7 as reported in this discussion earlier too. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@SoNiceCoder](/SoNiceCoder) It should be 7 but Leetcode incorrectly failed the test case asking for 8\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is target value for this specific tc ?\\n "
                    },
                    {
                        "username": "xtrezzes",
                        "content": " `int minLen = Int32.MaxValue;\nint currLen = 0, leftPointer = 0, tempTarget = target;\n\n            while (leftPointer < nums.Length)\n            {\n                for (int i = leftPointer; i < nums.Length && tempTarget > 0; i++)\n                {\n                    tempTarget -= nums[i];\n                    currLen++;\n                }\n\n                if (tempTarget <= 0)\n                {\n                    if (currLen < minLen)\n                        minLen = currLen;\n                }\n\n                currLen = 0;\n                leftPointer++;\n                tempTarget = target;\n            }\n\n            return (minLen < Int32.MaxValue) ? minLen : 0;\n`\n\nHi all, please, help with my decision. Doesn't pass because TLE with a test case where there are 100000 elements with a value of 10000 and the target is 1 billion =). I looked at the solutions and saw a brute-force with three loops and O(n^3) complexity, which is also not suitable due to TLE. Also, in the solutions, I found an improved brute-force with O(n^2) complexity, which passes the tests. But my code is much faster (if only because there are not 3, but 2 loops, and because of the conditions in the second loop, it will not be executed n times, which means that the total complexity is even less than even O(n^2) )."
                    },
                    {
                        "username": "satyaso",
                        "content": "I am not able to understand, How can the expected result be 2 for this testcase? . Can anyone explain? target =20, nums=[2,16,14,15], my output is 0 , But it\\'s wrong. Expected is 2.\\n"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "It\\'s greater than or equal to. so 16 + 14 = 30 => 20 ."
                    },
                    {
                        "username": "saurya_k_gupta",
                        "content": "Solve using Sliding Window concept."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "void helper(int i,vector<int>&Nums,vector<vector<int>>&h,vector<int>& k)\\n    {\\n         if(i==Nums.size())\\n         {\\n             h.push_back(k);\\n             return;\\n         }\\n         k.push_back(Nums[i]);\\n         helper(i+1,Nums,h,k);\\n         k.pop_back();\\n         helper(i+1,Nums,h,k);\\n         \\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n      vector<vector<int>>ans;\\n      vector<vector<int>>G;\\n      vector<int>h;\\n      helper(0,nums,G,h);\\n      int size=INT_MAX;\\n      for(int i=0;i<G.size();i++)\\n      {\\n          int sum=0;\\n          for(int j=0;j<G[i].size();j++)\\n          {\\n              sum=sum+G[i][j];\\n          }\\n          if(sum>=target)\\n          { \\n            int size1=G[i].size();\\n            size=min(size,size1);\\n          }\\n      }\\n      if(size==INT_MAX)\\n      {\\n        return 0;\\n      }\\n      return size;\\n      \\n    }\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\noutput:7\\nexpected:8\\nWhy i am getting the wrong answer in this case?\\nPlease anybody tell me .\\n"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "[@bparanj](/bparanj)  Thank you Sir,it  is  a nice approach.Now it\\'s clear."
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve shared is an implementation of a brute force solution to find the smallest length subarray with a sum greater than or equal to a given target. This approach generates all possible subarrays and checks each one to see if its sum is greater than or equal to the target.\\n\\nThe problem is that the code doesn\\'t guarantee that the minimum length subarray found is contiguous (i.e., its elements are in consecutive positions in the original array). In your code, you are considering all subsets of the array, not just the contiguous subarrays.\\n\\nLet\\'s consider the array [12,28,83,4,25,26,25,2,25,25,25,12] and the target value 213. The smallest contiguous subarray that sums up to 213 or more is [83,4,25,26,25,2,25,25], which is 8 elements long. However, your code might return a non-contiguous subarray [83,4,25,26,25,2,25], which is 7 elements long.\\n\\nYou need to change your approach to solve this problem. An efficient solution is to use a two-pointer (or sliding window) technique. This approach maintains a window of elements and adjusts its size and position based on the sum of its elements compared to the target. This guarantees that you are only considering contiguous subarrays. Here\\'s a simple implementation:\\n\\n```cpp\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    int left = 0, sum = 0, minLen = INT_MAX;\\n    for (int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while (sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (minLen != INT_MAX) ? minLen : 0;\\n}\\n```\\nIn this code, we continuously add elements to `sum` until it is greater than or equal to `target`. Once `sum` is large enough, we subtract elements from the left side of the window until `sum` is less than `target` again. We repeat this process, maintaining the smallest window size (`minLen`) seen so far. If no subarray meets the condition, the function returns 0. This approach has a time complexity of O(n), making it much more efficient for large inputs."
                    },
                    {
                        "username": "haoyukwok",
                        "content": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //To check if sum of the entire array is greater than or equal to target\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        if(sum < target) {\\n            return 0;\\n        }\\n        \\n        //If sum is big enough\\n        int k = 1;\\n        int max_sum = 0;\\n        while(max_sum < target) {\\n            for(int i = 0; i < k; i++) {\\n                max_sum += nums[i];\\n            }\\n            if(max_sum >= target)\\n                return k;\\n\\n            int window_sum = max_sum;\\n            for(int i = k; i < nums.length; i++) {\\n                window_sum += nums[i] - nums[i - k];\\n                max_sum = Math.max(window_sum,max_sum);\\n            }\\n            if(max_sum >= target)\\n                return k;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n\\n\\nHello guys, I want to know why my program will output 2 instead of 2 when it deals with [1,2,3,4,5] target = 11."
                    }
                ]
            },
            {
                "id": 1997106,
                "content": [
                    {
                        "username": "Ly403",
                        "content": "This is easy actually."
                    },
                    {
                        "username": "mlivingston",
                        "content": "Think this is another one where some of the extremely long test cases and getting TLE errors is unreasonable.... this solution should totally be accepatable\\nhttps://gist.github.com/mlivingston40/0bf6bf7a71516d2a887e0e828511c775"
                    },
                    {
                        "username": "MohanKrishna5",
                        "content": "[1,2,3,4,5] how the output is 3 if target is 11"
                    },
                    {
                        "username": "sameena_yp",
                        "content": "I don't understand why the answer for the following inputs should be 8 instead of 7. Am I missing something? Looks like this question has been asked before and no one has responded from LeetCode yet. Can someone from LeetCode please review your answers for this question, so some of us can submit our responses? Thank you.\n\ntarget =\n213\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n"
                    },
                    {
                        "username": "ahrix268",
                        "content": "can you show me any subarray with length = 7 whose sum >= 213 ?!\\nactually, there\\'s none of it.\\nalso, there\\'re several subarrays with length = 8 whose sum >= 213. therefore, the answer is 8 in this case"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There is a bug in this question for [12,28,83,4,25,26,25,2,25,25,25,12] answer should be 7 as reported in this discussion earlier too. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@SoNiceCoder](/SoNiceCoder) It should be 7 but Leetcode incorrectly failed the test case asking for 8\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is target value for this specific tc ?\\n "
                    },
                    {
                        "username": "xtrezzes",
                        "content": " `int minLen = Int32.MaxValue;\nint currLen = 0, leftPointer = 0, tempTarget = target;\n\n            while (leftPointer < nums.Length)\n            {\n                for (int i = leftPointer; i < nums.Length && tempTarget > 0; i++)\n                {\n                    tempTarget -= nums[i];\n                    currLen++;\n                }\n\n                if (tempTarget <= 0)\n                {\n                    if (currLen < minLen)\n                        minLen = currLen;\n                }\n\n                currLen = 0;\n                leftPointer++;\n                tempTarget = target;\n            }\n\n            return (minLen < Int32.MaxValue) ? minLen : 0;\n`\n\nHi all, please, help with my decision. Doesn't pass because TLE with a test case where there are 100000 elements with a value of 10000 and the target is 1 billion =). I looked at the solutions and saw a brute-force with three loops and O(n^3) complexity, which is also not suitable due to TLE. Also, in the solutions, I found an improved brute-force with O(n^2) complexity, which passes the tests. But my code is much faster (if only because there are not 3, but 2 loops, and because of the conditions in the second loop, it will not be executed n times, which means that the total complexity is even less than even O(n^2) )."
                    },
                    {
                        "username": "satyaso",
                        "content": "I am not able to understand, How can the expected result be 2 for this testcase? . Can anyone explain? target =20, nums=[2,16,14,15], my output is 0 , But it\\'s wrong. Expected is 2.\\n"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "It\\'s greater than or equal to. so 16 + 14 = 30 => 20 ."
                    },
                    {
                        "username": "saurya_k_gupta",
                        "content": "Solve using Sliding Window concept."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "void helper(int i,vector<int>&Nums,vector<vector<int>>&h,vector<int>& k)\\n    {\\n         if(i==Nums.size())\\n         {\\n             h.push_back(k);\\n             return;\\n         }\\n         k.push_back(Nums[i]);\\n         helper(i+1,Nums,h,k);\\n         k.pop_back();\\n         helper(i+1,Nums,h,k);\\n         \\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n      vector<vector<int>>ans;\\n      vector<vector<int>>G;\\n      vector<int>h;\\n      helper(0,nums,G,h);\\n      int size=INT_MAX;\\n      for(int i=0;i<G.size();i++)\\n      {\\n          int sum=0;\\n          for(int j=0;j<G[i].size();j++)\\n          {\\n              sum=sum+G[i][j];\\n          }\\n          if(sum>=target)\\n          { \\n            int size1=G[i].size();\\n            size=min(size,size1);\\n          }\\n      }\\n      if(size==INT_MAX)\\n      {\\n        return 0;\\n      }\\n      return size;\\n      \\n    }\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\noutput:7\\nexpected:8\\nWhy i am getting the wrong answer in this case?\\nPlease anybody tell me .\\n"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "[@bparanj](/bparanj)  Thank you Sir,it  is  a nice approach.Now it\\'s clear."
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve shared is an implementation of a brute force solution to find the smallest length subarray with a sum greater than or equal to a given target. This approach generates all possible subarrays and checks each one to see if its sum is greater than or equal to the target.\\n\\nThe problem is that the code doesn\\'t guarantee that the minimum length subarray found is contiguous (i.e., its elements are in consecutive positions in the original array). In your code, you are considering all subsets of the array, not just the contiguous subarrays.\\n\\nLet\\'s consider the array [12,28,83,4,25,26,25,2,25,25,25,12] and the target value 213. The smallest contiguous subarray that sums up to 213 or more is [83,4,25,26,25,2,25,25], which is 8 elements long. However, your code might return a non-contiguous subarray [83,4,25,26,25,2,25], which is 7 elements long.\\n\\nYou need to change your approach to solve this problem. An efficient solution is to use a two-pointer (or sliding window) technique. This approach maintains a window of elements and adjusts its size and position based on the sum of its elements compared to the target. This guarantees that you are only considering contiguous subarrays. Here\\'s a simple implementation:\\n\\n```cpp\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    int left = 0, sum = 0, minLen = INT_MAX;\\n    for (int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while (sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (minLen != INT_MAX) ? minLen : 0;\\n}\\n```\\nIn this code, we continuously add elements to `sum` until it is greater than or equal to `target`. Once `sum` is large enough, we subtract elements from the left side of the window until `sum` is less than `target` again. We repeat this process, maintaining the smallest window size (`minLen`) seen so far. If no subarray meets the condition, the function returns 0. This approach has a time complexity of O(n), making it much more efficient for large inputs."
                    },
                    {
                        "username": "haoyukwok",
                        "content": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //To check if sum of the entire array is greater than or equal to target\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        if(sum < target) {\\n            return 0;\\n        }\\n        \\n        //If sum is big enough\\n        int k = 1;\\n        int max_sum = 0;\\n        while(max_sum < target) {\\n            for(int i = 0; i < k; i++) {\\n                max_sum += nums[i];\\n            }\\n            if(max_sum >= target)\\n                return k;\\n\\n            int window_sum = max_sum;\\n            for(int i = k; i < nums.length; i++) {\\n                window_sum += nums[i] - nums[i - k];\\n                max_sum = Math.max(window_sum,max_sum);\\n            }\\n            if(max_sum >= target)\\n                return k;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n\\n\\nHello guys, I want to know why my program will output 2 instead of 2 when it deals with [1,2,3,4,5] target = 11."
                    }
                ]
            },
            {
                "id": 1992945,
                "content": [
                    {
                        "username": "Ly403",
                        "content": "This is easy actually."
                    },
                    {
                        "username": "mlivingston",
                        "content": "Think this is another one where some of the extremely long test cases and getting TLE errors is unreasonable.... this solution should totally be accepatable\\nhttps://gist.github.com/mlivingston40/0bf6bf7a71516d2a887e0e828511c775"
                    },
                    {
                        "username": "MohanKrishna5",
                        "content": "[1,2,3,4,5] how the output is 3 if target is 11"
                    },
                    {
                        "username": "sameena_yp",
                        "content": "I don't understand why the answer for the following inputs should be 8 instead of 7. Am I missing something? Looks like this question has been asked before and no one has responded from LeetCode yet. Can someone from LeetCode please review your answers for this question, so some of us can submit our responses? Thank you.\n\ntarget =\n213\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n"
                    },
                    {
                        "username": "ahrix268",
                        "content": "can you show me any subarray with length = 7 whose sum >= 213 ?!\\nactually, there\\'s none of it.\\nalso, there\\'re several subarrays with length = 8 whose sum >= 213. therefore, the answer is 8 in this case"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There is a bug in this question for [12,28,83,4,25,26,25,2,25,25,25,12] answer should be 7 as reported in this discussion earlier too. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@SoNiceCoder](/SoNiceCoder) It should be 7 but Leetcode incorrectly failed the test case asking for 8\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is target value for this specific tc ?\\n "
                    },
                    {
                        "username": "xtrezzes",
                        "content": " `int minLen = Int32.MaxValue;\nint currLen = 0, leftPointer = 0, tempTarget = target;\n\n            while (leftPointer < nums.Length)\n            {\n                for (int i = leftPointer; i < nums.Length && tempTarget > 0; i++)\n                {\n                    tempTarget -= nums[i];\n                    currLen++;\n                }\n\n                if (tempTarget <= 0)\n                {\n                    if (currLen < minLen)\n                        minLen = currLen;\n                }\n\n                currLen = 0;\n                leftPointer++;\n                tempTarget = target;\n            }\n\n            return (minLen < Int32.MaxValue) ? minLen : 0;\n`\n\nHi all, please, help with my decision. Doesn't pass because TLE with a test case where there are 100000 elements with a value of 10000 and the target is 1 billion =). I looked at the solutions and saw a brute-force with three loops and O(n^3) complexity, which is also not suitable due to TLE. Also, in the solutions, I found an improved brute-force with O(n^2) complexity, which passes the tests. But my code is much faster (if only because there are not 3, but 2 loops, and because of the conditions in the second loop, it will not be executed n times, which means that the total complexity is even less than even O(n^2) )."
                    },
                    {
                        "username": "satyaso",
                        "content": "I am not able to understand, How can the expected result be 2 for this testcase? . Can anyone explain? target =20, nums=[2,16,14,15], my output is 0 , But it\\'s wrong. Expected is 2.\\n"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "It\\'s greater than or equal to. so 16 + 14 = 30 => 20 ."
                    },
                    {
                        "username": "saurya_k_gupta",
                        "content": "Solve using Sliding Window concept."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "void helper(int i,vector<int>&Nums,vector<vector<int>>&h,vector<int>& k)\\n    {\\n         if(i==Nums.size())\\n         {\\n             h.push_back(k);\\n             return;\\n         }\\n         k.push_back(Nums[i]);\\n         helper(i+1,Nums,h,k);\\n         k.pop_back();\\n         helper(i+1,Nums,h,k);\\n         \\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n      vector<vector<int>>ans;\\n      vector<vector<int>>G;\\n      vector<int>h;\\n      helper(0,nums,G,h);\\n      int size=INT_MAX;\\n      for(int i=0;i<G.size();i++)\\n      {\\n          int sum=0;\\n          for(int j=0;j<G[i].size();j++)\\n          {\\n              sum=sum+G[i][j];\\n          }\\n          if(sum>=target)\\n          { \\n            int size1=G[i].size();\\n            size=min(size,size1);\\n          }\\n      }\\n      if(size==INT_MAX)\\n      {\\n        return 0;\\n      }\\n      return size;\\n      \\n    }\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\noutput:7\\nexpected:8\\nWhy i am getting the wrong answer in this case?\\nPlease anybody tell me .\\n"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "[@bparanj](/bparanj)  Thank you Sir,it  is  a nice approach.Now it\\'s clear."
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve shared is an implementation of a brute force solution to find the smallest length subarray with a sum greater than or equal to a given target. This approach generates all possible subarrays and checks each one to see if its sum is greater than or equal to the target.\\n\\nThe problem is that the code doesn\\'t guarantee that the minimum length subarray found is contiguous (i.e., its elements are in consecutive positions in the original array). In your code, you are considering all subsets of the array, not just the contiguous subarrays.\\n\\nLet\\'s consider the array [12,28,83,4,25,26,25,2,25,25,25,12] and the target value 213. The smallest contiguous subarray that sums up to 213 or more is [83,4,25,26,25,2,25,25], which is 8 elements long. However, your code might return a non-contiguous subarray [83,4,25,26,25,2,25], which is 7 elements long.\\n\\nYou need to change your approach to solve this problem. An efficient solution is to use a two-pointer (or sliding window) technique. This approach maintains a window of elements and adjusts its size and position based on the sum of its elements compared to the target. This guarantees that you are only considering contiguous subarrays. Here\\'s a simple implementation:\\n\\n```cpp\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    int left = 0, sum = 0, minLen = INT_MAX;\\n    for (int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while (sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (minLen != INT_MAX) ? minLen : 0;\\n}\\n```\\nIn this code, we continuously add elements to `sum` until it is greater than or equal to `target`. Once `sum` is large enough, we subtract elements from the left side of the window until `sum` is less than `target` again. We repeat this process, maintaining the smallest window size (`minLen`) seen so far. If no subarray meets the condition, the function returns 0. This approach has a time complexity of O(n), making it much more efficient for large inputs."
                    },
                    {
                        "username": "haoyukwok",
                        "content": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //To check if sum of the entire array is greater than or equal to target\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        if(sum < target) {\\n            return 0;\\n        }\\n        \\n        //If sum is big enough\\n        int k = 1;\\n        int max_sum = 0;\\n        while(max_sum < target) {\\n            for(int i = 0; i < k; i++) {\\n                max_sum += nums[i];\\n            }\\n            if(max_sum >= target)\\n                return k;\\n\\n            int window_sum = max_sum;\\n            for(int i = k; i < nums.length; i++) {\\n                window_sum += nums[i] - nums[i - k];\\n                max_sum = Math.max(window_sum,max_sum);\\n            }\\n            if(max_sum >= target)\\n                return k;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n\\n\\nHello guys, I want to know why my program will output 2 instead of 2 when it deals with [1,2,3,4,5] target = 11."
                    }
                ]
            },
            {
                "id": 1992257,
                "content": [
                    {
                        "username": "Ly403",
                        "content": "This is easy actually."
                    },
                    {
                        "username": "mlivingston",
                        "content": "Think this is another one where some of the extremely long test cases and getting TLE errors is unreasonable.... this solution should totally be accepatable\\nhttps://gist.github.com/mlivingston40/0bf6bf7a71516d2a887e0e828511c775"
                    },
                    {
                        "username": "MohanKrishna5",
                        "content": "[1,2,3,4,5] how the output is 3 if target is 11"
                    },
                    {
                        "username": "sameena_yp",
                        "content": "I don't understand why the answer for the following inputs should be 8 instead of 7. Am I missing something? Looks like this question has been asked before and no one has responded from LeetCode yet. Can someone from LeetCode please review your answers for this question, so some of us can submit our responses? Thank you.\n\ntarget =\n213\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n"
                    },
                    {
                        "username": "ahrix268",
                        "content": "can you show me any subarray with length = 7 whose sum >= 213 ?!\\nactually, there\\'s none of it.\\nalso, there\\'re several subarrays with length = 8 whose sum >= 213. therefore, the answer is 8 in this case"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There is a bug in this question for [12,28,83,4,25,26,25,2,25,25,25,12] answer should be 7 as reported in this discussion earlier too. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@SoNiceCoder](/SoNiceCoder) It should be 7 but Leetcode incorrectly failed the test case asking for 8\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is target value for this specific tc ?\\n "
                    },
                    {
                        "username": "xtrezzes",
                        "content": " `int minLen = Int32.MaxValue;\nint currLen = 0, leftPointer = 0, tempTarget = target;\n\n            while (leftPointer < nums.Length)\n            {\n                for (int i = leftPointer; i < nums.Length && tempTarget > 0; i++)\n                {\n                    tempTarget -= nums[i];\n                    currLen++;\n                }\n\n                if (tempTarget <= 0)\n                {\n                    if (currLen < minLen)\n                        minLen = currLen;\n                }\n\n                currLen = 0;\n                leftPointer++;\n                tempTarget = target;\n            }\n\n            return (minLen < Int32.MaxValue) ? minLen : 0;\n`\n\nHi all, please, help with my decision. Doesn't pass because TLE with a test case where there are 100000 elements with a value of 10000 and the target is 1 billion =). I looked at the solutions and saw a brute-force with three loops and O(n^3) complexity, which is also not suitable due to TLE. Also, in the solutions, I found an improved brute-force with O(n^2) complexity, which passes the tests. But my code is much faster (if only because there are not 3, but 2 loops, and because of the conditions in the second loop, it will not be executed n times, which means that the total complexity is even less than even O(n^2) )."
                    },
                    {
                        "username": "satyaso",
                        "content": "I am not able to understand, How can the expected result be 2 for this testcase? . Can anyone explain? target =20, nums=[2,16,14,15], my output is 0 , But it\\'s wrong. Expected is 2.\\n"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "It\\'s greater than or equal to. so 16 + 14 = 30 => 20 ."
                    },
                    {
                        "username": "saurya_k_gupta",
                        "content": "Solve using Sliding Window concept."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "void helper(int i,vector<int>&Nums,vector<vector<int>>&h,vector<int>& k)\\n    {\\n         if(i==Nums.size())\\n         {\\n             h.push_back(k);\\n             return;\\n         }\\n         k.push_back(Nums[i]);\\n         helper(i+1,Nums,h,k);\\n         k.pop_back();\\n         helper(i+1,Nums,h,k);\\n         \\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n      vector<vector<int>>ans;\\n      vector<vector<int>>G;\\n      vector<int>h;\\n      helper(0,nums,G,h);\\n      int size=INT_MAX;\\n      for(int i=0;i<G.size();i++)\\n      {\\n          int sum=0;\\n          for(int j=0;j<G[i].size();j++)\\n          {\\n              sum=sum+G[i][j];\\n          }\\n          if(sum>=target)\\n          { \\n            int size1=G[i].size();\\n            size=min(size,size1);\\n          }\\n      }\\n      if(size==INT_MAX)\\n      {\\n        return 0;\\n      }\\n      return size;\\n      \\n    }\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\noutput:7\\nexpected:8\\nWhy i am getting the wrong answer in this case?\\nPlease anybody tell me .\\n"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "[@bparanj](/bparanj)  Thank you Sir,it  is  a nice approach.Now it\\'s clear."
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve shared is an implementation of a brute force solution to find the smallest length subarray with a sum greater than or equal to a given target. This approach generates all possible subarrays and checks each one to see if its sum is greater than or equal to the target.\\n\\nThe problem is that the code doesn\\'t guarantee that the minimum length subarray found is contiguous (i.e., its elements are in consecutive positions in the original array). In your code, you are considering all subsets of the array, not just the contiguous subarrays.\\n\\nLet\\'s consider the array [12,28,83,4,25,26,25,2,25,25,25,12] and the target value 213. The smallest contiguous subarray that sums up to 213 or more is [83,4,25,26,25,2,25,25], which is 8 elements long. However, your code might return a non-contiguous subarray [83,4,25,26,25,2,25], which is 7 elements long.\\n\\nYou need to change your approach to solve this problem. An efficient solution is to use a two-pointer (or sliding window) technique. This approach maintains a window of elements and adjusts its size and position based on the sum of its elements compared to the target. This guarantees that you are only considering contiguous subarrays. Here\\'s a simple implementation:\\n\\n```cpp\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    int left = 0, sum = 0, minLen = INT_MAX;\\n    for (int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while (sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (minLen != INT_MAX) ? minLen : 0;\\n}\\n```\\nIn this code, we continuously add elements to `sum` until it is greater than or equal to `target`. Once `sum` is large enough, we subtract elements from the left side of the window until `sum` is less than `target` again. We repeat this process, maintaining the smallest window size (`minLen`) seen so far. If no subarray meets the condition, the function returns 0. This approach has a time complexity of O(n), making it much more efficient for large inputs."
                    },
                    {
                        "username": "haoyukwok",
                        "content": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //To check if sum of the entire array is greater than or equal to target\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        if(sum < target) {\\n            return 0;\\n        }\\n        \\n        //If sum is big enough\\n        int k = 1;\\n        int max_sum = 0;\\n        while(max_sum < target) {\\n            for(int i = 0; i < k; i++) {\\n                max_sum += nums[i];\\n            }\\n            if(max_sum >= target)\\n                return k;\\n\\n            int window_sum = max_sum;\\n            for(int i = k; i < nums.length; i++) {\\n                window_sum += nums[i] - nums[i - k];\\n                max_sum = Math.max(window_sum,max_sum);\\n            }\\n            if(max_sum >= target)\\n                return k;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n\\n\\nHello guys, I want to know why my program will output 2 instead of 2 when it deals with [1,2,3,4,5] target = 11."
                    }
                ]
            },
            {
                "id": 1988756,
                "content": [
                    {
                        "username": "Ly403",
                        "content": "This is easy actually."
                    },
                    {
                        "username": "mlivingston",
                        "content": "Think this is another one where some of the extremely long test cases and getting TLE errors is unreasonable.... this solution should totally be accepatable\\nhttps://gist.github.com/mlivingston40/0bf6bf7a71516d2a887e0e828511c775"
                    },
                    {
                        "username": "MohanKrishna5",
                        "content": "[1,2,3,4,5] how the output is 3 if target is 11"
                    },
                    {
                        "username": "sameena_yp",
                        "content": "I don't understand why the answer for the following inputs should be 8 instead of 7. Am I missing something? Looks like this question has been asked before and no one has responded from LeetCode yet. Can someone from LeetCode please review your answers for this question, so some of us can submit our responses? Thank you.\n\ntarget =\n213\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n"
                    },
                    {
                        "username": "ahrix268",
                        "content": "can you show me any subarray with length = 7 whose sum >= 213 ?!\\nactually, there\\'s none of it.\\nalso, there\\'re several subarrays with length = 8 whose sum >= 213. therefore, the answer is 8 in this case"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There is a bug in this question for [12,28,83,4,25,26,25,2,25,25,25,12] answer should be 7 as reported in this discussion earlier too. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@SoNiceCoder](/SoNiceCoder) It should be 7 but Leetcode incorrectly failed the test case asking for 8\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is target value for this specific tc ?\\n "
                    },
                    {
                        "username": "xtrezzes",
                        "content": " `int minLen = Int32.MaxValue;\nint currLen = 0, leftPointer = 0, tempTarget = target;\n\n            while (leftPointer < nums.Length)\n            {\n                for (int i = leftPointer; i < nums.Length && tempTarget > 0; i++)\n                {\n                    tempTarget -= nums[i];\n                    currLen++;\n                }\n\n                if (tempTarget <= 0)\n                {\n                    if (currLen < minLen)\n                        minLen = currLen;\n                }\n\n                currLen = 0;\n                leftPointer++;\n                tempTarget = target;\n            }\n\n            return (minLen < Int32.MaxValue) ? minLen : 0;\n`\n\nHi all, please, help with my decision. Doesn't pass because TLE with a test case where there are 100000 elements with a value of 10000 and the target is 1 billion =). I looked at the solutions and saw a brute-force with three loops and O(n^3) complexity, which is also not suitable due to TLE. Also, in the solutions, I found an improved brute-force with O(n^2) complexity, which passes the tests. But my code is much faster (if only because there are not 3, but 2 loops, and because of the conditions in the second loop, it will not be executed n times, which means that the total complexity is even less than even O(n^2) )."
                    },
                    {
                        "username": "satyaso",
                        "content": "I am not able to understand, How can the expected result be 2 for this testcase? . Can anyone explain? target =20, nums=[2,16,14,15], my output is 0 , But it\\'s wrong. Expected is 2.\\n"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "It\\'s greater than or equal to. so 16 + 14 = 30 => 20 ."
                    },
                    {
                        "username": "saurya_k_gupta",
                        "content": "Solve using Sliding Window concept."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "void helper(int i,vector<int>&Nums,vector<vector<int>>&h,vector<int>& k)\\n    {\\n         if(i==Nums.size())\\n         {\\n             h.push_back(k);\\n             return;\\n         }\\n         k.push_back(Nums[i]);\\n         helper(i+1,Nums,h,k);\\n         k.pop_back();\\n         helper(i+1,Nums,h,k);\\n         \\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n      vector<vector<int>>ans;\\n      vector<vector<int>>G;\\n      vector<int>h;\\n      helper(0,nums,G,h);\\n      int size=INT_MAX;\\n      for(int i=0;i<G.size();i++)\\n      {\\n          int sum=0;\\n          for(int j=0;j<G[i].size();j++)\\n          {\\n              sum=sum+G[i][j];\\n          }\\n          if(sum>=target)\\n          { \\n            int size1=G[i].size();\\n            size=min(size,size1);\\n          }\\n      }\\n      if(size==INT_MAX)\\n      {\\n        return 0;\\n      }\\n      return size;\\n      \\n    }\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\noutput:7\\nexpected:8\\nWhy i am getting the wrong answer in this case?\\nPlease anybody tell me .\\n"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "[@bparanj](/bparanj)  Thank you Sir,it  is  a nice approach.Now it\\'s clear."
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve shared is an implementation of a brute force solution to find the smallest length subarray with a sum greater than or equal to a given target. This approach generates all possible subarrays and checks each one to see if its sum is greater than or equal to the target.\\n\\nThe problem is that the code doesn\\'t guarantee that the minimum length subarray found is contiguous (i.e., its elements are in consecutive positions in the original array). In your code, you are considering all subsets of the array, not just the contiguous subarrays.\\n\\nLet\\'s consider the array [12,28,83,4,25,26,25,2,25,25,25,12] and the target value 213. The smallest contiguous subarray that sums up to 213 or more is [83,4,25,26,25,2,25,25], which is 8 elements long. However, your code might return a non-contiguous subarray [83,4,25,26,25,2,25], which is 7 elements long.\\n\\nYou need to change your approach to solve this problem. An efficient solution is to use a two-pointer (or sliding window) technique. This approach maintains a window of elements and adjusts its size and position based on the sum of its elements compared to the target. This guarantees that you are only considering contiguous subarrays. Here\\'s a simple implementation:\\n\\n```cpp\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    int left = 0, sum = 0, minLen = INT_MAX;\\n    for (int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while (sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (minLen != INT_MAX) ? minLen : 0;\\n}\\n```\\nIn this code, we continuously add elements to `sum` until it is greater than or equal to `target`. Once `sum` is large enough, we subtract elements from the left side of the window until `sum` is less than `target` again. We repeat this process, maintaining the smallest window size (`minLen`) seen so far. If no subarray meets the condition, the function returns 0. This approach has a time complexity of O(n), making it much more efficient for large inputs."
                    },
                    {
                        "username": "haoyukwok",
                        "content": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //To check if sum of the entire array is greater than or equal to target\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        if(sum < target) {\\n            return 0;\\n        }\\n        \\n        //If sum is big enough\\n        int k = 1;\\n        int max_sum = 0;\\n        while(max_sum < target) {\\n            for(int i = 0; i < k; i++) {\\n                max_sum += nums[i];\\n            }\\n            if(max_sum >= target)\\n                return k;\\n\\n            int window_sum = max_sum;\\n            for(int i = k; i < nums.length; i++) {\\n                window_sum += nums[i] - nums[i - k];\\n                max_sum = Math.max(window_sum,max_sum);\\n            }\\n            if(max_sum >= target)\\n                return k;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n\\n\\nHello guys, I want to know why my program will output 2 instead of 2 when it deals with [1,2,3,4,5] target = 11."
                    }
                ]
            },
            {
                "id": 1987399,
                "content": [
                    {
                        "username": "Ly403",
                        "content": "This is easy actually."
                    },
                    {
                        "username": "mlivingston",
                        "content": "Think this is another one where some of the extremely long test cases and getting TLE errors is unreasonable.... this solution should totally be accepatable\\nhttps://gist.github.com/mlivingston40/0bf6bf7a71516d2a887e0e828511c775"
                    },
                    {
                        "username": "MohanKrishna5",
                        "content": "[1,2,3,4,5] how the output is 3 if target is 11"
                    },
                    {
                        "username": "sameena_yp",
                        "content": "I don't understand why the answer for the following inputs should be 8 instead of 7. Am I missing something? Looks like this question has been asked before and no one has responded from LeetCode yet. Can someone from LeetCode please review your answers for this question, so some of us can submit our responses? Thank you.\n\ntarget =\n213\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n"
                    },
                    {
                        "username": "ahrix268",
                        "content": "can you show me any subarray with length = 7 whose sum >= 213 ?!\\nactually, there\\'s none of it.\\nalso, there\\'re several subarrays with length = 8 whose sum >= 213. therefore, the answer is 8 in this case"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There is a bug in this question for [12,28,83,4,25,26,25,2,25,25,25,12] answer should be 7 as reported in this discussion earlier too. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "[@SoNiceCoder](/SoNiceCoder) It should be 7 but Leetcode incorrectly failed the test case asking for 8\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is target value for this specific tc ?\\n "
                    },
                    {
                        "username": "xtrezzes",
                        "content": " `int minLen = Int32.MaxValue;\nint currLen = 0, leftPointer = 0, tempTarget = target;\n\n            while (leftPointer < nums.Length)\n            {\n                for (int i = leftPointer; i < nums.Length && tempTarget > 0; i++)\n                {\n                    tempTarget -= nums[i];\n                    currLen++;\n                }\n\n                if (tempTarget <= 0)\n                {\n                    if (currLen < minLen)\n                        minLen = currLen;\n                }\n\n                currLen = 0;\n                leftPointer++;\n                tempTarget = target;\n            }\n\n            return (minLen < Int32.MaxValue) ? minLen : 0;\n`\n\nHi all, please, help with my decision. Doesn't pass because TLE with a test case where there are 100000 elements with a value of 10000 and the target is 1 billion =). I looked at the solutions and saw a brute-force with three loops and O(n^3) complexity, which is also not suitable due to TLE. Also, in the solutions, I found an improved brute-force with O(n^2) complexity, which passes the tests. But my code is much faster (if only because there are not 3, but 2 loops, and because of the conditions in the second loop, it will not be executed n times, which means that the total complexity is even less than even O(n^2) )."
                    },
                    {
                        "username": "satyaso",
                        "content": "I am not able to understand, How can the expected result be 2 for this testcase? . Can anyone explain? target =20, nums=[2,16,14,15], my output is 0 , But it\\'s wrong. Expected is 2.\\n"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "It\\'s greater than or equal to. so 16 + 14 = 30 => 20 ."
                    },
                    {
                        "username": "saurya_k_gupta",
                        "content": "Solve using Sliding Window concept."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "void helper(int i,vector<int>&Nums,vector<vector<int>>&h,vector<int>& k)\\n    {\\n         if(i==Nums.size())\\n         {\\n             h.push_back(k);\\n             return;\\n         }\\n         k.push_back(Nums[i]);\\n         helper(i+1,Nums,h,k);\\n         k.pop_back();\\n         helper(i+1,Nums,h,k);\\n         \\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) \\n    {\\n      vector<vector<int>>ans;\\n      vector<vector<int>>G;\\n      vector<int>h;\\n      helper(0,nums,G,h);\\n      int size=INT_MAX;\\n      for(int i=0;i<G.size();i++)\\n      {\\n          int sum=0;\\n          for(int j=0;j<G[i].size();j++)\\n          {\\n              sum=sum+G[i][j];\\n          }\\n          if(sum>=target)\\n          { \\n            int size1=G[i].size();\\n            size=min(size,size1);\\n          }\\n      }\\n      if(size==INT_MAX)\\n      {\\n        return 0;\\n      }\\n      return size;\\n      \\n    }\\n[12,28,83,4,25,26,25,2,25,25,25,12]\\noutput:7\\nexpected:8\\nWhy i am getting the wrong answer in this case?\\nPlease anybody tell me .\\n"
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "[@bparanj](/bparanj)  Thank you Sir,it  is  a nice approach.Now it\\'s clear."
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve shared is an implementation of a brute force solution to find the smallest length subarray with a sum greater than or equal to a given target. This approach generates all possible subarrays and checks each one to see if its sum is greater than or equal to the target.\\n\\nThe problem is that the code doesn\\'t guarantee that the minimum length subarray found is contiguous (i.e., its elements are in consecutive positions in the original array). In your code, you are considering all subsets of the array, not just the contiguous subarrays.\\n\\nLet\\'s consider the array [12,28,83,4,25,26,25,2,25,25,25,12] and the target value 213. The smallest contiguous subarray that sums up to 213 or more is [83,4,25,26,25,2,25,25], which is 8 elements long. However, your code might return a non-contiguous subarray [83,4,25,26,25,2,25], which is 7 elements long.\\n\\nYou need to change your approach to solve this problem. An efficient solution is to use a two-pointer (or sliding window) technique. This approach maintains a window of elements and adjusts its size and position based on the sum of its elements compared to the target. This guarantees that you are only considering contiguous subarrays. Here\\'s a simple implementation:\\n\\n```cpp\\nint minSubArrayLen(int target, vector<int>& nums) {\\n    int n = nums.size();\\n    int left = 0, sum = 0, minLen = INT_MAX;\\n    for (int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while (sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left++];\\n        }\\n    }\\n    return (minLen != INT_MAX) ? minLen : 0;\\n}\\n```\\nIn this code, we continuously add elements to `sum` until it is greater than or equal to `target`. Once `sum` is large enough, we subtract elements from the left side of the window until `sum` is less than `target` again. We repeat this process, maintaining the smallest window size (`minLen`) seen so far. If no subarray meets the condition, the function returns 0. This approach has a time complexity of O(n), making it much more efficient for large inputs."
                    },
                    {
                        "username": "haoyukwok",
                        "content": "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        //To check if sum of the entire array is greater than or equal to target\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        if(sum < target) {\\n            return 0;\\n        }\\n        \\n        //If sum is big enough\\n        int k = 1;\\n        int max_sum = 0;\\n        while(max_sum < target) {\\n            for(int i = 0; i < k; i++) {\\n                max_sum += nums[i];\\n            }\\n            if(max_sum >= target)\\n                return k;\\n\\n            int window_sum = max_sum;\\n            for(int i = k; i < nums.length; i++) {\\n                window_sum += nums[i] - nums[i - k];\\n                max_sum = Math.max(window_sum,max_sum);\\n            }\\n            if(max_sum >= target)\\n                return k;\\n            k++;\\n        }\\n        return k;\\n    }\\n}\\n\\n\\nHello guys, I want to know why my program will output 2 instead of 2 when it deals with [1,2,3,4,5] target = 11."
                    }
                ]
            },
            {
                "id": 1984209,
                "content": [
                    {
                        "username": "TwilightTraveler",
                        "content": "Wow, I spent so long doing this program and wondering why the test case \"2, 16, 14, 15\" -> 2 wasn\\'t working. And then I realized, it said Greater or equal, I thought it was only equal to. This problem is super simple for greater than."
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "Question includes in binary search but arr not sorted!!!!  But whenever I try to solve this using binary search after sorting the array, then it violates the question\\'s rule..... can anyone help me to solve this puzzle?? \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is more of a sliding window problem than a binary search problem."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": " public int minSubArrayLen(int target, int[] nums) {\\n        int min_length=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int sum=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(i!=j){\\n                    sum+=+nums[j];\\n                    if(sum>=target){\\n                        min_length=Math.min(min_length, j-i+1);\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[i]>=target){\\n                        min_length=1;\\n                        return min_length;\\n                    }\\n                }\\n            }\\n            sum=0;\\n        }\\n\\n        if(min_length==Integer.MAX_VALUE){\\n            return 0;\\n        }else{\\n            return min_length;\\n        }\\n    }\\n\\n\\n\\nif this is n^2 why isnt it accepted?"
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "I had a test case were all the nums were even but the target is odd, so the output should be 0, but it said the expected outcome is 4."
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "Yes, of course it can be greater than the target, so a case of me not reading the question properly. A good lesson relearned.\\nIt is a trickier problem if the sum has to be equal to the target. All testcases pass even when you just go for the exact target."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you can take  subarray that gives the sum greater than target and have minimum length"
                    },
                    {
                        "username": "nagasundaram373",
                        "content": " `class Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int ans=Integer.MAX_VALUE;\\n        int sum=0;\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            count++;\\n            if(target==sum){\\n                sum=0;\\n                ans=Math.min(ans,count);\\n                count=0;\\n            }\\n           \\n        }\\n        return ans==Integer.MAX_VALUE ? 0 :ans;\\n        \\n    }\\n}`\\n what is wrong in this code\\n"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "The condition if (target == sum) is incorrect because it is checking if the current sum is equal to the target. Instead, it should check if the current sum is greater than or equal to the target.\\n\\nuse :\\nwhile (sum >= target) {\\n                ans = Math.min(ans, count);\\n                sum -= A[i - count + 1];\\n                count--;\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once you get your sum euqal Target  you are setting the sum =0 which will give the wrong answer  you just need to subtract the initial elements of subarray until sum becomes less than Target again so you can count all subarray. And get the minimum   subarray lengths \nYou can check the solution here https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3094090/c-simple-solutions-2-solutions/"
                    },
                    {
                        "username": "DanielaYamashita",
                        "content": "It is strange, in the test case below:\\n\\ntarge = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\n\\nI got 7 as the smallest combination length, which is [28, 83, 4, 25, 26, 25, 25]. However, the expected result is 8. Does someone know what is wrong ?"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "A subarray is a contiguous non-empty sequence of elements within an array."
                    },
                    {
                        "username": "hemanth_12",
                        "content": "the question itself wrong i also got same error but if you try continious subarray it will work"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@DanielaYamashita](/DanielaYamashita) I think you missed 2 (index 7)."
                    },
                    {
                        "username": "l227874",
                        "content": "dsdsdsdsd"
                    },
                    {
                        "username": "Tediyang",
                        "content": "testcase 19: 10^5 is giving me serious runtime error.\\n"
                    },
                    {
                        "username": "luke_py",
                        "content": "I watched a video on sliding window algorithm this morning, and this turns out to be the daily problem today. what a coincidence lol :)"
                    },
                    {
                        "username": "sarthakr10",
                        "content": "my solution in not correct for 19th test case i.e. {2,3,1,1,1,1,1}. , target = 5. output should be 2 my is 3......rest all test case are solved please see where I am getting it wrong....\\n class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minlength = n +1;\\n        int start = 0 , end = 0,sum = 0;\\n        while(end < n){\\n            while(end< n && sum <= target){\\n                sum += nums[end++];\\n            }\\n            while(sum >= target && start < n){\\n                if(end - start < minlength){\\n                    minlength = end -start;\\n                }\\n                sum -= nums[start++];\\n            }\\n\\n        }\\n        if(minlength >= n+1){\\n            return 0;\\n        }\\n        return minlength;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1984017,
                "content": [
                    {
                        "username": "TwilightTraveler",
                        "content": "Wow, I spent so long doing this program and wondering why the test case \"2, 16, 14, 15\" -> 2 wasn\\'t working. And then I realized, it said Greater or equal, I thought it was only equal to. This problem is super simple for greater than."
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "Question includes in binary search but arr not sorted!!!!  But whenever I try to solve this using binary search after sorting the array, then it violates the question\\'s rule..... can anyone help me to solve this puzzle?? \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is more of a sliding window problem than a binary search problem."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": " public int minSubArrayLen(int target, int[] nums) {\\n        int min_length=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int sum=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(i!=j){\\n                    sum+=+nums[j];\\n                    if(sum>=target){\\n                        min_length=Math.min(min_length, j-i+1);\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[i]>=target){\\n                        min_length=1;\\n                        return min_length;\\n                    }\\n                }\\n            }\\n            sum=0;\\n        }\\n\\n        if(min_length==Integer.MAX_VALUE){\\n            return 0;\\n        }else{\\n            return min_length;\\n        }\\n    }\\n\\n\\n\\nif this is n^2 why isnt it accepted?"
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "I had a test case were all the nums were even but the target is odd, so the output should be 0, but it said the expected outcome is 4."
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "Yes, of course it can be greater than the target, so a case of me not reading the question properly. A good lesson relearned.\\nIt is a trickier problem if the sum has to be equal to the target. All testcases pass even when you just go for the exact target."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you can take  subarray that gives the sum greater than target and have minimum length"
                    },
                    {
                        "username": "nagasundaram373",
                        "content": " `class Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int ans=Integer.MAX_VALUE;\\n        int sum=0;\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            count++;\\n            if(target==sum){\\n                sum=0;\\n                ans=Math.min(ans,count);\\n                count=0;\\n            }\\n           \\n        }\\n        return ans==Integer.MAX_VALUE ? 0 :ans;\\n        \\n    }\\n}`\\n what is wrong in this code\\n"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "The condition if (target == sum) is incorrect because it is checking if the current sum is equal to the target. Instead, it should check if the current sum is greater than or equal to the target.\\n\\nuse :\\nwhile (sum >= target) {\\n                ans = Math.min(ans, count);\\n                sum -= A[i - count + 1];\\n                count--;\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once you get your sum euqal Target  you are setting the sum =0 which will give the wrong answer  you just need to subtract the initial elements of subarray until sum becomes less than Target again so you can count all subarray. And get the minimum   subarray lengths \nYou can check the solution here https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3094090/c-simple-solutions-2-solutions/"
                    },
                    {
                        "username": "DanielaYamashita",
                        "content": "It is strange, in the test case below:\\n\\ntarge = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\n\\nI got 7 as the smallest combination length, which is [28, 83, 4, 25, 26, 25, 25]. However, the expected result is 8. Does someone know what is wrong ?"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "A subarray is a contiguous non-empty sequence of elements within an array."
                    },
                    {
                        "username": "hemanth_12",
                        "content": "the question itself wrong i also got same error but if you try continious subarray it will work"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@DanielaYamashita](/DanielaYamashita) I think you missed 2 (index 7)."
                    },
                    {
                        "username": "l227874",
                        "content": "dsdsdsdsd"
                    },
                    {
                        "username": "Tediyang",
                        "content": "testcase 19: 10^5 is giving me serious runtime error.\\n"
                    },
                    {
                        "username": "luke_py",
                        "content": "I watched a video on sliding window algorithm this morning, and this turns out to be the daily problem today. what a coincidence lol :)"
                    },
                    {
                        "username": "sarthakr10",
                        "content": "my solution in not correct for 19th test case i.e. {2,3,1,1,1,1,1}. , target = 5. output should be 2 my is 3......rest all test case are solved please see where I am getting it wrong....\\n class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minlength = n +1;\\n        int start = 0 , end = 0,sum = 0;\\n        while(end < n){\\n            while(end< n && sum <= target){\\n                sum += nums[end++];\\n            }\\n            while(sum >= target && start < n){\\n                if(end - start < minlength){\\n                    minlength = end -start;\\n                }\\n                sum -= nums[start++];\\n            }\\n\\n        }\\n        if(minlength >= n+1){\\n            return 0;\\n        }\\n        return minlength;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1971427,
                "content": [
                    {
                        "username": "TwilightTraveler",
                        "content": "Wow, I spent so long doing this program and wondering why the test case \"2, 16, 14, 15\" -> 2 wasn\\'t working. And then I realized, it said Greater or equal, I thought it was only equal to. This problem is super simple for greater than."
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "Question includes in binary search but arr not sorted!!!!  But whenever I try to solve this using binary search after sorting the array, then it violates the question\\'s rule..... can anyone help me to solve this puzzle?? \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is more of a sliding window problem than a binary search problem."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": " public int minSubArrayLen(int target, int[] nums) {\\n        int min_length=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int sum=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(i!=j){\\n                    sum+=+nums[j];\\n                    if(sum>=target){\\n                        min_length=Math.min(min_length, j-i+1);\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[i]>=target){\\n                        min_length=1;\\n                        return min_length;\\n                    }\\n                }\\n            }\\n            sum=0;\\n        }\\n\\n        if(min_length==Integer.MAX_VALUE){\\n            return 0;\\n        }else{\\n            return min_length;\\n        }\\n    }\\n\\n\\n\\nif this is n^2 why isnt it accepted?"
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "I had a test case were all the nums were even but the target is odd, so the output should be 0, but it said the expected outcome is 4."
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "Yes, of course it can be greater than the target, so a case of me not reading the question properly. A good lesson relearned.\\nIt is a trickier problem if the sum has to be equal to the target. All testcases pass even when you just go for the exact target."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you can take  subarray that gives the sum greater than target and have minimum length"
                    },
                    {
                        "username": "nagasundaram373",
                        "content": " `class Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int ans=Integer.MAX_VALUE;\\n        int sum=0;\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            count++;\\n            if(target==sum){\\n                sum=0;\\n                ans=Math.min(ans,count);\\n                count=0;\\n            }\\n           \\n        }\\n        return ans==Integer.MAX_VALUE ? 0 :ans;\\n        \\n    }\\n}`\\n what is wrong in this code\\n"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "The condition if (target == sum) is incorrect because it is checking if the current sum is equal to the target. Instead, it should check if the current sum is greater than or equal to the target.\\n\\nuse :\\nwhile (sum >= target) {\\n                ans = Math.min(ans, count);\\n                sum -= A[i - count + 1];\\n                count--;\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once you get your sum euqal Target  you are setting the sum =0 which will give the wrong answer  you just need to subtract the initial elements of subarray until sum becomes less than Target again so you can count all subarray. And get the minimum   subarray lengths \nYou can check the solution here https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3094090/c-simple-solutions-2-solutions/"
                    },
                    {
                        "username": "DanielaYamashita",
                        "content": "It is strange, in the test case below:\\n\\ntarge = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\n\\nI got 7 as the smallest combination length, which is [28, 83, 4, 25, 26, 25, 25]. However, the expected result is 8. Does someone know what is wrong ?"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "A subarray is a contiguous non-empty sequence of elements within an array."
                    },
                    {
                        "username": "hemanth_12",
                        "content": "the question itself wrong i also got same error but if you try continious subarray it will work"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@DanielaYamashita](/DanielaYamashita) I think you missed 2 (index 7)."
                    },
                    {
                        "username": "l227874",
                        "content": "dsdsdsdsd"
                    },
                    {
                        "username": "Tediyang",
                        "content": "testcase 19: 10^5 is giving me serious runtime error.\\n"
                    },
                    {
                        "username": "luke_py",
                        "content": "I watched a video on sliding window algorithm this morning, and this turns out to be the daily problem today. what a coincidence lol :)"
                    },
                    {
                        "username": "sarthakr10",
                        "content": "my solution in not correct for 19th test case i.e. {2,3,1,1,1,1,1}. , target = 5. output should be 2 my is 3......rest all test case are solved please see where I am getting it wrong....\\n class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minlength = n +1;\\n        int start = 0 , end = 0,sum = 0;\\n        while(end < n){\\n            while(end< n && sum <= target){\\n                sum += nums[end++];\\n            }\\n            while(sum >= target && start < n){\\n                if(end - start < minlength){\\n                    minlength = end -start;\\n                }\\n                sum -= nums[start++];\\n            }\\n\\n        }\\n        if(minlength >= n+1){\\n            return 0;\\n        }\\n        return minlength;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1965926,
                "content": [
                    {
                        "username": "TwilightTraveler",
                        "content": "Wow, I spent so long doing this program and wondering why the test case \"2, 16, 14, 15\" -> 2 wasn\\'t working. And then I realized, it said Greater or equal, I thought it was only equal to. This problem is super simple for greater than."
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "Question includes in binary search but arr not sorted!!!!  But whenever I try to solve this using binary search after sorting the array, then it violates the question\\'s rule..... can anyone help me to solve this puzzle?? \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is more of a sliding window problem than a binary search problem."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": " public int minSubArrayLen(int target, int[] nums) {\\n        int min_length=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int sum=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(i!=j){\\n                    sum+=+nums[j];\\n                    if(sum>=target){\\n                        min_length=Math.min(min_length, j-i+1);\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[i]>=target){\\n                        min_length=1;\\n                        return min_length;\\n                    }\\n                }\\n            }\\n            sum=0;\\n        }\\n\\n        if(min_length==Integer.MAX_VALUE){\\n            return 0;\\n        }else{\\n            return min_length;\\n        }\\n    }\\n\\n\\n\\nif this is n^2 why isnt it accepted?"
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "I had a test case were all the nums were even but the target is odd, so the output should be 0, but it said the expected outcome is 4."
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "Yes, of course it can be greater than the target, so a case of me not reading the question properly. A good lesson relearned.\\nIt is a trickier problem if the sum has to be equal to the target. All testcases pass even when you just go for the exact target."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you can take  subarray that gives the sum greater than target and have minimum length"
                    },
                    {
                        "username": "nagasundaram373",
                        "content": " `class Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int ans=Integer.MAX_VALUE;\\n        int sum=0;\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            count++;\\n            if(target==sum){\\n                sum=0;\\n                ans=Math.min(ans,count);\\n                count=0;\\n            }\\n           \\n        }\\n        return ans==Integer.MAX_VALUE ? 0 :ans;\\n        \\n    }\\n}`\\n what is wrong in this code\\n"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "The condition if (target == sum) is incorrect because it is checking if the current sum is equal to the target. Instead, it should check if the current sum is greater than or equal to the target.\\n\\nuse :\\nwhile (sum >= target) {\\n                ans = Math.min(ans, count);\\n                sum -= A[i - count + 1];\\n                count--;\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once you get your sum euqal Target  you are setting the sum =0 which will give the wrong answer  you just need to subtract the initial elements of subarray until sum becomes less than Target again so you can count all subarray. And get the minimum   subarray lengths \nYou can check the solution here https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3094090/c-simple-solutions-2-solutions/"
                    },
                    {
                        "username": "DanielaYamashita",
                        "content": "It is strange, in the test case below:\\n\\ntarge = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\n\\nI got 7 as the smallest combination length, which is [28, 83, 4, 25, 26, 25, 25]. However, the expected result is 8. Does someone know what is wrong ?"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "A subarray is a contiguous non-empty sequence of elements within an array."
                    },
                    {
                        "username": "hemanth_12",
                        "content": "the question itself wrong i also got same error but if you try continious subarray it will work"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@DanielaYamashita](/DanielaYamashita) I think you missed 2 (index 7)."
                    },
                    {
                        "username": "l227874",
                        "content": "dsdsdsdsd"
                    },
                    {
                        "username": "Tediyang",
                        "content": "testcase 19: 10^5 is giving me serious runtime error.\\n"
                    },
                    {
                        "username": "luke_py",
                        "content": "I watched a video on sliding window algorithm this morning, and this turns out to be the daily problem today. what a coincidence lol :)"
                    },
                    {
                        "username": "sarthakr10",
                        "content": "my solution in not correct for 19th test case i.e. {2,3,1,1,1,1,1}. , target = 5. output should be 2 my is 3......rest all test case are solved please see where I am getting it wrong....\\n class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minlength = n +1;\\n        int start = 0 , end = 0,sum = 0;\\n        while(end < n){\\n            while(end< n && sum <= target){\\n                sum += nums[end++];\\n            }\\n            while(sum >= target && start < n){\\n                if(end - start < minlength){\\n                    minlength = end -start;\\n                }\\n                sum -= nums[start++];\\n            }\\n\\n        }\\n        if(minlength >= n+1){\\n            return 0;\\n        }\\n        return minlength;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1963996,
                "content": [
                    {
                        "username": "TwilightTraveler",
                        "content": "Wow, I spent so long doing this program and wondering why the test case \"2, 16, 14, 15\" -> 2 wasn\\'t working. And then I realized, it said Greater or equal, I thought it was only equal to. This problem is super simple for greater than."
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "Question includes in binary search but arr not sorted!!!!  But whenever I try to solve this using binary search after sorting the array, then it violates the question\\'s rule..... can anyone help me to solve this puzzle?? \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is more of a sliding window problem than a binary search problem."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": " public int minSubArrayLen(int target, int[] nums) {\\n        int min_length=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int sum=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(i!=j){\\n                    sum+=+nums[j];\\n                    if(sum>=target){\\n                        min_length=Math.min(min_length, j-i+1);\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[i]>=target){\\n                        min_length=1;\\n                        return min_length;\\n                    }\\n                }\\n            }\\n            sum=0;\\n        }\\n\\n        if(min_length==Integer.MAX_VALUE){\\n            return 0;\\n        }else{\\n            return min_length;\\n        }\\n    }\\n\\n\\n\\nif this is n^2 why isnt it accepted?"
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "I had a test case were all the nums were even but the target is odd, so the output should be 0, but it said the expected outcome is 4."
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "Yes, of course it can be greater than the target, so a case of me not reading the question properly. A good lesson relearned.\\nIt is a trickier problem if the sum has to be equal to the target. All testcases pass even when you just go for the exact target."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you can take  subarray that gives the sum greater than target and have minimum length"
                    },
                    {
                        "username": "nagasundaram373",
                        "content": " `class Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int ans=Integer.MAX_VALUE;\\n        int sum=0;\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            count++;\\n            if(target==sum){\\n                sum=0;\\n                ans=Math.min(ans,count);\\n                count=0;\\n            }\\n           \\n        }\\n        return ans==Integer.MAX_VALUE ? 0 :ans;\\n        \\n    }\\n}`\\n what is wrong in this code\\n"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "The condition if (target == sum) is incorrect because it is checking if the current sum is equal to the target. Instead, it should check if the current sum is greater than or equal to the target.\\n\\nuse :\\nwhile (sum >= target) {\\n                ans = Math.min(ans, count);\\n                sum -= A[i - count + 1];\\n                count--;\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once you get your sum euqal Target  you are setting the sum =0 which will give the wrong answer  you just need to subtract the initial elements of subarray until sum becomes less than Target again so you can count all subarray. And get the minimum   subarray lengths \nYou can check the solution here https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3094090/c-simple-solutions-2-solutions/"
                    },
                    {
                        "username": "DanielaYamashita",
                        "content": "It is strange, in the test case below:\\n\\ntarge = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\n\\nI got 7 as the smallest combination length, which is [28, 83, 4, 25, 26, 25, 25]. However, the expected result is 8. Does someone know what is wrong ?"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "A subarray is a contiguous non-empty sequence of elements within an array."
                    },
                    {
                        "username": "hemanth_12",
                        "content": "the question itself wrong i also got same error but if you try continious subarray it will work"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@DanielaYamashita](/DanielaYamashita) I think you missed 2 (index 7)."
                    },
                    {
                        "username": "l227874",
                        "content": "dsdsdsdsd"
                    },
                    {
                        "username": "Tediyang",
                        "content": "testcase 19: 10^5 is giving me serious runtime error.\\n"
                    },
                    {
                        "username": "luke_py",
                        "content": "I watched a video on sliding window algorithm this morning, and this turns out to be the daily problem today. what a coincidence lol :)"
                    },
                    {
                        "username": "sarthakr10",
                        "content": "my solution in not correct for 19th test case i.e. {2,3,1,1,1,1,1}. , target = 5. output should be 2 my is 3......rest all test case are solved please see where I am getting it wrong....\\n class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minlength = n +1;\\n        int start = 0 , end = 0,sum = 0;\\n        while(end < n){\\n            while(end< n && sum <= target){\\n                sum += nums[end++];\\n            }\\n            while(sum >= target && start < n){\\n                if(end - start < minlength){\\n                    minlength = end -start;\\n                }\\n                sum -= nums[start++];\\n            }\\n\\n        }\\n        if(minlength >= n+1){\\n            return 0;\\n        }\\n        return minlength;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1963326,
                "content": [
                    {
                        "username": "TwilightTraveler",
                        "content": "Wow, I spent so long doing this program and wondering why the test case \"2, 16, 14, 15\" -> 2 wasn\\'t working. And then I realized, it said Greater or equal, I thought it was only equal to. This problem is super simple for greater than."
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "Question includes in binary search but arr not sorted!!!!  But whenever I try to solve this using binary search after sorting the array, then it violates the question\\'s rule..... can anyone help me to solve this puzzle?? \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is more of a sliding window problem than a binary search problem."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": " public int minSubArrayLen(int target, int[] nums) {\\n        int min_length=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int sum=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(i!=j){\\n                    sum+=+nums[j];\\n                    if(sum>=target){\\n                        min_length=Math.min(min_length, j-i+1);\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[i]>=target){\\n                        min_length=1;\\n                        return min_length;\\n                    }\\n                }\\n            }\\n            sum=0;\\n        }\\n\\n        if(min_length==Integer.MAX_VALUE){\\n            return 0;\\n        }else{\\n            return min_length;\\n        }\\n    }\\n\\n\\n\\nif this is n^2 why isnt it accepted?"
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "I had a test case were all the nums were even but the target is odd, so the output should be 0, but it said the expected outcome is 4."
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "Yes, of course it can be greater than the target, so a case of me not reading the question properly. A good lesson relearned.\\nIt is a trickier problem if the sum has to be equal to the target. All testcases pass even when you just go for the exact target."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you can take  subarray that gives the sum greater than target and have minimum length"
                    },
                    {
                        "username": "nagasundaram373",
                        "content": " `class Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int ans=Integer.MAX_VALUE;\\n        int sum=0;\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            count++;\\n            if(target==sum){\\n                sum=0;\\n                ans=Math.min(ans,count);\\n                count=0;\\n            }\\n           \\n        }\\n        return ans==Integer.MAX_VALUE ? 0 :ans;\\n        \\n    }\\n}`\\n what is wrong in this code\\n"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "The condition if (target == sum) is incorrect because it is checking if the current sum is equal to the target. Instead, it should check if the current sum is greater than or equal to the target.\\n\\nuse :\\nwhile (sum >= target) {\\n                ans = Math.min(ans, count);\\n                sum -= A[i - count + 1];\\n                count--;\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once you get your sum euqal Target  you are setting the sum =0 which will give the wrong answer  you just need to subtract the initial elements of subarray until sum becomes less than Target again so you can count all subarray. And get the minimum   subarray lengths \nYou can check the solution here https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3094090/c-simple-solutions-2-solutions/"
                    },
                    {
                        "username": "DanielaYamashita",
                        "content": "It is strange, in the test case below:\\n\\ntarge = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\n\\nI got 7 as the smallest combination length, which is [28, 83, 4, 25, 26, 25, 25]. However, the expected result is 8. Does someone know what is wrong ?"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "A subarray is a contiguous non-empty sequence of elements within an array."
                    },
                    {
                        "username": "hemanth_12",
                        "content": "the question itself wrong i also got same error but if you try continious subarray it will work"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@DanielaYamashita](/DanielaYamashita) I think you missed 2 (index 7)."
                    },
                    {
                        "username": "l227874",
                        "content": "dsdsdsdsd"
                    },
                    {
                        "username": "Tediyang",
                        "content": "testcase 19: 10^5 is giving me serious runtime error.\\n"
                    },
                    {
                        "username": "luke_py",
                        "content": "I watched a video on sliding window algorithm this morning, and this turns out to be the daily problem today. what a coincidence lol :)"
                    },
                    {
                        "username": "sarthakr10",
                        "content": "my solution in not correct for 19th test case i.e. {2,3,1,1,1,1,1}. , target = 5. output should be 2 my is 3......rest all test case are solved please see where I am getting it wrong....\\n class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minlength = n +1;\\n        int start = 0 , end = 0,sum = 0;\\n        while(end < n){\\n            while(end< n && sum <= target){\\n                sum += nums[end++];\\n            }\\n            while(sum >= target && start < n){\\n                if(end - start < minlength){\\n                    minlength = end -start;\\n                }\\n                sum -= nums[start++];\\n            }\\n\\n        }\\n        if(minlength >= n+1){\\n            return 0;\\n        }\\n        return minlength;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1960888,
                "content": [
                    {
                        "username": "TwilightTraveler",
                        "content": "Wow, I spent so long doing this program and wondering why the test case \"2, 16, 14, 15\" -> 2 wasn\\'t working. And then I realized, it said Greater or equal, I thought it was only equal to. This problem is super simple for greater than."
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "Question includes in binary search but arr not sorted!!!!  But whenever I try to solve this using binary search after sorting the array, then it violates the question\\'s rule..... can anyone help me to solve this puzzle?? \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is more of a sliding window problem than a binary search problem."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": " public int minSubArrayLen(int target, int[] nums) {\\n        int min_length=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int sum=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(i!=j){\\n                    sum+=+nums[j];\\n                    if(sum>=target){\\n                        min_length=Math.min(min_length, j-i+1);\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[i]>=target){\\n                        min_length=1;\\n                        return min_length;\\n                    }\\n                }\\n            }\\n            sum=0;\\n        }\\n\\n        if(min_length==Integer.MAX_VALUE){\\n            return 0;\\n        }else{\\n            return min_length;\\n        }\\n    }\\n\\n\\n\\nif this is n^2 why isnt it accepted?"
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "I had a test case were all the nums were even but the target is odd, so the output should be 0, but it said the expected outcome is 4."
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "Yes, of course it can be greater than the target, so a case of me not reading the question properly. A good lesson relearned.\\nIt is a trickier problem if the sum has to be equal to the target. All testcases pass even when you just go for the exact target."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you can take  subarray that gives the sum greater than target and have minimum length"
                    },
                    {
                        "username": "nagasundaram373",
                        "content": " `class Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int ans=Integer.MAX_VALUE;\\n        int sum=0;\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            count++;\\n            if(target==sum){\\n                sum=0;\\n                ans=Math.min(ans,count);\\n                count=0;\\n            }\\n           \\n        }\\n        return ans==Integer.MAX_VALUE ? 0 :ans;\\n        \\n    }\\n}`\\n what is wrong in this code\\n"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "The condition if (target == sum) is incorrect because it is checking if the current sum is equal to the target. Instead, it should check if the current sum is greater than or equal to the target.\\n\\nuse :\\nwhile (sum >= target) {\\n                ans = Math.min(ans, count);\\n                sum -= A[i - count + 1];\\n                count--;\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once you get your sum euqal Target  you are setting the sum =0 which will give the wrong answer  you just need to subtract the initial elements of subarray until sum becomes less than Target again so you can count all subarray. And get the minimum   subarray lengths \nYou can check the solution here https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3094090/c-simple-solutions-2-solutions/"
                    },
                    {
                        "username": "DanielaYamashita",
                        "content": "It is strange, in the test case below:\\n\\ntarge = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\n\\nI got 7 as the smallest combination length, which is [28, 83, 4, 25, 26, 25, 25]. However, the expected result is 8. Does someone know what is wrong ?"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "A subarray is a contiguous non-empty sequence of elements within an array."
                    },
                    {
                        "username": "hemanth_12",
                        "content": "the question itself wrong i also got same error but if you try continious subarray it will work"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@DanielaYamashita](/DanielaYamashita) I think you missed 2 (index 7)."
                    },
                    {
                        "username": "l227874",
                        "content": "dsdsdsdsd"
                    },
                    {
                        "username": "Tediyang",
                        "content": "testcase 19: 10^5 is giving me serious runtime error.\\n"
                    },
                    {
                        "username": "luke_py",
                        "content": "I watched a video on sliding window algorithm this morning, and this turns out to be the daily problem today. what a coincidence lol :)"
                    },
                    {
                        "username": "sarthakr10",
                        "content": "my solution in not correct for 19th test case i.e. {2,3,1,1,1,1,1}. , target = 5. output should be 2 my is 3......rest all test case are solved please see where I am getting it wrong....\\n class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minlength = n +1;\\n        int start = 0 , end = 0,sum = 0;\\n        while(end < n){\\n            while(end< n && sum <= target){\\n                sum += nums[end++];\\n            }\\n            while(sum >= target && start < n){\\n                if(end - start < minlength){\\n                    minlength = end -start;\\n                }\\n                sum -= nums[start++];\\n            }\\n\\n        }\\n        if(minlength >= n+1){\\n            return 0;\\n        }\\n        return minlength;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1959255,
                "content": [
                    {
                        "username": "TwilightTraveler",
                        "content": "Wow, I spent so long doing this program and wondering why the test case \"2, 16, 14, 15\" -> 2 wasn\\'t working. And then I realized, it said Greater or equal, I thought it was only equal to. This problem is super simple for greater than."
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "Question includes in binary search but arr not sorted!!!!  But whenever I try to solve this using binary search after sorting the array, then it violates the question\\'s rule..... can anyone help me to solve this puzzle?? \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is more of a sliding window problem than a binary search problem."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": " public int minSubArrayLen(int target, int[] nums) {\\n        int min_length=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int sum=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(i!=j){\\n                    sum+=+nums[j];\\n                    if(sum>=target){\\n                        min_length=Math.min(min_length, j-i+1);\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[i]>=target){\\n                        min_length=1;\\n                        return min_length;\\n                    }\\n                }\\n            }\\n            sum=0;\\n        }\\n\\n        if(min_length==Integer.MAX_VALUE){\\n            return 0;\\n        }else{\\n            return min_length;\\n        }\\n    }\\n\\n\\n\\nif this is n^2 why isnt it accepted?"
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "I had a test case were all the nums were even but the target is odd, so the output should be 0, but it said the expected outcome is 4."
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "Yes, of course it can be greater than the target, so a case of me not reading the question properly. A good lesson relearned.\\nIt is a trickier problem if the sum has to be equal to the target. All testcases pass even when you just go for the exact target."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you can take  subarray that gives the sum greater than target and have minimum length"
                    },
                    {
                        "username": "nagasundaram373",
                        "content": " `class Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int ans=Integer.MAX_VALUE;\\n        int sum=0;\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            count++;\\n            if(target==sum){\\n                sum=0;\\n                ans=Math.min(ans,count);\\n                count=0;\\n            }\\n           \\n        }\\n        return ans==Integer.MAX_VALUE ? 0 :ans;\\n        \\n    }\\n}`\\n what is wrong in this code\\n"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "The condition if (target == sum) is incorrect because it is checking if the current sum is equal to the target. Instead, it should check if the current sum is greater than or equal to the target.\\n\\nuse :\\nwhile (sum >= target) {\\n                ans = Math.min(ans, count);\\n                sum -= A[i - count + 1];\\n                count--;\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once you get your sum euqal Target  you are setting the sum =0 which will give the wrong answer  you just need to subtract the initial elements of subarray until sum becomes less than Target again so you can count all subarray. And get the minimum   subarray lengths \nYou can check the solution here https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3094090/c-simple-solutions-2-solutions/"
                    },
                    {
                        "username": "DanielaYamashita",
                        "content": "It is strange, in the test case below:\\n\\ntarge = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\n\\nI got 7 as the smallest combination length, which is [28, 83, 4, 25, 26, 25, 25]. However, the expected result is 8. Does someone know what is wrong ?"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "A subarray is a contiguous non-empty sequence of elements within an array."
                    },
                    {
                        "username": "hemanth_12",
                        "content": "the question itself wrong i also got same error but if you try continious subarray it will work"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@DanielaYamashita](/DanielaYamashita) I think you missed 2 (index 7)."
                    },
                    {
                        "username": "l227874",
                        "content": "dsdsdsdsd"
                    },
                    {
                        "username": "Tediyang",
                        "content": "testcase 19: 10^5 is giving me serious runtime error.\\n"
                    },
                    {
                        "username": "luke_py",
                        "content": "I watched a video on sliding window algorithm this morning, and this turns out to be the daily problem today. what a coincidence lol :)"
                    },
                    {
                        "username": "sarthakr10",
                        "content": "my solution in not correct for 19th test case i.e. {2,3,1,1,1,1,1}. , target = 5. output should be 2 my is 3......rest all test case are solved please see where I am getting it wrong....\\n class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minlength = n +1;\\n        int start = 0 , end = 0,sum = 0;\\n        while(end < n){\\n            while(end< n && sum <= target){\\n                sum += nums[end++];\\n            }\\n            while(sum >= target && start < n){\\n                if(end - start < minlength){\\n                    minlength = end -start;\\n                }\\n                sum -= nums[start++];\\n            }\\n\\n        }\\n        if(minlength >= n+1){\\n            return 0;\\n        }\\n        return minlength;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1959181,
                "content": [
                    {
                        "username": "TwilightTraveler",
                        "content": "Wow, I spent so long doing this program and wondering why the test case \"2, 16, 14, 15\" -> 2 wasn\\'t working. And then I realized, it said Greater or equal, I thought it was only equal to. This problem is super simple for greater than."
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "Question includes in binary search but arr not sorted!!!!  But whenever I try to solve this using binary search after sorting the array, then it violates the question\\'s rule..... can anyone help me to solve this puzzle?? \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is more of a sliding window problem than a binary search problem."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": " public int minSubArrayLen(int target, int[] nums) {\\n        int min_length=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int sum=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(i!=j){\\n                    sum+=+nums[j];\\n                    if(sum>=target){\\n                        min_length=Math.min(min_length, j-i+1);\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[i]>=target){\\n                        min_length=1;\\n                        return min_length;\\n                    }\\n                }\\n            }\\n            sum=0;\\n        }\\n\\n        if(min_length==Integer.MAX_VALUE){\\n            return 0;\\n        }else{\\n            return min_length;\\n        }\\n    }\\n\\n\\n\\nif this is n^2 why isnt it accepted?"
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "I had a test case were all the nums were even but the target is odd, so the output should be 0, but it said the expected outcome is 4."
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "Yes, of course it can be greater than the target, so a case of me not reading the question properly. A good lesson relearned.\\nIt is a trickier problem if the sum has to be equal to the target. All testcases pass even when you just go for the exact target."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you can take  subarray that gives the sum greater than target and have minimum length"
                    },
                    {
                        "username": "nagasundaram373",
                        "content": " `class Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int ans=Integer.MAX_VALUE;\\n        int sum=0;\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            count++;\\n            if(target==sum){\\n                sum=0;\\n                ans=Math.min(ans,count);\\n                count=0;\\n            }\\n           \\n        }\\n        return ans==Integer.MAX_VALUE ? 0 :ans;\\n        \\n    }\\n}`\\n what is wrong in this code\\n"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "The condition if (target == sum) is incorrect because it is checking if the current sum is equal to the target. Instead, it should check if the current sum is greater than or equal to the target.\\n\\nuse :\\nwhile (sum >= target) {\\n                ans = Math.min(ans, count);\\n                sum -= A[i - count + 1];\\n                count--;\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once you get your sum euqal Target  you are setting the sum =0 which will give the wrong answer  you just need to subtract the initial elements of subarray until sum becomes less than Target again so you can count all subarray. And get the minimum   subarray lengths \nYou can check the solution here https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3094090/c-simple-solutions-2-solutions/"
                    },
                    {
                        "username": "DanielaYamashita",
                        "content": "It is strange, in the test case below:\\n\\ntarge = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\n\\nI got 7 as the smallest combination length, which is [28, 83, 4, 25, 26, 25, 25]. However, the expected result is 8. Does someone know what is wrong ?"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "A subarray is a contiguous non-empty sequence of elements within an array."
                    },
                    {
                        "username": "hemanth_12",
                        "content": "the question itself wrong i also got same error but if you try continious subarray it will work"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@DanielaYamashita](/DanielaYamashita) I think you missed 2 (index 7)."
                    },
                    {
                        "username": "l227874",
                        "content": "dsdsdsdsd"
                    },
                    {
                        "username": "Tediyang",
                        "content": "testcase 19: 10^5 is giving me serious runtime error.\\n"
                    },
                    {
                        "username": "luke_py",
                        "content": "I watched a video on sliding window algorithm this morning, and this turns out to be the daily problem today. what a coincidence lol :)"
                    },
                    {
                        "username": "sarthakr10",
                        "content": "my solution in not correct for 19th test case i.e. {2,3,1,1,1,1,1}. , target = 5. output should be 2 my is 3......rest all test case are solved please see where I am getting it wrong....\\n class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minlength = n +1;\\n        int start = 0 , end = 0,sum = 0;\\n        while(end < n){\\n            while(end< n && sum <= target){\\n                sum += nums[end++];\\n            }\\n            while(sum >= target && start < n){\\n                if(end - start < minlength){\\n                    minlength = end -start;\\n                }\\n                sum -= nums[start++];\\n            }\\n\\n        }\\n        if(minlength >= n+1){\\n            return 0;\\n        }\\n        return minlength;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1959121,
                "content": [
                    {
                        "username": "TwilightTraveler",
                        "content": "Wow, I spent so long doing this program and wondering why the test case \"2, 16, 14, 15\" -> 2 wasn\\'t working. And then I realized, it said Greater or equal, I thought it was only equal to. This problem is super simple for greater than."
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "Question includes in binary search but arr not sorted!!!!  But whenever I try to solve this using binary search after sorting the array, then it violates the question\\'s rule..... can anyone help me to solve this puzzle?? \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is more of a sliding window problem than a binary search problem."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": " public int minSubArrayLen(int target, int[] nums) {\\n        int min_length=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int sum=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(i!=j){\\n                    sum+=+nums[j];\\n                    if(sum>=target){\\n                        min_length=Math.min(min_length, j-i+1);\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[i]>=target){\\n                        min_length=1;\\n                        return min_length;\\n                    }\\n                }\\n            }\\n            sum=0;\\n        }\\n\\n        if(min_length==Integer.MAX_VALUE){\\n            return 0;\\n        }else{\\n            return min_length;\\n        }\\n    }\\n\\n\\n\\nif this is n^2 why isnt it accepted?"
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "I had a test case were all the nums were even but the target is odd, so the output should be 0, but it said the expected outcome is 4."
                    },
                    {
                        "username": "aaronhurley777",
                        "content": "Yes, of course it can be greater than the target, so a case of me not reading the question properly. A good lesson relearned.\\nIt is a trickier problem if the sum has to be equal to the target. All testcases pass even when you just go for the exact target."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you can take  subarray that gives the sum greater than target and have minimum length"
                    },
                    {
                        "username": "nagasundaram373",
                        "content": " `class Solution {\\n    public int minSubArrayLen(int target, int[] A) {\\n        int ans=Integer.MAX_VALUE;\\n        int sum=0;\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            count++;\\n            if(target==sum){\\n                sum=0;\\n                ans=Math.min(ans,count);\\n                count=0;\\n            }\\n           \\n        }\\n        return ans==Integer.MAX_VALUE ? 0 :ans;\\n        \\n    }\\n}`\\n what is wrong in this code\\n"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "The condition if (target == sum) is incorrect because it is checking if the current sum is equal to the target. Instead, it should check if the current sum is greater than or equal to the target.\\n\\nuse :\\nwhile (sum >= target) {\\n                ans = Math.min(ans, count);\\n                sum -= A[i - count + 1];\\n                count--;\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Once you get your sum euqal Target  you are setting the sum =0 which will give the wrong answer  you just need to subtract the initial elements of subarray until sum becomes less than Target again so you can count all subarray. And get the minimum   subarray lengths \nYou can check the solution here https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3094090/c-simple-solutions-2-solutions/"
                    },
                    {
                        "username": "DanielaYamashita",
                        "content": "It is strange, in the test case below:\\n\\ntarge = 213\\nnums = [12,28,83,4,25,26,25,2,25,25,25,12]\\n\\nI got 7 as the smallest combination length, which is [28, 83, 4, 25, 26, 25, 25]. However, the expected result is 8. Does someone know what is wrong ?"
                    },
                    {
                        "username": "ImmortalMerlin",
                        "content": "A subarray is a contiguous non-empty sequence of elements within an array."
                    },
                    {
                        "username": "hemanth_12",
                        "content": "the question itself wrong i also got same error but if you try continious subarray it will work"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@DanielaYamashita](/DanielaYamashita) I think you missed 2 (index 7)."
                    },
                    {
                        "username": "l227874",
                        "content": "dsdsdsdsd"
                    },
                    {
                        "username": "Tediyang",
                        "content": "testcase 19: 10^5 is giving me serious runtime error.\\n"
                    },
                    {
                        "username": "luke_py",
                        "content": "I watched a video on sliding window algorithm this morning, and this turns out to be the daily problem today. what a coincidence lol :)"
                    },
                    {
                        "username": "sarthakr10",
                        "content": "my solution in not correct for 19th test case i.e. {2,3,1,1,1,1,1}. , target = 5. output should be 2 my is 3......rest all test case are solved please see where I am getting it wrong....\\n class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int minlength = n +1;\\n        int start = 0 , end = 0,sum = 0;\\n        while(end < n){\\n            while(end< n && sum <= target){\\n                sum += nums[end++];\\n            }\\n            while(sum >= target && start < n){\\n                if(end - start < minlength){\\n                    minlength = end -start;\\n                }\\n                sum -= nums[start++];\\n            }\\n\\n        }\\n        if(minlength >= n+1){\\n            return 0;\\n        }\\n        return minlength;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1959076,
                "content": [
                    {
                        "username": "Anshika_0924",
                        "content": "Can anyone explain how the sliding window approach has O(N) complexity?\\n"
                    },
                    {
                        "username": "Megir",
                        "content": "Help please with testcase 13:\\ntarget = 20\\nnums = [2,16,14,15]\\nwhy answer is 2 instead of 0?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "actual mentioning : Return the minimal length of a subarray whose sum is *greater than or equal* to target."
                    },
                    {
                        "username": "nightfury_69",
                        "content": "I am getting minimal output but expected is showing wrong"
                    },
                    {
                        "username": "rahul_siddhu",
                        "content": "I am gettingg wrong answer on 19th test case my code is giving output 131 but the correct answer is 132, below is my code please tell where is the problem. Thank you.\\n    [my code](https://leetcode.com/problems/minimum-size-subarray-sum/submissions/987924946/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code lies in the second while loop where you\\'re decrementing the window and sum without ensuring that the index \\'i\\' is within the valid range. Also, you are subtracting `nums[i]` from `sum` after incrementing `i`, which could potentially lead to incorrect results. \\n\\nTry adjusting the code as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int len = 0, ans = INT_MAX, i = 0, j = 0, sum = 0, n = nums.size();\\n        while(j < n){\\n            sum += nums[j];\\n            len++;\\n            j++;\\n\\n            while(sum >= target){\\n                ans = min(ans, len);\\n                sum -= nums[i];\\n                i++;\\n                len--;\\n            }\\n        }\\n        return (ans == INT_MAX) ? 0 : ans;\\n    }\\n};\\n```\\n\\nHere\\'s what\\'s changed:\\n\\n1. The second while loop is now checking `sum >= target` instead of `sum-nums[i] >= target`. We\\'re still sliding the window to the right when the total is greater than or equal to the target.\\n\\n2. Inside the second while loop, `sum -= nums[i];` is now before `i++;` ensuring that we\\'re decrementing the sum by the correct amount.\\n\\n3. The final return statement is adjusted to handle the case where no subarray sums to the target. If no such subarray is found, `ans` will remain at its initial value of `INT_MAX`, and the function should return 0."
                    },
                    {
                        "username": "iamprobablycoding",
                        "content": "Finally my noob brain got a little dopamine hit solving this."
                    },
                    {
                        "username": "theNikhilP",
                        "content": "Can anyone tell me what\\'s wrong in my code\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target, int i) {\\n        if (target <= 0) {\\n            return 0;\\n        }\\n\\n        if (i >= nums.size()) {\\n            return INT_MAX/2;\\n        }\\n\\n        int l1 = 1 + helper(nums, target - nums[i], i + 1);\\n        int l2 = helper(nums, target, i + 1);\\n        return min(l1, l2);\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int x = helper(nums, target, 0);\\n        if (x >= INT_MAX/2) {\\n            return 0;\\n        }\\n\\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted appears to be attempting a recursive approach to solving the problem. The helper function is trying to explore all possible subarrays by recursively reducing the target by the value of the current element (l1), and moving to the next element, or skipping the current element and moving to the next one (l2). Then it chooses the smaller length subarray between the two.\\n\\nHowever, this approach doesn\\'t fit the problem for two reasons:\\n\\n1. It does not preserve the order of the array elements: The problem statement specifies that you need to find the smallest contiguous subarray that sums to at least the target value. Contiguous means the elements are in their original order in the array. However, the recursive approach you\\'re using can mix up the order of the elements, as it\\'s effectively trying all combinations of elements, not just contiguous subarrays.\\n\\n2. It\\'s inefficient: The time complexity of this approach is O(2^n), where n is the number of elements in the array. This is because each recursive call branches into two new recursive calls, leading to an exponential number of total function calls. This could cause your program to run very slowly, or even exceed the time limit, for larger input arrays.\\n\\nYou might want to reconsider your approach and consider using a technique like a sliding window or prefix sum which can solve this problem with a time complexity of O(n)."
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "Solution using sliding window \\u2705\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/solutions/3727421/sliding-window-solution/"
                    },
                    {
                        "username": "layyy",
                        "content": "keep a window of sum>=target and track its size"
                    },
                    {
                        "username": "patrickson1997",
                        "content": "How is this a sliding window problem? The window length can be anything and is not fixed."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, the window size does not always have to be fixed. What\\'s more important is that there is a contiguous subarray, or a \"window,\" that you\\'re considering at any given time.\\n\\nIn this particular problem, the \"window\" refers to a contiguous subarray of the original array. The goal is to find the shortest such subarray that has a sum greater than or equal to a target value.\\n\\nYou start by initializing a window at the beginning of the array and continue to expand it (by moving the end of the window to the right) as long as the sum of the elements in the window is less than the target. When the sum is greater than or equal to the target, you attempt to contract the window (by moving the start of the window to the right) while ensuring the sum still remains greater than or equal to the target. \\n\\nIn this way, the window \"slides\" through the array, and its size dynamically changes depending on the specific values in the array and their sum relative to the target. Therefore, this problem is categorized as a sliding window problem."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "For nlogn, apply bs on fixed sized window!"
                    }
                ]
            },
            {
                "id": 1959052,
                "content": [
                    {
                        "username": "Anshika_0924",
                        "content": "Can anyone explain how the sliding window approach has O(N) complexity?\\n"
                    },
                    {
                        "username": "Megir",
                        "content": "Help please with testcase 13:\\ntarget = 20\\nnums = [2,16,14,15]\\nwhy answer is 2 instead of 0?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "actual mentioning : Return the minimal length of a subarray whose sum is *greater than or equal* to target."
                    },
                    {
                        "username": "nightfury_69",
                        "content": "I am getting minimal output but expected is showing wrong"
                    },
                    {
                        "username": "rahul_siddhu",
                        "content": "I am gettingg wrong answer on 19th test case my code is giving output 131 but the correct answer is 132, below is my code please tell where is the problem. Thank you.\\n    [my code](https://leetcode.com/problems/minimum-size-subarray-sum/submissions/987924946/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code lies in the second while loop where you\\'re decrementing the window and sum without ensuring that the index \\'i\\' is within the valid range. Also, you are subtracting `nums[i]` from `sum` after incrementing `i`, which could potentially lead to incorrect results. \\n\\nTry adjusting the code as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int len = 0, ans = INT_MAX, i = 0, j = 0, sum = 0, n = nums.size();\\n        while(j < n){\\n            sum += nums[j];\\n            len++;\\n            j++;\\n\\n            while(sum >= target){\\n                ans = min(ans, len);\\n                sum -= nums[i];\\n                i++;\\n                len--;\\n            }\\n        }\\n        return (ans == INT_MAX) ? 0 : ans;\\n    }\\n};\\n```\\n\\nHere\\'s what\\'s changed:\\n\\n1. The second while loop is now checking `sum >= target` instead of `sum-nums[i] >= target`. We\\'re still sliding the window to the right when the total is greater than or equal to the target.\\n\\n2. Inside the second while loop, `sum -= nums[i];` is now before `i++;` ensuring that we\\'re decrementing the sum by the correct amount.\\n\\n3. The final return statement is adjusted to handle the case where no subarray sums to the target. If no such subarray is found, `ans` will remain at its initial value of `INT_MAX`, and the function should return 0."
                    },
                    {
                        "username": "iamprobablycoding",
                        "content": "Finally my noob brain got a little dopamine hit solving this."
                    },
                    {
                        "username": "theNikhilP",
                        "content": "Can anyone tell me what\\'s wrong in my code\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target, int i) {\\n        if (target <= 0) {\\n            return 0;\\n        }\\n\\n        if (i >= nums.size()) {\\n            return INT_MAX/2;\\n        }\\n\\n        int l1 = 1 + helper(nums, target - nums[i], i + 1);\\n        int l2 = helper(nums, target, i + 1);\\n        return min(l1, l2);\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int x = helper(nums, target, 0);\\n        if (x >= INT_MAX/2) {\\n            return 0;\\n        }\\n\\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted appears to be attempting a recursive approach to solving the problem. The helper function is trying to explore all possible subarrays by recursively reducing the target by the value of the current element (l1), and moving to the next element, or skipping the current element and moving to the next one (l2). Then it chooses the smaller length subarray between the two.\\n\\nHowever, this approach doesn\\'t fit the problem for two reasons:\\n\\n1. It does not preserve the order of the array elements: The problem statement specifies that you need to find the smallest contiguous subarray that sums to at least the target value. Contiguous means the elements are in their original order in the array. However, the recursive approach you\\'re using can mix up the order of the elements, as it\\'s effectively trying all combinations of elements, not just contiguous subarrays.\\n\\n2. It\\'s inefficient: The time complexity of this approach is O(2^n), where n is the number of elements in the array. This is because each recursive call branches into two new recursive calls, leading to an exponential number of total function calls. This could cause your program to run very slowly, or even exceed the time limit, for larger input arrays.\\n\\nYou might want to reconsider your approach and consider using a technique like a sliding window or prefix sum which can solve this problem with a time complexity of O(n)."
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "Solution using sliding window \\u2705\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/solutions/3727421/sliding-window-solution/"
                    },
                    {
                        "username": "layyy",
                        "content": "keep a window of sum>=target and track its size"
                    },
                    {
                        "username": "patrickson1997",
                        "content": "How is this a sliding window problem? The window length can be anything and is not fixed."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, the window size does not always have to be fixed. What\\'s more important is that there is a contiguous subarray, or a \"window,\" that you\\'re considering at any given time.\\n\\nIn this particular problem, the \"window\" refers to a contiguous subarray of the original array. The goal is to find the shortest such subarray that has a sum greater than or equal to a target value.\\n\\nYou start by initializing a window at the beginning of the array and continue to expand it (by moving the end of the window to the right) as long as the sum of the elements in the window is less than the target. When the sum is greater than or equal to the target, you attempt to contract the window (by moving the start of the window to the right) while ensuring the sum still remains greater than or equal to the target. \\n\\nIn this way, the window \"slides\" through the array, and its size dynamically changes depending on the specific values in the array and their sum relative to the target. Therefore, this problem is categorized as a sliding window problem."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "For nlogn, apply bs on fixed sized window!"
                    }
                ]
            },
            {
                "id": 1959014,
                "content": [
                    {
                        "username": "Anshika_0924",
                        "content": "Can anyone explain how the sliding window approach has O(N) complexity?\\n"
                    },
                    {
                        "username": "Megir",
                        "content": "Help please with testcase 13:\\ntarget = 20\\nnums = [2,16,14,15]\\nwhy answer is 2 instead of 0?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "actual mentioning : Return the minimal length of a subarray whose sum is *greater than or equal* to target."
                    },
                    {
                        "username": "nightfury_69",
                        "content": "I am getting minimal output but expected is showing wrong"
                    },
                    {
                        "username": "rahul_siddhu",
                        "content": "I am gettingg wrong answer on 19th test case my code is giving output 131 but the correct answer is 132, below is my code please tell where is the problem. Thank you.\\n    [my code](https://leetcode.com/problems/minimum-size-subarray-sum/submissions/987924946/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code lies in the second while loop where you\\'re decrementing the window and sum without ensuring that the index \\'i\\' is within the valid range. Also, you are subtracting `nums[i]` from `sum` after incrementing `i`, which could potentially lead to incorrect results. \\n\\nTry adjusting the code as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int len = 0, ans = INT_MAX, i = 0, j = 0, sum = 0, n = nums.size();\\n        while(j < n){\\n            sum += nums[j];\\n            len++;\\n            j++;\\n\\n            while(sum >= target){\\n                ans = min(ans, len);\\n                sum -= nums[i];\\n                i++;\\n                len--;\\n            }\\n        }\\n        return (ans == INT_MAX) ? 0 : ans;\\n    }\\n};\\n```\\n\\nHere\\'s what\\'s changed:\\n\\n1. The second while loop is now checking `sum >= target` instead of `sum-nums[i] >= target`. We\\'re still sliding the window to the right when the total is greater than or equal to the target.\\n\\n2. Inside the second while loop, `sum -= nums[i];` is now before `i++;` ensuring that we\\'re decrementing the sum by the correct amount.\\n\\n3. The final return statement is adjusted to handle the case where no subarray sums to the target. If no such subarray is found, `ans` will remain at its initial value of `INT_MAX`, and the function should return 0."
                    },
                    {
                        "username": "iamprobablycoding",
                        "content": "Finally my noob brain got a little dopamine hit solving this."
                    },
                    {
                        "username": "theNikhilP",
                        "content": "Can anyone tell me what\\'s wrong in my code\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target, int i) {\\n        if (target <= 0) {\\n            return 0;\\n        }\\n\\n        if (i >= nums.size()) {\\n            return INT_MAX/2;\\n        }\\n\\n        int l1 = 1 + helper(nums, target - nums[i], i + 1);\\n        int l2 = helper(nums, target, i + 1);\\n        return min(l1, l2);\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int x = helper(nums, target, 0);\\n        if (x >= INT_MAX/2) {\\n            return 0;\\n        }\\n\\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted appears to be attempting a recursive approach to solving the problem. The helper function is trying to explore all possible subarrays by recursively reducing the target by the value of the current element (l1), and moving to the next element, or skipping the current element and moving to the next one (l2). Then it chooses the smaller length subarray between the two.\\n\\nHowever, this approach doesn\\'t fit the problem for two reasons:\\n\\n1. It does not preserve the order of the array elements: The problem statement specifies that you need to find the smallest contiguous subarray that sums to at least the target value. Contiguous means the elements are in their original order in the array. However, the recursive approach you\\'re using can mix up the order of the elements, as it\\'s effectively trying all combinations of elements, not just contiguous subarrays.\\n\\n2. It\\'s inefficient: The time complexity of this approach is O(2^n), where n is the number of elements in the array. This is because each recursive call branches into two new recursive calls, leading to an exponential number of total function calls. This could cause your program to run very slowly, or even exceed the time limit, for larger input arrays.\\n\\nYou might want to reconsider your approach and consider using a technique like a sliding window or prefix sum which can solve this problem with a time complexity of O(n)."
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "Solution using sliding window \\u2705\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/solutions/3727421/sliding-window-solution/"
                    },
                    {
                        "username": "layyy",
                        "content": "keep a window of sum>=target and track its size"
                    },
                    {
                        "username": "patrickson1997",
                        "content": "How is this a sliding window problem? The window length can be anything and is not fixed."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, the window size does not always have to be fixed. What\\'s more important is that there is a contiguous subarray, or a \"window,\" that you\\'re considering at any given time.\\n\\nIn this particular problem, the \"window\" refers to a contiguous subarray of the original array. The goal is to find the shortest such subarray that has a sum greater than or equal to a target value.\\n\\nYou start by initializing a window at the beginning of the array and continue to expand it (by moving the end of the window to the right) as long as the sum of the elements in the window is less than the target. When the sum is greater than or equal to the target, you attempt to contract the window (by moving the start of the window to the right) while ensuring the sum still remains greater than or equal to the target. \\n\\nIn this way, the window \"slides\" through the array, and its size dynamically changes depending on the specific values in the array and their sum relative to the target. Therefore, this problem is categorized as a sliding window problem."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "For nlogn, apply bs on fixed sized window!"
                    }
                ]
            },
            {
                "id": 1958992,
                "content": [
                    {
                        "username": "Anshika_0924",
                        "content": "Can anyone explain how the sliding window approach has O(N) complexity?\\n"
                    },
                    {
                        "username": "Megir",
                        "content": "Help please with testcase 13:\\ntarget = 20\\nnums = [2,16,14,15]\\nwhy answer is 2 instead of 0?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "actual mentioning : Return the minimal length of a subarray whose sum is *greater than or equal* to target."
                    },
                    {
                        "username": "nightfury_69",
                        "content": "I am getting minimal output but expected is showing wrong"
                    },
                    {
                        "username": "rahul_siddhu",
                        "content": "I am gettingg wrong answer on 19th test case my code is giving output 131 but the correct answer is 132, below is my code please tell where is the problem. Thank you.\\n    [my code](https://leetcode.com/problems/minimum-size-subarray-sum/submissions/987924946/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code lies in the second while loop where you\\'re decrementing the window and sum without ensuring that the index \\'i\\' is within the valid range. Also, you are subtracting `nums[i]` from `sum` after incrementing `i`, which could potentially lead to incorrect results. \\n\\nTry adjusting the code as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int len = 0, ans = INT_MAX, i = 0, j = 0, sum = 0, n = nums.size();\\n        while(j < n){\\n            sum += nums[j];\\n            len++;\\n            j++;\\n\\n            while(sum >= target){\\n                ans = min(ans, len);\\n                sum -= nums[i];\\n                i++;\\n                len--;\\n            }\\n        }\\n        return (ans == INT_MAX) ? 0 : ans;\\n    }\\n};\\n```\\n\\nHere\\'s what\\'s changed:\\n\\n1. The second while loop is now checking `sum >= target` instead of `sum-nums[i] >= target`. We\\'re still sliding the window to the right when the total is greater than or equal to the target.\\n\\n2. Inside the second while loop, `sum -= nums[i];` is now before `i++;` ensuring that we\\'re decrementing the sum by the correct amount.\\n\\n3. The final return statement is adjusted to handle the case where no subarray sums to the target. If no such subarray is found, `ans` will remain at its initial value of `INT_MAX`, and the function should return 0."
                    },
                    {
                        "username": "iamprobablycoding",
                        "content": "Finally my noob brain got a little dopamine hit solving this."
                    },
                    {
                        "username": "theNikhilP",
                        "content": "Can anyone tell me what\\'s wrong in my code\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target, int i) {\\n        if (target <= 0) {\\n            return 0;\\n        }\\n\\n        if (i >= nums.size()) {\\n            return INT_MAX/2;\\n        }\\n\\n        int l1 = 1 + helper(nums, target - nums[i], i + 1);\\n        int l2 = helper(nums, target, i + 1);\\n        return min(l1, l2);\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int x = helper(nums, target, 0);\\n        if (x >= INT_MAX/2) {\\n            return 0;\\n        }\\n\\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted appears to be attempting a recursive approach to solving the problem. The helper function is trying to explore all possible subarrays by recursively reducing the target by the value of the current element (l1), and moving to the next element, or skipping the current element and moving to the next one (l2). Then it chooses the smaller length subarray between the two.\\n\\nHowever, this approach doesn\\'t fit the problem for two reasons:\\n\\n1. It does not preserve the order of the array elements: The problem statement specifies that you need to find the smallest contiguous subarray that sums to at least the target value. Contiguous means the elements are in their original order in the array. However, the recursive approach you\\'re using can mix up the order of the elements, as it\\'s effectively trying all combinations of elements, not just contiguous subarrays.\\n\\n2. It\\'s inefficient: The time complexity of this approach is O(2^n), where n is the number of elements in the array. This is because each recursive call branches into two new recursive calls, leading to an exponential number of total function calls. This could cause your program to run very slowly, or even exceed the time limit, for larger input arrays.\\n\\nYou might want to reconsider your approach and consider using a technique like a sliding window or prefix sum which can solve this problem with a time complexity of O(n)."
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "Solution using sliding window \\u2705\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/solutions/3727421/sliding-window-solution/"
                    },
                    {
                        "username": "layyy",
                        "content": "keep a window of sum>=target and track its size"
                    },
                    {
                        "username": "patrickson1997",
                        "content": "How is this a sliding window problem? The window length can be anything and is not fixed."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, the window size does not always have to be fixed. What\\'s more important is that there is a contiguous subarray, or a \"window,\" that you\\'re considering at any given time.\\n\\nIn this particular problem, the \"window\" refers to a contiguous subarray of the original array. The goal is to find the shortest such subarray that has a sum greater than or equal to a target value.\\n\\nYou start by initializing a window at the beginning of the array and continue to expand it (by moving the end of the window to the right) as long as the sum of the elements in the window is less than the target. When the sum is greater than or equal to the target, you attempt to contract the window (by moving the start of the window to the right) while ensuring the sum still remains greater than or equal to the target. \\n\\nIn this way, the window \"slides\" through the array, and its size dynamically changes depending on the specific values in the array and their sum relative to the target. Therefore, this problem is categorized as a sliding window problem."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "For nlogn, apply bs on fixed sized window!"
                    }
                ]
            },
            {
                "id": 1958978,
                "content": [
                    {
                        "username": "Anshika_0924",
                        "content": "Can anyone explain how the sliding window approach has O(N) complexity?\\n"
                    },
                    {
                        "username": "Megir",
                        "content": "Help please with testcase 13:\\ntarget = 20\\nnums = [2,16,14,15]\\nwhy answer is 2 instead of 0?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "actual mentioning : Return the minimal length of a subarray whose sum is *greater than or equal* to target."
                    },
                    {
                        "username": "nightfury_69",
                        "content": "I am getting minimal output but expected is showing wrong"
                    },
                    {
                        "username": "rahul_siddhu",
                        "content": "I am gettingg wrong answer on 19th test case my code is giving output 131 but the correct answer is 132, below is my code please tell where is the problem. Thank you.\\n    [my code](https://leetcode.com/problems/minimum-size-subarray-sum/submissions/987924946/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code lies in the second while loop where you\\'re decrementing the window and sum without ensuring that the index \\'i\\' is within the valid range. Also, you are subtracting `nums[i]` from `sum` after incrementing `i`, which could potentially lead to incorrect results. \\n\\nTry adjusting the code as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int len = 0, ans = INT_MAX, i = 0, j = 0, sum = 0, n = nums.size();\\n        while(j < n){\\n            sum += nums[j];\\n            len++;\\n            j++;\\n\\n            while(sum >= target){\\n                ans = min(ans, len);\\n                sum -= nums[i];\\n                i++;\\n                len--;\\n            }\\n        }\\n        return (ans == INT_MAX) ? 0 : ans;\\n    }\\n};\\n```\\n\\nHere\\'s what\\'s changed:\\n\\n1. The second while loop is now checking `sum >= target` instead of `sum-nums[i] >= target`. We\\'re still sliding the window to the right when the total is greater than or equal to the target.\\n\\n2. Inside the second while loop, `sum -= nums[i];` is now before `i++;` ensuring that we\\'re decrementing the sum by the correct amount.\\n\\n3. The final return statement is adjusted to handle the case where no subarray sums to the target. If no such subarray is found, `ans` will remain at its initial value of `INT_MAX`, and the function should return 0."
                    },
                    {
                        "username": "iamprobablycoding",
                        "content": "Finally my noob brain got a little dopamine hit solving this."
                    },
                    {
                        "username": "theNikhilP",
                        "content": "Can anyone tell me what\\'s wrong in my code\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target, int i) {\\n        if (target <= 0) {\\n            return 0;\\n        }\\n\\n        if (i >= nums.size()) {\\n            return INT_MAX/2;\\n        }\\n\\n        int l1 = 1 + helper(nums, target - nums[i], i + 1);\\n        int l2 = helper(nums, target, i + 1);\\n        return min(l1, l2);\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int x = helper(nums, target, 0);\\n        if (x >= INT_MAX/2) {\\n            return 0;\\n        }\\n\\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted appears to be attempting a recursive approach to solving the problem. The helper function is trying to explore all possible subarrays by recursively reducing the target by the value of the current element (l1), and moving to the next element, or skipping the current element and moving to the next one (l2). Then it chooses the smaller length subarray between the two.\\n\\nHowever, this approach doesn\\'t fit the problem for two reasons:\\n\\n1. It does not preserve the order of the array elements: The problem statement specifies that you need to find the smallest contiguous subarray that sums to at least the target value. Contiguous means the elements are in their original order in the array. However, the recursive approach you\\'re using can mix up the order of the elements, as it\\'s effectively trying all combinations of elements, not just contiguous subarrays.\\n\\n2. It\\'s inefficient: The time complexity of this approach is O(2^n), where n is the number of elements in the array. This is because each recursive call branches into two new recursive calls, leading to an exponential number of total function calls. This could cause your program to run very slowly, or even exceed the time limit, for larger input arrays.\\n\\nYou might want to reconsider your approach and consider using a technique like a sliding window or prefix sum which can solve this problem with a time complexity of O(n)."
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "Solution using sliding window \\u2705\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/solutions/3727421/sliding-window-solution/"
                    },
                    {
                        "username": "layyy",
                        "content": "keep a window of sum>=target and track its size"
                    },
                    {
                        "username": "patrickson1997",
                        "content": "How is this a sliding window problem? The window length can be anything and is not fixed."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, the window size does not always have to be fixed. What\\'s more important is that there is a contiguous subarray, or a \"window,\" that you\\'re considering at any given time.\\n\\nIn this particular problem, the \"window\" refers to a contiguous subarray of the original array. The goal is to find the shortest such subarray that has a sum greater than or equal to a target value.\\n\\nYou start by initializing a window at the beginning of the array and continue to expand it (by moving the end of the window to the right) as long as the sum of the elements in the window is less than the target. When the sum is greater than or equal to the target, you attempt to contract the window (by moving the start of the window to the right) while ensuring the sum still remains greater than or equal to the target. \\n\\nIn this way, the window \"slides\" through the array, and its size dynamically changes depending on the specific values in the array and their sum relative to the target. Therefore, this problem is categorized as a sliding window problem."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "For nlogn, apply bs on fixed sized window!"
                    }
                ]
            },
            {
                "id": 1958806,
                "content": [
                    {
                        "username": "Anshika_0924",
                        "content": "Can anyone explain how the sliding window approach has O(N) complexity?\\n"
                    },
                    {
                        "username": "Megir",
                        "content": "Help please with testcase 13:\\ntarget = 20\\nnums = [2,16,14,15]\\nwhy answer is 2 instead of 0?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "actual mentioning : Return the minimal length of a subarray whose sum is *greater than or equal* to target."
                    },
                    {
                        "username": "nightfury_69",
                        "content": "I am getting minimal output but expected is showing wrong"
                    },
                    {
                        "username": "rahul_siddhu",
                        "content": "I am gettingg wrong answer on 19th test case my code is giving output 131 but the correct answer is 132, below is my code please tell where is the problem. Thank you.\\n    [my code](https://leetcode.com/problems/minimum-size-subarray-sum/submissions/987924946/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code lies in the second while loop where you\\'re decrementing the window and sum without ensuring that the index \\'i\\' is within the valid range. Also, you are subtracting `nums[i]` from `sum` after incrementing `i`, which could potentially lead to incorrect results. \\n\\nTry adjusting the code as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int len = 0, ans = INT_MAX, i = 0, j = 0, sum = 0, n = nums.size();\\n        while(j < n){\\n            sum += nums[j];\\n            len++;\\n            j++;\\n\\n            while(sum >= target){\\n                ans = min(ans, len);\\n                sum -= nums[i];\\n                i++;\\n                len--;\\n            }\\n        }\\n        return (ans == INT_MAX) ? 0 : ans;\\n    }\\n};\\n```\\n\\nHere\\'s what\\'s changed:\\n\\n1. The second while loop is now checking `sum >= target` instead of `sum-nums[i] >= target`. We\\'re still sliding the window to the right when the total is greater than or equal to the target.\\n\\n2. Inside the second while loop, `sum -= nums[i];` is now before `i++;` ensuring that we\\'re decrementing the sum by the correct amount.\\n\\n3. The final return statement is adjusted to handle the case where no subarray sums to the target. If no such subarray is found, `ans` will remain at its initial value of `INT_MAX`, and the function should return 0."
                    },
                    {
                        "username": "iamprobablycoding",
                        "content": "Finally my noob brain got a little dopamine hit solving this."
                    },
                    {
                        "username": "theNikhilP",
                        "content": "Can anyone tell me what\\'s wrong in my code\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target, int i) {\\n        if (target <= 0) {\\n            return 0;\\n        }\\n\\n        if (i >= nums.size()) {\\n            return INT_MAX/2;\\n        }\\n\\n        int l1 = 1 + helper(nums, target - nums[i], i + 1);\\n        int l2 = helper(nums, target, i + 1);\\n        return min(l1, l2);\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int x = helper(nums, target, 0);\\n        if (x >= INT_MAX/2) {\\n            return 0;\\n        }\\n\\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted appears to be attempting a recursive approach to solving the problem. The helper function is trying to explore all possible subarrays by recursively reducing the target by the value of the current element (l1), and moving to the next element, or skipping the current element and moving to the next one (l2). Then it chooses the smaller length subarray between the two.\\n\\nHowever, this approach doesn\\'t fit the problem for two reasons:\\n\\n1. It does not preserve the order of the array elements: The problem statement specifies that you need to find the smallest contiguous subarray that sums to at least the target value. Contiguous means the elements are in their original order in the array. However, the recursive approach you\\'re using can mix up the order of the elements, as it\\'s effectively trying all combinations of elements, not just contiguous subarrays.\\n\\n2. It\\'s inefficient: The time complexity of this approach is O(2^n), where n is the number of elements in the array. This is because each recursive call branches into two new recursive calls, leading to an exponential number of total function calls. This could cause your program to run very slowly, or even exceed the time limit, for larger input arrays.\\n\\nYou might want to reconsider your approach and consider using a technique like a sliding window or prefix sum which can solve this problem with a time complexity of O(n)."
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "Solution using sliding window \\u2705\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/solutions/3727421/sliding-window-solution/"
                    },
                    {
                        "username": "layyy",
                        "content": "keep a window of sum>=target and track its size"
                    },
                    {
                        "username": "patrickson1997",
                        "content": "How is this a sliding window problem? The window length can be anything and is not fixed."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, the window size does not always have to be fixed. What\\'s more important is that there is a contiguous subarray, or a \"window,\" that you\\'re considering at any given time.\\n\\nIn this particular problem, the \"window\" refers to a contiguous subarray of the original array. The goal is to find the shortest such subarray that has a sum greater than or equal to a target value.\\n\\nYou start by initializing a window at the beginning of the array and continue to expand it (by moving the end of the window to the right) as long as the sum of the elements in the window is less than the target. When the sum is greater than or equal to the target, you attempt to contract the window (by moving the start of the window to the right) while ensuring the sum still remains greater than or equal to the target. \\n\\nIn this way, the window \"slides\" through the array, and its size dynamically changes depending on the specific values in the array and their sum relative to the target. Therefore, this problem is categorized as a sliding window problem."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "For nlogn, apply bs on fixed sized window!"
                    }
                ]
            },
            {
                "id": 1958776,
                "content": [
                    {
                        "username": "Anshika_0924",
                        "content": "Can anyone explain how the sliding window approach has O(N) complexity?\\n"
                    },
                    {
                        "username": "Megir",
                        "content": "Help please with testcase 13:\\ntarget = 20\\nnums = [2,16,14,15]\\nwhy answer is 2 instead of 0?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "actual mentioning : Return the minimal length of a subarray whose sum is *greater than or equal* to target."
                    },
                    {
                        "username": "nightfury_69",
                        "content": "I am getting minimal output but expected is showing wrong"
                    },
                    {
                        "username": "rahul_siddhu",
                        "content": "I am gettingg wrong answer on 19th test case my code is giving output 131 but the correct answer is 132, below is my code please tell where is the problem. Thank you.\\n    [my code](https://leetcode.com/problems/minimum-size-subarray-sum/submissions/987924946/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code lies in the second while loop where you\\'re decrementing the window and sum without ensuring that the index \\'i\\' is within the valid range. Also, you are subtracting `nums[i]` from `sum` after incrementing `i`, which could potentially lead to incorrect results. \\n\\nTry adjusting the code as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int len = 0, ans = INT_MAX, i = 0, j = 0, sum = 0, n = nums.size();\\n        while(j < n){\\n            sum += nums[j];\\n            len++;\\n            j++;\\n\\n            while(sum >= target){\\n                ans = min(ans, len);\\n                sum -= nums[i];\\n                i++;\\n                len--;\\n            }\\n        }\\n        return (ans == INT_MAX) ? 0 : ans;\\n    }\\n};\\n```\\n\\nHere\\'s what\\'s changed:\\n\\n1. The second while loop is now checking `sum >= target` instead of `sum-nums[i] >= target`. We\\'re still sliding the window to the right when the total is greater than or equal to the target.\\n\\n2. Inside the second while loop, `sum -= nums[i];` is now before `i++;` ensuring that we\\'re decrementing the sum by the correct amount.\\n\\n3. The final return statement is adjusted to handle the case where no subarray sums to the target. If no such subarray is found, `ans` will remain at its initial value of `INT_MAX`, and the function should return 0."
                    },
                    {
                        "username": "iamprobablycoding",
                        "content": "Finally my noob brain got a little dopamine hit solving this."
                    },
                    {
                        "username": "theNikhilP",
                        "content": "Can anyone tell me what\\'s wrong in my code\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target, int i) {\\n        if (target <= 0) {\\n            return 0;\\n        }\\n\\n        if (i >= nums.size()) {\\n            return INT_MAX/2;\\n        }\\n\\n        int l1 = 1 + helper(nums, target - nums[i], i + 1);\\n        int l2 = helper(nums, target, i + 1);\\n        return min(l1, l2);\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int x = helper(nums, target, 0);\\n        if (x >= INT_MAX/2) {\\n            return 0;\\n        }\\n\\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted appears to be attempting a recursive approach to solving the problem. The helper function is trying to explore all possible subarrays by recursively reducing the target by the value of the current element (l1), and moving to the next element, or skipping the current element and moving to the next one (l2). Then it chooses the smaller length subarray between the two.\\n\\nHowever, this approach doesn\\'t fit the problem for two reasons:\\n\\n1. It does not preserve the order of the array elements: The problem statement specifies that you need to find the smallest contiguous subarray that sums to at least the target value. Contiguous means the elements are in their original order in the array. However, the recursive approach you\\'re using can mix up the order of the elements, as it\\'s effectively trying all combinations of elements, not just contiguous subarrays.\\n\\n2. It\\'s inefficient: The time complexity of this approach is O(2^n), where n is the number of elements in the array. This is because each recursive call branches into two new recursive calls, leading to an exponential number of total function calls. This could cause your program to run very slowly, or even exceed the time limit, for larger input arrays.\\n\\nYou might want to reconsider your approach and consider using a technique like a sliding window or prefix sum which can solve this problem with a time complexity of O(n)."
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "Solution using sliding window \\u2705\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/solutions/3727421/sliding-window-solution/"
                    },
                    {
                        "username": "layyy",
                        "content": "keep a window of sum>=target and track its size"
                    },
                    {
                        "username": "patrickson1997",
                        "content": "How is this a sliding window problem? The window length can be anything and is not fixed."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, the window size does not always have to be fixed. What\\'s more important is that there is a contiguous subarray, or a \"window,\" that you\\'re considering at any given time.\\n\\nIn this particular problem, the \"window\" refers to a contiguous subarray of the original array. The goal is to find the shortest such subarray that has a sum greater than or equal to a target value.\\n\\nYou start by initializing a window at the beginning of the array and continue to expand it (by moving the end of the window to the right) as long as the sum of the elements in the window is less than the target. When the sum is greater than or equal to the target, you attempt to contract the window (by moving the start of the window to the right) while ensuring the sum still remains greater than or equal to the target. \\n\\nIn this way, the window \"slides\" through the array, and its size dynamically changes depending on the specific values in the array and their sum relative to the target. Therefore, this problem is categorized as a sliding window problem."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "For nlogn, apply bs on fixed sized window!"
                    }
                ]
            },
            {
                "id": 1958743,
                "content": [
                    {
                        "username": "Anshika_0924",
                        "content": "Can anyone explain how the sliding window approach has O(N) complexity?\\n"
                    },
                    {
                        "username": "Megir",
                        "content": "Help please with testcase 13:\\ntarget = 20\\nnums = [2,16,14,15]\\nwhy answer is 2 instead of 0?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "actual mentioning : Return the minimal length of a subarray whose sum is *greater than or equal* to target."
                    },
                    {
                        "username": "nightfury_69",
                        "content": "I am getting minimal output but expected is showing wrong"
                    },
                    {
                        "username": "rahul_siddhu",
                        "content": "I am gettingg wrong answer on 19th test case my code is giving output 131 but the correct answer is 132, below is my code please tell where is the problem. Thank you.\\n    [my code](https://leetcode.com/problems/minimum-size-subarray-sum/submissions/987924946/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code lies in the second while loop where you\\'re decrementing the window and sum without ensuring that the index \\'i\\' is within the valid range. Also, you are subtracting `nums[i]` from `sum` after incrementing `i`, which could potentially lead to incorrect results. \\n\\nTry adjusting the code as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int len = 0, ans = INT_MAX, i = 0, j = 0, sum = 0, n = nums.size();\\n        while(j < n){\\n            sum += nums[j];\\n            len++;\\n            j++;\\n\\n            while(sum >= target){\\n                ans = min(ans, len);\\n                sum -= nums[i];\\n                i++;\\n                len--;\\n            }\\n        }\\n        return (ans == INT_MAX) ? 0 : ans;\\n    }\\n};\\n```\\n\\nHere\\'s what\\'s changed:\\n\\n1. The second while loop is now checking `sum >= target` instead of `sum-nums[i] >= target`. We\\'re still sliding the window to the right when the total is greater than or equal to the target.\\n\\n2. Inside the second while loop, `sum -= nums[i];` is now before `i++;` ensuring that we\\'re decrementing the sum by the correct amount.\\n\\n3. The final return statement is adjusted to handle the case where no subarray sums to the target. If no such subarray is found, `ans` will remain at its initial value of `INT_MAX`, and the function should return 0."
                    },
                    {
                        "username": "iamprobablycoding",
                        "content": "Finally my noob brain got a little dopamine hit solving this."
                    },
                    {
                        "username": "theNikhilP",
                        "content": "Can anyone tell me what\\'s wrong in my code\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target, int i) {\\n        if (target <= 0) {\\n            return 0;\\n        }\\n\\n        if (i >= nums.size()) {\\n            return INT_MAX/2;\\n        }\\n\\n        int l1 = 1 + helper(nums, target - nums[i], i + 1);\\n        int l2 = helper(nums, target, i + 1);\\n        return min(l1, l2);\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int x = helper(nums, target, 0);\\n        if (x >= INT_MAX/2) {\\n            return 0;\\n        }\\n\\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted appears to be attempting a recursive approach to solving the problem. The helper function is trying to explore all possible subarrays by recursively reducing the target by the value of the current element (l1), and moving to the next element, or skipping the current element and moving to the next one (l2). Then it chooses the smaller length subarray between the two.\\n\\nHowever, this approach doesn\\'t fit the problem for two reasons:\\n\\n1. It does not preserve the order of the array elements: The problem statement specifies that you need to find the smallest contiguous subarray that sums to at least the target value. Contiguous means the elements are in their original order in the array. However, the recursive approach you\\'re using can mix up the order of the elements, as it\\'s effectively trying all combinations of elements, not just contiguous subarrays.\\n\\n2. It\\'s inefficient: The time complexity of this approach is O(2^n), where n is the number of elements in the array. This is because each recursive call branches into two new recursive calls, leading to an exponential number of total function calls. This could cause your program to run very slowly, or even exceed the time limit, for larger input arrays.\\n\\nYou might want to reconsider your approach and consider using a technique like a sliding window or prefix sum which can solve this problem with a time complexity of O(n)."
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "Solution using sliding window \\u2705\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/solutions/3727421/sliding-window-solution/"
                    },
                    {
                        "username": "layyy",
                        "content": "keep a window of sum>=target and track its size"
                    },
                    {
                        "username": "patrickson1997",
                        "content": "How is this a sliding window problem? The window length can be anything and is not fixed."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, the window size does not always have to be fixed. What\\'s more important is that there is a contiguous subarray, or a \"window,\" that you\\'re considering at any given time.\\n\\nIn this particular problem, the \"window\" refers to a contiguous subarray of the original array. The goal is to find the shortest such subarray that has a sum greater than or equal to a target value.\\n\\nYou start by initializing a window at the beginning of the array and continue to expand it (by moving the end of the window to the right) as long as the sum of the elements in the window is less than the target. When the sum is greater than or equal to the target, you attempt to contract the window (by moving the start of the window to the right) while ensuring the sum still remains greater than or equal to the target. \\n\\nIn this way, the window \"slides\" through the array, and its size dynamically changes depending on the specific values in the array and their sum relative to the target. Therefore, this problem is categorized as a sliding window problem."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "For nlogn, apply bs on fixed sized window!"
                    }
                ]
            },
            {
                "id": 1958736,
                "content": [
                    {
                        "username": "Anshika_0924",
                        "content": "Can anyone explain how the sliding window approach has O(N) complexity?\\n"
                    },
                    {
                        "username": "Megir",
                        "content": "Help please with testcase 13:\\ntarget = 20\\nnums = [2,16,14,15]\\nwhy answer is 2 instead of 0?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "actual mentioning : Return the minimal length of a subarray whose sum is *greater than or equal* to target."
                    },
                    {
                        "username": "nightfury_69",
                        "content": "I am getting minimal output but expected is showing wrong"
                    },
                    {
                        "username": "rahul_siddhu",
                        "content": "I am gettingg wrong answer on 19th test case my code is giving output 131 but the correct answer is 132, below is my code please tell where is the problem. Thank you.\\n    [my code](https://leetcode.com/problems/minimum-size-subarray-sum/submissions/987924946/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code lies in the second while loop where you\\'re decrementing the window and sum without ensuring that the index \\'i\\' is within the valid range. Also, you are subtracting `nums[i]` from `sum` after incrementing `i`, which could potentially lead to incorrect results. \\n\\nTry adjusting the code as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int len = 0, ans = INT_MAX, i = 0, j = 0, sum = 0, n = nums.size();\\n        while(j < n){\\n            sum += nums[j];\\n            len++;\\n            j++;\\n\\n            while(sum >= target){\\n                ans = min(ans, len);\\n                sum -= nums[i];\\n                i++;\\n                len--;\\n            }\\n        }\\n        return (ans == INT_MAX) ? 0 : ans;\\n    }\\n};\\n```\\n\\nHere\\'s what\\'s changed:\\n\\n1. The second while loop is now checking `sum >= target` instead of `sum-nums[i] >= target`. We\\'re still sliding the window to the right when the total is greater than or equal to the target.\\n\\n2. Inside the second while loop, `sum -= nums[i];` is now before `i++;` ensuring that we\\'re decrementing the sum by the correct amount.\\n\\n3. The final return statement is adjusted to handle the case where no subarray sums to the target. If no such subarray is found, `ans` will remain at its initial value of `INT_MAX`, and the function should return 0."
                    },
                    {
                        "username": "iamprobablycoding",
                        "content": "Finally my noob brain got a little dopamine hit solving this."
                    },
                    {
                        "username": "theNikhilP",
                        "content": "Can anyone tell me what\\'s wrong in my code\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target, int i) {\\n        if (target <= 0) {\\n            return 0;\\n        }\\n\\n        if (i >= nums.size()) {\\n            return INT_MAX/2;\\n        }\\n\\n        int l1 = 1 + helper(nums, target - nums[i], i + 1);\\n        int l2 = helper(nums, target, i + 1);\\n        return min(l1, l2);\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int x = helper(nums, target, 0);\\n        if (x >= INT_MAX/2) {\\n            return 0;\\n        }\\n\\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted appears to be attempting a recursive approach to solving the problem. The helper function is trying to explore all possible subarrays by recursively reducing the target by the value of the current element (l1), and moving to the next element, or skipping the current element and moving to the next one (l2). Then it chooses the smaller length subarray between the two.\\n\\nHowever, this approach doesn\\'t fit the problem for two reasons:\\n\\n1. It does not preserve the order of the array elements: The problem statement specifies that you need to find the smallest contiguous subarray that sums to at least the target value. Contiguous means the elements are in their original order in the array. However, the recursive approach you\\'re using can mix up the order of the elements, as it\\'s effectively trying all combinations of elements, not just contiguous subarrays.\\n\\n2. It\\'s inefficient: The time complexity of this approach is O(2^n), where n is the number of elements in the array. This is because each recursive call branches into two new recursive calls, leading to an exponential number of total function calls. This could cause your program to run very slowly, or even exceed the time limit, for larger input arrays.\\n\\nYou might want to reconsider your approach and consider using a technique like a sliding window or prefix sum which can solve this problem with a time complexity of O(n)."
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "Solution using sliding window \\u2705\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/solutions/3727421/sliding-window-solution/"
                    },
                    {
                        "username": "layyy",
                        "content": "keep a window of sum>=target and track its size"
                    },
                    {
                        "username": "patrickson1997",
                        "content": "How is this a sliding window problem? The window length can be anything and is not fixed."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, the window size does not always have to be fixed. What\\'s more important is that there is a contiguous subarray, or a \"window,\" that you\\'re considering at any given time.\\n\\nIn this particular problem, the \"window\" refers to a contiguous subarray of the original array. The goal is to find the shortest such subarray that has a sum greater than or equal to a target value.\\n\\nYou start by initializing a window at the beginning of the array and continue to expand it (by moving the end of the window to the right) as long as the sum of the elements in the window is less than the target. When the sum is greater than or equal to the target, you attempt to contract the window (by moving the start of the window to the right) while ensuring the sum still remains greater than or equal to the target. \\n\\nIn this way, the window \"slides\" through the array, and its size dynamically changes depending on the specific values in the array and their sum relative to the target. Therefore, this problem is categorized as a sliding window problem."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "For nlogn, apply bs on fixed sized window!"
                    }
                ]
            },
            {
                "id": 1958685,
                "content": [
                    {
                        "username": "Anshika_0924",
                        "content": "Can anyone explain how the sliding window approach has O(N) complexity?\\n"
                    },
                    {
                        "username": "Megir",
                        "content": "Help please with testcase 13:\\ntarget = 20\\nnums = [2,16,14,15]\\nwhy answer is 2 instead of 0?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "actual mentioning : Return the minimal length of a subarray whose sum is *greater than or equal* to target."
                    },
                    {
                        "username": "nightfury_69",
                        "content": "I am getting minimal output but expected is showing wrong"
                    },
                    {
                        "username": "rahul_siddhu",
                        "content": "I am gettingg wrong answer on 19th test case my code is giving output 131 but the correct answer is 132, below is my code please tell where is the problem. Thank you.\\n    [my code](https://leetcode.com/problems/minimum-size-subarray-sum/submissions/987924946/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code lies in the second while loop where you\\'re decrementing the window and sum without ensuring that the index \\'i\\' is within the valid range. Also, you are subtracting `nums[i]` from `sum` after incrementing `i`, which could potentially lead to incorrect results. \\n\\nTry adjusting the code as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int len = 0, ans = INT_MAX, i = 0, j = 0, sum = 0, n = nums.size();\\n        while(j < n){\\n            sum += nums[j];\\n            len++;\\n            j++;\\n\\n            while(sum >= target){\\n                ans = min(ans, len);\\n                sum -= nums[i];\\n                i++;\\n                len--;\\n            }\\n        }\\n        return (ans == INT_MAX) ? 0 : ans;\\n    }\\n};\\n```\\n\\nHere\\'s what\\'s changed:\\n\\n1. The second while loop is now checking `sum >= target` instead of `sum-nums[i] >= target`. We\\'re still sliding the window to the right when the total is greater than or equal to the target.\\n\\n2. Inside the second while loop, `sum -= nums[i];` is now before `i++;` ensuring that we\\'re decrementing the sum by the correct amount.\\n\\n3. The final return statement is adjusted to handle the case where no subarray sums to the target. If no such subarray is found, `ans` will remain at its initial value of `INT_MAX`, and the function should return 0."
                    },
                    {
                        "username": "iamprobablycoding",
                        "content": "Finally my noob brain got a little dopamine hit solving this."
                    },
                    {
                        "username": "theNikhilP",
                        "content": "Can anyone tell me what\\'s wrong in my code\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target, int i) {\\n        if (target <= 0) {\\n            return 0;\\n        }\\n\\n        if (i >= nums.size()) {\\n            return INT_MAX/2;\\n        }\\n\\n        int l1 = 1 + helper(nums, target - nums[i], i + 1);\\n        int l2 = helper(nums, target, i + 1);\\n        return min(l1, l2);\\n    }\\n\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int x = helper(nums, target, 0);\\n        if (x >= INT_MAX/2) {\\n            return 0;\\n        }\\n\\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted appears to be attempting a recursive approach to solving the problem. The helper function is trying to explore all possible subarrays by recursively reducing the target by the value of the current element (l1), and moving to the next element, or skipping the current element and moving to the next one (l2). Then it chooses the smaller length subarray between the two.\\n\\nHowever, this approach doesn\\'t fit the problem for two reasons:\\n\\n1. It does not preserve the order of the array elements: The problem statement specifies that you need to find the smallest contiguous subarray that sums to at least the target value. Contiguous means the elements are in their original order in the array. However, the recursive approach you\\'re using can mix up the order of the elements, as it\\'s effectively trying all combinations of elements, not just contiguous subarrays.\\n\\n2. It\\'s inefficient: The time complexity of this approach is O(2^n), where n is the number of elements in the array. This is because each recursive call branches into two new recursive calls, leading to an exponential number of total function calls. This could cause your program to run very slowly, or even exceed the time limit, for larger input arrays.\\n\\nYou might want to reconsider your approach and consider using a technique like a sliding window or prefix sum which can solve this problem with a time complexity of O(n)."
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "Solution using sliding window \\u2705\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/solutions/3727421/sliding-window-solution/"
                    },
                    {
                        "username": "layyy",
                        "content": "keep a window of sum>=target and track its size"
                    },
                    {
                        "username": "patrickson1997",
                        "content": "How is this a sliding window problem? The window length can be anything and is not fixed."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, the window size does not always have to be fixed. What\\'s more important is that there is a contiguous subarray, or a \"window,\" that you\\'re considering at any given time.\\n\\nIn this particular problem, the \"window\" refers to a contiguous subarray of the original array. The goal is to find the shortest such subarray that has a sum greater than or equal to a target value.\\n\\nYou start by initializing a window at the beginning of the array and continue to expand it (by moving the end of the window to the right) as long as the sum of the elements in the window is less than the target. When the sum is greater than or equal to the target, you attempt to contract the window (by moving the start of the window to the right) while ensuring the sum still remains greater than or equal to the target. \\n\\nIn this way, the window \"slides\" through the array, and its size dynamically changes depending on the specific values in the array and their sum relative to the target. Therefore, this problem is categorized as a sliding window problem."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "For nlogn, apply bs on fixed sized window!"
                    }
                ]
            },
            {
                "id": 1958679,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "It should be an easy problem. \\n**Hint** - Use Sliding Window Technique"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "just failed 1 test cases."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "How does one come up with prefix sum + binary search intuition?"
                    },
                    {
                        "username": "yooyepyoo",
                        "content": "for target = 11\\nand nums =[1,2,3,4,5]\\nanswer should be 0 but in test cases its 3 can someone explain how?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "subarray with sum value **greater** than or equal to 11\n- [1,2,3,4,5] 15 >= 11\n- [2,3,4,5] 14 >= 11\n- [3,4,5] 12 >= 11\n\nthe min subarray is [3,4,5] so the answer is 3"
                    },
                    {
                        "username": "SG-C",
                        "content": "Yesss ! back to back sliding window questions"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "why they don\\'t describe that the sub array should be continuous"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement for minimum size subarray, the term \"subarray\" implicitly refers to a contiguous segment of the array. By definition, a subarray is a contiguous subset of an array, which means that the elements in the subarray must be in the same order they appear in the original array, with no breaks or gaps. \\n\\nSo, if you see a problem that asks for a \"subarray,\" you can assume that it is asking for a contiguous segment unless it explicitly specifies otherwise. Therefore, it is not necessary for every problem to explicitly state that the subarray should be contiguous. If non-contiguous subsets of an array are allowed, the problem will typically use the term \"subsequence\" instead of \"subarray.\""
                    },
                    {
                        "username": "seeker_747",
                        "content": "very good problem on arrays , it took O(2N) complexity to solve , can anyone tell me a better way to solve it.My Approach is based on two pointers ,and i am shrinking the window once i get more or equal to the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of using a sliding window with two pointers is a good one and it is actually one of the most optimal ways to solve this problem! This method allows you to scan through the array once, making it a O(n) time complexity solution, where n is the number of elements in the array.\\n\\nHere\\'s a little clarification on why it\\'s O(n) and not O(2n): \\n\\nIn Big O notation, we drop constants. This is because Big O notation describes the rate of growth of an algorithm\\'s runtime, rather than the exact runtime. So even if each element of the array might be visited twice (once when expanding the window, and once when shrinking), we still consider this to be linear time complexity, or O(n), as the number of operations grows linearly with the size of the input array. \\n\\nIf you want to further optimize this problem, you could consider optimizing the space complexity if you\\'re storing extra data. But in terms of time complexity, the two-pointer sliding window approach is considered optimal for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I am really off my game today. This is just a straightforward sliding window problem but it took me all day to get the logic right."
                    },
                    {
                        "username": "meeseeks_san",
                        "content": "This should definitely be marked as an easy question."
                    },
                    {
                        "username": "rohanlalwani0810",
                        "content": "For the last test case you need to use INT_MAX in C++"
                    }
                ]
            },
            {
                "id": 1958635,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "It should be an easy problem. \\n**Hint** - Use Sliding Window Technique"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "just failed 1 test cases."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "How does one come up with prefix sum + binary search intuition?"
                    },
                    {
                        "username": "yooyepyoo",
                        "content": "for target = 11\\nand nums =[1,2,3,4,5]\\nanswer should be 0 but in test cases its 3 can someone explain how?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "subarray with sum value **greater** than or equal to 11\n- [1,2,3,4,5] 15 >= 11\n- [2,3,4,5] 14 >= 11\n- [3,4,5] 12 >= 11\n\nthe min subarray is [3,4,5] so the answer is 3"
                    },
                    {
                        "username": "SG-C",
                        "content": "Yesss ! back to back sliding window questions"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "why they don\\'t describe that the sub array should be continuous"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement for minimum size subarray, the term \"subarray\" implicitly refers to a contiguous segment of the array. By definition, a subarray is a contiguous subset of an array, which means that the elements in the subarray must be in the same order they appear in the original array, with no breaks or gaps. \\n\\nSo, if you see a problem that asks for a \"subarray,\" you can assume that it is asking for a contiguous segment unless it explicitly specifies otherwise. Therefore, it is not necessary for every problem to explicitly state that the subarray should be contiguous. If non-contiguous subsets of an array are allowed, the problem will typically use the term \"subsequence\" instead of \"subarray.\""
                    },
                    {
                        "username": "seeker_747",
                        "content": "very good problem on arrays , it took O(2N) complexity to solve , can anyone tell me a better way to solve it.My Approach is based on two pointers ,and i am shrinking the window once i get more or equal to the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of using a sliding window with two pointers is a good one and it is actually one of the most optimal ways to solve this problem! This method allows you to scan through the array once, making it a O(n) time complexity solution, where n is the number of elements in the array.\\n\\nHere\\'s a little clarification on why it\\'s O(n) and not O(2n): \\n\\nIn Big O notation, we drop constants. This is because Big O notation describes the rate of growth of an algorithm\\'s runtime, rather than the exact runtime. So even if each element of the array might be visited twice (once when expanding the window, and once when shrinking), we still consider this to be linear time complexity, or O(n), as the number of operations grows linearly with the size of the input array. \\n\\nIf you want to further optimize this problem, you could consider optimizing the space complexity if you\\'re storing extra data. But in terms of time complexity, the two-pointer sliding window approach is considered optimal for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I am really off my game today. This is just a straightforward sliding window problem but it took me all day to get the logic right."
                    },
                    {
                        "username": "meeseeks_san",
                        "content": "This should definitely be marked as an easy question."
                    },
                    {
                        "username": "rohanlalwani0810",
                        "content": "For the last test case you need to use INT_MAX in C++"
                    }
                ]
            },
            {
                "id": 1958583,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "It should be an easy problem. \\n**Hint** - Use Sliding Window Technique"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "just failed 1 test cases."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "How does one come up with prefix sum + binary search intuition?"
                    },
                    {
                        "username": "yooyepyoo",
                        "content": "for target = 11\\nand nums =[1,2,3,4,5]\\nanswer should be 0 but in test cases its 3 can someone explain how?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "subarray with sum value **greater** than or equal to 11\n- [1,2,3,4,5] 15 >= 11\n- [2,3,4,5] 14 >= 11\n- [3,4,5] 12 >= 11\n\nthe min subarray is [3,4,5] so the answer is 3"
                    },
                    {
                        "username": "SG-C",
                        "content": "Yesss ! back to back sliding window questions"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "why they don\\'t describe that the sub array should be continuous"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement for minimum size subarray, the term \"subarray\" implicitly refers to a contiguous segment of the array. By definition, a subarray is a contiguous subset of an array, which means that the elements in the subarray must be in the same order they appear in the original array, with no breaks or gaps. \\n\\nSo, if you see a problem that asks for a \"subarray,\" you can assume that it is asking for a contiguous segment unless it explicitly specifies otherwise. Therefore, it is not necessary for every problem to explicitly state that the subarray should be contiguous. If non-contiguous subsets of an array are allowed, the problem will typically use the term \"subsequence\" instead of \"subarray.\""
                    },
                    {
                        "username": "seeker_747",
                        "content": "very good problem on arrays , it took O(2N) complexity to solve , can anyone tell me a better way to solve it.My Approach is based on two pointers ,and i am shrinking the window once i get more or equal to the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of using a sliding window with two pointers is a good one and it is actually one of the most optimal ways to solve this problem! This method allows you to scan through the array once, making it a O(n) time complexity solution, where n is the number of elements in the array.\\n\\nHere\\'s a little clarification on why it\\'s O(n) and not O(2n): \\n\\nIn Big O notation, we drop constants. This is because Big O notation describes the rate of growth of an algorithm\\'s runtime, rather than the exact runtime. So even if each element of the array might be visited twice (once when expanding the window, and once when shrinking), we still consider this to be linear time complexity, or O(n), as the number of operations grows linearly with the size of the input array. \\n\\nIf you want to further optimize this problem, you could consider optimizing the space complexity if you\\'re storing extra data. But in terms of time complexity, the two-pointer sliding window approach is considered optimal for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I am really off my game today. This is just a straightforward sliding window problem but it took me all day to get the logic right."
                    },
                    {
                        "username": "meeseeks_san",
                        "content": "This should definitely be marked as an easy question."
                    },
                    {
                        "username": "rohanlalwani0810",
                        "content": "For the last test case you need to use INT_MAX in C++"
                    }
                ]
            },
            {
                "id": 1958577,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "It should be an easy problem. \\n**Hint** - Use Sliding Window Technique"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "just failed 1 test cases."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "How does one come up with prefix sum + binary search intuition?"
                    },
                    {
                        "username": "yooyepyoo",
                        "content": "for target = 11\\nand nums =[1,2,3,4,5]\\nanswer should be 0 but in test cases its 3 can someone explain how?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "subarray with sum value **greater** than or equal to 11\n- [1,2,3,4,5] 15 >= 11\n- [2,3,4,5] 14 >= 11\n- [3,4,5] 12 >= 11\n\nthe min subarray is [3,4,5] so the answer is 3"
                    },
                    {
                        "username": "SG-C",
                        "content": "Yesss ! back to back sliding window questions"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "why they don\\'t describe that the sub array should be continuous"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement for minimum size subarray, the term \"subarray\" implicitly refers to a contiguous segment of the array. By definition, a subarray is a contiguous subset of an array, which means that the elements in the subarray must be in the same order they appear in the original array, with no breaks or gaps. \\n\\nSo, if you see a problem that asks for a \"subarray,\" you can assume that it is asking for a contiguous segment unless it explicitly specifies otherwise. Therefore, it is not necessary for every problem to explicitly state that the subarray should be contiguous. If non-contiguous subsets of an array are allowed, the problem will typically use the term \"subsequence\" instead of \"subarray.\""
                    },
                    {
                        "username": "seeker_747",
                        "content": "very good problem on arrays , it took O(2N) complexity to solve , can anyone tell me a better way to solve it.My Approach is based on two pointers ,and i am shrinking the window once i get more or equal to the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of using a sliding window with two pointers is a good one and it is actually one of the most optimal ways to solve this problem! This method allows you to scan through the array once, making it a O(n) time complexity solution, where n is the number of elements in the array.\\n\\nHere\\'s a little clarification on why it\\'s O(n) and not O(2n): \\n\\nIn Big O notation, we drop constants. This is because Big O notation describes the rate of growth of an algorithm\\'s runtime, rather than the exact runtime. So even if each element of the array might be visited twice (once when expanding the window, and once when shrinking), we still consider this to be linear time complexity, or O(n), as the number of operations grows linearly with the size of the input array. \\n\\nIf you want to further optimize this problem, you could consider optimizing the space complexity if you\\'re storing extra data. But in terms of time complexity, the two-pointer sliding window approach is considered optimal for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I am really off my game today. This is just a straightforward sliding window problem but it took me all day to get the logic right."
                    },
                    {
                        "username": "meeseeks_san",
                        "content": "This should definitely be marked as an easy question."
                    },
                    {
                        "username": "rohanlalwani0810",
                        "content": "For the last test case you need to use INT_MAX in C++"
                    }
                ]
            },
            {
                "id": 1958562,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "It should be an easy problem. \\n**Hint** - Use Sliding Window Technique"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "just failed 1 test cases."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "How does one come up with prefix sum + binary search intuition?"
                    },
                    {
                        "username": "yooyepyoo",
                        "content": "for target = 11\\nand nums =[1,2,3,4,5]\\nanswer should be 0 but in test cases its 3 can someone explain how?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "subarray with sum value **greater** than or equal to 11\n- [1,2,3,4,5] 15 >= 11\n- [2,3,4,5] 14 >= 11\n- [3,4,5] 12 >= 11\n\nthe min subarray is [3,4,5] so the answer is 3"
                    },
                    {
                        "username": "SG-C",
                        "content": "Yesss ! back to back sliding window questions"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "why they don\\'t describe that the sub array should be continuous"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement for minimum size subarray, the term \"subarray\" implicitly refers to a contiguous segment of the array. By definition, a subarray is a contiguous subset of an array, which means that the elements in the subarray must be in the same order they appear in the original array, with no breaks or gaps. \\n\\nSo, if you see a problem that asks for a \"subarray,\" you can assume that it is asking for a contiguous segment unless it explicitly specifies otherwise. Therefore, it is not necessary for every problem to explicitly state that the subarray should be contiguous. If non-contiguous subsets of an array are allowed, the problem will typically use the term \"subsequence\" instead of \"subarray.\""
                    },
                    {
                        "username": "seeker_747",
                        "content": "very good problem on arrays , it took O(2N) complexity to solve , can anyone tell me a better way to solve it.My Approach is based on two pointers ,and i am shrinking the window once i get more or equal to the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of using a sliding window with two pointers is a good one and it is actually one of the most optimal ways to solve this problem! This method allows you to scan through the array once, making it a O(n) time complexity solution, where n is the number of elements in the array.\\n\\nHere\\'s a little clarification on why it\\'s O(n) and not O(2n): \\n\\nIn Big O notation, we drop constants. This is because Big O notation describes the rate of growth of an algorithm\\'s runtime, rather than the exact runtime. So even if each element of the array might be visited twice (once when expanding the window, and once when shrinking), we still consider this to be linear time complexity, or O(n), as the number of operations grows linearly with the size of the input array. \\n\\nIf you want to further optimize this problem, you could consider optimizing the space complexity if you\\'re storing extra data. But in terms of time complexity, the two-pointer sliding window approach is considered optimal for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I am really off my game today. This is just a straightforward sliding window problem but it took me all day to get the logic right."
                    },
                    {
                        "username": "meeseeks_san",
                        "content": "This should definitely be marked as an easy question."
                    },
                    {
                        "username": "rohanlalwani0810",
                        "content": "For the last test case you need to use INT_MAX in C++"
                    }
                ]
            },
            {
                "id": 1958553,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "It should be an easy problem. \\n**Hint** - Use Sliding Window Technique"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "just failed 1 test cases."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "How does one come up with prefix sum + binary search intuition?"
                    },
                    {
                        "username": "yooyepyoo",
                        "content": "for target = 11\\nand nums =[1,2,3,4,5]\\nanswer should be 0 but in test cases its 3 can someone explain how?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "subarray with sum value **greater** than or equal to 11\n- [1,2,3,4,5] 15 >= 11\n- [2,3,4,5] 14 >= 11\n- [3,4,5] 12 >= 11\n\nthe min subarray is [3,4,5] so the answer is 3"
                    },
                    {
                        "username": "SG-C",
                        "content": "Yesss ! back to back sliding window questions"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "why they don\\'t describe that the sub array should be continuous"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement for minimum size subarray, the term \"subarray\" implicitly refers to a contiguous segment of the array. By definition, a subarray is a contiguous subset of an array, which means that the elements in the subarray must be in the same order they appear in the original array, with no breaks or gaps. \\n\\nSo, if you see a problem that asks for a \"subarray,\" you can assume that it is asking for a contiguous segment unless it explicitly specifies otherwise. Therefore, it is not necessary for every problem to explicitly state that the subarray should be contiguous. If non-contiguous subsets of an array are allowed, the problem will typically use the term \"subsequence\" instead of \"subarray.\""
                    },
                    {
                        "username": "seeker_747",
                        "content": "very good problem on arrays , it took O(2N) complexity to solve , can anyone tell me a better way to solve it.My Approach is based on two pointers ,and i am shrinking the window once i get more or equal to the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of using a sliding window with two pointers is a good one and it is actually one of the most optimal ways to solve this problem! This method allows you to scan through the array once, making it a O(n) time complexity solution, where n is the number of elements in the array.\\n\\nHere\\'s a little clarification on why it\\'s O(n) and not O(2n): \\n\\nIn Big O notation, we drop constants. This is because Big O notation describes the rate of growth of an algorithm\\'s runtime, rather than the exact runtime. So even if each element of the array might be visited twice (once when expanding the window, and once when shrinking), we still consider this to be linear time complexity, or O(n), as the number of operations grows linearly with the size of the input array. \\n\\nIf you want to further optimize this problem, you could consider optimizing the space complexity if you\\'re storing extra data. But in terms of time complexity, the two-pointer sliding window approach is considered optimal for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I am really off my game today. This is just a straightforward sliding window problem but it took me all day to get the logic right."
                    },
                    {
                        "username": "meeseeks_san",
                        "content": "This should definitely be marked as an easy question."
                    },
                    {
                        "username": "rohanlalwani0810",
                        "content": "For the last test case you need to use INT_MAX in C++"
                    }
                ]
            },
            {
                "id": 1958525,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "It should be an easy problem. \\n**Hint** - Use Sliding Window Technique"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "just failed 1 test cases."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "How does one come up with prefix sum + binary search intuition?"
                    },
                    {
                        "username": "yooyepyoo",
                        "content": "for target = 11\\nand nums =[1,2,3,4,5]\\nanswer should be 0 but in test cases its 3 can someone explain how?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "subarray with sum value **greater** than or equal to 11\n- [1,2,3,4,5] 15 >= 11\n- [2,3,4,5] 14 >= 11\n- [3,4,5] 12 >= 11\n\nthe min subarray is [3,4,5] so the answer is 3"
                    },
                    {
                        "username": "SG-C",
                        "content": "Yesss ! back to back sliding window questions"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "why they don\\'t describe that the sub array should be continuous"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement for minimum size subarray, the term \"subarray\" implicitly refers to a contiguous segment of the array. By definition, a subarray is a contiguous subset of an array, which means that the elements in the subarray must be in the same order they appear in the original array, with no breaks or gaps. \\n\\nSo, if you see a problem that asks for a \"subarray,\" you can assume that it is asking for a contiguous segment unless it explicitly specifies otherwise. Therefore, it is not necessary for every problem to explicitly state that the subarray should be contiguous. If non-contiguous subsets of an array are allowed, the problem will typically use the term \"subsequence\" instead of \"subarray.\""
                    },
                    {
                        "username": "seeker_747",
                        "content": "very good problem on arrays , it took O(2N) complexity to solve , can anyone tell me a better way to solve it.My Approach is based on two pointers ,and i am shrinking the window once i get more or equal to the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of using a sliding window with two pointers is a good one and it is actually one of the most optimal ways to solve this problem! This method allows you to scan through the array once, making it a O(n) time complexity solution, where n is the number of elements in the array.\\n\\nHere\\'s a little clarification on why it\\'s O(n) and not O(2n): \\n\\nIn Big O notation, we drop constants. This is because Big O notation describes the rate of growth of an algorithm\\'s runtime, rather than the exact runtime. So even if each element of the array might be visited twice (once when expanding the window, and once when shrinking), we still consider this to be linear time complexity, or O(n), as the number of operations grows linearly with the size of the input array. \\n\\nIf you want to further optimize this problem, you could consider optimizing the space complexity if you\\'re storing extra data. But in terms of time complexity, the two-pointer sliding window approach is considered optimal for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I am really off my game today. This is just a straightforward sliding window problem but it took me all day to get the logic right."
                    },
                    {
                        "username": "meeseeks_san",
                        "content": "This should definitely be marked as an easy question."
                    },
                    {
                        "username": "rohanlalwani0810",
                        "content": "For the last test case you need to use INT_MAX in C++"
                    }
                ]
            },
            {
                "id": 1958502,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "It should be an easy problem. \\n**Hint** - Use Sliding Window Technique"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "just failed 1 test cases."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "How does one come up with prefix sum + binary search intuition?"
                    },
                    {
                        "username": "yooyepyoo",
                        "content": "for target = 11\\nand nums =[1,2,3,4,5]\\nanswer should be 0 but in test cases its 3 can someone explain how?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "subarray with sum value **greater** than or equal to 11\n- [1,2,3,4,5] 15 >= 11\n- [2,3,4,5] 14 >= 11\n- [3,4,5] 12 >= 11\n\nthe min subarray is [3,4,5] so the answer is 3"
                    },
                    {
                        "username": "SG-C",
                        "content": "Yesss ! back to back sliding window questions"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "why they don\\'t describe that the sub array should be continuous"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement for minimum size subarray, the term \"subarray\" implicitly refers to a contiguous segment of the array. By definition, a subarray is a contiguous subset of an array, which means that the elements in the subarray must be in the same order they appear in the original array, with no breaks or gaps. \\n\\nSo, if you see a problem that asks for a \"subarray,\" you can assume that it is asking for a contiguous segment unless it explicitly specifies otherwise. Therefore, it is not necessary for every problem to explicitly state that the subarray should be contiguous. If non-contiguous subsets of an array are allowed, the problem will typically use the term \"subsequence\" instead of \"subarray.\""
                    },
                    {
                        "username": "seeker_747",
                        "content": "very good problem on arrays , it took O(2N) complexity to solve , can anyone tell me a better way to solve it.My Approach is based on two pointers ,and i am shrinking the window once i get more or equal to the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of using a sliding window with two pointers is a good one and it is actually one of the most optimal ways to solve this problem! This method allows you to scan through the array once, making it a O(n) time complexity solution, where n is the number of elements in the array.\\n\\nHere\\'s a little clarification on why it\\'s O(n) and not O(2n): \\n\\nIn Big O notation, we drop constants. This is because Big O notation describes the rate of growth of an algorithm\\'s runtime, rather than the exact runtime. So even if each element of the array might be visited twice (once when expanding the window, and once when shrinking), we still consider this to be linear time complexity, or O(n), as the number of operations grows linearly with the size of the input array. \\n\\nIf you want to further optimize this problem, you could consider optimizing the space complexity if you\\'re storing extra data. But in terms of time complexity, the two-pointer sliding window approach is considered optimal for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I am really off my game today. This is just a straightforward sliding window problem but it took me all day to get the logic right."
                    },
                    {
                        "username": "meeseeks_san",
                        "content": "This should definitely be marked as an easy question."
                    },
                    {
                        "username": "rohanlalwani0810",
                        "content": "For the last test case you need to use INT_MAX in C++"
                    }
                ]
            },
            {
                "id": 1958497,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "It should be an easy problem. \\n**Hint** - Use Sliding Window Technique"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "just failed 1 test cases."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "How does one come up with prefix sum + binary search intuition?"
                    },
                    {
                        "username": "yooyepyoo",
                        "content": "for target = 11\\nand nums =[1,2,3,4,5]\\nanswer should be 0 but in test cases its 3 can someone explain how?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "subarray with sum value **greater** than or equal to 11\n- [1,2,3,4,5] 15 >= 11\n- [2,3,4,5] 14 >= 11\n- [3,4,5] 12 >= 11\n\nthe min subarray is [3,4,5] so the answer is 3"
                    },
                    {
                        "username": "SG-C",
                        "content": "Yesss ! back to back sliding window questions"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "why they don\\'t describe that the sub array should be continuous"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement for minimum size subarray, the term \"subarray\" implicitly refers to a contiguous segment of the array. By definition, a subarray is a contiguous subset of an array, which means that the elements in the subarray must be in the same order they appear in the original array, with no breaks or gaps. \\n\\nSo, if you see a problem that asks for a \"subarray,\" you can assume that it is asking for a contiguous segment unless it explicitly specifies otherwise. Therefore, it is not necessary for every problem to explicitly state that the subarray should be contiguous. If non-contiguous subsets of an array are allowed, the problem will typically use the term \"subsequence\" instead of \"subarray.\""
                    },
                    {
                        "username": "seeker_747",
                        "content": "very good problem on arrays , it took O(2N) complexity to solve , can anyone tell me a better way to solve it.My Approach is based on two pointers ,and i am shrinking the window once i get more or equal to the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of using a sliding window with two pointers is a good one and it is actually one of the most optimal ways to solve this problem! This method allows you to scan through the array once, making it a O(n) time complexity solution, where n is the number of elements in the array.\\n\\nHere\\'s a little clarification on why it\\'s O(n) and not O(2n): \\n\\nIn Big O notation, we drop constants. This is because Big O notation describes the rate of growth of an algorithm\\'s runtime, rather than the exact runtime. So even if each element of the array might be visited twice (once when expanding the window, and once when shrinking), we still consider this to be linear time complexity, or O(n), as the number of operations grows linearly with the size of the input array. \\n\\nIf you want to further optimize this problem, you could consider optimizing the space complexity if you\\'re storing extra data. But in terms of time complexity, the two-pointer sliding window approach is considered optimal for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I am really off my game today. This is just a straightforward sliding window problem but it took me all day to get the logic right."
                    },
                    {
                        "username": "meeseeks_san",
                        "content": "This should definitely be marked as an easy question."
                    },
                    {
                        "username": "rohanlalwani0810",
                        "content": "For the last test case you need to use INT_MAX in C++"
                    }
                ]
            },
            {
                "id": 1958462,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "It should be an easy problem. \\n**Hint** - Use Sliding Window Technique"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "just failed 1 test cases."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "How does one come up with prefix sum + binary search intuition?"
                    },
                    {
                        "username": "yooyepyoo",
                        "content": "for target = 11\\nand nums =[1,2,3,4,5]\\nanswer should be 0 but in test cases its 3 can someone explain how?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "subarray with sum value **greater** than or equal to 11\n- [1,2,3,4,5] 15 >= 11\n- [2,3,4,5] 14 >= 11\n- [3,4,5] 12 >= 11\n\nthe min subarray is [3,4,5] so the answer is 3"
                    },
                    {
                        "username": "SG-C",
                        "content": "Yesss ! back to back sliding window questions"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "why they don\\'t describe that the sub array should be continuous"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement for minimum size subarray, the term \"subarray\" implicitly refers to a contiguous segment of the array. By definition, a subarray is a contiguous subset of an array, which means that the elements in the subarray must be in the same order they appear in the original array, with no breaks or gaps. \\n\\nSo, if you see a problem that asks for a \"subarray,\" you can assume that it is asking for a contiguous segment unless it explicitly specifies otherwise. Therefore, it is not necessary for every problem to explicitly state that the subarray should be contiguous. If non-contiguous subsets of an array are allowed, the problem will typically use the term \"subsequence\" instead of \"subarray.\""
                    },
                    {
                        "username": "seeker_747",
                        "content": "very good problem on arrays , it took O(2N) complexity to solve , can anyone tell me a better way to solve it.My Approach is based on two pointers ,and i am shrinking the window once i get more or equal to the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of using a sliding window with two pointers is a good one and it is actually one of the most optimal ways to solve this problem! This method allows you to scan through the array once, making it a O(n) time complexity solution, where n is the number of elements in the array.\\n\\nHere\\'s a little clarification on why it\\'s O(n) and not O(2n): \\n\\nIn Big O notation, we drop constants. This is because Big O notation describes the rate of growth of an algorithm\\'s runtime, rather than the exact runtime. So even if each element of the array might be visited twice (once when expanding the window, and once when shrinking), we still consider this to be linear time complexity, or O(n), as the number of operations grows linearly with the size of the input array. \\n\\nIf you want to further optimize this problem, you could consider optimizing the space complexity if you\\'re storing extra data. But in terms of time complexity, the two-pointer sliding window approach is considered optimal for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I am really off my game today. This is just a straightforward sliding window problem but it took me all day to get the logic right."
                    },
                    {
                        "username": "meeseeks_san",
                        "content": "This should definitely be marked as an easy question."
                    },
                    {
                        "username": "rohanlalwani0810",
                        "content": "For the last test case you need to use INT_MAX in C++"
                    }
                ]
            },
            {
                "id": 1958352,
                "content": [
                    {
                        "username": "hemanth_12",
                        "content": "explain this one to me\\nit is the wrong test case\\n\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nSubarray : [83, 26, 25, 25, 25, 25, 12]\\nOutput : 7\\nExpected : 8"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) Yes, you\\'re right. In the context of this problem, a subarray means a contiguous segment from the original array, so you cannot remove elements in the middle of it. The solution must involve finding a subarray (a consecutive sequence in the array) such that the sum of its elements is equal to or larger than the target. The order of elements in the subarray will be exactly the same as their order in the original array."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is a subarray problem. You can\\'t delete elements in the middle."
                    },
                    {
                        "username": "sam2611",
                        "content": "If you have already solved this problem, do not submit as it is. Just without having a look at the code reset to default and check how much you still remember. (Best way of revising questions is leetcode daily challenges) \\u270C"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "minimal length of a subarray whose sum is <h1><b>greater</b></h1> than or equal to target"
                    },
                    {
                        "username": "kunal-j",
                        "content": "seems like it is the week of subarrays!"
                    },
                    {
                        "username": "Burrito1510",
                        "content": "I\\'m trying my hand in backtracking (it\\'s not a topic I\\'m very confident in), and I\\'m unsure if this question can be solved through the approach? \\n\\nThe test case I\\'m getting stuck in is nums=[12,28,83,4,25,26,25,2,25,25,25,12]\\nand target = 213.\\n\\nHere\\'s the code: \\n\\nint result=INT_MAX;\\n    void loop(int index, int target, vector<int>&nums, int count){\\n        if(target<=0){\\n            result=min(result,count);\\n            return;\\n        } \\n        for(int i=index;i<nums.size();i++){\\n            target-=nums[i];\\n            count+=1;\\n            loop(i+1,target,nums,count);\\n            target+=nums[i];\\n            count-=1;\\n        }\\n        return;\\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    loop(0,target,nums,0);\\n    return result==INT_MAX?0:result;\\n    }\\n\\nI\\'d be grateful if anyone can point out the mistake!"
                    },
                    {
                        "username": "bparanj",
                        "content": "While backtracking can theoretically solve this problem, it is not the most efficient approach due to the high time complexity (O(2^n) in the worst case, where n is the number of elements in the array). The backtracking approach tries all possible combinations of subarrays, which is not necessary for this problem and results in a lot of redundant computation.\\n\\nIn your code, the issue arises from the fact that you\\'re recursively exploring all possible subarrays starting from each index in the array. But the problem specifically asks for contiguous subarrays. Your approach doesn\\'t ensure contiguity because it explores all subarrays starting from each index, without considering whether these subarrays are contiguous or not.\\n\\nThe more optimal way to solve this problem is by using a \"sliding window\" or \"two pointers\" approach, which solves the problem in O(n) time. \\n\\nHere\\'s the general idea of the sliding window approach:\\n\\n1. Start with a window that includes the first element of the array.\\n2. Then expand the window from the right until the sum of the window elements is equal to or greater than the target.\\n3. When the sum becomes equal to or greater than the target, try to shrink the window from the left side as much as possible while maintaining a sum that is equal to or greater than the target.\\n4. Keep track of the minimum length of such a window during this process.\\n5. Move the right end of the window one position at a time, repeating steps 3 and 4, until the right end reaches the last element of the array.\\n\\nThis approach ensures that you\\'re only looking at contiguous subarrays and that you\\'re efficiently minimizing the window size whenever possible.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem lies on how you use the for loop. the problem want us to find a subarray but what your code does is find the minimum amount of number  you can take to reach the target (subsequence).\n\neg\nusing testcase [12,28,83,4,25,26,25,2,25,25,25,12]\ntarget = 213\n- first loop (target = 213)\ntarget -= 12 \ncount += 1;\nloop()\n\n- second loop (target = 201, count = 1)\ntarget -= 28\ncount+= 1\nloop() we skip this one\ntarget += 28 (start of the problem)\ncount -= 1\nNEXT FOR LOOP iteration (target = 201, count = 1)\ntarget -= 83\ncount += 1\nloop() (here's the problem)\n\nin the second recursion loop the target is reduced by 12 and 83 which is not a subarray but a subsequence.\n\ni think backtracking approach will give you TLE because of the constraint of nums.length 10^5 (i try it)"
                    },
                    {
                        "username": "SpaghettiCode92",
                        "content": "Testcase 13/20 \\n\\nTarget = 20\\nnums = [2,16,14,15]\\n\\nMy answer = 0\\nExpected = 2\\n\\nAm I missing something here or is the testcase incorrect?"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "We have to check \"Greater or equal to target\"  not only equal!!!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "16 and 14 is one sub array whose sum is grater than 20 the other one is 14 ,15 you can take any one both of length 2 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE with 20/20 testcases passed... Last Executed input target =\\n\\nwhat\\'s wrong?????"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just a little unlucky, try again!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i also get the same error ..just submit twice ,,generally the solution is wrong somewhere but leetcode shows all test cases passed with tle.."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "May be you are using Brute force optimise your code it is taking more time than allowed "
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "why pick and non pick concept is not apply? can anyone resolve ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"pick and non-pick\" concept, typically used in backtracking and recursive solutions, involves making a decision at each step whether to \"pick\" or \"not pick\" an element for a particular solution.\\n\\nIn this problem, however, we are not selecting individual, non-contiguous elements from the array. Instead, we\\'re trying to find the smallest contiguous subarray with a sum greater than or equal to the target. The elements in a contiguous subarray are inherently linked -- you can\\'t pick one and not pick the one next to it, because doing so would break the contiguity of the subarray.\\n\\nTherefore, the concept of \"pick and non-pick\" doesn\\'t apply here. Instead, the problem is more suited to a \"sliding window\" or \"two pointers\" approach, where you adjust the start and end points of the subarray to find the smallest subarray that meets the criteria.\\n\\nThe sliding window approach involves initializing two pointers at the beginning of the array and then moving them through the array such that the sum of the subarray between the two pointers is as close to the target as possible. The window (subarray) \"slides\" through the array, growing and shrinking as necessary, to find the smallest subarray with a sum >= target."
                    },
                    {
                        "username": "Ultron03",
                        "content": "because it is question related to subarray not subsequence .. in the pick and non pick you will end up getting a subsequence which will not be continuous,,"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because it\\'s subarray which is contiguous so you cannot skip any element you must add each number as they appear in vector"
                    },
                    {
                        "username": "Ultron03",
                        "content": "window kuch jyada hi slide kr rhi h ..\nday 2  #sliding window\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I saw the editorial cuz I didnt know any way to solve this problem cuz the concept used here goes way above my mind.....Gotta go practice some more !!"
                    }
                ]
            },
            {
                "id": 1958328,
                "content": [
                    {
                        "username": "hemanth_12",
                        "content": "explain this one to me\\nit is the wrong test case\\n\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nSubarray : [83, 26, 25, 25, 25, 25, 12]\\nOutput : 7\\nExpected : 8"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) Yes, you\\'re right. In the context of this problem, a subarray means a contiguous segment from the original array, so you cannot remove elements in the middle of it. The solution must involve finding a subarray (a consecutive sequence in the array) such that the sum of its elements is equal to or larger than the target. The order of elements in the subarray will be exactly the same as their order in the original array."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is a subarray problem. You can\\'t delete elements in the middle."
                    },
                    {
                        "username": "sam2611",
                        "content": "If you have already solved this problem, do not submit as it is. Just without having a look at the code reset to default and check how much you still remember. (Best way of revising questions is leetcode daily challenges) \\u270C"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "minimal length of a subarray whose sum is <h1><b>greater</b></h1> than or equal to target"
                    },
                    {
                        "username": "kunal-j",
                        "content": "seems like it is the week of subarrays!"
                    },
                    {
                        "username": "Burrito1510",
                        "content": "I\\'m trying my hand in backtracking (it\\'s not a topic I\\'m very confident in), and I\\'m unsure if this question can be solved through the approach? \\n\\nThe test case I\\'m getting stuck in is nums=[12,28,83,4,25,26,25,2,25,25,25,12]\\nand target = 213.\\n\\nHere\\'s the code: \\n\\nint result=INT_MAX;\\n    void loop(int index, int target, vector<int>&nums, int count){\\n        if(target<=0){\\n            result=min(result,count);\\n            return;\\n        } \\n        for(int i=index;i<nums.size();i++){\\n            target-=nums[i];\\n            count+=1;\\n            loop(i+1,target,nums,count);\\n            target+=nums[i];\\n            count-=1;\\n        }\\n        return;\\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    loop(0,target,nums,0);\\n    return result==INT_MAX?0:result;\\n    }\\n\\nI\\'d be grateful if anyone can point out the mistake!"
                    },
                    {
                        "username": "bparanj",
                        "content": "While backtracking can theoretically solve this problem, it is not the most efficient approach due to the high time complexity (O(2^n) in the worst case, where n is the number of elements in the array). The backtracking approach tries all possible combinations of subarrays, which is not necessary for this problem and results in a lot of redundant computation.\\n\\nIn your code, the issue arises from the fact that you\\'re recursively exploring all possible subarrays starting from each index in the array. But the problem specifically asks for contiguous subarrays. Your approach doesn\\'t ensure contiguity because it explores all subarrays starting from each index, without considering whether these subarrays are contiguous or not.\\n\\nThe more optimal way to solve this problem is by using a \"sliding window\" or \"two pointers\" approach, which solves the problem in O(n) time. \\n\\nHere\\'s the general idea of the sliding window approach:\\n\\n1. Start with a window that includes the first element of the array.\\n2. Then expand the window from the right until the sum of the window elements is equal to or greater than the target.\\n3. When the sum becomes equal to or greater than the target, try to shrink the window from the left side as much as possible while maintaining a sum that is equal to or greater than the target.\\n4. Keep track of the minimum length of such a window during this process.\\n5. Move the right end of the window one position at a time, repeating steps 3 and 4, until the right end reaches the last element of the array.\\n\\nThis approach ensures that you\\'re only looking at contiguous subarrays and that you\\'re efficiently minimizing the window size whenever possible.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem lies on how you use the for loop. the problem want us to find a subarray but what your code does is find the minimum amount of number  you can take to reach the target (subsequence).\n\neg\nusing testcase [12,28,83,4,25,26,25,2,25,25,25,12]\ntarget = 213\n- first loop (target = 213)\ntarget -= 12 \ncount += 1;\nloop()\n\n- second loop (target = 201, count = 1)\ntarget -= 28\ncount+= 1\nloop() we skip this one\ntarget += 28 (start of the problem)\ncount -= 1\nNEXT FOR LOOP iteration (target = 201, count = 1)\ntarget -= 83\ncount += 1\nloop() (here's the problem)\n\nin the second recursion loop the target is reduced by 12 and 83 which is not a subarray but a subsequence.\n\ni think backtracking approach will give you TLE because of the constraint of nums.length 10^5 (i try it)"
                    },
                    {
                        "username": "SpaghettiCode92",
                        "content": "Testcase 13/20 \\n\\nTarget = 20\\nnums = [2,16,14,15]\\n\\nMy answer = 0\\nExpected = 2\\n\\nAm I missing something here or is the testcase incorrect?"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "We have to check \"Greater or equal to target\"  not only equal!!!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "16 and 14 is one sub array whose sum is grater than 20 the other one is 14 ,15 you can take any one both of length 2 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE with 20/20 testcases passed... Last Executed input target =\\n\\nwhat\\'s wrong?????"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just a little unlucky, try again!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i also get the same error ..just submit twice ,,generally the solution is wrong somewhere but leetcode shows all test cases passed with tle.."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "May be you are using Brute force optimise your code it is taking more time than allowed "
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "why pick and non pick concept is not apply? can anyone resolve ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"pick and non-pick\" concept, typically used in backtracking and recursive solutions, involves making a decision at each step whether to \"pick\" or \"not pick\" an element for a particular solution.\\n\\nIn this problem, however, we are not selecting individual, non-contiguous elements from the array. Instead, we\\'re trying to find the smallest contiguous subarray with a sum greater than or equal to the target. The elements in a contiguous subarray are inherently linked -- you can\\'t pick one and not pick the one next to it, because doing so would break the contiguity of the subarray.\\n\\nTherefore, the concept of \"pick and non-pick\" doesn\\'t apply here. Instead, the problem is more suited to a \"sliding window\" or \"two pointers\" approach, where you adjust the start and end points of the subarray to find the smallest subarray that meets the criteria.\\n\\nThe sliding window approach involves initializing two pointers at the beginning of the array and then moving them through the array such that the sum of the subarray between the two pointers is as close to the target as possible. The window (subarray) \"slides\" through the array, growing and shrinking as necessary, to find the smallest subarray with a sum >= target."
                    },
                    {
                        "username": "Ultron03",
                        "content": "because it is question related to subarray not subsequence .. in the pick and non pick you will end up getting a subsequence which will not be continuous,,"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because it\\'s subarray which is contiguous so you cannot skip any element you must add each number as they appear in vector"
                    },
                    {
                        "username": "Ultron03",
                        "content": "window kuch jyada hi slide kr rhi h ..\nday 2  #sliding window\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I saw the editorial cuz I didnt know any way to solve this problem cuz the concept used here goes way above my mind.....Gotta go practice some more !!"
                    }
                ]
            },
            {
                "id": 1958289,
                "content": [
                    {
                        "username": "hemanth_12",
                        "content": "explain this one to me\\nit is the wrong test case\\n\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nSubarray : [83, 26, 25, 25, 25, 25, 12]\\nOutput : 7\\nExpected : 8"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) Yes, you\\'re right. In the context of this problem, a subarray means a contiguous segment from the original array, so you cannot remove elements in the middle of it. The solution must involve finding a subarray (a consecutive sequence in the array) such that the sum of its elements is equal to or larger than the target. The order of elements in the subarray will be exactly the same as their order in the original array."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is a subarray problem. You can\\'t delete elements in the middle."
                    },
                    {
                        "username": "sam2611",
                        "content": "If you have already solved this problem, do not submit as it is. Just without having a look at the code reset to default and check how much you still remember. (Best way of revising questions is leetcode daily challenges) \\u270C"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "minimal length of a subarray whose sum is <h1><b>greater</b></h1> than or equal to target"
                    },
                    {
                        "username": "kunal-j",
                        "content": "seems like it is the week of subarrays!"
                    },
                    {
                        "username": "Burrito1510",
                        "content": "I\\'m trying my hand in backtracking (it\\'s not a topic I\\'m very confident in), and I\\'m unsure if this question can be solved through the approach? \\n\\nThe test case I\\'m getting stuck in is nums=[12,28,83,4,25,26,25,2,25,25,25,12]\\nand target = 213.\\n\\nHere\\'s the code: \\n\\nint result=INT_MAX;\\n    void loop(int index, int target, vector<int>&nums, int count){\\n        if(target<=0){\\n            result=min(result,count);\\n            return;\\n        } \\n        for(int i=index;i<nums.size();i++){\\n            target-=nums[i];\\n            count+=1;\\n            loop(i+1,target,nums,count);\\n            target+=nums[i];\\n            count-=1;\\n        }\\n        return;\\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    loop(0,target,nums,0);\\n    return result==INT_MAX?0:result;\\n    }\\n\\nI\\'d be grateful if anyone can point out the mistake!"
                    },
                    {
                        "username": "bparanj",
                        "content": "While backtracking can theoretically solve this problem, it is not the most efficient approach due to the high time complexity (O(2^n) in the worst case, where n is the number of elements in the array). The backtracking approach tries all possible combinations of subarrays, which is not necessary for this problem and results in a lot of redundant computation.\\n\\nIn your code, the issue arises from the fact that you\\'re recursively exploring all possible subarrays starting from each index in the array. But the problem specifically asks for contiguous subarrays. Your approach doesn\\'t ensure contiguity because it explores all subarrays starting from each index, without considering whether these subarrays are contiguous or not.\\n\\nThe more optimal way to solve this problem is by using a \"sliding window\" or \"two pointers\" approach, which solves the problem in O(n) time. \\n\\nHere\\'s the general idea of the sliding window approach:\\n\\n1. Start with a window that includes the first element of the array.\\n2. Then expand the window from the right until the sum of the window elements is equal to or greater than the target.\\n3. When the sum becomes equal to or greater than the target, try to shrink the window from the left side as much as possible while maintaining a sum that is equal to or greater than the target.\\n4. Keep track of the minimum length of such a window during this process.\\n5. Move the right end of the window one position at a time, repeating steps 3 and 4, until the right end reaches the last element of the array.\\n\\nThis approach ensures that you\\'re only looking at contiguous subarrays and that you\\'re efficiently minimizing the window size whenever possible.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem lies on how you use the for loop. the problem want us to find a subarray but what your code does is find the minimum amount of number  you can take to reach the target (subsequence).\n\neg\nusing testcase [12,28,83,4,25,26,25,2,25,25,25,12]\ntarget = 213\n- first loop (target = 213)\ntarget -= 12 \ncount += 1;\nloop()\n\n- second loop (target = 201, count = 1)\ntarget -= 28\ncount+= 1\nloop() we skip this one\ntarget += 28 (start of the problem)\ncount -= 1\nNEXT FOR LOOP iteration (target = 201, count = 1)\ntarget -= 83\ncount += 1\nloop() (here's the problem)\n\nin the second recursion loop the target is reduced by 12 and 83 which is not a subarray but a subsequence.\n\ni think backtracking approach will give you TLE because of the constraint of nums.length 10^5 (i try it)"
                    },
                    {
                        "username": "SpaghettiCode92",
                        "content": "Testcase 13/20 \\n\\nTarget = 20\\nnums = [2,16,14,15]\\n\\nMy answer = 0\\nExpected = 2\\n\\nAm I missing something here or is the testcase incorrect?"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "We have to check \"Greater or equal to target\"  not only equal!!!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "16 and 14 is one sub array whose sum is grater than 20 the other one is 14 ,15 you can take any one both of length 2 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE with 20/20 testcases passed... Last Executed input target =\\n\\nwhat\\'s wrong?????"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just a little unlucky, try again!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i also get the same error ..just submit twice ,,generally the solution is wrong somewhere but leetcode shows all test cases passed with tle.."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "May be you are using Brute force optimise your code it is taking more time than allowed "
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "why pick and non pick concept is not apply? can anyone resolve ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"pick and non-pick\" concept, typically used in backtracking and recursive solutions, involves making a decision at each step whether to \"pick\" or \"not pick\" an element for a particular solution.\\n\\nIn this problem, however, we are not selecting individual, non-contiguous elements from the array. Instead, we\\'re trying to find the smallest contiguous subarray with a sum greater than or equal to the target. The elements in a contiguous subarray are inherently linked -- you can\\'t pick one and not pick the one next to it, because doing so would break the contiguity of the subarray.\\n\\nTherefore, the concept of \"pick and non-pick\" doesn\\'t apply here. Instead, the problem is more suited to a \"sliding window\" or \"two pointers\" approach, where you adjust the start and end points of the subarray to find the smallest subarray that meets the criteria.\\n\\nThe sliding window approach involves initializing two pointers at the beginning of the array and then moving them through the array such that the sum of the subarray between the two pointers is as close to the target as possible. The window (subarray) \"slides\" through the array, growing and shrinking as necessary, to find the smallest subarray with a sum >= target."
                    },
                    {
                        "username": "Ultron03",
                        "content": "because it is question related to subarray not subsequence .. in the pick and non pick you will end up getting a subsequence which will not be continuous,,"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because it\\'s subarray which is contiguous so you cannot skip any element you must add each number as they appear in vector"
                    },
                    {
                        "username": "Ultron03",
                        "content": "window kuch jyada hi slide kr rhi h ..\nday 2  #sliding window\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I saw the editorial cuz I didnt know any way to solve this problem cuz the concept used here goes way above my mind.....Gotta go practice some more !!"
                    }
                ]
            },
            {
                "id": 1958243,
                "content": [
                    {
                        "username": "hemanth_12",
                        "content": "explain this one to me\\nit is the wrong test case\\n\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nSubarray : [83, 26, 25, 25, 25, 25, 12]\\nOutput : 7\\nExpected : 8"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) Yes, you\\'re right. In the context of this problem, a subarray means a contiguous segment from the original array, so you cannot remove elements in the middle of it. The solution must involve finding a subarray (a consecutive sequence in the array) such that the sum of its elements is equal to or larger than the target. The order of elements in the subarray will be exactly the same as their order in the original array."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is a subarray problem. You can\\'t delete elements in the middle."
                    },
                    {
                        "username": "sam2611",
                        "content": "If you have already solved this problem, do not submit as it is. Just without having a look at the code reset to default and check how much you still remember. (Best way of revising questions is leetcode daily challenges) \\u270C"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "minimal length of a subarray whose sum is <h1><b>greater</b></h1> than or equal to target"
                    },
                    {
                        "username": "kunal-j",
                        "content": "seems like it is the week of subarrays!"
                    },
                    {
                        "username": "Burrito1510",
                        "content": "I\\'m trying my hand in backtracking (it\\'s not a topic I\\'m very confident in), and I\\'m unsure if this question can be solved through the approach? \\n\\nThe test case I\\'m getting stuck in is nums=[12,28,83,4,25,26,25,2,25,25,25,12]\\nand target = 213.\\n\\nHere\\'s the code: \\n\\nint result=INT_MAX;\\n    void loop(int index, int target, vector<int>&nums, int count){\\n        if(target<=0){\\n            result=min(result,count);\\n            return;\\n        } \\n        for(int i=index;i<nums.size();i++){\\n            target-=nums[i];\\n            count+=1;\\n            loop(i+1,target,nums,count);\\n            target+=nums[i];\\n            count-=1;\\n        }\\n        return;\\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    loop(0,target,nums,0);\\n    return result==INT_MAX?0:result;\\n    }\\n\\nI\\'d be grateful if anyone can point out the mistake!"
                    },
                    {
                        "username": "bparanj",
                        "content": "While backtracking can theoretically solve this problem, it is not the most efficient approach due to the high time complexity (O(2^n) in the worst case, where n is the number of elements in the array). The backtracking approach tries all possible combinations of subarrays, which is not necessary for this problem and results in a lot of redundant computation.\\n\\nIn your code, the issue arises from the fact that you\\'re recursively exploring all possible subarrays starting from each index in the array. But the problem specifically asks for contiguous subarrays. Your approach doesn\\'t ensure contiguity because it explores all subarrays starting from each index, without considering whether these subarrays are contiguous or not.\\n\\nThe more optimal way to solve this problem is by using a \"sliding window\" or \"two pointers\" approach, which solves the problem in O(n) time. \\n\\nHere\\'s the general idea of the sliding window approach:\\n\\n1. Start with a window that includes the first element of the array.\\n2. Then expand the window from the right until the sum of the window elements is equal to or greater than the target.\\n3. When the sum becomes equal to or greater than the target, try to shrink the window from the left side as much as possible while maintaining a sum that is equal to or greater than the target.\\n4. Keep track of the minimum length of such a window during this process.\\n5. Move the right end of the window one position at a time, repeating steps 3 and 4, until the right end reaches the last element of the array.\\n\\nThis approach ensures that you\\'re only looking at contiguous subarrays and that you\\'re efficiently minimizing the window size whenever possible.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem lies on how you use the for loop. the problem want us to find a subarray but what your code does is find the minimum amount of number  you can take to reach the target (subsequence).\n\neg\nusing testcase [12,28,83,4,25,26,25,2,25,25,25,12]\ntarget = 213\n- first loop (target = 213)\ntarget -= 12 \ncount += 1;\nloop()\n\n- second loop (target = 201, count = 1)\ntarget -= 28\ncount+= 1\nloop() we skip this one\ntarget += 28 (start of the problem)\ncount -= 1\nNEXT FOR LOOP iteration (target = 201, count = 1)\ntarget -= 83\ncount += 1\nloop() (here's the problem)\n\nin the second recursion loop the target is reduced by 12 and 83 which is not a subarray but a subsequence.\n\ni think backtracking approach will give you TLE because of the constraint of nums.length 10^5 (i try it)"
                    },
                    {
                        "username": "SpaghettiCode92",
                        "content": "Testcase 13/20 \\n\\nTarget = 20\\nnums = [2,16,14,15]\\n\\nMy answer = 0\\nExpected = 2\\n\\nAm I missing something here or is the testcase incorrect?"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "We have to check \"Greater or equal to target\"  not only equal!!!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "16 and 14 is one sub array whose sum is grater than 20 the other one is 14 ,15 you can take any one both of length 2 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE with 20/20 testcases passed... Last Executed input target =\\n\\nwhat\\'s wrong?????"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just a little unlucky, try again!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i also get the same error ..just submit twice ,,generally the solution is wrong somewhere but leetcode shows all test cases passed with tle.."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "May be you are using Brute force optimise your code it is taking more time than allowed "
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "why pick and non pick concept is not apply? can anyone resolve ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"pick and non-pick\" concept, typically used in backtracking and recursive solutions, involves making a decision at each step whether to \"pick\" or \"not pick\" an element for a particular solution.\\n\\nIn this problem, however, we are not selecting individual, non-contiguous elements from the array. Instead, we\\'re trying to find the smallest contiguous subarray with a sum greater than or equal to the target. The elements in a contiguous subarray are inherently linked -- you can\\'t pick one and not pick the one next to it, because doing so would break the contiguity of the subarray.\\n\\nTherefore, the concept of \"pick and non-pick\" doesn\\'t apply here. Instead, the problem is more suited to a \"sliding window\" or \"two pointers\" approach, where you adjust the start and end points of the subarray to find the smallest subarray that meets the criteria.\\n\\nThe sliding window approach involves initializing two pointers at the beginning of the array and then moving them through the array such that the sum of the subarray between the two pointers is as close to the target as possible. The window (subarray) \"slides\" through the array, growing and shrinking as necessary, to find the smallest subarray with a sum >= target."
                    },
                    {
                        "username": "Ultron03",
                        "content": "because it is question related to subarray not subsequence .. in the pick and non pick you will end up getting a subsequence which will not be continuous,,"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because it\\'s subarray which is contiguous so you cannot skip any element you must add each number as they appear in vector"
                    },
                    {
                        "username": "Ultron03",
                        "content": "window kuch jyada hi slide kr rhi h ..\nday 2  #sliding window\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I saw the editorial cuz I didnt know any way to solve this problem cuz the concept used here goes way above my mind.....Gotta go practice some more !!"
                    }
                ]
            },
            {
                "id": 1958218,
                "content": [
                    {
                        "username": "hemanth_12",
                        "content": "explain this one to me\\nit is the wrong test case\\n\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nSubarray : [83, 26, 25, 25, 25, 25, 12]\\nOutput : 7\\nExpected : 8"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) Yes, you\\'re right. In the context of this problem, a subarray means a contiguous segment from the original array, so you cannot remove elements in the middle of it. The solution must involve finding a subarray (a consecutive sequence in the array) such that the sum of its elements is equal to or larger than the target. The order of elements in the subarray will be exactly the same as their order in the original array."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is a subarray problem. You can\\'t delete elements in the middle."
                    },
                    {
                        "username": "sam2611",
                        "content": "If you have already solved this problem, do not submit as it is. Just without having a look at the code reset to default and check how much you still remember. (Best way of revising questions is leetcode daily challenges) \\u270C"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "minimal length of a subarray whose sum is <h1><b>greater</b></h1> than or equal to target"
                    },
                    {
                        "username": "kunal-j",
                        "content": "seems like it is the week of subarrays!"
                    },
                    {
                        "username": "Burrito1510",
                        "content": "I\\'m trying my hand in backtracking (it\\'s not a topic I\\'m very confident in), and I\\'m unsure if this question can be solved through the approach? \\n\\nThe test case I\\'m getting stuck in is nums=[12,28,83,4,25,26,25,2,25,25,25,12]\\nand target = 213.\\n\\nHere\\'s the code: \\n\\nint result=INT_MAX;\\n    void loop(int index, int target, vector<int>&nums, int count){\\n        if(target<=0){\\n            result=min(result,count);\\n            return;\\n        } \\n        for(int i=index;i<nums.size();i++){\\n            target-=nums[i];\\n            count+=1;\\n            loop(i+1,target,nums,count);\\n            target+=nums[i];\\n            count-=1;\\n        }\\n        return;\\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    loop(0,target,nums,0);\\n    return result==INT_MAX?0:result;\\n    }\\n\\nI\\'d be grateful if anyone can point out the mistake!"
                    },
                    {
                        "username": "bparanj",
                        "content": "While backtracking can theoretically solve this problem, it is not the most efficient approach due to the high time complexity (O(2^n) in the worst case, where n is the number of elements in the array). The backtracking approach tries all possible combinations of subarrays, which is not necessary for this problem and results in a lot of redundant computation.\\n\\nIn your code, the issue arises from the fact that you\\'re recursively exploring all possible subarrays starting from each index in the array. But the problem specifically asks for contiguous subarrays. Your approach doesn\\'t ensure contiguity because it explores all subarrays starting from each index, without considering whether these subarrays are contiguous or not.\\n\\nThe more optimal way to solve this problem is by using a \"sliding window\" or \"two pointers\" approach, which solves the problem in O(n) time. \\n\\nHere\\'s the general idea of the sliding window approach:\\n\\n1. Start with a window that includes the first element of the array.\\n2. Then expand the window from the right until the sum of the window elements is equal to or greater than the target.\\n3. When the sum becomes equal to or greater than the target, try to shrink the window from the left side as much as possible while maintaining a sum that is equal to or greater than the target.\\n4. Keep track of the minimum length of such a window during this process.\\n5. Move the right end of the window one position at a time, repeating steps 3 and 4, until the right end reaches the last element of the array.\\n\\nThis approach ensures that you\\'re only looking at contiguous subarrays and that you\\'re efficiently minimizing the window size whenever possible.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem lies on how you use the for loop. the problem want us to find a subarray but what your code does is find the minimum amount of number  you can take to reach the target (subsequence).\n\neg\nusing testcase [12,28,83,4,25,26,25,2,25,25,25,12]\ntarget = 213\n- first loop (target = 213)\ntarget -= 12 \ncount += 1;\nloop()\n\n- second loop (target = 201, count = 1)\ntarget -= 28\ncount+= 1\nloop() we skip this one\ntarget += 28 (start of the problem)\ncount -= 1\nNEXT FOR LOOP iteration (target = 201, count = 1)\ntarget -= 83\ncount += 1\nloop() (here's the problem)\n\nin the second recursion loop the target is reduced by 12 and 83 which is not a subarray but a subsequence.\n\ni think backtracking approach will give you TLE because of the constraint of nums.length 10^5 (i try it)"
                    },
                    {
                        "username": "SpaghettiCode92",
                        "content": "Testcase 13/20 \\n\\nTarget = 20\\nnums = [2,16,14,15]\\n\\nMy answer = 0\\nExpected = 2\\n\\nAm I missing something here or is the testcase incorrect?"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "We have to check \"Greater or equal to target\"  not only equal!!!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "16 and 14 is one sub array whose sum is grater than 20 the other one is 14 ,15 you can take any one both of length 2 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE with 20/20 testcases passed... Last Executed input target =\\n\\nwhat\\'s wrong?????"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just a little unlucky, try again!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i also get the same error ..just submit twice ,,generally the solution is wrong somewhere but leetcode shows all test cases passed with tle.."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "May be you are using Brute force optimise your code it is taking more time than allowed "
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "why pick and non pick concept is not apply? can anyone resolve ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"pick and non-pick\" concept, typically used in backtracking and recursive solutions, involves making a decision at each step whether to \"pick\" or \"not pick\" an element for a particular solution.\\n\\nIn this problem, however, we are not selecting individual, non-contiguous elements from the array. Instead, we\\'re trying to find the smallest contiguous subarray with a sum greater than or equal to the target. The elements in a contiguous subarray are inherently linked -- you can\\'t pick one and not pick the one next to it, because doing so would break the contiguity of the subarray.\\n\\nTherefore, the concept of \"pick and non-pick\" doesn\\'t apply here. Instead, the problem is more suited to a \"sliding window\" or \"two pointers\" approach, where you adjust the start and end points of the subarray to find the smallest subarray that meets the criteria.\\n\\nThe sliding window approach involves initializing two pointers at the beginning of the array and then moving them through the array such that the sum of the subarray between the two pointers is as close to the target as possible. The window (subarray) \"slides\" through the array, growing and shrinking as necessary, to find the smallest subarray with a sum >= target."
                    },
                    {
                        "username": "Ultron03",
                        "content": "because it is question related to subarray not subsequence .. in the pick and non pick you will end up getting a subsequence which will not be continuous,,"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because it\\'s subarray which is contiguous so you cannot skip any element you must add each number as they appear in vector"
                    },
                    {
                        "username": "Ultron03",
                        "content": "window kuch jyada hi slide kr rhi h ..\nday 2  #sliding window\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I saw the editorial cuz I didnt know any way to solve this problem cuz the concept used here goes way above my mind.....Gotta go practice some more !!"
                    }
                ]
            },
            {
                "id": 1958209,
                "content": [
                    {
                        "username": "hemanth_12",
                        "content": "explain this one to me\\nit is the wrong test case\\n\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nSubarray : [83, 26, 25, 25, 25, 25, 12]\\nOutput : 7\\nExpected : 8"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) Yes, you\\'re right. In the context of this problem, a subarray means a contiguous segment from the original array, so you cannot remove elements in the middle of it. The solution must involve finding a subarray (a consecutive sequence in the array) such that the sum of its elements is equal to or larger than the target. The order of elements in the subarray will be exactly the same as their order in the original array."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is a subarray problem. You can\\'t delete elements in the middle."
                    },
                    {
                        "username": "sam2611",
                        "content": "If you have already solved this problem, do not submit as it is. Just without having a look at the code reset to default and check how much you still remember. (Best way of revising questions is leetcode daily challenges) \\u270C"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "minimal length of a subarray whose sum is <h1><b>greater</b></h1> than or equal to target"
                    },
                    {
                        "username": "kunal-j",
                        "content": "seems like it is the week of subarrays!"
                    },
                    {
                        "username": "Burrito1510",
                        "content": "I\\'m trying my hand in backtracking (it\\'s not a topic I\\'m very confident in), and I\\'m unsure if this question can be solved through the approach? \\n\\nThe test case I\\'m getting stuck in is nums=[12,28,83,4,25,26,25,2,25,25,25,12]\\nand target = 213.\\n\\nHere\\'s the code: \\n\\nint result=INT_MAX;\\n    void loop(int index, int target, vector<int>&nums, int count){\\n        if(target<=0){\\n            result=min(result,count);\\n            return;\\n        } \\n        for(int i=index;i<nums.size();i++){\\n            target-=nums[i];\\n            count+=1;\\n            loop(i+1,target,nums,count);\\n            target+=nums[i];\\n            count-=1;\\n        }\\n        return;\\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    loop(0,target,nums,0);\\n    return result==INT_MAX?0:result;\\n    }\\n\\nI\\'d be grateful if anyone can point out the mistake!"
                    },
                    {
                        "username": "bparanj",
                        "content": "While backtracking can theoretically solve this problem, it is not the most efficient approach due to the high time complexity (O(2^n) in the worst case, where n is the number of elements in the array). The backtracking approach tries all possible combinations of subarrays, which is not necessary for this problem and results in a lot of redundant computation.\\n\\nIn your code, the issue arises from the fact that you\\'re recursively exploring all possible subarrays starting from each index in the array. But the problem specifically asks for contiguous subarrays. Your approach doesn\\'t ensure contiguity because it explores all subarrays starting from each index, without considering whether these subarrays are contiguous or not.\\n\\nThe more optimal way to solve this problem is by using a \"sliding window\" or \"two pointers\" approach, which solves the problem in O(n) time. \\n\\nHere\\'s the general idea of the sliding window approach:\\n\\n1. Start with a window that includes the first element of the array.\\n2. Then expand the window from the right until the sum of the window elements is equal to or greater than the target.\\n3. When the sum becomes equal to or greater than the target, try to shrink the window from the left side as much as possible while maintaining a sum that is equal to or greater than the target.\\n4. Keep track of the minimum length of such a window during this process.\\n5. Move the right end of the window one position at a time, repeating steps 3 and 4, until the right end reaches the last element of the array.\\n\\nThis approach ensures that you\\'re only looking at contiguous subarrays and that you\\'re efficiently minimizing the window size whenever possible.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem lies on how you use the for loop. the problem want us to find a subarray but what your code does is find the minimum amount of number  you can take to reach the target (subsequence).\n\neg\nusing testcase [12,28,83,4,25,26,25,2,25,25,25,12]\ntarget = 213\n- first loop (target = 213)\ntarget -= 12 \ncount += 1;\nloop()\n\n- second loop (target = 201, count = 1)\ntarget -= 28\ncount+= 1\nloop() we skip this one\ntarget += 28 (start of the problem)\ncount -= 1\nNEXT FOR LOOP iteration (target = 201, count = 1)\ntarget -= 83\ncount += 1\nloop() (here's the problem)\n\nin the second recursion loop the target is reduced by 12 and 83 which is not a subarray but a subsequence.\n\ni think backtracking approach will give you TLE because of the constraint of nums.length 10^5 (i try it)"
                    },
                    {
                        "username": "SpaghettiCode92",
                        "content": "Testcase 13/20 \\n\\nTarget = 20\\nnums = [2,16,14,15]\\n\\nMy answer = 0\\nExpected = 2\\n\\nAm I missing something here or is the testcase incorrect?"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "We have to check \"Greater or equal to target\"  not only equal!!!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "16 and 14 is one sub array whose sum is grater than 20 the other one is 14 ,15 you can take any one both of length 2 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE with 20/20 testcases passed... Last Executed input target =\\n\\nwhat\\'s wrong?????"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just a little unlucky, try again!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i also get the same error ..just submit twice ,,generally the solution is wrong somewhere but leetcode shows all test cases passed with tle.."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "May be you are using Brute force optimise your code it is taking more time than allowed "
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "why pick and non pick concept is not apply? can anyone resolve ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"pick and non-pick\" concept, typically used in backtracking and recursive solutions, involves making a decision at each step whether to \"pick\" or \"not pick\" an element for a particular solution.\\n\\nIn this problem, however, we are not selecting individual, non-contiguous elements from the array. Instead, we\\'re trying to find the smallest contiguous subarray with a sum greater than or equal to the target. The elements in a contiguous subarray are inherently linked -- you can\\'t pick one and not pick the one next to it, because doing so would break the contiguity of the subarray.\\n\\nTherefore, the concept of \"pick and non-pick\" doesn\\'t apply here. Instead, the problem is more suited to a \"sliding window\" or \"two pointers\" approach, where you adjust the start and end points of the subarray to find the smallest subarray that meets the criteria.\\n\\nThe sliding window approach involves initializing two pointers at the beginning of the array and then moving them through the array such that the sum of the subarray between the two pointers is as close to the target as possible. The window (subarray) \"slides\" through the array, growing and shrinking as necessary, to find the smallest subarray with a sum >= target."
                    },
                    {
                        "username": "Ultron03",
                        "content": "because it is question related to subarray not subsequence .. in the pick and non pick you will end up getting a subsequence which will not be continuous,,"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because it\\'s subarray which is contiguous so you cannot skip any element you must add each number as they appear in vector"
                    },
                    {
                        "username": "Ultron03",
                        "content": "window kuch jyada hi slide kr rhi h ..\nday 2  #sliding window\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I saw the editorial cuz I didnt know any way to solve this problem cuz the concept used here goes way above my mind.....Gotta go practice some more !!"
                    }
                ]
            },
            {
                "id": 1958182,
                "content": [
                    {
                        "username": "hemanth_12",
                        "content": "explain this one to me\\nit is the wrong test case\\n\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nSubarray : [83, 26, 25, 25, 25, 25, 12]\\nOutput : 7\\nExpected : 8"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) Yes, you\\'re right. In the context of this problem, a subarray means a contiguous segment from the original array, so you cannot remove elements in the middle of it. The solution must involve finding a subarray (a consecutive sequence in the array) such that the sum of its elements is equal to or larger than the target. The order of elements in the subarray will be exactly the same as their order in the original array."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is a subarray problem. You can\\'t delete elements in the middle."
                    },
                    {
                        "username": "sam2611",
                        "content": "If you have already solved this problem, do not submit as it is. Just without having a look at the code reset to default and check how much you still remember. (Best way of revising questions is leetcode daily challenges) \\u270C"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "minimal length of a subarray whose sum is <h1><b>greater</b></h1> than or equal to target"
                    },
                    {
                        "username": "kunal-j",
                        "content": "seems like it is the week of subarrays!"
                    },
                    {
                        "username": "Burrito1510",
                        "content": "I\\'m trying my hand in backtracking (it\\'s not a topic I\\'m very confident in), and I\\'m unsure if this question can be solved through the approach? \\n\\nThe test case I\\'m getting stuck in is nums=[12,28,83,4,25,26,25,2,25,25,25,12]\\nand target = 213.\\n\\nHere\\'s the code: \\n\\nint result=INT_MAX;\\n    void loop(int index, int target, vector<int>&nums, int count){\\n        if(target<=0){\\n            result=min(result,count);\\n            return;\\n        } \\n        for(int i=index;i<nums.size();i++){\\n            target-=nums[i];\\n            count+=1;\\n            loop(i+1,target,nums,count);\\n            target+=nums[i];\\n            count-=1;\\n        }\\n        return;\\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    loop(0,target,nums,0);\\n    return result==INT_MAX?0:result;\\n    }\\n\\nI\\'d be grateful if anyone can point out the mistake!"
                    },
                    {
                        "username": "bparanj",
                        "content": "While backtracking can theoretically solve this problem, it is not the most efficient approach due to the high time complexity (O(2^n) in the worst case, where n is the number of elements in the array). The backtracking approach tries all possible combinations of subarrays, which is not necessary for this problem and results in a lot of redundant computation.\\n\\nIn your code, the issue arises from the fact that you\\'re recursively exploring all possible subarrays starting from each index in the array. But the problem specifically asks for contiguous subarrays. Your approach doesn\\'t ensure contiguity because it explores all subarrays starting from each index, without considering whether these subarrays are contiguous or not.\\n\\nThe more optimal way to solve this problem is by using a \"sliding window\" or \"two pointers\" approach, which solves the problem in O(n) time. \\n\\nHere\\'s the general idea of the sliding window approach:\\n\\n1. Start with a window that includes the first element of the array.\\n2. Then expand the window from the right until the sum of the window elements is equal to or greater than the target.\\n3. When the sum becomes equal to or greater than the target, try to shrink the window from the left side as much as possible while maintaining a sum that is equal to or greater than the target.\\n4. Keep track of the minimum length of such a window during this process.\\n5. Move the right end of the window one position at a time, repeating steps 3 and 4, until the right end reaches the last element of the array.\\n\\nThis approach ensures that you\\'re only looking at contiguous subarrays and that you\\'re efficiently minimizing the window size whenever possible.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem lies on how you use the for loop. the problem want us to find a subarray but what your code does is find the minimum amount of number  you can take to reach the target (subsequence).\n\neg\nusing testcase [12,28,83,4,25,26,25,2,25,25,25,12]\ntarget = 213\n- first loop (target = 213)\ntarget -= 12 \ncount += 1;\nloop()\n\n- second loop (target = 201, count = 1)\ntarget -= 28\ncount+= 1\nloop() we skip this one\ntarget += 28 (start of the problem)\ncount -= 1\nNEXT FOR LOOP iteration (target = 201, count = 1)\ntarget -= 83\ncount += 1\nloop() (here's the problem)\n\nin the second recursion loop the target is reduced by 12 and 83 which is not a subarray but a subsequence.\n\ni think backtracking approach will give you TLE because of the constraint of nums.length 10^5 (i try it)"
                    },
                    {
                        "username": "SpaghettiCode92",
                        "content": "Testcase 13/20 \\n\\nTarget = 20\\nnums = [2,16,14,15]\\n\\nMy answer = 0\\nExpected = 2\\n\\nAm I missing something here or is the testcase incorrect?"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "We have to check \"Greater or equal to target\"  not only equal!!!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "16 and 14 is one sub array whose sum is grater than 20 the other one is 14 ,15 you can take any one both of length 2 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE with 20/20 testcases passed... Last Executed input target =\\n\\nwhat\\'s wrong?????"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just a little unlucky, try again!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i also get the same error ..just submit twice ,,generally the solution is wrong somewhere but leetcode shows all test cases passed with tle.."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "May be you are using Brute force optimise your code it is taking more time than allowed "
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "why pick and non pick concept is not apply? can anyone resolve ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"pick and non-pick\" concept, typically used in backtracking and recursive solutions, involves making a decision at each step whether to \"pick\" or \"not pick\" an element for a particular solution.\\n\\nIn this problem, however, we are not selecting individual, non-contiguous elements from the array. Instead, we\\'re trying to find the smallest contiguous subarray with a sum greater than or equal to the target. The elements in a contiguous subarray are inherently linked -- you can\\'t pick one and not pick the one next to it, because doing so would break the contiguity of the subarray.\\n\\nTherefore, the concept of \"pick and non-pick\" doesn\\'t apply here. Instead, the problem is more suited to a \"sliding window\" or \"two pointers\" approach, where you adjust the start and end points of the subarray to find the smallest subarray that meets the criteria.\\n\\nThe sliding window approach involves initializing two pointers at the beginning of the array and then moving them through the array such that the sum of the subarray between the two pointers is as close to the target as possible. The window (subarray) \"slides\" through the array, growing and shrinking as necessary, to find the smallest subarray with a sum >= target."
                    },
                    {
                        "username": "Ultron03",
                        "content": "because it is question related to subarray not subsequence .. in the pick and non pick you will end up getting a subsequence which will not be continuous,,"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because it\\'s subarray which is contiguous so you cannot skip any element you must add each number as they appear in vector"
                    },
                    {
                        "username": "Ultron03",
                        "content": "window kuch jyada hi slide kr rhi h ..\nday 2  #sliding window\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I saw the editorial cuz I didnt know any way to solve this problem cuz the concept used here goes way above my mind.....Gotta go practice some more !!"
                    }
                ]
            },
            {
                "id": 1958180,
                "content": [
                    {
                        "username": "hemanth_12",
                        "content": "explain this one to me\\nit is the wrong test case\\n\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nSubarray : [83, 26, 25, 25, 25, 25, 12]\\nOutput : 7\\nExpected : 8"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) Yes, you\\'re right. In the context of this problem, a subarray means a contiguous segment from the original array, so you cannot remove elements in the middle of it. The solution must involve finding a subarray (a consecutive sequence in the array) such that the sum of its elements is equal to or larger than the target. The order of elements in the subarray will be exactly the same as their order in the original array."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is a subarray problem. You can\\'t delete elements in the middle."
                    },
                    {
                        "username": "sam2611",
                        "content": "If you have already solved this problem, do not submit as it is. Just without having a look at the code reset to default and check how much you still remember. (Best way of revising questions is leetcode daily challenges) \\u270C"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "minimal length of a subarray whose sum is <h1><b>greater</b></h1> than or equal to target"
                    },
                    {
                        "username": "kunal-j",
                        "content": "seems like it is the week of subarrays!"
                    },
                    {
                        "username": "Burrito1510",
                        "content": "I\\'m trying my hand in backtracking (it\\'s not a topic I\\'m very confident in), and I\\'m unsure if this question can be solved through the approach? \\n\\nThe test case I\\'m getting stuck in is nums=[12,28,83,4,25,26,25,2,25,25,25,12]\\nand target = 213.\\n\\nHere\\'s the code: \\n\\nint result=INT_MAX;\\n    void loop(int index, int target, vector<int>&nums, int count){\\n        if(target<=0){\\n            result=min(result,count);\\n            return;\\n        } \\n        for(int i=index;i<nums.size();i++){\\n            target-=nums[i];\\n            count+=1;\\n            loop(i+1,target,nums,count);\\n            target+=nums[i];\\n            count-=1;\\n        }\\n        return;\\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    loop(0,target,nums,0);\\n    return result==INT_MAX?0:result;\\n    }\\n\\nI\\'d be grateful if anyone can point out the mistake!"
                    },
                    {
                        "username": "bparanj",
                        "content": "While backtracking can theoretically solve this problem, it is not the most efficient approach due to the high time complexity (O(2^n) in the worst case, where n is the number of elements in the array). The backtracking approach tries all possible combinations of subarrays, which is not necessary for this problem and results in a lot of redundant computation.\\n\\nIn your code, the issue arises from the fact that you\\'re recursively exploring all possible subarrays starting from each index in the array. But the problem specifically asks for contiguous subarrays. Your approach doesn\\'t ensure contiguity because it explores all subarrays starting from each index, without considering whether these subarrays are contiguous or not.\\n\\nThe more optimal way to solve this problem is by using a \"sliding window\" or \"two pointers\" approach, which solves the problem in O(n) time. \\n\\nHere\\'s the general idea of the sliding window approach:\\n\\n1. Start with a window that includes the first element of the array.\\n2. Then expand the window from the right until the sum of the window elements is equal to or greater than the target.\\n3. When the sum becomes equal to or greater than the target, try to shrink the window from the left side as much as possible while maintaining a sum that is equal to or greater than the target.\\n4. Keep track of the minimum length of such a window during this process.\\n5. Move the right end of the window one position at a time, repeating steps 3 and 4, until the right end reaches the last element of the array.\\n\\nThis approach ensures that you\\'re only looking at contiguous subarrays and that you\\'re efficiently minimizing the window size whenever possible.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem lies on how you use the for loop. the problem want us to find a subarray but what your code does is find the minimum amount of number  you can take to reach the target (subsequence).\n\neg\nusing testcase [12,28,83,4,25,26,25,2,25,25,25,12]\ntarget = 213\n- first loop (target = 213)\ntarget -= 12 \ncount += 1;\nloop()\n\n- second loop (target = 201, count = 1)\ntarget -= 28\ncount+= 1\nloop() we skip this one\ntarget += 28 (start of the problem)\ncount -= 1\nNEXT FOR LOOP iteration (target = 201, count = 1)\ntarget -= 83\ncount += 1\nloop() (here's the problem)\n\nin the second recursion loop the target is reduced by 12 and 83 which is not a subarray but a subsequence.\n\ni think backtracking approach will give you TLE because of the constraint of nums.length 10^5 (i try it)"
                    },
                    {
                        "username": "SpaghettiCode92",
                        "content": "Testcase 13/20 \\n\\nTarget = 20\\nnums = [2,16,14,15]\\n\\nMy answer = 0\\nExpected = 2\\n\\nAm I missing something here or is the testcase incorrect?"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "We have to check \"Greater or equal to target\"  not only equal!!!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "16 and 14 is one sub array whose sum is grater than 20 the other one is 14 ,15 you can take any one both of length 2 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE with 20/20 testcases passed... Last Executed input target =\\n\\nwhat\\'s wrong?????"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just a little unlucky, try again!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i also get the same error ..just submit twice ,,generally the solution is wrong somewhere but leetcode shows all test cases passed with tle.."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "May be you are using Brute force optimise your code it is taking more time than allowed "
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "why pick and non pick concept is not apply? can anyone resolve ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"pick and non-pick\" concept, typically used in backtracking and recursive solutions, involves making a decision at each step whether to \"pick\" or \"not pick\" an element for a particular solution.\\n\\nIn this problem, however, we are not selecting individual, non-contiguous elements from the array. Instead, we\\'re trying to find the smallest contiguous subarray with a sum greater than or equal to the target. The elements in a contiguous subarray are inherently linked -- you can\\'t pick one and not pick the one next to it, because doing so would break the contiguity of the subarray.\\n\\nTherefore, the concept of \"pick and non-pick\" doesn\\'t apply here. Instead, the problem is more suited to a \"sliding window\" or \"two pointers\" approach, where you adjust the start and end points of the subarray to find the smallest subarray that meets the criteria.\\n\\nThe sliding window approach involves initializing two pointers at the beginning of the array and then moving them through the array such that the sum of the subarray between the two pointers is as close to the target as possible. The window (subarray) \"slides\" through the array, growing and shrinking as necessary, to find the smallest subarray with a sum >= target."
                    },
                    {
                        "username": "Ultron03",
                        "content": "because it is question related to subarray not subsequence .. in the pick and non pick you will end up getting a subsequence which will not be continuous,,"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because it\\'s subarray which is contiguous so you cannot skip any element you must add each number as they appear in vector"
                    },
                    {
                        "username": "Ultron03",
                        "content": "window kuch jyada hi slide kr rhi h ..\nday 2  #sliding window\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I saw the editorial cuz I didnt know any way to solve this problem cuz the concept used here goes way above my mind.....Gotta go practice some more !!"
                    }
                ]
            },
            {
                "id": 1958166,
                "content": [
                    {
                        "username": "hemanth_12",
                        "content": "explain this one to me\\nit is the wrong test case\\n\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nSubarray : [83, 26, 25, 25, 25, 25, 12]\\nOutput : 7\\nExpected : 8"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) Yes, you\\'re right. In the context of this problem, a subarray means a contiguous segment from the original array, so you cannot remove elements in the middle of it. The solution must involve finding a subarray (a consecutive sequence in the array) such that the sum of its elements is equal to or larger than the target. The order of elements in the subarray will be exactly the same as their order in the original array."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is a subarray problem. You can\\'t delete elements in the middle."
                    },
                    {
                        "username": "sam2611",
                        "content": "If you have already solved this problem, do not submit as it is. Just without having a look at the code reset to default and check how much you still remember. (Best way of revising questions is leetcode daily challenges) \\u270C"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "minimal length of a subarray whose sum is <h1><b>greater</b></h1> than or equal to target"
                    },
                    {
                        "username": "kunal-j",
                        "content": "seems like it is the week of subarrays!"
                    },
                    {
                        "username": "Burrito1510",
                        "content": "I\\'m trying my hand in backtracking (it\\'s not a topic I\\'m very confident in), and I\\'m unsure if this question can be solved through the approach? \\n\\nThe test case I\\'m getting stuck in is nums=[12,28,83,4,25,26,25,2,25,25,25,12]\\nand target = 213.\\n\\nHere\\'s the code: \\n\\nint result=INT_MAX;\\n    void loop(int index, int target, vector<int>&nums, int count){\\n        if(target<=0){\\n            result=min(result,count);\\n            return;\\n        } \\n        for(int i=index;i<nums.size();i++){\\n            target-=nums[i];\\n            count+=1;\\n            loop(i+1,target,nums,count);\\n            target+=nums[i];\\n            count-=1;\\n        }\\n        return;\\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    loop(0,target,nums,0);\\n    return result==INT_MAX?0:result;\\n    }\\n\\nI\\'d be grateful if anyone can point out the mistake!"
                    },
                    {
                        "username": "bparanj",
                        "content": "While backtracking can theoretically solve this problem, it is not the most efficient approach due to the high time complexity (O(2^n) in the worst case, where n is the number of elements in the array). The backtracking approach tries all possible combinations of subarrays, which is not necessary for this problem and results in a lot of redundant computation.\\n\\nIn your code, the issue arises from the fact that you\\'re recursively exploring all possible subarrays starting from each index in the array. But the problem specifically asks for contiguous subarrays. Your approach doesn\\'t ensure contiguity because it explores all subarrays starting from each index, without considering whether these subarrays are contiguous or not.\\n\\nThe more optimal way to solve this problem is by using a \"sliding window\" or \"two pointers\" approach, which solves the problem in O(n) time. \\n\\nHere\\'s the general idea of the sliding window approach:\\n\\n1. Start with a window that includes the first element of the array.\\n2. Then expand the window from the right until the sum of the window elements is equal to or greater than the target.\\n3. When the sum becomes equal to or greater than the target, try to shrink the window from the left side as much as possible while maintaining a sum that is equal to or greater than the target.\\n4. Keep track of the minimum length of such a window during this process.\\n5. Move the right end of the window one position at a time, repeating steps 3 and 4, until the right end reaches the last element of the array.\\n\\nThis approach ensures that you\\'re only looking at contiguous subarrays and that you\\'re efficiently minimizing the window size whenever possible.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem lies on how you use the for loop. the problem want us to find a subarray but what your code does is find the minimum amount of number  you can take to reach the target (subsequence).\n\neg\nusing testcase [12,28,83,4,25,26,25,2,25,25,25,12]\ntarget = 213\n- first loop (target = 213)\ntarget -= 12 \ncount += 1;\nloop()\n\n- second loop (target = 201, count = 1)\ntarget -= 28\ncount+= 1\nloop() we skip this one\ntarget += 28 (start of the problem)\ncount -= 1\nNEXT FOR LOOP iteration (target = 201, count = 1)\ntarget -= 83\ncount += 1\nloop() (here's the problem)\n\nin the second recursion loop the target is reduced by 12 and 83 which is not a subarray but a subsequence.\n\ni think backtracking approach will give you TLE because of the constraint of nums.length 10^5 (i try it)"
                    },
                    {
                        "username": "SpaghettiCode92",
                        "content": "Testcase 13/20 \\n\\nTarget = 20\\nnums = [2,16,14,15]\\n\\nMy answer = 0\\nExpected = 2\\n\\nAm I missing something here or is the testcase incorrect?"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "We have to check \"Greater or equal to target\"  not only equal!!!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "16 and 14 is one sub array whose sum is grater than 20 the other one is 14 ,15 you can take any one both of length 2 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE with 20/20 testcases passed... Last Executed input target =\\n\\nwhat\\'s wrong?????"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just a little unlucky, try again!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i also get the same error ..just submit twice ,,generally the solution is wrong somewhere but leetcode shows all test cases passed with tle.."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "May be you are using Brute force optimise your code it is taking more time than allowed "
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "why pick and non pick concept is not apply? can anyone resolve ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"pick and non-pick\" concept, typically used in backtracking and recursive solutions, involves making a decision at each step whether to \"pick\" or \"not pick\" an element for a particular solution.\\n\\nIn this problem, however, we are not selecting individual, non-contiguous elements from the array. Instead, we\\'re trying to find the smallest contiguous subarray with a sum greater than or equal to the target. The elements in a contiguous subarray are inherently linked -- you can\\'t pick one and not pick the one next to it, because doing so would break the contiguity of the subarray.\\n\\nTherefore, the concept of \"pick and non-pick\" doesn\\'t apply here. Instead, the problem is more suited to a \"sliding window\" or \"two pointers\" approach, where you adjust the start and end points of the subarray to find the smallest subarray that meets the criteria.\\n\\nThe sliding window approach involves initializing two pointers at the beginning of the array and then moving them through the array such that the sum of the subarray between the two pointers is as close to the target as possible. The window (subarray) \"slides\" through the array, growing and shrinking as necessary, to find the smallest subarray with a sum >= target."
                    },
                    {
                        "username": "Ultron03",
                        "content": "because it is question related to subarray not subsequence .. in the pick and non pick you will end up getting a subsequence which will not be continuous,,"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because it\\'s subarray which is contiguous so you cannot skip any element you must add each number as they appear in vector"
                    },
                    {
                        "username": "Ultron03",
                        "content": "window kuch jyada hi slide kr rhi h ..\nday 2  #sliding window\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I saw the editorial cuz I didnt know any way to solve this problem cuz the concept used here goes way above my mind.....Gotta go practice some more !!"
                    }
                ]
            },
            {
                "id": 1958106,
                "content": [
                    {
                        "username": "hemanth_12",
                        "content": "explain this one to me\\nit is the wrong test case\\n\\ntarget =213\\nnums =[12,28,83,4,25,26,25,2,25,25,25,12]\\nSubarray : [83, 26, 25, 25, 25, 25, 12]\\nOutput : 7\\nExpected : 8"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) Yes, you\\'re right. In the context of this problem, a subarray means a contiguous segment from the original array, so you cannot remove elements in the middle of it. The solution must involve finding a subarray (a consecutive sequence in the array) such that the sum of its elements is equal to or larger than the target. The order of elements in the subarray will be exactly the same as their order in the original array."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is a subarray problem. You can\\'t delete elements in the middle."
                    },
                    {
                        "username": "sam2611",
                        "content": "If you have already solved this problem, do not submit as it is. Just without having a look at the code reset to default and check how much you still remember. (Best way of revising questions is leetcode daily challenges) \\u270C"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "minimal length of a subarray whose sum is <h1><b>greater</b></h1> than or equal to target"
                    },
                    {
                        "username": "kunal-j",
                        "content": "seems like it is the week of subarrays!"
                    },
                    {
                        "username": "Burrito1510",
                        "content": "I\\'m trying my hand in backtracking (it\\'s not a topic I\\'m very confident in), and I\\'m unsure if this question can be solved through the approach? \\n\\nThe test case I\\'m getting stuck in is nums=[12,28,83,4,25,26,25,2,25,25,25,12]\\nand target = 213.\\n\\nHere\\'s the code: \\n\\nint result=INT_MAX;\\n    void loop(int index, int target, vector<int>&nums, int count){\\n        if(target<=0){\\n            result=min(result,count);\\n            return;\\n        } \\n        for(int i=index;i<nums.size();i++){\\n            target-=nums[i];\\n            count+=1;\\n            loop(i+1,target,nums,count);\\n            target+=nums[i];\\n            count-=1;\\n        }\\n        return;\\n    }\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n    loop(0,target,nums,0);\\n    return result==INT_MAX?0:result;\\n    }\\n\\nI\\'d be grateful if anyone can point out the mistake!"
                    },
                    {
                        "username": "bparanj",
                        "content": "While backtracking can theoretically solve this problem, it is not the most efficient approach due to the high time complexity (O(2^n) in the worst case, where n is the number of elements in the array). The backtracking approach tries all possible combinations of subarrays, which is not necessary for this problem and results in a lot of redundant computation.\\n\\nIn your code, the issue arises from the fact that you\\'re recursively exploring all possible subarrays starting from each index in the array. But the problem specifically asks for contiguous subarrays. Your approach doesn\\'t ensure contiguity because it explores all subarrays starting from each index, without considering whether these subarrays are contiguous or not.\\n\\nThe more optimal way to solve this problem is by using a \"sliding window\" or \"two pointers\" approach, which solves the problem in O(n) time. \\n\\nHere\\'s the general idea of the sliding window approach:\\n\\n1. Start with a window that includes the first element of the array.\\n2. Then expand the window from the right until the sum of the window elements is equal to or greater than the target.\\n3. When the sum becomes equal to or greater than the target, try to shrink the window from the left side as much as possible while maintaining a sum that is equal to or greater than the target.\\n4. Keep track of the minimum length of such a window during this process.\\n5. Move the right end of the window one position at a time, repeating steps 3 and 4, until the right end reaches the last element of the array.\\n\\nThis approach ensures that you\\'re only looking at contiguous subarrays and that you\\'re efficiently minimizing the window size whenever possible.\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem lies on how you use the for loop. the problem want us to find a subarray but what your code does is find the minimum amount of number  you can take to reach the target (subsequence).\n\neg\nusing testcase [12,28,83,4,25,26,25,2,25,25,25,12]\ntarget = 213\n- first loop (target = 213)\ntarget -= 12 \ncount += 1;\nloop()\n\n- second loop (target = 201, count = 1)\ntarget -= 28\ncount+= 1\nloop() we skip this one\ntarget += 28 (start of the problem)\ncount -= 1\nNEXT FOR LOOP iteration (target = 201, count = 1)\ntarget -= 83\ncount += 1\nloop() (here's the problem)\n\nin the second recursion loop the target is reduced by 12 and 83 which is not a subarray but a subsequence.\n\ni think backtracking approach will give you TLE because of the constraint of nums.length 10^5 (i try it)"
                    },
                    {
                        "username": "SpaghettiCode92",
                        "content": "Testcase 13/20 \\n\\nTarget = 20\\nnums = [2,16,14,15]\\n\\nMy answer = 0\\nExpected = 2\\n\\nAm I missing something here or is the testcase incorrect?"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "We have to check \"Greater or equal to target\"  not only equal!!!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "16 and 14 is one sub array whose sum is grater than 20 the other one is 14 ,15 you can take any one both of length 2 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE with 20/20 testcases passed... Last Executed input target =\\n\\nwhat\\'s wrong?????"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just a little unlucky, try again!"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i also get the same error ..just submit twice ,,generally the solution is wrong somewhere but leetcode shows all test cases passed with tle.."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "May be you are using Brute force optimise your code it is taking more time than allowed "
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "why pick and non pick concept is not apply? can anyone resolve ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"pick and non-pick\" concept, typically used in backtracking and recursive solutions, involves making a decision at each step whether to \"pick\" or \"not pick\" an element for a particular solution.\\n\\nIn this problem, however, we are not selecting individual, non-contiguous elements from the array. Instead, we\\'re trying to find the smallest contiguous subarray with a sum greater than or equal to the target. The elements in a contiguous subarray are inherently linked -- you can\\'t pick one and not pick the one next to it, because doing so would break the contiguity of the subarray.\\n\\nTherefore, the concept of \"pick and non-pick\" doesn\\'t apply here. Instead, the problem is more suited to a \"sliding window\" or \"two pointers\" approach, where you adjust the start and end points of the subarray to find the smallest subarray that meets the criteria.\\n\\nThe sliding window approach involves initializing two pointers at the beginning of the array and then moving them through the array such that the sum of the subarray between the two pointers is as close to the target as possible. The window (subarray) \"slides\" through the array, growing and shrinking as necessary, to find the smallest subarray with a sum >= target."
                    },
                    {
                        "username": "Ultron03",
                        "content": "because it is question related to subarray not subsequence .. in the pick and non pick you will end up getting a subsequence which will not be continuous,,"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because it\\'s subarray which is contiguous so you cannot skip any element you must add each number as they appear in vector"
                    },
                    {
                        "username": "Ultron03",
                        "content": "window kuch jyada hi slide kr rhi h ..\nday 2  #sliding window\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I saw the editorial cuz I didnt know any way to solve this problem cuz the concept used here goes way above my mind.....Gotta go practice some more !!"
                    }
                ]
            },
            {
                "id": 1958096,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Maybe the test cases can be enhanced to consider long long."
                    },
                    {
                        "username": "noman598",
                        "content": "Don\\'t forget to read the word - `subarray` :)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hmm, the problem of how to make such a cool-looking <span style=\"font-style: italic; color:#0080EE\">tooltip</span> seems more interesting.\n\nUPD: Alas, it's done via [js](https://leetcode.com/_next/static/chunks/3232-410ec17362fc0411.js). And the Markdown that is available to us here supports only very limited HTML functionality - no scripts or stylesheets (just inline styles). So no luck.\n\nThe closest we can get is:\n standard Markdown popover: `[tooltip](# \"Text\")` [tooltip](# \"\nAt least something\n\")\n the html *abbr* tag: `<abbr title=\"Text\">tooltip</abbr>` <abbr title=\"\nNot so different either\n\">tooltip</abbr>"
                    },
                    {
                        "username": "jaswanthsai181",
                        "content": "For nums = [12,28,83,4,25,26,25,2,25,25,25,12] and target 213, the solution is 7 but expected solution is 8.   My answer = [28,83,25,26,25,25,25] which sums up to 237 and greater than target (213). Am I missing anything?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "The goal is to find subarray (continguous subsequence), and your answer skips some numbers "
                    },
                    {
                        "username": "Nikilangelo",
                        "content": "Why this problem at Two-Pointer Technique list?"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "sliding window is 2 pointer :- one for the start and one for the end."
                    },
                    {
                        "username": "strahd",
                        "content": "The follow up of this question is confusing. If you can come up with a O(N) solution, why would you look for a slower O(N logN) solution? \\nIf there\\'s a typo and they mean following up with a O(logN) solution,  this practically implies applying binary search. I don\\'t know if there is a clever way of doing such a binary search on the nums array. Some preprocessing is necessary for binary search. Sorting the array would make it O(N logN) and accumulating the nums values on another array would make it O(N). So, I am not sure O(logN) is achievable at all if that\\'s what they meant."
                    },
                    {
                        "username": "bparanj",
                        "content": "The follow-up question in problem #209 is asking if it is possible to solve the problem in O(n log n) time, if the initial input array is unsorted. The sliding window approach, which is O(n), works when the input array is sorted. The follow-up is suggesting a scenario where you have an unsorted array, and you still need to solve the problem. \\n\\nYou might think that sorting the array first (which takes O(n log n) time) and then applying the sliding window approach would be a solution, but remember that sorting the array would change the order of the original elements, and in this problem, the subarray must be contiguous based on the original ordering of the array.\\n\\nInstead, an O(n log n) solution would involve a different approach, such as using a data structure like a TreeMap (in Java), which maintains its elements in sorted order and allows for operations like `floorEntry()`. These operations take O(log n) time, and you\\'d have to do them for each of the n elements in the array, hence the O(n log n) time complexity.\\n\\nHowever, it\\'s worth noting that a faster solution (like the O(n) sliding window approach) is generally preferred over a slower one (like the O(n log n) TreeMap approach). The follow-up is really just a thought experiment to see if you understand the problem well enough to come up with a different solution under different conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A follow up question is just brilliant:\\n`Oh, you\\'re too smart? Please be not.`"
                    },
                    {
                        "username": "junejah24",
                        "content": "Sliding window approach looks good. Make sure to recompute the min as you remove the elements from back/left side of the array, too."
                    },
                    {
                        "username": "denlig",
                        "content": "Wrong test case.\n```\ntarget =\n213\n\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n```\n\n\nI think that right answer and the problem don't match."
                    },
                    {
                        "username": "Tuna_in_spring_water",
                        "content": "damn, missed the \"greater than\" in this question"
                    }
                ]
            },
            {
                "id": 1958075,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Maybe the test cases can be enhanced to consider long long."
                    },
                    {
                        "username": "noman598",
                        "content": "Don\\'t forget to read the word - `subarray` :)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hmm, the problem of how to make such a cool-looking <span style=\"font-style: italic; color:#0080EE\">tooltip</span> seems more interesting.\n\nUPD: Alas, it's done via [js](https://leetcode.com/_next/static/chunks/3232-410ec17362fc0411.js). And the Markdown that is available to us here supports only very limited HTML functionality - no scripts or stylesheets (just inline styles). So no luck.\n\nThe closest we can get is:\n standard Markdown popover: `[tooltip](# \"Text\")` [tooltip](# \"\nAt least something\n\")\n the html *abbr* tag: `<abbr title=\"Text\">tooltip</abbr>` <abbr title=\"\nNot so different either\n\">tooltip</abbr>"
                    },
                    {
                        "username": "jaswanthsai181",
                        "content": "For nums = [12,28,83,4,25,26,25,2,25,25,25,12] and target 213, the solution is 7 but expected solution is 8.   My answer = [28,83,25,26,25,25,25] which sums up to 237 and greater than target (213). Am I missing anything?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "The goal is to find subarray (continguous subsequence), and your answer skips some numbers "
                    },
                    {
                        "username": "Nikilangelo",
                        "content": "Why this problem at Two-Pointer Technique list?"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "sliding window is 2 pointer :- one for the start and one for the end."
                    },
                    {
                        "username": "strahd",
                        "content": "The follow up of this question is confusing. If you can come up with a O(N) solution, why would you look for a slower O(N logN) solution? \\nIf there\\'s a typo and they mean following up with a O(logN) solution,  this practically implies applying binary search. I don\\'t know if there is a clever way of doing such a binary search on the nums array. Some preprocessing is necessary for binary search. Sorting the array would make it O(N logN) and accumulating the nums values on another array would make it O(N). So, I am not sure O(logN) is achievable at all if that\\'s what they meant."
                    },
                    {
                        "username": "bparanj",
                        "content": "The follow-up question in problem #209 is asking if it is possible to solve the problem in O(n log n) time, if the initial input array is unsorted. The sliding window approach, which is O(n), works when the input array is sorted. The follow-up is suggesting a scenario where you have an unsorted array, and you still need to solve the problem. \\n\\nYou might think that sorting the array first (which takes O(n log n) time) and then applying the sliding window approach would be a solution, but remember that sorting the array would change the order of the original elements, and in this problem, the subarray must be contiguous based on the original ordering of the array.\\n\\nInstead, an O(n log n) solution would involve a different approach, such as using a data structure like a TreeMap (in Java), which maintains its elements in sorted order and allows for operations like `floorEntry()`. These operations take O(log n) time, and you\\'d have to do them for each of the n elements in the array, hence the O(n log n) time complexity.\\n\\nHowever, it\\'s worth noting that a faster solution (like the O(n) sliding window approach) is generally preferred over a slower one (like the O(n log n) TreeMap approach). The follow-up is really just a thought experiment to see if you understand the problem well enough to come up with a different solution under different conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A follow up question is just brilliant:\\n`Oh, you\\'re too smart? Please be not.`"
                    },
                    {
                        "username": "junejah24",
                        "content": "Sliding window approach looks good. Make sure to recompute the min as you remove the elements from back/left side of the array, too."
                    },
                    {
                        "username": "denlig",
                        "content": "Wrong test case.\n```\ntarget =\n213\n\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n```\n\n\nI think that right answer and the problem don't match."
                    },
                    {
                        "username": "Tuna_in_spring_water",
                        "content": "damn, missed the \"greater than\" in this question"
                    }
                ]
            },
            {
                "id": 1958034,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Maybe the test cases can be enhanced to consider long long."
                    },
                    {
                        "username": "noman598",
                        "content": "Don\\'t forget to read the word - `subarray` :)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hmm, the problem of how to make such a cool-looking <span style=\"font-style: italic; color:#0080EE\">tooltip</span> seems more interesting.\n\nUPD: Alas, it's done via [js](https://leetcode.com/_next/static/chunks/3232-410ec17362fc0411.js). And the Markdown that is available to us here supports only very limited HTML functionality - no scripts or stylesheets (just inline styles). So no luck.\n\nThe closest we can get is:\n standard Markdown popover: `[tooltip](# \"Text\")` [tooltip](# \"\nAt least something\n\")\n the html *abbr* tag: `<abbr title=\"Text\">tooltip</abbr>` <abbr title=\"\nNot so different either\n\">tooltip</abbr>"
                    },
                    {
                        "username": "jaswanthsai181",
                        "content": "For nums = [12,28,83,4,25,26,25,2,25,25,25,12] and target 213, the solution is 7 but expected solution is 8.   My answer = [28,83,25,26,25,25,25] which sums up to 237 and greater than target (213). Am I missing anything?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "The goal is to find subarray (continguous subsequence), and your answer skips some numbers "
                    },
                    {
                        "username": "Nikilangelo",
                        "content": "Why this problem at Two-Pointer Technique list?"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "sliding window is 2 pointer :- one for the start and one for the end."
                    },
                    {
                        "username": "strahd",
                        "content": "The follow up of this question is confusing. If you can come up with a O(N) solution, why would you look for a slower O(N logN) solution? \\nIf there\\'s a typo and they mean following up with a O(logN) solution,  this practically implies applying binary search. I don\\'t know if there is a clever way of doing such a binary search on the nums array. Some preprocessing is necessary for binary search. Sorting the array would make it O(N logN) and accumulating the nums values on another array would make it O(N). So, I am not sure O(logN) is achievable at all if that\\'s what they meant."
                    },
                    {
                        "username": "bparanj",
                        "content": "The follow-up question in problem #209 is asking if it is possible to solve the problem in O(n log n) time, if the initial input array is unsorted. The sliding window approach, which is O(n), works when the input array is sorted. The follow-up is suggesting a scenario where you have an unsorted array, and you still need to solve the problem. \\n\\nYou might think that sorting the array first (which takes O(n log n) time) and then applying the sliding window approach would be a solution, but remember that sorting the array would change the order of the original elements, and in this problem, the subarray must be contiguous based on the original ordering of the array.\\n\\nInstead, an O(n log n) solution would involve a different approach, such as using a data structure like a TreeMap (in Java), which maintains its elements in sorted order and allows for operations like `floorEntry()`. These operations take O(log n) time, and you\\'d have to do them for each of the n elements in the array, hence the O(n log n) time complexity.\\n\\nHowever, it\\'s worth noting that a faster solution (like the O(n) sliding window approach) is generally preferred over a slower one (like the O(n log n) TreeMap approach). The follow-up is really just a thought experiment to see if you understand the problem well enough to come up with a different solution under different conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A follow up question is just brilliant:\\n`Oh, you\\'re too smart? Please be not.`"
                    },
                    {
                        "username": "junejah24",
                        "content": "Sliding window approach looks good. Make sure to recompute the min as you remove the elements from back/left side of the array, too."
                    },
                    {
                        "username": "denlig",
                        "content": "Wrong test case.\n```\ntarget =\n213\n\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n```\n\n\nI think that right answer and the problem don't match."
                    },
                    {
                        "username": "Tuna_in_spring_water",
                        "content": "damn, missed the \"greater than\" in this question"
                    }
                ]
            },
            {
                "id": 1929218,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Maybe the test cases can be enhanced to consider long long."
                    },
                    {
                        "username": "noman598",
                        "content": "Don\\'t forget to read the word - `subarray` :)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hmm, the problem of how to make such a cool-looking <span style=\"font-style: italic; color:#0080EE\">tooltip</span> seems more interesting.\n\nUPD: Alas, it's done via [js](https://leetcode.com/_next/static/chunks/3232-410ec17362fc0411.js). And the Markdown that is available to us here supports only very limited HTML functionality - no scripts or stylesheets (just inline styles). So no luck.\n\nThe closest we can get is:\n standard Markdown popover: `[tooltip](# \"Text\")` [tooltip](# \"\nAt least something\n\")\n the html *abbr* tag: `<abbr title=\"Text\">tooltip</abbr>` <abbr title=\"\nNot so different either\n\">tooltip</abbr>"
                    },
                    {
                        "username": "jaswanthsai181",
                        "content": "For nums = [12,28,83,4,25,26,25,2,25,25,25,12] and target 213, the solution is 7 but expected solution is 8.   My answer = [28,83,25,26,25,25,25] which sums up to 237 and greater than target (213). Am I missing anything?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "The goal is to find subarray (continguous subsequence), and your answer skips some numbers "
                    },
                    {
                        "username": "Nikilangelo",
                        "content": "Why this problem at Two-Pointer Technique list?"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "sliding window is 2 pointer :- one for the start and one for the end."
                    },
                    {
                        "username": "strahd",
                        "content": "The follow up of this question is confusing. If you can come up with a O(N) solution, why would you look for a slower O(N logN) solution? \\nIf there\\'s a typo and they mean following up with a O(logN) solution,  this practically implies applying binary search. I don\\'t know if there is a clever way of doing such a binary search on the nums array. Some preprocessing is necessary for binary search. Sorting the array would make it O(N logN) and accumulating the nums values on another array would make it O(N). So, I am not sure O(logN) is achievable at all if that\\'s what they meant."
                    },
                    {
                        "username": "bparanj",
                        "content": "The follow-up question in problem #209 is asking if it is possible to solve the problem in O(n log n) time, if the initial input array is unsorted. The sliding window approach, which is O(n), works when the input array is sorted. The follow-up is suggesting a scenario where you have an unsorted array, and you still need to solve the problem. \\n\\nYou might think that sorting the array first (which takes O(n log n) time) and then applying the sliding window approach would be a solution, but remember that sorting the array would change the order of the original elements, and in this problem, the subarray must be contiguous based on the original ordering of the array.\\n\\nInstead, an O(n log n) solution would involve a different approach, such as using a data structure like a TreeMap (in Java), which maintains its elements in sorted order and allows for operations like `floorEntry()`. These operations take O(log n) time, and you\\'d have to do them for each of the n elements in the array, hence the O(n log n) time complexity.\\n\\nHowever, it\\'s worth noting that a faster solution (like the O(n) sliding window approach) is generally preferred over a slower one (like the O(n log n) TreeMap approach). The follow-up is really just a thought experiment to see if you understand the problem well enough to come up with a different solution under different conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A follow up question is just brilliant:\\n`Oh, you\\'re too smart? Please be not.`"
                    },
                    {
                        "username": "junejah24",
                        "content": "Sliding window approach looks good. Make sure to recompute the min as you remove the elements from back/left side of the array, too."
                    },
                    {
                        "username": "denlig",
                        "content": "Wrong test case.\n```\ntarget =\n213\n\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n```\n\n\nI think that right answer and the problem don't match."
                    },
                    {
                        "username": "Tuna_in_spring_water",
                        "content": "damn, missed the \"greater than\" in this question"
                    }
                ]
            },
            {
                "id": 1920235,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Maybe the test cases can be enhanced to consider long long."
                    },
                    {
                        "username": "noman598",
                        "content": "Don\\'t forget to read the word - `subarray` :)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hmm, the problem of how to make such a cool-looking <span style=\"font-style: italic; color:#0080EE\">tooltip</span> seems more interesting.\n\nUPD: Alas, it's done via [js](https://leetcode.com/_next/static/chunks/3232-410ec17362fc0411.js). And the Markdown that is available to us here supports only very limited HTML functionality - no scripts or stylesheets (just inline styles). So no luck.\n\nThe closest we can get is:\n standard Markdown popover: `[tooltip](# \"Text\")` [tooltip](# \"\nAt least something\n\")\n the html *abbr* tag: `<abbr title=\"Text\">tooltip</abbr>` <abbr title=\"\nNot so different either\n\">tooltip</abbr>"
                    },
                    {
                        "username": "jaswanthsai181",
                        "content": "For nums = [12,28,83,4,25,26,25,2,25,25,25,12] and target 213, the solution is 7 but expected solution is 8.   My answer = [28,83,25,26,25,25,25] which sums up to 237 and greater than target (213). Am I missing anything?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "The goal is to find subarray (continguous subsequence), and your answer skips some numbers "
                    },
                    {
                        "username": "Nikilangelo",
                        "content": "Why this problem at Two-Pointer Technique list?"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "sliding window is 2 pointer :- one for the start and one for the end."
                    },
                    {
                        "username": "strahd",
                        "content": "The follow up of this question is confusing. If you can come up with a O(N) solution, why would you look for a slower O(N logN) solution? \\nIf there\\'s a typo and they mean following up with a O(logN) solution,  this practically implies applying binary search. I don\\'t know if there is a clever way of doing such a binary search on the nums array. Some preprocessing is necessary for binary search. Sorting the array would make it O(N logN) and accumulating the nums values on another array would make it O(N). So, I am not sure O(logN) is achievable at all if that\\'s what they meant."
                    },
                    {
                        "username": "bparanj",
                        "content": "The follow-up question in problem #209 is asking if it is possible to solve the problem in O(n log n) time, if the initial input array is unsorted. The sliding window approach, which is O(n), works when the input array is sorted. The follow-up is suggesting a scenario where you have an unsorted array, and you still need to solve the problem. \\n\\nYou might think that sorting the array first (which takes O(n log n) time) and then applying the sliding window approach would be a solution, but remember that sorting the array would change the order of the original elements, and in this problem, the subarray must be contiguous based on the original ordering of the array.\\n\\nInstead, an O(n log n) solution would involve a different approach, such as using a data structure like a TreeMap (in Java), which maintains its elements in sorted order and allows for operations like `floorEntry()`. These operations take O(log n) time, and you\\'d have to do them for each of the n elements in the array, hence the O(n log n) time complexity.\\n\\nHowever, it\\'s worth noting that a faster solution (like the O(n) sliding window approach) is generally preferred over a slower one (like the O(n log n) TreeMap approach). The follow-up is really just a thought experiment to see if you understand the problem well enough to come up with a different solution under different conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A follow up question is just brilliant:\\n`Oh, you\\'re too smart? Please be not.`"
                    },
                    {
                        "username": "junejah24",
                        "content": "Sliding window approach looks good. Make sure to recompute the min as you remove the elements from back/left side of the array, too."
                    },
                    {
                        "username": "denlig",
                        "content": "Wrong test case.\n```\ntarget =\n213\n\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n```\n\n\nI think that right answer and the problem don't match."
                    },
                    {
                        "username": "Tuna_in_spring_water",
                        "content": "damn, missed the \"greater than\" in this question"
                    }
                ]
            },
            {
                "id": 1918315,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Maybe the test cases can be enhanced to consider long long."
                    },
                    {
                        "username": "noman598",
                        "content": "Don\\'t forget to read the word - `subarray` :)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hmm, the problem of how to make such a cool-looking <span style=\"font-style: italic; color:#0080EE\">tooltip</span> seems more interesting.\n\nUPD: Alas, it's done via [js](https://leetcode.com/_next/static/chunks/3232-410ec17362fc0411.js). And the Markdown that is available to us here supports only very limited HTML functionality - no scripts or stylesheets (just inline styles). So no luck.\n\nThe closest we can get is:\n standard Markdown popover: `[tooltip](# \"Text\")` [tooltip](# \"\nAt least something\n\")\n the html *abbr* tag: `<abbr title=\"Text\">tooltip</abbr>` <abbr title=\"\nNot so different either\n\">tooltip</abbr>"
                    },
                    {
                        "username": "jaswanthsai181",
                        "content": "For nums = [12,28,83,4,25,26,25,2,25,25,25,12] and target 213, the solution is 7 but expected solution is 8.   My answer = [28,83,25,26,25,25,25] which sums up to 237 and greater than target (213). Am I missing anything?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "The goal is to find subarray (continguous subsequence), and your answer skips some numbers "
                    },
                    {
                        "username": "Nikilangelo",
                        "content": "Why this problem at Two-Pointer Technique list?"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "sliding window is 2 pointer :- one for the start and one for the end."
                    },
                    {
                        "username": "strahd",
                        "content": "The follow up of this question is confusing. If you can come up with a O(N) solution, why would you look for a slower O(N logN) solution? \\nIf there\\'s a typo and they mean following up with a O(logN) solution,  this practically implies applying binary search. I don\\'t know if there is a clever way of doing such a binary search on the nums array. Some preprocessing is necessary for binary search. Sorting the array would make it O(N logN) and accumulating the nums values on another array would make it O(N). So, I am not sure O(logN) is achievable at all if that\\'s what they meant."
                    },
                    {
                        "username": "bparanj",
                        "content": "The follow-up question in problem #209 is asking if it is possible to solve the problem in O(n log n) time, if the initial input array is unsorted. The sliding window approach, which is O(n), works when the input array is sorted. The follow-up is suggesting a scenario where you have an unsorted array, and you still need to solve the problem. \\n\\nYou might think that sorting the array first (which takes O(n log n) time) and then applying the sliding window approach would be a solution, but remember that sorting the array would change the order of the original elements, and in this problem, the subarray must be contiguous based on the original ordering of the array.\\n\\nInstead, an O(n log n) solution would involve a different approach, such as using a data structure like a TreeMap (in Java), which maintains its elements in sorted order and allows for operations like `floorEntry()`. These operations take O(log n) time, and you\\'d have to do them for each of the n elements in the array, hence the O(n log n) time complexity.\\n\\nHowever, it\\'s worth noting that a faster solution (like the O(n) sliding window approach) is generally preferred over a slower one (like the O(n log n) TreeMap approach). The follow-up is really just a thought experiment to see if you understand the problem well enough to come up with a different solution under different conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A follow up question is just brilliant:\\n`Oh, you\\'re too smart? Please be not.`"
                    },
                    {
                        "username": "junejah24",
                        "content": "Sliding window approach looks good. Make sure to recompute the min as you remove the elements from back/left side of the array, too."
                    },
                    {
                        "username": "denlig",
                        "content": "Wrong test case.\n```\ntarget =\n213\n\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n```\n\n\nI think that right answer and the problem don't match."
                    },
                    {
                        "username": "Tuna_in_spring_water",
                        "content": "damn, missed the \"greater than\" in this question"
                    }
                ]
            },
            {
                "id": 1912377,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Maybe the test cases can be enhanced to consider long long."
                    },
                    {
                        "username": "noman598",
                        "content": "Don\\'t forget to read the word - `subarray` :)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hmm, the problem of how to make such a cool-looking <span style=\"font-style: italic; color:#0080EE\">tooltip</span> seems more interesting.\n\nUPD: Alas, it's done via [js](https://leetcode.com/_next/static/chunks/3232-410ec17362fc0411.js). And the Markdown that is available to us here supports only very limited HTML functionality - no scripts or stylesheets (just inline styles). So no luck.\n\nThe closest we can get is:\n standard Markdown popover: `[tooltip](# \"Text\")` [tooltip](# \"\nAt least something\n\")\n the html *abbr* tag: `<abbr title=\"Text\">tooltip</abbr>` <abbr title=\"\nNot so different either\n\">tooltip</abbr>"
                    },
                    {
                        "username": "jaswanthsai181",
                        "content": "For nums = [12,28,83,4,25,26,25,2,25,25,25,12] and target 213, the solution is 7 but expected solution is 8.   My answer = [28,83,25,26,25,25,25] which sums up to 237 and greater than target (213). Am I missing anything?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "The goal is to find subarray (continguous subsequence), and your answer skips some numbers "
                    },
                    {
                        "username": "Nikilangelo",
                        "content": "Why this problem at Two-Pointer Technique list?"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "sliding window is 2 pointer :- one for the start and one for the end."
                    },
                    {
                        "username": "strahd",
                        "content": "The follow up of this question is confusing. If you can come up with a O(N) solution, why would you look for a slower O(N logN) solution? \\nIf there\\'s a typo and they mean following up with a O(logN) solution,  this practically implies applying binary search. I don\\'t know if there is a clever way of doing such a binary search on the nums array. Some preprocessing is necessary for binary search. Sorting the array would make it O(N logN) and accumulating the nums values on another array would make it O(N). So, I am not sure O(logN) is achievable at all if that\\'s what they meant."
                    },
                    {
                        "username": "bparanj",
                        "content": "The follow-up question in problem #209 is asking if it is possible to solve the problem in O(n log n) time, if the initial input array is unsorted. The sliding window approach, which is O(n), works when the input array is sorted. The follow-up is suggesting a scenario where you have an unsorted array, and you still need to solve the problem. \\n\\nYou might think that sorting the array first (which takes O(n log n) time) and then applying the sliding window approach would be a solution, but remember that sorting the array would change the order of the original elements, and in this problem, the subarray must be contiguous based on the original ordering of the array.\\n\\nInstead, an O(n log n) solution would involve a different approach, such as using a data structure like a TreeMap (in Java), which maintains its elements in sorted order and allows for operations like `floorEntry()`. These operations take O(log n) time, and you\\'d have to do them for each of the n elements in the array, hence the O(n log n) time complexity.\\n\\nHowever, it\\'s worth noting that a faster solution (like the O(n) sliding window approach) is generally preferred over a slower one (like the O(n log n) TreeMap approach). The follow-up is really just a thought experiment to see if you understand the problem well enough to come up with a different solution under different conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A follow up question is just brilliant:\\n`Oh, you\\'re too smart? Please be not.`"
                    },
                    {
                        "username": "junejah24",
                        "content": "Sliding window approach looks good. Make sure to recompute the min as you remove the elements from back/left side of the array, too."
                    },
                    {
                        "username": "denlig",
                        "content": "Wrong test case.\n```\ntarget =\n213\n\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n```\n\n\nI think that right answer and the problem don't match."
                    },
                    {
                        "username": "Tuna_in_spring_water",
                        "content": "damn, missed the \"greater than\" in this question"
                    }
                ]
            },
            {
                "id": 1897210,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Maybe the test cases can be enhanced to consider long long."
                    },
                    {
                        "username": "noman598",
                        "content": "Don\\'t forget to read the word - `subarray` :)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hmm, the problem of how to make such a cool-looking <span style=\"font-style: italic; color:#0080EE\">tooltip</span> seems more interesting.\n\nUPD: Alas, it's done via [js](https://leetcode.com/_next/static/chunks/3232-410ec17362fc0411.js). And the Markdown that is available to us here supports only very limited HTML functionality - no scripts or stylesheets (just inline styles). So no luck.\n\nThe closest we can get is:\n standard Markdown popover: `[tooltip](# \"Text\")` [tooltip](# \"\nAt least something\n\")\n the html *abbr* tag: `<abbr title=\"Text\">tooltip</abbr>` <abbr title=\"\nNot so different either\n\">tooltip</abbr>"
                    },
                    {
                        "username": "jaswanthsai181",
                        "content": "For nums = [12,28,83,4,25,26,25,2,25,25,25,12] and target 213, the solution is 7 but expected solution is 8.   My answer = [28,83,25,26,25,25,25] which sums up to 237 and greater than target (213). Am I missing anything?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "The goal is to find subarray (continguous subsequence), and your answer skips some numbers "
                    },
                    {
                        "username": "Nikilangelo",
                        "content": "Why this problem at Two-Pointer Technique list?"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "sliding window is 2 pointer :- one for the start and one for the end."
                    },
                    {
                        "username": "strahd",
                        "content": "The follow up of this question is confusing. If you can come up with a O(N) solution, why would you look for a slower O(N logN) solution? \\nIf there\\'s a typo and they mean following up with a O(logN) solution,  this practically implies applying binary search. I don\\'t know if there is a clever way of doing such a binary search on the nums array. Some preprocessing is necessary for binary search. Sorting the array would make it O(N logN) and accumulating the nums values on another array would make it O(N). So, I am not sure O(logN) is achievable at all if that\\'s what they meant."
                    },
                    {
                        "username": "bparanj",
                        "content": "The follow-up question in problem #209 is asking if it is possible to solve the problem in O(n log n) time, if the initial input array is unsorted. The sliding window approach, which is O(n), works when the input array is sorted. The follow-up is suggesting a scenario where you have an unsorted array, and you still need to solve the problem. \\n\\nYou might think that sorting the array first (which takes O(n log n) time) and then applying the sliding window approach would be a solution, but remember that sorting the array would change the order of the original elements, and in this problem, the subarray must be contiguous based on the original ordering of the array.\\n\\nInstead, an O(n log n) solution would involve a different approach, such as using a data structure like a TreeMap (in Java), which maintains its elements in sorted order and allows for operations like `floorEntry()`. These operations take O(log n) time, and you\\'d have to do them for each of the n elements in the array, hence the O(n log n) time complexity.\\n\\nHowever, it\\'s worth noting that a faster solution (like the O(n) sliding window approach) is generally preferred over a slower one (like the O(n log n) TreeMap approach). The follow-up is really just a thought experiment to see if you understand the problem well enough to come up with a different solution under different conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A follow up question is just brilliant:\\n`Oh, you\\'re too smart? Please be not.`"
                    },
                    {
                        "username": "junejah24",
                        "content": "Sliding window approach looks good. Make sure to recompute the min as you remove the elements from back/left side of the array, too."
                    },
                    {
                        "username": "denlig",
                        "content": "Wrong test case.\n```\ntarget =\n213\n\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n```\n\n\nI think that right answer and the problem don't match."
                    },
                    {
                        "username": "Tuna_in_spring_water",
                        "content": "damn, missed the \"greater than\" in this question"
                    }
                ]
            },
            {
                "id": 1895489,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Maybe the test cases can be enhanced to consider long long."
                    },
                    {
                        "username": "noman598",
                        "content": "Don\\'t forget to read the word - `subarray` :)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hmm, the problem of how to make such a cool-looking <span style=\"font-style: italic; color:#0080EE\">tooltip</span> seems more interesting.\n\nUPD: Alas, it's done via [js](https://leetcode.com/_next/static/chunks/3232-410ec17362fc0411.js). And the Markdown that is available to us here supports only very limited HTML functionality - no scripts or stylesheets (just inline styles). So no luck.\n\nThe closest we can get is:\n standard Markdown popover: `[tooltip](# \"Text\")` [tooltip](# \"\nAt least something\n\")\n the html *abbr* tag: `<abbr title=\"Text\">tooltip</abbr>` <abbr title=\"\nNot so different either\n\">tooltip</abbr>"
                    },
                    {
                        "username": "jaswanthsai181",
                        "content": "For nums = [12,28,83,4,25,26,25,2,25,25,25,12] and target 213, the solution is 7 but expected solution is 8.   My answer = [28,83,25,26,25,25,25] which sums up to 237 and greater than target (213). Am I missing anything?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "The goal is to find subarray (continguous subsequence), and your answer skips some numbers "
                    },
                    {
                        "username": "Nikilangelo",
                        "content": "Why this problem at Two-Pointer Technique list?"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "sliding window is 2 pointer :- one for the start and one for the end."
                    },
                    {
                        "username": "strahd",
                        "content": "The follow up of this question is confusing. If you can come up with a O(N) solution, why would you look for a slower O(N logN) solution? \\nIf there\\'s a typo and they mean following up with a O(logN) solution,  this practically implies applying binary search. I don\\'t know if there is a clever way of doing such a binary search on the nums array. Some preprocessing is necessary for binary search. Sorting the array would make it O(N logN) and accumulating the nums values on another array would make it O(N). So, I am not sure O(logN) is achievable at all if that\\'s what they meant."
                    },
                    {
                        "username": "bparanj",
                        "content": "The follow-up question in problem #209 is asking if it is possible to solve the problem in O(n log n) time, if the initial input array is unsorted. The sliding window approach, which is O(n), works when the input array is sorted. The follow-up is suggesting a scenario where you have an unsorted array, and you still need to solve the problem. \\n\\nYou might think that sorting the array first (which takes O(n log n) time) and then applying the sliding window approach would be a solution, but remember that sorting the array would change the order of the original elements, and in this problem, the subarray must be contiguous based on the original ordering of the array.\\n\\nInstead, an O(n log n) solution would involve a different approach, such as using a data structure like a TreeMap (in Java), which maintains its elements in sorted order and allows for operations like `floorEntry()`. These operations take O(log n) time, and you\\'d have to do them for each of the n elements in the array, hence the O(n log n) time complexity.\\n\\nHowever, it\\'s worth noting that a faster solution (like the O(n) sliding window approach) is generally preferred over a slower one (like the O(n log n) TreeMap approach). The follow-up is really just a thought experiment to see if you understand the problem well enough to come up with a different solution under different conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A follow up question is just brilliant:\\n`Oh, you\\'re too smart? Please be not.`"
                    },
                    {
                        "username": "junejah24",
                        "content": "Sliding window approach looks good. Make sure to recompute the min as you remove the elements from back/left side of the array, too."
                    },
                    {
                        "username": "denlig",
                        "content": "Wrong test case.\n```\ntarget =\n213\n\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n```\n\n\nI think that right answer and the problem don't match."
                    },
                    {
                        "username": "Tuna_in_spring_water",
                        "content": "damn, missed the \"greater than\" in this question"
                    }
                ]
            },
            {
                "id": 1890542,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Maybe the test cases can be enhanced to consider long long."
                    },
                    {
                        "username": "noman598",
                        "content": "Don\\'t forget to read the word - `subarray` :)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hmm, the problem of how to make such a cool-looking <span style=\"font-style: italic; color:#0080EE\">tooltip</span> seems more interesting.\n\nUPD: Alas, it's done via [js](https://leetcode.com/_next/static/chunks/3232-410ec17362fc0411.js). And the Markdown that is available to us here supports only very limited HTML functionality - no scripts or stylesheets (just inline styles). So no luck.\n\nThe closest we can get is:\n standard Markdown popover: `[tooltip](# \"Text\")` [tooltip](# \"\nAt least something\n\")\n the html *abbr* tag: `<abbr title=\"Text\">tooltip</abbr>` <abbr title=\"\nNot so different either\n\">tooltip</abbr>"
                    },
                    {
                        "username": "jaswanthsai181",
                        "content": "For nums = [12,28,83,4,25,26,25,2,25,25,25,12] and target 213, the solution is 7 but expected solution is 8.   My answer = [28,83,25,26,25,25,25] which sums up to 237 and greater than target (213). Am I missing anything?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "The goal is to find subarray (continguous subsequence), and your answer skips some numbers "
                    },
                    {
                        "username": "Nikilangelo",
                        "content": "Why this problem at Two-Pointer Technique list?"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "sliding window is 2 pointer :- one for the start and one for the end."
                    },
                    {
                        "username": "strahd",
                        "content": "The follow up of this question is confusing. If you can come up with a O(N) solution, why would you look for a slower O(N logN) solution? \\nIf there\\'s a typo and they mean following up with a O(logN) solution,  this practically implies applying binary search. I don\\'t know if there is a clever way of doing such a binary search on the nums array. Some preprocessing is necessary for binary search. Sorting the array would make it O(N logN) and accumulating the nums values on another array would make it O(N). So, I am not sure O(logN) is achievable at all if that\\'s what they meant."
                    },
                    {
                        "username": "bparanj",
                        "content": "The follow-up question in problem #209 is asking if it is possible to solve the problem in O(n log n) time, if the initial input array is unsorted. The sliding window approach, which is O(n), works when the input array is sorted. The follow-up is suggesting a scenario where you have an unsorted array, and you still need to solve the problem. \\n\\nYou might think that sorting the array first (which takes O(n log n) time) and then applying the sliding window approach would be a solution, but remember that sorting the array would change the order of the original elements, and in this problem, the subarray must be contiguous based on the original ordering of the array.\\n\\nInstead, an O(n log n) solution would involve a different approach, such as using a data structure like a TreeMap (in Java), which maintains its elements in sorted order and allows for operations like `floorEntry()`. These operations take O(log n) time, and you\\'d have to do them for each of the n elements in the array, hence the O(n log n) time complexity.\\n\\nHowever, it\\'s worth noting that a faster solution (like the O(n) sliding window approach) is generally preferred over a slower one (like the O(n log n) TreeMap approach). The follow-up is really just a thought experiment to see if you understand the problem well enough to come up with a different solution under different conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A follow up question is just brilliant:\\n`Oh, you\\'re too smart? Please be not.`"
                    },
                    {
                        "username": "junejah24",
                        "content": "Sliding window approach looks good. Make sure to recompute the min as you remove the elements from back/left side of the array, too."
                    },
                    {
                        "username": "denlig",
                        "content": "Wrong test case.\n```\ntarget =\n213\n\nnums =\n[12,28,83,4,25,26,25,2,25,25,25,12]\n```\n\n\nI think that right answer and the problem don't match."
                    },
                    {
                        "username": "Tuna_in_spring_water",
                        "content": "damn, missed the \"greater than\" in this question"
                    }
                ]
            },
            {
                "id": 1865822,
                "content": [
                    {
                        "username": "denniscorsi",
                        "content": "I could not figure out why my answer wasn\\'t matching the expected answer. After a lot of confusion, I learned that a subarray has to be *contiguous*. It would have been helpful to have that in the explanation. In math a subset does not have to be contiguous, so I didn\\'t know it would be different for an array. "
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right. It\\'s an important detail that can lead to misunderstanding if not explicitly stated. When we\\'re talking about subarrays in computer science, we are usually referring to contiguous sections of an array. This is different from the concept of a subset in mathematics, where elements do not have to be contiguous. \\n\\nIn the context of these problems, a subarray is a contiguous block of elements within the array. This is important because the solutions often involve techniques like sliding windows or prefix sums, which rely on the elements being contiguous.\\n\\nI understand the confusion and it\\'s a good point to remember for future programming problems. Always assume that subarray refers to contiguous elements unless explicitly stated otherwise."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you hover over the word subarray in the description, it will tell you that a subarray is contiguous. For non contiguous subsets of an array, we use the word \"subsequence\"."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "window sliding question"
                    },
                    {
                        "username": "RG7",
                        "content": "My code is not working can someone please see to it \\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=1;\\n        int sum=nums[0];\\n        while(sum<target){\\n            sum+=nums[right];\\n            right++;\\n        }\\n        int window = right-left;\\n        cout<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n        while(left!=nums.size()){\\n            cout<<\"a\";\\n            if(right==nums.size()&&sum<=target){\\n                cout<<\"p\";\\n                cout<<\"qq\";\\n                break;\\n                break;\\n            }\\n\\n            if(sum<=target){\\n                cout<<\"b\";\\n                if(sum==target&&right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                if(right<nums.size()){\\n                    sum+=nums[right];\\n                    right++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n                \\n            }\\n            else{\\n                cout<<\"c\";\\n                if(right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n            }\\n        }\\n        return window;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "After reviewing your code, it seems like you\\'re trying to implement a sliding window approach to solve the problem. However, there are a few issues:\\n\\n1. Your outer while loop (`while(left!=nums.size())`) may lead to an infinite loop in some cases, because you\\'re not incrementing `left` in every iteration of the loop.\\n\\n2. Your code is not considering the possibility that the sum may not reach the target at all. This happens when you\\'re trying to calculate the initial sum before the main loop.\\n\\n3. The condition in your second `if` statement in the main loop (`if(sum<=target)`) is misleading. If the sum is equal to the target, you would want to update your minimum window size, decrement the sum by `nums[left]` and increment `left`. But if the sum is less than the target, you would want to increment `right` (if it\\'s less than `nums.size()`) and add `nums[right]` to the sum.\\n\\n4. The \\'else\\' part should handle when the sum is greater than the target, and not the other way around as it is in your code.\\n\\nHere is a revised version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int window = nums.size() + 1;\\n\\n        while (right < nums.size()) {\\n            while (sum < target && right < nums.size()) {\\n                sum += nums[right++];\\n            }\\n\\n            while (sum >= target) {\\n                window = min(window, right - left);\\n                sum -= nums[left++];\\n            }\\n        }\\n\\n        return window == nums.size() + 1 ? 0 : window;\\n    }\\n};\\n```\\n\\nThis code keeps expanding the window until the sum is greater than or equal to the target, and then it shrinks the window from the left until the sum is less than the target, while keeping track of the smallest window size. If no valid window is found, it returns 0.\\n"
                    },
                    {
                        "username": "Bill12138",
                        "content": "Can anyone have a look at my solution?\\n\\nSince the desired subarray must be a subarray of the original array, we can find it by keep popping the smaller end value (the left most value or right most value) out while the sum is greater.\\n\\nFor example, target = 7, nums = [2, 3, 1, 2, 4, 3]\\nsubarray = \\n[3, 1, 2, 4, 3]\\n[1, 2, 4, 3]\\n[2, 4, 3]\\n[4, 3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of starting with the entire array and shrinking it from one end when the sum is greater than or equal to the target is an interesting idea. However, it doesn\\'t always work as expected. \\n\\nThe primary issue with your approach is that it doesn\\'t account for situations where the sum of a smaller subarray could still meet the target value. Your algorithm is biased towards the beginning of the array, and may result in subarrays that are unnecessarily long.\\n\\nTake, for example, the array [1, 2, 3, 4, 100, 1, 1, 1, 1, 1] with a target of 7. Your algorithm would start by shrinking the array from the left until it ends up with the subarray [100, 1, 1, 1, 1, 1], which has a length of 6. However, the actual minimum length subarray with a sum greater than or equal to 7 is [100], which only has a length of 1.\\n\\nInstead, consider using a sliding window approach. This method involves maintaining a \"window\" of elements that shifts rightward through the array. The window expands to the right as long as the sum is less than the target, and it shrinks from the left when the sum is greater than or equal to the target. Throughout this process, you keep track of the minimum window size where the sum is greater than or equal to the target. This ensures that you consider all possible subarrays."
                    },
                    {
                        "username": "shiro707",
                        "content": "How do you know which side to pop? "
                    },
                    {
                        "username": "BharathVanki",
                        "content": "l=0\\n        curr=0\\n        ans=999999999999\\n        for i in range(len(nums)):\\n            \\n            curr+=nums[i]\\n\\n            while (curr>=target):\\n                ans = min(ans,i-l+1)\\n                print(ans)\\n                curr=curr-nums[l]\\n                l+=1\\n        if(ans==999999999999):\\n            return 0\\n\\n        return ans\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "The solution says that the time complexity of O(n^2) is accepte: however, it gives time limit exceeded for my solution: as far as I understand my code should have quadratic time complexity in n: am I missing something? \\n\\n `class Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n\\n       \\n\\n        if  sum( nums ) < target:\\n\\n            return 0\\n\\n        \\n        min_sofar = int( 1e5 ) \\n\\n        for st in range( len( nums ) ):\\n\\n            current_sum = nums[st]\\n\\n            current_len = 1\\n\\n            end  = st\\n\\n\\n            while current_sum < target and current_len < min_sofar:\\n\\n                end += 1\\n\\n                if end  >= len( nums ):\\n\\n                    break\\n\\n                current_sum += nums[end]\\n\\n                current_len += 1\\n\\n                \\n\\n            if current_sum >= target:\\n\\n                if current_len < min_sofar:\\n\\n                    min_sofar = current_len\\n\\n        return min_sofar\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n      \\n        return min_len_sofar\\n\\n\\n\\n\\n        `"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your solution indeed has a time complexity of O(n^2). However, LeetCode has a certain time limit for each test case of a problem. If your solution exceeds this limit, it results in a Time Limit Exceeded error. Quadratic time complexity can often be too slow for larger inputs, and it seems that\\'s the case for your solution here.\\n\\nIn this problem, a quadratic time complexity solution might not be efficient enough for larger test cases because it will check every subarray in the worst-case scenario. \\n\\nThe problem can be solved in O(n) time complexity using a sliding window approach. In the sliding window approach, you start with a window at the leftmost part of the array and move it to the right, while keeping track of the sum of the elements in the window. If the sum is less than the target, you expand the window from the right. If the sum is more than or equal to the target, you shrink the window from the left and update the minimum length of the window that has been found so far. This approach will traverse the array only once, hence the time complexity is linear.\\n\\nIt\\'s a good practice to think about the time and space complexity of your solution before implementation. It can help you understand whether your approach will be efficient enough for all test cases."
                    },
                    {
                        "username": "anwer",
                        "content": "Is it consecutive sub array?"
                    },
                    {
                        "username": "shuydo12",
                        "content": "YEA"
                    },
                    {
                        "username": "user9444l",
                        "content": " `Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).`\\n\\nIs this approach related to prefix sum + binary search ? did this with another complexity approach"
                    },
                    {
                        "username": "nhaeri",
                        "content": "For nums=[2,16,14,15] and target=20, how is it possible that the expected output be 2? I think that it should be 0 as there is no sub array satisfying the condition. It is only possible if we use number 2, two times (16+2+2=20). If it is the case, then for nums=[1,1,1,1,1,1,1] and target=11, the expected output should not be 0. Where am I going wrong?"
                    },
                    {
                        "username": "kushagrasharma_13",
                        "content": "sum can be greater"
                    }
                ]
            },
            {
                "id": 1796981,
                "content": [
                    {
                        "username": "denniscorsi",
                        "content": "I could not figure out why my answer wasn\\'t matching the expected answer. After a lot of confusion, I learned that a subarray has to be *contiguous*. It would have been helpful to have that in the explanation. In math a subset does not have to be contiguous, so I didn\\'t know it would be different for an array. "
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right. It\\'s an important detail that can lead to misunderstanding if not explicitly stated. When we\\'re talking about subarrays in computer science, we are usually referring to contiguous sections of an array. This is different from the concept of a subset in mathematics, where elements do not have to be contiguous. \\n\\nIn the context of these problems, a subarray is a contiguous block of elements within the array. This is important because the solutions often involve techniques like sliding windows or prefix sums, which rely on the elements being contiguous.\\n\\nI understand the confusion and it\\'s a good point to remember for future programming problems. Always assume that subarray refers to contiguous elements unless explicitly stated otherwise."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you hover over the word subarray in the description, it will tell you that a subarray is contiguous. For non contiguous subsets of an array, we use the word \"subsequence\"."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "window sliding question"
                    },
                    {
                        "username": "RG7",
                        "content": "My code is not working can someone please see to it \\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=1;\\n        int sum=nums[0];\\n        while(sum<target){\\n            sum+=nums[right];\\n            right++;\\n        }\\n        int window = right-left;\\n        cout<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n        while(left!=nums.size()){\\n            cout<<\"a\";\\n            if(right==nums.size()&&sum<=target){\\n                cout<<\"p\";\\n                cout<<\"qq\";\\n                break;\\n                break;\\n            }\\n\\n            if(sum<=target){\\n                cout<<\"b\";\\n                if(sum==target&&right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                if(right<nums.size()){\\n                    sum+=nums[right];\\n                    right++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n                \\n            }\\n            else{\\n                cout<<\"c\";\\n                if(right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n            }\\n        }\\n        return window;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "After reviewing your code, it seems like you\\'re trying to implement a sliding window approach to solve the problem. However, there are a few issues:\\n\\n1. Your outer while loop (`while(left!=nums.size())`) may lead to an infinite loop in some cases, because you\\'re not incrementing `left` in every iteration of the loop.\\n\\n2. Your code is not considering the possibility that the sum may not reach the target at all. This happens when you\\'re trying to calculate the initial sum before the main loop.\\n\\n3. The condition in your second `if` statement in the main loop (`if(sum<=target)`) is misleading. If the sum is equal to the target, you would want to update your minimum window size, decrement the sum by `nums[left]` and increment `left`. But if the sum is less than the target, you would want to increment `right` (if it\\'s less than `nums.size()`) and add `nums[right]` to the sum.\\n\\n4. The \\'else\\' part should handle when the sum is greater than the target, and not the other way around as it is in your code.\\n\\nHere is a revised version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int window = nums.size() + 1;\\n\\n        while (right < nums.size()) {\\n            while (sum < target && right < nums.size()) {\\n                sum += nums[right++];\\n            }\\n\\n            while (sum >= target) {\\n                window = min(window, right - left);\\n                sum -= nums[left++];\\n            }\\n        }\\n\\n        return window == nums.size() + 1 ? 0 : window;\\n    }\\n};\\n```\\n\\nThis code keeps expanding the window until the sum is greater than or equal to the target, and then it shrinks the window from the left until the sum is less than the target, while keeping track of the smallest window size. If no valid window is found, it returns 0.\\n"
                    },
                    {
                        "username": "Bill12138",
                        "content": "Can anyone have a look at my solution?\\n\\nSince the desired subarray must be a subarray of the original array, we can find it by keep popping the smaller end value (the left most value or right most value) out while the sum is greater.\\n\\nFor example, target = 7, nums = [2, 3, 1, 2, 4, 3]\\nsubarray = \\n[3, 1, 2, 4, 3]\\n[1, 2, 4, 3]\\n[2, 4, 3]\\n[4, 3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of starting with the entire array and shrinking it from one end when the sum is greater than or equal to the target is an interesting idea. However, it doesn\\'t always work as expected. \\n\\nThe primary issue with your approach is that it doesn\\'t account for situations where the sum of a smaller subarray could still meet the target value. Your algorithm is biased towards the beginning of the array, and may result in subarrays that are unnecessarily long.\\n\\nTake, for example, the array [1, 2, 3, 4, 100, 1, 1, 1, 1, 1] with a target of 7. Your algorithm would start by shrinking the array from the left until it ends up with the subarray [100, 1, 1, 1, 1, 1], which has a length of 6. However, the actual minimum length subarray with a sum greater than or equal to 7 is [100], which only has a length of 1.\\n\\nInstead, consider using a sliding window approach. This method involves maintaining a \"window\" of elements that shifts rightward through the array. The window expands to the right as long as the sum is less than the target, and it shrinks from the left when the sum is greater than or equal to the target. Throughout this process, you keep track of the minimum window size where the sum is greater than or equal to the target. This ensures that you consider all possible subarrays."
                    },
                    {
                        "username": "shiro707",
                        "content": "How do you know which side to pop? "
                    },
                    {
                        "username": "BharathVanki",
                        "content": "l=0\\n        curr=0\\n        ans=999999999999\\n        for i in range(len(nums)):\\n            \\n            curr+=nums[i]\\n\\n            while (curr>=target):\\n                ans = min(ans,i-l+1)\\n                print(ans)\\n                curr=curr-nums[l]\\n                l+=1\\n        if(ans==999999999999):\\n            return 0\\n\\n        return ans\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "The solution says that the time complexity of O(n^2) is accepte: however, it gives time limit exceeded for my solution: as far as I understand my code should have quadratic time complexity in n: am I missing something? \\n\\n `class Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n\\n       \\n\\n        if  sum( nums ) < target:\\n\\n            return 0\\n\\n        \\n        min_sofar = int( 1e5 ) \\n\\n        for st in range( len( nums ) ):\\n\\n            current_sum = nums[st]\\n\\n            current_len = 1\\n\\n            end  = st\\n\\n\\n            while current_sum < target and current_len < min_sofar:\\n\\n                end += 1\\n\\n                if end  >= len( nums ):\\n\\n                    break\\n\\n                current_sum += nums[end]\\n\\n                current_len += 1\\n\\n                \\n\\n            if current_sum >= target:\\n\\n                if current_len < min_sofar:\\n\\n                    min_sofar = current_len\\n\\n        return min_sofar\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n      \\n        return min_len_sofar\\n\\n\\n\\n\\n        `"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your solution indeed has a time complexity of O(n^2). However, LeetCode has a certain time limit for each test case of a problem. If your solution exceeds this limit, it results in a Time Limit Exceeded error. Quadratic time complexity can often be too slow for larger inputs, and it seems that\\'s the case for your solution here.\\n\\nIn this problem, a quadratic time complexity solution might not be efficient enough for larger test cases because it will check every subarray in the worst-case scenario. \\n\\nThe problem can be solved in O(n) time complexity using a sliding window approach. In the sliding window approach, you start with a window at the leftmost part of the array and move it to the right, while keeping track of the sum of the elements in the window. If the sum is less than the target, you expand the window from the right. If the sum is more than or equal to the target, you shrink the window from the left and update the minimum length of the window that has been found so far. This approach will traverse the array only once, hence the time complexity is linear.\\n\\nIt\\'s a good practice to think about the time and space complexity of your solution before implementation. It can help you understand whether your approach will be efficient enough for all test cases."
                    },
                    {
                        "username": "anwer",
                        "content": "Is it consecutive sub array?"
                    },
                    {
                        "username": "shuydo12",
                        "content": "YEA"
                    },
                    {
                        "username": "user9444l",
                        "content": " `Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).`\\n\\nIs this approach related to prefix sum + binary search ? did this with another complexity approach"
                    },
                    {
                        "username": "nhaeri",
                        "content": "For nums=[2,16,14,15] and target=20, how is it possible that the expected output be 2? I think that it should be 0 as there is no sub array satisfying the condition. It is only possible if we use number 2, two times (16+2+2=20). If it is the case, then for nums=[1,1,1,1,1,1,1] and target=11, the expected output should not be 0. Where am I going wrong?"
                    },
                    {
                        "username": "kushagrasharma_13",
                        "content": "sum can be greater"
                    }
                ]
            },
            {
                "id": 1777447,
                "content": [
                    {
                        "username": "denniscorsi",
                        "content": "I could not figure out why my answer wasn\\'t matching the expected answer. After a lot of confusion, I learned that a subarray has to be *contiguous*. It would have been helpful to have that in the explanation. In math a subset does not have to be contiguous, so I didn\\'t know it would be different for an array. "
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right. It\\'s an important detail that can lead to misunderstanding if not explicitly stated. When we\\'re talking about subarrays in computer science, we are usually referring to contiguous sections of an array. This is different from the concept of a subset in mathematics, where elements do not have to be contiguous. \\n\\nIn the context of these problems, a subarray is a contiguous block of elements within the array. This is important because the solutions often involve techniques like sliding windows or prefix sums, which rely on the elements being contiguous.\\n\\nI understand the confusion and it\\'s a good point to remember for future programming problems. Always assume that subarray refers to contiguous elements unless explicitly stated otherwise."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you hover over the word subarray in the description, it will tell you that a subarray is contiguous. For non contiguous subsets of an array, we use the word \"subsequence\"."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "window sliding question"
                    },
                    {
                        "username": "RG7",
                        "content": "My code is not working can someone please see to it \\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=1;\\n        int sum=nums[0];\\n        while(sum<target){\\n            sum+=nums[right];\\n            right++;\\n        }\\n        int window = right-left;\\n        cout<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n        while(left!=nums.size()){\\n            cout<<\"a\";\\n            if(right==nums.size()&&sum<=target){\\n                cout<<\"p\";\\n                cout<<\"qq\";\\n                break;\\n                break;\\n            }\\n\\n            if(sum<=target){\\n                cout<<\"b\";\\n                if(sum==target&&right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                if(right<nums.size()){\\n                    sum+=nums[right];\\n                    right++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n                \\n            }\\n            else{\\n                cout<<\"c\";\\n                if(right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n            }\\n        }\\n        return window;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "After reviewing your code, it seems like you\\'re trying to implement a sliding window approach to solve the problem. However, there are a few issues:\\n\\n1. Your outer while loop (`while(left!=nums.size())`) may lead to an infinite loop in some cases, because you\\'re not incrementing `left` in every iteration of the loop.\\n\\n2. Your code is not considering the possibility that the sum may not reach the target at all. This happens when you\\'re trying to calculate the initial sum before the main loop.\\n\\n3. The condition in your second `if` statement in the main loop (`if(sum<=target)`) is misleading. If the sum is equal to the target, you would want to update your minimum window size, decrement the sum by `nums[left]` and increment `left`. But if the sum is less than the target, you would want to increment `right` (if it\\'s less than `nums.size()`) and add `nums[right]` to the sum.\\n\\n4. The \\'else\\' part should handle when the sum is greater than the target, and not the other way around as it is in your code.\\n\\nHere is a revised version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int window = nums.size() + 1;\\n\\n        while (right < nums.size()) {\\n            while (sum < target && right < nums.size()) {\\n                sum += nums[right++];\\n            }\\n\\n            while (sum >= target) {\\n                window = min(window, right - left);\\n                sum -= nums[left++];\\n            }\\n        }\\n\\n        return window == nums.size() + 1 ? 0 : window;\\n    }\\n};\\n```\\n\\nThis code keeps expanding the window until the sum is greater than or equal to the target, and then it shrinks the window from the left until the sum is less than the target, while keeping track of the smallest window size. If no valid window is found, it returns 0.\\n"
                    },
                    {
                        "username": "Bill12138",
                        "content": "Can anyone have a look at my solution?\\n\\nSince the desired subarray must be a subarray of the original array, we can find it by keep popping the smaller end value (the left most value or right most value) out while the sum is greater.\\n\\nFor example, target = 7, nums = [2, 3, 1, 2, 4, 3]\\nsubarray = \\n[3, 1, 2, 4, 3]\\n[1, 2, 4, 3]\\n[2, 4, 3]\\n[4, 3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of starting with the entire array and shrinking it from one end when the sum is greater than or equal to the target is an interesting idea. However, it doesn\\'t always work as expected. \\n\\nThe primary issue with your approach is that it doesn\\'t account for situations where the sum of a smaller subarray could still meet the target value. Your algorithm is biased towards the beginning of the array, and may result in subarrays that are unnecessarily long.\\n\\nTake, for example, the array [1, 2, 3, 4, 100, 1, 1, 1, 1, 1] with a target of 7. Your algorithm would start by shrinking the array from the left until it ends up with the subarray [100, 1, 1, 1, 1, 1], which has a length of 6. However, the actual minimum length subarray with a sum greater than or equal to 7 is [100], which only has a length of 1.\\n\\nInstead, consider using a sliding window approach. This method involves maintaining a \"window\" of elements that shifts rightward through the array. The window expands to the right as long as the sum is less than the target, and it shrinks from the left when the sum is greater than or equal to the target. Throughout this process, you keep track of the minimum window size where the sum is greater than or equal to the target. This ensures that you consider all possible subarrays."
                    },
                    {
                        "username": "shiro707",
                        "content": "How do you know which side to pop? "
                    },
                    {
                        "username": "BharathVanki",
                        "content": "l=0\\n        curr=0\\n        ans=999999999999\\n        for i in range(len(nums)):\\n            \\n            curr+=nums[i]\\n\\n            while (curr>=target):\\n                ans = min(ans,i-l+1)\\n                print(ans)\\n                curr=curr-nums[l]\\n                l+=1\\n        if(ans==999999999999):\\n            return 0\\n\\n        return ans\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "The solution says that the time complexity of O(n^2) is accepte: however, it gives time limit exceeded for my solution: as far as I understand my code should have quadratic time complexity in n: am I missing something? \\n\\n `class Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n\\n       \\n\\n        if  sum( nums ) < target:\\n\\n            return 0\\n\\n        \\n        min_sofar = int( 1e5 ) \\n\\n        for st in range( len( nums ) ):\\n\\n            current_sum = nums[st]\\n\\n            current_len = 1\\n\\n            end  = st\\n\\n\\n            while current_sum < target and current_len < min_sofar:\\n\\n                end += 1\\n\\n                if end  >= len( nums ):\\n\\n                    break\\n\\n                current_sum += nums[end]\\n\\n                current_len += 1\\n\\n                \\n\\n            if current_sum >= target:\\n\\n                if current_len < min_sofar:\\n\\n                    min_sofar = current_len\\n\\n        return min_sofar\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n      \\n        return min_len_sofar\\n\\n\\n\\n\\n        `"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your solution indeed has a time complexity of O(n^2). However, LeetCode has a certain time limit for each test case of a problem. If your solution exceeds this limit, it results in a Time Limit Exceeded error. Quadratic time complexity can often be too slow for larger inputs, and it seems that\\'s the case for your solution here.\\n\\nIn this problem, a quadratic time complexity solution might not be efficient enough for larger test cases because it will check every subarray in the worst-case scenario. \\n\\nThe problem can be solved in O(n) time complexity using a sliding window approach. In the sliding window approach, you start with a window at the leftmost part of the array and move it to the right, while keeping track of the sum of the elements in the window. If the sum is less than the target, you expand the window from the right. If the sum is more than or equal to the target, you shrink the window from the left and update the minimum length of the window that has been found so far. This approach will traverse the array only once, hence the time complexity is linear.\\n\\nIt\\'s a good practice to think about the time and space complexity of your solution before implementation. It can help you understand whether your approach will be efficient enough for all test cases."
                    },
                    {
                        "username": "anwer",
                        "content": "Is it consecutive sub array?"
                    },
                    {
                        "username": "shuydo12",
                        "content": "YEA"
                    },
                    {
                        "username": "user9444l",
                        "content": " `Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).`\\n\\nIs this approach related to prefix sum + binary search ? did this with another complexity approach"
                    },
                    {
                        "username": "nhaeri",
                        "content": "For nums=[2,16,14,15] and target=20, how is it possible that the expected output be 2? I think that it should be 0 as there is no sub array satisfying the condition. It is only possible if we use number 2, two times (16+2+2=20). If it is the case, then for nums=[1,1,1,1,1,1,1] and target=11, the expected output should not be 0. Where am I going wrong?"
                    },
                    {
                        "username": "kushagrasharma_13",
                        "content": "sum can be greater"
                    }
                ]
            },
            {
                "id": 1771756,
                "content": [
                    {
                        "username": "denniscorsi",
                        "content": "I could not figure out why my answer wasn\\'t matching the expected answer. After a lot of confusion, I learned that a subarray has to be *contiguous*. It would have been helpful to have that in the explanation. In math a subset does not have to be contiguous, so I didn\\'t know it would be different for an array. "
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right. It\\'s an important detail that can lead to misunderstanding if not explicitly stated. When we\\'re talking about subarrays in computer science, we are usually referring to contiguous sections of an array. This is different from the concept of a subset in mathematics, where elements do not have to be contiguous. \\n\\nIn the context of these problems, a subarray is a contiguous block of elements within the array. This is important because the solutions often involve techniques like sliding windows or prefix sums, which rely on the elements being contiguous.\\n\\nI understand the confusion and it\\'s a good point to remember for future programming problems. Always assume that subarray refers to contiguous elements unless explicitly stated otherwise."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you hover over the word subarray in the description, it will tell you that a subarray is contiguous. For non contiguous subsets of an array, we use the word \"subsequence\"."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "window sliding question"
                    },
                    {
                        "username": "RG7",
                        "content": "My code is not working can someone please see to it \\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=1;\\n        int sum=nums[0];\\n        while(sum<target){\\n            sum+=nums[right];\\n            right++;\\n        }\\n        int window = right-left;\\n        cout<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n        while(left!=nums.size()){\\n            cout<<\"a\";\\n            if(right==nums.size()&&sum<=target){\\n                cout<<\"p\";\\n                cout<<\"qq\";\\n                break;\\n                break;\\n            }\\n\\n            if(sum<=target){\\n                cout<<\"b\";\\n                if(sum==target&&right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                if(right<nums.size()){\\n                    sum+=nums[right];\\n                    right++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n                \\n            }\\n            else{\\n                cout<<\"c\";\\n                if(right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n            }\\n        }\\n        return window;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "After reviewing your code, it seems like you\\'re trying to implement a sliding window approach to solve the problem. However, there are a few issues:\\n\\n1. Your outer while loop (`while(left!=nums.size())`) may lead to an infinite loop in some cases, because you\\'re not incrementing `left` in every iteration of the loop.\\n\\n2. Your code is not considering the possibility that the sum may not reach the target at all. This happens when you\\'re trying to calculate the initial sum before the main loop.\\n\\n3. The condition in your second `if` statement in the main loop (`if(sum<=target)`) is misleading. If the sum is equal to the target, you would want to update your minimum window size, decrement the sum by `nums[left]` and increment `left`. But if the sum is less than the target, you would want to increment `right` (if it\\'s less than `nums.size()`) and add `nums[right]` to the sum.\\n\\n4. The \\'else\\' part should handle when the sum is greater than the target, and not the other way around as it is in your code.\\n\\nHere is a revised version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int window = nums.size() + 1;\\n\\n        while (right < nums.size()) {\\n            while (sum < target && right < nums.size()) {\\n                sum += nums[right++];\\n            }\\n\\n            while (sum >= target) {\\n                window = min(window, right - left);\\n                sum -= nums[left++];\\n            }\\n        }\\n\\n        return window == nums.size() + 1 ? 0 : window;\\n    }\\n};\\n```\\n\\nThis code keeps expanding the window until the sum is greater than or equal to the target, and then it shrinks the window from the left until the sum is less than the target, while keeping track of the smallest window size. If no valid window is found, it returns 0.\\n"
                    },
                    {
                        "username": "Bill12138",
                        "content": "Can anyone have a look at my solution?\\n\\nSince the desired subarray must be a subarray of the original array, we can find it by keep popping the smaller end value (the left most value or right most value) out while the sum is greater.\\n\\nFor example, target = 7, nums = [2, 3, 1, 2, 4, 3]\\nsubarray = \\n[3, 1, 2, 4, 3]\\n[1, 2, 4, 3]\\n[2, 4, 3]\\n[4, 3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of starting with the entire array and shrinking it from one end when the sum is greater than or equal to the target is an interesting idea. However, it doesn\\'t always work as expected. \\n\\nThe primary issue with your approach is that it doesn\\'t account for situations where the sum of a smaller subarray could still meet the target value. Your algorithm is biased towards the beginning of the array, and may result in subarrays that are unnecessarily long.\\n\\nTake, for example, the array [1, 2, 3, 4, 100, 1, 1, 1, 1, 1] with a target of 7. Your algorithm would start by shrinking the array from the left until it ends up with the subarray [100, 1, 1, 1, 1, 1], which has a length of 6. However, the actual minimum length subarray with a sum greater than or equal to 7 is [100], which only has a length of 1.\\n\\nInstead, consider using a sliding window approach. This method involves maintaining a \"window\" of elements that shifts rightward through the array. The window expands to the right as long as the sum is less than the target, and it shrinks from the left when the sum is greater than or equal to the target. Throughout this process, you keep track of the minimum window size where the sum is greater than or equal to the target. This ensures that you consider all possible subarrays."
                    },
                    {
                        "username": "shiro707",
                        "content": "How do you know which side to pop? "
                    },
                    {
                        "username": "BharathVanki",
                        "content": "l=0\\n        curr=0\\n        ans=999999999999\\n        for i in range(len(nums)):\\n            \\n            curr+=nums[i]\\n\\n            while (curr>=target):\\n                ans = min(ans,i-l+1)\\n                print(ans)\\n                curr=curr-nums[l]\\n                l+=1\\n        if(ans==999999999999):\\n            return 0\\n\\n        return ans\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "The solution says that the time complexity of O(n^2) is accepte: however, it gives time limit exceeded for my solution: as far as I understand my code should have quadratic time complexity in n: am I missing something? \\n\\n `class Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n\\n       \\n\\n        if  sum( nums ) < target:\\n\\n            return 0\\n\\n        \\n        min_sofar = int( 1e5 ) \\n\\n        for st in range( len( nums ) ):\\n\\n            current_sum = nums[st]\\n\\n            current_len = 1\\n\\n            end  = st\\n\\n\\n            while current_sum < target and current_len < min_sofar:\\n\\n                end += 1\\n\\n                if end  >= len( nums ):\\n\\n                    break\\n\\n                current_sum += nums[end]\\n\\n                current_len += 1\\n\\n                \\n\\n            if current_sum >= target:\\n\\n                if current_len < min_sofar:\\n\\n                    min_sofar = current_len\\n\\n        return min_sofar\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n      \\n        return min_len_sofar\\n\\n\\n\\n\\n        `"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your solution indeed has a time complexity of O(n^2). However, LeetCode has a certain time limit for each test case of a problem. If your solution exceeds this limit, it results in a Time Limit Exceeded error. Quadratic time complexity can often be too slow for larger inputs, and it seems that\\'s the case for your solution here.\\n\\nIn this problem, a quadratic time complexity solution might not be efficient enough for larger test cases because it will check every subarray in the worst-case scenario. \\n\\nThe problem can be solved in O(n) time complexity using a sliding window approach. In the sliding window approach, you start with a window at the leftmost part of the array and move it to the right, while keeping track of the sum of the elements in the window. If the sum is less than the target, you expand the window from the right. If the sum is more than or equal to the target, you shrink the window from the left and update the minimum length of the window that has been found so far. This approach will traverse the array only once, hence the time complexity is linear.\\n\\nIt\\'s a good practice to think about the time and space complexity of your solution before implementation. It can help you understand whether your approach will be efficient enough for all test cases."
                    },
                    {
                        "username": "anwer",
                        "content": "Is it consecutive sub array?"
                    },
                    {
                        "username": "shuydo12",
                        "content": "YEA"
                    },
                    {
                        "username": "user9444l",
                        "content": " `Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).`\\n\\nIs this approach related to prefix sum + binary search ? did this with another complexity approach"
                    },
                    {
                        "username": "nhaeri",
                        "content": "For nums=[2,16,14,15] and target=20, how is it possible that the expected output be 2? I think that it should be 0 as there is no sub array satisfying the condition. It is only possible if we use number 2, two times (16+2+2=20). If it is the case, then for nums=[1,1,1,1,1,1,1] and target=11, the expected output should not be 0. Where am I going wrong?"
                    },
                    {
                        "username": "kushagrasharma_13",
                        "content": "sum can be greater"
                    }
                ]
            },
            {
                "id": 1771739,
                "content": [
                    {
                        "username": "denniscorsi",
                        "content": "I could not figure out why my answer wasn\\'t matching the expected answer. After a lot of confusion, I learned that a subarray has to be *contiguous*. It would have been helpful to have that in the explanation. In math a subset does not have to be contiguous, so I didn\\'t know it would be different for an array. "
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right. It\\'s an important detail that can lead to misunderstanding if not explicitly stated. When we\\'re talking about subarrays in computer science, we are usually referring to contiguous sections of an array. This is different from the concept of a subset in mathematics, where elements do not have to be contiguous. \\n\\nIn the context of these problems, a subarray is a contiguous block of elements within the array. This is important because the solutions often involve techniques like sliding windows or prefix sums, which rely on the elements being contiguous.\\n\\nI understand the confusion and it\\'s a good point to remember for future programming problems. Always assume that subarray refers to contiguous elements unless explicitly stated otherwise."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you hover over the word subarray in the description, it will tell you that a subarray is contiguous. For non contiguous subsets of an array, we use the word \"subsequence\"."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "window sliding question"
                    },
                    {
                        "username": "RG7",
                        "content": "My code is not working can someone please see to it \\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=1;\\n        int sum=nums[0];\\n        while(sum<target){\\n            sum+=nums[right];\\n            right++;\\n        }\\n        int window = right-left;\\n        cout<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n        while(left!=nums.size()){\\n            cout<<\"a\";\\n            if(right==nums.size()&&sum<=target){\\n                cout<<\"p\";\\n                cout<<\"qq\";\\n                break;\\n                break;\\n            }\\n\\n            if(sum<=target){\\n                cout<<\"b\";\\n                if(sum==target&&right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                if(right<nums.size()){\\n                    sum+=nums[right];\\n                    right++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n                \\n            }\\n            else{\\n                cout<<\"c\";\\n                if(right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n            }\\n        }\\n        return window;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "After reviewing your code, it seems like you\\'re trying to implement a sliding window approach to solve the problem. However, there are a few issues:\\n\\n1. Your outer while loop (`while(left!=nums.size())`) may lead to an infinite loop in some cases, because you\\'re not incrementing `left` in every iteration of the loop.\\n\\n2. Your code is not considering the possibility that the sum may not reach the target at all. This happens when you\\'re trying to calculate the initial sum before the main loop.\\n\\n3. The condition in your second `if` statement in the main loop (`if(sum<=target)`) is misleading. If the sum is equal to the target, you would want to update your minimum window size, decrement the sum by `nums[left]` and increment `left`. But if the sum is less than the target, you would want to increment `right` (if it\\'s less than `nums.size()`) and add `nums[right]` to the sum.\\n\\n4. The \\'else\\' part should handle when the sum is greater than the target, and not the other way around as it is in your code.\\n\\nHere is a revised version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int window = nums.size() + 1;\\n\\n        while (right < nums.size()) {\\n            while (sum < target && right < nums.size()) {\\n                sum += nums[right++];\\n            }\\n\\n            while (sum >= target) {\\n                window = min(window, right - left);\\n                sum -= nums[left++];\\n            }\\n        }\\n\\n        return window == nums.size() + 1 ? 0 : window;\\n    }\\n};\\n```\\n\\nThis code keeps expanding the window until the sum is greater than or equal to the target, and then it shrinks the window from the left until the sum is less than the target, while keeping track of the smallest window size. If no valid window is found, it returns 0.\\n"
                    },
                    {
                        "username": "Bill12138",
                        "content": "Can anyone have a look at my solution?\\n\\nSince the desired subarray must be a subarray of the original array, we can find it by keep popping the smaller end value (the left most value or right most value) out while the sum is greater.\\n\\nFor example, target = 7, nums = [2, 3, 1, 2, 4, 3]\\nsubarray = \\n[3, 1, 2, 4, 3]\\n[1, 2, 4, 3]\\n[2, 4, 3]\\n[4, 3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of starting with the entire array and shrinking it from one end when the sum is greater than or equal to the target is an interesting idea. However, it doesn\\'t always work as expected. \\n\\nThe primary issue with your approach is that it doesn\\'t account for situations where the sum of a smaller subarray could still meet the target value. Your algorithm is biased towards the beginning of the array, and may result in subarrays that are unnecessarily long.\\n\\nTake, for example, the array [1, 2, 3, 4, 100, 1, 1, 1, 1, 1] with a target of 7. Your algorithm would start by shrinking the array from the left until it ends up with the subarray [100, 1, 1, 1, 1, 1], which has a length of 6. However, the actual minimum length subarray with a sum greater than or equal to 7 is [100], which only has a length of 1.\\n\\nInstead, consider using a sliding window approach. This method involves maintaining a \"window\" of elements that shifts rightward through the array. The window expands to the right as long as the sum is less than the target, and it shrinks from the left when the sum is greater than or equal to the target. Throughout this process, you keep track of the minimum window size where the sum is greater than or equal to the target. This ensures that you consider all possible subarrays."
                    },
                    {
                        "username": "shiro707",
                        "content": "How do you know which side to pop? "
                    },
                    {
                        "username": "BharathVanki",
                        "content": "l=0\\n        curr=0\\n        ans=999999999999\\n        for i in range(len(nums)):\\n            \\n            curr+=nums[i]\\n\\n            while (curr>=target):\\n                ans = min(ans,i-l+1)\\n                print(ans)\\n                curr=curr-nums[l]\\n                l+=1\\n        if(ans==999999999999):\\n            return 0\\n\\n        return ans\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "The solution says that the time complexity of O(n^2) is accepte: however, it gives time limit exceeded for my solution: as far as I understand my code should have quadratic time complexity in n: am I missing something? \\n\\n `class Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n\\n       \\n\\n        if  sum( nums ) < target:\\n\\n            return 0\\n\\n        \\n        min_sofar = int( 1e5 ) \\n\\n        for st in range( len( nums ) ):\\n\\n            current_sum = nums[st]\\n\\n            current_len = 1\\n\\n            end  = st\\n\\n\\n            while current_sum < target and current_len < min_sofar:\\n\\n                end += 1\\n\\n                if end  >= len( nums ):\\n\\n                    break\\n\\n                current_sum += nums[end]\\n\\n                current_len += 1\\n\\n                \\n\\n            if current_sum >= target:\\n\\n                if current_len < min_sofar:\\n\\n                    min_sofar = current_len\\n\\n        return min_sofar\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n      \\n        return min_len_sofar\\n\\n\\n\\n\\n        `"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your solution indeed has a time complexity of O(n^2). However, LeetCode has a certain time limit for each test case of a problem. If your solution exceeds this limit, it results in a Time Limit Exceeded error. Quadratic time complexity can often be too slow for larger inputs, and it seems that\\'s the case for your solution here.\\n\\nIn this problem, a quadratic time complexity solution might not be efficient enough for larger test cases because it will check every subarray in the worst-case scenario. \\n\\nThe problem can be solved in O(n) time complexity using a sliding window approach. In the sliding window approach, you start with a window at the leftmost part of the array and move it to the right, while keeping track of the sum of the elements in the window. If the sum is less than the target, you expand the window from the right. If the sum is more than or equal to the target, you shrink the window from the left and update the minimum length of the window that has been found so far. This approach will traverse the array only once, hence the time complexity is linear.\\n\\nIt\\'s a good practice to think about the time and space complexity of your solution before implementation. It can help you understand whether your approach will be efficient enough for all test cases."
                    },
                    {
                        "username": "anwer",
                        "content": "Is it consecutive sub array?"
                    },
                    {
                        "username": "shuydo12",
                        "content": "YEA"
                    },
                    {
                        "username": "user9444l",
                        "content": " `Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).`\\n\\nIs this approach related to prefix sum + binary search ? did this with another complexity approach"
                    },
                    {
                        "username": "nhaeri",
                        "content": "For nums=[2,16,14,15] and target=20, how is it possible that the expected output be 2? I think that it should be 0 as there is no sub array satisfying the condition. It is only possible if we use number 2, two times (16+2+2=20). If it is the case, then for nums=[1,1,1,1,1,1,1] and target=11, the expected output should not be 0. Where am I going wrong?"
                    },
                    {
                        "username": "kushagrasharma_13",
                        "content": "sum can be greater"
                    }
                ]
            },
            {
                "id": 1757515,
                "content": [
                    {
                        "username": "denniscorsi",
                        "content": "I could not figure out why my answer wasn\\'t matching the expected answer. After a lot of confusion, I learned that a subarray has to be *contiguous*. It would have been helpful to have that in the explanation. In math a subset does not have to be contiguous, so I didn\\'t know it would be different for an array. "
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right. It\\'s an important detail that can lead to misunderstanding if not explicitly stated. When we\\'re talking about subarrays in computer science, we are usually referring to contiguous sections of an array. This is different from the concept of a subset in mathematics, where elements do not have to be contiguous. \\n\\nIn the context of these problems, a subarray is a contiguous block of elements within the array. This is important because the solutions often involve techniques like sliding windows or prefix sums, which rely on the elements being contiguous.\\n\\nI understand the confusion and it\\'s a good point to remember for future programming problems. Always assume that subarray refers to contiguous elements unless explicitly stated otherwise."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you hover over the word subarray in the description, it will tell you that a subarray is contiguous. For non contiguous subsets of an array, we use the word \"subsequence\"."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "window sliding question"
                    },
                    {
                        "username": "RG7",
                        "content": "My code is not working can someone please see to it \\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=1;\\n        int sum=nums[0];\\n        while(sum<target){\\n            sum+=nums[right];\\n            right++;\\n        }\\n        int window = right-left;\\n        cout<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n        while(left!=nums.size()){\\n            cout<<\"a\";\\n            if(right==nums.size()&&sum<=target){\\n                cout<<\"p\";\\n                cout<<\"qq\";\\n                break;\\n                break;\\n            }\\n\\n            if(sum<=target){\\n                cout<<\"b\";\\n                if(sum==target&&right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                if(right<nums.size()){\\n                    sum+=nums[right];\\n                    right++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n                \\n            }\\n            else{\\n                cout<<\"c\";\\n                if(right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n            }\\n        }\\n        return window;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "After reviewing your code, it seems like you\\'re trying to implement a sliding window approach to solve the problem. However, there are a few issues:\\n\\n1. Your outer while loop (`while(left!=nums.size())`) may lead to an infinite loop in some cases, because you\\'re not incrementing `left` in every iteration of the loop.\\n\\n2. Your code is not considering the possibility that the sum may not reach the target at all. This happens when you\\'re trying to calculate the initial sum before the main loop.\\n\\n3. The condition in your second `if` statement in the main loop (`if(sum<=target)`) is misleading. If the sum is equal to the target, you would want to update your minimum window size, decrement the sum by `nums[left]` and increment `left`. But if the sum is less than the target, you would want to increment `right` (if it\\'s less than `nums.size()`) and add `nums[right]` to the sum.\\n\\n4. The \\'else\\' part should handle when the sum is greater than the target, and not the other way around as it is in your code.\\n\\nHere is a revised version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int window = nums.size() + 1;\\n\\n        while (right < nums.size()) {\\n            while (sum < target && right < nums.size()) {\\n                sum += nums[right++];\\n            }\\n\\n            while (sum >= target) {\\n                window = min(window, right - left);\\n                sum -= nums[left++];\\n            }\\n        }\\n\\n        return window == nums.size() + 1 ? 0 : window;\\n    }\\n};\\n```\\n\\nThis code keeps expanding the window until the sum is greater than or equal to the target, and then it shrinks the window from the left until the sum is less than the target, while keeping track of the smallest window size. If no valid window is found, it returns 0.\\n"
                    },
                    {
                        "username": "Bill12138",
                        "content": "Can anyone have a look at my solution?\\n\\nSince the desired subarray must be a subarray of the original array, we can find it by keep popping the smaller end value (the left most value or right most value) out while the sum is greater.\\n\\nFor example, target = 7, nums = [2, 3, 1, 2, 4, 3]\\nsubarray = \\n[3, 1, 2, 4, 3]\\n[1, 2, 4, 3]\\n[2, 4, 3]\\n[4, 3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of starting with the entire array and shrinking it from one end when the sum is greater than or equal to the target is an interesting idea. However, it doesn\\'t always work as expected. \\n\\nThe primary issue with your approach is that it doesn\\'t account for situations where the sum of a smaller subarray could still meet the target value. Your algorithm is biased towards the beginning of the array, and may result in subarrays that are unnecessarily long.\\n\\nTake, for example, the array [1, 2, 3, 4, 100, 1, 1, 1, 1, 1] with a target of 7. Your algorithm would start by shrinking the array from the left until it ends up with the subarray [100, 1, 1, 1, 1, 1], which has a length of 6. However, the actual minimum length subarray with a sum greater than or equal to 7 is [100], which only has a length of 1.\\n\\nInstead, consider using a sliding window approach. This method involves maintaining a \"window\" of elements that shifts rightward through the array. The window expands to the right as long as the sum is less than the target, and it shrinks from the left when the sum is greater than or equal to the target. Throughout this process, you keep track of the minimum window size where the sum is greater than or equal to the target. This ensures that you consider all possible subarrays."
                    },
                    {
                        "username": "shiro707",
                        "content": "How do you know which side to pop? "
                    },
                    {
                        "username": "BharathVanki",
                        "content": "l=0\\n        curr=0\\n        ans=999999999999\\n        for i in range(len(nums)):\\n            \\n            curr+=nums[i]\\n\\n            while (curr>=target):\\n                ans = min(ans,i-l+1)\\n                print(ans)\\n                curr=curr-nums[l]\\n                l+=1\\n        if(ans==999999999999):\\n            return 0\\n\\n        return ans\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "The solution says that the time complexity of O(n^2) is accepte: however, it gives time limit exceeded for my solution: as far as I understand my code should have quadratic time complexity in n: am I missing something? \\n\\n `class Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n\\n       \\n\\n        if  sum( nums ) < target:\\n\\n            return 0\\n\\n        \\n        min_sofar = int( 1e5 ) \\n\\n        for st in range( len( nums ) ):\\n\\n            current_sum = nums[st]\\n\\n            current_len = 1\\n\\n            end  = st\\n\\n\\n            while current_sum < target and current_len < min_sofar:\\n\\n                end += 1\\n\\n                if end  >= len( nums ):\\n\\n                    break\\n\\n                current_sum += nums[end]\\n\\n                current_len += 1\\n\\n                \\n\\n            if current_sum >= target:\\n\\n                if current_len < min_sofar:\\n\\n                    min_sofar = current_len\\n\\n        return min_sofar\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n      \\n        return min_len_sofar\\n\\n\\n\\n\\n        `"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your solution indeed has a time complexity of O(n^2). However, LeetCode has a certain time limit for each test case of a problem. If your solution exceeds this limit, it results in a Time Limit Exceeded error. Quadratic time complexity can often be too slow for larger inputs, and it seems that\\'s the case for your solution here.\\n\\nIn this problem, a quadratic time complexity solution might not be efficient enough for larger test cases because it will check every subarray in the worst-case scenario. \\n\\nThe problem can be solved in O(n) time complexity using a sliding window approach. In the sliding window approach, you start with a window at the leftmost part of the array and move it to the right, while keeping track of the sum of the elements in the window. If the sum is less than the target, you expand the window from the right. If the sum is more than or equal to the target, you shrink the window from the left and update the minimum length of the window that has been found so far. This approach will traverse the array only once, hence the time complexity is linear.\\n\\nIt\\'s a good practice to think about the time and space complexity of your solution before implementation. It can help you understand whether your approach will be efficient enough for all test cases."
                    },
                    {
                        "username": "anwer",
                        "content": "Is it consecutive sub array?"
                    },
                    {
                        "username": "shuydo12",
                        "content": "YEA"
                    },
                    {
                        "username": "user9444l",
                        "content": " `Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).`\\n\\nIs this approach related to prefix sum + binary search ? did this with another complexity approach"
                    },
                    {
                        "username": "nhaeri",
                        "content": "For nums=[2,16,14,15] and target=20, how is it possible that the expected output be 2? I think that it should be 0 as there is no sub array satisfying the condition. It is only possible if we use number 2, two times (16+2+2=20). If it is the case, then for nums=[1,1,1,1,1,1,1] and target=11, the expected output should not be 0. Where am I going wrong?"
                    },
                    {
                        "username": "kushagrasharma_13",
                        "content": "sum can be greater"
                    }
                ]
            },
            {
                "id": 1750342,
                "content": [
                    {
                        "username": "denniscorsi",
                        "content": "I could not figure out why my answer wasn\\'t matching the expected answer. After a lot of confusion, I learned that a subarray has to be *contiguous*. It would have been helpful to have that in the explanation. In math a subset does not have to be contiguous, so I didn\\'t know it would be different for an array. "
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right. It\\'s an important detail that can lead to misunderstanding if not explicitly stated. When we\\'re talking about subarrays in computer science, we are usually referring to contiguous sections of an array. This is different from the concept of a subset in mathematics, where elements do not have to be contiguous. \\n\\nIn the context of these problems, a subarray is a contiguous block of elements within the array. This is important because the solutions often involve techniques like sliding windows or prefix sums, which rely on the elements being contiguous.\\n\\nI understand the confusion and it\\'s a good point to remember for future programming problems. Always assume that subarray refers to contiguous elements unless explicitly stated otherwise."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you hover over the word subarray in the description, it will tell you that a subarray is contiguous. For non contiguous subsets of an array, we use the word \"subsequence\"."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "window sliding question"
                    },
                    {
                        "username": "RG7",
                        "content": "My code is not working can someone please see to it \\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=1;\\n        int sum=nums[0];\\n        while(sum<target){\\n            sum+=nums[right];\\n            right++;\\n        }\\n        int window = right-left;\\n        cout<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n        while(left!=nums.size()){\\n            cout<<\"a\";\\n            if(right==nums.size()&&sum<=target){\\n                cout<<\"p\";\\n                cout<<\"qq\";\\n                break;\\n                break;\\n            }\\n\\n            if(sum<=target){\\n                cout<<\"b\";\\n                if(sum==target&&right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                if(right<nums.size()){\\n                    sum+=nums[right];\\n                    right++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n                \\n            }\\n            else{\\n                cout<<\"c\";\\n                if(right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n            }\\n        }\\n        return window;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "After reviewing your code, it seems like you\\'re trying to implement a sliding window approach to solve the problem. However, there are a few issues:\\n\\n1. Your outer while loop (`while(left!=nums.size())`) may lead to an infinite loop in some cases, because you\\'re not incrementing `left` in every iteration of the loop.\\n\\n2. Your code is not considering the possibility that the sum may not reach the target at all. This happens when you\\'re trying to calculate the initial sum before the main loop.\\n\\n3. The condition in your second `if` statement in the main loop (`if(sum<=target)`) is misleading. If the sum is equal to the target, you would want to update your minimum window size, decrement the sum by `nums[left]` and increment `left`. But if the sum is less than the target, you would want to increment `right` (if it\\'s less than `nums.size()`) and add `nums[right]` to the sum.\\n\\n4. The \\'else\\' part should handle when the sum is greater than the target, and not the other way around as it is in your code.\\n\\nHere is a revised version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int window = nums.size() + 1;\\n\\n        while (right < nums.size()) {\\n            while (sum < target && right < nums.size()) {\\n                sum += nums[right++];\\n            }\\n\\n            while (sum >= target) {\\n                window = min(window, right - left);\\n                sum -= nums[left++];\\n            }\\n        }\\n\\n        return window == nums.size() + 1 ? 0 : window;\\n    }\\n};\\n```\\n\\nThis code keeps expanding the window until the sum is greater than or equal to the target, and then it shrinks the window from the left until the sum is less than the target, while keeping track of the smallest window size. If no valid window is found, it returns 0.\\n"
                    },
                    {
                        "username": "Bill12138",
                        "content": "Can anyone have a look at my solution?\\n\\nSince the desired subarray must be a subarray of the original array, we can find it by keep popping the smaller end value (the left most value or right most value) out while the sum is greater.\\n\\nFor example, target = 7, nums = [2, 3, 1, 2, 4, 3]\\nsubarray = \\n[3, 1, 2, 4, 3]\\n[1, 2, 4, 3]\\n[2, 4, 3]\\n[4, 3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of starting with the entire array and shrinking it from one end when the sum is greater than or equal to the target is an interesting idea. However, it doesn\\'t always work as expected. \\n\\nThe primary issue with your approach is that it doesn\\'t account for situations where the sum of a smaller subarray could still meet the target value. Your algorithm is biased towards the beginning of the array, and may result in subarrays that are unnecessarily long.\\n\\nTake, for example, the array [1, 2, 3, 4, 100, 1, 1, 1, 1, 1] with a target of 7. Your algorithm would start by shrinking the array from the left until it ends up with the subarray [100, 1, 1, 1, 1, 1], which has a length of 6. However, the actual minimum length subarray with a sum greater than or equal to 7 is [100], which only has a length of 1.\\n\\nInstead, consider using a sliding window approach. This method involves maintaining a \"window\" of elements that shifts rightward through the array. The window expands to the right as long as the sum is less than the target, and it shrinks from the left when the sum is greater than or equal to the target. Throughout this process, you keep track of the minimum window size where the sum is greater than or equal to the target. This ensures that you consider all possible subarrays."
                    },
                    {
                        "username": "shiro707",
                        "content": "How do you know which side to pop? "
                    },
                    {
                        "username": "BharathVanki",
                        "content": "l=0\\n        curr=0\\n        ans=999999999999\\n        for i in range(len(nums)):\\n            \\n            curr+=nums[i]\\n\\n            while (curr>=target):\\n                ans = min(ans,i-l+1)\\n                print(ans)\\n                curr=curr-nums[l]\\n                l+=1\\n        if(ans==999999999999):\\n            return 0\\n\\n        return ans\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "The solution says that the time complexity of O(n^2) is accepte: however, it gives time limit exceeded for my solution: as far as I understand my code should have quadratic time complexity in n: am I missing something? \\n\\n `class Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n\\n       \\n\\n        if  sum( nums ) < target:\\n\\n            return 0\\n\\n        \\n        min_sofar = int( 1e5 ) \\n\\n        for st in range( len( nums ) ):\\n\\n            current_sum = nums[st]\\n\\n            current_len = 1\\n\\n            end  = st\\n\\n\\n            while current_sum < target and current_len < min_sofar:\\n\\n                end += 1\\n\\n                if end  >= len( nums ):\\n\\n                    break\\n\\n                current_sum += nums[end]\\n\\n                current_len += 1\\n\\n                \\n\\n            if current_sum >= target:\\n\\n                if current_len < min_sofar:\\n\\n                    min_sofar = current_len\\n\\n        return min_sofar\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n      \\n        return min_len_sofar\\n\\n\\n\\n\\n        `"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your solution indeed has a time complexity of O(n^2). However, LeetCode has a certain time limit for each test case of a problem. If your solution exceeds this limit, it results in a Time Limit Exceeded error. Quadratic time complexity can often be too slow for larger inputs, and it seems that\\'s the case for your solution here.\\n\\nIn this problem, a quadratic time complexity solution might not be efficient enough for larger test cases because it will check every subarray in the worst-case scenario. \\n\\nThe problem can be solved in O(n) time complexity using a sliding window approach. In the sliding window approach, you start with a window at the leftmost part of the array and move it to the right, while keeping track of the sum of the elements in the window. If the sum is less than the target, you expand the window from the right. If the sum is more than or equal to the target, you shrink the window from the left and update the minimum length of the window that has been found so far. This approach will traverse the array only once, hence the time complexity is linear.\\n\\nIt\\'s a good practice to think about the time and space complexity of your solution before implementation. It can help you understand whether your approach will be efficient enough for all test cases."
                    },
                    {
                        "username": "anwer",
                        "content": "Is it consecutive sub array?"
                    },
                    {
                        "username": "shuydo12",
                        "content": "YEA"
                    },
                    {
                        "username": "user9444l",
                        "content": " `Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).`\\n\\nIs this approach related to prefix sum + binary search ? did this with another complexity approach"
                    },
                    {
                        "username": "nhaeri",
                        "content": "For nums=[2,16,14,15] and target=20, how is it possible that the expected output be 2? I think that it should be 0 as there is no sub array satisfying the condition. It is only possible if we use number 2, two times (16+2+2=20). If it is the case, then for nums=[1,1,1,1,1,1,1] and target=11, the expected output should not be 0. Where am I going wrong?"
                    },
                    {
                        "username": "kushagrasharma_13",
                        "content": "sum can be greater"
                    }
                ]
            },
            {
                "id": 1749109,
                "content": [
                    {
                        "username": "denniscorsi",
                        "content": "I could not figure out why my answer wasn\\'t matching the expected answer. After a lot of confusion, I learned that a subarray has to be *contiguous*. It would have been helpful to have that in the explanation. In math a subset does not have to be contiguous, so I didn\\'t know it would be different for an array. "
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right. It\\'s an important detail that can lead to misunderstanding if not explicitly stated. When we\\'re talking about subarrays in computer science, we are usually referring to contiguous sections of an array. This is different from the concept of a subset in mathematics, where elements do not have to be contiguous. \\n\\nIn the context of these problems, a subarray is a contiguous block of elements within the array. This is important because the solutions often involve techniques like sliding windows or prefix sums, which rely on the elements being contiguous.\\n\\nI understand the confusion and it\\'s a good point to remember for future programming problems. Always assume that subarray refers to contiguous elements unless explicitly stated otherwise."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you hover over the word subarray in the description, it will tell you that a subarray is contiguous. For non contiguous subsets of an array, we use the word \"subsequence\"."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "window sliding question"
                    },
                    {
                        "username": "RG7",
                        "content": "My code is not working can someone please see to it \\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=1;\\n        int sum=nums[0];\\n        while(sum<target){\\n            sum+=nums[right];\\n            right++;\\n        }\\n        int window = right-left;\\n        cout<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n        while(left!=nums.size()){\\n            cout<<\"a\";\\n            if(right==nums.size()&&sum<=target){\\n                cout<<\"p\";\\n                cout<<\"qq\";\\n                break;\\n                break;\\n            }\\n\\n            if(sum<=target){\\n                cout<<\"b\";\\n                if(sum==target&&right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                if(right<nums.size()){\\n                    sum+=nums[right];\\n                    right++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n                \\n            }\\n            else{\\n                cout<<\"c\";\\n                if(right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n            }\\n        }\\n        return window;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "After reviewing your code, it seems like you\\'re trying to implement a sliding window approach to solve the problem. However, there are a few issues:\\n\\n1. Your outer while loop (`while(left!=nums.size())`) may lead to an infinite loop in some cases, because you\\'re not incrementing `left` in every iteration of the loop.\\n\\n2. Your code is not considering the possibility that the sum may not reach the target at all. This happens when you\\'re trying to calculate the initial sum before the main loop.\\n\\n3. The condition in your second `if` statement in the main loop (`if(sum<=target)`) is misleading. If the sum is equal to the target, you would want to update your minimum window size, decrement the sum by `nums[left]` and increment `left`. But if the sum is less than the target, you would want to increment `right` (if it\\'s less than `nums.size()`) and add `nums[right]` to the sum.\\n\\n4. The \\'else\\' part should handle when the sum is greater than the target, and not the other way around as it is in your code.\\n\\nHere is a revised version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int window = nums.size() + 1;\\n\\n        while (right < nums.size()) {\\n            while (sum < target && right < nums.size()) {\\n                sum += nums[right++];\\n            }\\n\\n            while (sum >= target) {\\n                window = min(window, right - left);\\n                sum -= nums[left++];\\n            }\\n        }\\n\\n        return window == nums.size() + 1 ? 0 : window;\\n    }\\n};\\n```\\n\\nThis code keeps expanding the window until the sum is greater than or equal to the target, and then it shrinks the window from the left until the sum is less than the target, while keeping track of the smallest window size. If no valid window is found, it returns 0.\\n"
                    },
                    {
                        "username": "Bill12138",
                        "content": "Can anyone have a look at my solution?\\n\\nSince the desired subarray must be a subarray of the original array, we can find it by keep popping the smaller end value (the left most value or right most value) out while the sum is greater.\\n\\nFor example, target = 7, nums = [2, 3, 1, 2, 4, 3]\\nsubarray = \\n[3, 1, 2, 4, 3]\\n[1, 2, 4, 3]\\n[2, 4, 3]\\n[4, 3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of starting with the entire array and shrinking it from one end when the sum is greater than or equal to the target is an interesting idea. However, it doesn\\'t always work as expected. \\n\\nThe primary issue with your approach is that it doesn\\'t account for situations where the sum of a smaller subarray could still meet the target value. Your algorithm is biased towards the beginning of the array, and may result in subarrays that are unnecessarily long.\\n\\nTake, for example, the array [1, 2, 3, 4, 100, 1, 1, 1, 1, 1] with a target of 7. Your algorithm would start by shrinking the array from the left until it ends up with the subarray [100, 1, 1, 1, 1, 1], which has a length of 6. However, the actual minimum length subarray with a sum greater than or equal to 7 is [100], which only has a length of 1.\\n\\nInstead, consider using a sliding window approach. This method involves maintaining a \"window\" of elements that shifts rightward through the array. The window expands to the right as long as the sum is less than the target, and it shrinks from the left when the sum is greater than or equal to the target. Throughout this process, you keep track of the minimum window size where the sum is greater than or equal to the target. This ensures that you consider all possible subarrays."
                    },
                    {
                        "username": "shiro707",
                        "content": "How do you know which side to pop? "
                    },
                    {
                        "username": "BharathVanki",
                        "content": "l=0\\n        curr=0\\n        ans=999999999999\\n        for i in range(len(nums)):\\n            \\n            curr+=nums[i]\\n\\n            while (curr>=target):\\n                ans = min(ans,i-l+1)\\n                print(ans)\\n                curr=curr-nums[l]\\n                l+=1\\n        if(ans==999999999999):\\n            return 0\\n\\n        return ans\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "The solution says that the time complexity of O(n^2) is accepte: however, it gives time limit exceeded for my solution: as far as I understand my code should have quadratic time complexity in n: am I missing something? \\n\\n `class Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n\\n       \\n\\n        if  sum( nums ) < target:\\n\\n            return 0\\n\\n        \\n        min_sofar = int( 1e5 ) \\n\\n        for st in range( len( nums ) ):\\n\\n            current_sum = nums[st]\\n\\n            current_len = 1\\n\\n            end  = st\\n\\n\\n            while current_sum < target and current_len < min_sofar:\\n\\n                end += 1\\n\\n                if end  >= len( nums ):\\n\\n                    break\\n\\n                current_sum += nums[end]\\n\\n                current_len += 1\\n\\n                \\n\\n            if current_sum >= target:\\n\\n                if current_len < min_sofar:\\n\\n                    min_sofar = current_len\\n\\n        return min_sofar\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n      \\n        return min_len_sofar\\n\\n\\n\\n\\n        `"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your solution indeed has a time complexity of O(n^2). However, LeetCode has a certain time limit for each test case of a problem. If your solution exceeds this limit, it results in a Time Limit Exceeded error. Quadratic time complexity can often be too slow for larger inputs, and it seems that\\'s the case for your solution here.\\n\\nIn this problem, a quadratic time complexity solution might not be efficient enough for larger test cases because it will check every subarray in the worst-case scenario. \\n\\nThe problem can be solved in O(n) time complexity using a sliding window approach. In the sliding window approach, you start with a window at the leftmost part of the array and move it to the right, while keeping track of the sum of the elements in the window. If the sum is less than the target, you expand the window from the right. If the sum is more than or equal to the target, you shrink the window from the left and update the minimum length of the window that has been found so far. This approach will traverse the array only once, hence the time complexity is linear.\\n\\nIt\\'s a good practice to think about the time and space complexity of your solution before implementation. It can help you understand whether your approach will be efficient enough for all test cases."
                    },
                    {
                        "username": "anwer",
                        "content": "Is it consecutive sub array?"
                    },
                    {
                        "username": "shuydo12",
                        "content": "YEA"
                    },
                    {
                        "username": "user9444l",
                        "content": " `Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).`\\n\\nIs this approach related to prefix sum + binary search ? did this with another complexity approach"
                    },
                    {
                        "username": "nhaeri",
                        "content": "For nums=[2,16,14,15] and target=20, how is it possible that the expected output be 2? I think that it should be 0 as there is no sub array satisfying the condition. It is only possible if we use number 2, two times (16+2+2=20). If it is the case, then for nums=[1,1,1,1,1,1,1] and target=11, the expected output should not be 0. Where am I going wrong?"
                    },
                    {
                        "username": "kushagrasharma_13",
                        "content": "sum can be greater"
                    }
                ]
            },
            {
                "id": 1739793,
                "content": [
                    {
                        "username": "denniscorsi",
                        "content": "I could not figure out why my answer wasn\\'t matching the expected answer. After a lot of confusion, I learned that a subarray has to be *contiguous*. It would have been helpful to have that in the explanation. In math a subset does not have to be contiguous, so I didn\\'t know it would be different for an array. "
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right. It\\'s an important detail that can lead to misunderstanding if not explicitly stated. When we\\'re talking about subarrays in computer science, we are usually referring to contiguous sections of an array. This is different from the concept of a subset in mathematics, where elements do not have to be contiguous. \\n\\nIn the context of these problems, a subarray is a contiguous block of elements within the array. This is important because the solutions often involve techniques like sliding windows or prefix sums, which rely on the elements being contiguous.\\n\\nI understand the confusion and it\\'s a good point to remember for future programming problems. Always assume that subarray refers to contiguous elements unless explicitly stated otherwise."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you hover over the word subarray in the description, it will tell you that a subarray is contiguous. For non contiguous subsets of an array, we use the word \"subsequence\"."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "window sliding question"
                    },
                    {
                        "username": "RG7",
                        "content": "My code is not working can someone please see to it \\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=1;\\n        int sum=nums[0];\\n        while(sum<target){\\n            sum+=nums[right];\\n            right++;\\n        }\\n        int window = right-left;\\n        cout<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n        while(left!=nums.size()){\\n            cout<<\"a\";\\n            if(right==nums.size()&&sum<=target){\\n                cout<<\"p\";\\n                cout<<\"qq\";\\n                break;\\n                break;\\n            }\\n\\n            if(sum<=target){\\n                cout<<\"b\";\\n                if(sum==target&&right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                if(right<nums.size()){\\n                    sum+=nums[right];\\n                    right++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n                \\n            }\\n            else{\\n                cout<<\"c\";\\n                if(right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n            }\\n        }\\n        return window;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "After reviewing your code, it seems like you\\'re trying to implement a sliding window approach to solve the problem. However, there are a few issues:\\n\\n1. Your outer while loop (`while(left!=nums.size())`) may lead to an infinite loop in some cases, because you\\'re not incrementing `left` in every iteration of the loop.\\n\\n2. Your code is not considering the possibility that the sum may not reach the target at all. This happens when you\\'re trying to calculate the initial sum before the main loop.\\n\\n3. The condition in your second `if` statement in the main loop (`if(sum<=target)`) is misleading. If the sum is equal to the target, you would want to update your minimum window size, decrement the sum by `nums[left]` and increment `left`. But if the sum is less than the target, you would want to increment `right` (if it\\'s less than `nums.size()`) and add `nums[right]` to the sum.\\n\\n4. The \\'else\\' part should handle when the sum is greater than the target, and not the other way around as it is in your code.\\n\\nHere is a revised version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int window = nums.size() + 1;\\n\\n        while (right < nums.size()) {\\n            while (sum < target && right < nums.size()) {\\n                sum += nums[right++];\\n            }\\n\\n            while (sum >= target) {\\n                window = min(window, right - left);\\n                sum -= nums[left++];\\n            }\\n        }\\n\\n        return window == nums.size() + 1 ? 0 : window;\\n    }\\n};\\n```\\n\\nThis code keeps expanding the window until the sum is greater than or equal to the target, and then it shrinks the window from the left until the sum is less than the target, while keeping track of the smallest window size. If no valid window is found, it returns 0.\\n"
                    },
                    {
                        "username": "Bill12138",
                        "content": "Can anyone have a look at my solution?\\n\\nSince the desired subarray must be a subarray of the original array, we can find it by keep popping the smaller end value (the left most value or right most value) out while the sum is greater.\\n\\nFor example, target = 7, nums = [2, 3, 1, 2, 4, 3]\\nsubarray = \\n[3, 1, 2, 4, 3]\\n[1, 2, 4, 3]\\n[2, 4, 3]\\n[4, 3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of starting with the entire array and shrinking it from one end when the sum is greater than or equal to the target is an interesting idea. However, it doesn\\'t always work as expected. \\n\\nThe primary issue with your approach is that it doesn\\'t account for situations where the sum of a smaller subarray could still meet the target value. Your algorithm is biased towards the beginning of the array, and may result in subarrays that are unnecessarily long.\\n\\nTake, for example, the array [1, 2, 3, 4, 100, 1, 1, 1, 1, 1] with a target of 7. Your algorithm would start by shrinking the array from the left until it ends up with the subarray [100, 1, 1, 1, 1, 1], which has a length of 6. However, the actual minimum length subarray with a sum greater than or equal to 7 is [100], which only has a length of 1.\\n\\nInstead, consider using a sliding window approach. This method involves maintaining a \"window\" of elements that shifts rightward through the array. The window expands to the right as long as the sum is less than the target, and it shrinks from the left when the sum is greater than or equal to the target. Throughout this process, you keep track of the minimum window size where the sum is greater than or equal to the target. This ensures that you consider all possible subarrays."
                    },
                    {
                        "username": "shiro707",
                        "content": "How do you know which side to pop? "
                    },
                    {
                        "username": "BharathVanki",
                        "content": "l=0\\n        curr=0\\n        ans=999999999999\\n        for i in range(len(nums)):\\n            \\n            curr+=nums[i]\\n\\n            while (curr>=target):\\n                ans = min(ans,i-l+1)\\n                print(ans)\\n                curr=curr-nums[l]\\n                l+=1\\n        if(ans==999999999999):\\n            return 0\\n\\n        return ans\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "The solution says that the time complexity of O(n^2) is accepte: however, it gives time limit exceeded for my solution: as far as I understand my code should have quadratic time complexity in n: am I missing something? \\n\\n `class Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n\\n       \\n\\n        if  sum( nums ) < target:\\n\\n            return 0\\n\\n        \\n        min_sofar = int( 1e5 ) \\n\\n        for st in range( len( nums ) ):\\n\\n            current_sum = nums[st]\\n\\n            current_len = 1\\n\\n            end  = st\\n\\n\\n            while current_sum < target and current_len < min_sofar:\\n\\n                end += 1\\n\\n                if end  >= len( nums ):\\n\\n                    break\\n\\n                current_sum += nums[end]\\n\\n                current_len += 1\\n\\n                \\n\\n            if current_sum >= target:\\n\\n                if current_len < min_sofar:\\n\\n                    min_sofar = current_len\\n\\n        return min_sofar\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n      \\n        return min_len_sofar\\n\\n\\n\\n\\n        `"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your solution indeed has a time complexity of O(n^2). However, LeetCode has a certain time limit for each test case of a problem. If your solution exceeds this limit, it results in a Time Limit Exceeded error. Quadratic time complexity can often be too slow for larger inputs, and it seems that\\'s the case for your solution here.\\n\\nIn this problem, a quadratic time complexity solution might not be efficient enough for larger test cases because it will check every subarray in the worst-case scenario. \\n\\nThe problem can be solved in O(n) time complexity using a sliding window approach. In the sliding window approach, you start with a window at the leftmost part of the array and move it to the right, while keeping track of the sum of the elements in the window. If the sum is less than the target, you expand the window from the right. If the sum is more than or equal to the target, you shrink the window from the left and update the minimum length of the window that has been found so far. This approach will traverse the array only once, hence the time complexity is linear.\\n\\nIt\\'s a good practice to think about the time and space complexity of your solution before implementation. It can help you understand whether your approach will be efficient enough for all test cases."
                    },
                    {
                        "username": "anwer",
                        "content": "Is it consecutive sub array?"
                    },
                    {
                        "username": "shuydo12",
                        "content": "YEA"
                    },
                    {
                        "username": "user9444l",
                        "content": " `Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).`\\n\\nIs this approach related to prefix sum + binary search ? did this with another complexity approach"
                    },
                    {
                        "username": "nhaeri",
                        "content": "For nums=[2,16,14,15] and target=20, how is it possible that the expected output be 2? I think that it should be 0 as there is no sub array satisfying the condition. It is only possible if we use number 2, two times (16+2+2=20). If it is the case, then for nums=[1,1,1,1,1,1,1] and target=11, the expected output should not be 0. Where am I going wrong?"
                    },
                    {
                        "username": "kushagrasharma_13",
                        "content": "sum can be greater"
                    }
                ]
            },
            {
                "id": 1737255,
                "content": [
                    {
                        "username": "denniscorsi",
                        "content": "I could not figure out why my answer wasn\\'t matching the expected answer. After a lot of confusion, I learned that a subarray has to be *contiguous*. It would have been helpful to have that in the explanation. In math a subset does not have to be contiguous, so I didn\\'t know it would be different for an array. "
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right. It\\'s an important detail that can lead to misunderstanding if not explicitly stated. When we\\'re talking about subarrays in computer science, we are usually referring to contiguous sections of an array. This is different from the concept of a subset in mathematics, where elements do not have to be contiguous. \\n\\nIn the context of these problems, a subarray is a contiguous block of elements within the array. This is important because the solutions often involve techniques like sliding windows or prefix sums, which rely on the elements being contiguous.\\n\\nI understand the confusion and it\\'s a good point to remember for future programming problems. Always assume that subarray refers to contiguous elements unless explicitly stated otherwise."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you hover over the word subarray in the description, it will tell you that a subarray is contiguous. For non contiguous subsets of an array, we use the word \"subsequence\"."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "window sliding question"
                    },
                    {
                        "username": "RG7",
                        "content": "My code is not working can someone please see to it \\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left=0;\\n        int right=1;\\n        int sum=nums[0];\\n        while(sum<target){\\n            sum+=nums[right];\\n            right++;\\n        }\\n        int window = right-left;\\n        cout<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n        while(left!=nums.size()){\\n            cout<<\"a\";\\n            if(right==nums.size()&&sum<=target){\\n                cout<<\"p\";\\n                cout<<\"qq\";\\n                break;\\n                break;\\n            }\\n\\n            if(sum<=target){\\n                cout<<\"b\";\\n                if(sum==target&&right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                if(right<nums.size()){\\n                    sum+=nums[right];\\n                    right++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n                \\n            }\\n            else{\\n                cout<<\"c\";\\n                if(right-left<window)window=right-left;\\n                if(left<nums.size()){\\n                    sum-=nums[left];\\n                    left++;\\n                }\\n                cout<<\" \"<<left<<\" \"<<right<<\" \"<<window<<\" \"<<sum<<\" \"; \\n            }\\n        }\\n        return window;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "After reviewing your code, it seems like you\\'re trying to implement a sliding window approach to solve the problem. However, there are a few issues:\\n\\n1. Your outer while loop (`while(left!=nums.size())`) may lead to an infinite loop in some cases, because you\\'re not incrementing `left` in every iteration of the loop.\\n\\n2. Your code is not considering the possibility that the sum may not reach the target at all. This happens when you\\'re trying to calculate the initial sum before the main loop.\\n\\n3. The condition in your second `if` statement in the main loop (`if(sum<=target)`) is misleading. If the sum is equal to the target, you would want to update your minimum window size, decrement the sum by `nums[left]` and increment `left`. But if the sum is less than the target, you would want to increment `right` (if it\\'s less than `nums.size()`) and add `nums[right]` to the sum.\\n\\n4. The \\'else\\' part should handle when the sum is greater than the target, and not the other way around as it is in your code.\\n\\nHere is a revised version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int window = nums.size() + 1;\\n\\n        while (right < nums.size()) {\\n            while (sum < target && right < nums.size()) {\\n                sum += nums[right++];\\n            }\\n\\n            while (sum >= target) {\\n                window = min(window, right - left);\\n                sum -= nums[left++];\\n            }\\n        }\\n\\n        return window == nums.size() + 1 ? 0 : window;\\n    }\\n};\\n```\\n\\nThis code keeps expanding the window until the sum is greater than or equal to the target, and then it shrinks the window from the left until the sum is less than the target, while keeping track of the smallest window size. If no valid window is found, it returns 0.\\n"
                    },
                    {
                        "username": "Bill12138",
                        "content": "Can anyone have a look at my solution?\\n\\nSince the desired subarray must be a subarray of the original array, we can find it by keep popping the smaller end value (the left most value or right most value) out while the sum is greater.\\n\\nFor example, target = 7, nums = [2, 3, 1, 2, 4, 3]\\nsubarray = \\n[3, 1, 2, 4, 3]\\n[1, 2, 4, 3]\\n[2, 4, 3]\\n[4, 3]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach of starting with the entire array and shrinking it from one end when the sum is greater than or equal to the target is an interesting idea. However, it doesn\\'t always work as expected. \\n\\nThe primary issue with your approach is that it doesn\\'t account for situations where the sum of a smaller subarray could still meet the target value. Your algorithm is biased towards the beginning of the array, and may result in subarrays that are unnecessarily long.\\n\\nTake, for example, the array [1, 2, 3, 4, 100, 1, 1, 1, 1, 1] with a target of 7. Your algorithm would start by shrinking the array from the left until it ends up with the subarray [100, 1, 1, 1, 1, 1], which has a length of 6. However, the actual minimum length subarray with a sum greater than or equal to 7 is [100], which only has a length of 1.\\n\\nInstead, consider using a sliding window approach. This method involves maintaining a \"window\" of elements that shifts rightward through the array. The window expands to the right as long as the sum is less than the target, and it shrinks from the left when the sum is greater than or equal to the target. Throughout this process, you keep track of the minimum window size where the sum is greater than or equal to the target. This ensures that you consider all possible subarrays."
                    },
                    {
                        "username": "shiro707",
                        "content": "How do you know which side to pop? "
                    },
                    {
                        "username": "BharathVanki",
                        "content": "l=0\\n        curr=0\\n        ans=999999999999\\n        for i in range(len(nums)):\\n            \\n            curr+=nums[i]\\n\\n            while (curr>=target):\\n                ans = min(ans,i-l+1)\\n                print(ans)\\n                curr=curr-nums[l]\\n                l+=1\\n        if(ans==999999999999):\\n            return 0\\n\\n        return ans\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "The solution says that the time complexity of O(n^2) is accepte: however, it gives time limit exceeded for my solution: as far as I understand my code should have quadratic time complexity in n: am I missing something? \\n\\n `class Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n\\n       \\n\\n        if  sum( nums ) < target:\\n\\n            return 0\\n\\n        \\n        min_sofar = int( 1e5 ) \\n\\n        for st in range( len( nums ) ):\\n\\n            current_sum = nums[st]\\n\\n            current_len = 1\\n\\n            end  = st\\n\\n\\n            while current_sum < target and current_len < min_sofar:\\n\\n                end += 1\\n\\n                if end  >= len( nums ):\\n\\n                    break\\n\\n                current_sum += nums[end]\\n\\n                current_len += 1\\n\\n                \\n\\n            if current_sum >= target:\\n\\n                if current_len < min_sofar:\\n\\n                    min_sofar = current_len\\n\\n        return min_sofar\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n      \\n        return min_len_sofar\\n\\n\\n\\n\\n        `"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your solution indeed has a time complexity of O(n^2). However, LeetCode has a certain time limit for each test case of a problem. If your solution exceeds this limit, it results in a Time Limit Exceeded error. Quadratic time complexity can often be too slow for larger inputs, and it seems that\\'s the case for your solution here.\\n\\nIn this problem, a quadratic time complexity solution might not be efficient enough for larger test cases because it will check every subarray in the worst-case scenario. \\n\\nThe problem can be solved in O(n) time complexity using a sliding window approach. In the sliding window approach, you start with a window at the leftmost part of the array and move it to the right, while keeping track of the sum of the elements in the window. If the sum is less than the target, you expand the window from the right. If the sum is more than or equal to the target, you shrink the window from the left and update the minimum length of the window that has been found so far. This approach will traverse the array only once, hence the time complexity is linear.\\n\\nIt\\'s a good practice to think about the time and space complexity of your solution before implementation. It can help you understand whether your approach will be efficient enough for all test cases."
                    },
                    {
                        "username": "anwer",
                        "content": "Is it consecutive sub array?"
                    },
                    {
                        "username": "shuydo12",
                        "content": "YEA"
                    },
                    {
                        "username": "user9444l",
                        "content": " `Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).`\\n\\nIs this approach related to prefix sum + binary search ? did this with another complexity approach"
                    },
                    {
                        "username": "nhaeri",
                        "content": "For nums=[2,16,14,15] and target=20, how is it possible that the expected output be 2? I think that it should be 0 as there is no sub array satisfying the condition. It is only possible if we use number 2, two times (16+2+2=20). If it is the case, then for nums=[1,1,1,1,1,1,1] and target=11, the expected output should not be 0. Where am I going wrong?"
                    },
                    {
                        "username": "kushagrasharma_13",
                        "content": "sum can be greater"
                    }
                ]
            }
        ]
    }
]