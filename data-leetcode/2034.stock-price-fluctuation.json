[
    {
        "title": "Stock Price Fluctuation ",
        "question_content": "You are given a stream of records about a particular stock. Each record contains a timestamp and the corresponding price of the stock at that timestamp.\nUnfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream correcting the price of the previous wrong record.\nDesign an algorithm that:\n\n\tUpdates the price of the stock at a particular timestamp, correcting the price from any previous records at the timestamp.\n\tFinds the latest price of the stock based on the current records. The latest price is the price at the latest timestamp recorded.\n\tFinds the maximum price the stock has been based on the current records.\n\tFinds the minimum price the stock has been based on the current records.\n\nImplement the StockPrice class:\n\n\tStockPrice() Initializes the object with no price records.\n\tvoid update(int timestamp, int price) Updates the price of the stock at the given timestamp.\n\tint current() Returns the latest price of the stock.\n\tint maximum() Returns the maximum price of the stock.\n\tint minimum() Returns the minimum price of the stock.\n\n&nbsp;\nExample 1:\n\nInput\n[\"StockPrice\", \"update\", \"update\", \"current\", \"maximum\", \"update\", \"maximum\", \"update\", \"minimum\"]\n[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\nOutput\n[null, null, null, 5, 10, null, 5, null, 2]\nExplanation\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].\nstockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].\nstockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.\nstockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.\nstockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.\n                          // Timestamps are [1,2] with corresponding prices [3,5].\nstockPrice.maximum();     // return 5, the maximum price is 5 after the correction.\nstockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].\nstockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= timestamp, price <= 109\n\tAt most 105 calls will be made in total to update, current, maximum, and minimum.\n\tcurrent, maximum, and minimum will be called only after update has been called at least once.",
        "solutions": [
            {
                "id": 1513293,
                "title": "python-clean-2-heaps-commented-code",
                "content": "Keep a hashmap of timestamp to prices. When updating a timestamp, push it in a heap along with it\\'s timestamp. \\n\\nWhen maximum or minimum is called, if the timestamp doesn\\'t match it\\'s current price, this indiciates it\\'s value has been updated in the meantime. Keeping popping elements off the heap until an element matches it\\'s current price\\n\\n\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.timestamps = {}\\n        self.highestTimestamp = 0\\n        self.minHeap = []\\n        self.maxHeap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n\\t    #Keep track of current prices\\n        self.timestamps[timestamp] = price\\n        self.highestTimestamp = max(self.highestTimestamp, timestamp)\\n        \\n\\t\\t#For maximum/minimum\\n        heappush(self.minHeap, (price, timestamp))\\n        heappush(self.maxHeap, (-price, timestamp))\\n\\n    def current(self) -> int:\\n\\t    #Just return the highest timestamp in O(1)\\n        return self.timestamps[self.highestTimestamp]\\n\\n    def maximum(self) -> int:\\n        currPrice, timestamp = heappop(self.maxHeap)\\n\\t\\t\\n\\t\\t#If the price from the heap doesn\\'t match the price the timestamp indicates, keep popping from the heap\\n        while -currPrice != self.timestamps[timestamp]:\\n            currPrice, timestamp = heappop(self.maxHeap)\\n            \\n        heappush(self.maxHeap, (currPrice, timestamp))\\n        return -currPrice\\n\\n    def minimum(self) -> int:\\n        currPrice, timestamp = heappop(self.minHeap)\\n\\t\\t\\n\\t\\t#If the price from the heap doesn\\'t match the price the timestamp indicates, keep popping from the heap\\n        while currPrice != self.timestamps[timestamp]:\\n            currPrice, timestamp = heappop(self.minHeap)\\n            \\n        heappush(self.minHeap, (currPrice, timestamp))\\n        return currPrice\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.timestamps = {}\\n        self.highestTimestamp = 0\\n        self.minHeap = []\\n        self.maxHeap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n\\t    #Keep track of current prices\\n        self.timestamps[timestamp] = price\\n        self.highestTimestamp = max(self.highestTimestamp, timestamp)\\n        \\n\\t\\t#For maximum/minimum\\n        heappush(self.minHeap, (price, timestamp))\\n        heappush(self.maxHeap, (-price, timestamp))\\n\\n    def current(self) -> int:\\n\\t    #Just return the highest timestamp in O(1)\\n        return self.timestamps[self.highestTimestamp]\\n\\n    def maximum(self) -> int:\\n        currPrice, timestamp = heappop(self.maxHeap)\\n\\t\\t\\n\\t\\t#If the price from the heap doesn\\'t match the price the timestamp indicates, keep popping from the heap\\n        while -currPrice != self.timestamps[timestamp]:\\n            currPrice, timestamp = heappop(self.maxHeap)\\n            \\n        heappush(self.maxHeap, (currPrice, timestamp))\\n        return -currPrice\\n\\n    def minimum(self) -> int:\\n        currPrice, timestamp = heappop(self.minHeap)\\n\\t\\t\\n\\t\\t#If the price from the heap doesn\\'t match the price the timestamp indicates, keep popping from the heap\\n        while currPrice != self.timestamps[timestamp]:\\n            currPrice, timestamp = heappop(self.minHeap)\\n            \\n        heappush(self.minHeap, (currPrice, timestamp))\\n        return currPrice\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513413,
                "title": "java-c-python-strightforward-solutions",
                "content": "# **Explanation**\\nUse whatever a sorted data structure in each lanuage,\\nmost likely a binary search tree.\\n<br>\\n\\n# **Complexity**\\nTime `O(logn)` for each function\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\nall from @blackspinner, using TreeMap\\n```java\\nclass StockPrice {\\n    TreeMap<Integer, Integer> record = new TreeMap<>();\\n    TreeMap<Integer, Set<Integer>> vals = new TreeMap<>();\\n\\n    public void update(int timestamp, int price) {\\n        if (record.containsKey(timestamp)) {\\n            int prevPrice = record.get(timestamp);\\n            Set<Integer> book = vals.get(prevPrice);\\n            book.remove(timestamp);\\n            if (book.isEmpty()) {\\n                vals.remove(prevPrice);\\n            }\\n        }\\n        vals.putIfAbsent(price, new HashSet<>());\\n        vals.get(price).add(timestamp);\\n        record.put(timestamp, price);\\n    }\\n\\n    public int current() {\\n        return record.lastEntry().getValue();\\n    }\\n\\n    public int maximum() {\\n        return vals.lastKey();\\n    }\\n\\n    public int minimum() {\\n        return vals.firstKey();\\n    }\\n}\\n```\\n\\n**C++**\\n```cpp\\npublic:\\n    map<int, int> rec;\\n    multiset<int> count;\\n\\n    void update(int t, int p) {\\n        if (rec.find(t) != rec.end())\\n            count.erase(count.find(rec[t]));\\n        rec[t] = p;\\n        count.insert(p);\\n    }\\n\\n    int current() {\\n        return rec.rbegin()->second;\\n    }\\n\\n    int maximum() {\\n        return *count.rbegin();\\n    }\\n\\n    int minimum() {\\n        return *count.begin();\\n    }\\n```\\n\\n**Python**\\nall from @blackspinner, using SortedDict\\n```py\\nfrom sortedcontainers import SortedDict\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.time_to_prices = SortedDict()\\n        self.rec = SortedDict()\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.time_to_prices:\\n            prev_price = self.time_to_prices[timestamp]\\n            self.rec[prev_price].remove(timestamp)\\n            if len(self.rec[prev_price]) == 0:\\n                self.rec.pop(prev_price)\\n        if not price in self.rec:\\n            self.rec[price] = set()\\n        self.rec[price].add(timestamp)\\n        self.time_to_prices[timestamp] = price\\n\\n    def current(self) -> int:\\n        return self.time_to_prices.peekitem(-1)[1]\\n\\n    def maximum(self) -> int:\\n        return self.rec.peekitem(-1)[0]\\n\\n    def minimum(self) -> int:\\n        return self.rec.peekitem(0)[0]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nclass StockPrice {\\n    TreeMap<Integer, Integer> record = new TreeMap<>();\\n    TreeMap<Integer, Set<Integer>> vals = new TreeMap<>();\\n\\n    public void update(int timestamp, int price) {\\n        if (record.containsKey(timestamp)) {\\n            int prevPrice = record.get(timestamp);\\n            Set<Integer> book = vals.get(prevPrice);\\n            book.remove(timestamp);\\n            if (book.isEmpty()) {\\n                vals.remove(prevPrice);\\n            }\\n        }\\n        vals.putIfAbsent(price, new HashSet<>());\\n        vals.get(price).add(timestamp);\\n        record.put(timestamp, price);\\n    }\\n\\n    public int current() {\\n        return record.lastEntry().getValue();\\n    }\\n\\n    public int maximum() {\\n        return vals.lastKey();\\n    }\\n\\n    public int minimum() {\\n        return vals.firstKey();\\n    }\\n}\\n```\n```cpp\\npublic:\\n    map<int, int> rec;\\n    multiset<int> count;\\n\\n    void update(int t, int p) {\\n        if (rec.find(t) != rec.end())\\n            count.erase(count.find(rec[t]));\\n        rec[t] = p;\\n        count.insert(p);\\n    }\\n\\n    int current() {\\n        return rec.rbegin()->second;\\n    }\\n\\n    int maximum() {\\n        return *count.rbegin();\\n    }\\n\\n    int minimum() {\\n        return *count.begin();\\n    }\\n```\n```py\\nfrom sortedcontainers import SortedDict\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.time_to_prices = SortedDict()\\n        self.rec = SortedDict()\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.time_to_prices:\\n            prev_price = self.time_to_prices[timestamp]\\n            self.rec[prev_price].remove(timestamp)\\n            if len(self.rec[prev_price]) == 0:\\n                self.rec.pop(prev_price)\\n        if not price in self.rec:\\n            self.rec[price] = set()\\n        self.rec[price].add(timestamp)\\n        self.time_to_prices[timestamp] = price\\n\\n    def current(self) -> int:\\n        return self.time_to_prices.peekitem(-1)[1]\\n\\n    def maximum(self) -> int:\\n        return self.rec.peekitem(-1)[0]\\n\\n    def minimum(self) -> int:\\n        return self.rec.peekitem(0)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513324,
                "title": "python3-hash-map-2-heaps",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/933e9b50b2532374ab8252f431da84b6675663a8) for solutions of weekly 262.\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.mp = {}\\n        self.maxp = [] # max-heap \\n        self.minp = [] # min-heap \\n        self.latest = 0 # latest timestamp\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.mp[timestamp] = price \\n        if self.latest <= timestamp: self.latest = timestamp\\n        heappush(self.maxp, (-price, timestamp))\\n        heappush(self.minp, (price, timestamp))\\n\\n    def current(self) -> int:\\n        return self.mp[self.latest]\\n\\n    def maximum(self) -> int:\\n        while self.mp[self.maxp[0][1]] != -self.maxp[0][0]: heappop(self.maxp)\\n        return -self.maxp[0][0]\\n\\n    def minimum(self) -> int:\\n        while self.mp[self.minp[0][1]] != self.minp[0][0]: heappop(self.minp)\\n        return self.minp[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.mp = {}\\n        self.maxp = [] # max-heap \\n        self.minp = [] # min-heap \\n        self.latest = 0 # latest timestamp\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.mp[timestamp] = price \\n        if self.latest <= timestamp: self.latest = timestamp\\n        heappush(self.maxp, (-price, timestamp))\\n        heappush(self.minp, (price, timestamp))\\n\\n    def current(self) -> int:\\n        return self.mp[self.latest]\\n\\n    def maximum(self) -> int:\\n        while self.mp[self.maxp[0][1]] != -self.maxp[0][0]: heappop(self.maxp)\\n        return -self.maxp[0][0]\\n\\n    def minimum(self) -> int:\\n        while self.mp[self.minp[0][1]] != self.minp[0][0]: heappop(self.minp)\\n        return self.minp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513345,
                "title": "map-and-multiset",
                "content": "The `update` function is where everything happens:\\n- we use a multimap to track all prices\\n- when we update the existing price, we need to remove the old one from the multimap\\n- we use a hashmap of timepoints to prices to handle updates.\\n\\nTo return the most recent price, we could either track in separately (approach 2). Or, we could use an ordered map instead of hashmap, and return the price for the largest timepoint (approach 1).\\n#### Approach 1: Ordered Map\\n**C++**\\n```cpp\\nmap<int, int> m;\\nmultiset<int> prices;\\nvoid update(int timestamp, int price) {\\n    auto it = m.find(timestamp);\\n    if (it != end(m))\\n        prices.erase(prices.find(it->second));\\n    prices.insert(price);\\n    m[timestamp] = price;\\n}\\nint current() { return rbegin(m)->second; }\\nint maximum() { return *rbegin(prices); }\\nint minimum() { return *begin(prices); }\\n```\\n\\n#### Approach 2: Hash Map\\n**C++**\\n```cpp\\nunordered_map<int, int> m;\\nmultiset<int> prices;\\nint last_timestamp = 0, last_price = 0;\\nvoid update(int timestamp, int price) {\\n    auto it = m.find(timestamp);\\n    if (it != end(m))\\n        prices.erase(prices.find(it->second));\\n    prices.insert(price);\\n    m[timestamp] = price;\\n    if (timestamp >= last_timestamp) {\\n        last_timestamp = timestamp;\\n        last_price = price;\\n    }\\n}\\nint current() { return last_price; }\\nint maximum() { return *rbegin(prices); }\\nint minimum() { return *begin(prices); }\\n```",
                "solutionTags": [],
                "code": "```cpp\\nmap<int, int> m;\\nmultiset<int> prices;\\nvoid update(int timestamp, int price) {\\n    auto it = m.find(timestamp);\\n    if (it != end(m))\\n        prices.erase(prices.find(it->second));\\n    prices.insert(price);\\n    m[timestamp] = price;\\n}\\nint current() { return rbegin(m)->second; }\\nint maximum() { return *rbegin(prices); }\\nint minimum() { return *begin(prices); }\\n```\n```cpp\\nunordered_map<int, int> m;\\nmultiset<int> prices;\\nint last_timestamp = 0, last_price = 0;\\nvoid update(int timestamp, int price) {\\n    auto it = m.find(timestamp);\\n    if (it != end(m))\\n        prices.erase(prices.find(it->second));\\n    prices.insert(price);\\n    m[timestamp] = price;\\n    if (timestamp >= last_timestamp) {\\n        last_timestamp = timestamp;\\n        last_price = price;\\n    }\\n}\\nint current() { return last_price; }\\nint maximum() { return *rbegin(prices); }\\nint minimum() { return *begin(prices); }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513323,
                "title": "simple-java-treemap-solution",
                "content": "```\\nclass StockPrice {\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        TreeMap<Integer, Set<Integer>> valueTimeStamp = new TreeMap<>();\\n    public StockPrice() {\\n        tm = new TreeMap<>();\\n        valueTimeStamp = new TreeMap<>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(tm.containsKey(timestamp)){//update to existing value - correction\\n            int oldPrice = tm.get(timestamp);\\n            valueTimeStamp.get(oldPrice).remove(timestamp);\\n            if(valueTimeStamp.get(oldPrice).size()==0)//if only one timestamp had the value and it later got updated \\n                valueTimeStamp.remove(oldPrice);\\n        }\\n        tm.put(timestamp, price);\\n        valueTimeStamp.putIfAbsent(price, new HashSet<>());\\n        valueTimeStamp.get(price).add(timestamp);\\n    }\\n    \\n    public int current() {\\n       return tm.get(tm.lastKey());\\n    }\\n    \\n    public int maximum() {\\n       return valueTimeStamp.lastKey();\\n    }\\n    \\n    public int minimum() {\\n       return valueTimeStamp.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        TreeMap<Integer, Set<Integer>> valueTimeStamp = new TreeMap<>();\\n    public StockPrice() {\\n        tm = new TreeMap<>();\\n        valueTimeStamp = new TreeMap<>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(tm.containsKey(timestamp)){//update to existing value - correction\\n            int oldPrice = tm.get(timestamp);\\n            valueTimeStamp.get(oldPrice).remove(timestamp);\\n            if(valueTimeStamp.get(oldPrice).size()==0)//if only one timestamp had the value and it later got updated \\n                valueTimeStamp.remove(oldPrice);\\n        }\\n        tm.put(timestamp, price);\\n        valueTimeStamp.putIfAbsent(price, new HashSet<>());\\n        valueTimeStamp.get(price).add(timestamp);\\n    }\\n    \\n    public int current() {\\n       return tm.get(tm.lastKey());\\n    }\\n    \\n    public int maximum() {\\n       return valueTimeStamp.lastKey();\\n    }\\n    \\n    public int minimum() {\\n       return valueTimeStamp.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514279,
                "title": "detailed-explanation-two-maps-c-clean-code",
                "content": "***If you find this solution helpful do give it a like :)***\\n\\n**Explanation :** \\n\\nIdea is to use map to keep track of prices and its count at various timestamps for stock. This map is used to get *minimum and maximum overall price* of stock till current timestamp. \\n\\n* We take 2 maps to track prices and timestamps :\\n\\n\\t1. **`stock`** : This map has key as `timestamp` and value is `price` of stock at that timestamp. This will be used to `update()` price for given timestamp.\\n\\n\\t2. **`prices`** : It has count of various `price` a stock can have at multiple timestamps. Since we can have same price at *different timestamps*. Thus, it stores the count of different timestamps this price is part of. \\n\\n* Now, to `update()` stock price, we have 2 cases : either we have a new timestamp, or else we can have new price for existing timestamp. \\n\\n\\t* **Case 1:** Here we simple need to add new entry in stock (timestamp) map as well as in stock prices map. \\n\\t\\n\\t* **Case 2:** In this case we need since we already have a price for given timestamp and we need to update that. \\n\\t\\t* So here, we get `old price` from `stock` map for current timestam.\\n\\t\\t* and then decrement 1 from the count of `old_price` in  prices map. \\n\\t\\t* And if anytime count reaches 0, we remove entry for that price from `prices` map. \\n\\t\\t* Rest we do same as we did in Case 1. i.e create new entry in stock and increment count in prices\\n\\n\\t\\t* Lets Dry run on some cases to get better understanding : \\n\\n\\t\\t\\t\\t1. update(1, 10)  :  Here 1 is timestamp and 10 is price\\n\\t\\t\\t\\t\\t\\t# prices : [ {10 -> 1} ]  \\n\\t\\t\\t\\t\\t\\t# stock [  {1 -> 10} ]\\n\\n\\t\\t\\t\\t2. update(2, 5) : Here 2 is timestamp and 5 is price \\n\\t\\t\\t\\t\\t\\t# prices : [ {5 -> 1} , {10 -> 1} ]  \\n\\t\\t\\t\\t\\t\\t# stock [  {1 -> 10} , {2 -> 5} ]\\n\\n\\t\\t\\t\\t3. update(5, 10) : Here 5 is timestamp and 10 is price \\n\\t\\t\\t\\t\\t    -> here count of price = 10 will be incremented\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# prices : [ {5 -> 1} , {10 -> 2} ]   \\n\\t\\t\\t\\t\\t\\t# stock [  {1 -> 10} , {2 -> 5} , {5 -> 10} ]\\n\\n\\t\\t\\t\\t4. update(1, 3) : Here 1 is timestamp and 3 is price , \\n\\t\\t\\t\\t\\t\\t-> since existing timestamp, so we have Case 2 here\\n\\t\\t\\t\\t\\t\\t-> here we decrement count of price = 10, and increment count of price = 3\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# prices : [ {3 -> 1} , {5 -> 1} , {10 -> 1} ] \\n\\t\\t\\t\\t\\t\\t# stock [  {1 -> 3} , {2 -> 5} , {5 -> 10} ], update price for timestamp-1 to price = 3\\n\\n\\t\\t\\t\\t5. update(4, 2) : new timestamp and price, so create a new entry \\n\\t\\t\\t\\t\\t\\t# prices : [ {2 -> 1} {3 -> 1} , {5 -> 1} , {10 -> 1} ] \\n\\t\\t\\t\\t\\t\\t# stock [  {1 -> 3} , {2 -> 5} , {4 -> 2} , {5 -> 10} ]\\n\\n* Also, to get current price we use a pair `currentStock`, which store `{timestamp, price}`. So everytime we get an update request, simple update this pair is current timestamp is less than the timestamp in request.\\n\\n* Since we are using map to store `prices` so items are sorted by keys i.e prices. Thus, top element of map will give `minimum` price and bottom/last element will give us `maximum` price. \\n\\n# Code : \\n\\n```\\nclass StockPrice {\\n    map<int, int> stock; \\n    map<int, int> prices;\\n    pair<int, int> currentStock = {-1, -1};\\npublic:\\n    \\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n\\t\\n\\t\\t// Update current stock price if we get a new greater timestamp\\n        if(timestamp >= currentStock.first) {\\n            currentStock = {timestamp, price};\\n        }\\n        \\n        if(stock.find(timestamp) != stock.end()) {\\n\\t\\t\\t// Case 2\\n            int old_price = stock[timestamp];  // Get old price for timestamp\\n            \\n            prices[old_price]--;  // Reduce count \\n            if(prices[old_price] == 0) prices.erase(old_price); // Remove if no timestamp has old price\\n        }\\n        \\n\\t\\t// Case 1\\n        prices[price]++;  \\n        stocks[timestamp] = price;   \\n        \\n    }\\n    \\n    int current() {\\n        return currentStock.second;\\n    }\\n    \\n    int maximum() {\\n\\t\\t\\treturn prices.rbegin()->first;  // GET last element\\n    }\\n    \\n    int minimum() {\\n        return prices.begin()->first; // Get first element\\n    }\\n};\\n```\\n\\n**Complexity Analysis :** \\n\\n* **Time  :** \\n\\t* `update()` : **O(N log N)** , N -> number of update() calls\\n\\t* `maximum()`, `minimum()` :  **O(1)** , since we can get top and bottom in contant time.\\n \\n * **Space :** : **O(2N)** , since we are using two maps for storing timestamp and prices entries.\\n\\nSimilar Problems :\\n\\n* [Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)\\n \\n***If you find this solution helpful do give it a like, it motivates me to write posts like this :)***",
                "solutionTags": [
                    "C",
                    "Design"
                ],
                "code": "```\\nclass StockPrice {\\n    map<int, int> stock; \\n    map<int, int> prices;\\n    pair<int, int> currentStock = {-1, -1};\\npublic:\\n    \\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n\\t\\n\\t\\t// Update current stock price if we get a new greater timestamp\\n        if(timestamp >= currentStock.first) {\\n            currentStock = {timestamp, price};\\n        }\\n        \\n        if(stock.find(timestamp) != stock.end()) {\\n\\t\\t\\t// Case 2\\n            int old_price = stock[timestamp];  // Get old price for timestamp\\n            \\n            prices[old_price]--;  // Reduce count \\n            if(prices[old_price] == 0) prices.erase(old_price); // Remove if no timestamp has old price\\n        }\\n        \\n\\t\\t// Case 1\\n        prices[price]++;  \\n        stocks[timestamp] = price;   \\n        \\n    }\\n    \\n    int current() {\\n        return currentStock.second;\\n    }\\n    \\n    int maximum() {\\n\\t\\t\\treturn prices.rbegin()->first;  // GET last element\\n    }\\n    \\n    int minimum() {\\n        return prices.begin()->first; // Get first element\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905632,
                "title": "java-full-explanation-interview-tips-2-solutions",
                "content": "# Interview process\\nThis problem is not so complicated for a leetcode perspective, so that\\'s why it is considered as medium. For an interview, it may be a hard problem, because of many traps we can fall in.\\n\\n## The easy trap to fall in\\nGo directly to code the solution. There is actually two optimal solutions, and it all depends on ... clarifying questions.\\nFor this problem, don\\'t miss them.\\n\\nOne very important question to ask : \"*How frequently may update be called compare to the max and min methods?*\"\\n\\nIf the answer is (very unlikely) : update may be called billions of times while max and min may be called only once. Consider that we log all the stock price, but want to get the statistics only once a month, then the first solution will be the best approach.\\n\\nIf the answer is (very likely) : they will be all called approximately the same amount of time, then the second approach is the best.\\n\\nIn an interview, you will always be in the second scenario, because the first one is not interesting for an interview purpose (as we will see, it\\'s just about sorting a list). But the fact that you ask will clearly show that you consider all possible cases.\\n\\n## Get the current price\\n\\nThis is the common part of the code, we just keep the last timestamp, and if a record is made with a timestamp which is equal or greater than the last timestamp, we update the value:\\n\\n```\\nclass StockPrice {\\n    private int currentStockPrice;\\n    private int currentTimestamp;\\n    public StockPrice() {\\n        currentStockPrice = 0;\\n        currentTimestamp = 0;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= currentTimestamp) {\\n            currentTimestamp = timestamp;\\n            currentStockPrice = price;\\n        }\\n    }\\n    \\n    public int current() {\\n        return currentStockPrice;\\n    }\\n    \\n    public int maximum() {\\n    }\\n    \\n    public int minimum() {\\n    }\\n}\\n```\\n\\n## List or PriorityQueue vs Map or Set\\n\\nThis is a general thought about the best solution. Now we will need to store all the stock prices. We could store it as a list, or as a Map with occurrences.\\nOf course, when it comes to duplicate values for stock price, the Map will be better than the list in terms of space used, even if this does not improve the space complexity.\\n\\n## If max and min are called a lot less than update\\n\\nIn that case, we want to have the best time complexity for update(), and according to that, the best possible complexity for maximum and minimum.\\nSo all we have to do here is to store all the stock prices, and sort them when max or min is called.\\n\\n**ATTENTION: This solution will end to a Time Limit Exceeded in Leetcode**\\n\\n```\\nclass StockPrice {\\n    private int currentStockPrice;\\n    private int currentTimestamp;\\n    private final Map<Integer, Integer> timestampPrices;\\n    private final Map<Integer, Integer> occurrences;\\n    \\n    public StockPrice() {\\n        currentStockPrice = 0;\\n        currentTimestamp = 0;\\n        occurrences = new HashMap();\\n        timestampPrices = new HashMap();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= currentTimestamp) {\\n            currentTimestamp = timestamp;\\n            currentStockPrice = price;\\n        }\\n        if(timestampPrices.containsKey(timestamp)) {\\n            int oldPrice = timestampPrices.get(timestamp);\\n            if(occurrences.get(oldPrice) == 1) {\\n                occurrences.remove(oldPrice);\\n            } else {\\n                occurrences.put(oldPrice, occurrences.get(oldPrice)-1);\\n            }\\n        }\\n        timestampPrices.put(timestamp, price);\\n        occurrences.put(price, occurrences.getOrDefault(price, 0)+1);\\n    }\\n    \\n    public int current() {\\n        return currentStockPrice;\\n    }\\n    \\n    public int maximum() {\\n        List<Integer> prices = new ArrayList(occurrences.keySet());\\n        Collections.sort(prices);\\n        return prices.get(prices.size()-1);\\n    }\\n    \\n    public int minimum() {\\n        List<Integer> prices = new ArrayList(occurrences.keySet());\\n        Collections.sort(prices);\\n        return prices.get(0);\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```\\n\\nIn this case, the time complexity of the `update()` method is `O(1)` while `minimum()` and `maximum()` methods have a time complexity of `O(nlogn)` as we are sorting the values.\\n\\n## If all methods are called approximately the same amount of time.\\n\\nThen the problem is not the same, we want to optimize the time complexity of each method, and not only the `update()` method. For example, using a TreeSet in Java will have a time complexity of `O(logn)` for each operation (search, add, remove, ...).\\nThis could end up to a `O(logn)` time complexity for `update` and `O(1)` for minimum and maximum.\\n\\n### Thought : Why isn\\'t it an optimal solution in first scenario\\n\\nSo to clarify, in the first scenario, we ended up with an `O(nlogn)` solution for min and max, and `O(1)` for update. Now considering that the `update` method will be called `n` times, why is this worst than the current approach which has a complexity of `logn`.\\nIt\\'s an other trap of time complexity calculation : calling with the same word (here `n`) things which are not the same. When we say max and min have a complexity of `O(nlogn)` we consider `n` as the number of distinct prices in the list, not the number of times you called the `update` method.\\nIf we consider a scenario with a lot of duplicate, and a lot of updates for the same timestamp, then the number of times we call the `update` method will be significantly higher than what we call `n`.\\n\\nThe the solution for the second scenario is:\\n\\n```\\nclass StockPrice {\\n    private final Map<Integer, Integer> map;\\n    private TreeSet<Integer> set;\\n    private int currentStockPrice;\\n    private int currentTimestamp;\\n    private Map<Integer, Integer> occurrences;\\n    public StockPrice() {\\n        map = new HashMap();\\n        set = new TreeSet();\\n        occurrences = new HashMap();\\n        currentStockPrice = 0;\\n        currentTimestamp = 0;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= currentTimestamp) {\\n            currentTimestamp = timestamp;\\n            currentStockPrice = price;\\n        }\\n        if(map.containsKey(timestamp)) {\\n            int oldPrice = map.get(timestamp);\\n            if(occurrences.get(oldPrice) == 1) {\\n                occurrences.remove(oldPrice);\\n                set.remove(oldPrice);\\n            } else {\\n                occurrences.put(oldPrice, occurrences.get(oldPrice)-1);\\n            }\\n        }\\n        int currentPrice = price;\\n        map.put(timestamp, currentPrice);\\n        set.add(currentPrice);\\n        occurrences.put(currentPrice, occurrences.getOrDefault(currentPrice, 0) + 1);\\n    }\\n    \\n    public int current() {\\n        return currentStockPrice;\\n    }\\n    \\n    public int maximum() {\\n        return set.last();\\n    }\\n    \\n    public int minimum() {\\n        return set.first();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```\\n\\nHere, the `update` method has a time complexity of : `O(1)` for the current price + `O(logn)` for removal + `O(logn)` for addition, which simplifies to `O(logn)`.\\nThe `maximum` and `minimum` methods just look for the first and last element, so they have a time complexity of `O(1)`, same as `current`.\\n\\nIf anything is unclear, feel free to ask by commenting this post.\\n\\n## Follow-up question\\n\\nActually, an other clarifying question may come to an other solution, and the question is *How often will the maximum value be updated to a lower value, or the minimum value be updated to a higher value*.\\n\\nIf the answer is never, then I let you find the `O(1)` solution for each method. If the answer is almost never, then it may be a good idea to calculate the min and the max each time it is updated in the `update()` method. As the answer *never* or *almost never* will never be answered, then I will not share this solution here.\\n\\nTo be honest, you don\\'t have to ask this question, think about time first, so no need to ask too much questions. But when the interviewer will ask you *Is there any way you could improve this algorithm*, then you can share about this scenario, and that in this case, you would calculate the min and max in `update()` directly, without the use of a `TreeSet`.",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass StockPrice {\\n    private int currentStockPrice;\\n    private int currentTimestamp;\\n    public StockPrice() {\\n        currentStockPrice = 0;\\n        currentTimestamp = 0;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= currentTimestamp) {\\n            currentTimestamp = timestamp;\\n            currentStockPrice = price;\\n        }\\n    }\\n    \\n    public int current() {\\n        return currentStockPrice;\\n    }\\n    \\n    public int maximum() {\\n    }\\n    \\n    public int minimum() {\\n    }\\n}\\n```\n```\\nclass StockPrice {\\n    private int currentStockPrice;\\n    private int currentTimestamp;\\n    private final Map<Integer, Integer> timestampPrices;\\n    private final Map<Integer, Integer> occurrences;\\n    \\n    public StockPrice() {\\n        currentStockPrice = 0;\\n        currentTimestamp = 0;\\n        occurrences = new HashMap();\\n        timestampPrices = new HashMap();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= currentTimestamp) {\\n            currentTimestamp = timestamp;\\n            currentStockPrice = price;\\n        }\\n        if(timestampPrices.containsKey(timestamp)) {\\n            int oldPrice = timestampPrices.get(timestamp);\\n            if(occurrences.get(oldPrice) == 1) {\\n                occurrences.remove(oldPrice);\\n            } else {\\n                occurrences.put(oldPrice, occurrences.get(oldPrice)-1);\\n            }\\n        }\\n        timestampPrices.put(timestamp, price);\\n        occurrences.put(price, occurrences.getOrDefault(price, 0)+1);\\n    }\\n    \\n    public int current() {\\n        return currentStockPrice;\\n    }\\n    \\n    public int maximum() {\\n        List<Integer> prices = new ArrayList(occurrences.keySet());\\n        Collections.sort(prices);\\n        return prices.get(prices.size()-1);\\n    }\\n    \\n    public int minimum() {\\n        List<Integer> prices = new ArrayList(occurrences.keySet());\\n        Collections.sort(prices);\\n        return prices.get(0);\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```\n```\\nclass StockPrice {\\n    private final Map<Integer, Integer> map;\\n    private TreeSet<Integer> set;\\n    private int currentStockPrice;\\n    private int currentTimestamp;\\n    private Map<Integer, Integer> occurrences;\\n    public StockPrice() {\\n        map = new HashMap();\\n        set = new TreeSet();\\n        occurrences = new HashMap();\\n        currentStockPrice = 0;\\n        currentTimestamp = 0;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= currentTimestamp) {\\n            currentTimestamp = timestamp;\\n            currentStockPrice = price;\\n        }\\n        if(map.containsKey(timestamp)) {\\n            int oldPrice = map.get(timestamp);\\n            if(occurrences.get(oldPrice) == 1) {\\n                occurrences.remove(oldPrice);\\n                set.remove(oldPrice);\\n            } else {\\n                occurrences.put(oldPrice, occurrences.get(oldPrice)-1);\\n            }\\n        }\\n        int currentPrice = price;\\n        map.put(timestamp, currentPrice);\\n        set.add(currentPrice);\\n        occurrences.put(currentPrice, occurrences.getOrDefault(currentPrice, 0) + 1);\\n    }\\n    \\n    public int current() {\\n        return currentStockPrice;\\n    }\\n    \\n    public int maximum() {\\n        return set.last();\\n    }\\n    \\n    public int minimum() {\\n        return set.first();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514021,
                "title": "java-68-ms-faster-than-100-using-2-priorityqueue-and-1-hashmap",
                "content": "```\\nclass StockRecord {\\n    int timestamp;\\n    int price;\\n    \\n    public StockRecord(){}\\n    \\n    public StockRecord(int t, int p) {\\n        timestamp = t;\\n        price = p;\\n    }\\n}\\n\\nclass StockPrice {\\n    \\n    PriorityQueue<StockRecord> max = new PriorityQueue<>((sr1, sr2) -> (sr2.price - sr1.price));\\n    PriorityQueue<StockRecord> min = new PriorityQueue<>((sr1, sr2) -> (sr1.price - sr2.price));\\n    StockRecord current_record;\\n    Map<Integer, Integer> map = new HashMap<>();\\n\\n    \\n    public StockPrice() {\\n        current_record = new StockRecord();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= current_record.timestamp) {\\n            current_record.timestamp = timestamp;\\n            current_record.price = price;\\n        }\\n        \\n        StockRecord sr = new StockRecord(timestamp, price);\\n        max.add(sr);\\n        min.add(sr);\\n        map.put(timestamp, price);\\n    }\\n    \\n    public int current() {\\n        return current_record.price;\\n    }\\n    \\n    public int maximum() {\\n        StockRecord sp = max.peek();\\n        while(true) {\\n            sp = max.peek();\\n            if(sp.price != map.get(sp.timestamp))\\n                max.poll();\\n            else break;\\n        }\\n        return sp.price;\\n    }\\n    \\n    public int minimum() {\\n        StockRecord sp = min.peek();\\n         while(true) {\\n            sp = min.peek();\\n            if(sp.price != map.get(sp.timestamp))\\n                min.poll();\\n            else break;\\n        }\\n        return sp.price;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockRecord {\\n    int timestamp;\\n    int price;\\n    \\n    public StockRecord(){}\\n    \\n    public StockRecord(int t, int p) {\\n        timestamp = t;\\n        price = p;\\n    }\\n}\\n\\nclass StockPrice {\\n    \\n    PriorityQueue<StockRecord> max = new PriorityQueue<>((sr1, sr2) -> (sr2.price - sr1.price));\\n    PriorityQueue<StockRecord> min = new PriorityQueue<>((sr1, sr2) -> (sr1.price - sr2.price));\\n    StockRecord current_record;\\n    Map<Integer, Integer> map = new HashMap<>();\\n\\n    \\n    public StockPrice() {\\n        current_record = new StockRecord();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= current_record.timestamp) {\\n            current_record.timestamp = timestamp;\\n            current_record.price = price;\\n        }\\n        \\n        StockRecord sr = new StockRecord(timestamp, price);\\n        max.add(sr);\\n        min.add(sr);\\n        map.put(timestamp, price);\\n    }\\n    \\n    public int current() {\\n        return current_record.price;\\n    }\\n    \\n    public int maximum() {\\n        StockRecord sp = max.peek();\\n        while(true) {\\n            sp = max.peek();\\n            if(sp.price != map.get(sp.timestamp))\\n                max.poll();\\n            else break;\\n        }\\n        return sp.price;\\n    }\\n    \\n    public int minimum() {\\n        StockRecord sp = min.peek();\\n         while(true) {\\n            sp = min.peek();\\n            if(sp.price != map.get(sp.timestamp))\\n                min.poll();\\n            else break;\\n        }\\n        return sp.price;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513475,
                "title": "java-hashmap-treemap-solution-with-comments",
                "content": "```\\n/*\\n1) for latest/current : \\n     we can take one variable for maximum timestamp we get till now\\n     we can get price of maximum/latest timestamp from hashmap.\\n2) for update :\\n    we will keep track of count prices according to ascending sorted order using treemap\\n\\tso finding maximum will be greatest key in treemap\\n\\tand finding minimum will be smallest key in treemap\\n\\tevery time we will update frequency/count of oldprice if exist\\n\\tand update new (key,value)=>(timestamp,price) in hashmap\\n\\tand upadate new (key,value)=>(price,frequency) in treemap\\n*/\\t\\n```\\n```\\nclass StockPrice {\\n    HashMap<Integer,Integer> h; //(key,value)=>(timestamp,price)\\n    TreeMap<Integer,Integer> tm;//(key,value)=>(price,frequency of price)\\n    int current;\\n    public StockPrice() {\\n        h=new HashMap<>();\\n        tm=new TreeMap<>();\\n        current=0;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        current=Math.max(current,timestamp);\\n        if(h.containsKey(timestamp)) // If timestamp already present\\n        {    \\n            int oldprice=h.get(timestamp); // old price of timestamp\\n            if(tm.containsKey(oldprice))\\n            {\\n\\t\\t\\t    //remove old price from frequency as old value is getting upadated\\n                if(tm.get(oldprice)==1)  // if frequency of old price is 1 then remove entry\\n                    tm.remove(oldprice);\\n                else\\n                    tm.put(oldprice,tm.get(oldprice)-1); // else update frequency of old -1\\n            }\\n        }\\n\\t\\t//Update new price in hasmap\\n        h.put(timestamp,price);\\n\\t\\t//Update new frequency of new price in treemap\\n        tm.put(price,tm.getOrDefault(price,0)+1);\\n    }\\n    \\n    public int current() {\\n        return h.get(current);\\n    }\\n    \\n    public int maximum() {\\n        return tm.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return tm.firstKey();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/*\\n1) for latest/current : \\n     we can take one variable for maximum timestamp we get till now\\n     we can get price of maximum/latest timestamp from hashmap.\\n2) for update :\\n    we will keep track of count prices according to ascending sorted order using treemap\\n\\tso finding maximum will be greatest key in treemap\\n\\tand finding minimum will be smallest key in treemap\\n\\tevery time we will update frequency/count of oldprice if exist\\n\\tand update new (key,value)=>(timestamp,price) in hashmap\\n\\tand upadate new (key,value)=>(price,frequency) in treemap\\n*/\\t\\n```\n```\\nclass StockPrice {\\n    HashMap<Integer,Integer> h; //(key,value)=>(timestamp,price)\\n    TreeMap<Integer,Integer> tm;//(key,value)=>(price,frequency of price)\\n    int current;\\n    public StockPrice() {\\n        h=new HashMap<>();\\n        tm=new TreeMap<>();\\n        current=0;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        current=Math.max(current,timestamp);\\n        if(h.containsKey(timestamp)) // If timestamp already present\\n        {    \\n            int oldprice=h.get(timestamp); // old price of timestamp\\n            if(tm.containsKey(oldprice))\\n            {\\n\\t\\t\\t    //remove old price from frequency as old value is getting upadated\\n                if(tm.get(oldprice)==1)  // if frequency of old price is 1 then remove entry\\n                    tm.remove(oldprice);\\n                else\\n                    tm.put(oldprice,tm.get(oldprice)-1); // else update frequency of old -1\\n            }\\n        }\\n\\t\\t//Update new price in hasmap\\n        h.put(timestamp,price);\\n\\t\\t//Update new frequency of new price in treemap\\n        tm.put(price,tm.getOrDefault(price,0)+1);\\n    }\\n    \\n    public int current() {\\n        return h.get(current);\\n    }\\n    \\n    public int maximum() {\\n        return tm.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return tm.firstKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513315,
                "title": "c-java-concise-with-explanation",
                "content": "## C++\\n\\nUsing two data structures here, an ordered map and a regular hashmap.\\n\\nThe ordered map is to make sure that we can get the `maximum` and `minimum` values in O(1), and I used a map to make sure that we can keep track of the count.\\n\\n`latestTime` in combination with the `prices` hashmap also ensures that the `current` method is O(1).\\n\\nThe worst case for the update method is `O(log N)` due to the binary search in `ordered` to update `price` count (same time complexity if the `timestamp` already exists and you need to reduce `prevPrice` count).\\n\\n```\\nclass StockPrice {\\npublic:\\n    unordered_map<int, int> prices = {};\\n    map<int, int> ordered = {};\\n    int latestTime = -1;\\n    \\n    void update(int timestamp, int price) {\\n        if (prices.find(timestamp) != prices.end()) {\\n            int prevPrice = prices[timestamp];\\n            ordered[prevPrice]--;\\n            if (ordered[prevPrice] == 0)\\n                ordered.erase(prevPrice);\\n        }\\n        prices[timestamp] = price;\\n        ordered[price]++;\\n        latestTime = max(latestTime, timestamp);\\n    }\\n    \\n    int current() {\\n        return prices[latestTime];\\n    }\\n    \\n    int maximum() {\\n\\t\\t// ordered.rbegin() means the first element in the map starting in reverse order, so the last element\\n\\t\\t// this returns an iterator to a pair<int, int> in this case, where the second value of the pair is the count\\n\\t\\t// and the first value is the price, and since its a pair from an iterator we access it with an arrow function: ->first\\n        return ordered.rbegin()->first;\\n    }\\n    \\n    int minimum() {\\n\\t\\t// same logic as above, but this is an iterator that has the pair<int, int> values of the lowest price and its count\\n        return ordered.begin()->first;\\n    }\\n};\\n```\\n\\n## Java\\n\\nThe time complexity of getting the highest and lowest values in a TreeMap is actually O(log N):\\nhttps://stackoverflow.com/questions/27364907/treemap-lastkey-lookup-time\\n\\nCompared to the sorted map structure in C++, where the look up times for both max and min is O(1):\\nhttps://stackoverflow.com/questions/53122376/what-is-the-time-complexity-of-getting-the-max-key-of-a-stdmap-in-c\\n\\nSo in order to keep the `maximum` and `minimum` methods at O(1), we have to keep track of the variables for `high` and `low` separately.\\n\\n```\\nclass StockPrice {\\n    HashMap<Integer, Integer> prices = new HashMap();\\n    TreeMap<Integer, Integer> ordered = new TreeMap();\\n    int latestTime = -1, high = Integer.MIN_VALUE, low = Integer.MAX_VALUE;\\n\\n    public void update(int timestamp, int price) {\\n        if (prices.containsKey(timestamp)) {\\n            int prevPrice = prices.get(timestamp);\\n            ordered.put(prevPrice, ordered.get(prevPrice) - 1);\\n            if (ordered.get(prevPrice) == 0) {\\n                ordered.remove(prevPrice);\\n                if (!ordered.isEmpty()) {\\n\\t\\t\\t\\t\\t// since update is already O(log N), the time complexity doesn\\'t change\\n                    if (prevPrice == high) high = ordered.lastKey();\\n                    if (prevPrice == low) low = ordered.firstKey();\\n                } else {\\n                    high = Integer.MIN_VALUE;\\n                    low = Integer.MAX_VALUE;\\n                }\\n            }\\n        }\\n        high = Math.max(high, price);\\n        low = Math.min(low, price);\\n        prices.put(timestamp, price);\\n        ordered.put(price, ordered.getOrDefault(price, 0) + 1);\\n        latestTime = Math.max(latestTime, timestamp);\\n    }\\n    \\n    public int current() {\\n        return prices.get(latestTime);\\n    }\\n    \\n    public int maximum() {\\n        return high;\\n    }\\n    \\n    public int minimum() {\\n        return low;\\n    }\\n}\\n```\\n## Alternative C++\\nAnd here\\'s a version using a `multiset` in C++ instead of the ordered `map` inspired by some of the other top solutions -- which is an ordered set that doesn\\'t only contain unique values, it can have multiple values that are the same.\\n\\nTime complexity for updating is still `O(log N)` since it\\'s an ordered data structure so binary search still has to be performed for adding / removing values.\\n\\n```\\nclass StockPrice {\\npublic:\\n    unordered_map<int, int> prices;\\n    multiset<int> ordered;\\n    int latestTime = -1;\\n    \\n    void update(int timestamp, int price) {\\n\\t    // this is the shorthand for `if (prices.find(timestamp) != prices.end())`\\n        if (prices.count(timestamp)) {\\n\\t\\t\\t// this makes sure that only one of the values equal to `prices[timestamp]` in the multiset is deleted, not all of them\\n            ordered.erase(ordered.lower_bound(prices[timestamp]));\\n        }\\n        prices[timestamp] = price;\\n        ordered.insert(price);\\n        latestTime = max(latestTime, timestamp);\\n    }\\n    \\n    int current() {\\n        return prices[latestTime];\\n    }\\n    \\n    int maximum() {\\n\\t\\t// so since this is a multi set, the rbegin() operation returns an iterator that points to the last element \\n\\t\\t// (which is the first element in reverse order)\\n\\t\\t// so in order to actually grab the value that this iterator is pointing to, we need to use the * notation\\n        return *rbegin(ordered);\\n    }\\n    \\n    int minimum() {\\n\\t\\t// same logic, but the iterator for begin() points to the first element\\n        return *begin(ordered);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    unordered_map<int, int> prices = {};\\n    map<int, int> ordered = {};\\n    int latestTime = -1;\\n    \\n    void update(int timestamp, int price) {\\n        if (prices.find(timestamp) != prices.end()) {\\n            int prevPrice = prices[timestamp];\\n            ordered[prevPrice]--;\\n            if (ordered[prevPrice] == 0)\\n                ordered.erase(prevPrice);\\n        }\\n        prices[timestamp] = price;\\n        ordered[price]++;\\n        latestTime = max(latestTime, timestamp);\\n    }\\n    \\n    int current() {\\n        return prices[latestTime];\\n    }\\n    \\n    int maximum() {\\n\\t\\t// ordered.rbegin() means the first element in the map starting in reverse order, so the last element\\n\\t\\t// this returns an iterator to a pair<int, int> in this case, where the second value of the pair is the count\\n\\t\\t// and the first value is the price, and since its a pair from an iterator we access it with an arrow function: ->first\\n        return ordered.rbegin()->first;\\n    }\\n    \\n    int minimum() {\\n\\t\\t// same logic as above, but this is an iterator that has the pair<int, int> values of the lowest price and its count\\n        return ordered.begin()->first;\\n    }\\n};\\n```\n```\\nclass StockPrice {\\n    HashMap<Integer, Integer> prices = new HashMap();\\n    TreeMap<Integer, Integer> ordered = new TreeMap();\\n    int latestTime = -1, high = Integer.MIN_VALUE, low = Integer.MAX_VALUE;\\n\\n    public void update(int timestamp, int price) {\\n        if (prices.containsKey(timestamp)) {\\n            int prevPrice = prices.get(timestamp);\\n            ordered.put(prevPrice, ordered.get(prevPrice) - 1);\\n            if (ordered.get(prevPrice) == 0) {\\n                ordered.remove(prevPrice);\\n                if (!ordered.isEmpty()) {\\n\\t\\t\\t\\t\\t// since update is already O(log N), the time complexity doesn\\'t change\\n                    if (prevPrice == high) high = ordered.lastKey();\\n                    if (prevPrice == low) low = ordered.firstKey();\\n                } else {\\n                    high = Integer.MIN_VALUE;\\n                    low = Integer.MAX_VALUE;\\n                }\\n            }\\n        }\\n        high = Math.max(high, price);\\n        low = Math.min(low, price);\\n        prices.put(timestamp, price);\\n        ordered.put(price, ordered.getOrDefault(price, 0) + 1);\\n        latestTime = Math.max(latestTime, timestamp);\\n    }\\n    \\n    public int current() {\\n        return prices.get(latestTime);\\n    }\\n    \\n    public int maximum() {\\n        return high;\\n    }\\n    \\n    public int minimum() {\\n        return low;\\n    }\\n}\\n```\n```\\nclass StockPrice {\\npublic:\\n    unordered_map<int, int> prices;\\n    multiset<int> ordered;\\n    int latestTime = -1;\\n    \\n    void update(int timestamp, int price) {\\n\\t    // this is the shorthand for `if (prices.find(timestamp) != prices.end())`\\n        if (prices.count(timestamp)) {\\n\\t\\t\\t// this makes sure that only one of the values equal to `prices[timestamp]` in the multiset is deleted, not all of them\\n            ordered.erase(ordered.lower_bound(prices[timestamp]));\\n        }\\n        prices[timestamp] = price;\\n        ordered.insert(price);\\n        latestTime = max(latestTime, timestamp);\\n    }\\n    \\n    int current() {\\n        return prices[latestTime];\\n    }\\n    \\n    int maximum() {\\n\\t\\t// so since this is a multi set, the rbegin() operation returns an iterator that points to the last element \\n\\t\\t// (which is the first element in reverse order)\\n\\t\\t// so in order to actually grab the value that this iterator is pointing to, we need to use the * notation\\n        return *rbegin(ordered);\\n    }\\n    \\n    int minimum() {\\n\\t\\t// same logic, but the iterator for begin() points to the first element\\n        return *begin(ordered);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786277,
                "title": "python-using-two-heaps-explained-accurately",
                "content": "We store latest timestamp and price information on a hash table. And everytime we look to calculate maximum and minimum value, we use this hash_table to calculate the values. Since we also get volatile price information, we can choose to update the maximum and minimum information at any place we like, and we decide to do it inside maximum() and minimum() functions. \\n\\nWhen a call is made to the maximum and minimum functions, we remove all the volatile prices and only keep the accurate ones. We would use heap for our solution, popping the max and min should be fairly easy if we can store it correctly. \\n\\nDuring the maximum and minimum operations, we compare the prices of each maximum price against the price in the self.t (this is updated hash_table), if there is a mismatch remove the price from the maximum heap. We do the same for the minimum() as well. \\n\\n\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.t = {}\\n        self.max = []\\n        self.min = []\\n        self.last = 0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.t[timestamp] = price\\n        self.last = max(self.last, timestamp)\\n        \\n        heappush(self.min, (price, timestamp))\\n        heappush(self.max, (-price, timestamp))\\n\\n    def current(self) -> int:\\n        return self.t[self.last]\\n\\n\\tdef maximum(self) -> int:\\n        while self.t[self.max[0][1]] != -self.max[0][0]:\\n            heappop(self.max)\\n        return -self.max[0][0]\\n\\n\\tdef minimum(self) -> int:          \\n        while self.t[self.min[0][1]] != self.min[0][0]:\\n            heappop(self.min)\\n        return self.min[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.t = {}\\n        self.max = []\\n        self.min = []\\n        self.last = 0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.t[timestamp] = price\\n        self.last = max(self.last, timestamp)\\n        \\n        heappush(self.min, (price, timestamp))\\n        heappush(self.max, (-price, timestamp))\\n\\n    def current(self) -> int:\\n        return self.t[self.last]\\n\\n\\tdef maximum(self) -> int:\\n        while self.t[self.max[0][1]] != -self.max[0][0]:\\n            heappop(self.max)\\n        return -self.max[0][0]\\n\\n\\tdef minimum(self) -> int:          \\n        while self.t[self.min[0][1]] != self.min[0][0]:\\n            heappop(self.min)\\n        return self.min[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516435,
                "title": "c-simple-and-clean-solution-detailed-explanation",
                "content": "**Idea:**\\nWe use a map `stock` to store the current price for each timestamp.\\nWe also need a multiset `prices` to store all the prices we had so far.\\nTo get the latest, we keep a variable `latest` for the latest timestamp.\\n1. **update**:\\nIf we had this timestamp already and we\\'re correcting the previous price so we need to remove it from `prices`.\\nThen we update `stock`, `prices` and `latest`.\\n2. **current**:\\njust return the price at the `latest` timestamp.\\n3. **maximum** and **minimum**:\\na multiset is always sorted, so we just return the first and last elements.\\n\\n**Time Complexity:** O(logn) for update, O(1) for the rest\\n**Space Complexity:** O(n)\\n```\\nclass StockPrice {\\npublic:\\n    StockPrice() {}\\n    \\n    void update(int timestamp, int price) {\\n        if (stock.find(timestamp) != stock.end())\\n            prices.erase(prices.find(stock[timestamp]));\\n        \\n        stock[timestamp] = price;\\n        prices.insert(price);\\n        \\n        latest = max(latest, timestamp);\\n    }\\n    \\n    int current() {\\n        return stock[latest];\\n    }\\n    \\n    int maximum() {\\n        return *prices.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *prices.begin();\\n    }\\n    \\nprivate:\\n    map<int, int> stock;\\n    multiset<int> prices;\\n    int latest = 0;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    StockPrice() {}\\n    \\n    void update(int timestamp, int price) {\\n        if (stock.find(timestamp) != stock.end())\\n            prices.erase(prices.find(stock[timestamp]));\\n        \\n        stock[timestamp] = price;\\n        prices.insert(price);\\n        \\n        latest = max(latest, timestamp);\\n    }\\n    \\n    int current() {\\n        return stock[latest];\\n    }\\n    \\n    int maximum() {\\n        return *prices.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *prices.begin();\\n    }\\n    \\nprivate:\\n    map<int, int> stock;\\n    multiset<int> prices;\\n    int latest = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808448,
                "title": "c-using-dictionary-and-sortedlist",
                "content": "**Explanation:**\\nTo solve this problem, initially I added 2 data structures, Dictionary (in Java terms HashMap) for mapping the stock price against the key being timestamp of that price, and another SortedDictionary where stock price is the key and list of timestamps would be the value for that price. Update operation updates both the structures and min max can be fetched from the sorted dictionary price.\\n\\nHowever this solution was giving TLE for me. So instead of having sorted dictionary value of list of timestamps, i changed it to SortedDictionary<int,int> and started maintaining only count of timestamps having specific stock price.\\n\\nThis solution also gave me TLE so I moved it to SortedList instead of SortedDictionary. The issue persisted.\\n\\nI have one takeaway from all my trouble with this TLE.\\n\\nIn C# SortedList or SortedDictionary even though sorted, do not maintain min max. and I was doing ```timeforprice.Keys.Last()``` or ```timeforprice.Last().Key``` both of which somehow enumerates through all the collection for I am not sure why.\\n\\nChanging the way I get min and max to ```timeforprice.Keys[timeforprice.Count - 1]``` solved my issue and answer was accepted.\\n\\nInstead of SortedList, we can use ```SortedSet<(int,int)>``` which does provide min and max properties, I got to know after searching later.\\n\\n**Code:**\\n```\\npublic class StockPrice {\\n\\n    int current;\\n    Dictionary<int,int> stockAndPrice;\\n    SortedList<int, int> timeforprice;\\n    \\n    public StockPrice() {\\n        current = 0;\\n        stockAndPrice = new Dictionary<int,int>();\\n        timeforprice = new SortedList<int, int>();\\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        current = Math.Max(current, timestamp);\\n        \\n        if(!stockAndPrice.ContainsKey(timestamp))\\n        {\\n            stockAndPrice.Add(timestamp,price);\\n            if(!timeforprice.ContainsKey(price))\\n                timeforprice.Add(price,1);\\n            else\\n                timeforprice[price]++;\\n        }   \\n        else\\n        {\\n            int oldPrice = stockAndPrice[timestamp];\\n            stockAndPrice[timestamp] = price;\\n            \\n            timeforprice[oldPrice]--;\\n            if(timeforprice[oldPrice] == 0)\\n                timeforprice.Remove(oldPrice);\\n            \\n            if(!timeforprice.ContainsKey(price))\\n                timeforprice.Add(price,1);\\n            else\\n                timeforprice[price]++;\\n        }\\n    }\\n    \\n    public int Current() {\\n        return stockAndPrice[current];\\n    }\\n    \\n    public int Maximum() {\\n        return timeforprice.Keys[timeforprice.Count - 1];\\n    }\\n    \\n    public int Minimum() {\\n        return timeforprice.Keys[0];\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.Update(timestamp,price);\\n * int param_2 = obj.Current();\\n * int param_3 = obj.Maximum();\\n * int param_4 = obj.Minimum();\\n */\\n```",
                "solutionTags": [],
                "code": "```timeforprice.Keys.Last()```\n```timeforprice.Last().Key```\n```timeforprice.Keys[timeforprice.Count - 1]```\n```SortedSet<(int,int)>```\n```\\npublic class StockPrice {\\n\\n    int current;\\n    Dictionary<int,int> stockAndPrice;\\n    SortedList<int, int> timeforprice;\\n    \\n    public StockPrice() {\\n        current = 0;\\n        stockAndPrice = new Dictionary<int,int>();\\n        timeforprice = new SortedList<int, int>();\\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        current = Math.Max(current, timestamp);\\n        \\n        if(!stockAndPrice.ContainsKey(timestamp))\\n        {\\n            stockAndPrice.Add(timestamp,price);\\n            if(!timeforprice.ContainsKey(price))\\n                timeforprice.Add(price,1);\\n            else\\n                timeforprice[price]++;\\n        }   \\n        else\\n        {\\n            int oldPrice = stockAndPrice[timestamp];\\n            stockAndPrice[timestamp] = price;\\n            \\n            timeforprice[oldPrice]--;\\n            if(timeforprice[oldPrice] == 0)\\n                timeforprice.Remove(oldPrice);\\n            \\n            if(!timeforprice.ContainsKey(price))\\n                timeforprice.Add(price,1);\\n            else\\n                timeforprice[price]++;\\n        }\\n    }\\n    \\n    public int Current() {\\n        return stockAndPrice[current];\\n    }\\n    \\n    public int Maximum() {\\n        return timeforprice.Keys[timeforprice.Count - 1];\\n    }\\n    \\n    public int Minimum() {\\n        return timeforprice.Keys[0];\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.Update(timestamp,price);\\n * int param_2 = obj.Current();\\n * int param_3 = obj.Maximum();\\n * int param_4 = obj.Minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880978,
                "title": "javascript-clean-js-solution-with-priority-queues-map",
                "content": "```\\nconst StockPrice = function () {\\n\\tthis.minHeap = new MinPriorityQueue({\\n\\t\\tcompare: (a, b) => a.price > b.price,\\n\\t});\\n\\tthis.maxHeap = new MaxPriorityQueue({\\n\\t\\tcompare: (a, b) => a.price < b.price,\\n\\t});\\n\\tthis.prices = new Map();\\n\\tthis.currentPrice = {};\\n};\\n\\nStockPrice.prototype.update = function (timestamp, price) {\\n\\tthis.prices.set(timestamp, price);\\n\\tthis.minHeap.enqueue({ timestamp, price });\\n\\tthis.maxHeap.enqueue({ timestamp, price });\\n\\tif (\\n\\t\\t!this.currentPrice.timestamp ||\\n\\t\\tthis.currentPrice.timestamp <= timestamp\\n\\t) {\\n\\t\\tthis.currentPrice = { timestamp, price };\\n\\t}\\n};\\n\\nStockPrice.prototype.current = function () {\\n\\treturn this.currentPrice.price;\\n};\\n\\nStockPrice.prototype.maximum = function () {\\n\\tlet front = this.maxHeap.front();\\n\\n\\twhile (this.prices.get(front.timestamp) != front.price) {\\n\\t\\tthis.maxHeap.dequeue();\\n\\t\\tfront = this.maxHeap.front();\\n\\t}\\n\\n\\treturn front.price;\\n};\\n\\nStockPrice.prototype.minimum = function () {\\n\\tlet front = this.minHeap.front();\\n\\n\\twhile (this.prices.get(front.timestamp) != front.price) {\\n\\t\\tthis.minHeap.dequeue();\\n\\t\\tfront = this.minHeap.front();\\n\\t}\\n\\n\\treturn front.price;\\n};\\n```\\nNote that MinPriorityQueue is already included in Leetcode\\'s js environment:\\nhttps://support.leetcode.com/hc/en-us/articles/360011833974-What-are-the-environments-for-the-programming-languages-",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst StockPrice = function () {\\n\\tthis.minHeap = new MinPriorityQueue({\\n\\t\\tcompare: (a, b) => a.price > b.price,\\n\\t});\\n\\tthis.maxHeap = new MaxPriorityQueue({\\n\\t\\tcompare: (a, b) => a.price < b.price,\\n\\t});\\n\\tthis.prices = new Map();\\n\\tthis.currentPrice = {};\\n};\\n\\nStockPrice.prototype.update = function (timestamp, price) {\\n\\tthis.prices.set(timestamp, price);\\n\\tthis.minHeap.enqueue({ timestamp, price });\\n\\tthis.maxHeap.enqueue({ timestamp, price });\\n\\tif (\\n\\t\\t!this.currentPrice.timestamp ||\\n\\t\\tthis.currentPrice.timestamp <= timestamp\\n\\t) {\\n\\t\\tthis.currentPrice = { timestamp, price };\\n\\t}\\n};\\n\\nStockPrice.prototype.current = function () {\\n\\treturn this.currentPrice.price;\\n};\\n\\nStockPrice.prototype.maximum = function () {\\n\\tlet front = this.maxHeap.front();\\n\\n\\twhile (this.prices.get(front.timestamp) != front.price) {\\n\\t\\tthis.maxHeap.dequeue();\\n\\t\\tfront = this.maxHeap.front();\\n\\t}\\n\\n\\treturn front.price;\\n};\\n\\nStockPrice.prototype.minimum = function () {\\n\\tlet front = this.minHeap.front();\\n\\n\\twhile (this.prices.get(front.timestamp) != front.price) {\\n\\t\\tthis.minHeap.dequeue();\\n\\t\\tfront = this.minHeap.front();\\n\\t}\\n\\n\\treturn front.price;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514101,
                "title": "javascript-simple-array-js-no-heap-solution",
                "content": "````\\n\\nvar StockPrice = function() {\\n    this.stocksPrice=[]\\n    this.timesStamp=[]\\n    this.lastPrice=[0,0];\\n    this.maxPrice=Number.NEGATIVE_INFINITY\\n    this.minPrice=Number.POSITIVE_INFINITY\\n};\\n\\n/** \\n * @param {number} timestamp \\n * @param {number} price\\n * @return {void}\\n */\\nStockPrice.prototype.update = function(timestamp, price) {  \\n    let index=this.timesStamp.indexOf(timestamp)\\n    if(index === -1) {\\n        this.timesStamp.push(timestamp)\\n        this.stocksPrice.push(price)\\n        this.maxPrice=Math.max(this.maxPrice, price)\\n        this.minPrice=Math.min(this.minPrice, price)\\n    } else {\\n        if(this.maxPrice === this.stocksPrice[index] || \\n           this.minPrice === this.stocksPrice[index]) {\\n            this.stocksPrice[index]=price\\n            this.maxPrice=Math.max(...this.stocksPrice)\\n            this.minPrice=Math.min(...this.stocksPrice)\\n        } else {\\n            this.stocksPrice[index]=price\\n            this.maxPrice=Math.max(this.maxPrice, price)\\n            this.minPrice=Math.min(this.minPrice, price)\\n        }\\n    }\\n    \\n    if(timestamp >= this.lastPrice[0])  this.lastPrice=[timestamp, price] \\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.current = function() {\\n    return this.lastPrice[1];\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.maximum = function() {\\n    return this.maxPrice\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.minimum = function() {\\n    return this.minPrice\\n};\\n\\n/** \\n * Your StockPrice object will be instantiated and called as such:\\n * var obj = new StockPrice()\\n * obj.update(timestamp,price)\\n * var param_2 = obj.current()\\n * var param_3 = obj.maximum()\\n * var param_4 = obj.minimum()\\n */",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\n\\nvar StockPrice = function() {\\n    this.stocksPrice=[]\\n    this.timesStamp=[]\\n    this.lastPrice=[0,0];\\n    this.maxPrice=Number.NEGATIVE_INFINITY\\n    this.minPrice=Number.POSITIVE_INFINITY\\n};\\n\\n/** \\n * @param {number} timestamp \\n * @param {number} price\\n * @return {void}\\n */\\nStockPrice.prototype.update = function(timestamp, price) {  \\n    let index=this.timesStamp.indexOf(timestamp)\\n    if(index === -1) {\\n        this.timesStamp.push(timestamp)\\n        this.stocksPrice.push(price)\\n        this.maxPrice=Math.max(this.maxPrice, price)\\n        this.minPrice=Math.min(this.minPrice, price)\\n    } else {\\n        if(this.maxPrice === this.stocksPrice[index] || \\n           this.minPrice === this.stocksPrice[index]) {\\n            this.stocksPrice[index]=price\\n            this.maxPrice=Math.max(...this.stocksPrice)\\n            this.minPrice=Math.min(...this.stocksPrice)\\n        } else {\\n            this.stocksPrice[index]=price\\n            this.maxPrice=Math.max(this.maxPrice, price)\\n            this.minPrice=Math.min(this.minPrice, price)\\n        }\\n    }\\n    \\n    if(timestamp >= this.lastPrice[0])  this.lastPrice=[timestamp, price] \\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.current = function() {\\n    return this.lastPrice[1];\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.maximum = function() {\\n    return this.maxPrice\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.minimum = function() {\\n    return this.minPrice\\n};\\n\\n/** \\n * Your StockPrice object will be instantiated and called as such:\\n * var obj = new StockPrice()\\n * obj.update(timestamp,price)\\n * var param_2 = obj.current()\\n * var param_3 = obj.maximum()\\n * var param_4 = obj.minimum()\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 1513447,
                "title": "c-map-multiset-do-not-erase-by-value-o-n-logn-solution",
                "content": "### **Do not remove by value in multiset it will remove all ocurrences of that value.**\\n### **Instead find a pointer to the value and remove value by pointer.**\\n\\nBelow is the simple code to demonstrate the same.\\nTime complexity of current, minimum and maximum function is constant. O(1)\\nTime complexity of Update function is O(logN);\\nSpace Complexity: O(N) for map + O(N) for set\\n\\n<iframe src=\"https://leetcode.com/playground/LPVnaFxZ/shared\" frameBorder=\"0\" width=\"400\" height=\"400\"></iframe>\\n",
                "solutionTags": [],
                "code": "### **Do not remove by value in multiset it will remove all ocurrences of that value.**\\n### **Instead find a pointer to the value and remove value by pointer.**\\n\\nBelow is the simple code to demonstrate the same.\\nTime complexity of current, minimum and maximum function is constant. O(1)\\nTime complexity of Update function is O(logN);\\nSpace Complexity: O(N) for map + O(N) for set\\n\\n<iframe src=\"https://leetcode.com/playground/LPVnaFxZ/shared\" frameBorder=\"0\" width=\"400\" height=\"400\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1779531,
                "title": "c-faster-than-100-dictionary-sortedset",
                "content": "```\\npublic class StockPrice {\\n    Dictionary<int, int> stockPrices = new Dictionary<int, int>();\\n    SortedSet<(int price, int timestamp)> sorted = new SortedSet<(int price, int timestamp)>();\\n    int mostRecent;\\n    \\n    public StockPrice() {        \\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        mostRecent = Math.Max(mostRecent, timestamp);\\n        \\n        if(!stockPrices.ContainsKey(timestamp))\\n        {\\n            sorted.Add((price, timestamp));\\n            stockPrices.Add(timestamp, price);\\n            return;\\n        }        \\n   \\n        sorted.Remove((stockPrices[timestamp], timestamp));\\n        sorted.Add((price, timestamp));\\n        stockPrices[timestamp] = price;            \\n    }\\n    \\n    public int Current() {\\n        return stockPrices[mostRecent];        \\n    }\\n    \\n    public int Maximum() {\\n        return sorted.Max.price;\\n    }\\n    \\n    public int Minimum() {\\n        return sorted.Min.price;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class StockPrice {\\n    Dictionary<int, int> stockPrices = new Dictionary<int, int>();\\n    SortedSet<(int price, int timestamp)> sorted = new SortedSet<(int price, int timestamp)>();\\n    int mostRecent;\\n    \\n    public StockPrice() {        \\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        mostRecent = Math.Max(mostRecent, timestamp);\\n        \\n        if(!stockPrices.ContainsKey(timestamp))\\n        {\\n            sorted.Add((price, timestamp));\\n            stockPrices.Add(timestamp, price);\\n            return;\\n        }        \\n   \\n        sorted.Remove((stockPrices[timestamp], timestamp));\\n        sorted.Add((price, timestamp));\\n        stockPrices[timestamp] = price;            \\n    }\\n    \\n    public int Current() {\\n        return stockPrices[mostRecent];        \\n    }\\n    \\n    public int Maximum() {\\n        return sorted.Max.price;\\n    }\\n    \\n    public int Minimum() {\\n        return sorted.Min.price;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513628,
                "title": "python3-sorteddict-and-sortedlist",
                "content": "```\\nfrom sortedcontainers import SortedDict, SortedList\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.time = SortedDict()\\n        self.prices = SortedList()\\n\\n        \\n    def update(self, timestamp: int, price: int) -> None:\\n        \\n        if timestamp in self.time.keys():\\n\\t\\t\\t#remove old price and add new price\\n            self.prices.remove(self.time[timestamp])\\n            self.time[timestamp] = price\\n            self.prices.add(price)\\n        else:\\n\\t\\t\\t#add new price\\n            self.time[timestamp] = price\\n            self.prices.add(price)\\n\\n    def current(self) -> int:\\n        \\n\\t\\t#return value of rightmost key\\n        return self.time[self.time.keys()[-1]]\\n\\n    def maximum(self) -> int:\\n\\t\\n\\t\\t#return rightmost element in prices\\n        return self.prices[-1]\\n\\n    def minimum(self) -> int:\\n\\t\\t#return leftmost element in prices\\n        return self.prices[0]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedDict, SortedList\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.time = SortedDict()\\n        self.prices = SortedList()\\n\\n        \\n    def update(self, timestamp: int, price: int) -> None:\\n        \\n        if timestamp in self.time.keys():\\n\\t\\t\\t#remove old price and add new price\\n            self.prices.remove(self.time[timestamp])\\n            self.time[timestamp] = price\\n            self.prices.add(price)\\n        else:\\n\\t\\t\\t#add new price\\n            self.time[timestamp] = price\\n            self.prices.add(price)\\n\\n    def current(self) -> int:\\n        \\n\\t\\t#return value of rightmost key\\n        return self.time[self.time.keys()[-1]]\\n\\n    def maximum(self) -> int:\\n\\t\\n\\t\\t#return rightmost element in prices\\n        return self.prices[-1]\\n\\n    def minimum(self) -> int:\\n\\t\\t#return leftmost element in prices\\n        return self.prices[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667001,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap && Hashset***\\n\\n* ***Time Complexity :- O(logN) for Update operation && O(1) for every other operation***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass StockPrice {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    \\n    // multiset will store the prices\\n    \\n    multiset<int> s;\\n    \\n    int max_time = 0;\\n    \\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        \\n        // if already present then delete the price from multiset\\n        \\n        if(mp.count(timestamp))\\n        {\\n            auto it = s.find(mp[timestamp]);\\n            \\n            s.erase(it);\\n        }\\n        \\n        // update \\n        \\n        max_time = max(max_time, timestamp);\\n        \\n        mp[timestamp] = price;\\n        \\n        s.insert(price);\\n    }\\n    \\n    int current() {\\n        \\n        return mp[max_time];\\n    }\\n    \\n    int maximum() {\\n        \\n        return *s.rbegin();\\n    }\\n    \\n    int minimum() {\\n        \\n        return *s.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    \\n    // multiset will store the prices\\n    \\n    multiset<int> s;\\n    \\n    int max_time = 0;\\n    \\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        \\n        // if already present then delete the price from multiset\\n        \\n        if(mp.count(timestamp))\\n        {\\n            auto it = s.find(mp[timestamp]);\\n            \\n            s.erase(it);\\n        }\\n        \\n        // update \\n        \\n        max_time = max(max_time, timestamp);\\n        \\n        mp[timestamp] = price;\\n        \\n        s.insert(price);\\n    }\\n    \\n    int current() {\\n        \\n        return mp[max_time];\\n    }\\n    \\n    int maximum() {\\n        \\n        return *s.rbegin();\\n    }\\n    \\n    int minimum() {\\n        \\n        return *s.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905977,
                "title": "simple-solution-in-java-concise-and-elegant-using-one-hashmap-and-treemap",
                "content": "```\\nclass StockPrice {\\n    private HashMap<Integer, Integer> map;\\n    private TreeMap<Integer, Integer> tmap;\\n    private Integer maxTimestamp;\\n    \\n    public StockPrice() {\\n        this.map = new HashMap<>();\\n        this.tmap = new TreeMap<>();\\n        this.maxTimestamp = -1;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        \\n        Integer prevPrice = map.get(timestamp);\\n        map.put(timestamp, price);\\n        \\n        if(prevPrice != null){\\n            tmap.put(prevPrice, tmap.get(prevPrice) - 1);\\n            if(tmap.get(prevPrice) == 0) tmap.remove(prevPrice);\\n        }\\n        \\n        tmap.put(price, tmap.getOrDefault(price, 0) + 1);\\n        \\n        // Update max time \\n        this.maxTimestamp = Math.max(maxTimestamp, timestamp);\\n    }\\n    \\n    public int current() {\\n        return map.get(this.maxTimestamp);\\n    }\\n    \\n    public int maximum() {\\n        return tmap.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return tmap.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n    private HashMap<Integer, Integer> map;\\n    private TreeMap<Integer, Integer> tmap;\\n    private Integer maxTimestamp;\\n    \\n    public StockPrice() {\\n        this.map = new HashMap<>();\\n        this.tmap = new TreeMap<>();\\n        this.maxTimestamp = -1;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        \\n        Integer prevPrice = map.get(timestamp);\\n        map.put(timestamp, price);\\n        \\n        if(prevPrice != null){\\n            tmap.put(prevPrice, tmap.get(prevPrice) - 1);\\n            if(tmap.get(prevPrice) == 0) tmap.remove(prevPrice);\\n        }\\n        \\n        tmap.put(price, tmap.getOrDefault(price, 0) + 1);\\n        \\n        // Update max time \\n        this.maxTimestamp = Math.max(maxTimestamp, timestamp);\\n    }\\n    \\n    public int current() {\\n        return map.get(this.maxTimestamp);\\n    }\\n    \\n    public int maximum() {\\n        return tmap.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return tmap.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645446,
                "title": "c-easy-and-clean-solution-with-dictionary-and-sortedset",
                "content": "Good link to check complexity of .NET collections [https://hovermind.com/csharp/runtime-complexity-of-generic-collection.html](http://)\\n```\\npublic class StockPrice\\n{\\n    private readonly SortedSet<(int Price, int Timestamp)> _sortedSet;\\n    private readonly Dictionary<int, (int Price, int Timestamp)> _dictionary;\\n    private int _currentTimestamp;\\n\\n    public StockPrice()\\n    {\\n        _dictionary = new Dictionary<int, (int Price, int Timestamp)>();\\n        _sortedSet = new SortedSet<(int Price, int Timestamp)>();\\n    }\\n\\n    public void Update(int timestamp, int price)\\n    {\\n        _currentTimestamp = Math.Max(_currentTimestamp, timestamp);\\n        \\n        if(!_dictionary.ContainsKey(timestamp))\\n        {\\n            var priceTimestamp = (price, timestamp);\\n            _sortedSet.Add(priceTimestamp);\\n            _dictionary[timestamp] = priceTimestamp; \\n            \\n            return;\\n        }\\n        \\n        if (_dictionary[timestamp].Price != price) {\\n            _sortedSet.Remove(_dictionary[timestamp]);\\n                \\n            var priceTimestamp = (price, timestamp);\\n            _sortedSet.Add(priceTimestamp);\\n            _dictionary[timestamp] = priceTimestamp; \\n        }\\n    }\\n\\n    public int Current() => _dictionary[_currentTimestamp].Price;\\n\\n    public int Maximum() => _sortedSet.Max.Price;\\n\\n    public int Minimum() => _sortedSet.Min.Price;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class StockPrice\\n{\\n    private readonly SortedSet<(int Price, int Timestamp)> _sortedSet;\\n    private readonly Dictionary<int, (int Price, int Timestamp)> _dictionary;\\n    private int _currentTimestamp;\\n\\n    public StockPrice()\\n    {\\n        _dictionary = new Dictionary<int, (int Price, int Timestamp)>();\\n        _sortedSet = new SortedSet<(int Price, int Timestamp)>();\\n    }\\n\\n    public void Update(int timestamp, int price)\\n    {\\n        _currentTimestamp = Math.Max(_currentTimestamp, timestamp);\\n        \\n        if(!_dictionary.ContainsKey(timestamp))\\n        {\\n            var priceTimestamp = (price, timestamp);\\n            _sortedSet.Add(priceTimestamp);\\n            _dictionary[timestamp] = priceTimestamp; \\n            \\n            return;\\n        }\\n        \\n        if (_dictionary[timestamp].Price != price) {\\n            _sortedSet.Remove(_dictionary[timestamp]);\\n                \\n            var priceTimestamp = (price, timestamp);\\n            _sortedSet.Add(priceTimestamp);\\n            _dictionary[timestamp] = priceTimestamp; \\n        }\\n    }\\n\\n    public int Current() => _dictionary[_currentTimestamp].Price;\\n\\n    public int Maximum() => _sortedSet.Max.Price;\\n\\n    public int Minimum() => _sortedSet.Min.Price;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563266,
                "title": "using-priorityqueue",
                "content": "```\\n\\n    PriorityQueue<Pair<Integer,Integer>> maxQueue=null;\\n    PriorityQueue<Pair<Integer,Integer>> minQueue=null;\\n    Map<Integer,Integer> map=null;\\n    int lastestTimeStamp=0;\\n    public StockPrice() {\\n     maxQueue = new PriorityQueue<Pair<Integer,Integer>>((p1,p2) ->\\n                                                         p2.getValue()-p1.getValue());\\n         minQueue = new PriorityQueue<Pair<Integer,Integer>>((p1,p2)->\\n                                                         p1.getValue()-p2.getValue()); \\n        map = new HashMap();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        lastestTimeStamp = Math.max(lastestTimeStamp,timestamp);\\n        map.put(timestamp,price);\\n        maxQueue.add(new Pair<Integer,Integer>(timestamp,price));\\n        minQueue.add(new Pair<Integer,Integer>(timestamp,price));\\n\\n    }\\n    \\n    public int current() {\\n        return map.get(lastestTimeStamp);\\n    }\\n    \\n    public int maximum() {\\n     \\n        while(!map.get(maxQueue.peek().getKey()).equals(maxQueue.peek().getValue())){\\n          maxQueue.poll();  \\n        }\\n        return maxQueue.peek().getValue();\\n    }\\n    \\n    public int minimum() {\\n      while(!map.get(minQueue.peek().getKey()).equals(minQueue.peek().getValue())){\\n          minQueue.poll();  \\n        }\\n        return minQueue.peek().getValue();   \\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n    PriorityQueue<Pair<Integer,Integer>> maxQueue=null;\\n    PriorityQueue<Pair<Integer,Integer>> minQueue=null;\\n    Map<Integer,Integer> map=null;\\n    int lastestTimeStamp=0;\\n    public StockPrice() {\\n     maxQueue = new PriorityQueue<Pair<Integer,Integer>>((p1,p2) ->\\n                                                         p2.getValue()-p1.getValue());\\n         minQueue = new PriorityQueue<Pair<Integer,Integer>>((p1,p2)->\\n                                                         p1.getValue()-p2.getValue()); \\n        map = new HashMap();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        lastestTimeStamp = Math.max(lastestTimeStamp,timestamp);\\n        map.put(timestamp,price);\\n        maxQueue.add(new Pair<Integer,Integer>(timestamp,price));\\n        minQueue.add(new Pair<Integer,Integer>(timestamp,price));\\n\\n    }\\n    \\n    public int current() {\\n        return map.get(lastestTimeStamp);\\n    }\\n    \\n    public int maximum() {\\n     \\n        while(!map.get(maxQueue.peek().getKey()).equals(maxQueue.peek().getValue())){\\n          maxQueue.poll();  \\n        }\\n        return maxQueue.peek().getValue();\\n    }\\n    \\n    public int minimum() {\\n      while(!map.get(minQueue.peek().getKey()).equals(minQueue.peek().getValue())){\\n          minQueue.poll();  \\n        }\\n        return minQueue.peek().getValue();   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1515381,
                "title": "golang-solution",
                "content": "```go\\ntype StockPrice struct {\\n\\thash             map[int]int\\n\\tlist             []int\\n\\tcurrentPrice     int\\n\\tcurrentTimestamp int\\n}\\n\\nfunc Constructor() StockPrice {\\n\\treturn StockPrice{\\n\\t\\thash:             make(map[int]int),\\n\\t\\tlist:             make([]int, 0),\\n\\t\\tcurrentPrice:     0,\\n\\t\\tcurrentTimestamp: 0,\\n\\t}\\n}\\n\\nfunc (sp *StockPrice) Update(timestamp int, price int) {\\n\\t// refresh current if need\\n\\tif timestamp >= sp.currentTimestamp {\\n\\t\\tsp.currentTimestamp = timestamp\\n\\t\\tsp.currentPrice = price\\n\\t}\\n\\t// remove oldPrice if need\\n\\tif oldPrice, exist := sp.hash[timestamp]; exist {\\n\\t\\tl, r := 0, len(sp.list)-1\\n\\t\\tfor l <= r {\\n\\t\\t\\tm := (l + r) >> 1\\n\\t\\t\\tif sp.list[m] == oldPrice {\\n\\t\\t\\t\\tcopy(sp.list[m:], sp.list[m+1:])\\n\\t\\t\\t\\tsp.list = sp.list[:len(sp.list)-1]\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t} else if sp.list[m] < oldPrice {\\n\\t\\t\\t\\tl = m + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// store/update price\\n\\tsp.hash[timestamp] = price\\n\\t// insert into list\\n\\tl, r := 0, len(sp.list)-1\\n\\tfor l <= r {\\n\\t\\tm := (l + r) >> 1\\n\\t\\tif sp.list[m] <= price {\\n\\t\\t\\tl = m + 1\\n\\t\\t} else {\\n\\t\\t\\tr = m - 1\\n\\t\\t}\\n\\t}\\n\\tsp.list = append(sp.list, 0)\\n\\tcopy(sp.list[l+1:], sp.list[l:])\\n\\tsp.list[l] = price\\n}\\n\\nfunc (sp *StockPrice) Current() int {\\n\\treturn sp.currentPrice\\n}\\n\\nfunc (sp *StockPrice) Maximum() int {\\n\\treturn sp.list[len(sp.list)-1]\\n}\\n\\nfunc (sp *StockPrice) Minimum() int {\\n\\treturn sp.list[0]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```go\\ntype StockPrice struct {\\n\\thash             map[int]int\\n\\tlist             []int\\n\\tcurrentPrice     int\\n\\tcurrentTimestamp int\\n}\\n\\nfunc Constructor() StockPrice {\\n\\treturn StockPrice{\\n\\t\\thash:             make(map[int]int),\\n\\t\\tlist:             make([]int, 0),\\n\\t\\tcurrentPrice:     0,\\n\\t\\tcurrentTimestamp: 0,\\n\\t}\\n}\\n\\nfunc (sp *StockPrice) Update(timestamp int, price int) {\\n\\t// refresh current if need\\n\\tif timestamp >= sp.currentTimestamp {\\n\\t\\tsp.currentTimestamp = timestamp\\n\\t\\tsp.currentPrice = price\\n\\t}\\n\\t// remove oldPrice if need\\n\\tif oldPrice, exist := sp.hash[timestamp]; exist {\\n\\t\\tl, r := 0, len(sp.list)-1\\n\\t\\tfor l <= r {\\n\\t\\t\\tm := (l + r) >> 1\\n\\t\\t\\tif sp.list[m] == oldPrice {\\n\\t\\t\\t\\tcopy(sp.list[m:], sp.list[m+1:])\\n\\t\\t\\t\\tsp.list = sp.list[:len(sp.list)-1]\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t} else if sp.list[m] < oldPrice {\\n\\t\\t\\t\\tl = m + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// store/update price\\n\\tsp.hash[timestamp] = price\\n\\t// insert into list\\n\\tl, r := 0, len(sp.list)-1\\n\\tfor l <= r {\\n\\t\\tm := (l + r) >> 1\\n\\t\\tif sp.list[m] <= price {\\n\\t\\t\\tl = m + 1\\n\\t\\t} else {\\n\\t\\t\\tr = m - 1\\n\\t\\t}\\n\\t}\\n\\tsp.list = append(sp.list, 0)\\n\\tcopy(sp.list[l+1:], sp.list[l:])\\n\\tsp.list[l] = price\\n}\\n\\nfunc (sp *StockPrice) Current() int {\\n\\treturn sp.currentPrice\\n}\\n\\nfunc (sp *StockPrice) Maximum() int {\\n\\treturn sp.list[len(sp.list)-1]\\n}\\n\\nfunc (sp *StockPrice) Minimum() int {\\n\\treturn sp.list[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513479,
                "title": "c-using-sortedlist-as-heap",
                "content": "```\\npublic class StockPrice {\\n\\n    SortedList<int,int> maxPrice;\\n    SortedList<int,int> minPrice;\\n    Dictionary<int,int> timePrice;\\n    int latestTime = -1;\\n    \\n    public StockPrice() {\\n        maxPrice = new SortedList<int,int>(Comparer<int>.Create((x, y) => y.CompareTo(x)));\\n        minPrice = new SortedList<int,int>();\\n        timePrice = new Dictionary<int,int>();\\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        latestTime = Math.Max(latestTime, timestamp);\\n        \\n        if(timePrice.ContainsKey(timestamp))\\n        {\\n            var oldValue = timePrice[timestamp];\\n            Remove(maxPrice, oldValue);\\n            Remove(minPrice, oldValue);\\n        }        \\n        \\n        timePrice[timestamp] = price;                \\n        \\n        Add(maxPrice, price);\\n        Add(minPrice, price);        \\n    }\\n    \\n    public int Current() {\\n        return timePrice[latestTime];\\n    }\\n    \\n    public int Maximum() {\\n        return maxPrice.First().Key;\\n    }\\n    \\n    public int Minimum() {        \\n        return minPrice.First().Key;\\n    }   \\n    \\n     public void Add(SortedList<int, int> lst, int num)\\n        {\\n            if (lst.ContainsKey(num))\\n                lst[num]++;\\n            else\\n                lst.Add(num, 1);\\n        }\\n\\n        public void Remove(SortedList<int, int> lst, int num)\\n        {\\n            if (lst.ContainsKey(num))\\n            {\\n                if (lst[num] == 1)\\n                    lst.Remove(num);\\n                else\\n                    lst[num]--;\\n            }\\n        }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class StockPrice {\\n\\n    SortedList<int,int> maxPrice;\\n    SortedList<int,int> minPrice;\\n    Dictionary<int,int> timePrice;\\n    int latestTime = -1;\\n    \\n    public StockPrice() {\\n        maxPrice = new SortedList<int,int>(Comparer<int>.Create((x, y) => y.CompareTo(x)));\\n        minPrice = new SortedList<int,int>();\\n        timePrice = new Dictionary<int,int>();\\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        latestTime = Math.Max(latestTime, timestamp);\\n        \\n        if(timePrice.ContainsKey(timestamp))\\n        {\\n            var oldValue = timePrice[timestamp];\\n            Remove(maxPrice, oldValue);\\n            Remove(minPrice, oldValue);\\n        }        \\n        \\n        timePrice[timestamp] = price;                \\n        \\n        Add(maxPrice, price);\\n        Add(minPrice, price);        \\n    }\\n    \\n    public int Current() {\\n        return timePrice[latestTime];\\n    }\\n    \\n    public int Maximum() {\\n        return maxPrice.First().Key;\\n    }\\n    \\n    public int Minimum() {        \\n        return minPrice.First().Key;\\n    }   \\n    \\n     public void Add(SortedList<int, int> lst, int num)\\n        {\\n            if (lst.ContainsKey(num))\\n                lst[num]++;\\n            else\\n                lst.Add(num, 1);\\n        }\\n\\n        public void Remove(SortedList<int, int> lst, int num)\\n        {\\n            if (lst.ContainsKey(num))\\n            {\\n                if (lst[num] == 1)\\n                    lst.Remove(num);\\n                else\\n                    lst[num]--;\\n            }\\n        }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513426,
                "title": "c-using-map",
                "content": "```\\n\\nclass StockPrice {\\n    map<int,int> stock;\\n    map<int,int> minmax;\\n    int curr=-1;    \\n    public:\\n    \\n    void update(int timestamp, int price) {\\n        if(stock.find(timestamp) != stock.end())\\n        {\\n            int pre_price=stock[timestamp];\\n            minmax[pre_price]--;            \\n            if(minmax[pre_price]==0)\\n                minmax.erase(pre_price);\\n        }           \\n        minmax[price]++;\\n        stock[timestamp]=price; \\n        curr=max(curr,timestamp);\\n    }    \\n    \\n    int current() {\\n       return stock[curr]; \\n    }\\n    \\n    int maximum() {\\n         auto it=minmax.rbegin();\\n         return it->first;\\n    }\\n    \\n    int minimum() {\\n        auto it=minmax.begin();\\n        return it->first;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\nclass StockPrice {\\n    map<int,int> stock;\\n    map<int,int> minmax;\\n    int curr=-1;    \\n    public:\\n    \\n    void update(int timestamp, int price) {\\n        if(stock.find(timestamp) != stock.end())\\n        {\\n            int pre_price=stock[timestamp];\\n            minmax[pre_price]--;            \\n            if(minmax[pre_price]==0)\\n                minmax.erase(pre_price);\\n        }           \\n        minmax[price]++;\\n        stock[timestamp]=price; \\n        curr=max(curr,timestamp);\\n    }    \\n    \\n    int current() {\\n       return stock[curr]; \\n    }\\n    \\n    int maximum() {\\n         auto it=minmax.rbegin();\\n         return it->first;\\n    }\\n    \\n    int minimum() {\\n        auto it=minmax.begin();\\n        return it->first;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2812140,
                "title": "explanation-o-n-log-n-java-2-priority-queues-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to tackle this problem by parts. For keeping track of the price at a certain moment we use the HashMap, for keeping track of the maximum value and minimum we can use two queues, from there we have to figure out how we can use them to implement each method.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor the current price we only have to keep track of the latest timestamp and consult the price in the hashnap.\\nFor the update we have to add the new information given to the queues of max and min and then we will worry if the info at the top is the accurate.\\nFor getting the min and max we are going to retrieve the peek of the queue and check with its corresponding timestamp if is the correct one comparing the value with what we have saved in the hashmap.\\n# Complexity\\n- Time complexity: O(N LOG N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass StockPrice {\\n    //SPACE: O(N)\\n    Queue<int[]> maxQ;\\n    Queue<int[]> minQ;\\n    HashMap<Integer,Integer> tpMap;\\n    int latestTimestamp;\\n    public StockPrice() {\\n        maxQ = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        minQ = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        tpMap = new HashMap<>();\\n        latestTimestamp = 0;\\n    }\\n    //Time: O(LOG N)\\n    public void update(int timestamp, int price) {\\n        //Updating latestTimestamp\\n        latestTimestamp = timestamp > latestTimestamp ? timestamp : latestTimestamp;\\n\\n        //adding prices to queues\\n        maxQ.add(new int[]{timestamp,price});\\n        minQ.add(new int[]{timestamp,price});\\n\\n        //Updating-Adding register of price at timestamp\\n        tpMap.put(timestamp,price);\\n    }\\n    //Time: O(1)\\n    public int current() {\\n        return tpMap.get(latestTimestamp);\\n    }\\n    //Time: O(N LOG N)\\n    public int maximum() {\\n        //Find the first max value that corresponds with value saved in hashmap\\n        // to validate that is the correct one.\\n        while(maxQ.peek()[1] != tpMap.get(maxQ.peek()[0])){\\n            maxQ.poll();\\n        }\\n        return maxQ.peek()[1];\\n    }\\n    //Time: O(N LOG N)\\n    public int minimum() {\\n        while(minQ.peek()[1] != tpMap.get(minQ.peek()[0])){\\n            minQ.poll();\\n        }\\n        return minQ.peek()[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StockPrice {\\n    //SPACE: O(N)\\n    Queue<int[]> maxQ;\\n    Queue<int[]> minQ;\\n    HashMap<Integer,Integer> tpMap;\\n    int latestTimestamp;\\n    public StockPrice() {\\n        maxQ = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        minQ = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        tpMap = new HashMap<>();\\n        latestTimestamp = 0;\\n    }\\n    //Time: O(LOG N)\\n    public void update(int timestamp, int price) {\\n        //Updating latestTimestamp\\n        latestTimestamp = timestamp > latestTimestamp ? timestamp : latestTimestamp;\\n\\n        //adding prices to queues\\n        maxQ.add(new int[]{timestamp,price});\\n        minQ.add(new int[]{timestamp,price});\\n\\n        //Updating-Adding register of price at timestamp\\n        tpMap.put(timestamp,price);\\n    }\\n    //Time: O(1)\\n    public int current() {\\n        return tpMap.get(latestTimestamp);\\n    }\\n    //Time: O(N LOG N)\\n    public int maximum() {\\n        //Find the first max value that corresponds with value saved in hashmap\\n        // to validate that is the correct one.\\n        while(maxQ.peek()[1] != tpMap.get(maxQ.peek()[0])){\\n            maxQ.poll();\\n        }\\n        return maxQ.peek()[1];\\n    }\\n    //Time: O(N LOG N)\\n    public int minimum() {\\n        while(minQ.peek()[1] != tpMap.get(minQ.peek()[0])){\\n            minQ.poll();\\n        }\\n        return minQ.peek()[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023993,
                "title": "python-concise-solution-using-max-min-heap",
                "content": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.latest_prices = {}\\n        self.time = 1\\n        self.min_prices = []\\n        self.max_prices = []\\n        heapify(self.min_prices)\\n        heapify(self.max_prices)\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.latest_prices[timestamp] = price\\n        self.time = max(self.time, timestamp)\\n        heapq.heappush(self.min_prices, (price,timestamp))\\n        heapq.heappush(self.max_prices, (-price,timestamp))\\n\\n    def current(self) -> int:\\n        return self.latest_prices[self.time]\\n\\n    def maximum(self) -> int:\\n        top = self.max_prices[0]\\n        while self.latest_prices[top[1]] != -top[0]:\\n            heapq.heappop(self.max_prices)\\n            top = self.max_prices[0]\\n        return -top[0]\\n\\n    def minimum(self) -> int:\\n        top = self.min_prices[0]\\n        while self.latest_prices[top[1]] != top[0]:\\n            heapq.heappop(self.min_prices)\\n            top = self.min_prices[0]\\n        return top[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.latest_prices = {}\\n        self.time = 1\\n        self.min_prices = []\\n        self.max_prices = []\\n        heapify(self.min_prices)\\n        heapify(self.max_prices)\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.latest_prices[timestamp] = price\\n        self.time = max(self.time, timestamp)\\n        heapq.heappush(self.min_prices, (price,timestamp))\\n        heapq.heappush(self.max_prices, (-price,timestamp))\\n\\n    def current(self) -> int:\\n        return self.latest_prices[self.time]\\n\\n    def maximum(self) -> int:\\n        top = self.max_prices[0]\\n        while self.latest_prices[top[1]] != -top[0]:\\n            heapq.heappop(self.max_prices)\\n            top = self.max_prices[0]\\n        return -top[0]\\n\\n    def minimum(self) -> int:\\n        top = self.min_prices[0]\\n        while self.latest_prices[top[1]] != top[0]:\\n            heapq.heappop(self.min_prices)\\n            top = self.min_prices[0]\\n        return top[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888627,
                "title": "python3-2-heaps-vs-sortedlist",
                "content": "* 2 heaps:\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.mx=[]\\n        self.mn=[]\\n        self.dct={}\\n        self.latest=0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.dct[timestamp]=price\\n        if timestamp>self.latest: self.latest=timestamp\\n        heapq.heappush(self.mx,(-price,timestamp))\\n        heapq.heappush(self.mn,(price,timestamp))\\n\\n    def current(self) -> int:\\n        return self.dct[self.latest]\\n\\n    def maximum(self) -> int:\\n        while self.dct[self.mx[0][1]]!=-self.mx[0][0]: heapq.heappop(self.mx)\\n        return -self.mx[0][0]\\n    \\n    def minimum(self) -> int:\\n        while self.dct[self.mn[0][1]]!=self.mn[0][0]: heapq.heappop(self.mn)\\n        return self.mn[0][0]\\n```\\n\\n* SortedList()\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.l=SortedList()\\n        self.dct={}\\n        self.latest=0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.dct: self.l.discard(self.dct[timestamp])\\n        self.l.add(price)\\n        self.dct[timestamp]=price\\n        if timestamp>self.latest: self.latest=timestamp\\n\\n    def current(self) -> int:\\n        return self.dct[self.latest]\\n\\n    def maximum(self) -> int:\\n        return self.l[-1]\\n\\n    def minimum(self) -> int:\\n        return self.l[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.mx=[]\\n        self.mn=[]\\n        self.dct={}\\n        self.latest=0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.dct[timestamp]=price\\n        if timestamp>self.latest: self.latest=timestamp\\n        heapq.heappush(self.mx,(-price,timestamp))\\n        heapq.heappush(self.mn,(price,timestamp))\\n\\n    def current(self) -> int:\\n        return self.dct[self.latest]\\n\\n    def maximum(self) -> int:\\n        while self.dct[self.mx[0][1]]!=-self.mx[0][0]: heapq.heappop(self.mx)\\n        return -self.mx[0][0]\\n    \\n    def minimum(self) -> int:\\n        while self.dct[self.mn[0][1]]!=self.mn[0][0]: heapq.heappop(self.mn)\\n        return self.mn[0][0]\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.l=SortedList()\\n        self.dct={}\\n        self.latest=0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.dct: self.l.discard(self.dct[timestamp])\\n        self.l.add(price)\\n        self.dct[timestamp]=price\\n        if timestamp>self.latest: self.latest=timestamp\\n\\n    def current(self) -> int:\\n        return self.dct[self.latest]\\n\\n    def maximum(self) -> int:\\n        return self.l[-1]\\n\\n    def minimum(self) -> int:\\n        return self.l[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613602,
                "title": "js-100",
                "content": "```\\n\\nvar StockPrice = function() {\\n    this.currentTime = 0;\\n    this.currentPrice = null;\\n    \\n    this.priceMaxHeap = new Heap((a,b) => {\\n        return a.price > b.price\\n    });\\n    this.priceMinHeap = new Heap((a,b) => {\\n        return a.price < b.price\\n    });\\n    this.map = new Map();\\n};\\n\\n/** \\n * @param {number} timestamp \\n * @param {number} price\\n * @return {void}\\n */\\nStockPrice.prototype.update = function(timestamp, price) {\\n    \\n    if(this.currentTime <= timestamp){\\n        this.currentTime = timestamp;\\n        this.currentPrice = price;\\n    }\\n    \\n     let info = {timestamp,price};\\n     this.priceMinHeap.push(info)\\n     this.priceMaxHeap.push(info)\\n     this.map.set(timestamp,price)\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.current = function() {\\n    return this.currentPrice;\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.maximum = function() {\\n    let res = this.priceMaxHeap.peek();\\n    \\n    while(res && res.price != this.map.get(res.timestamp)){\\n        this.priceMaxHeap.pop();\\n        res = this.priceMaxHeap.peek();\\n    }\\n    \\n    return res ? res.price : null;\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.minimum = function() {\\n    \\n    let res = this.priceMinHeap.peek();\\n    while(res && res.price != this.map.get(res.timestamp)){\\n        this.priceMinHeap.pop();\\n        res = this.priceMinHeap.peek();\\n    }\\n    return res ? res.price : null;\\n};\\n\\n/** \\n * Your StockPrice object will be instantiated and called as such:\\n * var obj = new StockPrice()\\n * obj.update(timestamp,price)\\n * var param_2 = obj.current()\\n * var param_3 = obj.maximum()\\n * var param_4 = obj.minimum()\\n */\\n\\n\\n\\n\\nclass Heap {\\n    constructor(compare){\\n        this.arr = [];\\n        this.compare = compare;\\n    }\\n    \\n    push(val){\\n        this.arr.push(val);\\n        this.heapifyUp();\\n    }\\n    \\n    pop(){\\n        if(this.arr.length == 0){\\n            return;\\n        }\\n        let res = this.arr[0];\\n        this.arr[0] = this.arr[this.arr.length - 1];\\n        this.arr.pop();\\n        this.heapifyBottom();\\n        return res;\\n    }\\n    \\n    heapifyBottom(pos = 0){\\n        if(pos >= this.arr.length){\\n            return;\\n        }\\n        let curr = pos;\\n        let left = pos * 2 + 1;\\n        let right = pos * 2 + 2;\\n        let max = pos;\\n        \\n        if(this.arr.length > left && this.compare(this.arr[left],this.arr[max])){\\n            max = left;\\n        }\\n        \\n        if(this.arr.length > right && this.compare(this.arr[right],this.arr[max])){\\n            max = right;\\n        }\\n        \\n        if(max != curr){\\n            let temp = this.arr[curr];\\n            this.arr[curr] = this.arr[max];\\n            this.arr[max] = temp;\\n            this.heapifyBottom(max);\\n        }\\n        \\n    }\\n    \\n    heapifyUp(pos = this.arr.length - 1){\\n        if(pos <= 0){\\n            return;\\n        }\\n        let parent = Math.floor(pos / 2) - (pos % 2 == 0 ? 1 : 0);\\n        if(this.compare(this.arr[pos],this.arr[parent])){\\n           let temp = this.arr[pos];\\n            this.arr[pos] = this.arr[parent];\\n            this.arr[parent] = temp;\\n            this.heapifyUp(parent);\\n        }\\n    }\\n    \\n    peek(){\\n        return this.arr.length > 0 ? this.arr[0] : {};\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nvar StockPrice = function() {\\n    this.currentTime = 0;\\n    this.currentPrice = null;\\n    \\n    this.priceMaxHeap = new Heap((a,b) => {\\n        return a.price > b.price\\n    });\\n    this.priceMinHeap = new Heap((a,b) => {\\n        return a.price < b.price\\n    });\\n    this.map = new Map();\\n};\\n\\n/** \\n * @param {number} timestamp \\n * @param {number} price\\n * @return {void}\\n */\\nStockPrice.prototype.update = function(timestamp, price) {\\n    \\n    if(this.currentTime <= timestamp){\\n        this.currentTime = timestamp;\\n        this.currentPrice = price;\\n    }\\n    \\n     let info = {timestamp,price};\\n     this.priceMinHeap.push(info)\\n     this.priceMaxHeap.push(info)\\n     this.map.set(timestamp,price)\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.current = function() {\\n    return this.currentPrice;\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.maximum = function() {\\n    let res = this.priceMaxHeap.peek();\\n    \\n    while(res && res.price != this.map.get(res.timestamp)){\\n        this.priceMaxHeap.pop();\\n        res = this.priceMaxHeap.peek();\\n    }\\n    \\n    return res ? res.price : null;\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.minimum = function() {\\n    \\n    let res = this.priceMinHeap.peek();\\n    while(res && res.price != this.map.get(res.timestamp)){\\n        this.priceMinHeap.pop();\\n        res = this.priceMinHeap.peek();\\n    }\\n    return res ? res.price : null;\\n};\\n\\n/** \\n * Your StockPrice object will be instantiated and called as such:\\n * var obj = new StockPrice()\\n * obj.update(timestamp,price)\\n * var param_2 = obj.current()\\n * var param_3 = obj.maximum()\\n * var param_4 = obj.minimum()\\n */\\n\\n\\n\\n\\nclass Heap {\\n    constructor(compare){\\n        this.arr = [];\\n        this.compare = compare;\\n    }\\n    \\n    push(val){\\n        this.arr.push(val);\\n        this.heapifyUp();\\n    }\\n    \\n    pop(){\\n        if(this.arr.length == 0){\\n            return;\\n        }\\n        let res = this.arr[0];\\n        this.arr[0] = this.arr[this.arr.length - 1];\\n        this.arr.pop();\\n        this.heapifyBottom();\\n        return res;\\n    }\\n    \\n    heapifyBottom(pos = 0){\\n        if(pos >= this.arr.length){\\n            return;\\n        }\\n        let curr = pos;\\n        let left = pos * 2 + 1;\\n        let right = pos * 2 + 2;\\n        let max = pos;\\n        \\n        if(this.arr.length > left && this.compare(this.arr[left],this.arr[max])){\\n            max = left;\\n        }\\n        \\n        if(this.arr.length > right && this.compare(this.arr[right],this.arr[max])){\\n            max = right;\\n        }\\n        \\n        if(max != curr){\\n            let temp = this.arr[curr];\\n            this.arr[curr] = this.arr[max];\\n            this.arr[max] = temp;\\n            this.heapifyBottom(max);\\n        }\\n        \\n    }\\n    \\n    heapifyUp(pos = this.arr.length - 1){\\n        if(pos <= 0){\\n            return;\\n        }\\n        let parent = Math.floor(pos / 2) - (pos % 2 == 0 ? 1 : 0);\\n        if(this.compare(this.arr[pos],this.arr[parent])){\\n           let temp = this.arr[pos];\\n            this.arr[pos] = this.arr[parent];\\n            this.arr[parent] = temp;\\n            this.heapifyUp(parent);\\n        }\\n    }\\n    \\n    peek(){\\n        return this.arr.length > 0 ? this.arr[0] : {};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514631,
                "title": "python-sortedlist-and-2-heaps-solutions",
                "content": "__Solution 1__: we can use a sorted list to keep the prices sorted. It also allows us to a remove a certain price in O(1). Moreover, we can also access the minimum and maximum price in O(1). The insert operation takes O(logN) time though. \\n```\\nfrom sortedcontainers import SortedList\\nclass StockPrice:\\n    def __init__(self):\\n        self.timed_prices = {}\\n        self.sorted_prices = SortedList([])\\n        self.latest = 0\\n        \\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.timed_prices:\\n            self.sorted_prices.remove(self.timed_prices[timestamp])\\n        self.timed_prices[timestamp] = price\\n        self.latest = max(self.latest, timestamp)\\n        self.sorted_prices.add(price)\\n        \\n    def current(self) -> int:\\n        return self.timed_prices[self.latest]\\n        \\n    def maximum(self) -> int:\\n        return self.sorted_prices[-1]\\n        \\n    def minimum(self) -> int:\\n        return self.sorted_prices[0]\\n``` \\n__Solution 2__: 2 heaps solution. We use a min and max heap to have access to the minimum and maximum price. Notice that time complexity is on average worse for the minimum and maximum operations than in solution 1, i.e., O(logN) instead of O(1) due to the popping of old/incorrect prices.\\n```\\nclass StockPrice:\\n    def __init__(self):\\n        self.latest = 0\\n        self.prices = {}\\n        self.h_min = []\\n        self.h_max = []\\n\\ndef update(self, timestamp: int, price: int) -> None:\\n        self.prices[timestamp] = price\\n        self.latest = max(self.latest, timestamp)\\n        heapq.heappush(self.h_min, (price, timestamp))\\n        heapq.heappush(self.h_max, (-price, timestamp))\\n        \\n    def current(self) -> int:\\n        return self.prices[self.latest]\\n\\n    def maximum(self) -> int:\\n        v = self.h_max[0]\\n        while -v[0] != self.prices[v[1]]:\\n            heapq.heappop(self.h_max)\\n            v = self.h_max[0]\\n        return -v[0]\\n    def minimum(self) -> int:\\n        v = self.h_min[0]\\n        while v[0] != self.prices[v[1]]:\\n            heapq.heappop(self.h_min)\\n            v = self.h_min[0]\\n        return v[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass StockPrice:\\n    def __init__(self):\\n        self.timed_prices = {}\\n        self.sorted_prices = SortedList([])\\n        self.latest = 0\\n        \\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.timed_prices:\\n            self.sorted_prices.remove(self.timed_prices[timestamp])\\n        self.timed_prices[timestamp] = price\\n        self.latest = max(self.latest, timestamp)\\n        self.sorted_prices.add(price)\\n        \\n    def current(self) -> int:\\n        return self.timed_prices[self.latest]\\n        \\n    def maximum(self) -> int:\\n        return self.sorted_prices[-1]\\n        \\n    def minimum(self) -> int:\\n        return self.sorted_prices[0]\\n```\n```\\nclass StockPrice:\\n    def __init__(self):\\n        self.latest = 0\\n        self.prices = {}\\n        self.h_min = []\\n        self.h_max = []\\n\\ndef update(self, timestamp: int, price: int) -> None:\\n        self.prices[timestamp] = price\\n        self.latest = max(self.latest, timestamp)\\n        heapq.heappush(self.h_min, (price, timestamp))\\n        heapq.heappush(self.h_max, (-price, timestamp))\\n        \\n    def current(self) -> int:\\n        return self.prices[self.latest]\\n\\n    def maximum(self) -> int:\\n        v = self.h_max[0]\\n        while -v[0] != self.prices[v[1]]:\\n            heapq.heappop(self.h_max)\\n            v = self.h_max[0]\\n        return -v[0]\\n    def minimum(self) -> int:\\n        v = self.h_min[0]\\n        while v[0] != self.prices[v[1]]:\\n            heapq.heappop(self.h_min)\\n            v = self.h_min[0]\\n        return v[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513408,
                "title": "c-two-heaps-explained",
                "content": "**Explanation :**\\n1. Maintaining pq_max and pq_min for retrieving max and min values at any given point of time\\n2. Maintained frequency map for price.\\n3. Maintained another map - um for (timestamp,price) mapping.\\n\\n**update(timestamp,new_price) :**\\n\\n1. If timestamp is already present in um with price old_price\\n\\t1.1 Reduce the frequency of old_price\\n\\t1.2 Check both heaps top elements, if their frequency has become zero, remove them out\\n2. Update timestamp in um with (timestamp, new_price).\\n3. Increase the frequency for new price.\\n4. If new price is not present in heaps, add them.\\n5. Make sure to maintain track of current price by getting price for max timestamp value so far.\\n\\nAll other functions are just one-liner and self-explained.\\n\\n\\n```\\nclass StockPrice {\\n    priority_queue<int> pq_max;\\n    priority_queue<int,vector<int>, greater<int> > pq_min;\\n    unordered_map<int,int> freq;\\n    unordered_map<int,int> um;\\n    \\n    int max_ts,curr;\\npublic:\\n    StockPrice() {\\n        max_ts = curr = 0;\\n    }\\n    \\n    void update(int ts, int price) {\\n\\n        if(um.find(ts) != um.end()){         //If this timestamp is already present\\n            freq[um[ts]]--;\\n\\t\\t\\t\\n            while(!pq_max.empty() && freq[pq_max.top()] == 0){\\n                pq_max.pop();\\n            }\\n            while(!pq_min.empty() && freq[pq_min.top()] == 0){\\n                pq_min.pop();\\n            }\\n        }\\n        \\n        um[ts] = price;     //Update timestamp with new price\\n        \\n        if(freq[price]++ == 0){ //If not present in heaps\\n            pq_max.push(price);\\n            pq_min.push(price);    \\n        }\\n        \\n        if(ts >= max_ts){ //Maintain latest price (current)\\n            max_ts = ts;\\n            curr = price;\\n        }\\n    }\\n    \\n    int current() {\\n        return curr;\\n    }\\n    \\n    int maximum() {\\n        return pq_max.top();\\n    }\\n    \\n    int minimum() {\\n        return pq_min.top();\\n    }\\n};\\n```\\nPlease upvote , it will be helpful for me. Thanks !\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice {\\n    priority_queue<int> pq_max;\\n    priority_queue<int,vector<int>, greater<int> > pq_min;\\n    unordered_map<int,int> freq;\\n    unordered_map<int,int> um;\\n    \\n    int max_ts,curr;\\npublic:\\n    StockPrice() {\\n        max_ts = curr = 0;\\n    }\\n    \\n    void update(int ts, int price) {\\n\\n        if(um.find(ts) != um.end()){         //If this timestamp is already present\\n            freq[um[ts]]--;\\n\\t\\t\\t\\n            while(!pq_max.empty() && freq[pq_max.top()] == 0){\\n                pq_max.pop();\\n            }\\n            while(!pq_min.empty() && freq[pq_min.top()] == 0){\\n                pq_min.pop();\\n            }\\n        }\\n        \\n        um[ts] = price;     //Update timestamp with new price\\n        \\n        if(freq[price]++ == 0){ //If not present in heaps\\n            pq_max.push(price);\\n            pq_min.push(price);    \\n        }\\n        \\n        if(ts >= max_ts){ //Maintain latest price (current)\\n            max_ts = ts;\\n            curr = price;\\n        }\\n    }\\n    \\n    int current() {\\n        return curr;\\n    }\\n    \\n    int maximum() {\\n        return pq_max.top();\\n    }\\n    \\n    int minimum() {\\n        return pq_min.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804688,
                "title": "c-map-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIn this probem -\\n\\n1. We can keep a map to store the (timestamp,price) pair\\n2. Since we always need the lastest time, we can keep a seperate variable for that\\n3. We can keep a multiset of prices to store the prices and get the smallest and the largest prices in O(1) time. \\n\\n\\n# Code\\n```\\nclass StockPrice {\\npublic:\\n\\n    unordered_map<int,int> m;\\n    int maxTime = 0;\\n    multiset<int> prices;\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        \\n        if(m.find(timestamp)==m.end())  // this timestamp has been fount for the first time\\n        {\\n                m[timestamp] = price;\\n                prices.insert(price);\\n        }\\n        else    // this timestamp has been found earlier so modify the prices\\n        {\\n                if(prices.count(m[timestamp]))\\n                prices.erase(prices.find(m[timestamp]));\\n                m[timestamp] = price;\\n                prices.insert(price);\\n        }\\n\\n        maxTime = max(maxTime,timestamp);\\n    }\\n    \\n    int current() {\\n        \\n\\n        return m[maxTime];\\n    }\\n    \\n    int maximum() {\\n\\n        auto it = prices.rbegin();\\n        int maxi = *it;\\n\\n        return maxi;\\n        \\n    }\\n    \\n    int minimum() {\\n\\n        auto it = prices.begin();\\n        int mini = *it;\\n\\n        return mini;\\n        \\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```\\n**Please upvote if you found it helpful**",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n\\n    unordered_map<int,int> m;\\n    int maxTime = 0;\\n    multiset<int> prices;\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        \\n        if(m.find(timestamp)==m.end())  // this timestamp has been fount for the first time\\n        {\\n                m[timestamp] = price;\\n                prices.insert(price);\\n        }\\n        else    // this timestamp has been found earlier so modify the prices\\n        {\\n                if(prices.count(m[timestamp]))\\n                prices.erase(prices.find(m[timestamp]));\\n                m[timestamp] = price;\\n                prices.insert(price);\\n        }\\n\\n        maxTime = max(maxTime,timestamp);\\n    }\\n    \\n    int current() {\\n        \\n\\n        return m[maxTime];\\n    }\\n    \\n    int maximum() {\\n\\n        auto it = prices.rbegin();\\n        int maxi = *it;\\n\\n        return maxi;\\n        \\n    }\\n    \\n    int minimum() {\\n\\n        auto it = prices.begin();\\n        int mini = *it;\\n\\n        return mini;\\n        \\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366177,
                "title": "java-solution-2-approaches-hashmap-treemap-priority-queue",
                "content": "```\\n// Approach 1: Using HashMap and TreeMap - time O(n*logn) | space O(n)\\nclass StockPrice {\\n\\n    private HashMap<Integer, Integer> timestampPriceMap;\\n    private TreeMap<Integer, Integer> priceFrequencyMap;\\n    private int lastestTimestamp = Integer.MIN_VALUE;\\n\\n    public StockPrice() {\\n        timestampPriceMap = new HashMap<>();\\n        priceFrequencyMap = new TreeMap<>();\\n    }\\n\\n    public void update(int timestamp, int price) {\\n\\n        if (timestampPriceMap.containsKey(timestamp)) {\\n\\n            Integer oldPrice = timestampPriceMap.get(timestamp);\\n            priceFrequencyMap.put(oldPrice, priceFrequencyMap.get(oldPrice) - 1);\\n            if (priceFrequencyMap.get(oldPrice) == 0) \\n                priceFrequencyMap.remove(oldPrice);\\n        }\\n\\n        timestampPriceMap.put(timestamp, price);\\n        priceFrequencyMap.put(price, priceFrequencyMap.getOrDefault(price, 0) + 1);\\n        lastestTimestamp = Math.max(lastestTimestamp, timestamp);\\n    }\\n\\n    public int current() {\\n        return timestampPriceMap.get(lastestTimestamp);\\n    }\\n\\n    public int maximum() {\\n        return priceFrequencyMap.lastKey();\\n    }\\n\\n    public int minimum() {\\n        return priceFrequencyMap.firstKey();\\n    }\\n}\\n\\n// Approach 2: Using HashMap, Min Heap and Max Heap - time O(n*logn) | space O(n)\\nclass StockPrice {\\n\\n    private HashMap<Integer, Integer> timestampPriceMap;\\n    private PriorityQueue<int[]> minHeap;\\n    private PriorityQueue<int[]> maxHeap;\\n\\n    private int latestTimestamp = Integer.MIN_VALUE;\\n\\n    public StockPrice() {\\n        timestampPriceMap = new HashMap<>();\\n        minHeap = new PriorityQueue<>((entry1, entry2) -> entry1[1] - entry2[1]);\\n        maxHeap = new PriorityQueue<>((entry1, entry2) -> entry2[1] - entry1[1]);\\n    }\\n\\n    public void update(int timestamp, int price) {\\n\\n        timestampPriceMap.put(timestamp, price);\\n        minHeap.add(new int[]{timestamp, price});\\n        maxHeap.add(new int[]{timestamp, price});\\n\\n        latestTimestamp = Math.max(latestTimestamp, timestamp);\\n    }\\n\\n    public int current() {\\n        return timestampPriceMap.get(latestTimestamp);\\n    }\\n\\n    public int maximum() {\\n\\n        int[] max = maxHeap.peek();\\n        while (timestampPriceMap.get(max[0]) != max[1]) {\\n            maxHeap.poll();\\n            max = maxHeap.peek();\\n        }\\n        return max[1];\\n    }\\n\\n    public int minimum() {\\n        int[] min = minHeap.peek();\\n        while (timestampPriceMap.get(min[0]) != min[1]) {\\n            minHeap.poll();\\n            min = minHeap.peek();\\n        }\\n        return min[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Approach 1: Using HashMap and TreeMap - time O(n*logn) | space O(n)\\nclass StockPrice {\\n\\n    private HashMap<Integer, Integer> timestampPriceMap;\\n    private TreeMap<Integer, Integer> priceFrequencyMap;\\n    private int lastestTimestamp = Integer.MIN_VALUE;\\n\\n    public StockPrice() {\\n        timestampPriceMap = new HashMap<>();\\n        priceFrequencyMap = new TreeMap<>();\\n    }\\n\\n    public void update(int timestamp, int price) {\\n\\n        if (timestampPriceMap.containsKey(timestamp)) {\\n\\n            Integer oldPrice = timestampPriceMap.get(timestamp);\\n            priceFrequencyMap.put(oldPrice, priceFrequencyMap.get(oldPrice) - 1);\\n            if (priceFrequencyMap.get(oldPrice) == 0) \\n                priceFrequencyMap.remove(oldPrice);\\n        }\\n\\n        timestampPriceMap.put(timestamp, price);\\n        priceFrequencyMap.put(price, priceFrequencyMap.getOrDefault(price, 0) + 1);\\n        lastestTimestamp = Math.max(lastestTimestamp, timestamp);\\n    }\\n\\n    public int current() {\\n        return timestampPriceMap.get(lastestTimestamp);\\n    }\\n\\n    public int maximum() {\\n        return priceFrequencyMap.lastKey();\\n    }\\n\\n    public int minimum() {\\n        return priceFrequencyMap.firstKey();\\n    }\\n}\\n\\n// Approach 2: Using HashMap, Min Heap and Max Heap - time O(n*logn) | space O(n)\\nclass StockPrice {\\n\\n    private HashMap<Integer, Integer> timestampPriceMap;\\n    private PriorityQueue<int[]> minHeap;\\n    private PriorityQueue<int[]> maxHeap;\\n\\n    private int latestTimestamp = Integer.MIN_VALUE;\\n\\n    public StockPrice() {\\n        timestampPriceMap = new HashMap<>();\\n        minHeap = new PriorityQueue<>((entry1, entry2) -> entry1[1] - entry2[1]);\\n        maxHeap = new PriorityQueue<>((entry1, entry2) -> entry2[1] - entry1[1]);\\n    }\\n\\n    public void update(int timestamp, int price) {\\n\\n        timestampPriceMap.put(timestamp, price);\\n        minHeap.add(new int[]{timestamp, price});\\n        maxHeap.add(new int[]{timestamp, price});\\n\\n        latestTimestamp = Math.max(latestTimestamp, timestamp);\\n    }\\n\\n    public int current() {\\n        return timestampPriceMap.get(latestTimestamp);\\n    }\\n\\n    public int maximum() {\\n\\n        int[] max = maxHeap.peek();\\n        while (timestampPriceMap.get(max[0]) != max[1]) {\\n            maxHeap.poll();\\n            max = maxHeap.peek();\\n        }\\n        return max[1];\\n    }\\n\\n    public int minimum() {\\n        int[] min = minHeap.peek();\\n        while (timestampPriceMap.get(min[0]) != min[1]) {\\n            minHeap.poll();\\n            min = minHeap.peek();\\n        }\\n        return min[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089216,
                "title": "python-dict-sortedset",
                "content": "```\\nfrom sortedcontainers import SortedSet\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.time_to_price = {}\\n        self.price_time = SortedSet()        \\n        self.current_timestamp = 0\\n        \\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.time_to_price:\\n            self.price_time.remove((self.time_to_price[timestamp], timestamp))\\n\\t\\t\\t\\n        self.price_time.add((price, timestamp))            \\n        self.time_to_price[timestamp] = price        \\n        self.current_timestamp = max(self.current_timestamp, timestamp)\\n\\n    def current(self) -> int:\\n        return self.time_to_price[self.current_timestamp]\\n\\n    def maximum(self) -> int:\\n        return self.price_time[-1][0]   \\n\\n    def minimum(self) -> int:\\n        return self.price_time[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.time_to_price = {}\\n        self.price_time = SortedSet()        \\n        self.current_timestamp = 0\\n        \\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.time_to_price:\\n            self.price_time.remove((self.time_to_price[timestamp], timestamp))\\n\\t\\t\\t\\n        self.price_time.add((price, timestamp))            \\n        self.time_to_price[timestamp] = price        \\n        self.current_timestamp = max(self.current_timestamp, timestamp)\\n\\n    def current(self) -> int:\\n        return self.time_to_price[self.current_timestamp]\\n\\n    def maximum(self) -> int:\\n        return self.price_time[-1][0]   \\n\\n    def minimum(self) -> int:\\n        return self.price_time[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926757,
                "title": "java-treemap-treeset-straightforward",
                "content": "Thanks for dropping-by... Pls upvote if it\\'s useful to you... :-)\\n\\n\\n```\\nclass StockPrice {\\n    TreeMap<Integer,Integer> map;\\n    TreeSet<int[]> set; //timestamp-price\\n    \\n    public StockPrice() {\\n        map = new TreeMap<>();\\n        set = new TreeSet<>((a,b)->a[1] == b[1] ? a[0]-b[0] : a[1]-b[1]);\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(map.containsKey(timestamp)) {\\n            int oldPrice=map.get(timestamp);\\n            set.remove(new int[]{timestamp,oldPrice});\\n        }\\n            \\n        map.put(timestamp,price);\\n        set.add(new int[]{timestamp,price});\\n    }\\n    \\n    public int current() {\\n        return map.get(map.lastKey());\\n    }\\n    \\n    public int maximum() {\\n        return set.last()[1];\\n    }\\n    \\n    public int minimum() {\\n        return set.first()[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass StockPrice {\\n    TreeMap<Integer,Integer> map;\\n    TreeSet<int[]> set; //timestamp-price\\n    \\n    public StockPrice() {\\n        map = new TreeMap<>();\\n        set = new TreeSet<>((a,b)->a[1] == b[1] ? a[0]-b[0] : a[1]-b[1]);\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(map.containsKey(timestamp)) {\\n            int oldPrice=map.get(timestamp);\\n            set.remove(new int[]{timestamp,oldPrice});\\n        }\\n            \\n        map.put(timestamp,price);\\n        set.add(new int[]{timestamp,price});\\n    }\\n    \\n    public int current() {\\n        return map.get(map.lastKey());\\n    }\\n    \\n    public int maximum() {\\n        return set.last()[1];\\n    }\\n    \\n    public int minimum() {\\n        return set.first()[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926105,
                "title": "java-map-and-2-heaps",
                "content": "```\\nclass StockPrice {\\n    class Stock{\\n        int price;\\n        int stamp;\\n        public Stock(int stamp, int price){\\n            this.price=price;\\n            this.stamp=stamp;\\n        }\\n    }\\n    PriorityQueue<Stock> minHeap = new PriorityQueue<>((Stock a, Stock b) -> Integer.compare(a.price, b.price));\\n    PriorityQueue<Stock> maxHeap = new PriorityQueue<>((Stock a, Stock b) -> Integer.compare(b.price, a.price));\\n    Map<Integer, Integer> prices= new HashMap<>();\\n    int latestTime=1;\\n    public StockPrice() {\\n        \\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        Stock stock = new Stock(timestamp, price);\\n        prices.put(timestamp, price);\\n        minHeap.add(stock);\\n        maxHeap.add(stock);\\n        latestTime = Math.max(latestTime, timestamp);\\n\\n    }\\n    \\n    public int current() {\\n        return prices.get(latestTime);\\n    }\\n    \\n    public int maximum() {\\n        while(maxHeap.peek().price != prices.get(maxHeap.peek().stamp)){\\n           maxHeap.poll(); \\n        }\\n        return maxHeap.peek().price;\\n    }\\n    \\n    public int minimum() {\\n        while(minHeap.peek().price != prices.get(minHeap.peek().stamp)){\\n           minHeap.poll(); \\n        }\\n        return minHeap.peek().price; \\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n    class Stock{\\n        int price;\\n        int stamp;\\n        public Stock(int stamp, int price){\\n            this.price=price;\\n            this.stamp=stamp;\\n        }\\n    }\\n    PriorityQueue<Stock> minHeap = new PriorityQueue<>((Stock a, Stock b) -> Integer.compare(a.price, b.price));\\n    PriorityQueue<Stock> maxHeap = new PriorityQueue<>((Stock a, Stock b) -> Integer.compare(b.price, a.price));\\n    Map<Integer, Integer> prices= new HashMap<>();\\n    int latestTime=1;\\n    public StockPrice() {\\n        \\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        Stock stock = new Stock(timestamp, price);\\n        prices.put(timestamp, price);\\n        minHeap.add(stock);\\n        maxHeap.add(stock);\\n        latestTime = Math.max(latestTime, timestamp);\\n\\n    }\\n    \\n    public int current() {\\n        return prices.get(latestTime);\\n    }\\n    \\n    public int maximum() {\\n        while(maxHeap.peek().price != prices.get(maxHeap.peek().stamp)){\\n           maxHeap.poll(); \\n        }\\n        return maxHeap.peek().price;\\n    }\\n    \\n    public int minimum() {\\n        while(minHeap.peek().price != prices.get(minHeap.peek().stamp)){\\n           minHeap.poll(); \\n        }\\n        return minHeap.peek().price; \\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873133,
                "title": "java-99-2-heaps",
                "content": "Keeping a minheap and a maxheap and map to store the correct price\\n\\n```\\nclass StockPrice {\\n    PriorityQueue<int[]> minHeap;\\n    PriorityQueue<int[]> maxHeap;\\n    Map<Integer,Integer> map;\\n    int lastTime = 0;\\n    public StockPrice() {\\n        minHeap = new PriorityQueue<int[]>( (a,b) ->  Integer.compare(a[1],b[1]));\\n        maxHeap = new PriorityQueue<int[]>( (a,b) ->  -Integer.compare(a[1],b[1]));\\n        map = new HashMap();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n       lastTime = Math.max(timestamp, lastTime);\\n       map.put(timestamp, price);\\n       minHeap.add(new int[]{timestamp, price});\\n       maxHeap.add(new int[]{timestamp, price});\\n    }\\n    \\n    public int current() {\\n        return map.get(lastTime);\\n    }\\n    \\n    public int maximum() {\\n        while(map.get(maxHeap.peek()[0]) != maxHeap.peek()[1]){\\n            maxHeap.poll();\\n        }\\n        return maxHeap.peek()[1];\\n    }\\n    \\n    public int minimum() {\\n        while(map.get(minHeap.peek()[0]) != minHeap.peek()[1]){\\n            minHeap.poll();\\n        }\\n        return minHeap.peek()[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n    PriorityQueue<int[]> minHeap;\\n    PriorityQueue<int[]> maxHeap;\\n    Map<Integer,Integer> map;\\n    int lastTime = 0;\\n    public StockPrice() {\\n        minHeap = new PriorityQueue<int[]>( (a,b) ->  Integer.compare(a[1],b[1]));\\n        maxHeap = new PriorityQueue<int[]>( (a,b) ->  -Integer.compare(a[1],b[1]));\\n        map = new HashMap();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n       lastTime = Math.max(timestamp, lastTime);\\n       map.put(timestamp, price);\\n       minHeap.add(new int[]{timestamp, price});\\n       maxHeap.add(new int[]{timestamp, price});\\n    }\\n    \\n    public int current() {\\n        return map.get(lastTime);\\n    }\\n    \\n    public int maximum() {\\n        while(map.get(maxHeap.peek()[0]) != maxHeap.peek()[1]){\\n            maxHeap.poll();\\n        }\\n        return maxHeap.peek()[1];\\n    }\\n    \\n    public int minimum() {\\n        while(map.get(minHeap.peek()[0]) != minHeap.peek()[1]){\\n            minHeap.poll();\\n        }\\n        return minHeap.peek()[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826834,
                "title": "java-treeset-solution-explanation",
                "content": "My intiial idea was to keep min / max heaps like most here had, but I was troubled but the issue I ran into that I couldn\\'t figure out how to get around was updates to a price would take O(n) time to search in the heap and fix. A TreeMap also seemed reasonable to me, but the problem with that is we needed to be able to look up entries by timestamp (the key) to see if they should be updated, but we want to sort the entries by price (the value).\\n\\nSo the main idea to my approach is that we use a TreeSet to store the prices, which we sort by the price. This allows for constant time lookup for max / min operations with O(log n) for updates. We can also do removals in O(log n) time, so for any updates to an entry we remove and readd the updated entry in log n time to ensure the order remains sorted.\\n\\nSolution:\\n\\n```\\nclass StockPrice {\\n    \\n    int currentPrice = -1;\\n    int currentTime = -1;\\n    \\n    // entry of [a, b] where a is price and b is time\\n    TreeSet<int[]> prices = new TreeSet<>((a1, a2) -> {\\n        if (a1 == a2) {\\n            return 0;\\n        }\\n        return a1[0] != a2[0] ? Integer.compare(a1[0], a2[0]) : Integer.compare(a1[1], a2[1]);\\n    });\\n    // keep track of prices entry refs for easy removal\\n    Map<Integer, int[]> entries = new HashMap<>();\\n    \\n\\n    public StockPrice() {\\n    }\\n    \\n    // O(log n)\\n    public void update(int timestamp, int price) {\\n        // if time is later, or the same (hence we would update) as current time, \\n        // update current time vars O(1)\\n        if (timestamp >= currentTime) {\\n            this.currentPrice = price;\\n            this.currentTime = timestamp;\\n        }\\n        \\n        int[] entry = new int[]{price, timestamp};\\n        \\n        // need to remove old entry from prices if it is an update O(log n)\\n        if (entries.containsKey(timestamp)) {\\n            int[] oldEntry = entries.get(timestamp);\\n            prices.remove(oldEntry);\\n        }\\n        \\n        // add entry to prices O(log n)\\n        prices.add(entry);\\n        \\n        // add entry to map O(1)\\n        entries.put(timestamp, entry);        \\n    }\\n    \\n    public int current() {\\n        // O(1)\\n        return this.currentPrice;\\n    }\\n    \\n    public int maximum() {\\n        // O(1)\\n        return prices.last()[0];\\n    }\\n    \\n    public int minimum() {\\n        // O(1)\\n        return prices.first()[0];\\n    }\\n}\\n```\\n\\nThe tricky part was the entries had to be an int[] as otherwise TreeSet would not allow for duplicate entries, but a single price might occur multiple times during different timestamps. For the comparator function, we only return 0 if the two objects are the same (needed for the remove() method to work correctly), and after we compare by price, and only then by time if the prices are the same. \\n\\nThe current() method can be managed seperately - all we really need for that is two ints to keep track of the current price and the timestamp it was updated at - if update() is called with a timestamp that is greater than or equal to the current timestamp, we update the values.",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass StockPrice {\\n    \\n    int currentPrice = -1;\\n    int currentTime = -1;\\n    \\n    // entry of [a, b] where a is price and b is time\\n    TreeSet<int[]> prices = new TreeSet<>((a1, a2) -> {\\n        if (a1 == a2) {\\n            return 0;\\n        }\\n        return a1[0] != a2[0] ? Integer.compare(a1[0], a2[0]) : Integer.compare(a1[1], a2[1]);\\n    });\\n    // keep track of prices entry refs for easy removal\\n    Map<Integer, int[]> entries = new HashMap<>();\\n    \\n\\n    public StockPrice() {\\n    }\\n    \\n    // O(log n)\\n    public void update(int timestamp, int price) {\\n        // if time is later, or the same (hence we would update) as current time, \\n        // update current time vars O(1)\\n        if (timestamp >= currentTime) {\\n            this.currentPrice = price;\\n            this.currentTime = timestamp;\\n        }\\n        \\n        int[] entry = new int[]{price, timestamp};\\n        \\n        // need to remove old entry from prices if it is an update O(log n)\\n        if (entries.containsKey(timestamp)) {\\n            int[] oldEntry = entries.get(timestamp);\\n            prices.remove(oldEntry);\\n        }\\n        \\n        // add entry to prices O(log n)\\n        prices.add(entry);\\n        \\n        // add entry to map O(1)\\n        entries.put(timestamp, entry);        \\n    }\\n    \\n    public int current() {\\n        // O(1)\\n        return this.currentPrice;\\n    }\\n    \\n    public int maximum() {\\n        // O(1)\\n        return prices.last()[0];\\n    }\\n    \\n    public int minimum() {\\n        // O(1)\\n        return prices.first()[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795026,
                "title": "python-sortedlist-solution",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n      \\n      self.current_stamp = -1\\n      self.records = {}\\n      self.prices = SortedList()\\n      \\n      \\n    def update(self, timestamp: int, price: int) -> None:\\n      \\n        if timestamp in self.records:\\n          self.prices.remove(self.records[timestamp])\\n          \\n        self.records[timestamp] = price\\n        self.prices.add(price)\\n        self.current_stamp = max(self.current_stamp, timestamp)\\n\\n        \\n    def current(self) -> int:\\n        return self.records[self.current_stamp]\\n\\n    def maximum(self) -> int:\\n        return self.prices[-1]\\n\\n    def minimum(self) -> int:\\n        return self.prices[0]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n      \\n      self.current_stamp = -1\\n      self.records = {}\\n      self.prices = SortedList()\\n      \\n      \\n    def update(self, timestamp: int, price: int) -> None:\\n      \\n        if timestamp in self.records:\\n          self.prices.remove(self.records[timestamp])\\n          \\n        self.records[timestamp] = price\\n        self.prices.add(price)\\n        self.current_stamp = max(self.current_stamp, timestamp)\\n\\n        \\n    def current(self) -> int:\\n        return self.records[self.current_stamp]\\n\\n    def maximum(self) -> int:\\n        return self.prices[-1]\\n\\n    def minimum(self) -> int:\\n        return self.prices[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782496,
                "title": "javascript-95-faster-solution-2-heaps-and-a-map-commented-and-simple",
                "content": "Simple JavaScript solution using 2 heap backed priority queue [LC Supports out of the box]\\n\\nFor Update \\n\\n1) We update out max timestamp\\n2) We just upsert the value price at timestamp key\\n3) We then just insert timestamp at as price priority to minHeap and maxHeap\\n\\nFor Currrent\\n\\n1) Just return the value from map as maxTimestamp Key\\n\\nFor Max and Min\\n\\n1) We check the front of queue for price and timestamp\\n2) Get latest value of timestamp and see if its authentic\\n3) If not we discard it till its correct\\n4) return front\\'s priority\\n\\n```\\n\\nvar StockPrice = function() {\\n\\t// Initialize a Map\\n\\t// Should simply store [timestamp -> value]\\n    this.data = new Map()\\n\\t\\n\\t// Initialize Max Heap\\n\\t// Should simply store timestamp as value, and price as priority\\n    this.max = new MaxPriorityQueue()\\n\\t\\n\\t// Initialize Min Heap\\n\\t// Should simply store timestamp as value, and price as priority\\n    this.min = new MinPriorityQueue()\\n\\t\\n\\t// This is find maximum timestamp i.e. current stock price.\\n    this.currentTimestamp = -1\\n};\\n\\n/** \\n * @param {number} timestamp \\n * @param {number} price\\n * @return {void}\\n */\\nStockPrice.prototype.update = function(timestamp, price) {\\n\\t// Check if its a new timestamp or an update to older\\n    this.currentTimestamp = Math.max(this.currentTimestamp, timestamp)\\n    \\n\\t// Upsert [Insert or Update value] for price at timestamp\\n    this.data.set(timestamp, price)\\n    \\n\\t// insert timestamp to the queue with price is priority\\n    this.max.enqueue(timestamp, price)\\n    this.min.enqueue(timestamp, price)\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.current = function() {\\n\\t// get the data with max timestamp from map\\n    return this.data.get(this.currentTimestamp)\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.maximum = function() {\\n\\t// check the front of max queue\\n\\t// element -> timestamp\\n\\t// priority -> price\\n    let {element, priority} = this.max.front()\\n    \\n\\t// if priority [i.e. price] is not same latest value, discard it\\n    while (priority != this.data.get(element)) {\\n        this.max.dequeue()\\n        \\n        element = this.max.front().element\\n        priority = this.max.front().priority\\n    }\\n    \\n\\t// return price\\n    return priority\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.minimum = function() {\\n\\t// check the front of max queue\\n\\t// element -> timestamp\\n\\t// priority -> price\\n    let {element, priority} = this.min.front()\\n    \\n\\t// if priority [i.e. price] is not same latest value, discard it\\n    while (priority != this.data.get(element)) {\\n        this.min.dequeue()\\n        \\n        element = this.min.front().element\\n        priority = this.min.front().priority\\n    }\\n\\t\\n\\t// return price\\n    return priority\\n};\\n\\n/** \\n * Your StockPrice object will be instantiated and called as such:\\n * var obj = new StockPrice()\\n * obj.update(timestamp,price)\\n * var param_2 = obj.current()\\n * var param_3 = obj.maximum()\\n * var param_4 = obj.minimum()\\n */\\n```\\n\\nP.S. I am new at writing these discussions, feel free to let me if you have a feedback.\\n\\nReferences \\n\\nhttps://github.com/datastructures-js/priority-queue\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar StockPrice = function() {\\n\\t// Initialize a Map\\n\\t// Should simply store [timestamp -> value]\\n    this.data = new Map()\\n\\t\\n\\t// Initialize Max Heap\\n\\t// Should simply store timestamp as value, and price as priority\\n    this.max = new MaxPriorityQueue()\\n\\t\\n\\t// Initialize Min Heap\\n\\t// Should simply store timestamp as value, and price as priority\\n    this.min = new MinPriorityQueue()\\n\\t\\n\\t// This is find maximum timestamp i.e. current stock price.\\n    this.currentTimestamp = -1\\n};\\n\\n/** \\n * @param {number} timestamp \\n * @param {number} price\\n * @return {void}\\n */\\nStockPrice.prototype.update = function(timestamp, price) {\\n\\t// Check if its a new timestamp or an update to older\\n    this.currentTimestamp = Math.max(this.currentTimestamp, timestamp)\\n    \\n\\t// Upsert [Insert or Update value] for price at timestamp\\n    this.data.set(timestamp, price)\\n    \\n\\t// insert timestamp to the queue with price is priority\\n    this.max.enqueue(timestamp, price)\\n    this.min.enqueue(timestamp, price)\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.current = function() {\\n\\t// get the data with max timestamp from map\\n    return this.data.get(this.currentTimestamp)\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.maximum = function() {\\n\\t// check the front of max queue\\n\\t// element -> timestamp\\n\\t// priority -> price\\n    let {element, priority} = this.max.front()\\n    \\n\\t// if priority [i.e. price] is not same latest value, discard it\\n    while (priority != this.data.get(element)) {\\n        this.max.dequeue()\\n        \\n        element = this.max.front().element\\n        priority = this.max.front().priority\\n    }\\n    \\n\\t// return price\\n    return priority\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.minimum = function() {\\n\\t// check the front of max queue\\n\\t// element -> timestamp\\n\\t// priority -> price\\n    let {element, priority} = this.min.front()\\n    \\n\\t// if priority [i.e. price] is not same latest value, discard it\\n    while (priority != this.data.get(element)) {\\n        this.min.dequeue()\\n        \\n        element = this.min.front().element\\n        priority = this.min.front().priority\\n    }\\n\\t\\n\\t// return price\\n    return priority\\n};\\n\\n/** \\n * Your StockPrice object will be instantiated and called as such:\\n * var obj = new StockPrice()\\n * obj.update(timestamp,price)\\n * var param_2 = obj.current()\\n * var param_3 = obj.maximum()\\n * var param_4 = obj.minimum()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700253,
                "title": "python-heap-lazy-deletion",
                "content": "The questions requires an online algorithm for datastream. Therefore if we just use bruteforce and search for maximum and minimum values it will be very expensive. Heap will be a great data structure to keep track of minimum and maximum values.\\n\\nThe next challenge is to delete a value from a heap. This is not an easy task because the deletion will change the tree structure of our heap. Alternatively, we can create a hashset to mark those deleted timestamps. However, in this question timestamps are not unique which means we cannot dump timestamps into deleted hashset. Therefore we add another variable called \"index\" to mark those deleted values. Each time we call our \"update\" function, we increment index by 1.\\n\\nIn python the zeroth element of a heap is always the minimum value. To find maximum value we need to multiply by -1 when pushing them into the priorityqueue and multiply by -1 again after peeking them.\\n\\nTimeComplexity: O((n+k)logn + c ), where n is the maximum index (the number of times that we call update function) and k is the number of times that we call maximum and minimum values. c is the number that we call \"current fucntion\", each time we only need to check a hashtable, which is an O(1) operation so the total time complexity for current function will just be O(c).\\n\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.price={}\\n        self.deleted=set()\\n        self.index=0\\n        self.pq=[]\\n        self.curr_time=0\\n        self.neg_pq=[]\\n        \\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n\\t    ## if timestamp is in our hashmap, we need to mark the original index as deleted and then update our hashmap\\n        if timestamp in self.price:\\n            self.deleted.add(self.price[timestamp][1])\\n        self.price[timestamp]=(price,self.index)\\n\\t\\t## put a tuple into our heaps, index is used to check if this value is deleter or not\\n        heapq.heappush(self.pq,(price,self.index))\\n        heapq.heappush(self.neg_pq,(price*(-1),self.index))\\n\\t\\t## curr_time is the maximum timestamp\\n        self.curr_time=max(self.curr_time,timestamp)\\n        self.index+=1\\n        \\n\\n    def current(self) -> int:\\n        return self.price[self.curr_time][0]\\n\\n    def maximum(self) -> int:\\n        ## if our maximum has an index in deleted hashset, pop it\\n        while self.neg_pq and self.neg_pq[0][1] in self.deleted:\\n            heapq.heappop(self.neg_pq)\\n        return -self.neg_pq[0][0]\\n        \\n\\n    def minimum(self) -> int:\\n\\t## if our minimum has an index in deleted hashset, pop it\\n        while self.pq and self.pq[0][1] in self.deleted:\\n            heapq.heappop(self.pq)\\n        return self.pq[0][0]\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.price={}\\n        self.deleted=set()\\n        self.index=0\\n        self.pq=[]\\n        self.curr_time=0\\n        self.neg_pq=[]\\n        \\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n\\t    ## if timestamp is in our hashmap, we need to mark the original index as deleted and then update our hashmap\\n        if timestamp in self.price:\\n            self.deleted.add(self.price[timestamp][1])\\n        self.price[timestamp]=(price,self.index)\\n\\t\\t## put a tuple into our heaps, index is used to check if this value is deleter or not\\n        heapq.heappush(self.pq,(price,self.index))\\n        heapq.heappush(self.neg_pq,(price*(-1),self.index))\\n\\t\\t## curr_time is the maximum timestamp\\n        self.curr_time=max(self.curr_time,timestamp)\\n        self.index+=1\\n        \\n\\n    def current(self) -> int:\\n        return self.price[self.curr_time][0]\\n\\n    def maximum(self) -> int:\\n        ## if our maximum has an index in deleted hashset, pop it\\n        while self.neg_pq and self.neg_pq[0][1] in self.deleted:\\n            heapq.heappop(self.neg_pq)\\n        return -self.neg_pq[0][0]\\n        \\n\\n    def minimum(self) -> int:\\n\\t## if our minimum has an index in deleted hashset, pop it\\n        while self.pq and self.pq[0][1] in self.deleted:\\n            heapq.heappop(self.pq)\\n        return self.pq[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513303,
                "title": "java-2-heaps",
                "content": "```\\nclass StockPrice {\\n    private final HashMap<Integer, Integer> priceHistory;\\n    private final HashMap<Integer, Integer> priceFreq;\\n    private final PriorityQueue<Integer> minPrice;\\n    private final PriorityQueue<Integer> maxPrice;\\n    \\n    private int latestPrice;\\n    private int maxTimestamp;\\n    \\n\\n    public StockPrice() {\\n        priceHistory = new HashMap<>();\\n        priceFreq = new HashMap<>();\\n        minPrice = new PriorityQueue<>();\\n        maxPrice = new PriorityQueue<>(11, (a, b) -> b-a);\\n        maxTimestamp = -1;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        int previousPrice = priceHistory.getOrDefault(timestamp, -1);\\n        priceHistory.put(timestamp, price);\\n        \\n        if (timestamp >= maxTimestamp) {\\n            maxTimestamp = timestamp;\\n            latestPrice = price;\\n        }\\n        \\n        priceFreq.put(price, priceFreq.getOrDefault(price, 0) + 1);\\n        if (previousPrice >= 0) {\\n            priceFreq.put(previousPrice, Math.max(priceFreq.get(previousPrice) - 1, 0));\\n        }\\n        \\n        minPrice.offer(price);\\n        maxPrice.offer(price);\\n    }\\n    \\n    public int current() {\\n        return latestPrice;\\n    }\\n    \\n    public int maximum() {\\n        while (priceFreq.get(maxPrice.peek()) <= 0) {\\n            maxPrice.poll();\\n        }\\n        return maxPrice.peek();\\n    }\\n    \\n    public int minimum() {\\n        while (priceFreq.get(minPrice.peek()) <= 0) {\\n            minPrice.poll();\\n        }\\n        return minPrice.peek();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice {\\n    private final HashMap<Integer, Integer> priceHistory;\\n    private final HashMap<Integer, Integer> priceFreq;\\n    private final PriorityQueue<Integer> minPrice;\\n    private final PriorityQueue<Integer> maxPrice;\\n    \\n    private int latestPrice;\\n    private int maxTimestamp;\\n    \\n\\n    public StockPrice() {\\n        priceHistory = new HashMap<>();\\n        priceFreq = new HashMap<>();\\n        minPrice = new PriorityQueue<>();\\n        maxPrice = new PriorityQueue<>(11, (a, b) -> b-a);\\n        maxTimestamp = -1;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        int previousPrice = priceHistory.getOrDefault(timestamp, -1);\\n        priceHistory.put(timestamp, price);\\n        \\n        if (timestamp >= maxTimestamp) {\\n            maxTimestamp = timestamp;\\n            latestPrice = price;\\n        }\\n        \\n        priceFreq.put(price, priceFreq.getOrDefault(price, 0) + 1);\\n        if (previousPrice >= 0) {\\n            priceFreq.put(previousPrice, Math.max(priceFreq.get(previousPrice) - 1, 0));\\n        }\\n        \\n        minPrice.offer(price);\\n        maxPrice.offer(price);\\n    }\\n    \\n    public int current() {\\n        return latestPrice;\\n    }\\n    \\n    public int maximum() {\\n        while (priceFreq.get(maxPrice.peek()) <= 0) {\\n            maxPrice.poll();\\n        }\\n        return maxPrice.peek();\\n    }\\n    \\n    public int minimum() {\\n        while (priceFreq.get(minPrice.peek()) <= 0) {\\n            minPrice.poll();\\n        }\\n        return minPrice.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090397,
                "title": "solution-using-set-and-map-in-cpp",
                "content": "# Code\\n```\\nclass StockPrice {\\npublic:\\n\\nmultiset<int>maxi,mini;\\nunordered_map<int,int>m;\\nint latest=0;\\n\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        \\n        if(m[timestamp]!=0){\\n            maxi.erase(maxi.find(m[timestamp]));\\n            mini.erase(mini.find(m[timestamp]));\\n        }\\n\\n        maxi.insert(price);\\n        mini.insert(price);\\n        m[timestamp]=price;\\n        latest=max(latest,timestamp);\\n    }\\n    \\n    int current() {\\n        \\n        return m[latest];\\n    }\\n    \\n    int maximum() {\\n        \\n        return *maxi.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *mini.begin();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n\\nmultiset<int>maxi,mini;\\nunordered_map<int,int>m;\\nint latest=0;\\n\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        \\n        if(m[timestamp]!=0){\\n            maxi.erase(maxi.find(m[timestamp]));\\n            mini.erase(mini.find(m[timestamp]));\\n        }\\n\\n        maxi.insert(price);\\n        mini.insert(price);\\n        m[timestamp]=price;\\n        latest=max(latest,timestamp);\\n    }\\n    \\n    int current() {\\n        \\n        return m[latest];\\n    }\\n    \\n    int maximum() {\\n        \\n        return *maxi.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *mini.begin();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065349,
                "title": "easy-soln-adobe",
                "content": "# Please Upvote if you found the solution helpful\\uD83D\\uDE0A\\n**#ReviseWithArsh #6Companies30Days Challenge 2023 \\nChallenge Company 3 : Adobe\\nQ11. Stock Price Fluctuation**\\n\\n# Complexity\\n- Time complexity of the update function: O(1)\\n- Time complexity of the current function: O(logN)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\n//StockPrice class that keeps track of the current, minimum and maximum stock prices. It uses a minHeap and maxHeap to maintain the minimum and maximum prices respectively. It also uses a map to store the timestamp and corresponding price for each update.\\n\\nclass StockPrice {\\n    // Min heap to maintain minimum prices\\n    PriorityQueue<int[]> minHeap;\\n    // Max heap to maintain maximum prices\\n    PriorityQueue<int[]> maxHeap;\\n    // Map to store the timestamp and corresponding price for each update\\n    Map<Integer,Integer> map;\\n    // Variable to keep track of the last updated timestamp\\n    int lastTime = 0;\\n    public StockPrice() {\\n        // Initialize min heap with custom comparator\\n        minHeap = new PriorityQueue<int[]>( (a,b) ->  Integer.compare(a[1],b[1]));\\n        // Initialize max heap with custom comparator\\n        maxHeap = new PriorityQueue<int[]>( (a,b) ->  -Integer.compare(a[1],b[1]));\\n        // Initialize map\\n        map = new HashMap();\\n    }\\n    // Method to update the stock price\\n    public void update(int timestamp, int price) {\\n        // Update the lastTime variable with the latest timestamp\\n       lastTime = Math.max(timestamp, lastTime);\\n       // Add the timestamp and price to the map\\n       map.put(timestamp, price);\\n       // Add the timestamp and price to the min heap\\n       minHeap.add(new int[]{timestamp, price});\\n       // Add the timestamp and price to the max heap\\n       maxHeap.add(new int[]{timestamp, price});\\n    }\\n    // Method to get the current stock price\\n    public int current() {\\n        // Get the price corresponding to the last updated timestamp from the map\\n        return map.get(lastTime);\\n    }\\n    // Method to get the maximum stock price\\n    public int maximum() {\\n    // Poll the max heap until the value at the front of the heap corresponds to the value in the map\\n        while(map.get(maxHeap.peek()[0]) != maxHeap.peek()[1]){\\n            maxHeap.poll();\\n        }\\n        // Return the price at the front of the max heap\\n        return maxHeap.peek()[1];\\n    }\\n    // Method to get the minimum stock price\\n    public int minimum() {\\n        while(map.get(minHeap.peek()[0]) != minHeap.peek()[1]){\\n            minHeap.poll();\\n        }\\n        return minHeap.peek()[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//StockPrice class that keeps track of the current, minimum and maximum stock prices. It uses a minHeap and maxHeap to maintain the minimum and maximum prices respectively. It also uses a map to store the timestamp and corresponding price for each update.\\n\\nclass StockPrice {\\n    // Min heap to maintain minimum prices\\n    PriorityQueue<int[]> minHeap;\\n    // Max heap to maintain maximum prices\\n    PriorityQueue<int[]> maxHeap;\\n    // Map to store the timestamp and corresponding price for each update\\n    Map<Integer,Integer> map;\\n    // Variable to keep track of the last updated timestamp\\n    int lastTime = 0;\\n    public StockPrice() {\\n        // Initialize min heap with custom comparator\\n        minHeap = new PriorityQueue<int[]>( (a,b) ->  Integer.compare(a[1],b[1]));\\n        // Initialize max heap with custom comparator\\n        maxHeap = new PriorityQueue<int[]>( (a,b) ->  -Integer.compare(a[1],b[1]));\\n        // Initialize map\\n        map = new HashMap();\\n    }\\n    // Method to update the stock price\\n    public void update(int timestamp, int price) {\\n        // Update the lastTime variable with the latest timestamp\\n       lastTime = Math.max(timestamp, lastTime);\\n       // Add the timestamp and price to the map\\n       map.put(timestamp, price);\\n       // Add the timestamp and price to the min heap\\n       minHeap.add(new int[]{timestamp, price});\\n       // Add the timestamp and price to the max heap\\n       maxHeap.add(new int[]{timestamp, price});\\n    }\\n    // Method to get the current stock price\\n    public int current() {\\n        // Get the price corresponding to the last updated timestamp from the map\\n        return map.get(lastTime);\\n    }\\n    // Method to get the maximum stock price\\n    public int maximum() {\\n    // Poll the max heap until the value at the front of the heap corresponds to the value in the map\\n        while(map.get(maxHeap.peek()[0]) != maxHeap.peek()[1]){\\n            maxHeap.poll();\\n        }\\n        // Return the price at the front of the max heap\\n        return maxHeap.peek()[1];\\n    }\\n    // Method to get the minimum stock price\\n    public int minimum() {\\n        while(map.get(minHeap.peek()[0]) != minHeap.peek()[1]){\\n            minHeap.poll();\\n        }\\n        return minHeap.peek()[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668536,
                "title": "c-easy-to-understand-min-max-heap",
                "content": "1.  Use map for updation of price at given timestamp\\n2.  Use min-max heap to find out minimum and maximum price \\n3.  Maintain maxTime for current Price\\n4.  Use heap and map combination to remove those pairs where price has been updated.\\n\\n```\\n\\tunordered_map<int, int> mp;\\n    int maxTime = 0;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pqMin;\\n    priority_queue<pair<int, int>> pqMax;\\n    \\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        maxTime = max(timestamp, maxTime);\\n        mp[timestamp] = price;\\n        pqMin.push(make_pair(price, timestamp));\\n        pqMax.push(make_pair(price, timestamp));\\n    }\\n    \\n    int current() {\\n        return mp[maxTime];\\n    }\\n    \\n    int maximum() {\\n        while(pqMax.top().first != mp[pqMax.top().second])\\n            pqMax.pop();\\n        \\n        return pqMax.top().first;\\n    }\\n    \\n    int minimum() {\\n        while(pqMin.top().first != mp[pqMin.top().second])\\n            pqMin.pop();\\n        \\n        return pqMin.top().first;\\n    }",
                "solutionTags": [],
                "code": "1.  Use map for updation of price at given timestamp\\n2.  Use min-max heap to find out minimum and maximum price \\n3.  Maintain maxTime for current Price\\n4.  Use heap and map combination to remove those pairs where price has been updated.\\n\\n```\\n\\tunordered_map<int, int> mp;\\n    int maxTime = 0;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pqMin;\\n    priority_queue<pair<int, int>> pqMax;\\n    \\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        maxTime = max(timestamp, maxTime);\\n        mp[timestamp] = price;\\n        pqMin.push(make_pair(price, timestamp));\\n        pqMax.push(make_pair(price, timestamp));\\n    }\\n    \\n    int current() {\\n        return mp[maxTime];\\n    }\\n    \\n    int maximum() {\\n        while(pqMax.top().first != mp[pqMax.top().second])\\n            pqMax.pop();\\n        \\n        return pqMax.top().first;\\n    }\\n    \\n    int minimum() {\\n        while(pqMin.top().first != mp[pqMin.top().second])\\n            pqMin.pop();\\n        \\n        return pqMin.top().first;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2667566,
                "title": "using-min-max-heap-c-simple-solution",
                "content": "```\\nclass StockPrice\\n{\\npublic:\\n    unordered_map<int, int> map;\\n    priority_queue<pair<int, int>> PQ;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> PQ_MIN;\\n\\n    int currentPrice = 0;\\n    int currentTime = 0;\\n\\n    StockPrice() {}\\n    void update(int timestamp, int price)\\n    {\\n\\n        map[timestamp] = price;\\n\\n        PQ.push({price, timestamp});\\n        PQ_MIN.push({price, timestamp});\\n\\n        // updating the current\\n        if (timestamp >= currentTime)\\n        {\\n            currentTime = timestamp;\\n            currentPrice = price;\\n        }\\n        // updating the max\\n        while (map[PQ.top().second] != PQ.top().first)\\n        {\\n            PQ.pop();\\n        }\\n        // updating the min\\n        while (map[PQ_MIN.top().second] != PQ_MIN.top().first)\\n        {\\n            PQ_MIN.pop();\\n        }\\n    }\\n    int current()\\n    {\\n        return currentPrice;\\n    }\\n\\n    int maximum()\\n    {\\n        return PQ.top().first;\\n    }\\n\\n    int minimum()\\n    {\\n        return PQ_MIN.top().first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice\\n{\\npublic:\\n    unordered_map<int, int> map;\\n    priority_queue<pair<int, int>> PQ;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> PQ_MIN;\\n\\n    int currentPrice = 0;\\n    int currentTime = 0;\\n\\n    StockPrice() {}\\n    void update(int timestamp, int price)\\n    {\\n\\n        map[timestamp] = price;\\n\\n        PQ.push({price, timestamp});\\n        PQ_MIN.push({price, timestamp});\\n\\n        // updating the current\\n        if (timestamp >= currentTime)\\n        {\\n            currentTime = timestamp;\\n            currentPrice = price;\\n        }\\n        // updating the max\\n        while (map[PQ.top().second] != PQ.top().first)\\n        {\\n            PQ.pop();\\n        }\\n        // updating the min\\n        while (map[PQ_MIN.top().second] != PQ_MIN.top().first)\\n        {\\n            PQ_MIN.pop();\\n        }\\n    }\\n    int current()\\n    {\\n        return currentPrice;\\n    }\\n\\n    int maximum()\\n    {\\n        return PQ.top().first;\\n    }\\n\\n    int minimum()\\n    {\\n        return PQ_MIN.top().first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622710,
                "title": "c-easy-to-understand-short",
                "content": "```\\nclass StockPrice {\\npublic:\\n    map<int,int> timeStampToValue;\\n    multiset<int> values;\\n    StockPrice() {\\n        timeStampToValue.clear();\\n        values.clear();\\n    }\\n    void update(int timestamp, int price) {\\n        if (timeStampToValue.find(timestamp)!=timeStampToValue.end()){\\n            int prevValue = timeStampToValue[timestamp];\\n            values.erase(values.find(prevValue));\\n            values.insert(price);\\n            timeStampToValue[timestamp] = price;\\n        }\\n        else{\\n            values.insert(price);\\n            timeStampToValue[timestamp] = price;\\n        }\\n        \\n    }\\n    int current() {\\n        return (timeStampToValue.rbegin()) -> second;\\n    }\\n    \\n    int maximum() {\\n        return *(values.rbegin());\\n    }\\n    \\n    int minimum() {\\n        return *(values.begin());\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    map<int,int> timeStampToValue;\\n    multiset<int> values;\\n    StockPrice() {\\n        timeStampToValue.clear();\\n        values.clear();\\n    }\\n    void update(int timestamp, int price) {\\n        if (timeStampToValue.find(timestamp)!=timeStampToValue.end()){\\n            int prevValue = timeStampToValue[timestamp];\\n            values.erase(values.find(prevValue));\\n            values.insert(price);\\n            timeStampToValue[timestamp] = price;\\n        }\\n        else{\\n            values.insert(price);\\n            timeStampToValue[timestamp] = price;\\n        }\\n        \\n    }\\n    int current() {\\n        return (timeStampToValue.rbegin()) -> second;\\n    }\\n    \\n    int maximum() {\\n        return *(values.rbegin());\\n    }\\n    \\n    int minimum() {\\n        return *(values.begin());\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2460317,
                "title": "java-hashmap-treeset-99-faster",
                "content": "<---//**VoteUp if you like the solution**\\n```\\nclass node implements Comparable<node>{\\n    int val;\\n    int time;\\n    \\n    public int compareTo(node n){\\n        if(this.val != n.val)\\n            return (this.val-n.val);\\n        \\n        return this.time-n.time;\\n    }\\n}\\n\\nclass StockPrice {\\n\\n    int maxTime;\\n    HashMap<Integer, node> hm;\\n    TreeSet<node> set;\\n    public StockPrice() {\\n        hm = new HashMap<>();\\n        set = new TreeSet<node>();//(a,b)->(a.val-b.val));\\n        maxTime = -1;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(hm.containsKey(timestamp)){\\n            set.remove(hm.get(timestamp));\\n        }\\n            node n = new node();\\n            n.val = price;\\n            n.time = timestamp;\\n            hm.put(timestamp, n);\\n            set.add(n);\\n        if(maxTime < timestamp)\\n            maxTime = timestamp;\\n    }\\n    \\n    public int current() {\\n        return hm.get(maxTime).val;\\n    }\\n    \\n    public int maximum() {\\n       return set.last().val;\\n    }\\n    \\n    public int minimum() {\\n       return set.first().val;   \\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass node implements Comparable<node>{\\n    int val;\\n    int time;\\n    \\n    public int compareTo(node n){\\n        if(this.val != n.val)\\n            return (this.val-n.val);\\n        \\n        return this.time-n.time;\\n    }\\n}\\n\\nclass StockPrice {\\n\\n    int maxTime;\\n    HashMap<Integer, node> hm;\\n    TreeSet<node> set;\\n    public StockPrice() {\\n        hm = new HashMap<>();\\n        set = new TreeSet<node>();//(a,b)->(a.val-b.val));\\n        maxTime = -1;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(hm.containsKey(timestamp)){\\n            set.remove(hm.get(timestamp));\\n        }\\n            node n = new node();\\n            n.val = price;\\n            n.time = timestamp;\\n            hm.put(timestamp, n);\\n            set.add(n);\\n        if(maxTime < timestamp)\\n            maxTime = timestamp;\\n    }\\n    \\n    public int current() {\\n        return hm.get(maxTime).val;\\n    }\\n    \\n    public int maximum() {\\n       return set.last().val;\\n    }\\n    \\n    public int minimum() {\\n       return set.first().val;   \\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173692,
                "title": "c-priority-queue",
                "content": "```\\nclass MaxHeap : IComparer<int>\\n{\\n    public int Compare(int x, int y)\\n    {\\n        if (x > y)\\n        {\\n            return -1;\\n        }\\n\\n        if (x < y)\\n        {\\n            return 1;\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\npublic class StockPrice {\\n\\n    private readonly Dictionary<int, int> _prices = new();\\n    private readonly PriorityQueue<int, int> _maxHeap = new(new MaxHeap());\\n    private readonly PriorityQueue<int, int> _minHeap = new();\\n    private int _currentTime;\\n\\n    public void Update(int timestamp, int price) {\\n        _currentTime = Math.Max(_currentTime, timestamp);\\n        _maxHeap.Enqueue(timestamp, price);\\n        _minHeap.Enqueue(timestamp, price);\\n        _prices[timestamp] = price;\\n    }\\n\\n    public int Current() {\\n        return _prices[_currentTime];\\n    }\\n\\n    public int Maximum() {\\n        var dequeued = _maxHeap.TryDequeue(out var timestamp, out var price);\\n        while (dequeued && price != _prices[timestamp])\\n        {\\n            dequeued = _maxHeap.TryDequeue(out timestamp,  out price);\\n        }\\n\\n        if (dequeued)\\n        {\\n            _maxHeap.Enqueue(timestamp, price);\\n        }\\n        return price;\\n    }\\n\\n    public int Minimum() {\\n        var dequeued = _minHeap.TryDequeue(out var timestamp, out var price);\\n        while (dequeued && price != _prices[timestamp])\\n        {\\n            dequeued = _minHeap.TryDequeue(out timestamp,  out price);\\n        }\\n\\n        if (dequeued)\\n        {\\n            _minHeap.Enqueue(timestamp, price);\\n\\n        }\\n        return price;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MaxHeap : IComparer<int>\\n{\\n    public int Compare(int x, int y)\\n    {\\n        if (x > y)\\n        {\\n            return -1;\\n        }\\n\\n        if (x < y)\\n        {\\n            return 1;\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\npublic class StockPrice {\\n\\n    private readonly Dictionary<int, int> _prices = new();\\n    private readonly PriorityQueue<int, int> _maxHeap = new(new MaxHeap());\\n    private readonly PriorityQueue<int, int> _minHeap = new();\\n    private int _currentTime;\\n\\n    public void Update(int timestamp, int price) {\\n        _currentTime = Math.Max(_currentTime, timestamp);\\n        _maxHeap.Enqueue(timestamp, price);\\n        _minHeap.Enqueue(timestamp, price);\\n        _prices[timestamp] = price;\\n    }\\n\\n    public int Current() {\\n        return _prices[_currentTime];\\n    }\\n\\n    public int Maximum() {\\n        var dequeued = _maxHeap.TryDequeue(out var timestamp, out var price);\\n        while (dequeued && price != _prices[timestamp])\\n        {\\n            dequeued = _maxHeap.TryDequeue(out timestamp,  out price);\\n        }\\n\\n        if (dequeued)\\n        {\\n            _maxHeap.Enqueue(timestamp, price);\\n        }\\n        return price;\\n    }\\n\\n    public int Minimum() {\\n        var dequeued = _minHeap.TryDequeue(out var timestamp, out var price);\\n        while (dequeued && price != _prices[timestamp])\\n        {\\n            dequeued = _minHeap.TryDequeue(out timestamp,  out price);\\n        }\\n\\n        if (dequeued)\\n        {\\n            _minHeap.Enqueue(timestamp, price);\\n\\n        }\\n        return price;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986361,
                "title": "java-treemap-easy-to-understand",
                "content": "Use treemap as it helps maintaing the order of the keys in O(logN) time complexity. \\nmaintain two treemap:\\n**first map**: timestamp to price tree map\\n**second map**: price to count tree map\\n\\n**update logic**:\\nWhenever a stock price is updated, check if the price exists given the input timestamp.\\nIf it exists, decrement the count in the second map. If the count is 0, remove this price. Then put the timestamp to price entry in the first map.\\nIf it does not exists, update the entry in both maps accordingly.\\n\\n**how to get current price?**\\nit\\'s the last entry value of the first map.\\n\\n**how to get max price?**\\nit\\'s the last key of the second map.\\n\\n**how to get min price?**\\nit\\'s the first key of the second map.\\n\\ncode:\\n```\\nclass StockPrice {\\n    TreeMap<Integer, Integer> timestampToPrices = new TreeMap<Integer, Integer>();\\n    TreeMap<Integer, Integer> priceCounts = new TreeMap<Integer, Integer>();\\n\\n    public StockPrice() {\\n        timestampToPrices = new TreeMap<Integer, Integer>();\\n        priceCounts = new TreeMap<Integer, Integer>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestampToPrices.containsKey(timestamp)) {\\n            int oldPrice = timestampToPrices.get(timestamp);\\n            priceCounts.put(oldPrice, priceCounts.get(oldPrice)-1);\\n            if(priceCounts.get(oldPrice) == 0) {\\n                priceCounts.remove(oldPrice);\\n            }\\n        }\\n        \\n        timestampToPrices.put(timestamp, price);\\n        priceCounts.put(price, priceCounts.getOrDefault(price, 0)+1);\\n    }\\n    \\n    public int current() {\\n        return timestampToPrices.lastEntry().getValue();\\n    }\\n    \\n    public int maximum() {\\n        return priceCounts.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return priceCounts.firstKey();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass StockPrice {\\n    TreeMap<Integer, Integer> timestampToPrices = new TreeMap<Integer, Integer>();\\n    TreeMap<Integer, Integer> priceCounts = new TreeMap<Integer, Integer>();\\n\\n    public StockPrice() {\\n        timestampToPrices = new TreeMap<Integer, Integer>();\\n        priceCounts = new TreeMap<Integer, Integer>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestampToPrices.containsKey(timestamp)) {\\n            int oldPrice = timestampToPrices.get(timestamp);\\n            priceCounts.put(oldPrice, priceCounts.get(oldPrice)-1);\\n            if(priceCounts.get(oldPrice) == 0) {\\n                priceCounts.remove(oldPrice);\\n            }\\n        }\\n        \\n        timestampToPrices.put(timestamp, price);\\n        priceCounts.put(price, priceCounts.getOrDefault(price, 0)+1);\\n    }\\n    \\n    public int current() {\\n        return timestampToPrices.lastEntry().getValue();\\n    }\\n    \\n    public int maximum() {\\n        return priceCounts.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return priceCounts.firstKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962912,
                "title": "python3-using-min-and-max-heap-beats-99-39",
                "content": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.stockPrices = {}\\n        self.minHeap = []\\n        self.maxHeap = []\\n        self.cleanMin = defaultdict(int)\\n        self.cleanMax = defaultdict(int)\\n        self.currts = 0\\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        # if this is an update of old price then record\\n        # the value that will be replaced with current \\n        # value\\n        #\\n        evicted = None\\n        if timestamp in self.stockPrices:\\n            evicted = self.stockPrices[timestamp]\\n        \\n        # now update the price and push them to the heap\\n        self.stockPrices[timestamp] = price\\n        heapq.heappush(self.minHeap, price)\\n        heapq.heappush(self.maxHeap, -price)\\n        \\n        # now mark the evicted value as to be pruned at\\n        # later time, when they float at the top of the\\n        # heap.\\n        #\\n        if evicted:\\n            self.cleanMin[evicted] += 1\\n            self.cleanMax[evicted] += 1\\n        \\n        \\n        # clean the minHeap        \\n        curHeapMin = self.minHeap[0]\\n        while curHeapMin in self.cleanMin:\\n            heapq.heappop(self.minHeap)\\n            self.cleanMin[curHeapMin] -= 1\\n            if self.cleanMin[curHeapMin] == 0: del self.cleanMin[curHeapMin]\\n            curHeapMin = self.minHeap[0]\\n        \\n        # clean the maxHeap\\n        curHeapMax = -self.maxHeap[0]\\n        while curHeapMax in self.cleanMax:\\n            heapq.heappop(self.maxHeap)\\n            self.cleanMax[curHeapMax] -= 1\\n            if self.cleanMax[curHeapMax] == 0: del self.cleanMax[curHeapMax]\\n            curHeapMax = -self.maxHeap[0]\\n        \\n        # update current time\\n        if timestamp > self.currts: self.currts = timestamp\\n\\n            \\n    def current(self) -> int:\\n        return self.stockPrices[self.currts]\\n\\n    \\n    def maximum(self) -> int:\\n        return -self.maxHeap[0]\\n\\n    \\n    def minimum(self) -> int:\\n        return self.minHeap[0]\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.stockPrices = {}\\n        self.minHeap = []\\n        self.maxHeap = []\\n        self.cleanMin = defaultdict(int)\\n        self.cleanMax = defaultdict(int)\\n        self.currts = 0\\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        # if this is an update of old price then record\\n        # the value that will be replaced with current \\n        # value\\n        #\\n        evicted = None\\n        if timestamp in self.stockPrices:\\n            evicted = self.stockPrices[timestamp]\\n        \\n        # now update the price and push them to the heap\\n        self.stockPrices[timestamp] = price\\n        heapq.heappush(self.minHeap, price)\\n        heapq.heappush(self.maxHeap, -price)\\n        \\n        # now mark the evicted value as to be pruned at\\n        # later time, when they float at the top of the\\n        # heap.\\n        #\\n        if evicted:\\n            self.cleanMin[evicted] += 1\\n            self.cleanMax[evicted] += 1\\n        \\n        \\n        # clean the minHeap        \\n        curHeapMin = self.minHeap[0]\\n        while curHeapMin in self.cleanMin:\\n            heapq.heappop(self.minHeap)\\n            self.cleanMin[curHeapMin] -= 1\\n            if self.cleanMin[curHeapMin] == 0: del self.cleanMin[curHeapMin]\\n            curHeapMin = self.minHeap[0]\\n        \\n        # clean the maxHeap\\n        curHeapMax = -self.maxHeap[0]\\n        while curHeapMax in self.cleanMax:\\n            heapq.heappop(self.maxHeap)\\n            self.cleanMax[curHeapMax] -= 1\\n            if self.cleanMax[curHeapMax] == 0: del self.cleanMax[curHeapMax]\\n            curHeapMax = -self.maxHeap[0]\\n        \\n        # update current time\\n        if timestamp > self.currts: self.currts = timestamp\\n\\n            \\n    def current(self) -> int:\\n        return self.stockPrices[self.currts]\\n\\n    \\n    def maximum(self) -> int:\\n        return -self.maxHeap[0]\\n\\n    \\n    def minimum(self) -> int:\\n        return self.minHeap[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837916,
                "title": "java-simple-hashmap-treemap-explanation",
                "content": "I used two maps: a hashmap for mapping timestamps to prices, and treemap for mapping prices to number of occurrences. The main idea is that whenever we receive a tiimestamp that already exists, we get the old price from the hashmap and then we remove the occurrence from the treemap. Since it\\'s a treemap, prices are sorted and I return the first and the last as the max and min. \\n    \\nTime Complexity: O(log N) for update, maximum and minimum, and O(1) for current.\\nSpace Complexity: O(N)\\n\\n```\\nclass StockPrice {\\n    Map<Integer, Integer> timestamps = new HashMap<>();\\n    TreeMap<Integer, Integer> priceCounts = new TreeMap<>();\\n    int latestTimestamp = -1;\\n    \\n    public void update(int timestamp, int price) {\\n        latestTimestamp = Math.max(timestamp, latestTimestamp);\\n        if (timestamps.containsKey(timestamp)) {\\n            int oldPrice = timestamps.get(timestamp);\\n            if (priceCounts.get(oldPrice) > 1) {\\n                priceCounts.put(oldPrice, priceCounts.get(oldPrice) - 1);\\n            }\\n            else {\\n                priceCounts.remove(oldPrice);\\n            }\\n        }\\n        priceCounts.put(price, priceCounts.getOrDefault(price, 0) + 1);\\n        timestamps.put(timestamp, price);\\n    }\\n    \\n    public int current() {\\n        return timestamps.get(latestTimestamp);        \\n    }\\n    \\n    public int maximum() {\\n        return priceCounts.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return priceCounts.firstKey();        \\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "I used two maps: a hashmap for mapping timestamps to prices, and treemap for mapping prices to number of occurrences. The main idea is that whenever we receive a tiimestamp that already exists, we get the old price from the hashmap and then we remove the occurrence from the treemap. Since it\\'s a treemap, prices are sorted and I return the first and the last as the max and min. \\n    \\nTime Complexity: O(log N) for update, maximum and minimum, and O(1) for current.\\nSpace Complexity: O(N)\\n\\n```\\nclass StockPrice {\\n    Map<Integer, Integer> timestamps = new HashMap<>();\\n    TreeMap<Integer, Integer> priceCounts = new TreeMap<>();\\n    int latestTimestamp = -1;\\n    \\n    public void update(int timestamp, int price) {\\n        latestTimestamp = Math.max(timestamp, latestTimestamp);\\n        if (timestamps.containsKey(timestamp)) {\\n            int oldPrice = timestamps.get(timestamp);\\n            if (priceCounts.get(oldPrice) > 1) {\\n                priceCounts.put(oldPrice, priceCounts.get(oldPrice) - 1);\\n            }\\n            else {\\n                priceCounts.remove(oldPrice);\\n            }\\n        }\\n        priceCounts.put(price, priceCounts.getOrDefault(price, 0) + 1);\\n        timestamps.put(timestamp, price);\\n    }\\n    \\n    public int current() {\\n        return timestamps.get(latestTimestamp);        \\n    }\\n    \\n    public int maximum() {\\n        return priceCounts.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return priceCounts.firstKey();        \\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1777268,
                "title": "c-solution",
                "content": "```\\nclass StockPrice {\\npublic:\\n    StockPrice() {\\n        latestTime = 0;\\n        currentValue = 0;\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        // if we have newer or the same latest timestamp, update the current one\\n        if (timestamp >= latestTime) {\\n            latestTime = timestamp;\\n            currentValue = price;\\n        }\\n        // if we have new time key, insert it\\n        if (timeLine.find(timestamp) == timeLine.end()) {\\n            timeLine[timestamp] = price;\\n        } else {\\n            // otherwise remove the previous key and value and insert the new one\\n            int oldPrice = timeLine[timestamp];\\n            timeLine[timestamp] = price;\\n            frequency[oldPrice]--;\\n            if (frequency[oldPrice] == 0) {\\n                frequency.erase(oldPrice);\\n            }\\n        }\\n        frequency[price]++;\\n    }\\n    \\n    int current() {\\n        return currentValue;\\n    }\\n    \\n    int maximum() {\\n        return prev(frequency.end())->first;\\n    }\\n    \\n    int minimum() {\\n        return frequency.begin()->first;\\n    }\\n    \\nprivate:\\n    // latestTime record the most recent time stamp\\n    // currentValue record the most recent value\\n    int latestTime;\\n    int currentValue;\\n    unordered_map<int, int> timeLine;\\n    map<int, int> frequency;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    StockPrice() {\\n        latestTime = 0;\\n        currentValue = 0;\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        // if we have newer or the same latest timestamp, update the current one\\n        if (timestamp >= latestTime) {\\n            latestTime = timestamp;\\n            currentValue = price;\\n        }\\n        // if we have new time key, insert it\\n        if (timeLine.find(timestamp) == timeLine.end()) {\\n            timeLine[timestamp] = price;\\n        } else {\\n            // otherwise remove the previous key and value and insert the new one\\n            int oldPrice = timeLine[timestamp];\\n            timeLine[timestamp] = price;\\n            frequency[oldPrice]--;\\n            if (frequency[oldPrice] == 0) {\\n                frequency.erase(oldPrice);\\n            }\\n        }\\n        frequency[price]++;\\n    }\\n    \\n    int current() {\\n        return currentValue;\\n    }\\n    \\n    int maximum() {\\n        return prev(frequency.end())->first;\\n    }\\n    \\n    int minimum() {\\n        return frequency.begin()->first;\\n    }\\n    \\nprivate:\\n    // latestTime record the most recent time stamp\\n    // currentValue record the most recent value\\n    int latestTime;\\n    int currentValue;\\n    unordered_map<int, int> timeLine;\\n    map<int, int> frequency;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772193,
                "title": "c-map",
                "content": "```\\nclass StockPrice {\\npublic:\\n    unordered_map<int,int>mp;\\n    map<int,int>count;\\n    int t;\\n    StockPrice() \\n    {\\n        t=0;\\n    }\\n    \\n    void update(int time, int price) \\n    {\\n        if(mp.find(time)==mp.end())\\n        {\\n            mp[time]=price;\\n            count[price]++;\\n        }\\n        else\\n        {\\n            int old=mp[time];\\n            count[old]--;\\n            count[price]++;\\n            mp[time]=price;\\n            if(count[old]==0)\\n                count.erase(old);\\n        }\\n        if(time>t)\\n            t=time;\\n    }\\n    \\n    int current() \\n    {\\n        return mp[t];\\n    }\\n    \\n    int maximum() \\n    {\\n        auto it=count.rbegin();\\n        return it->first;\\n    }\\n    \\n    int minimum() \\n    {\\n        auto it=count.begin();\\n        return it->first;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    unordered_map<int,int>mp;\\n    map<int,int>count;\\n    int t;\\n    StockPrice() \\n    {\\n        t=0;\\n    }\\n    \\n    void update(int time, int price) \\n    {\\n        if(mp.find(time)==mp.end())\\n        {\\n            mp[time]=price;\\n            count[price]++;\\n        }\\n        else\\n        {\\n            int old=mp[time];\\n            count[old]--;\\n            count[price]++;\\n            mp[time]=price;\\n            if(count[old]==0)\\n                count.erase(old);\\n        }\\n        if(time>t)\\n            t=time;\\n    }\\n    \\n    int current() \\n    {\\n        return mp[t];\\n    }\\n    \\n    int maximum() \\n    {\\n        auto it=count.rbegin();\\n        return it->first;\\n    }\\n    \\n    int minimum() \\n    {\\n        auto it=count.begin();\\n        return it->first;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761421,
                "title": "java-heap-and-map-solution-beats-95",
                "content": "```\\nclass StockPrice {\\n    \\n    class Entry{\\n        int price;\\n        int timestamp;\\n        \\n        public Entry(int p, int t){\\n            price = p;\\n            timestamp = t;\\n        }\\n    }\\n    \\n    private int latesTime = 0;\\n    private PriorityQueue<Entry> maxHeap = new PriorityQueue<>((a,b) -> Integer.compare(b.price, a.price));\\n    private PriorityQueue<Entry> minHeap = new PriorityQueue<>((a,b) -> Integer.compare(a.price, b.price));;\\n    private Map<Integer, Integer> map = new HashMap<>();\\n\\n    public StockPrice() {\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp > latesTime){\\n            latesTime = timestamp;\\n        }\\n        map.put(timestamp, price);\\n        maxHeap.offer(new Entry(price, timestamp));\\n        minHeap.offer(new Entry(price, timestamp));\\n    }\\n    \\n    public int current() {\\n        return map.get(latesTime);\\n    }\\n    \\n    public int maximum() {\\n        return head(maxHeap);\\n    }\\n    \\n    public int minimum() {\\n        return head(minHeap);\\n    }\\n    \\n    private int head(PriorityQueue<Entry> pq){\\n        while(!pq.isEmpty()){\\n            Entry e = pq.peek();\\n            if(map.get(e.timestamp) != e.price)\\n                pq.poll();\\n            else \\n                return e.price;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice {\\n    \\n    class Entry{\\n        int price;\\n        int timestamp;\\n        \\n        public Entry(int p, int t){\\n            price = p;\\n            timestamp = t;\\n        }\\n    }\\n    \\n    private int latesTime = 0;\\n    private PriorityQueue<Entry> maxHeap = new PriorityQueue<>((a,b) -> Integer.compare(b.price, a.price));\\n    private PriorityQueue<Entry> minHeap = new PriorityQueue<>((a,b) -> Integer.compare(a.price, b.price));;\\n    private Map<Integer, Integer> map = new HashMap<>();\\n\\n    public StockPrice() {\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp > latesTime){\\n            latesTime = timestamp;\\n        }\\n        map.put(timestamp, price);\\n        maxHeap.offer(new Entry(price, timestamp));\\n        minHeap.offer(new Entry(price, timestamp));\\n    }\\n    \\n    public int current() {\\n        return map.get(latesTime);\\n    }\\n    \\n    public int maximum() {\\n        return head(maxHeap);\\n    }\\n    \\n    public int minimum() {\\n        return head(minHeap);\\n    }\\n    \\n    private int head(PriorityQueue<Entry> pq){\\n        while(!pq.isEmpty()){\\n            Entry e = pq.peek();\\n            if(map.get(e.timestamp) != e.price)\\n                pq.poll();\\n            else \\n                return e.price;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720920,
                "title": "c-using-min-and-max-heap",
                "content": "```\\nclass StockPrice {\\npublic:\\n    unordered_map<int,int> rem;\\n    \\n    priority_queue<pair<int,int>> pq_max;\\n    \\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq_min;\\n    \\n    int curr;\\n    \\n    StockPrice() {\\n        curr = 0;    \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        \\n        curr = max(curr,timestamp);\\n        \\n        rem[timestamp] = price;\\n        \\n        pq_max.push({price,timestamp});\\n        pq_min.push({price,timestamp});\\n        \\n    }\\n    \\n    int current() {\\n        \\n        return rem[curr];\\n    }\\n    \\n    int maximum() {\\n        \\n        pair<int,int> temp;\\n        \\n        while(!pq_max.empty()) {\\n            temp = pq_max.top();\\n            if(rem[temp.second] == temp.first)\\n                return temp.first;\\n            \\n            else\\n                pq_max.pop();\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    int minimum() {\\n        \\n        pair<int,int> temp;\\n        \\n        while(!pq_min.empty()) {\\n            temp = pq_min.top();\\n            if(rem[temp.second] == temp.first)\\n                return temp.first;\\n            \\n            else\\n                pq_min.pop();\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    unordered_map<int,int> rem;\\n    \\n    priority_queue<pair<int,int>> pq_max;\\n    \\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq_min;\\n    \\n    int curr;\\n    \\n    StockPrice() {\\n        curr = 0;    \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        \\n        curr = max(curr,timestamp);\\n        \\n        rem[timestamp] = price;\\n        \\n        pq_max.push({price,timestamp});\\n        pq_min.push({price,timestamp});\\n        \\n    }\\n    \\n    int current() {\\n        \\n        return rem[curr];\\n    }\\n    \\n    int maximum() {\\n        \\n        pair<int,int> temp;\\n        \\n        while(!pq_max.empty()) {\\n            temp = pq_max.top();\\n            if(rem[temp.second] == temp.first)\\n                return temp.first;\\n            \\n            else\\n                pq_max.pop();\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    int minimum() {\\n        \\n        pair<int,int> temp;\\n        \\n        while(!pq_min.empty()) {\\n            temp = pq_min.top();\\n            if(rem[temp.second] == temp.first)\\n                return temp.first;\\n            \\n            else\\n                pq_min.pop();\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665822,
                "title": "java-solution-with-hashmap-and-treemap-and-maxtime",
                "content": "```\\nclass StockPrice {\\n    int maxTime;\\n    HashMap<Integer, Integer> timeToPrices;\\n    TreeMap<Integer, Integer> pricesToCount;\\n    public StockPrice() {\\n        timeToPrices = new HashMap<>();\\n        pricesToCount = new TreeMap<>();\\n        maxTime = -1;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timeToPrices.containsKey(timestamp))\\n        {\\n            int curprice = timeToPrices.get(timestamp);\\n            int cnt = pricesToCount.get(curprice);\\n            if(cnt>1)\\n            {\\n                pricesToCount.put(curprice, cnt-1);\\n            }\\n            else\\n            {\\n                pricesToCount.remove(curprice);\\n            }\\n        }\\n        \\n        timeToPrices.put(timestamp, price);\\n        pricesToCount.put(price, pricesToCount.getOrDefault(price, 0)+1);\\n        maxTime = Math.max(maxTime, timestamp);\\n    }\\n    \\n    public int current() {\\n        return timeToPrices.get(maxTime);\\n    }\\n    \\n    public int maximum() {\\n        return pricesToCount.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return pricesToCount.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n    int maxTime;\\n    HashMap<Integer, Integer> timeToPrices;\\n    TreeMap<Integer, Integer> pricesToCount;\\n    public StockPrice() {\\n        timeToPrices = new HashMap<>();\\n        pricesToCount = new TreeMap<>();\\n        maxTime = -1;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timeToPrices.containsKey(timestamp))\\n        {\\n            int curprice = timeToPrices.get(timestamp);\\n            int cnt = pricesToCount.get(curprice);\\n            if(cnt>1)\\n            {\\n                pricesToCount.put(curprice, cnt-1);\\n            }\\n            else\\n            {\\n                pricesToCount.remove(curprice);\\n            }\\n        }\\n        \\n        timeToPrices.put(timestamp, price);\\n        pricesToCount.put(price, pricesToCount.getOrDefault(price, 0)+1);\\n        maxTime = Math.max(maxTime, timestamp);\\n    }\\n    \\n    public int current() {\\n        return timeToPrices.get(maxTime);\\n    }\\n    \\n    public int maximum() {\\n        return pricesToCount.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return pricesToCount.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609423,
                "title": "c-hashmap-multiset-o-nlog-n",
                "content": "```\\nclass StockPrice {\\npublic:\\n    \\n    int price;\\n    multiset<int> m;\\n    map<int, int> value;\\n    int mx;\\n    \\n    StockPrice() {\\n        price = 0;\\n        mx = 0;\\n    }\\n    \\n    void update(int timestamp, int p) {\\n        price = p;\\n        if ( value[timestamp] ) {\\n            m.erase ( m.find(value[timestamp]) );\\n        }\\n        \\n        m.insert ( price );\\n        value[timestamp] = price;\\n        mx = max (mx, timestamp);\\n    }\\n    \\n    int current() {\\n        return value[mx];\\n    }\\n    \\n    int maximum() {\\n        return *m.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *m.begin();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    \\n    int price;\\n    multiset<int> m;\\n    map<int, int> value;\\n    int mx;\\n    \\n    StockPrice() {\\n        price = 0;\\n        mx = 0;\\n    }\\n    \\n    void update(int timestamp, int p) {\\n        price = p;\\n        if ( value[timestamp] ) {\\n            m.erase ( m.find(value[timestamp]) );\\n        }\\n        \\n        m.insert ( price );\\n        value[timestamp] = price;\\n        mx = max (mx, timestamp);\\n    }\\n    \\n    int current() {\\n        return value[mx];\\n    }\\n    \\n    int maximum() {\\n        return *m.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *m.begin();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569223,
                "title": "python-double-priorityqueue-solution",
                "content": "If you don\\'t like fancy structures like sortedmap / treemap, refer to this solution. \\n\\nWould love to hear any suggestion that can avoid duplicating the queue. \\n\\n```\\nclass StockPrice:\\n    \\n    def __init__(self):\\n        self.max_price = []\\n        self.min_price = []\\n        self.prices = dict()\\n        self.latest_time = 0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.latest_time = max(self.latest_time, timestamp)\\n        self.prices[timestamp] = price\\n        heapq.heappush(self.min_price, (price, timestamp))\\n        heapq.heappush(self.max_price, (-price, timestamp))\\n        \\n\\n    def current(self) -> int:\\n        return self.prices[self.latest_time]\\n        \\n\\n    def maximum(self) -> int:\\n        current_max, timestamp = self.max_price[0]\\n        # price needs to invert\\n        if self.prices[timestamp] != -current_max:\\n            heapq.heappop(self.max_price)\\n            heapq.heappush(self.max_price, (-self.prices[timestamp], timestamp))\\n            return self.maximum()\\n        \\n        return -current_max\\n        \\n\\n    def minimum(self) -> int:\\n        current_min, timestamp = self.min_price[0] \\n        if self.prices[timestamp] != current_min:\\n            heapq.heappop(self.min_price)\\n            heapq.heappush(self.min_price, (self.prices[timestamp], timestamp))\\n            return self.minimum()\\n        \\n        return current_min\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice:\\n    \\n    def __init__(self):\\n        self.max_price = []\\n        self.min_price = []\\n        self.prices = dict()\\n        self.latest_time = 0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.latest_time = max(self.latest_time, timestamp)\\n        self.prices[timestamp] = price\\n        heapq.heappush(self.min_price, (price, timestamp))\\n        heapq.heappush(self.max_price, (-price, timestamp))\\n        \\n\\n    def current(self) -> int:\\n        return self.prices[self.latest_time]\\n        \\n\\n    def maximum(self) -> int:\\n        current_max, timestamp = self.max_price[0]\\n        # price needs to invert\\n        if self.prices[timestamp] != -current_max:\\n            heapq.heappop(self.max_price)\\n            heapq.heappush(self.max_price, (-self.prices[timestamp], timestamp))\\n            return self.maximum()\\n        \\n        return -current_max\\n        \\n\\n    def minimum(self) -> int:\\n        current_min, timestamp = self.min_price[0] \\n        if self.prices[timestamp] != current_min:\\n            heapq.heappop(self.min_price)\\n            heapq.heappush(self.min_price, (self.prices[timestamp], timestamp))\\n            return self.minimum()\\n        \\n        return current_min\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530963,
                "title": "easy-python-solution-using-sortedlist",
                "content": "from sortedcontainers import SortedList\\nclass StockPrice:\\n\\n    def __init__(self):\\n        \\n        self.dict={}\\n        self.maxkey=-1\\n        self.sortlist=SortedList([])\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.dict:\\n            self.sortlist.remove(self.dict[timestamp])\\n            \\n        self.dict[timestamp]=price\\n        self.maxkey=max(timestamp,self.maxkey)\\n        \\n        self.sortlist.add(price)\\n        \\n    def current(self) -> int:\\n        return self.dict[self.maxkey]\\n\\n    def maximum(self) -> int:\\n        return self.sortlist[-1]\\n\\n    def minimum(self) -> int:\\n        return self.sortlist[0]\\n\\t\\n#Please Upvote",
                "solutionTags": [
                    "Python3"
                ],
                "code": "from sortedcontainers import SortedList\\nclass StockPrice:\\n\\n    def __init__(self):\\n        \\n        self.dict={}\\n        self.maxkey=-1\\n        self.sortlist=SortedList([])\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.dict:\\n            self.sortlist.remove(self.dict[timestamp])\\n            \\n        self.dict[timestamp]=price\\n        self.maxkey=max(timestamp,self.maxkey)\\n        \\n        self.sortlist.add(price)\\n        \\n    def current(self) -> int:\\n        return self.dict[self.maxkey]\\n\\n    def maximum(self) -> int:\\n        return self.sortlist[-1]\\n\\n    def minimum(self) -> int:\\n        return self.sortlist[0]\\n\\t\\n#Please Upvote",
                "codeTag": "Java"
            },
            {
                "id": 1518836,
                "title": "python-use-your-resoureces-sorteddict-solution",
                "content": "```\\nimport heapq\\nfrom sortedcontainers import SortedDict\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self._priceSortedDict = SortedDict()\\n        self._timestampToPrice = {}\\n        self._latestTimestamp = float(\\'-inf\\')\\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        oldPrice = None\\n        if timestamp in self._timestampToPrice:\\n            oldPrice = self._timestampToPrice[timestamp]\\n        \\n        if oldPrice:\\n            self._priceSortedDict[oldPrice] -= 1\\n            if self._priceSortedDict[oldPrice] == 0:\\n                del self._priceSortedDict[oldPrice]\\n        \\n        if price in self._priceSortedDict:\\n            self._priceSortedDict[price] += 1\\n        else:\\n            self._priceSortedDict[price] = 1\\n        \\n        self._timestampToPrice[timestamp] = price\\n        self._latestTimestamp = max(timestamp, self._latestTimestamp)\\n\\n    def current(self) -> int:\\n        return self._timestampToPrice[self._latestTimestamp]\\n\\n    def maximum(self) -> int:\\n        return self._priceSortedDict.keys()[-1]\\n\\n    def minimum(self) -> int:\\n        return self._priceSortedDict.keys()[0]\\n",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nfrom sortedcontainers import SortedDict\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self._priceSortedDict = SortedDict()\\n        self._timestampToPrice = {}\\n        self._latestTimestamp = float(\\'-inf\\')\\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        oldPrice = None\\n        if timestamp in self._timestampToPrice:\\n            oldPrice = self._timestampToPrice[timestamp]\\n        \\n        if oldPrice:\\n            self._priceSortedDict[oldPrice] -= 1\\n            if self._priceSortedDict[oldPrice] == 0:\\n                del self._priceSortedDict[oldPrice]\\n        \\n        if price in self._priceSortedDict:\\n            self._priceSortedDict[price] += 1\\n        else:\\n            self._priceSortedDict[price] = 1\\n        \\n        self._timestampToPrice[timestamp] = price\\n        self._latestTimestamp = max(timestamp, self._latestTimestamp)\\n\\n    def current(self) -> int:\\n        return self._timestampToPrice[self._latestTimestamp]\\n\\n    def maximum(self) -> int:\\n        return self._priceSortedDict.keys()[-1]\\n\\n    def minimum(self) -> int:\\n        return self._priceSortedDict.keys()[0]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1514299,
                "title": "python-max-and-min-heap-hashmap-simple-solution-with-explanation",
                "content": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.stocks = {}\\n        self.currentTimestamp = 0\\n        self.maximumPrice = []\\n        self.minimumPrice = []\\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        # Update price of the stock at timestamp \\n        self.stocks[timestamp] = price\\n        \\n        # Update currentTimestamp\\n        self.currentTimestamp = max(self.currentTimestamp, timestamp)\\n        \\n        # Update maximumPrice heap\\n        heapq.heappush(self.maximumPrice, [-price, timestamp])\\n        \\n        # Update minimumPrice heap\\n        heapq.heappush(self.minimumPrice, [price, timestamp])\\n        \\n\\n    def current(self) -> int:\\n        return self.stocks[self.currentTimestamp]\\n        \\n\\n    def maximum(self) -> int:\\n        # If the price from the maximumPrice doesn\\'t match the price the stocks for that timestamp then it means the price for that timestamp has been updated. So pop from maximumPrice till we find a matching price.\\n        maxPrice, timestamp = heapq.heappop(self.maximumPrice)\\n        while -maxPrice != self.stocks[timestamp]:\\n            maxPrice, timestamp = heapq.heappop(self.maximumPrice)\\n        \\n        heapq.heappush(self.maximumPrice, [maxPrice, timestamp])\\n        return -maxPrice\\n        \\n\\n    def minimum(self) -> int:\\n        # If the price from the minimumPrice doesn\\'t match the price the stocks for that timestamp then it means the price for that timestamp has been updated. So pop from minimumPrice till we find a matching price.\\n        minPrice, timestamp = heapq.heappop(self.minimumPrice)\\n        while minPrice != self.stocks[timestamp]:\\n            minPrice, timestamp = heapq.heappop(self.minimumPrice)\\n        \\n        heapq.heappush(self.minimumPrice, [minPrice, timestamp])\\n        return minPrice\\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.stocks = {}\\n        self.currentTimestamp = 0\\n        self.maximumPrice = []\\n        self.minimumPrice = []\\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        # Update price of the stock at timestamp \\n        self.stocks[timestamp] = price\\n        \\n        # Update currentTimestamp\\n        self.currentTimestamp = max(self.currentTimestamp, timestamp)\\n        \\n        # Update maximumPrice heap\\n        heapq.heappush(self.maximumPrice, [-price, timestamp])\\n        \\n        # Update minimumPrice heap\\n        heapq.heappush(self.minimumPrice, [price, timestamp])\\n        \\n\\n    def current(self) -> int:\\n        return self.stocks[self.currentTimestamp]\\n        \\n\\n    def maximum(self) -> int:\\n        # If the price from the maximumPrice doesn\\'t match the price the stocks for that timestamp then it means the price for that timestamp has been updated. So pop from maximumPrice till we find a matching price.\\n        maxPrice, timestamp = heapq.heappop(self.maximumPrice)\\n        while -maxPrice != self.stocks[timestamp]:\\n            maxPrice, timestamp = heapq.heappop(self.maximumPrice)\\n        \\n        heapq.heappush(self.maximumPrice, [maxPrice, timestamp])\\n        return -maxPrice\\n        \\n\\n    def minimum(self) -> int:\\n        # If the price from the minimumPrice doesn\\'t match the price the stocks for that timestamp then it means the price for that timestamp has been updated. So pop from minimumPrice till we find a matching price.\\n        minPrice, timestamp = heapq.heappop(self.minimumPrice)\\n        while minPrice != self.stocks[timestamp]:\\n            minPrice, timestamp = heapq.heappop(self.minimumPrice)\\n        \\n        heapq.heappush(self.minimumPrice, [minPrice, timestamp])\\n        return minPrice\\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513564,
                "title": "leetcode-diff-doesn-t-work",
                "content": "13/17 test case have passed. There is no diff between the expected output and program output but it shows wrong answer.  I couldn\\'t post the test case as it is too big.\\n\\n```\\nclass StockPrice {\\npublic:\\n    map<int, int> stock;\\n    map<int, set<int>> valueMap;\\n    \\n    StockPrice() {\\n        stock.clear();\\n        valueMap.clear();\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if ( stock.find(timestamp) == stock.end()){\\n            valueMap[price] = {timestamp};\\n        }else{\\n            int oldPrice = stock[timestamp];\\n            if(oldPrice==price) return;\\n            valueMap[oldPrice].erase(timestamp);\\n            if ( valueMap[oldPrice].empty()){\\n                valueMap.erase(oldPrice);\\n            }\\n            if (valueMap.find(price) == valueMap.end()){\\n                valueMap[price] = {timestamp};\\n            }else{\\n                valueMap[price].insert(timestamp);\\n            }\\n                   \\n        }\\n        stock[timestamp] = price;\\n        \\n    }\\n    \\n    int current() {\\n        return (stock.rbegin()->second);\\n    }\\n    \\n    int maximum() {\\n        return (valueMap.rbegin()->first);\\n    }\\n    \\n    int minimum() {\\n        return (valueMap.begin()->first);\\n    }\\n};\\n\\n```\\nTest case - \\n",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    map<int, int> stock;\\n    map<int, set<int>> valueMap;\\n    \\n    StockPrice() {\\n        stock.clear();\\n        valueMap.clear();\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if ( stock.find(timestamp) == stock.end()){\\n            valueMap[price] = {timestamp};\\n        }else{\\n            int oldPrice = stock[timestamp];\\n            if(oldPrice==price) return;\\n            valueMap[oldPrice].erase(timestamp);\\n            if ( valueMap[oldPrice].empty()){\\n                valueMap.erase(oldPrice);\\n            }\\n            if (valueMap.find(price) == valueMap.end()){\\n                valueMap[price] = {timestamp};\\n            }else{\\n                valueMap[price].insert(timestamp);\\n            }\\n                   \\n        }\\n        stock[timestamp] = price;\\n        \\n    }\\n    \\n    int current() {\\n        return (stock.rbegin()->second);\\n    }\\n    \\n    int maximum() {\\n        return (valueMap.rbegin()->first);\\n    }\\n    \\n    int minimum() {\\n        return (valueMap.begin()->first);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513407,
                "title": "java-treemap",
                "content": "```\\nclass StockPrice {\\n\\n    TreeMap<Integer, Integer> current;\\n    TreeMap<Integer, Set<Integer>> priceToTime;\\n    public StockPrice() {\\n        current = new TreeMap<Integer, Integer>();\\n        priceToTime = new TreeMap<Integer, Set<Integer>>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (current.containsKey(timestamp)) {\\n            int seenPrice = current.get(timestamp);\\n            if (priceToTime.get(seenPrice).size() == 1) {\\n                priceToTime.remove(seenPrice);\\n            } else {\\n                Set<Integer> seen = priceToTime.get(seenPrice);\\n                seen.remove(timestamp);\\n                priceToTime.put(seenPrice, seen);  \\n            }\\n        }\\n        current.put(timestamp, price);\\n        priceToTime.computeIfAbsent(price, l -> new HashSet<>()).add(timestamp);\\n    }\\n    \\n    public int current() {\\n        Integer key = current.lastKey();\\n        return current.get(key);\\n    }\\n    \\n    public int maximum() {\\n        Integer price = priceToTime.lastKey();\\n        return price;\\n    }\\n    \\n    public int minimum() {\\n        Integer price = priceToTime.firstKey();\\n        return price;\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass StockPrice {\\n\\n    TreeMap<Integer, Integer> current;\\n    TreeMap<Integer, Set<Integer>> priceToTime;\\n    public StockPrice() {\\n        current = new TreeMap<Integer, Integer>();\\n        priceToTime = new TreeMap<Integer, Set<Integer>>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (current.containsKey(timestamp)) {\\n            int seenPrice = current.get(timestamp);\\n            if (priceToTime.get(seenPrice).size() == 1) {\\n                priceToTime.remove(seenPrice);\\n            } else {\\n                Set<Integer> seen = priceToTime.get(seenPrice);\\n                seen.remove(timestamp);\\n                priceToTime.put(seenPrice, seen);  \\n            }\\n        }\\n        current.put(timestamp, price);\\n        priceToTime.computeIfAbsent(price, l -> new HashSet<>()).add(timestamp);\\n    }\\n    \\n    public int current() {\\n        Integer key = current.lastKey();\\n        return current.get(key);\\n    }\\n    \\n    public int maximum() {\\n        Integer price = priceToTime.lastKey();\\n        return price;\\n    }\\n    \\n    public int minimum() {\\n        Integer price = priceToTime.firstKey();\\n        return price;\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513325,
                "title": "simple-java-solution-treemap",
                "content": "1. Keep two maps\\n            One hashmap from <TimeStamp, price>\\n            One TreeMap from <Price, Set{TimeStamp}>, in which all timestamps this price has been seen before. It becomes easier to update.\\n 2. On each update,\\n            1. If new timestamp, straightforward, update hashMap<timestamp, price> and TreeMap<Price, Set{TimeStamp}>.\\n            2. If previously seen timestamp, fetch previous price of this timestamp from hashmap into variable \\'p\\'. For this previous price \\'p\\' update TreeMap, by removing current timestamp from the set. If the set becomes empty remove the \\'p\\' from the TreeMap.\\n  3. For Min, return the firstKey in TreeMap. (since all prices are kept sorted in the TreeMap).\\n  4. For Max, return lastKey of the TreeMap.\\n   5. For Current, keep a track of lastest timestamp seen so far and its price.\\n\\n\\nclass StockPrice {\\n    \\n    int[] latest;\\n    TreeMap<Integer, Set<Integer>> map;\\n    Map<Integer, Integer> ts;\\n    public StockPrice() {\\n        map=new TreeMap();\\n        ts=new HashMap();\\n        latest=new int[2];\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(!ts.containsKey(timestamp)){\\n            ts.put(timestamp, price);\\n            if(!map.containsKey(price))\\n                map.put(price, new HashSet());\\n            map.get(price).add(timestamp);\\n        }else{\\n            int p=ts.get(timestamp);\\n            ts.put(timestamp, price);\\n            map.get(p).remove(timestamp);\\n            if(map.get(p).size()==0)\\n                map.remove(p);\\n            \\n            \\n            if(!map.containsKey(price))\\n                map.put(price, new HashSet());\\n            map.get(price).add(timestamp);            \\n        }\\n        if(latest[0]<=timestamp){\\n            latest[0]=timestamp;\\n            latest[1]=price;\\n        }\\n    }\\n    \\n    public int current() {\\n        return latest[1];\\n    }\\n    \\n    public int maximum() {\\n        return map.lastKey();\\n    }\\n    \\n    public int minimum() {\\n         return map.firstKey();\\n    }\\n}\\n\\t\\t\\n\\t\\t\\n        Cheers!",
                "solutionTags": [],
                "code": "1. Keep two maps\\n            One hashmap from <TimeStamp, price>\\n            One TreeMap from <Price, Set{TimeStamp}>, in which all timestamps this price has been seen before. It becomes easier to update.\\n 2. On each update,\\n            1. If new timestamp, straightforward, update hashMap<timestamp, price> and TreeMap<Price, Set{TimeStamp}>.\\n            2. If previously seen timestamp, fetch previous price of this timestamp from hashmap into variable \\'p\\'. For this previous price \\'p\\' update TreeMap, by removing current timestamp from the set. If the set becomes empty remove the \\'p\\' from the TreeMap.\\n  3. For Min, return the firstKey in TreeMap. (since all prices are kept sorted in the TreeMap).\\n  4. For Max, return lastKey of the TreeMap.\\n   5. For Current, keep a track of lastest timestamp seen so far and its price.\\n\\n\\nclass StockPrice {\\n    \\n    int[] latest;\\n    TreeMap<Integer, Set<Integer>> map;\\n    Map<Integer, Integer> ts;\\n    public StockPrice() {\\n        map=new TreeMap();\\n        ts=new HashMap();\\n        latest=new int[2];\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(!ts.containsKey(timestamp)){\\n            ts.put(timestamp, price);\\n            if(!map.containsKey(price))\\n                map.put(price, new HashSet());\\n            map.get(price).add(timestamp);\\n        }else{\\n            int p=ts.get(timestamp);\\n            ts.put(timestamp, price);\\n            map.get(p).remove(timestamp);\\n            if(map.get(p).size()==0)\\n                map.remove(p);\\n            \\n            \\n            if(!map.containsKey(price))\\n                map.put(price, new HashSet());\\n            map.get(price).add(timestamp);            \\n        }\\n        if(latest[0]<=timestamp){\\n            latest[0]=timestamp;\\n            latest[1]=price;\\n        }\\n    }\\n    \\n    public int current() {\\n        return latest[1];\\n    }\\n    \\n    public int maximum() {\\n        return map.lastKey();\\n    }\\n    \\n    public int minimum() {\\n         return map.firstKey();\\n    }\\n}\\n\\t\\t\\n\\t\\t\\n        Cheers!",
                "codeTag": "Java"
            },
            {
                "id": 1513320,
                "title": "minheap-and-maxheap-python-simple-approach-explanation-with-comments",
                "content": "**Description**\\nThe idea is to store utilize minHeap and maxHeap for keeping tracking of the prices. And, then skip the values which become invalid after latest update to find min or max price.\\n\\n**Code**\\n\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.priceInfo = dict()\\n        self.minHeap = []\\n        self.maxHeap = []\\n        self.latestTimestamp = None \\n        \\n    def update(self, timestamp: int, price: int) -> None:\\n        \\n        self.priceInfo[timestamp] = price\\n        \\n        heapq.heappush(self.maxHeap, [-price, timestamp]) # note we\\'re doing -price to simulate maxHeap in python\\n        heapq.heappush(self.minHeap, [price, timestamp])\\n        \\n        if self.latestTimestamp is None or timestamp>self.latestTimestamp:\\n            self.latestTimestamp = timestamp\\n\\n    def current(self) -> int:\\n        return self.priceInfo[self.latestTimestamp]\\n\\n    def maximum(self) -> int:\\n        price, timestamp = self.maxHeap[0]\\n        price = abs(price)\\n        \\n        # cleaning the invalid values from heap\\n        while self.priceInfo[timestamp] != price:\\n            heapq.heappop(self.maxHeap)\\n            price, timestamp = self.maxHeap[0]\\n            price = abs(price)\\n        \\n        return price\\n    \\n    def minimum(self) -> int:\\n        price, timestamp = self.minHeap[0]\\n        \\n        # cleaning the invalid values from heap\\n        while self.priceInfo[timestamp] != price:\\n            heapq.heappop(self.minHeap)\\n            price, timestamp = self.minHeap[0]\\n        \\n        return price\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.priceInfo = dict()\\n        self.minHeap = []\\n        self.maxHeap = []\\n        self.latestTimestamp = None \\n        \\n    def update(self, timestamp: int, price: int) -> None:\\n        \\n        self.priceInfo[timestamp] = price\\n        \\n        heapq.heappush(self.maxHeap, [-price, timestamp]) # note we\\'re doing -price to simulate maxHeap in python\\n        heapq.heappush(self.minHeap, [price, timestamp])\\n        \\n        if self.latestTimestamp is None or timestamp>self.latestTimestamp:\\n            self.latestTimestamp = timestamp\\n\\n    def current(self) -> int:\\n        return self.priceInfo[self.latestTimestamp]\\n\\n    def maximum(self) -> int:\\n        price, timestamp = self.maxHeap[0]\\n        price = abs(price)\\n        \\n        # cleaning the invalid values from heap\\n        while self.priceInfo[timestamp] != price:\\n            heapq.heappop(self.maxHeap)\\n            price, timestamp = self.maxHeap[0]\\n            price = abs(price)\\n        \\n        return price\\n    \\n    def minimum(self) -> int:\\n        price, timestamp = self.minHeap[0]\\n        \\n        # cleaning the invalid values from heap\\n        while self.priceInfo[timestamp] != price:\\n            heapq.heappop(self.minHeap)\\n            price, timestamp = self.minHeap[0]\\n        \\n        return price\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513308,
                "title": "c-solution-using-multiset",
                "content": "```\\nclass StockPrice {\\npublic:\\n    map<long long,long long >mp;\\n    multiset<long long>s;\\n    \\n    StockPrice() \\n    {\\n        mp.clear();\\n        s.clear();\\n    }\\n    void update(int timestamp, int price) \\n    {\\n        if(mp.find(timestamp)!=mp.end())\\n        {\\n           long long  val=mp[timestamp];\\n            s.erase(s.find(val));\\n        }\\n        mp[timestamp]=price;\\n        s.insert(price);\\n    }\\n    \\n    int current() \\n    {\\n        auto it=*mp.rbegin();\\n        return it.second;\\n    }\\n    \\n    int maximum() \\n    {\\n        return *s.rbegin();\\n    }\\n    \\n    int minimum() {\\n        // auto it=*mp.begin();\\n        return *s.begin();\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    map<long long,long long >mp;\\n    multiset<long long>s;\\n    \\n    StockPrice() \\n    {\\n        mp.clear();\\n        s.clear();\\n    }\\n    void update(int timestamp, int price) \\n    {\\n        if(mp.find(timestamp)!=mp.end())\\n        {\\n           long long  val=mp[timestamp];\\n            s.erase(s.find(val));\\n        }\\n        mp[timestamp]=price;\\n        s.insert(price);\\n    }\\n    \\n    int current() \\n    {\\n        auto it=*mp.rbegin();\\n        return it.second;\\n    }\\n    \\n    int maximum() \\n    {\\n        return *s.rbegin();\\n    }\\n    \\n    int minimum() {\\n        // auto it=*mp.begin();\\n        return *s.begin();\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562739,
                "title": "simple-c-solution-using-two-maps",
                "content": "# Code\\n```\\nclass StockPrice {\\npublic:\\n    map<int,int> value;     // price,count\\n    map<int,int> timeStock; // timestamp,price\\n    StockPrice() {\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        auto it = timeStock.find(timestamp);\\n        if(it != timeStock.end()){\\n            int price = it->second;\\n            value[price]--;\\n            if(value[price]==0) value.erase(price);\\n        }\\n        timeStock[timestamp]=price;\\n        value[price]++;\\n    }\\n    \\n    int current() {\\n        auto it = timeStock.end();\\n        it--;\\n        return it->second;\\n    }\\n    \\n    int maximum() {\\n        auto it = value.end();\\n        it--;\\n        return it->first;\\n    }\\n    \\n    int minimum() {\\n        auto it = value.begin();\\n        return it->first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    map<int,int> value;     // price,count\\n    map<int,int> timeStock; // timestamp,price\\n    StockPrice() {\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        auto it = timeStock.find(timestamp);\\n        if(it != timeStock.end()){\\n            int price = it->second;\\n            value[price]--;\\n            if(value[price]==0) value.erase(price);\\n        }\\n        timeStock[timestamp]=price;\\n        value[price]++;\\n    }\\n    \\n    int current() {\\n        auto it = timeStock.end();\\n        it--;\\n        return it->second;\\n    }\\n    \\n    int maximum() {\\n        auto it = value.end();\\n        it--;\\n        return it->first;\\n    }\\n    \\n    int minimum() {\\n        auto it = value.begin();\\n        return it->first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190791,
                "title": "c-solution-hashmap-orderedset",
                "content": "```\\nclass StockPrice {\\npublic:\\n    set<pair<int,int>> s;  //{price ,-time}\\n    map<int,int> map; // -time : price\\n    \\n    StockPrice() {}\\n    \\n    void update(int time, int price) {\\n        if(map.find(-time)!= map.end()){\\n            s.erase({map[-time],-time});\\n        }\\n        map[-time]= price;\\n        s.insert({price,-time});\\n    }\\n    \\n    \\n    int current() {\\n        return map.begin()->second ;\\n    }\\n    \\n    \\n    int maximum() {\\n        return s.rbegin()->first;\\n    }\\n    \\n    \\n    int minimum() {\\n        return s.begin()->first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    set<pair<int,int>> s;  //{price ,-time}\\n    map<int,int> map; // -time : price\\n    \\n    StockPrice() {}\\n    \\n    void update(int time, int price) {\\n        if(map.find(-time)!= map.end()){\\n            s.erase({map[-time],-time});\\n        }\\n        map[-time]= price;\\n        s.insert({price,-time});\\n    }\\n    \\n    \\n    int current() {\\n        return map.begin()->second ;\\n    }\\n    \\n    \\n    int maximum() {\\n        return s.rbegin()->first;\\n    }\\n    \\n    \\n    int minimum() {\\n        return s.begin()->first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044211,
                "title": "using-sorted-list-update-in-o-n",
                "content": "# Approach\\n### Initialisation\\n1. On the time of initialization of the object (constructor function), we would initialise a dictionary `records` which would hold the timestamps as keys and prices as values.\\n2. We would also initialise a variable `latesttimestamp` which would hold the maximum timestamp, which would help fetching the current price from dictionary. Initially, we set it to `None`.\\n3. Lastly, we would initialise a SortedList object (from sorted containers module) which would store the prices in a sorted order. We would call it `prices`. Since it is a SortedList object, it would always keep the list of `prices` sorted, and insertion and removal of new values (when there is an update in the price of an existing timestamp) is an O(log N) operation where N is the length of the list. \\n\\n*(Note that the insertion time is O(log N), but insertion is done in a list fashion in python so, eventually finding the insertion point is O(log N) and insertion is O(N)).*\\n\\n### Update\\n\\n1. While updating, we check if the `timestamp` is alread in the `record`. If it is already in the `record`, then we fetch the `price` of the `timestamp` from the `record` and remove it from the sorted list `prices`, because the price is now to be updated with another price. \\n2. We update the new `timestamp: price` in the `record` dictionary, and also add the new `price` to the sorted list `prices`.\\n3. We check if the `latesttimestamp` is `None`. If so, then we update `latesttimestamp` to the new `timestamp`. If not so, then we assign the maximum of `timestamp` and `latesttimestamp` to it.\\n\\n### Get Current, Maximum and Minimum Price\\n\\n1. **Current Price:** We can get the current price by fetching the value of `latesttimestamp` in `records` and return it.\\n2. **Maximum Price:** We fetch and return the last element of the sorted list `prices`.\\n3. **Minimum Price:** We fetch and return the first element of the sorted list `prices`.\\n\\n# Complexity\\n- Time complexity:\\nUpdate: O(N)\\nCurrent Price: O(1)\\nMaximum Price: O(1)\\nMinimum Price: O(1)\\n\\n# Code\\n```python\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.records = dict()\\n        self.latesttimestamp = None\\n        from sortedcontainers import SortedList\\n        self.prices = SortedList()\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.records:\\n            self.prices.remove(self.records[timestamp])\\n        self.records[timestamp] = price\\n        self.prices.add(price)\\n        if self.latesttimestamp is None:\\n            self.latesttimestamp  = timestamp\\n        else:\\n            self.latesttimestamp = max(self.latesttimestamp, timestamp)\\n\\n    def current(self) -> int:\\n        return self.records[self.latesttimestamp] \\n\\n    def maximum(self) -> int:\\n        return self.prices[~0]\\n\\n    def minimum(self) -> int:\\n        return self.prices[0]\\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.records = dict()\\n        self.latesttimestamp = None\\n        from sortedcontainers import SortedList\\n        self.prices = SortedList()\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.records:\\n            self.prices.remove(self.records[timestamp])\\n        self.records[timestamp] = price\\n        self.prices.add(price)\\n        if self.latesttimestamp is None:\\n            self.latesttimestamp  = timestamp\\n        else:\\n            self.latesttimestamp = max(self.latesttimestamp, timestamp)\\n\\n    def current(self) -> int:\\n        return self.records[self.latesttimestamp] \\n\\n    def maximum(self) -> int:\\n        return self.prices[~0]\\n\\n    def minimum(self) -> int:\\n        return self.prices[0]\\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039393,
                "title": "c-solution-using-maps-multiset",
                "content": "## Code\\n```\\nclass StockPrice {\\npublic:\\n    map<int,int> mp;\\n    multiset<int> mset;\\n    //priority_queue<int> maxheap;\\n    //priority_queue<int,vector<int>,greater<int>> minheap;\\n    int time=0; int curr=0;\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if (timestamp>=time){curr= price; time=timestamp;}\\n        if (mp.find(timestamp)== mp.end()){\\n            mp.insert({timestamp,price});\\n            mset.insert(price);\\n        }\\n        else{\\n            auto it= mset.find(mp[timestamp]);\\n            mset.erase(it);\\n            mp[timestamp]= price;\\n            mset.insert(price);\\n        }\\n\\n    }\\n    \\n    int current() {\\n        return curr;\\n    }\\n    \\n    int maximum() {\\n        //return maxheap.top();\\n        return *(mset.rbegin());\\n    }\\n    \\n    int minimum() {\\n        //return minheap.top();\\n        return *(mset.begin());\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Counting",
                    "Ordered Set"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    map<int,int> mp;\\n    multiset<int> mset;\\n    //priority_queue<int> maxheap;\\n    //priority_queue<int,vector<int>,greater<int>> minheap;\\n    int time=0; int curr=0;\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if (timestamp>=time){curr= price; time=timestamp;}\\n        if (mp.find(timestamp)== mp.end()){\\n            mp.insert({timestamp,price});\\n            mset.insert(price);\\n        }\\n        else{\\n            auto it= mset.find(mp[timestamp]);\\n            mset.erase(it);\\n            mp[timestamp]= price;\\n            mset.insert(price);\\n        }\\n\\n    }\\n    \\n    int current() {\\n        return curr;\\n    }\\n    \\n    int maximum() {\\n        //return maxheap.top();\\n        return *(mset.rbegin());\\n    }\\n    \\n    int minimum() {\\n        //return minheap.top();\\n        return *(mset.begin());\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652819,
                "title": "python-3-min-heap-and-max-heap",
                "content": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.price = 0\\n        self.max_heap = []\\n        self.min_heap = []\\n        self.prices = defaultdict(list)\\n        self.latest_time = float(\\'-inf\\')\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.prices[timestamp] = price\\n        self.latest_time = max(self.latest_time, timestamp)\\n        heapq.heappush(self.max_heap, (-price, timestamp))\\n        heapq.heappush(self.min_heap, (price, timestamp))\\n        \\n        \\n        # print(\"updating price of {} at time {}\".format(timestamp, price))\\n\\n    def current(self) -> int:\\n        # print(\"current price: {}\".format(self.prices[self.latest_time]))\\n        return self.prices[self.latest_time]\\n\\n    def maximum(self) -> int:\\n        # print(\"max price: {}\".format(self.prices[self.max_index]))\\n        p, t = self.max_heap[0]\\n        while -p != self.prices[t]:\\n            heappop(self.max_heap)\\n            p, t = self.max_heap[0]\\n        return -p\\n\\n    def minimum(self) -> int:\\n        # print(\"min price: {}\".format(self.prices[self.min_index]))\\n        p, t = self.min_heap[0]\\n        \\n        while p != self.prices[t]:\\n            heappop(self.min_heap)\\n            p, t = self.min_heap[0]\\n        return p\\n        \\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.price = 0\\n        self.max_heap = []\\n        self.min_heap = []\\n        self.prices = defaultdict(list)\\n        self.latest_time = float(\\'-inf\\')\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.prices[timestamp] = price\\n        self.latest_time = max(self.latest_time, timestamp)\\n        heapq.heappush(self.max_heap, (-price, timestamp))\\n        heapq.heappush(self.min_heap, (price, timestamp))\\n        \\n        \\n        # print(\"updating price of {} at time {}\".format(timestamp, price))\\n\\n    def current(self) -> int:\\n        # print(\"current price: {}\".format(self.prices[self.latest_time]))\\n        return self.prices[self.latest_time]\\n\\n    def maximum(self) -> int:\\n        # print(\"max price: {}\".format(self.prices[self.max_index]))\\n        p, t = self.max_heap[0]\\n        while -p != self.prices[t]:\\n            heappop(self.max_heap)\\n            p, t = self.max_heap[0]\\n        return -p\\n\\n    def minimum(self) -> int:\\n        # print(\"min price: {}\".format(self.prices[self.min_index]))\\n        p, t = self.min_heap[0]\\n        \\n        while p != self.prices[t]:\\n            heappop(self.min_heap)\\n            p, t = self.min_heap[0]\\n        return p\\n        \\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409088,
                "title": "c-solution-multiset-and-hashmap",
                "content": "```\\nclass StockPrice {\\n    unordered_map<int,int> prices;\\n    multiset<int> ms;\\n    int maxTimestamp = -1;\\npublic:\\n    StockPrice() { }\\n    \\n    void update(int timestamp, int price) {\\n        if (prices.find(timestamp) != prices.end()) {\\n            ms.erase(ms.find(prices[timestamp]));\\n        }\\n        prices[timestamp] = price;\\n        ms.insert(price);\\n        \\n        maxTimestamp = max(maxTimestamp, timestamp);\\n    }\\n    \\n    int current() {\\n        return prices[maxTimestamp];\\n    }\\n    \\n    int maximum() {\\n        return *ms.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *ms.begin();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n    unordered_map<int,int> prices;\\n    multiset<int> ms;\\n    int maxTimestamp = -1;\\npublic:\\n    StockPrice() { }\\n    \\n    void update(int timestamp, int price) {\\n        if (prices.find(timestamp) != prices.end()) {\\n            ms.erase(ms.find(prices[timestamp]));\\n        }\\n        prices[timestamp] = price;\\n        ms.insert(price);\\n        \\n        maxTimestamp = max(maxTimestamp, timestamp);\\n    }\\n    \\n    int current() {\\n        return prices[maxTimestamp];\\n    }\\n    \\n    int maximum() {\\n        return *ms.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *ms.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361287,
                "title": "c-easy-solution-with-explanation",
                "content": "Hi , \\n\\nLet us understand the requirements. \\n\\n1) Need to maintain values for timestamp to price mapping. Hence , we can use unordered or ordered maps for this purpose. \\n2) Get Latest Price according to time : For this we can maintain a **ordered map** . As the values gets inserted , map will sort. And to return the latest price we can return the last row of map.\\n3) Find Minimum value of stock : Maintain a **multiset** for this. on every update update the set containing min value and same goes for Maximum value.\\n\\n**PS : Negative values are used so that abs(key) comes in descending order.**\\n\\n```\\nclass StockPrice {\\n    map<int , int> st;\\n    multiset<int> mini;\\n    multiset<int> maxi;\\npublic:\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        auto itr = st.find(-timestamp);\\n        \\n        if(itr == st.end()) {\\n            st.insert({-timestamp , price});\\n            mini.insert(price);\\n            maxi.insert(-price);\\n        } else {\\n            mini.erase(mini.find(itr->second));\\n            mini.insert(price);\\n            maxi.erase(maxi.find(-itr->second));\\n            maxi.insert(-price);\\n            st[-timestamp] = price;\\n        }\\n    }\\n    \\n    int current() {\\n        /// find begin pointer because map is sorted in descending order.\\n        auto itr = st.begin();\\n        return itr->second;\\n    }\\n    \\n    int maximum() {\\n\\t/// abs because we stored negative value of prices to sort in descending order\\n        return abs(*maxi.begin());\\n    }\\n    \\n    int minimum() {\\n        return *mini.begin();\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass StockPrice {\\n    map<int , int> st;\\n    multiset<int> mini;\\n    multiset<int> maxi;\\npublic:\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        auto itr = st.find(-timestamp);\\n        \\n        if(itr == st.end()) {\\n            st.insert({-timestamp , price});\\n            mini.insert(price);\\n            maxi.insert(-price);\\n        } else {\\n            mini.erase(mini.find(itr->second));\\n            mini.insert(price);\\n            maxi.erase(maxi.find(-itr->second));\\n            maxi.insert(-price);\\n            st[-timestamp] = price;\\n        }\\n    }\\n    \\n    int current() {\\n        /// find begin pointer because map is sorted in descending order.\\n        auto itr = st.begin();\\n        return itr->second;\\n    }\\n    \\n    int maximum() {\\n\\t/// abs because we stored negative value of prices to sort in descending order\\n        return abs(*maxi.begin());\\n    }\\n    \\n    int minimum() {\\n        return *mini.begin();\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2282907,
                "title": "java-hashmap-treemap-o-logn-with-explanation",
                "content": "```/*\\nwe need a HashMap to store the timestamp and its updated price.\\nWe need another TreeMap to store the price as the key and the value \\n- the count/frequency of how many times this price has appeared \\n\\n- we need this tree map because the entries in the treemap are sorts by the key O(logn) in asc order \\n- and stores the entries in the map. so at any point we can easily get the maximum price \\n- (priceFrequencyMap.lastKey()) and minimum price (priceFrequencyMap.firstKey()) of the stock \\n\\nwe are storing the value as the count, because based on the count if(count==1) \\nwe either remove the entry or if(count>1) we decrement the count and update the entry.\\n\\nmaintain the highest time stamp in a variable to keep track of the \\ncurrent maximum timestamp and its latest price.\\n\\nwhen a new timestamp and the price comes, always update the latest time stamp with max \\nbetween the latestTimeStamp and the incoming/current timestamp.\\n\\nif there is already a value in the stockTimeAndPriceMap for that timestamp, it means the value \\nin the map is outdated, we need to update the entry with the new time stamp.\\n\\nGet the outdated time stamp, we need this to work on the price frequency map. \\n*/\\nclass StockPrice {\\n    \\n   \\n    Map<Integer, Integer> stockTimeAndPriceMap; \\n    TreeMap<Integer, Integer> priceFrequencyMap; // {price : frequencyOfThatPrice}\\n    \\n    int latestTimeStamp = Integer.MIN_VALUE;\\n\\n    public StockPrice() {\\n        stockTimeAndPriceMap = new HashMap<>();\\n        priceFrequencyMap = new TreeMap<>();\\n    }\\n    \\n    // O(logn)\\n    public void update(int timestamp, int price) {\\n        \\n        latestTimeStamp = Math.max(latestTimeStamp, timestamp);\\n        \\n        if(stockTimeAndPriceMap.containsKey(timestamp)) {\\n            \\n            int outdatedPrice = stockTimeAndPriceMap.get(timestamp);\\n            stockTimeAndPriceMap.put(timestamp, price);\\n\\n            if(priceFrequencyMap.containsKey(outdatedPrice)) {\\n            \\n            // if frequency of the outdated price is 1, we need to decrement the count, and it becomes 0 and we need to remove that entry\\n                if(priceFrequencyMap.get(outdatedPrice) == 1) {\\n                    priceFrequencyMap.remove(outdatedPrice);\\n                } else {\\n                    priceFrequencyMap.put(outdatedPrice, priceFrequencyMap.get(outdatedPrice)-1);\\n                }\\n            } \\n            \\n            priceFrequencyMap.put(price, priceFrequencyMap.getOrDefault(price, 0)+1);\\n            \\n        } else {\\n            stockTimeAndPriceMap.put(timestamp, price);\\n            priceFrequencyMap.put(price, priceFrequencyMap.getOrDefault(price, 0)+1);\\n        }\\n        \\n    }\\n    \\n    // O(1)\\n    public int current() {\\n        return stockTimeAndPriceMap.get(latestTimeStamp);\\n    }\\n    \\n    // O(logn)\\n    public int maximum() {\\n        return priceFrequencyMap.lastKey();\\n    }\\n    \\n    // O(logn)\\n    public int minimum() {\\n       return priceFrequencyMap.firstKey();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```/*\\nwe need a HashMap to store the timestamp and its updated price.\\nWe need another TreeMap to store the price as the key and the value \\n- the count/frequency of how many times this price has appeared \\n\\n- we need this tree map because the entries in the treemap are sorts by the key O(logn) in asc order \\n- and stores the entries in the map. so at any point we can easily get the maximum price \\n- (priceFrequencyMap.lastKey()) and minimum price (priceFrequencyMap.firstKey()) of the stock \\n\\nwe are storing the value as the count, because based on the count if(count==1) \\nwe either remove the entry or if(count>1) we decrement the count and update the entry.\\n\\nmaintain the highest time stamp in a variable to keep track of the \\ncurrent maximum timestamp and its latest price.\\n\\nwhen a new timestamp and the price comes, always update the latest time stamp with max \\nbetween the latestTimeStamp and the incoming/current timestamp.\\n\\nif there is already a value in the stockTimeAndPriceMap for that timestamp, it means the value \\nin the map is outdated, we need to update the entry with the new time stamp.\\n\\nGet the outdated time stamp, we need this to work on the price frequency map. \\n*/\\nclass StockPrice {\\n    \\n   \\n    Map<Integer, Integer> stockTimeAndPriceMap; \\n    TreeMap<Integer, Integer> priceFrequencyMap; // {price : frequencyOfThatPrice}\\n    \\n    int latestTimeStamp = Integer.MIN_VALUE;\\n\\n    public StockPrice() {\\n        stockTimeAndPriceMap = new HashMap<>();\\n        priceFrequencyMap = new TreeMap<>();\\n    }\\n    \\n    // O(logn)\\n    public void update(int timestamp, int price) {\\n        \\n        latestTimeStamp = Math.max(latestTimeStamp, timestamp);\\n        \\n        if(stockTimeAndPriceMap.containsKey(timestamp)) {\\n            \\n            int outdatedPrice = stockTimeAndPriceMap.get(timestamp);\\n            stockTimeAndPriceMap.put(timestamp, price);\\n\\n            if(priceFrequencyMap.containsKey(outdatedPrice)) {\\n            \\n            // if frequency of the outdated price is 1, we need to decrement the count, and it becomes 0 and we need to remove that entry\\n                if(priceFrequencyMap.get(outdatedPrice) == 1) {\\n                    priceFrequencyMap.remove(outdatedPrice);\\n                } else {\\n                    priceFrequencyMap.put(outdatedPrice, priceFrequencyMap.get(outdatedPrice)-1);\\n                }\\n            } \\n            \\n            priceFrequencyMap.put(price, priceFrequencyMap.getOrDefault(price, 0)+1);\\n            \\n        } else {\\n            stockTimeAndPriceMap.put(timestamp, price);\\n            priceFrequencyMap.put(price, priceFrequencyMap.getOrDefault(price, 0)+1);\\n        }\\n        \\n    }\\n    \\n    // O(1)\\n    public int current() {\\n        return stockTimeAndPriceMap.get(latestTimeStamp);\\n    }\\n    \\n    // O(logn)\\n    public int maximum() {\\n        return priceFrequencyMap.lastKey();\\n    }\\n    \\n    // O(logn)\\n    public int minimum() {\\n       return priceFrequencyMap.firstKey();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2273926,
                "title": "python-min-max-heap-approach",
                "content": "```\\nclass StockPrice:\\n    def __init__(self):\\n        # Store price of each stock at each timestamp.\\n        self.records = {}\\n        \\n        # Store time to get the latest price.\\n        self.lastTimestamp = 0 \\n       \\n        # Store stock prices in sorted order to get min and max price.\\n        self.max_heap = []\\n        self.min_heap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        # Update latestTime to latest timestamp.\\n        self.records[timestamp] = price\\n        self.lastTimestamp = max(self.lastTimestamp, timestamp)\\n\\n        # Add latest price for timestamp.\\n        heapq.heappush(self.min_heap, (price, timestamp))\\n        heapq.heappush(self.max_heap, (-price, timestamp))\\n\\n    # Return latest price of the stock.\\n    def current(self) -> int:\\n        return self.records[self.lastTimestamp]\\n\\n    # In the maximum/minimum functions, we get the (price, timestamp) pair \\n    # from the top of maxHeap/minHeap. If timestampPriceMap[timestamp] is not \\n    # same as price, we discard this pair and repeat the same step again. \\n    # Otherwise, return the current price.\\n    def maximum(self) -> int:\\n        price, timestamp = self.max_heap[0]\\n\\n        # Pop pairs from heap with the price doesn\\'t match with hashmap.\\n        while -price != self.records[timestamp]:\\n            heapq.heappop(self.max_heap)\\n            price, timestamp = self.max_heap[0]\\n            \\n        return -price\\n\\n    def minimum(self) -> int:\\n        price, timestamp = self.min_heap[0]\\n\\n        # Pop pairs from heap with the price doesn\\'t match with hashmap.\\n        while price != self.records[timestamp]:\\n            heapq.heappop(self.min_heap)\\n            price, timestamp = self.min_heap[0]\\n            \\n        return price\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice:\\n    def __init__(self):\\n        # Store price of each stock at each timestamp.\\n        self.records = {}\\n        \\n        # Store time to get the latest price.\\n        self.lastTimestamp = 0 \\n       \\n        # Store stock prices in sorted order to get min and max price.\\n        self.max_heap = []\\n        self.min_heap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        # Update latestTime to latest timestamp.\\n        self.records[timestamp] = price\\n        self.lastTimestamp = max(self.lastTimestamp, timestamp)\\n\\n        # Add latest price for timestamp.\\n        heapq.heappush(self.min_heap, (price, timestamp))\\n        heapq.heappush(self.max_heap, (-price, timestamp))\\n\\n    # Return latest price of the stock.\\n    def current(self) -> int:\\n        return self.records[self.lastTimestamp]\\n\\n    # In the maximum/minimum functions, we get the (price, timestamp) pair \\n    # from the top of maxHeap/minHeap. If timestampPriceMap[timestamp] is not \\n    # same as price, we discard this pair and repeat the same step again. \\n    # Otherwise, return the current price.\\n    def maximum(self) -> int:\\n        price, timestamp = self.max_heap[0]\\n\\n        # Pop pairs from heap with the price doesn\\'t match with hashmap.\\n        while -price != self.records[timestamp]:\\n            heapq.heappop(self.max_heap)\\n            price, timestamp = self.max_heap[0]\\n            \\n        return -price\\n\\n    def minimum(self) -> int:\\n        price, timestamp = self.min_heap[0]\\n\\n        # Pop pairs from heap with the price doesn\\'t match with hashmap.\\n        while price != self.records[timestamp]:\\n            heapq.heappop(self.min_heap)\\n            price, timestamp = self.min_heap[0]\\n            \\n        return price\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179472,
                "title": "java-red-black-tree",
                "content": "Similar to another post I saw by vishalgoel.\\n\\n```\\nclass StockPrice {\\n    TreeMap<Integer, Integer> tree;\\n    HashMap<Integer, Integer> stockPrices;\\n    Pair<Integer, Integer> curPrice;\\n    \\n    public StockPrice() {\\n        this.tree = new TreeMap<Integer, Integer>();\\n        this.stockPrices = new HashMap<Integer, Integer>();\\n        this.curPrice = new Pair<Integer, Integer>(-1,-1);\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        boolean curChanged = false;\\n        if(tree.containsValue(timestamp)){\\n            \\n            int oldprice = stockPrices.get(timestamp);\\n            //System.out.println(\"Old price: \" + oldprice);\\n            //System.out.println(\"New Price: \" + price);\\n\\n            tree.remove(oldprice);\\n            tree.put(price, timestamp);\\n            \\n            stockPrices.remove(timestamp);\\n            stockPrices.put(timestamp, price);\\n            \\n            if(timestamp == curPrice.getKey()){\\n                curChanged = true;\\n            }\\n        }\\n        // since it does not exist, we can add it to the tree and hashmap\\n        else{\\n            stockPrices.put(timestamp, price);\\n            tree.put(price, timestamp);\\n        }\\n        \\n        // check if we need to update current price\\n        if(curPrice.getKey() < timestamp || curChanged){\\n            curPrice = new Pair<Integer, Integer>(timestamp, price);\\n        }\\n        \\n    }\\n    \\n    public int current() {\\n        //System.out.println(\"Current \" + curPrice.getValue());\\n        return curPrice.getValue();\\n    }\\n    \\n    public int maximum() {\\n        //System.out.println(\"Maximum \" + tree.lastKey());\\n        return tree.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        //System.out.println(\"Minimum \" + tree.firstKey());\\n        return tree.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass StockPrice {\\n    TreeMap<Integer, Integer> tree;\\n    HashMap<Integer, Integer> stockPrices;\\n    Pair<Integer, Integer> curPrice;\\n    \\n    public StockPrice() {\\n        this.tree = new TreeMap<Integer, Integer>();\\n        this.stockPrices = new HashMap<Integer, Integer>();\\n        this.curPrice = new Pair<Integer, Integer>(-1,-1);\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        boolean curChanged = false;\\n        if(tree.containsValue(timestamp)){\\n            \\n            int oldprice = stockPrices.get(timestamp);\\n            //System.out.println(\"Old price: \" + oldprice);\\n            //System.out.println(\"New Price: \" + price);\\n\\n            tree.remove(oldprice);\\n            tree.put(price, timestamp);\\n            \\n            stockPrices.remove(timestamp);\\n            stockPrices.put(timestamp, price);\\n            \\n            if(timestamp == curPrice.getKey()){\\n                curChanged = true;\\n            }\\n        }\\n        // since it does not exist, we can add it to the tree and hashmap\\n        else{\\n            stockPrices.put(timestamp, price);\\n            tree.put(price, timestamp);\\n        }\\n        \\n        // check if we need to update current price\\n        if(curPrice.getKey() < timestamp || curChanged){\\n            curPrice = new Pair<Integer, Integer>(timestamp, price);\\n        }\\n        \\n    }\\n    \\n    public int current() {\\n        //System.out.println(\"Current \" + curPrice.getValue());\\n        return curPrice.getValue();\\n    }\\n    \\n    public int maximum() {\\n        //System.out.println(\"Maximum \" + tree.lastKey());\\n        return tree.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        //System.out.println(\"Minimum \" + tree.firstKey());\\n        return tree.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2168909,
                "title": "python-sortedset",
                "content": "```\\nfrom sortedcontainers import SortedSet\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.sortedPriceTime = SortedSet()   \\n        self.timeToPrice = {}\\n        self.currentTime = 0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.timeToPrice:\\n            self.sortedPriceTime.remove((self.timeToPrice[timestamp], timestamp))\\n        self.sortedPriceTime.add((price, timestamp))\\n        self.timeToPrice[timestamp] = price\\n        self.currentTime = max(timestamp, self.currentTime)\\n        \\n\\n    def current(self) -> int:\\n        return self.timeToPrice[self.currentTime]\\n\\n    def maximum(self) -> int:\\n        return self.sortedPriceTime[-1][0]\\n\\n    def minimum(self) -> int:\\n        return self.sortedPriceTime[0][0]\\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedSet\\n\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.sortedPriceTime = SortedSet()   \\n        self.timeToPrice = {}\\n        self.currentTime = 0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.timeToPrice:\\n            self.sortedPriceTime.remove((self.timeToPrice[timestamp], timestamp))\\n        self.sortedPriceTime.add((price, timestamp))\\n        self.timeToPrice[timestamp] = price\\n        self.currentTime = max(timestamp, self.currentTime)\\n        \\n\\n    def current(self) -> int:\\n        return self.timeToPrice[self.currentTime]\\n\\n    def maximum(self) -> int:\\n        return self.sortedPriceTime[-1][0]\\n\\n    def minimum(self) -> int:\\n        return self.sortedPriceTime[0][0]\\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137978,
                "title": "java-treemap-hashmap-easy-to-understand",
                "content": "```\\n\\nclass StockPrice {\\n\\n    private TreeMap<Integer, List<Integer>> prices = new TreeMap<>();   //price vs list of ts\\n    private Map<Integer, Integer> map = new HashMap<>();        //ts vs price\\n    private int ts = Integer.MIN_VALUE;\\n    private int current = Integer.MIN_VALUE;\\n    \\n    public StockPrice() {\\n        \\n    }\\n    \\n    public void update(int timestamp, int price) {        \\n        if(map.containsKey(timestamp)) {        //if it is for existing price correction, remove the ts \\n            int prevPrice = map.get(timestamp);\\n            prices.get(prevPrice).remove((Object)timestamp);\\n            if(prices.get(prevPrice).isEmpty())\\n                prices.remove(prevPrice);\\n        }\\n        \\n        if(prices.get(price) == null)\\n            prices.put(price, new ArrayList<Integer>());\\n        \\n        prices.get(price).add(timestamp);\\n        map.put(timestamp, price);\\n        \\n        if(timestamp >= ts) {\\n            ts = timestamp;\\n            current = price;   \\n        }\\n    }\\n    \\n    public int current() {\\n        return current;\\n    }\\n    \\n    public int maximum() {\\n        return prices.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return prices.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\nclass StockPrice {\\n\\n    private TreeMap<Integer, List<Integer>> prices = new TreeMap<>();   //price vs list of ts\\n    private Map<Integer, Integer> map = new HashMap<>();        //ts vs price\\n    private int ts = Integer.MIN_VALUE;\\n    private int current = Integer.MIN_VALUE;\\n    \\n    public StockPrice() {\\n        \\n    }\\n    \\n    public void update(int timestamp, int price) {        \\n        if(map.containsKey(timestamp)) {        //if it is for existing price correction, remove the ts \\n            int prevPrice = map.get(timestamp);\\n            prices.get(prevPrice).remove((Object)timestamp);\\n            if(prices.get(prevPrice).isEmpty())\\n                prices.remove(prevPrice);\\n        }\\n        \\n        if(prices.get(price) == null)\\n            prices.put(price, new ArrayList<Integer>());\\n        \\n        prices.get(price).add(timestamp);\\n        map.put(timestamp, price);\\n        \\n        if(timestamp >= ts) {\\n            ts = timestamp;\\n            current = price;   \\n        }\\n    }\\n    \\n    public int current() {\\n        return current;\\n    }\\n    \\n    public int maximum() {\\n        return prices.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return prices.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080504,
                "title": "python-easy-to-understand",
                "content": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.data = {}\\n        self.currTime = 0\\n        self.minHeap = []\\n        self.maxHeap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp > self.currTime:\\n            self.currTime = timestamp\\n        \\n        self.data[timestamp] = price\\n        heapq.heappush(self.minHeap, (price, timestamp))\\n        heapq.heappush(self.maxHeap, (-price, timestamp))\\n\\n    def current(self) -> int:\\n        return self.data[self.currTime]\\n\\n    def maximum(self) -> int:\\n        while -1 * self.maxHeap[0][0] != self.data[self.maxHeap[0][1]]:\\n            _, timestamp = heapq.heappop(self.maxHeap)\\n        return -1 * self.maxHeap[0][0]\\n\\n    def minimum(self) -> int:\\n        while self.minHeap[0][0] != self.data[self.minHeap[0][1]]:\\n            _, timestamp = heapq.heappop(self.minHeap)\\n        return self.minHeap[0][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.data = {}\\n        self.currTime = 0\\n        self.minHeap = []\\n        self.maxHeap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp > self.currTime:\\n            self.currTime = timestamp\\n        \\n        self.data[timestamp] = price\\n        heapq.heappush(self.minHeap, (price, timestamp))\\n        heapq.heappush(self.maxHeap, (-price, timestamp))\\n\\n    def current(self) -> int:\\n        return self.data[self.currTime]\\n\\n    def maximum(self) -> int:\\n        while -1 * self.maxHeap[0][0] != self.data[self.maxHeap[0][1]]:\\n            _, timestamp = heapq.heappop(self.maxHeap)\\n        return -1 * self.maxHeap[0][0]\\n\\n    def minimum(self) -> int:\\n        while self.minHeap[0][0] != self.data[self.minHeap[0][1]]:\\n            _, timestamp = heapq.heappop(self.minHeap)\\n        return self.minHeap[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064378,
                "title": "could-someone-help-me-understand-why-my-hashmap-treeset-solution-failed-for-the-11th-test-case",
                "content": "```\\nclass StockPrice {\\n    \\n    Map<Integer, Integer> timeToPrice; // maps the timestamp to the most recent price\\n    TreeSet<Integer> sortedPrice; // set of timestamps in the order of the price\\n    int currentTimestamp; // current timestamp\\n    \\n\\n    public StockPrice() {\\n        \\n        this.timeToPrice = new HashMap();\\n        this.sortedPrice = new TreeSet<>((t1, t2) -> {\\n\\n\\t\\t\\t// if different timestamps have different value, they need to both exist in the set\\n            if (this.timeToPrice.get(t1) == this.timeToPrice.get(t2))\\n                return t1 - t2;\\n            \\n            return this.timeToPrice.get(t1) - this.timeToPrice.get(t2);\\n        });\\n        \\n        this.currentTimestamp = -1; // no stock price yet\\n\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (timestamp >= this.currentTimestamp) {\\n            this.currentTimestamp =  timestamp;\\n        }\\n        \\n        if (this.timeToPrice.containsKey(timestamp)) {\\n            this.sortedPrice.remove(timestamp); \\n        }\\n        \\n        this.timeToPrice.put(timestamp, price);\\n        this.sortedPrice.add(timestamp);\\n        \\n    }\\n    \\n    public int current() {\\n        return this.timeToPrice.get(currentTimestamp);\\n    }\\n    \\n    public int maximum() {\\n        return this.timeToPrice.get(this.sortedPrice.last());\\n    }\\n    \\n    public int minimum() {\\n        return this.timeToPrice.get(this.sortedPrice.first());\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n\\n ```\\n\\nI really cannot figure this out why this does not work ... :(   Please help!",
                "solutionTags": [
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass StockPrice {\\n    \\n    Map<Integer, Integer> timeToPrice; // maps the timestamp to the most recent price\\n    TreeSet<Integer> sortedPrice; // set of timestamps in the order of the price\\n    int currentTimestamp; // current timestamp\\n    \\n\\n    public StockPrice() {\\n        \\n        this.timeToPrice = new HashMap();\\n        this.sortedPrice = new TreeSet<>((t1, t2) -> {\\n\\n\\t\\t\\t// if different timestamps have different value, they need to both exist in the set\\n            if (this.timeToPrice.get(t1) == this.timeToPrice.get(t2))\\n                return t1 - t2;\\n            \\n            return this.timeToPrice.get(t1) - this.timeToPrice.get(t2);\\n        });\\n        \\n        this.currentTimestamp = -1; // no stock price yet\\n\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (timestamp >= this.currentTimestamp) {\\n            this.currentTimestamp =  timestamp;\\n        }\\n        \\n        if (this.timeToPrice.containsKey(timestamp)) {\\n            this.sortedPrice.remove(timestamp); \\n        }\\n        \\n        this.timeToPrice.put(timestamp, price);\\n        this.sortedPrice.add(timestamp);\\n        \\n    }\\n    \\n    public int current() {\\n        return this.timeToPrice.get(currentTimestamp);\\n    }\\n    \\n    public int maximum() {\\n        return this.timeToPrice.get(this.sortedPrice.last());\\n    }\\n    \\n    public int minimum() {\\n        return this.timeToPrice.get(this.sortedPrice.first());\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2041154,
                "title": "double-map-c-easiest",
                "content": "```\\nclass StockPrice {\\nprivate:\\n    map<int, int> mp; // timestamp->value map\\n    map<int, int> st; // value->frequency map\\n    \\npublic:\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(mp.find(timestamp) != mp.end()){\\n            int value = mp[timestamp];\\n            st[value]--;\\n            if(st[value]==0)\\n                st.erase(value);\\n        }\\n        mp[timestamp] = price;\\n        st[price]++;\\n        \\n    }\\n    \\n    int current() {\\n        return mp.rbegin()->second;\\n    }\\n    \\n    int maximum() {\\n        return st.rbegin()->first;\\n    }\\n    \\n    int minimum() {\\n        return st.begin()->first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\nprivate:\\n    map<int, int> mp; // timestamp->value map\\n    map<int, int> st; // value->frequency map\\n    \\npublic:\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(mp.find(timestamp) != mp.end()){\\n            int value = mp[timestamp];\\n            st[value]--;\\n            if(st[value]==0)\\n                st.erase(value);\\n        }\\n        mp[timestamp] = price;\\n        st[price]++;\\n        \\n    }\\n    \\n    int current() {\\n        return mp.rbegin()->second;\\n    }\\n    \\n    int maximum() {\\n        return st.rbegin()->first;\\n    }\\n    \\n    int minimum() {\\n        return st.begin()->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032974,
                "title": "c-easy-solution-using-map-and-heap",
                "content": "```\\nclass StockPrice {\\n    \\n    int maxTime = INT_MIN;\\n    priority_queue<int> maxQ;\\n    priority_queue<int,vector<int>,greater<int>> minQ;\\n    unordered_map<int,int> m,minMap,maxMap;\\n    \\n    \\npublic:\\n    StockPrice() {\\n        \\n        return ;\\n        \\n    }\\n    \\n    void update(int t, int p) {\\n        \\n        maxTime = max(maxTime,t);\\n        if(m.count(t))\\n        {\\n            minMap[m[t]]++;\\n            maxMap[m[t]]++; \\n        }\\n        m[t]  = p;\\n        maxQ.push(p);\\n        minQ.push(p);\\n        return ;\\n    }\\n    \\n    int current() {\\n        return m[maxTime];\\n    }\\n    \\n    int maximum() {\\n        \\n        int h ;\\n        while(maxMap.count(maxQ.top()))\\n        {\\n            h = maxQ.top();\\n            maxQ.pop();\\n            maxMap[h]--;\\n            if(maxMap[h]==0)\\n                maxMap.erase(h);\\n        }\\n        \\n        return maxQ.top();\\n        \\n    }\\n    \\n    int minimum() {\\n        \\n        int h ;\\n        while(minMap.count(minQ.top()))\\n        {\\n            h = minQ.top();\\n            minQ.pop();\\n            minMap[h]--;\\n            if(minMap[h]==0)\\n                minMap.erase(h);\\n        }\\n        \\n        return minQ.top();\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n    \\n    int maxTime = INT_MIN;\\n    priority_queue<int> maxQ;\\n    priority_queue<int,vector<int>,greater<int>> minQ;\\n    unordered_map<int,int> m,minMap,maxMap;\\n    \\n    \\npublic:\\n    StockPrice() {\\n        \\n        return ;\\n        \\n    }\\n    \\n    void update(int t, int p) {\\n        \\n        maxTime = max(maxTime,t);\\n        if(m.count(t))\\n        {\\n            minMap[m[t]]++;\\n            maxMap[m[t]]++; \\n        }\\n        m[t]  = p;\\n        maxQ.push(p);\\n        minQ.push(p);\\n        return ;\\n    }\\n    \\n    int current() {\\n        return m[maxTime];\\n    }\\n    \\n    int maximum() {\\n        \\n        int h ;\\n        while(maxMap.count(maxQ.top()))\\n        {\\n            h = maxQ.top();\\n            maxQ.pop();\\n            maxMap[h]--;\\n            if(maxMap[h]==0)\\n                maxMap.erase(h);\\n        }\\n        \\n        return maxQ.top();\\n        \\n    }\\n    \\n    int minimum() {\\n        \\n        int h ;\\n        while(minMap.count(minQ.top()))\\n        {\\n            h = minQ.top();\\n            minQ.pop();\\n            minMap[h]--;\\n            if(minMap[h]==0)\\n                minMap.erase(h);\\n        }\\n        \\n        return minQ.top();\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988238,
                "title": "hashmap-multiset",
                "content": "```\\nclass StockPrice {\\npublic:\\n    multiset <int> priceSet;\\n    int maximum_timestamp, last_timestamp, last_price;\\n    vector <int> hashTable[1 << 16];\\n    vector <int> hashTableValue[1 << 16];\\n    \\n    int Insert(int y, int val) {\\n        unsigned short x = y;\\n        for (int i = 0; i < hashTable[x].size(); ++i) if (y == hashTable[x][i]) {\\n            int previous_value = hashTableValue[x][i];\\n            hashTableValue[x][i] = val;\\n            return previous_value;\\n        }\\n        hashTable[x].push_back(y);\\n        hashTableValue[x].push_back(val);\\n        return 0;\\n    }\\n    \\n    int Find(int y) {\\n        unsigned short x = y;\\n        for (int i = 0; i < hashTable[x].size(); i++) if (y == hashTable[x][i]) return hashTableValue[x][i];\\n        \\n        return 0;\\n    }\\n    \\n    StockPrice() {\\n        priceSet.clear();\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        // maximum_timestamp = max(maximum_timestamp, timestamp);\\n        int previous_value = Insert(timestamp, price);\\n        priceSet.insert(price);\\n        if (previous_value) {\\n            priceSet.erase(priceSet.find(previous_value)); \\n        }       \\n        \\n        if (timestamp >= last_timestamp) {\\n            last_timestamp = timestamp;\\n            last_price = price;\\n        }\\n    }\\n    \\n    int current() {\\n        return last_price;\\n    }\\n    \\n    int maximum() {\\n        return *priceSet.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *priceSet.begin();\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    multiset <int> priceSet;\\n    int maximum_timestamp, last_timestamp, last_price;\\n    vector <int> hashTable[1 << 16];\\n    vector <int> hashTableValue[1 << 16];\\n    \\n    int Insert(int y, int val) {\\n        unsigned short x = y;\\n        for (int i = 0; i < hashTable[x].size(); ++i) if (y == hashTable[x][i]) {\\n            int previous_value = hashTableValue[x][i];\\n            hashTableValue[x][i] = val;\\n            return previous_value;\\n        }\\n        hashTable[x].push_back(y);\\n        hashTableValue[x].push_back(val);\\n        return 0;\\n    }\\n    \\n    int Find(int y) {\\n        unsigned short x = y;\\n        for (int i = 0; i < hashTable[x].size(); i++) if (y == hashTable[x][i]) return hashTableValue[x][i];\\n        \\n        return 0;\\n    }\\n    \\n    StockPrice() {\\n        priceSet.clear();\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        // maximum_timestamp = max(maximum_timestamp, timestamp);\\n        int previous_value = Insert(timestamp, price);\\n        priceSet.insert(price);\\n        if (previous_value) {\\n            priceSet.erase(priceSet.find(previous_value)); \\n        }       \\n        \\n        if (timestamp >= last_timestamp) {\\n            last_timestamp = timestamp;\\n            last_price = price;\\n        }\\n    }\\n    \\n    int current() {\\n        return last_price;\\n    }\\n    \\n    int maximum() {\\n        return *priceSet.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *priceSet.begin();\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982481,
                "title": "java-solution-two-heaps",
                "content": "```\\nclass StockPrice {\\n  Map<Integer, Integer> timeToPrice = new HashMap<>();\\n  PriorityQueue<int[]> minPrices = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n  PriorityQueue<int[]> maxPrices = new PriorityQueue<>((a, b) -> b[1] - a[1]); // timestamp, value\\n  int timestamp = 1;\\n\\n  public void update(int timestamp, int price) {\\n    timeToPrice.put(timestamp, price); // Add new price\\n    minPrices.add(new int[] {timestamp, price});\\n    maxPrices.add(new int[] {timestamp, price});\\n    this.timestamp = Math.max(this.timestamp, timestamp);\\n  }\\n\\n  public int current() {\\n    return timeToPrice.get(timestamp);\\n  }\\n\\n  public int maximum() {\\n    while (maxPrices.peek()[1] != timeToPrice.get(maxPrices.peek()[0])) {\\n      maxPrices.remove(); // Keep removing the maximum value if it doesn\\'t match the latest value\\n    }\\n    return maxPrices.peek()[1];\\n  }\\n\\n  public int minimum() {\\n    while (minPrices.peek()[1] != timeToPrice.get(minPrices.peek()[0])) {\\n      minPrices.remove(); // Keep removing the minimum value if it doesn\\'t match the latest value\\n    }\\n    return minPrices.peek()[1];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StockPrice {\\n  Map<Integer, Integer> timeToPrice = new HashMap<>();\\n  PriorityQueue<int[]> minPrices = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n  PriorityQueue<int[]> maxPrices = new PriorityQueue<>((a, b) -> b[1] - a[1]); // timestamp, value\\n  int timestamp = 1;\\n\\n  public void update(int timestamp, int price) {\\n    timeToPrice.put(timestamp, price); // Add new price\\n    minPrices.add(new int[] {timestamp, price});\\n    maxPrices.add(new int[] {timestamp, price});\\n    this.timestamp = Math.max(this.timestamp, timestamp);\\n  }\\n\\n  public int current() {\\n    return timeToPrice.get(timestamp);\\n  }\\n\\n  public int maximum() {\\n    while (maxPrices.peek()[1] != timeToPrice.get(maxPrices.peek()[0])) {\\n      maxPrices.remove(); // Keep removing the maximum value if it doesn\\'t match the latest value\\n    }\\n    return maxPrices.peek()[1];\\n  }\\n\\n  public int minimum() {\\n    while (minPrices.peek()[1] != timeToPrice.get(minPrices.peek()[0])) {\\n      minPrices.remove(); // Keep removing the minimum value if it doesn\\'t match the latest value\\n    }\\n    return minPrices.peek()[1];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942390,
                "title": "java-min-max-heap-hashmap-fast-solution",
                "content": "![image](https://assets.leetcode.com/users/images/293bc99f-843c-41e6-8b44-345888226bbe_1649839634.9747665.png)\\n\\n```\\nclass StockPriceRecord {\\n    int price, timestamp;\\n    StockPriceRecord(int price, int timestamp) {\\n        this.price = price;\\n        this.timestamp = timestamp;\\n    }\\n}\\n\\nclass StockPriceMinComparator implements Comparator<StockPriceRecord> {\\n    @Override\\n    public int compare(StockPriceRecord spr1, StockPriceRecord spr2) {\\n        return Integer.compare(spr1.price, spr2.price);\\n    }\\n}\\n\\nclass StockPriceMaxComparator implements Comparator<StockPriceRecord> {\\n    @Override\\n    public int compare(StockPriceRecord spr1, StockPriceRecord spr2) {\\n        return Integer.compare(spr2.price, spr1.price);\\n    }\\n}\\n\\nclass StockPrice {\\n    \\n    PriorityQueue<StockPriceRecord> maxHeap;\\n    PriorityQueue<StockPriceRecord> minHeap;\\n    Map<Integer, Integer> prices;\\n    int latestTime;\\n    \\n    public StockPrice() {\\n        maxHeap = new PriorityQueue<>(new StockPriceMaxComparator());\\n        minHeap = new PriorityQueue<>(new StockPriceMinComparator());\\n        prices = new HashMap<>();\\n        latestTime = 1;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        StockPriceRecord record = new StockPriceRecord(price, timestamp);\\n        prices.put(timestamp, price);\\n        maxHeap.offer(record);\\n        minHeap.offer(record);\\n        latestTime = Math.max(latestTime, timestamp);\\n    }\\n    \\n    public int current() {\\n        return prices.get(latestTime);\\n    }\\n    \\n    public int maximum() {\\n        while(maxHeap.peek().price != prices.get(maxHeap.peek().timestamp)) {\\n           maxHeap.poll(); \\n        }\\n        return maxHeap.peek().price;\\n    }\\n    \\n    public int minimum() {\\n        while(minHeap.peek().price != prices.get(minHeap.peek().timestamp)){\\n           minHeap.poll(); \\n        }\\n        return minHeap.peek().price; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPriceRecord {\\n    int price, timestamp;\\n    StockPriceRecord(int price, int timestamp) {\\n        this.price = price;\\n        this.timestamp = timestamp;\\n    }\\n}\\n\\nclass StockPriceMinComparator implements Comparator<StockPriceRecord> {\\n    @Override\\n    public int compare(StockPriceRecord spr1, StockPriceRecord spr2) {\\n        return Integer.compare(spr1.price, spr2.price);\\n    }\\n}\\n\\nclass StockPriceMaxComparator implements Comparator<StockPriceRecord> {\\n    @Override\\n    public int compare(StockPriceRecord spr1, StockPriceRecord spr2) {\\n        return Integer.compare(spr2.price, spr1.price);\\n    }\\n}\\n\\nclass StockPrice {\\n    \\n    PriorityQueue<StockPriceRecord> maxHeap;\\n    PriorityQueue<StockPriceRecord> minHeap;\\n    Map<Integer, Integer> prices;\\n    int latestTime;\\n    \\n    public StockPrice() {\\n        maxHeap = new PriorityQueue<>(new StockPriceMaxComparator());\\n        minHeap = new PriorityQueue<>(new StockPriceMinComparator());\\n        prices = new HashMap<>();\\n        latestTime = 1;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        StockPriceRecord record = new StockPriceRecord(price, timestamp);\\n        prices.put(timestamp, price);\\n        maxHeap.offer(record);\\n        minHeap.offer(record);\\n        latestTime = Math.max(latestTime, timestamp);\\n    }\\n    \\n    public int current() {\\n        return prices.get(latestTime);\\n    }\\n    \\n    public int maximum() {\\n        while(maxHeap.peek().price != prices.get(maxHeap.peek().timestamp)) {\\n           maxHeap.poll(); \\n        }\\n        return maxHeap.peek().price;\\n    }\\n    \\n    public int minimum() {\\n        while(minHeap.peek().price != prices.get(minHeap.peek().timestamp)){\\n           minHeap.poll(); \\n        }\\n        return minHeap.peek().price; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905066,
                "title": "go-2-heaps",
                "content": "```\\n/*\\nthe current timestamp is always the latest value and timestamps\\ncannot update, so keeping the largest timestamp will maintain the\\ncurrent time\\n\\nhow to get max/min of the stock prices?\\nupdate can be managed quickly with a map of timestamps -> price\\nin order to get the min/max the entire map would need to be traversed\\nonce an update happens the min/max could change\\n\\nto maintain better min/max heaps could be used for constant time\\nbut finding a value to update could take logn time\\n\\nit could be eventual consistency where the map is the source of truth\\nand when popping values out the min/max heap if corresponding timestamp/value\\npair is not found in the map, then pop the next one from the heap. though\\nthis would take n more space\\n\\n\\n*/\\n\\ntype stock struct {\\n    ts, price int\\n}\\ntype StockPrice struct {\\n    curTime int\\n    prices map[int]int\\n    maxPriceHeap minHeap\\n    minPriceHeap minHeap\\n}\\n\\n\\nfunc Constructor() StockPrice {\\n    maxPH := minHeap{}\\n    minPH := minHeap{}\\n    heap.Init(&maxPH)\\n    heap.Init(&minPH)\\n    return StockPrice{\\n        curTime: 0,\\n        prices: map[int]int{},\\n        maxPriceHeap: maxPH,\\n        minPriceHeap: minPH, \\n    }\\n}\\n\\n\\nfunc (s *StockPrice) Update(timestamp int, price int)  {\\n    if s.curTime < timestamp {\\n        s.curTime = timestamp\\n    }\\n    heap.Push(&s.maxPriceHeap, stock{timestamp, -1*price})\\n    heap.Push(&s.minPriceHeap, stock{timestamp, price})\\n    s.prices[timestamp] = price\\n}\\n\\n\\nfunc (s *StockPrice) Current() int {\\n    return s.prices[s.curTime]   \\n}\\n\\n\\nfunc (s *StockPrice) Maximum() int {\\n    for s.prices[s.maxPriceHeap[0].ts] != -1*s.maxPriceHeap[0].price {\\n        heap.Pop(&s.maxPriceHeap)\\n    }\\n\\n    return -1*s.maxPriceHeap[0].price\\n}\\n\\n\\nfunc (s *StockPrice) Minimum() int {\\n    for s.prices[s.minPriceHeap[0].ts] != s.minPriceHeap[0].price {\\n        heap.Pop(&s.minPriceHeap)\\n    }\\n    return s.minPriceHeap[0].price\\n}\\n\\ntype minHeap []stock\\n\\nfunc (h minHeap) Len() int           { return len(h) }\\nfunc (h minHeap) Less(i, j int) bool { return h[i].price < h[j].price }\\nfunc (h minHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *minHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(stock))\\n}\\n\\nfunc (h *minHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nthe current timestamp is always the latest value and timestamps\\ncannot update, so keeping the largest timestamp will maintain the\\ncurrent time\\n\\nhow to get max/min of the stock prices?\\nupdate can be managed quickly with a map of timestamps -> price\\nin order to get the min/max the entire map would need to be traversed\\nonce an update happens the min/max could change\\n\\nto maintain better min/max heaps could be used for constant time\\nbut finding a value to update could take logn time\\n\\nit could be eventual consistency where the map is the source of truth\\nand when popping values out the min/max heap if corresponding timestamp/value\\npair is not found in the map, then pop the next one from the heap. though\\nthis would take n more space\\n\\n\\n*/\\n\\ntype stock struct {\\n    ts, price int\\n}\\ntype StockPrice struct {\\n    curTime int\\n    prices map[int]int\\n    maxPriceHeap minHeap\\n    minPriceHeap minHeap\\n}\\n\\n\\nfunc Constructor() StockPrice {\\n    maxPH := minHeap{}\\n    minPH := minHeap{}\\n    heap.Init(&maxPH)\\n    heap.Init(&minPH)\\n    return StockPrice{\\n        curTime: 0,\\n        prices: map[int]int{},\\n        maxPriceHeap: maxPH,\\n        minPriceHeap: minPH, \\n    }\\n}\\n\\n\\nfunc (s *StockPrice) Update(timestamp int, price int)  {\\n    if s.curTime < timestamp {\\n        s.curTime = timestamp\\n    }\\n    heap.Push(&s.maxPriceHeap, stock{timestamp, -1*price})\\n    heap.Push(&s.minPriceHeap, stock{timestamp, price})\\n    s.prices[timestamp] = price\\n}\\n\\n\\nfunc (s *StockPrice) Current() int {\\n    return s.prices[s.curTime]   \\n}\\n\\n\\nfunc (s *StockPrice) Maximum() int {\\n    for s.prices[s.maxPriceHeap[0].ts] != -1*s.maxPriceHeap[0].price {\\n        heap.Pop(&s.maxPriceHeap)\\n    }\\n\\n    return -1*s.maxPriceHeap[0].price\\n}\\n\\n\\nfunc (s *StockPrice) Minimum() int {\\n    for s.prices[s.minPriceHeap[0].ts] != s.minPriceHeap[0].price {\\n        heap.Pop(&s.minPriceHeap)\\n    }\\n    return s.minPriceHeap[0].price\\n}\\n\\ntype minHeap []stock\\n\\nfunc (h minHeap) Len() int           { return len(h) }\\nfunc (h minHeap) Less(i, j int) bool { return h[i].price < h[j].price }\\nfunc (h minHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *minHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(stock))\\n}\\n\\nfunc (h *minHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1866632,
                "title": "simple-c-solution",
                "content": "```\\nclass StockPrice {\\npublic:\\n    unordered_map<int, pair<int, multiset<int> :: iterator>> mp;\\n    multiset<int> sec;\\n    map<int, int> currVal;\\n    \\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if (!mp.count(timestamp)) {\\n            auto it = sec.insert(price);\\n            mp[timestamp] = make_pair(price, it);\\n            currVal[timestamp] = price;\\n        } else {\\n            auto it = mp[timestamp].second;\\n            sec.erase(it);\\n            it = sec.insert(price);\\n            mp[timestamp] = make_pair(price, it);\\n            currVal[timestamp] = price;\\n        }\\n    }\\n    \\n    int current() {\\n        return currVal.rbegin()->second;\\n    }\\n    \\n    int maximum() {\\n        return *(sec.rbegin());\\n    }\\n    \\n    int minimum() {\\n        return *(sec.begin());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    unordered_map<int, pair<int, multiset<int> :: iterator>> mp;\\n    multiset<int> sec;\\n    map<int, int> currVal;\\n    \\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if (!mp.count(timestamp)) {\\n            auto it = sec.insert(price);\\n            mp[timestamp] = make_pair(price, it);\\n            currVal[timestamp] = price;\\n        } else {\\n            auto it = mp[timestamp].second;\\n            sec.erase(it);\\n            it = sec.insert(price);\\n            mp[timestamp] = make_pair(price, it);\\n            currVal[timestamp] = price;\\n        }\\n    }\\n    \\n    int current() {\\n        return currVal.rbegin()->second;\\n    }\\n    \\n    int maximum() {\\n        return *(sec.rbegin());\\n    }\\n    \\n    int minimum() {\\n        return *(sec.begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857370,
                "title": "c-simple-solution",
                "content": "1. Solution was pretty simple. Use 2 priority queue ( one max and one min), I thought this might increase the data usage but it didnt. \\n2. Keep returning the root of the priority queue when min, max are queried.\\n3. Also, maintain a map of the timetamp vs price to keep a check on the price of the stock at a particular timestamp.\\n```\\nclass StockPrice {\\npublic:\\n\\t//stores timestamp and price hash table\\n    unordered_map<int, int> stock_price;\\n\\t\\n\\t//priority queue to keep the max value on the root\\n    priority_queue<pair<int, int>> max_value_queue;\\n\\t\\n\\t//priority queue to keep the min value on the root\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_value_queue;\\n    \\n\\t//latest timestamp recieved so far\\n    int latest_timestamp;\\n\\t\\n\\t//price at the latest timestamp\\n    int latest_price;\\n\\t\\n    StockPrice() {\\n        //initialise\\n        latest_timestamp = -1;\\n        latest_price = -1;\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        pair<int, int> new_data;\\n        new_data.first = price;\\n        new_data.second = timestamp;\\n\\t\\t\\n\\t\\t//save the data to the map\\n        stock_price[timestamp] = price;\\n\\t\\t\\n\\t\\t//push the data to the max heap\\n        max_value_queue.push(new_data);\\n\\t\\t\\n\\t\\t//push the data to the min heap\\n        min_value_queue.push(new_data);\\n        \\n\\t\\t//update the latest timestamp\\n        if ( timestamp > latest_timestamp ) {\\n            latest_timestamp = timestamp;\\n            latest_price = price;\\n        }\\n\\t\\t\\n\\t\\t//see if the latest price is being updated\\n        if ( timestamp == latest_timestamp ) {\\n            latest_price = price;\\n        }\\n    }\\n    \\n    int current() {\\n\\t\\t//return the latest price\\n        return latest_price;\\n    }\\n    \\n    int maximum() {\\n        pair<int, int> max_data;\\n\\t\\t//keep checking if the priority queue top is the latest price of the timestamp and if so, return the value, else delete that node and pop the queue untill you find a valid <price, timestamp> pair on top of the queue\\n        while ( !max_value_queue.empty() ) {\\n            max_data = max_value_queue.top();\\n            int timestamp = max_data.second;\\n            int price = max_data.first;\\n            if ( stock_price[timestamp] != price ) {\\n                max_value_queue.pop();\\n            }\\n            else {\\n                return price;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    int minimum() {\\n        pair<int, int> max_data;\\n\\t\\t\\n\\t\\t////keep checking if the priority queue top is the latest price of the timestamp and if so, return the value, else delete that node and pop the queue untill you find a valid <price, timestamp> pair on top of the queue\\n        while ( !min_value_queue.empty() ) {\\n            max_data = min_value_queue.top();\\n            int timestamp = max_data.second;\\n            int price = max_data.first;\\n            if ( stock_price[timestamp] != price ) {\\n                min_value_queue.pop();\\n            }\\n            else {\\n                return price;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n ```",
                "solutionTags": [
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n\\t//stores timestamp and price hash table\\n    unordered_map<int, int> stock_price;\\n\\t\\n\\t//priority queue to keep the max value on the root\\n    priority_queue<pair<int, int>> max_value_queue;\\n\\t\\n\\t//priority queue to keep the min value on the root\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_value_queue;\\n    \\n\\t//latest timestamp recieved so far\\n    int latest_timestamp;\\n\\t\\n\\t//price at the latest timestamp\\n    int latest_price;\\n\\t\\n    StockPrice() {\\n        //initialise\\n        latest_timestamp = -1;\\n        latest_price = -1;\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        pair<int, int> new_data;\\n        new_data.first = price;\\n        new_data.second = timestamp;\\n\\t\\t\\n\\t\\t//save the data to the map\\n        stock_price[timestamp] = price;\\n\\t\\t\\n\\t\\t//push the data to the max heap\\n        max_value_queue.push(new_data);\\n\\t\\t\\n\\t\\t//push the data to the min heap\\n        min_value_queue.push(new_data);\\n        \\n\\t\\t//update the latest timestamp\\n        if ( timestamp > latest_timestamp ) {\\n            latest_timestamp = timestamp;\\n            latest_price = price;\\n        }\\n\\t\\t\\n\\t\\t//see if the latest price is being updated\\n        if ( timestamp == latest_timestamp ) {\\n            latest_price = price;\\n        }\\n    }\\n    \\n    int current() {\\n\\t\\t//return the latest price\\n        return latest_price;\\n    }\\n    \\n    int maximum() {\\n        pair<int, int> max_data;\\n\\t\\t//keep checking if the priority queue top is the latest price of the timestamp and if so, return the value, else delete that node and pop the queue untill you find a valid <price, timestamp> pair on top of the queue\\n        while ( !max_value_queue.empty() ) {\\n            max_data = max_value_queue.top();\\n            int timestamp = max_data.second;\\n            int price = max_data.first;\\n            if ( stock_price[timestamp] != price ) {\\n                max_value_queue.pop();\\n            }\\n            else {\\n                return price;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    int minimum() {\\n        pair<int, int> max_data;\\n\\t\\t\\n\\t\\t////keep checking if the priority queue top is the latest price of the timestamp and if so, return the value, else delete that node and pop the queue untill you find a valid <price, timestamp> pair on top of the queue\\n        while ( !min_value_queue.empty() ) {\\n            max_data = min_value_queue.top();\\n            int timestamp = max_data.second;\\n            int price = max_data.first;\\n            if ( stock_price[timestamp] != price ) {\\n                min_value_queue.pop();\\n            }\\n            else {\\n                return price;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1781448,
                "title": "2-heap-solution-clean-with-comments",
                "content": "keep a simple hash map, mapping timestamps to values\\n then also keep the max_time seen and its_value, when you\\n want to get the current check for that\\n you also need to keep a min heap and a max heap\\n everytime you see a new element, you push it to the heaps (after updating the value)\\n when you want to get the max or min, check validity whether they match their hash values\\n the optimization? what if we have many corrections? heap will get too large. But how big it gets would not impact log n operations.\\n for sure space is an issue here. Maybe we can recycle heaps every 1000 operations to make sure what is there matches what are on the hash maps\\n\\n\\n```\\nfrom heapq import heappush, heappop\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.max_time = 0\\n        self.current_vaue = 0\\n        self.stock = {}\\n        self.max_heap = []\\n        self.min_heap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.stock[timestamp] = price\\n        heappush(self.max_heap, (-price,timestamp))\\n        heappush(self.min_heap, (price,timestamp))\\n        if timestamp >= self.max_time:\\n            self.max_time = timestamp\\n            self.current_vaue = price\\n\\n    def current(self) -> int:\\n        return self.current_vaue\\n\\n    def maximum(self) -> int:\\n        while self.stock[self.max_heap[0][1]] != - self.max_heap[0][0]:\\n            heappop(self.max_heap)\\n        return -self.max_heap[0][0] \\n\\n    def minimum(self) -> int:\\n        while self.stock[self.min_heap[0][1]] != self.min_heap[0][0]:\\n            heappop(self.min_heap)\\n        return self.min_heap[0][0]        \\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "keep a simple hash map, mapping timestamps to values\\n then also keep the max_time seen and its_value, when you\\n want to get the current check for that\\n you also need to keep a min heap and a max heap\\n everytime you see a new element, you push it to the heaps (after updating the value)\\n when you want to get the max or min, check validity whether they match their hash values\\n the optimization? what if we have many corrections? heap will get too large. But how big it gets would not impact log n operations.\\n for sure space is an issue here. Maybe we can recycle heaps every 1000 operations to make sure what is there matches what are on the hash maps\\n\\n\\n```\\nfrom heapq import heappush, heappop\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.max_time = 0\\n        self.current_vaue = 0\\n        self.stock = {}\\n        self.max_heap = []\\n        self.min_heap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.stock[timestamp] = price\\n        heappush(self.max_heap, (-price,timestamp))\\n        heappush(self.min_heap, (price,timestamp))\\n        if timestamp >= self.max_time:\\n            self.max_time = timestamp\\n            self.current_vaue = price\\n\\n    def current(self) -> int:\\n        return self.current_vaue\\n\\n    def maximum(self) -> int:\\n        while self.stock[self.max_heap[0][1]] != - self.max_heap[0][0]:\\n            heappop(self.max_heap)\\n        return -self.max_heap[0][0] \\n\\n    def minimum(self) -> int:\\n        while self.stock[self.min_heap[0][1]] != self.min_heap[0][0]:\\n            heappop(self.min_heap)\\n        return self.min_heap[0][0]        \\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1726317,
                "title": "easy-js-solution-using-2-heaps-with-intuition",
                "content": "**Intuition:**  \\n\\nThe Idea is to use two map, one for Min Heap and another one for Max Heap that will store a property \"index\".\\n\\nThe use of index property is to delete the entry alongwith price from heap(either min or max) in logarithmic time whenever there is an update in price for past timestamps.\\n\\nThe index key is autogenerated in Heap class whenever there is an insert in heap, which allow us to track the position of Price in minHeap or maxHeap.\\n\\nSo everythin happens at \"update\" function. \\n\\n1. When there is an new price at particular timestamp. Insert them in minHeap and maxHeap.\\n2. When there is update in price in past timestamp. Delete that entry both from minHeap and maxHeap, which takes only O(log N) time. Later insert the updated price in Heaps again.\\n\\n**update** takes around  4O(logN) time\\n**current, maximum and minimum** takes O(1) time\\n\\nSpace complexity is 2O(N). A little more then the approach with single Map given here: https://leetcode.com/problems/stock-price-fluctuation/discuss/1613602/JS-100\\n\\n```\\n\\nvar StockPrice = function() {\\n    this.maxMap = new Map();\\n    this.minMap = new Map();\\n    \\n    this.maxHeap = new Heap((a,b) => {\\n        return a.price < b.price\\n    },  Infinity);\\n    \\n    this.minHeap = new Heap((a,b) => {\\n        return a.price > b.price\\n    },  -Infinity);\\n    \\n    this.currentTime = 0;\\n    this.currentPrice = null;\\n};\\n\\n/** \\n * @param {number} timestamp \\n * @param {number} price\\n * @return {void}\\n */\\nStockPrice.prototype.update = function(timestamp, price) {\\n   //Remove past timestamps from minHeap and maxHeap\\n    if(this.maxMap.has(timestamp)) {\\n        let prev1 = this.maxMap.get(timestamp);\\n        this.maxHeap.remove(prev1.index);\\n    }\\n    \\n    if(this.minMap.has(timestamp)) {\\n        let prev2 = this.minMap.get(timestamp);\\n        this.minHeap.remove(prev2.index);\\n    }\\n    \\n    let data1 = { price: price };\\n    this.maxMap.set(timestamp, data1);\\n    \\n    let data2 = { price: price };\\n    this.minMap.set(timestamp, data2);\\n        \\n    this.maxHeap.insert(data1);\\n    this.minHeap.insert(data2);\\n    \\n    if(this.currentTime <= timestamp){\\n        this.currentTime = timestamp;\\n        this.currentPrice = price;\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.current = function() {\\n    return this.currentPrice;\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.maximum = function() {\\n    return this.maxHeap.peek().price;\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.minimum = function() {\\n    return this.minHeap.peek().price;\\n};\\n\\n\\nclass Heap {\\n\\tconstructor(compare, value) {\\n\\t\\tthis.heap = [];\\n        this.compare = compare;\\n        this.value = value;\\n\\t}\\n\\t\\n    leftChild(index) {\\n        return index * 2 + 1;\\n    }\\n\\n    rightChild(index) {\\n        return index * 2 + 2;\\n    }\\n\\n    parent(index) {\\n        return Math.floor((index\\u200A-\\u200A1) / 2);\\n    }\\n\\t\\n    insert(element) { //log n)\\n       this.heap.push(element);\\n\\t   \\n       // the index of the element we have just pushed\\n       let i = this.heap.length\\u200A-\\u200A1;\\n       element.index = i;\\n\\t   \\n       this.__bubbleUp(i);\\n    }\\n\\n    __bubbleUp(i) {\\n      // if the element is greater than its parent:\\n      // swap element with its parent\\n      //Bubble Up / Sift Up\\n      while(i > 0) {\\n        let p = this.parent(i);\\n\\n         if( this.compare(this.heap[p], this.heap[i]) ) {\\n                let temp = this.heap[i];\\n                this.heap[i] = this.heap[p];\\n                this.heap[p] = temp;\\n             \\n                this.heap[i].index = i;\\n                this.heap[p].index = p;\\n                i = p;\\n          } else {\\n               break;\\n          }\\n       }\\n     }\\n\\t \\n\\t extractMax() {\\n         if(this.heap.length === 1)\\n             return this.heap.pop();\\n\\n        let data = this.heap;\\n\\n        // stroing maximum value\\n        let root = data[0];\\n         \\n        // making root equal to the last element\\n        let end = data.pop();\\n\\n        data[0] = end;\\n        data[0].index = 0;\\n         \\n        let eIdx = data.length - 1;\\n\\n        // correctly re-position heap\\n        // as root is not following max-heap property\\n        this.__siftDown(0, eIdx);\\n\\n        return root;\\n\\t }\\n\\t \\n     __siftDown(start, end) {//O(log n)\\n         let left = this.leftChild(start);\\n         let right = this.rightChild(start);\\n\\n         let largest;\\n\\n         if(\\n             (left <= end) && \\n             this.heap[start] &&\\n             this.heap[left] &&\\n             ( this.compare(this.heap[start], this.heap[left]) )\\n           ) {\\n             largest = left\\n            } else  {\\n                 largest = start;\\n          }\\n\\n         if(\\n             (right <= end) && \\n             this.heap[largest] && \\n             this.heap[right] && \\n             ( this.compare(this.heap[largest], this.heap[right]) )\\n         ) {\\n             largest = right;\\n         }\\n\\n         if(largest !== start) {\\n             const tmp = this.heap[largest];\\n             this.heap[largest] = this.heap[start];\\n             this.heap[start] = tmp;\\n             \\n             this.heap[largest].index = largest;\\n             this.heap[start].index = start;\\n             \\n             this.__siftDown(largest, end);\\n         }\\n     }\\n    \\n    remove(pos) {\\n        this.heap[pos].price = this.value;\\n        this.__bubbleUp(pos);\\n        this.extractMax();\\n    }\\n\\t \\n     peek() {\\n         // the root is always the highest priority item\\n         return this.heap[0];\\n     }\\n\\t \\n}\\n\\n/** \\n * Your StockPrice object will be instantiated and called as such:\\n * var obj = new StockPrice()\\n * obj.update(timestamp,price)\\n * var param_2 = obj.current()\\n * var param_3 = obj.maximum()\\n * var param_4 = obj.minimum()\\n */\\n ```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nvar StockPrice = function() {\\n    this.maxMap = new Map();\\n    this.minMap = new Map();\\n    \\n    this.maxHeap = new Heap((a,b) => {\\n        return a.price < b.price\\n    },  Infinity);\\n    \\n    this.minHeap = new Heap((a,b) => {\\n        return a.price > b.price\\n    },  -Infinity);\\n    \\n    this.currentTime = 0;\\n    this.currentPrice = null;\\n};\\n\\n/** \\n * @param {number} timestamp \\n * @param {number} price\\n * @return {void}\\n */\\nStockPrice.prototype.update = function(timestamp, price) {\\n   //Remove past timestamps from minHeap and maxHeap\\n    if(this.maxMap.has(timestamp)) {\\n        let prev1 = this.maxMap.get(timestamp);\\n        this.maxHeap.remove(prev1.index);\\n    }\\n    \\n    if(this.minMap.has(timestamp)) {\\n        let prev2 = this.minMap.get(timestamp);\\n        this.minHeap.remove(prev2.index);\\n    }\\n    \\n    let data1 = { price: price };\\n    this.maxMap.set(timestamp, data1);\\n    \\n    let data2 = { price: price };\\n    this.minMap.set(timestamp, data2);\\n        \\n    this.maxHeap.insert(data1);\\n    this.minHeap.insert(data2);\\n    \\n    if(this.currentTime <= timestamp){\\n        this.currentTime = timestamp;\\n        this.currentPrice = price;\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.current = function() {\\n    return this.currentPrice;\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.maximum = function() {\\n    return this.maxHeap.peek().price;\\n};\\n\\n/**\\n * @return {number}\\n */\\nStockPrice.prototype.minimum = function() {\\n    return this.minHeap.peek().price;\\n};\\n\\n\\nclass Heap {\\n\\tconstructor(compare, value) {\\n\\t\\tthis.heap = [];\\n        this.compare = compare;\\n        this.value = value;\\n\\t}\\n\\t\\n    leftChild(index) {\\n        return index * 2 + 1;\\n    }\\n\\n    rightChild(index) {\\n        return index * 2 + 2;\\n    }\\n\\n    parent(index) {\\n        return Math.floor((index\\u200A-\\u200A1) / 2);\\n    }\\n\\t\\n    insert(element) { //log n)\\n       this.heap.push(element);\\n\\t   \\n       // the index of the element we have just pushed\\n       let i = this.heap.length\\u200A-\\u200A1;\\n       element.index = i;\\n\\t   \\n       this.__bubbleUp(i);\\n    }\\n\\n    __bubbleUp(i) {\\n      // if the element is greater than its parent:\\n      // swap element with its parent\\n      //Bubble Up / Sift Up\\n      while(i > 0) {\\n        let p = this.parent(i);\\n\\n         if( this.compare(this.heap[p], this.heap[i]) ) {\\n                let temp = this.heap[i];\\n                this.heap[i] = this.heap[p];\\n                this.heap[p] = temp;\\n             \\n                this.heap[i].index = i;\\n                this.heap[p].index = p;\\n                i = p;\\n          } else {\\n               break;\\n          }\\n       }\\n     }\\n\\t \\n\\t extractMax() {\\n         if(this.heap.length === 1)\\n             return this.heap.pop();\\n\\n        let data = this.heap;\\n\\n        // stroing maximum value\\n        let root = data[0];\\n         \\n        // making root equal to the last element\\n        let end = data.pop();\\n\\n        data[0] = end;\\n        data[0].index = 0;\\n         \\n        let eIdx = data.length - 1;\\n\\n        // correctly re-position heap\\n        // as root is not following max-heap property\\n        this.__siftDown(0, eIdx);\\n\\n        return root;\\n\\t }\\n\\t \\n     __siftDown(start, end) {//O(log n)\\n         let left = this.leftChild(start);\\n         let right = this.rightChild(start);\\n\\n         let largest;\\n\\n         if(\\n             (left <= end) && \\n             this.heap[start] &&\\n             this.heap[left] &&\\n             ( this.compare(this.heap[start], this.heap[left]) )\\n           ) {\\n             largest = left\\n            } else  {\\n                 largest = start;\\n          }\\n\\n         if(\\n             (right <= end) && \\n             this.heap[largest] && \\n             this.heap[right] && \\n             ( this.compare(this.heap[largest], this.heap[right]) )\\n         ) {\\n             largest = right;\\n         }\\n\\n         if(largest !== start) {\\n             const tmp = this.heap[largest];\\n             this.heap[largest] = this.heap[start];\\n             this.heap[start] = tmp;\\n             \\n             this.heap[largest].index = largest;\\n             this.heap[start].index = start;\\n             \\n             this.__siftDown(largest, end);\\n         }\\n     }\\n    \\n    remove(pos) {\\n        this.heap[pos].price = this.value;\\n        this.__bubbleUp(pos);\\n        this.extractMax();\\n    }\\n\\t \\n     peek() {\\n         // the root is always the highest priority item\\n         return this.heap[0];\\n     }\\n\\t \\n}\\n\\n/** \\n * Your StockPrice object will be instantiated and called as such:\\n * var obj = new StockPrice()\\n * obj.update(timestamp,price)\\n * var param_2 = obj.current()\\n * var param_3 = obj.maximum()\\n * var param_4 = obj.minimum()\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1711886,
                "title": "python-sortedlist-hashmap",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.records = {}\\n        self.maxTimeStamp = 0\\n        self.prices = SortedList()\\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        \\n        if timestamp in self.records:\\n            origPrice = self.records[timestamp]\\n            #log(n) time\\n            self.prices.remove(origPrice)\\n        #log(n) time    \\n        self.prices.add(price)\\n        self.records[timestamp] = price\\n        self.maxTimeStamp = max(self.maxTimeStamp, timestamp)\\n        \\n\\n    def current(self) -> int:\\n        #O(1) time\\n        return self.records[self.maxTimeStamp]\\n\\n    def maximum(self) -> int:\\n        #log(n) time\\n        return self.prices[-1]\\n\\n    def minimum(self) -> int:\\n        #log(n) time\\n        return self.prices[0]\\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.records = {}\\n        self.maxTimeStamp = 0\\n        self.prices = SortedList()\\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        \\n        if timestamp in self.records:\\n            origPrice = self.records[timestamp]\\n            #log(n) time\\n            self.prices.remove(origPrice)\\n        #log(n) time    \\n        self.prices.add(price)\\n        self.records[timestamp] = price\\n        self.maxTimeStamp = max(self.maxTimeStamp, timestamp)\\n        \\n\\n    def current(self) -> int:\\n        #O(1) time\\n        return self.records[self.maxTimeStamp]\\n\\n    def maximum(self) -> int:\\n        #log(n) time\\n        return self.prices[-1]\\n\\n    def minimum(self) -> int:\\n        #log(n) time\\n        return self.prices[0]\\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704128,
                "title": "java-treemap",
                "content": "```\\nclass StockPrice {\\n    TreeMap<Integer, Integer> stockPrice; // timestamp -> stockValue\\n    TreeMap<Integer, Set<Integer>> values; // stockValue -> a list of timeStamps\\n\\n    public StockPrice() {\\n        stockPrice = new TreeMap<Integer, Integer>();\\n        values = new TreeMap<Integer, Set<Integer>>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (stockPrice.containsKey(timestamp)) {\\n            int priceAtThisTS = stockPrice.get(timestamp);\\n            if (priceAtThisTS != price) {\\n                Set<Integer> timeStamps = values.get(priceAtThisTS);\\n                timeStamps.remove(timestamp);\\n                if (timeStamps.size() == 0) {\\n                    values.remove(priceAtThisTS);\\n                }\\n            }\\n        }\\n        stockPrice.put(timestamp, price);\\n        values.putIfAbsent(price, new HashSet<Integer>());\\n        values.get(price).add(timestamp);\\n    }\\n    \\n    public int current() {\\n        return stockPrice.lastEntry().getValue();\\n    }\\n    \\n    public int maximum() {\\n        return values.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return values.firstKey();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n    TreeMap<Integer, Integer> stockPrice; // timestamp -> stockValue\\n    TreeMap<Integer, Set<Integer>> values; // stockValue -> a list of timeStamps\\n\\n    public StockPrice() {\\n        stockPrice = new TreeMap<Integer, Integer>();\\n        values = new TreeMap<Integer, Set<Integer>>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (stockPrice.containsKey(timestamp)) {\\n            int priceAtThisTS = stockPrice.get(timestamp);\\n            if (priceAtThisTS != price) {\\n                Set<Integer> timeStamps = values.get(priceAtThisTS);\\n                timeStamps.remove(timestamp);\\n                if (timeStamps.size() == 0) {\\n                    values.remove(priceAtThisTS);\\n                }\\n            }\\n        }\\n        stockPrice.put(timestamp, price);\\n        values.putIfAbsent(price, new HashSet<Integer>());\\n        values.get(price).add(timestamp);\\n    }\\n    \\n    public int current() {\\n        return stockPrice.lastEntry().getValue();\\n    }\\n    \\n    public int maximum() {\\n        return values.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return values.firstKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687107,
                "title": "2034-stock-price-fluctuation-c-multiset-unordered-map",
                "content": "* void update(int timestamp, int price) : `O(logN)`. \\n* int current() :`O(1)`.\\n* int maximum() : `O(1)`.\\n* int minimum() : `O(1)`.\\n\\n```\\nclass StockPrice {\\npublic:\\n    int current_timestamp;\\n    unordered_map<int, int> timestamp_price;\\n    multiset<pair<int, int>> price_timestamp;\\n    StockPrice() {\\n        current_timestamp = 0;\\n        timestamp_price.clear();\\n        price_timestamp.clear();\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        current_timestamp = max(current_timestamp, timestamp);\\n        if(timestamp_price.count(timestamp)){\\n            auto it = price_timestamp.find({timestamp_price[timestamp], timestamp});\\n            price_timestamp.erase(it);\\n            price_timestamp.insert({price, timestamp});\\n            timestamp_price[timestamp] = price;\\n        }\\n        else{\\n            timestamp_price[timestamp] = price;\\n            price_timestamp.insert({price, timestamp});\\n        }\\n    }\\n    \\n    int current() {\\n        return timestamp_price[current_timestamp];\\n    }\\n    \\n    int maximum() {\\n        return price_timestamp.rbegin()->first;\\n    }\\n    \\n    int minimum() {\\n        return price_timestamp.begin()->first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    int current_timestamp;\\n    unordered_map<int, int> timestamp_price;\\n    multiset<pair<int, int>> price_timestamp;\\n    StockPrice() {\\n        current_timestamp = 0;\\n        timestamp_price.clear();\\n        price_timestamp.clear();\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        current_timestamp = max(current_timestamp, timestamp);\\n        if(timestamp_price.count(timestamp)){\\n            auto it = price_timestamp.find({timestamp_price[timestamp], timestamp});\\n            price_timestamp.erase(it);\\n            price_timestamp.insert({price, timestamp});\\n            timestamp_price[timestamp] = price;\\n        }\\n        else{\\n            timestamp_price[timestamp] = price;\\n            price_timestamp.insert({price, timestamp});\\n        }\\n    }\\n    \\n    int current() {\\n        return timestamp_price[current_timestamp];\\n    }\\n    \\n    int maximum() {\\n        return price_timestamp.rbegin()->first;\\n    }\\n    \\n    int minimum() {\\n        return price_timestamp.begin()->first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650979,
                "title": "java-simple-solution-using-treemap",
                "content": "Approach: My first thought was to maintain all the stock prices in a TreeSet to get the lowest and highest stock prices in O(1). But if multiple timestamps have the same stock price, this wont work when we update the stock price. So, used a TreeMap storing the stocks and their frequencies. \\n```\\nclass StockPrice {\\n\\n    Map<Integer, Integer> timestampStock;\\n    int latestTimestamp;\\n    TreeMap<Integer, Integer> stockFrequency;\\n    \\n    public StockPrice() {\\n        timestampStock = new HashMap<>();\\n        stockFrequency = new TreeMap<>();\\n        latestTimestamp = 0;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        latestTimestamp = Math.max(latestTimestamp, timestamp);\\n        int prevStockPrice = timestampStock.getOrDefault(timestamp, 0);\\n        if (prevStockPrice != 0) {\\n            int curStockFreq = stockFrequency.get(prevStockPrice);\\n            if (curStockFreq == 1)\\n                stockFrequency.remove(prevStockPrice);\\n            else\\n                stockFrequency.put(prevStockPrice, curStockFreq-1);\\n        }\\n        stockFrequency.put(price, stockFrequency.getOrDefault(price, 0)+1);\\n        timestampStock.put(timestamp, price);\\n        \\n    }\\n    \\n    public int current() {\\n        return timestampStock.get(latestTimestamp);\\n    }\\n    \\n    public int maximum() {\\n        return stockFrequency.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return stockFrequency.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n\\n    Map<Integer, Integer> timestampStock;\\n    int latestTimestamp;\\n    TreeMap<Integer, Integer> stockFrequency;\\n    \\n    public StockPrice() {\\n        timestampStock = new HashMap<>();\\n        stockFrequency = new TreeMap<>();\\n        latestTimestamp = 0;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        latestTimestamp = Math.max(latestTimestamp, timestamp);\\n        int prevStockPrice = timestampStock.getOrDefault(timestamp, 0);\\n        if (prevStockPrice != 0) {\\n            int curStockFreq = stockFrequency.get(prevStockPrice);\\n            if (curStockFreq == 1)\\n                stockFrequency.remove(prevStockPrice);\\n            else\\n                stockFrequency.put(prevStockPrice, curStockFreq-1);\\n        }\\n        stockFrequency.put(price, stockFrequency.getOrDefault(price, 0)+1);\\n        timestampStock.put(timestamp, price);\\n        \\n    }\\n    \\n    public int current() {\\n        return timestampStock.get(latestTimestamp);\\n    }\\n    \\n    public int maximum() {\\n        return stockFrequency.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return stockFrequency.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603597,
                "title": "javascript-es6-two-heaps-comments-with-complexity-analysis",
                "content": "\\n* when we update, we can record max and min to return in O(1) time \\n* hashmap will store { timestamp : price} and can be added and updated in O(1)\\n* keep a constant for latest timestamp and look up in hashmap for current()\\n\\n** problem with getting max and mins in O(N) time here. since we can update an old timestamp and have a price be adjusted, an old max/min may no longer be valid.\\n* using a heap here for max and mins and check vs hashmap for timestamp:price verification \\nmaxHeap: [[timestamp, price]] priority by price. when getting max, check price vs hashmap[timestamp]. if match, return, else pop heap\\n\\nfor N timestamps\\nT: O(1) to update hashmap, and 2 * O(logN) to put in each heap heaps, O(1) to check for latest timestamp, O(1) to look up price in hashmap, O(1) for max and min\\nS: 2*O(N) for 2 heaps space, O(N) for hashmap => O(N)\\n\\n```\\nclass Heap{\\n    constructor(func){\\n        this.heap = [];\\n        this.func = func;\\n    }\\n    siftDown(idx,end,heap){\\n        let child1 = idx*2+1;\\n        while (child1 <= end){\\n            let child2 = idx*2+2 <= end ? idx*2+2 : -1;\\n            let swapIdx;\\n            if (child2 !== -1 && this.shouldSwap(child2,child1)){\\n                swapIdx = child2;\\n            } else {\\n                swapIdx = child1;\\n            }\\n            if (this.shouldSwap(swapIdx,idx)){\\n                this.swap(swapIdx,idx,heap);\\n                idx = swapIdx;\\n                child1 = idx*2+1;\\n            } else return;\\n        }\\n    }\\n    siftUp(idx, heap){\\n        let parent = Math.floor((idx-1)/2);\\n        while (idx > 0 && this.shouldSwap(idx,parent)){\\n            this.swap(idx,parent,heap);\\n            idx = parent;\\n            parent = Math.floor((idx-1)/2);\\n        }\\n    }\\n    peek(){\\n        return this.heap[0];\\n    }\\n    poll(){\\n        this.swap(0, this.heap.length-1, this.heap);\\n        let valueToReturn = this.heap.pop();\\n        this.siftDown(0, this.heap.length-1, this.heap);\\n        return valueToReturn;\\n    }\\n    offer(val){\\n        this.heap.push(val);\\n        this.siftUp(this.heap.length-1, this.heap);\\n    }\\n    isEmpty(){\\n        return this.heap.length === 0;\\n    }\\n    size(){\\n        return this.heap.length;\\n    }\\n    swap(i,j,heap){\\n        [heap[i],heap[j]] = [heap[j],heap[i]];\\n    }\\n    shouldSwap(idx1,idx2){\\n        return this.func(this.heap[idx1],this.heap[idx2]);\\n    }\\n}\\n\\nclass StockPrice{\\n    constructor(){\\n        this.max = new Heap((a,b) => a[1] > b[1]);\\n        this.min = new Heap((a,b) => a[1] < b[1]);\\n        this.latestTime = -1;\\n        this.prices = {};\\n    }\\n    update(timestamp, price){\\n        // update price in map\\n        this.prices[timestamp] = price;\\n        // update max\\n        this.max.offer([timestamp, price]);\\n        while (this.max.peek()[1] !== this.prices[this.max.peek()[0]]) this.max.poll();\\n        // update min\\n        this.min.offer([timestamp, price]);\\n        while (this.min.peek()[1] !== this.prices[this.min.peek()[0]]) this.min.poll();\\n        // update latest time\\n        this.latestTime = Math.max(this.latestTime, timestamp);\\n    }\\n    current(){ // O(1)\\n        return this.prices[this.latestTime]; \\n    }\\n    maximum(){ // O(1)\\n        return this.max.peek()[1];\\n    }\\n    minimum(){ // O(1)\\n        return this.min.peek()[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Heap{\\n    constructor(func){\\n        this.heap = [];\\n        this.func = func;\\n    }\\n    siftDown(idx,end,heap){\\n        let child1 = idx*2+1;\\n        while (child1 <= end){\\n            let child2 = idx*2+2 <= end ? idx*2+2 : -1;\\n            let swapIdx;\\n            if (child2 !== -1 && this.shouldSwap(child2,child1)){\\n                swapIdx = child2;\\n            } else {\\n                swapIdx = child1;\\n            }\\n            if (this.shouldSwap(swapIdx,idx)){\\n                this.swap(swapIdx,idx,heap);\\n                idx = swapIdx;\\n                child1 = idx*2+1;\\n            } else return;\\n        }\\n    }\\n    siftUp(idx, heap){\\n        let parent = Math.floor((idx-1)/2);\\n        while (idx > 0 && this.shouldSwap(idx,parent)){\\n            this.swap(idx,parent,heap);\\n            idx = parent;\\n            parent = Math.floor((idx-1)/2);\\n        }\\n    }\\n    peek(){\\n        return this.heap[0];\\n    }\\n    poll(){\\n        this.swap(0, this.heap.length-1, this.heap);\\n        let valueToReturn = this.heap.pop();\\n        this.siftDown(0, this.heap.length-1, this.heap);\\n        return valueToReturn;\\n    }\\n    offer(val){\\n        this.heap.push(val);\\n        this.siftUp(this.heap.length-1, this.heap);\\n    }\\n    isEmpty(){\\n        return this.heap.length === 0;\\n    }\\n    size(){\\n        return this.heap.length;\\n    }\\n    swap(i,j,heap){\\n        [heap[i],heap[j]] = [heap[j],heap[i]];\\n    }\\n    shouldSwap(idx1,idx2){\\n        return this.func(this.heap[idx1],this.heap[idx2]);\\n    }\\n}\\n\\nclass StockPrice{\\n    constructor(){\\n        this.max = new Heap((a,b) => a[1] > b[1]);\\n        this.min = new Heap((a,b) => a[1] < b[1]);\\n        this.latestTime = -1;\\n        this.prices = {};\\n    }\\n    update(timestamp, price){\\n        // update price in map\\n        this.prices[timestamp] = price;\\n        // update max\\n        this.max.offer([timestamp, price]);\\n        while (this.max.peek()[1] !== this.prices[this.max.peek()[0]]) this.max.poll();\\n        // update min\\n        this.min.offer([timestamp, price]);\\n        while (this.min.peek()[1] !== this.prices[this.min.peek()[0]]) this.min.poll();\\n        // update latest time\\n        this.latestTime = Math.max(this.latestTime, timestamp);\\n    }\\n    current(){ // O(1)\\n        return this.prices[this.latestTime]; \\n    }\\n    maximum(){ // O(1)\\n        return this.max.peek()[1];\\n    }\\n    minimum(){ // O(1)\\n        return this.min.peek()[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603257,
                "title": "java-100",
                "content": "```\\nclass StockPrice {\\n    \\n    PriorityQueue<int[]> min = new PriorityQueue<>((arr1, arr2) -> arr1[1] - arr2[1]);\\n    PriorityQueue<int[]> max = new PriorityQueue<>((arr1, arr2) -> arr2[1] - arr1[1]);\\n    \\n    Map<Integer, Integer> registry = new HashMap<>();\\n    int current = -1;\\n    \\n    public StockPrice() {\\n        \\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        int[] elem = new int[] {timestamp, price};\\n        registry.put(timestamp, price);\\n        min.add(elem);\\n        max.add(elem);\\n        \\n        if (timestamp > current) {\\n            current = timestamp;\\n        }\\n    }\\n    \\n    public int current() {\\n        return registry.get(current);    \\n    }\\n    \\n    public int maximum() {\\n        while (!peekIsValid(max)) {\\n            int[] elem = max.poll();\\n            max.add(new int[] {elem[0], registry.get(elem[0])});\\n        }\\n        return max.peek()[1];\\n    }\\n    \\n    public int minimum() {\\n        while (!peekIsValid(min)) {\\n            int[] elem = min.poll();\\n            min.add(new int[] {elem[0], registry.get(elem[0])});\\n        }\\n        return min.peek()[1];\\n    }\\n    \\n    private boolean peekIsValid(PriorityQueue<int[]> pq) {\\n        int[] elem = pq.peek();\\n        return registry.get(elem[0]) == elem[1];        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n    \\n    PriorityQueue<int[]> min = new PriorityQueue<>((arr1, arr2) -> arr1[1] - arr2[1]);\\n    PriorityQueue<int[]> max = new PriorityQueue<>((arr1, arr2) -> arr2[1] - arr1[1]);\\n    \\n    Map<Integer, Integer> registry = new HashMap<>();\\n    int current = -1;\\n    \\n    public StockPrice() {\\n        \\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        int[] elem = new int[] {timestamp, price};\\n        registry.put(timestamp, price);\\n        min.add(elem);\\n        max.add(elem);\\n        \\n        if (timestamp > current) {\\n            current = timestamp;\\n        }\\n    }\\n    \\n    public int current() {\\n        return registry.get(current);    \\n    }\\n    \\n    public int maximum() {\\n        while (!peekIsValid(max)) {\\n            int[] elem = max.poll();\\n            max.add(new int[] {elem[0], registry.get(elem[0])});\\n        }\\n        return max.peek()[1];\\n    }\\n    \\n    public int minimum() {\\n        while (!peekIsValid(min)) {\\n            int[] elem = min.poll();\\n            min.add(new int[] {elem[0], registry.get(elem[0])});\\n        }\\n        return min.peek()[1];\\n    }\\n    \\n    private boolean peekIsValid(PriorityQueue<int[]> pq) {\\n        int[] elem = pq.peek();\\n        return registry.get(elem[0]) == elem[1];        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561980,
                "title": "python-god-level-double-heap-hashmap-solution-with-explanation",
                "content": "We can use a min and max heap to keep track on the maximums. Because prices can change at a given timestamp, we need to somehow delete previous prices added at timestamps that were overriden. We can do this lazily by keeping track of the number of changes at each timestamp. When we\\'re getting from the min/max heap, we check if this is the latest price at the timestamp by checking the change number against the current number of changes recorded at the timestamp. If it doesn\\'t match up, then we can delete, otherwise, we have an answer for the min/max.\\n\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.minHeap = []\\n        self.maxHeap = []\\n        self.timestampToChanges = defaultdict(int)\\n        self.latestTimestamp = -1\\n        self.latestPrice = 0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp >= self.latestTimestamp:\\n            self.latestTimestamp = timestamp\\n            self.latestPrice = price\\n        \\n        self.timestampToChanges[timestamp] += 1\\n        \\n        heappush(self.minHeap, (price, timestamp, self.timestampToChanges[timestamp]))\\n        heappush(self.maxHeap, (-price, timestamp, self.timestampToChanges[timestamp]))\\n                 \\n        \\n\\n    def current(self) -> int:\\n        return self.latestPrice\\n\\n    def maximum(self) -> int:\\n        while self.maxHeap:\\n            price, timestamp, changes = self.maxHeap[0]\\n            if changes != self.timestampToChanges[timestamp]:\\n                heappop(self.maxHeap)\\n            else:\\n                return -price\\n\\n    def minimum(self) -> int:\\n        while self.minHeap:\\n            price, timestamp, changes = self.minHeap[0]\\n            if changes != self.timestampToChanges[timestamp]:\\n                heappop(self.minHeap)\\n            else:\\n                return price\\n        \\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.minHeap = []\\n        self.maxHeap = []\\n        self.timestampToChanges = defaultdict(int)\\n        self.latestTimestamp = -1\\n        self.latestPrice = 0\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp >= self.latestTimestamp:\\n            self.latestTimestamp = timestamp\\n            self.latestPrice = price\\n        \\n        self.timestampToChanges[timestamp] += 1\\n        \\n        heappush(self.minHeap, (price, timestamp, self.timestampToChanges[timestamp]))\\n        heappush(self.maxHeap, (-price, timestamp, self.timestampToChanges[timestamp]))\\n                 \\n        \\n\\n    def current(self) -> int:\\n        return self.latestPrice\\n\\n    def maximum(self) -> int:\\n        while self.maxHeap:\\n            price, timestamp, changes = self.maxHeap[0]\\n            if changes != self.timestampToChanges[timestamp]:\\n                heappop(self.maxHeap)\\n            else:\\n                return -price\\n\\n    def minimum(self) -> int:\\n        while self.minHeap:\\n            price, timestamp, changes = self.minHeap[0]\\n            if changes != self.timestampToChanges[timestamp]:\\n                heappop(self.minHeap)\\n            else:\\n                return price\\n        \\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546368,
                "title": "using-treemap-java",
                "content": "```\\nclass StockPrice \\n{\\n    TreeMap<Integer, Integer> tsM, minMaxM;\\n    public StockPrice() \\n    {\\n        tsM = new TreeMap<Integer, Integer>();\\n        minMaxM = new TreeMap<Integer, Integer>();\\n    }\\n    \\n    public void update(int timestamp, int price) \\n    {\\n        int val = tsM.getOrDefault(timestamp, -1);\\n        if(val != -1)\\n        {\\n            int freq = minMaxM.getOrDefault(val, 0);\\n            if(freq == 1)\\n                minMaxM.remove(val);\\n            else\\n                minMaxM.put(val, freq - 1);\\n        }\\n        minMaxM.put(price, minMaxM.getOrDefault(price, 0) + 1);\\n        tsM.put(timestamp, price);\\n        \\n    }\\n    \\n    public int current() {\\n        return tsM.get(tsM.lastKey());\\n    }\\n    \\n    public int maximum() {\\n        return minMaxM.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return minMaxM.firstKey();\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass StockPrice \\n{\\n    TreeMap<Integer, Integer> tsM, minMaxM;\\n    public StockPrice() \\n    {\\n        tsM = new TreeMap<Integer, Integer>();\\n        minMaxM = new TreeMap<Integer, Integer>();\\n    }\\n    \\n    public void update(int timestamp, int price) \\n    {\\n        int val = tsM.getOrDefault(timestamp, -1);\\n        if(val != -1)\\n        {\\n            int freq = minMaxM.getOrDefault(val, 0);\\n            if(freq == 1)\\n                minMaxM.remove(val);\\n            else\\n                minMaxM.put(val, freq - 1);\\n        }\\n        minMaxM.put(price, minMaxM.getOrDefault(price, 0) + 1);\\n        tsM.put(timestamp, price);\\n        \\n    }\\n    \\n    public int current() {\\n        return tsM.get(tsM.lastKey());\\n    }\\n    \\n    public int maximum() {\\n        return minMaxM.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return minMaxM.firstKey();\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1544678,
                "title": "java-solution-failing-test-case-11",
                "content": "Hello can I get some help on this one, hard to debug the test case as it\\'s very long. Wondering if anyone can see the flaw in my code.\\n\\n```\\nclass StockPrice {\\n    \\n    TreeSet<Stock> prices;\\n    TreeSet<Stock> timestamps;\\n    Map<Integer, Stock> timestampToStock;\\n\\n    public StockPrice() {\\n        timestamps = new TreeSet<Stock>(new Comparator<Stock>(){\\n            public int compare(Stock a, Stock b){\\n                return a.timestamp - b.timestamp;\\n            }\\n        });\\n        \\n        prices = new TreeSet<Stock>(new Comparator<Stock>(){\\n            public int compare(Stock a, Stock b){\\n                return a.price - b.price;\\n            }\\n        });\\n        timestampToStock = new HashMap<>();\\n        \\n    }\\n    \\n    public void update(int timestamp, int price) {\\n       // System.out.println(\"update\");\\n        Stock s = timestampToStock.containsKey(timestamp) ? timestampToStock.get(timestamp) : new Stock(timestamp, price);\\n        \\n        timestamps.remove(s);\\n        prices.remove(s);\\n        \\n        s.price = price;\\n        timestamps.add(s);\\n        prices.add(s);\\n        timestampToStock.put(timestamp, s);\\n        //print();\\n    }\\n    \\n    public int current() {\\n        //System.out.println(\"current\");\\n       // print();\\n        return timestamps.last().price;\\n    }\\n    \\n    public int maximum() {\\n       // System.out.println(\"maximum\");\\n       // print();\\n        return prices.last().price;\\n    }\\n    \\n    public int minimum() {\\n      //  print();\\n        return prices.first().price;\\n    }\\n    \\n    public void print(){\\n        System.out.println(\"prices:\");\\n        System.out.println(prices.toString());\\n        System.out.println(\"timestamps\");\\n        System.out.println(timestamps.toString());\\n        System.out.println();\\n    }\\n}\\n\\nclass Stock {\\n    int timestamp;\\n    int price;\\n    \\n    public Stock(int timestamp, int price){\\n        this.timestamp = timestamp;\\n        this.price = price;\\n    }\\n    \\n\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StockPrice {\\n    \\n    TreeSet<Stock> prices;\\n    TreeSet<Stock> timestamps;\\n    Map<Integer, Stock> timestampToStock;\\n\\n    public StockPrice() {\\n        timestamps = new TreeSet<Stock>(new Comparator<Stock>(){\\n            public int compare(Stock a, Stock b){\\n                return a.timestamp - b.timestamp;\\n            }\\n        });\\n        \\n        prices = new TreeSet<Stock>(new Comparator<Stock>(){\\n            public int compare(Stock a, Stock b){\\n                return a.price - b.price;\\n            }\\n        });\\n        timestampToStock = new HashMap<>();\\n        \\n    }\\n    \\n    public void update(int timestamp, int price) {\\n       // System.out.println(\"update\");\\n        Stock s = timestampToStock.containsKey(timestamp) ? timestampToStock.get(timestamp) : new Stock(timestamp, price);\\n        \\n        timestamps.remove(s);\\n        prices.remove(s);\\n        \\n        s.price = price;\\n        timestamps.add(s);\\n        prices.add(s);\\n        timestampToStock.put(timestamp, s);\\n        //print();\\n    }\\n    \\n    public int current() {\\n        //System.out.println(\"current\");\\n       // print();\\n        return timestamps.last().price;\\n    }\\n    \\n    public int maximum() {\\n       // System.out.println(\"maximum\");\\n       // print();\\n        return prices.last().price;\\n    }\\n    \\n    public int minimum() {\\n      //  print();\\n        return prices.first().price;\\n    }\\n    \\n    public void print(){\\n        System.out.println(\"prices:\");\\n        System.out.println(prices.toString());\\n        System.out.println(\"timestamps\");\\n        System.out.println(timestamps.toString());\\n        System.out.println();\\n    }\\n}\\n\\nclass Stock {\\n    int timestamp;\\n    int price;\\n    \\n    public Stock(int timestamp, int price){\\n        this.timestamp = timestamp;\\n        this.price = price;\\n    }\\n    \\n\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523051,
                "title": "java-treemap",
                "content": "```\\nclass StockPrice {\\n    \\n    private TreeMap<Integer, Integer> priceToTimes = new TreeMap<>();\\n    private Map<Integer, Integer> timestampToPrice = new HashMap<>();\\n    private int currentTime = 0;\\n    private int currentPrice = 0;\\n\\n    public StockPrice() {\\n        \\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (timestampToPrice.containsKey(timestamp)) {\\n            int oldPrice = timestampToPrice.get(timestamp);\\n            removePrice(oldPrice);\\n        }\\n        timestampToPrice.put(timestamp, price);\\n        addPrice(price);\\n        if (timestamp >= currentTime) {\\n            currentTime = timestamp;\\n            currentPrice = price;\\n        }\\n    }\\n    \\n    public int current() {\\n        return currentPrice;\\n    }\\n    \\n    public int maximum() {\\n        return priceToTimes.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return priceToTimes.firstKey();\\n    }\\n    \\n    private void addPrice(int price) {\\n        priceToTimes.put(price, 1 + priceToTimes.getOrDefault(price, 0));\\n    }\\n    \\n    private void removePrice(int price) {\\n        if (priceToTimes.get(price) == 1) {\\n            priceToTimes.remove(price);\\n        } else {\\n            priceToTimes.put(price, priceToTimes.get(price) - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n    \\n    private TreeMap<Integer, Integer> priceToTimes = new TreeMap<>();\\n    private Map<Integer, Integer> timestampToPrice = new HashMap<>();\\n    private int currentTime = 0;\\n    private int currentPrice = 0;\\n\\n    public StockPrice() {\\n        \\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (timestampToPrice.containsKey(timestamp)) {\\n            int oldPrice = timestampToPrice.get(timestamp);\\n            removePrice(oldPrice);\\n        }\\n        timestampToPrice.put(timestamp, price);\\n        addPrice(price);\\n        if (timestamp >= currentTime) {\\n            currentTime = timestamp;\\n            currentPrice = price;\\n        }\\n    }\\n    \\n    public int current() {\\n        return currentPrice;\\n    }\\n    \\n    public int maximum() {\\n        return priceToTimes.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return priceToTimes.firstKey();\\n    }\\n    \\n    private void addPrice(int price) {\\n        priceToTimes.put(price, 1 + priceToTimes.getOrDefault(price, 0));\\n    }\\n    \\n    private void removePrice(int price) {\\n        if (priceToTimes.get(price) == 1) {\\n            priceToTimes.remove(price);\\n        } else {\\n            priceToTimes.put(price, priceToTimes.get(price) - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517828,
                "title": "solution-in-c-using-a-sortedset-and-a-dictionary",
                "content": "\\nThe dictionary is to save the accurate date about price based on timestamp and sorted set is to have the price sorted. The good thing about the sortedset is you already have the Min and Max, in case the value of price of Min/Max doesn\\'t match with the price in the dictionary for a given timestamp, is because that price was updated, so you need to keep iterating in the set until they match\\n\\n\\n    public class StockPrice {\\n\\n\\t\\tint maxTimeStamp=int.MinValue;\\n\\t\\tDictionary<int, int> dictionary;\\n\\t\\tSortedSet<(int price, int timestamp)> set;\\n\\n\\t\\tpublic StockPrice() {\\n\\n\\t\\t\\tdictionary=new Dictionary<int,int>();\\n\\t\\t\\tset=new  SortedSet<(int price, int timestamp)>();\\n\\t\\t}\\n\\n\\t\\tpublic void Update(int timestamp, int price) {\\n\\t\\t\\tmaxTimeStamp=Math.Max(maxTimeStamp, timestamp);\\n\\t\\t\\tset.Add((price, timestamp));\\n\\t\\t\\tif(!dictionary.ContainsKey(timestamp))\\n\\t\\t\\t{\\n\\t\\t\\t\\tdictionary.Add(timestamp,0);\\n\\t\\t\\t}\\n\\t\\t\\tdictionary[timestamp]=price;\\n\\t\\t}\\n\\n\\t\\tpublic int Current() {\\n\\t\\t\\tif(dictionary.Count==0) return -1;\\n\\t\\t\\treturn dictionary[maxTimeStamp];\\n\\t\\t}\\n\\n\\t\\tpublic int Maximum() {\\n\\t\\t\\tif(dictionary.Count==0) return -1;\\n\\t\\t\\tint price =set.Max.price;\\n\\t\\t\\tint timestamp=set.Max.timestamp;\\n\\t\\t\\twhile(price!= dictionary[timestamp] && set.Count>0)\\n\\t\\t\\t{\\n\\t\\t\\t   set.Remove(set.Max);\\n\\t\\t\\t   price =set.Max.price;\\n\\t\\t\\t   timestamp=set.Max.timestamp;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn price;\\n\\t\\t}\\n\\n\\t\\tpublic int Minimum() {\\n\\t\\t\\tif(dictionary.Count==0) return -1;\\n\\t\\t\\tint price =set.Min.price;\\n\\t\\t\\tint timestamp=set.Min.timestamp;\\n\\t\\t\\twhile(price!= dictionary[timestamp] && set.Count>0)\\n\\t\\t\\t{\\n\\t\\t\\t   set.Remove(set.Min);\\n\\t\\t\\t   price =set.Min.price;\\n\\t\\t\\t   timestamp=set.Min.timestamp;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn price;\\n\\t\\t }\\n     }\\n",
                "solutionTags": [],
                "code": "\\nThe dictionary is to save the accurate date about price based on timestamp and sorted set is to have the price sorted. The good thing about the sortedset is you already have the Min and Max, in case the value of price of Min/Max doesn\\'t match with the price in the dictionary for a given timestamp, is because that price was updated, so you need to keep iterating in the set until they match\\n\\n\\n    public class StockPrice {\\n\\n\\t\\tint maxTimeStamp=int.MinValue;\\n\\t\\tDictionary<int, int> dictionary;\\n\\t\\tSortedSet<(int price, int timestamp)> set;\\n\\n\\t\\tpublic StockPrice() {\\n\\n\\t\\t\\tdictionary=new Dictionary<int,int>();\\n\\t\\t\\tset=new  SortedSet<(int price, int timestamp)>();\\n\\t\\t}\\n\\n\\t\\tpublic void Update(int timestamp, int price) {\\n\\t\\t\\tmaxTimeStamp=Math.Max(maxTimeStamp, timestamp);\\n\\t\\t\\tset.Add((price, timestamp));\\n\\t\\t\\tif(!dictionary.ContainsKey(timestamp))\\n\\t\\t\\t{\\n\\t\\t\\t\\tdictionary.Add(timestamp,0);\\n\\t\\t\\t}\\n\\t\\t\\tdictionary[timestamp]=price;\\n\\t\\t}\\n\\n\\t\\tpublic int Current() {\\n\\t\\t\\tif(dictionary.Count==0) return -1;\\n\\t\\t\\treturn dictionary[maxTimeStamp];\\n\\t\\t}\\n\\n\\t\\tpublic int Maximum() {\\n\\t\\t\\tif(dictionary.Count==0) return -1;\\n\\t\\t\\tint price =set.Max.price;\\n\\t\\t\\tint timestamp=set.Max.timestamp;\\n\\t\\t\\twhile(price!= dictionary[timestamp] && set.Count>0)\\n\\t\\t\\t{\\n\\t\\t\\t   set.Remove(set.Max);\\n\\t\\t\\t   price =set.Max.price;\\n\\t\\t\\t   timestamp=set.Max.timestamp;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn price;\\n\\t\\t}\\n\\n\\t\\tpublic int Minimum() {\\n\\t\\t\\tif(dictionary.Count==0) return -1;\\n\\t\\t\\tint price =set.Min.price;\\n\\t\\t\\tint timestamp=set.Min.timestamp;\\n\\t\\t\\twhile(price!= dictionary[timestamp] && set.Count>0)\\n\\t\\t\\t{\\n\\t\\t\\t   set.Remove(set.Min);\\n\\t\\t\\t   price =set.Min.price;\\n\\t\\t\\t   timestamp=set.Min.timestamp;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn price;\\n\\t\\t }\\n     }\\n",
                "codeTag": "Java"
            },
            {
                "id": 1516386,
                "title": "expected-output-seems-incorrect-for-below-testcase",
                "content": "For below input expected output seems wrong, as after 5th update the current should point to 5339 but in the expected output its giving 1866.\\nAnd output after this point are also incorrect.\\n\\n[\"StockPrice\",\"update\",\"maximum\",\"current\",\"minimum\",\"maximum\",\"maximum\",\"maximum\",\"minimum\",\"minimum\",\"maximum\",\\n\"update\",\"maximum\",\"minimum\",\\n\"update\",\"maximum\",\"minimum\",\"current\",\"maximum\",\\n\"update\",\"minimum\",\"maximum\",\\n**\"update\",\"maximum\",\"maximum\",\"current\",**\\n\"update\",\"current\",\"minimum\",\\n\"update\",\\n\"update\",\"minimum\",\"minimum\",\\n\"update\",\"current\",\\n\"update\",\"maximum\",\\n\"update\",\"minimum\"]\\n\\n[[],[38,2308],[],[],[],[],[],[],[],[],[],\\n[47,7876],[],[],\\n[58,1866],[],[],[],[],\\n[43,121],[],[],\\n**[40,5339],[],[],[],**\\n[32,5339],[],[],[43,6414],[49,9369],[],[],[36,3192],[],[48,1006],[],[53,8013],[]]\\n\\n\\n**Current Expected Output:**\\n[null,null,2308,2308,2308,2308,2308,2308,2308,2308,2308,\\nnull,7876,2308,\\nnull,7876,1866,1866,7876,\\nnull,121,7876,\\nnull,7876,7876,**1866**,\\nnull,**1866**,121,null,null,1866,1866,null,**1866**,null,9369,null,1006]\\n\\n\\n**Expected Output should be **\\n\\n[null,null,2308,2308,2308,2308,2308,2308,2308,2308,2308,\\nnull,7876,2308,\\nnull,7876,1866,1866,7876,\\nnull,121,7876,\\nnull,7876,7876,**5339,**\\nnull,**5339**,121,null,null,1866,1866,null,**3192**,null,9369,null,1006]\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1514970,
                "title": "c-2034-stock-price-fluctuation",
                "content": "\\n```\\nclass StockPrice {\\n    unordered_map<int, int> mp; \\n    priority_queue<pair<int, int>> maxp; \\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minp; \\n    int latest = 0; \\n    \\npublic:\\n    StockPrice() {}\\n    \\n    void update(int timestamp, int price) {\\n        mp[timestamp] = price; \\n        if (latest < timestamp) latest = timestamp; \\n        maxp.emplace(price, timestamp); \\n        minp.emplace(price, timestamp); \\n    }\\n    \\n    int current() {\\n        return mp[latest]; \\n    }\\n    \\n    int maximum() {\\n        while (mp[maxp.top().second] != maxp.top().first) maxp.pop(); \\n        return maxp.top().first; \\n    }\\n    \\n    int minimum() {\\n        while (mp[minp.top().second] != minp.top().first) minp.pop(); \\n        return minp.top().first; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass StockPrice {\\n    unordered_map<int, int> mp; \\n    priority_queue<pair<int, int>> maxp; \\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minp; \\n    int latest = 0; \\n    \\npublic:\\n    StockPrice() {}\\n    \\n    void update(int timestamp, int price) {\\n        mp[timestamp] = price; \\n        if (latest < timestamp) latest = timestamp; \\n        maxp.emplace(price, timestamp); \\n        minp.emplace(price, timestamp); \\n    }\\n    \\n    int current() {\\n        return mp[latest]; \\n    }\\n    \\n    int maximum() {\\n        while (mp[maxp.top().second] != maxp.top().first) maxp.pop(); \\n        return maxp.top().first; \\n    }\\n    \\n    int minimum() {\\n        while (mp[minp.top().second] != minp.top().first) minp.pop(); \\n        return minp.top().first; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514629,
                "title": "python-implicit-segment-tree-solution",
                "content": "```python\\nINF = 10 ** 9 + 5\\n\\nclass SegTreeNode:\\n    def __init__(self, l=0, r=0, val=-1, val2=INF, lchd=None, rchd=None):\\n        self.l = l\\n        self.r = r\\n        self.val = val\\n        self.val2 = val2\\n        self.lchd = lchd\\n        self.rchd = rchd\\n\\n    def extend(self):\\n        if not self.lchd:\\n            m = self.l + (self.r - self.l) // 2\\n            self.lchd = SegTreeNode(self.l, m)\\n            self.rchd = SegTreeNode(m + 1, self.r)\\n\\n\\nclass SegTree:\\n    def __init__(self, n):\\n        self.root = SegTreeNode(0, n)\\n\\n    def ptassign(self, pos, val):\\n        self.__ptassign(pos, val, self.root)\\n\\n    def query(self, ql, qr, func):\\n        return self.__query(ql, qr, func, self.root)\\n\\n    def __ptassign(self, pos, val, node):\\n        if node.l == node.r:\\n            node.val = node.val2 = val\\n            return\\n        node.extend()\\n        if pos <= node.lchd.r:\\n            self.__ptassign(pos, val, node.lchd)\\n        else:\\n            self.__ptassign(pos, val, node.rchd)\\n        self.__op(node)\\n\\n    def __query(self, ql, qr, func, node):\\n        if ql <= node.l and node.r <= qr:\\n            return node.val if func == max else node.val2\\n        node.extend()\\n        ans = -1 if func == max else INF\\n        if ql <= node.lchd.r:\\n            ans = func(ans, self.__query(ql, qr, node.lchd))\\n        if node.rchd.l <= qr:\\n            ans = func(ans, self.__query(ql, qr, node.rchd))\\n        return ans\\n\\n    def __op(self, node):\\n        node.val = max(node.lchd.val, node.rchd.val)\\n        node.val2 = min(node.lchd.val2, node.rchd.val2)\\n\\n\\nclass StockPrice:\\n    def __init__(self):\\n        self.seg_tree = SegTree(10 ** 9)\\n        self.time = 0\\n        self.cur = 0\\n\\n    def update(self, timestamp, price):\\n        self.seg_tree.ptassign(timestamp, price)\\n        if timestamp >= self.time:\\n            self.time = timestamp\\n            self.cur = price\\n\\n    def current(self):\\n        return self.cur\\n\\n    def maximum(self):\\n        return self.seg_tree.query(0, 10 ** 9, max)\\n\\n    def minimum(self):\\n        return self.seg_tree.query(0, 10 ** 9, min)\\n```",
                "solutionTags": [],
                "code": "```python\\nINF = 10 ** 9 + 5\\n\\nclass SegTreeNode:\\n    def __init__(self, l=0, r=0, val=-1, val2=INF, lchd=None, rchd=None):\\n        self.l = l\\n        self.r = r\\n        self.val = val\\n        self.val2 = val2\\n        self.lchd = lchd\\n        self.rchd = rchd\\n\\n    def extend(self):\\n        if not self.lchd:\\n            m = self.l + (self.r - self.l) // 2\\n            self.lchd = SegTreeNode(self.l, m)\\n            self.rchd = SegTreeNode(m + 1, self.r)\\n\\n\\nclass SegTree:\\n    def __init__(self, n):\\n        self.root = SegTreeNode(0, n)\\n\\n    def ptassign(self, pos, val):\\n        self.__ptassign(pos, val, self.root)\\n\\n    def query(self, ql, qr, func):\\n        return self.__query(ql, qr, func, self.root)\\n\\n    def __ptassign(self, pos, val, node):\\n        if node.l == node.r:\\n            node.val = node.val2 = val\\n            return\\n        node.extend()\\n        if pos <= node.lchd.r:\\n            self.__ptassign(pos, val, node.lchd)\\n        else:\\n            self.__ptassign(pos, val, node.rchd)\\n        self.__op(node)\\n\\n    def __query(self, ql, qr, func, node):\\n        if ql <= node.l and node.r <= qr:\\n            return node.val if func == max else node.val2\\n        node.extend()\\n        ans = -1 if func == max else INF\\n        if ql <= node.lchd.r:\\n            ans = func(ans, self.__query(ql, qr, node.lchd))\\n        if node.rchd.l <= qr:\\n            ans = func(ans, self.__query(ql, qr, node.rchd))\\n        return ans\\n\\n    def __op(self, node):\\n        node.val = max(node.lchd.val, node.rchd.val)\\n        node.val2 = min(node.lchd.val2, node.rchd.val2)\\n\\n\\nclass StockPrice:\\n    def __init__(self):\\n        self.seg_tree = SegTree(10 ** 9)\\n        self.time = 0\\n        self.cur = 0\\n\\n    def update(self, timestamp, price):\\n        self.seg_tree.ptassign(timestamp, price)\\n        if timestamp >= self.time:\\n            self.time = timestamp\\n            self.cur = price\\n\\n    def current(self):\\n        return self.cur\\n\\n    def maximum(self):\\n        return self.seg_tree.query(0, 10 ** 9, max)\\n\\n    def minimum(self):\\n        return self.seg_tree.query(0, 10 ** 9, min)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514501,
                "title": "2034-stock-price-fluctuation",
                "content": "---\\n\\n- Heap solution is better\\n- WIthout heap solution is below\\n\\nHope it is simple to understand.\\n\\n---\\n\\n    class StockPrice {\\n        T = [];              // all timestamps\\n        P = [];              // all prices - corresponding to all above timestamps\\n        min_p = Infinity;    // all minimum price\\n        max_p = -Infinity;   // all maximum price\\n        latest_ts = -1;      // latest timestamp\\n        latest_p = -1;       // price - corresponding above latest timestamp\\n\\n        update(timestamp, price) {\\n            const index = this.T.indexOf(timestamp);\\n            if (index !== -1) {\\n                let prev_price = this.P[index];\\n                this.P[index] = price;\\n                if (prev_price === this.min_p && prev_price === this.max_p) {\\n                    this.min_p = Infinity;\\n                    this.max_p = -Infinity;\\n                    for (let p of this.P) {\\n                        this.min_p = Math.min(this.min_p, p);\\n                        this.max_p = Math.max(this.max_p, p);\\n                    }\\n                } else if (prev_price === this.min_p) {\\n                    this.min_p = Infinity;\\n                    for (let p of this.P) this.min_p = Math.min(this.min_p, p);\\n                } else if (prev_price === this.max_p) {\\n                    this.max_p = -Infinity;\\n                    for (let p of this.P) this.max_p = Math.max(this.max_p, p);\\n                }\\n            } else {\\n                this.T.push(timestamp);\\n                this.P.push(price);\\n            }\\n\\n            if (price < this.min_p) this.min_p = price;\\n            if (price > this.max_p) this.max_p = price;\\n\\n            if (timestamp >= this.latest_ts) {\\n                this.latest_ts = timestamp;\\n                this.latest_p = price;\\n            }\\n            return null;\\n        }\\n        current() {\\n            return this.latest_p;\\n        }\\n        maximum() {\\n            return this.max_p;\\n        }\\n        minimum() {\\n            return this.min_p;\\n        }\\n    }\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "---\\n\\n- Heap solution is better\\n- WIthout heap solution is below\\n\\nHope it is simple to understand.\\n\\n---\\n\\n    class StockPrice {\\n        T = [];              // all timestamps\\n        P = [];              // all prices - corresponding to all above timestamps\\n        min_p = Infinity;    // all minimum price\\n        max_p = -Infinity;   // all maximum price\\n        latest_ts = -1;      // latest timestamp\\n        latest_p = -1;       // price - corresponding above latest timestamp\\n\\n        update(timestamp, price) {\\n            const index = this.T.indexOf(timestamp);\\n            if (index !== -1) {\\n                let prev_price = this.P[index];\\n                this.P[index] = price;\\n                if (prev_price === this.min_p && prev_price === this.max_p) {\\n                    this.min_p = Infinity;\\n                    this.max_p = -Infinity;\\n                    for (let p of this.P) {\\n                        this.min_p = Math.min(this.min_p, p);\\n                        this.max_p = Math.max(this.max_p, p);\\n                    }\\n                } else if (prev_price === this.min_p) {\\n                    this.min_p = Infinity;\\n                    for (let p of this.P) this.min_p = Math.min(this.min_p, p);\\n                } else if (prev_price === this.max_p) {\\n                    this.max_p = -Infinity;\\n                    for (let p of this.P) this.max_p = Math.max(this.max_p, p);\\n                }\\n            } else {\\n                this.T.push(timestamp);\\n                this.P.push(price);\\n            }\\n\\n            if (price < this.min_p) this.min_p = price;\\n            if (price > this.max_p) this.max_p = price;\\n\\n            if (timestamp >= this.latest_ts) {\\n                this.latest_ts = timestamp;\\n                this.latest_p = price;\\n            }\\n            return null;\\n        }\\n        current() {\\n            return this.latest_p;\\n        }\\n        maximum() {\\n            return this.max_p;\\n        }\\n        minimum() {\\n            return this.min_p;\\n        }\\n    }\\n\\n---\\n",
                "codeTag": "Java"
            },
            {
                "id": 1514484,
                "title": "a-few-solutions",
                "content": "Use a map `m` to store value `x` per time `t` and use min,max heaps `lo`,`hi` correspondingly.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass StockPrice() {\\n    private var m = mutableMapOf<Int, Int>()\\n    private var lo = PriorityQueue<Pair<Int, Int>>(Comparator{ a: Pair<Int, Int>, b: Pair<Int, Int> -> a.second.compareTo(b.second) })\\n    private var hi = PriorityQueue<Pair<Int, Int>>(Comparator{ a: Pair<Int, Int>, b: Pair<Int, Int> -> b.second.compareTo(a.second) })\\n    private var time = 0\\n    private var last = 0\\n    fun update(t: Int, x: Int) {\\n        m[t] = x\\n        lo.add(Pair(t, x))\\n        hi.add(Pair(t, x))\\n        if (time <= t) {\\n            time = t\\n            last = x\\n        }\\n    }\\n    fun current(): Int {\\n        return last\\n    }\\n    fun maximum(): Int {\\n        var found = false\\n        while (!found) {\\n            var (t, x) = hi.poll()\\n            if (m[t] == x) {\\n                found = true\\n                hi.add(Pair(t, x))\\n            }\\n        }\\n        return hi.peek().second\\n    }\\n    fun minimum(): Int {\\n        var found = false\\n        while (!found) {\\n            var (t, x) = lo.poll()\\n            if (m[t] == x) {\\n                found = true\\n                lo.add(Pair(t, x))\\n            }\\n        }\\n        return lo.peek().second\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nclass StockPrice {\\n    constructor() {\\n        this.m = new Map();\\n        this.lo = [];\\n        this.hi = [];\\n        this.time = 0;\\n        this.last = 0;\\n    }\\n    update(t, x) {\\n        this.m.set(t, x);\\n        heappush(this.lo, [x, t], Math.min);\\n        heappush(this.hi, [x, t], Math.max);\\n        if (this.time <= t) {\\n            this.time = t;\\n            this.last = x;\\n        }\\n    }\\n    current() {\\n        return this.last;\\n    }\\n    maximum() {\\n        let found = false;\\n        while (!found) {\\n            let [x, t] = this.hi[0];\\n            if (this.m.get(t) == x)\\n                found = true;\\n            else\\n                heappop(this.hi, Math.max);\\n        }\\n        return this.hi[0][0];\\n    }\\n    minimum() {\\n        let found = false;\\n        while (!found) {\\n            let [x, t] = this.lo[0];\\n            if (this.m.get(t) == x)\\n                found = true;\\n            else\\n                heappop(this.lo, Math.min);\\n        }\\n        return this.lo[0][0];\\n    }\\n}\\n```\\n\\n*Python3*\\n```\\nclass StockPrice:\\n    def __init__(self):\\n        self.m = {}\\n        self.lo = []\\n        self.hi = []\\n        self.time = 0\\n        self.last = 0\\n\\n    def update(self, t: int, x: int) -> None:\\n        self.m[t] = x\\n        heappush(self.lo, [x, t])\\n        heappush(self.hi, [-x, t])\\n        if self.time <= t:\\n            self.time = t\\n            self.last = x\\n\\n    def current(self) -> int:\\n        return self.last\\n\\n    def maximum(self) -> int:\\n        found = False\\n        while not found:\\n            x, t = self.hi[0]\\n            if self.m[t] == -x:\\n                found = True\\n            else:\\n                heappop(self.hi)\\n        return -self.hi[0][0]\\n\\n    def minimum(self) -> int:\\n        found = False\\n        while not found:\\n            x, t = self.lo[0]\\n            if self.m[t] == x:\\n                found = True\\n            else:\\n                heappop(self.lo)\\n        return self.lo[0][0]\\n```\\n\\n*C++*\\n```\\nclass StockPrice {\\n    using Map = unordered_map<int, int>;\\n    Map m;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    struct Min { size_t operator()(const Pair& a, const Pair& b) { return b.second < a.second; } };\\n    struct Max { size_t operator()(const Pair& a, const Pair& b) { return a.second < b.second; } };\\n    priority_queue<Pair, Pairs, Min> lo;\\n    priority_queue<Pair, Pairs, Max> hi;\\n    int last, time;\\npublic:\\n    void update(int t, int x) {\\n        m[t] = x;\\n        lo.push(make_pair(t, x));\\n        hi.push(make_pair(t, x));\\n        if (time <= t) {\\n            time = t;\\n            last = x;\\n        }\\n    }\\n    int current() {\\n        return last;\\n    }\\n    int maximum() {\\n        auto found = false;\\n        while (!found) {\\n            auto [t, x] = hi.top();\\n            if (m[t] == x)\\n                found = true;\\n            else\\n                hi.pop();\\n        }\\n        return hi.top().second;\\n    }\\n    int minimum() {\\n        auto found = false;\\n        while (!found) {\\n            auto [t, x] = lo.top();\\n            if (m[t] == x)\\n                found = true;\\n            else\\n                lo.pop();\\n        }\\n        return lo.top().second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice() {\\n    private var m = mutableMapOf<Int, Int>()\\n    private var lo = PriorityQueue<Pair<Int, Int>>(Comparator{ a: Pair<Int, Int>, b: Pair<Int, Int> -> a.second.compareTo(b.second) })\\n    private var hi = PriorityQueue<Pair<Int, Int>>(Comparator{ a: Pair<Int, Int>, b: Pair<Int, Int> -> b.second.compareTo(a.second) })\\n    private var time = 0\\n    private var last = 0\\n    fun update(t: Int, x: Int) {\\n        m[t] = x\\n        lo.add(Pair(t, x))\\n        hi.add(Pair(t, x))\\n        if (time <= t) {\\n            time = t\\n            last = x\\n        }\\n    }\\n    fun current(): Int {\\n        return last\\n    }\\n    fun maximum(): Int {\\n        var found = false\\n        while (!found) {\\n            var (t, x) = hi.poll()\\n            if (m[t] == x) {\\n                found = true\\n                hi.add(Pair(t, x))\\n            }\\n        }\\n        return hi.peek().second\\n    }\\n    fun minimum(): Int {\\n        var found = false\\n        while (!found) {\\n            var (t, x) = lo.poll()\\n            if (m[t] == x) {\\n                found = true\\n                lo.add(Pair(t, x))\\n            }\\n        }\\n        return lo.peek().second\\n    }\\n}\\n```\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nclass StockPrice {\\n    constructor() {\\n        this.m = new Map();\\n        this.lo = [];\\n        this.hi = [];\\n        this.time = 0;\\n        this.last = 0;\\n    }\\n    update(t, x) {\\n        this.m.set(t, x);\\n        heappush(this.lo, [x, t], Math.min);\\n        heappush(this.hi, [x, t], Math.max);\\n        if (this.time <= t) {\\n            this.time = t;\\n            this.last = x;\\n        }\\n    }\\n    current() {\\n        return this.last;\\n    }\\n    maximum() {\\n        let found = false;\\n        while (!found) {\\n            let [x, t] = this.hi[0];\\n            if (this.m.get(t) == x)\\n                found = true;\\n            else\\n                heappop(this.hi, Math.max);\\n        }\\n        return this.hi[0][0];\\n    }\\n    minimum() {\\n        let found = false;\\n        while (!found) {\\n            let [x, t] = this.lo[0];\\n            if (this.m.get(t) == x)\\n                found = true;\\n            else\\n                heappop(this.lo, Math.min);\\n        }\\n        return this.lo[0][0];\\n    }\\n}\\n```\n```\\nclass StockPrice:\\n    def __init__(self):\\n        self.m = {}\\n        self.lo = []\\n        self.hi = []\\n        self.time = 0\\n        self.last = 0\\n\\n    def update(self, t: int, x: int) -> None:\\n        self.m[t] = x\\n        heappush(self.lo, [x, t])\\n        heappush(self.hi, [-x, t])\\n        if self.time <= t:\\n            self.time = t\\n            self.last = x\\n\\n    def current(self) -> int:\\n        return self.last\\n\\n    def maximum(self) -> int:\\n        found = False\\n        while not found:\\n            x, t = self.hi[0]\\n            if self.m[t] == -x:\\n                found = True\\n            else:\\n                heappop(self.hi)\\n        return -self.hi[0][0]\\n\\n    def minimum(self) -> int:\\n        found = False\\n        while not found:\\n            x, t = self.lo[0]\\n            if self.m[t] == x:\\n                found = True\\n            else:\\n                heappop(self.lo)\\n        return self.lo[0][0]\\n```\n```\\nclass StockPrice {\\n    using Map = unordered_map<int, int>;\\n    Map m;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    struct Min { size_t operator()(const Pair& a, const Pair& b) { return b.second < a.second; } };\\n    struct Max { size_t operator()(const Pair& a, const Pair& b) { return a.second < b.second; } };\\n    priority_queue<Pair, Pairs, Min> lo;\\n    priority_queue<Pair, Pairs, Max> hi;\\n    int last, time;\\npublic:\\n    void update(int t, int x) {\\n        m[t] = x;\\n        lo.push(make_pair(t, x));\\n        hi.push(make_pair(t, x));\\n        if (time <= t) {\\n            time = t;\\n            last = x;\\n        }\\n    }\\n    int current() {\\n        return last;\\n    }\\n    int maximum() {\\n        auto found = false;\\n        while (!found) {\\n            auto [t, x] = hi.top();\\n            if (m[t] == x)\\n                found = true;\\n            else\\n                hi.pop();\\n        }\\n        return hi.top().second;\\n    }\\n    int minimum() {\\n        auto found = false;\\n        while (!found) {\\n            auto [t, x] = lo.top();\\n            if (m[t] == x)\\n                found = true;\\n            else\\n                lo.pop();\\n        }\\n        return lo.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514048,
                "title": "c-hashmap-and-2-heaps",
                "content": "If we get a maximum profit which has been updated in the table, then look for next valid max in the heap.\\nSame with minimum.\\n```\\nclass StockPrice {\\npublic:\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > min_heap;\\n    priority_queue<pair<int, int>> max_heap;\\n    unordered_map<int, int>table;\\n    \\n    int latest;\\n    \\n    StockPrice() {\\n        latest = INT_MIN;\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        table[timestamp] = price;\\n        min_heap.push({price, timestamp});\\n        max_heap.push({price, timestamp});\\n        if(latest<timestamp) latest = timestamp;\\n    }\\n    \\n    int current() {\\n        return table[latest];\\n    }\\n    \\n    int maximum() {\\n        auto curr = max_heap.top();\\n        max_heap.pop();\\n        if(table[curr.second]!=curr.first) return maximum();\\n        max_heap.push(curr);\\n        return curr.first;\\n    }\\n    \\n    int minimum() {\\n        auto curr = min_heap.top();\\n        min_heap.pop();\\n        if(table[curr.second]!=curr.first) return minimum();\\n        min_heap.push(curr);\\n        return curr.first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > min_heap;\\n    priority_queue<pair<int, int>> max_heap;\\n    unordered_map<int, int>table;\\n    \\n    int latest;\\n    \\n    StockPrice() {\\n        latest = INT_MIN;\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        table[timestamp] = price;\\n        min_heap.push({price, timestamp});\\n        max_heap.push({price, timestamp});\\n        if(latest<timestamp) latest = timestamp;\\n    }\\n    \\n    int current() {\\n        return table[latest];\\n    }\\n    \\n    int maximum() {\\n        auto curr = max_heap.top();\\n        max_heap.pop();\\n        if(table[curr.second]!=curr.first) return maximum();\\n        max_heap.push(curr);\\n        return curr.first;\\n    }\\n    \\n    int minimum() {\\n        auto curr = min_heap.top();\\n        min_heap.pop();\\n        if(table[curr.second]!=curr.first) return minimum();\\n        min_heap.push(curr);\\n        return curr.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513916,
                "title": "python-sorted-containers-n-log-n-sorted-list",
                "content": "Leetcode has the libraries available. A hash to help in popping the values. Price to monitor the smallest and largest price. Time to monitor recent.\\n```\\nfrom sortedcontainers import SortedList\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.hash = {}\\n        self.price = SortedList()\\n        self.time = [0,0]\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.hash:\\n            k = [timestamp , self.hash[timestamp] ]\\n            self.price.remove( k[::-1] )\\n        if self.time[0] <= timestamp :\\n            self.time = [timestamp , price]\\n        self.hash[ timestamp ] = price\\n        self.price.add( [price,timestamp] )\\n        \\n    def current(self) -> int:\\n        return self.time[1]\\n\\n    def maximum(self) -> int:\\n        return self.price[-1][0]\\n\\n    def minimum(self) -> int:\\n        return self.price[0][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.hash = {}\\n        self.price = SortedList()\\n        self.time = [0,0]\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.hash:\\n            k = [timestamp , self.hash[timestamp] ]\\n            self.price.remove( k[::-1] )\\n        if self.time[0] <= timestamp :\\n            self.time = [timestamp , price]\\n        self.hash[ timestamp ] = price\\n        self.price.add( [price,timestamp] )\\n        \\n    def current(self) -> int:\\n        return self.time[1]\\n\\n    def maximum(self) -> int:\\n        return self.price[-1][0]\\n\\n    def minimum(self) -> int:\\n        return self.price[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513798,
                "title": "python-code-with-dictionary-and-binary-search-beats-66-submissions",
                "content": "class StockPrice:\\n    \\n    def __init__(self):\\n        \\n        #dict of {time-price} records. Maintained to reduce lookup time to O(1)\\n        self.records = dict()\\n\\t\\t\\n        #latest-timestamp\\n        self.latest = 0\\n\\t\\t\\n\\t\\t#sorted array of prices for minimum and maximum\\n        self.prices = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        \\n\\t\\t#if the incoming timestamp is latest, update the latest records\\n        if timestamp > self.latest:\\n            self.latest = timestamp\\n        \\n\\t\\t#if timestamp already existed in the records, remove it to support price correction\\n        if timestamp in self.records:\\n            self.removeFromPrices(self.records[timestamp])   \\n            \\n\\t\\t# add/update the records\\n        self.records[timestamp] = price\\n\\t\\t\\n\\t\\t#add the new price to the sorted array\\n        self.addToPrices(price)\\n\\n    def current(self) -> int:\\n        return self.records[self.latest]\\n\\n    def maximum(self) -> int:\\n        return self.prices[-1]\\n\\n    def minimum(self) -> int:\\n         return self.prices[0]\\n        \\n    def removeFromPrices(self, price):\\n        index = bisect_left(self.prices, price)\\n        self.prices.pop(index)\\n    \\n    def addToPrices(self, price):\\n        index = insort_left(self.prices, price)\\n\\t\\t\\n---\\n\\nHappy to take better coding/performance improvement suggestions",
                "solutionTags": [],
                "code": "class StockPrice:\\n    \\n    def __init__(self):\\n        \\n        #dict of {time-price} records. Maintained to reduce lookup time to O(1)\\n        self.records = dict()\\n\\t\\t\\n        #latest-timestamp\\n        self.latest = 0\\n\\t\\t\\n\\t\\t#sorted array of prices for minimum and maximum\\n        self.prices = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        \\n\\t\\t#if the incoming timestamp is latest, update the latest records\\n        if timestamp > self.latest:\\n            self.latest = timestamp\\n        \\n\\t\\t#if timestamp already existed in the records, remove it to support price correction\\n        if timestamp in self.records:\\n            self.removeFromPrices(self.records[timestamp])   \\n            \\n\\t\\t# add/update the records\\n        self.records[timestamp] = price\\n\\t\\t\\n\\t\\t#add the new price to the sorted array\\n        self.addToPrices(price)\\n\\n    def current(self) -> int:\\n        return self.records[self.latest]\\n\\n    def maximum(self) -> int:\\n        return self.prices[-1]\\n\\n    def minimum(self) -> int:\\n         return self.prices[0]\\n        \\n    def removeFromPrices(self, price):\\n        index = bisect_left(self.prices, price)\\n        self.prices.pop(index)\\n    \\n    def addToPrices(self, price):\\n        index = insort_left(self.prices, price)\\n\\t\\t\\n---\\n\\nHappy to take better coding/performance improvement suggestions",
                "codeTag": "Java"
            },
            {
                "id": 1513684,
                "title": "python-use-bisect",
                "content": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.dict_t = {}\\n        self.price = []\\n        self.curr = 0\\n        \\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.dict_t:\\n            self.price.remove(self.dict_t[timestamp])\\n            \\n        self.dict_t[timestamp] = price\\n        if timestamp > self.curr:\\n            self.curr = timestamp\\n        bisect.insort(self.price, price) \\n\\n    def current(self) -> int:\\n        return self.dict_t[self.curr]\\n        \\n\\n    def maximum(self) -> int:\\n        return self.price[-1]\\n        \\n\\n    def minimum(self) -> int:\\n        return self.price[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.dict_t = {}\\n        self.price = []\\n        self.curr = 0\\n        \\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.dict_t:\\n            self.price.remove(self.dict_t[timestamp])\\n            \\n        self.dict_t[timestamp] = price\\n        if timestamp > self.curr:\\n            self.curr = timestamp\\n        bisect.insort(self.price, price) \\n\\n    def current(self) -> int:\\n        return self.dict_t[self.curr]\\n        \\n\\n    def maximum(self) -> int:\\n        return self.price[-1]\\n        \\n\\n    def minimum(self) -> int:\\n        return self.price[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513578,
                "title": "why-heap",
                "content": "```\\nimport bisect \\n\\nclass StockPrice:\\n    def __init__(self):\\n        # prices from minimum to maximum\\n        self.prices = []\\n        # (latest timestamp, latest price)\\n        self.latest = (0, None)\\n        self.t2price = dict()\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.t2price:\\n            # evict the previous price\\n            self.prices.remove(self.t2price[timestamp])\\n        # insert the new price\\n        i = bisect.bisect_left(self.prices, price)\\n        self.prices.insert(i, price)\\n        self.t2price[timestamp] = price\\n        \\n        if timestamp >= self.latest[0]:\\n            self.latest = (timestamp, price)\\n            \\n    def current(self) -> int:\\n        return self.latest[1]\\n\\n    def maximum(self) -> int:\\n        return self.prices[-1]\\n\\n    def minimum(self) -> int:\\n        return self.prices[0]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect \\n\\nclass StockPrice:\\n    def __init__(self):\\n        # prices from minimum to maximum\\n        self.prices = []\\n        # (latest timestamp, latest price)\\n        self.latest = (0, None)\\n        self.t2price = dict()\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.t2price:\\n            # evict the previous price\\n            self.prices.remove(self.t2price[timestamp])\\n        # insert the new price\\n        i = bisect.bisect_left(self.prices, price)\\n        self.prices.insert(i, price)\\n        self.t2price[timestamp] = price\\n        \\n        if timestamp >= self.latest[0]:\\n            self.latest = (timestamp, price)\\n            \\n    def current(self) -> int:\\n        return self.latest[1]\\n\\n    def maximum(self) -> int:\\n        return self.prices[-1]\\n\\n    def minimum(self) -> int:\\n        return self.prices[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513554,
                "title": "c-segment-tree-beats-100-user",
                "content": "```\\nclass StockPrice {\\npublic:\\n    map<int,int> help;\\n    int currents=0,time=0;\\n    int index=0;\\n    map<int,int> help2;\\n    int seg_tree[400000];\\n    int seg_tree2[400000];\\n    void update(int indexs,int l,int r,int index,int price){\\n        if(l>indexs||r<indexs){\\n            return;\\n        }\\n        if(indexs==l&&l==r){\\n            seg_tree[index]=price;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        update(indexs,l,mid,2*index+1,price);\\n        update(indexs,mid+1,r,2*index+2,price);\\n        seg_tree[index]=max(seg_tree[2*index+1],seg_tree[2*index+2]);\\n        // cout<<seg_tree[index]<<endl;\\n    }\\n     void update2(int indexs,int l,int r,int index,int price){\\n        if(l>indexs||r<indexs){\\n            return;\\n        }\\n        if(indexs==l&&l==r){\\n            seg_tree2[index]=price;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        update2(indexs,l,mid,2*index+1,price);\\n        update2(indexs,mid+1,r,2*index+2,price);\\n        seg_tree2[index]=min(seg_tree2[2*index+1],seg_tree2[2*index+2]);\\n    }\\n    \\n    StockPrice() {\\n        for(int i=0;i<400000;i++){\\n            seg_tree[i]=0;\\n            seg_tree2[i]=INT_MAX;\\n        }\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(time<=timestamp){\\n            time=timestamp;\\n            currents=price;\\n            // cout<<currents<<endl;\\n        }\\n        if(help2.find(timestamp)==help2.end())\\n        help2[timestamp]=index++;\\n        update(help2[timestamp],0,100000,0,price);\\n        update2(help2[timestamp],0,100000,0,price);\\n        help[timestamp]=price;\\n    }\\n    \\n    int current() {\\n        return currents;\\n    }\\n    \\n    int maximum() {\\n        return seg_tree[0];\\n    }\\n    \\n    int minimum() {\\n        return seg_tree2[0]; \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    map<int,int> help;\\n    int currents=0,time=0;\\n    int index=0;\\n    map<int,int> help2;\\n    int seg_tree[400000];\\n    int seg_tree2[400000];\\n    void update(int indexs,int l,int r,int index,int price){\\n        if(l>indexs||r<indexs){\\n            return;\\n        }\\n        if(indexs==l&&l==r){\\n            seg_tree[index]=price;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        update(indexs,l,mid,2*index+1,price);\\n        update(indexs,mid+1,r,2*index+2,price);\\n        seg_tree[index]=max(seg_tree[2*index+1],seg_tree[2*index+2]);\\n        // cout<<seg_tree[index]<<endl;\\n    }\\n     void update2(int indexs,int l,int r,int index,int price){\\n        if(l>indexs||r<indexs){\\n            return;\\n        }\\n        if(indexs==l&&l==r){\\n            seg_tree2[index]=price;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        update2(indexs,l,mid,2*index+1,price);\\n        update2(indexs,mid+1,r,2*index+2,price);\\n        seg_tree2[index]=min(seg_tree2[2*index+1],seg_tree2[2*index+2]);\\n    }\\n    \\n    StockPrice() {\\n        for(int i=0;i<400000;i++){\\n            seg_tree[i]=0;\\n            seg_tree2[i]=INT_MAX;\\n        }\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(time<=timestamp){\\n            time=timestamp;\\n            currents=price;\\n            // cout<<currents<<endl;\\n        }\\n        if(help2.find(timestamp)==help2.end())\\n        help2[timestamp]=index++;\\n        update(help2[timestamp],0,100000,0,price);\\n        update2(help2[timestamp],0,100000,0,price);\\n        help[timestamp]=price;\\n    }\\n    \\n    int current() {\\n        return currents;\\n    }\\n    \\n    int maximum() {\\n        return seg_tree[0];\\n    }\\n    \\n    int minimum() {\\n        return seg_tree2[0]; \\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1513551,
                "title": "use-two-tree-maps",
                "content": "Use two treemaps\\n\\n**StockPrice TreeMap**\\n1. This map will keep timestamp as key and price of stock as value.\\n2. Why to use TreeMap and not a HashMap?\\n3. Since `currentPrice` is needed, treemap can keep stock price in sorted manner and the last entry in this map can give the latest price\\n\\n**PriceCount TreeMap**\\n1. This map will have stock price as key and value will be the frequency of that stock price\\n2. Why to use TreeMap and not a HashMap?\\n3. `minimum` can be easily retrieved using first key\\n4. `maximum` can be easily retrieved using last key\\n\\n**How will update function work?**\\n1. Whenever a call is made to update stock price with value `price` at a `timestamp` \\n2. Check if this timestamp was already there in which case updation will be needed otherwise addition has to be done\\n3. In case of **Updation:** \\n\\t4. Find the old price of stock from `StockPrice` treemap \\n\\t5. Reduce its count in `PriceCount` treemap\\n\\t6. if the count has been reduced to zero remove that entry from `PriceCount` treemap\\n\\t7. Update the price of stock in `StockPrice` treemap\\n\\t8. Update the frequency of stock in `PriceCount` treemap\\n9. In case of **Addition**\\n\\t10. Update the price of stock in `StockPrice` treemap\\n\\t11. Update the frequency of stock in `PriceCount` treemap\\n\\n```\\nclass StockPrice {\\n\\n    int currentPrice;\\n    TreeMap<Integer, Integer> stockPrice;\\n    TreeMap<Integer, Integer> priceCount;\\n\\n    public StockPrice() {\\n        stockPrice = new TreeMap<>();\\n        priceCount = new TreeMap<>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (stockPrice.containsKey(timestamp)) {\\n            int oldPrice = stockPrice.get(timestamp);\\n            priceCount.put(oldPrice, priceCount.get(oldPrice) - 1);\\n            if (priceCount.get(oldPrice) == 0) {\\n                priceCount.remove(oldPrice);\\n            }\\n        }\\n        stockPrice.put(timestamp, price);\\n        priceCount.put(price, priceCount.getOrDefault(price, 0) + 1);\\n    }\\n    \\n    public int current() {\\n        return stockPrice.lastEntry().getValue();\\n    }\\n    \\n    public int maximum() {\\n        return priceCount.lastEntry().getKey();\\n    }\\n    \\n    public int minimum() {\\n        return priceCount.firstEntry().getKey();\\n    }\\n}\\n```\\n\\n**Complexity Analysis**\\n**Time Complexity**\\n1. Not familiar with the internal implementation of TreeMap but I think it should be like a BinarySearchTree so retrieval/updation can be done in O(lg(n))\\n2. current(): last element has to be taken from `StockPrice` so it will take O(lg(n))\\n3. maximum(): last element has to be taken from `PriceCount` so it will take O(lg(n))\\n4. minimum(): first element has to be taken from `PriceCount` so it will take O(lg(n))\\n5. updation(): \\n\\t6. addition/updation in `StockPrice` will take O(lg(n)). It will be like adding/updating a new node in BST\\n\\t7. addition/updation in `PriceCount` will take O(lg(n)). It will be like adding/updating a new node in BST\\n\\n**SpaceComplexity**\\nO(2*n) = O(n) : For using two tree maps",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n\\n    int currentPrice;\\n    TreeMap<Integer, Integer> stockPrice;\\n    TreeMap<Integer, Integer> priceCount;\\n\\n    public StockPrice() {\\n        stockPrice = new TreeMap<>();\\n        priceCount = new TreeMap<>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (stockPrice.containsKey(timestamp)) {\\n            int oldPrice = stockPrice.get(timestamp);\\n            priceCount.put(oldPrice, priceCount.get(oldPrice) - 1);\\n            if (priceCount.get(oldPrice) == 0) {\\n                priceCount.remove(oldPrice);\\n            }\\n        }\\n        stockPrice.put(timestamp, price);\\n        priceCount.put(price, priceCount.getOrDefault(price, 0) + 1);\\n    }\\n    \\n    public int current() {\\n        return stockPrice.lastEntry().getValue();\\n    }\\n    \\n    public int maximum() {\\n        return priceCount.lastEntry().getKey();\\n    }\\n    \\n    public int minimum() {\\n        return priceCount.firstEntry().getKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513423,
                "title": "java-two-treemaps-pricemap-only-using-counter",
                "content": "priceMap only needs a counter to count the number of same price instead of set.\\n```\\nclass StockPrice {\\n    TreeMap<Integer, Integer> map;\\n    TreeMap<Integer, Integer> priceMap;\\n    public StockPrice() {\\n        map = new TreeMap<>();\\n        priceMap = new TreeMap<>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (map.containsKey(timestamp)) {\\n            int cur = map.get(timestamp);\\n            priceMap.put(cur, priceMap.get(cur) - 1);\\n            if (priceMap.get(cur) == 0) {\\n                priceMap.remove(cur);\\n            }\\n        }\\n        map.put(timestamp, price);\\n        priceMap.put(price, priceMap.getOrDefault(price, 0) + 1);\\n    }\\n    \\n    public int current() {\\n        return map.get(map.lastKey());\\n    }\\n    \\n    public int maximum() {\\n        return priceMap.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return priceMap.firstKey();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n    TreeMap<Integer, Integer> map;\\n    TreeMap<Integer, Integer> priceMap;\\n    public StockPrice() {\\n        map = new TreeMap<>();\\n        priceMap = new TreeMap<>();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if (map.containsKey(timestamp)) {\\n            int cur = map.get(timestamp);\\n            priceMap.put(cur, priceMap.get(cur) - 1);\\n            if (priceMap.get(cur) == 0) {\\n                priceMap.remove(cur);\\n            }\\n        }\\n        map.put(timestamp, price);\\n        priceMap.put(price, priceMap.getOrDefault(price, 0) + 1);\\n    }\\n    \\n    public int current() {\\n        return map.get(map.lastKey());\\n    }\\n    \\n    public int maximum() {\\n        return priceMap.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return priceMap.firstKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513411,
                "title": "help-me-understand-why-this-two-heap-solution-is-wrong",
                "content": "Test case I failed on probably has 10^5 entries so it\\'s really hard to figure out what went wrong... Really appriciate if someone can point out a test case that would fail this solution. Thanks!\\n\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.prices = {}\\n        self.time = 0\\n        self.maxheap = []\\n        self.minheap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.prices:\\n            while self.minheap and  self.minheap[0] == self.prices[timestamp]:\\n                heapq.heappop(self.minheap)\\n            while self.maxheap and self.maxheap[0] == -self.prices[timestamp]:\\n                heapq.heappop(self.maxheap)\\n        self.prices[timestamp] = price\\n        self.time = max(self.time, timestamp)\\n        heapq.heappush(self.maxheap, -price)\\n        heapq.heappush(self.minheap, price)\\n\\n    def current(self) -> int:\\n        return self.prices[self.time]\\n\\n    def maximum(self) -> int:\\n        return -self.maxheap[0]\\n\\n    def minimum(self) -> int:\\n        return self.minheap[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.prices = {}\\n        self.time = 0\\n        self.maxheap = []\\n        self.minheap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.prices:\\n            while self.minheap and  self.minheap[0] == self.prices[timestamp]:\\n                heapq.heappop(self.minheap)\\n            while self.maxheap and self.maxheap[0] == -self.prices[timestamp]:\\n                heapq.heappop(self.maxheap)\\n        self.prices[timestamp] = price\\n        self.time = max(self.time, timestamp)\\n        heapq.heappush(self.maxheap, -price)\\n        heapq.heappush(self.minheap, price)\\n\\n    def current(self) -> int:\\n        return self.prices[self.time]\\n\\n    def maximum(self) -> int:\\n        return -self.maxheap[0]\\n\\n    def minimum(self) -> int:\\n        return self.minheap[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513406,
                "title": "python-2-heaps",
                "content": "We can use a max-heap and a min-heap to deal with the max and min queries respectively. For the max query, we pop the heap and push the updated record so as to update the heap. If the poped result is greater than the record, we repeat this process. Otherwise, we return the record since it\\'s greater than or equal to all prices in the heap. Min queries can be dealt similarly using another heap.\\n\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.correct = {}\\n        self.curr = (0, 0)\\n        self.max = []\\n        self.min = []\\n        heapq.heapify(self.max)\\n        heapq.heapify(self.min)\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.correct[timestamp] = price\\n        if timestamp >= self.curr[0]:\\n            self.curr = (timestamp, price)\\n        heapq.heappush(self.max, (-price, timestamp))\\n        heapq.heappush(self.min, (price, timestamp))\\n\\n    def current(self) -> int:\\n        return self.curr[1]\\n\\n    def maximum(self) -> int:\\n        while True:\\n            p, t = heapq.heappop(self.max)\\n            heapq.heappush(self.max, (-self.correct[t], t))\\n            if self.correct[t] >= -p:\\n                return self.correct[t]\\n\\n    def minimum(self) -> int:\\n        while True:\\n            p, t = heapq.heappop(self.min)\\n            heapq.heappush(self.min, (self.correct[t], t))\\n            if self.correct[t] <= p:\\n                return self.correct[t]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.correct = {}\\n        self.curr = (0, 0)\\n        self.max = []\\n        self.min = []\\n        heapq.heapify(self.max)\\n        heapq.heapify(self.min)\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.correct[timestamp] = price\\n        if timestamp >= self.curr[0]:\\n            self.curr = (timestamp, price)\\n        heapq.heappush(self.max, (-price, timestamp))\\n        heapq.heappush(self.min, (price, timestamp))\\n\\n    def current(self) -> int:\\n        return self.curr[1]\\n\\n    def maximum(self) -> int:\\n        while True:\\n            p, t = heapq.heappop(self.max)\\n            heapq.heappush(self.max, (-self.correct[t], t))\\n            if self.correct[t] >= -p:\\n                return self.correct[t]\\n\\n    def minimum(self) -> int:\\n        while True:\\n            p, t = heapq.heappop(self.min)\\n            heapq.heappush(self.min, (self.correct[t], t))\\n            if self.correct[t] <= p:\\n                return self.correct[t]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513371,
                "title": "c-map-straightforward-solution",
                "content": "**Solution**\\nUse a unordered map `seen` to recored appeared timestamp and its price.\\nUse a map `p` to record the number of a price.\\n\\nWhy use map? Because `map` is an ordered container (implemented by RB tree) in c++ STL, all elements in it are in order.\\nSo, we can get minimal and maximal quickly by using map.\\n\\n**Code**\\n```cpp\\nclass StockPrice {\\npublic:\\n    unordered_map<int, int> seen;\\n    map<int, int> p;\\n    int curTime, mn, mx;\\n    \\n    StockPrice() {\\n        curTime = -1;\\n        mn = INT_MAX;\\n        mx = INT_MIN;\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(timestamp > curTime)\\n            curTime = timestamp;\\n        if(seen.find(timestamp) != seen.end()) {\\n            p[seen[timestamp]]--;\\n            if(p[seen[timestamp]] == 0)\\n                p.erase(seen[timestamp]);\\n        }\\n        seen[timestamp] = price;\\n        p[price]++;\\n        \\n        mn = p.begin()->first;\\n        mx = p.rbegin()->first;\\n    }\\n    \\n    int current() {\\n        return seen[curTime];\\n    }\\n    \\n    int maximum() {\\n        return mx;\\n    }\\n    \\n    int minimum() {\\n        return mn;\\n    }\\n};\\n```\\n\\n**Complexity**\\nTime Complexity: O(logn) for each update(), O(1) for each find()\\nSpace Complexity: O(n)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass StockPrice {\\npublic:\\n    unordered_map<int, int> seen;\\n    map<int, int> p;\\n    int curTime, mn, mx;\\n    \\n    StockPrice() {\\n        curTime = -1;\\n        mn = INT_MAX;\\n        mx = INT_MIN;\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(timestamp > curTime)\\n            curTime = timestamp;\\n        if(seen.find(timestamp) != seen.end()) {\\n            p[seen[timestamp]]--;\\n            if(p[seen[timestamp]] == 0)\\n                p.erase(seen[timestamp]);\\n        }\\n        seen[timestamp] = price;\\n        p[price]++;\\n        \\n        mn = p.begin()->first;\\n        mx = p.rbegin()->first;\\n    }\\n    \\n    int current() {\\n        return seen[curTime];\\n    }\\n    \\n    int maximum() {\\n        return mx;\\n    }\\n    \\n    int minimum() {\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513338,
                "title": "very-simple-c-if-you-know-standary-library-well-only-few-lines-of-codes-in-c-very-clean",
                "content": "```\\nclass StockPrice {\\npublic:\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(st.count(timestamp)){\\n            price_history.erase(st[timestamp]);\\n        }\\n        st[timestamp] = price_history.insert(price);\\n    }\\n    \\n    int current() {\\n        return *st.rbegin()->second;\\n    }\\n    \\n    int maximum() {\\n        return *price_history.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *price_history.begin();        \\n    }\\n    \\n    map<int, multiset<int>::iterator> st;\\n    multiset<int> price_history;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\npublic:\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(st.count(timestamp)){\\n            price_history.erase(st[timestamp]);\\n        }\\n        st[timestamp] = price_history.insert(price);\\n    }\\n    \\n    int current() {\\n        return *st.rbegin()->second;\\n    }\\n    \\n    int maximum() {\\n        return *price_history.rbegin();\\n    }\\n    \\n    int minimum() {\\n        return *price_history.begin();        \\n    }\\n    \\n    map<int, multiset<int>::iterator> st;\\n    multiset<int> price_history;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513330,
                "title": "java-two-treemap-o-logn-all-operations-simple-with-explanation",
                "content": "```\\n/**\\n * Simple solution with 2 TreeMaps. We maintain a TreeMap to\\n * keep track of the prices by their timestamp and another TreeMap to maintain\\n * the timestamps by their prices. The second one maintains all the timestamps\\n * for a given price.\\n *\\n * To return the minimum, we return the first entry of the TreeMap indexed by\\n * the price.\\n * To return the maximim, we return the last entry of the TreeMap indexed by\\n * the price.\\n * On an update, we first adjust the maps so that any timestamp corresponding\\n * to the old price is removed from the prices map.\\n * Once the prices map is adjusted, we update both the maps.\\n *\\n * All operations are O(log(N)) \\n */\\npublic class StockPrice {\\n    TreeMap<Integer, Set<Integer>> prices = new TreeMap<>();\\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public StockPrice() {\\n    }\\n\\n    public void update(int timestamp, int price) {\\n        if (map.containsKey(timestamp)) {\\n            int currPrice = map.get(timestamp);\\n            var ts = prices.get(currPrice);\\n            if (ts != null) {\\n                ts.remove(timestamp);\\n                if (ts.isEmpty()) {\\n                    prices.remove(currPrice);\\n                }\\n            }\\n        }\\n        map.put(timestamp, price);\\n        prices.computeIfAbsent(price, x -> new HashSet<>()).add(timestamp);\\n    }\\n\\n    public int current() {\\n        return map.lastEntry().getValue();\\n    }\\n\\n    public int maximum() {\\n        return prices.lastKey();\\n    }\\n\\n    public int minimum() {\\n        return prices.firstKey();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Simple solution with 2 TreeMaps. We maintain a TreeMap to\\n * keep track of the prices by their timestamp and another TreeMap to maintain\\n * the timestamps by their prices. The second one maintains all the timestamps\\n * for a given price.\\n *\\n * To return the minimum, we return the first entry of the TreeMap indexed by\\n * the price.\\n * To return the maximim, we return the last entry of the TreeMap indexed by\\n * the price.\\n * On an update, we first adjust the maps so that any timestamp corresponding\\n * to the old price is removed from the prices map.\\n * Once the prices map is adjusted, we update both the maps.\\n *\\n * All operations are O(log(N)) \\n */\\npublic class StockPrice {\\n    TreeMap<Integer, Set<Integer>> prices = new TreeMap<>();\\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public StockPrice() {\\n    }\\n\\n    public void update(int timestamp, int price) {\\n        if (map.containsKey(timestamp)) {\\n            int currPrice = map.get(timestamp);\\n            var ts = prices.get(currPrice);\\n            if (ts != null) {\\n                ts.remove(timestamp);\\n                if (ts.isEmpty()) {\\n                    prices.remove(currPrice);\\n                }\\n            }\\n        }\\n        map.put(timestamp, price);\\n        prices.computeIfAbsent(price, x -> new HashSet<>()).add(timestamp);\\n    }\\n\\n    public int current() {\\n        return map.lastEntry().getValue();\\n    }\\n\\n    public int maximum() {\\n        return prices.lastKey();\\n    }\\n\\n    public int minimum() {\\n        return prices.firstKey();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513302,
                "title": "simple-solution-using-max-heap-and-min-heap",
                "content": "**Solution using hashmap,min-heap,max-heap C++**\\n\\n* At time of update insert value into hashmap,push value into max-heap/min-heap\\n* For the current keep track of the latest time stamp\\n* While returning the max value check if the time-stamp value at the top of max-heap is equal to time stamp value in hashmap, if yes then return value else pop the max heap until the values become equal\\n* Do same for min-heap\\n\\n**Time-Complexities:-**\\nCurrent:- `O(1)`\\nMaximum :- `O(nlogn)`\\nminimum :-` O(nlogn)`\\n\\n<iframe src=\"https://leetcode.com/playground/hZ7mSXVh/shared\" frameBorder=\"0\" width=\"1000\" height=\"800\"></iframe>",
                "solutionTags": [
                    "C"
                ],
                "code": "**Solution using hashmap,min-heap,max-heap C++**\\n\\n* At time of update insert value into hashmap,push value into max-heap/min-heap\\n* For the current keep track of the latest time stamp\\n* While returning the max value check if the time-stamp value at the top of max-heap is equal to time stamp value in hashmap, if yes then return value else pop the max heap until the values become equal\\n* Do same for min-heap\\n\\n**Time-Complexities:-**\\nCurrent:- `O(1)`\\nMaximum :- `O(nlogn)`\\nminimum :-` O(nlogn)`\\n\\n<iframe src=\"https://leetcode.com/playground/hZ7mSXVh/shared\" frameBorder=\"0\" width=\"1000\" height=\"800\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1513296,
                "title": "short-and-concise-using-heap-and-bisect-python",
                "content": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.dic = {}\\n        self.time = []\\n        self.l = []\\n        heapq.heapify(self.time)\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.dic:\\n            self.l.remove(self.dic[timestamp])\\n\\n        self.dic[timestamp] = price\\n        heapq.heappush(self.time, -timestamp)\\n        bisect.insort(self.l, price)\\n\\n    def current(self) -> int:\\n        x = heapq.heappop(self.time)\\n        heapq.heappush(self.time, x)\\n        return self.dic[-x]\\n\\n    def maximum(self) -> int:\\n        return self.l[-1]\\n\\n    def minimum(self) -> int:\\n        return self.l[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.dic = {}\\n        self.time = []\\n        self.l = []\\n        heapq.heapify(self.time)\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        if timestamp in self.dic:\\n            self.l.remove(self.dic[timestamp])\\n\\n        self.dic[timestamp] = price\\n        heapq.heappush(self.time, -timestamp)\\n        bisect.insort(self.l, price)\\n\\n    def current(self) -> int:\\n        x = heapq.heappop(self.time)\\n        heapq.heappush(self.time, x)\\n        return self.dic[-x]\\n\\n    def maximum(self) -> int:\\n        return self.l[-1]\\n\\n    def minimum(self) -> int:\\n        return self.l[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073803,
                "title": "explained-c-hash-map-multiset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne important clue is that: \"Price can be corrected, but timestamp **NOT**.\" \\n\\nTherefore, we can use timestamp as an unique id for each stock.\\n\\nTo implement these interfaces, we need three things\\n- `Current time`: The most recent timestamp\\n- `Hash map`: Record the price of each stock based on its **UNIQUE** timestamp\\n- `Multimap`: Record each stock based on their stock price. Note that different stocks might have same price. Hence, we use a multimap here.\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`void update(int, int)`: Everytime comes a new pair (time, price), we will to three things.\\n- Update the most recent timestamp\\n- Update the price of the stock in `Hash map` based on their timestamp\\n- Insert the lastest (price, time) pair into `Multimap`. Be aware that there might be some invaid pairs in multimap, i.e. prices before correcting\\n\\n`int current()`: Return the price of the stock with most recent timestamp\\n\\n`int maximum()`: Find the stock with maximum (or minimum) price by multimap. Note that the retrieved (price, timestamp) pair might be invalid, so we must verify it by **HASH MAP**, which always stores valid data.\\n\\n`int minimum()`: Similar to `int maximum()`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`void update(int, int)`: \\n - O(logn)\\n\\n`int current()`: \\n- O(1)\\n\\n`int maximum()`: \\n- Amortized: O(logn)\\n- Worst case in single operation: O(nlogn)\\n\\n`int minimum()`: O(logn) (Amortized)\\n- Amortized: O(logn)\\n- Worst case in single operation: O(nlogn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass StockPrice {\\npublic:\\n    StockPrice(): curr_time(-1)  {}\\n    \\n    void update(int timestamp, int price) {\\n        curr_time = max(curr_time, timestamp);\\n        time_to_price[timestamp] = price;\\n        mmap.insert({price, timestamp});\\n    }\\n    \\n    int current() {\\n        return time_to_price[curr_time];\\n    }\\n    \\n    int maximum() {\\n\\n        int max_price = INT_MIN;\\n        while(!mmap.empty()){\\n            auto iter = mmap.end();\\n            iter = std::prev(iter);\\n\\n            int price = iter->first;\\n            int time  = iter->second;\\n\\n            if(time_to_price[time] != price){\\n                mmap.erase(iter);\\n            }else{\\n                max_price = price;\\n                break;\\n            }\\n        }\\n        return max_price;\\n    }\\n    \\n    int minimum() {\\n       int min_price = INT_MAX;\\n        while(!mmap.empty()){\\n            auto iter = mmap.begin();\\n\\n            int price = iter->first;\\n            int time = iter->second;\\n\\n            if(time_to_price[time] != price){\\n                mmap.erase(iter);\\n            }else{\\n                min_price = price;\\n                break;\\n            }\\n        }\\n        return min_price;        \\n    }\\n\\nprivate:\\n    int curr_time;\\n    unordered_map<int, int> time_to_price; // time, price\\n    multimap<int, int> mmap; // price, time\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n\\n /*\\n\\nint curr_timestamp\\nunordered_map<time, price> mp\\nmap[timestamp] = price\\nmultimap<price, timestamp> \\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    StockPrice(): curr_time(-1)  {}\\n    \\n    void update(int timestamp, int price) {\\n        curr_time = max(curr_time, timestamp);\\n        time_to_price[timestamp] = price;\\n        mmap.insert({price, timestamp});\\n    }\\n    \\n    int current() {\\n        return time_to_price[curr_time];\\n    }\\n    \\n    int maximum() {\\n\\n        int max_price = INT_MIN;\\n        while(!mmap.empty()){\\n            auto iter = mmap.end();\\n            iter = std::prev(iter);\\n\\n            int price = iter->first;\\n            int time  = iter->second;\\n\\n            if(time_to_price[time] != price){\\n                mmap.erase(iter);\\n            }else{\\n                max_price = price;\\n                break;\\n            }\\n        }\\n        return max_price;\\n    }\\n    \\n    int minimum() {\\n       int min_price = INT_MAX;\\n        while(!mmap.empty()){\\n            auto iter = mmap.begin();\\n\\n            int price = iter->first;\\n            int time = iter->second;\\n\\n            if(time_to_price[time] != price){\\n                mmap.erase(iter);\\n            }else{\\n                min_price = price;\\n                break;\\n            }\\n        }\\n        return min_price;        \\n    }\\n\\nprivate:\\n    int curr_time;\\n    unordered_map<int, int> time_to_price; // time, price\\n    multimap<int, int> mmap; // price, time\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n\\n /*\\n\\nint curr_timestamp\\nunordered_map<time, price> mp\\nmap[timestamp] = price\\nmultimap<price, timestamp> \\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051561,
                "title": "c-min-and-max-priority-queue",
                "content": "# class StockPrice {\\n# public:\\n# int c=0,ts=-1; // storing latest price for only latest timestamp\\n# priority_queue<pair<int,int>>pb; // max priority queue \\n# priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pc; // min priority queue\\n# map<int,int>mp; // this mp for storing latest price with latest timestamp\\n# StockPrice() {}\\n# void update(int timestamp, int price) {\\n# if(timestamp>=ts){ //if latest timestamp is greater than equal to the previous timestamp then change the price\\n# c=price;\\n# ts=timestamp;\\n# }\\n# mp[timestamp]=price;\\n# pb.push({price,timestamp});\\n# pc.push({price,timestamp});\\n# }\\n# int current() {\\n# return c;\\n# }\\n# \\n# int maximum() {\\n# while(mp[pb.top().second]!=pb.top().first) // if the latest price is updated then we have to remove that value.\\n# pb.pop();\\n# return pb.top().first;\\n# }\\n# \\n# int minimum() {\\n# while(mp[pc.top().second]!=pc.top().first) //// if the latest price is updated then we have to remove that value.\\n# pc.pop();\\n# return pc.top().first;\\n# }\\n# * };",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "# class StockPrice {\\n# public:\\n# int c=0,ts=-1; // storing latest price for only latest timestamp\\n# priority_queue<pair<int,int>>pb; // max priority queue \\n# priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pc; // min priority queue\\n# map<int,int>mp; // this mp for storing latest price with latest timestamp\\n# StockPrice() {}\\n# void update(int timestamp, int price) {\\n# if(timestamp>=ts){ //if latest timestamp is greater than equal to the previous timestamp then change the price\\n# c=price;\\n# ts=timestamp;\\n# }\\n# mp[timestamp]=price;\\n# pb.push({price,timestamp});\\n# pc.push({price,timestamp});\\n# }\\n# int current() {\\n# return c;\\n# }\\n# \\n# int maximum() {\\n# while(mp[pb.top().second]!=pb.top().first) // if the latest price is updated then we have to remove that value.\\n# pb.pop();\\n# return pb.top().first;\\n# }\\n# \\n# int minimum() {\\n# while(mp[pc.top().second]!=pc.top().first) //// if the latest price is updated then we have to remove that value.\\n# pc.pop();\\n# return pc.top().first;\\n# }\\n# * };",
                "codeTag": "Java"
            },
            {
                "id": 4036961,
                "title": "solution-using-2-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass StockPrice {\\npublic:\\nmap<int,int> rec;\\nmap <int,set<unordered_int>> mx;\\nint min;\\n    StockPrice() {\\n      \\n    }\\n    \\n    void update(int timestamp, int price) {\\n       int prev=rec[timestamp];\\n       auto del=mx[prev].find(timestamp);\\n       if(del!=mx[prev].end())\\n       mx[prev].erase(del);\\n       if(mx[prev].size()==0)\\n       {\\n           mx.erase(prev);\\n       }\\n       rec[timestamp]=price;\\n       mx[price].insert(timestamp);\\n        \\n    }\\n    \\n    int current() {\\n        auto i = rec.rbegin();\\n        return  i->second;\\n        \\n    }\\n    \\n    int maximum() {\\n        auto i = mx.rbegin();\\n        return  i->first;\\n    }\\n    \\n    int minimum() {\\n         auto i = mx.begin();\\n        return  i->first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\nmap<int,int> rec;\\nmap <int,set<unordered_int>> mx;\\nint min;\\n    StockPrice() {\\n      \\n    }\\n    \\n    void update(int timestamp, int price) {\\n       int prev=rec[timestamp];\\n       auto del=mx[prev].find(timestamp);\\n       if(del!=mx[prev].end())\\n       mx[prev].erase(del);\\n       if(mx[prev].size()==0)\\n       {\\n           mx.erase(prev);\\n       }\\n       rec[timestamp]=price;\\n       mx[price].insert(timestamp);\\n        \\n    }\\n    \\n    int current() {\\n        auto i = rec.rbegin();\\n        return  i->second;\\n        \\n    }\\n    \\n    int maximum() {\\n        auto i = mx.rbegin();\\n        return  i->first;\\n    }\\n    \\n    int minimum() {\\n         auto i = mx.begin();\\n        return  i->first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004415,
                "title": "java-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass StockPrice {\\n    int currentTimeStamp;\\n    Map<Integer, Integer> stockMap;\\n    //arr[0] timestamp, arr[1] price\\n    PriorityQueue<int[]> maxHeap;\\n    PriorityQueue<int[]> minHeap;\\n    public StockPrice() {\\n        currentTimeStamp = 0;\\n        stockMap = new HashMap<>();\\n        maxHeap = new PriorityQueue<>((a, b) -> (b[1]-a[1]));\\n        minHeap = new PriorityQueue<>((a, b) -> (a[1]-b[1]));\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        currentTimeStamp = Math.max(currentTimeStamp, timestamp);\\n        stockMap.put(timestamp, price);\\n        maxHeap.add(new int[]{timestamp, price});\\n        minHeap.add(new int[]{timestamp, price});\\n    }\\n    \\n    public int current() {\\n        return stockMap.get(currentTimeStamp);\\n    }\\n    \\n    public int maximum() {\\n        //Below while loop is used to invalidate and remove from heap ,if later price has updated with same timestamp, it will check against stockMap\\n        while(maxHeap.size() > 0 && maxHeap.peek()[1] != stockMap.get(maxHeap.peek()[0])){\\n            maxHeap.add(new int[]{maxHeap.peek()[0], stockMap.get(maxHeap.peek()[0])});\\n            maxHeap.poll();\\n        }\\n        return maxHeap.peek()[1];\\n    }\\n    \\n    public int minimum() {\\n        while(minHeap.size() > 0 && minHeap.peek()[1] != stockMap.get(minHeap.peek()[0])){\\n            minHeap.add(new int[]{minHeap.peek()[0], stockMap.get(minHeap.peek()[0])});\\n            minHeap.poll();\\n        }\\n        return minHeap.peek()[1];\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StockPrice {\\n    int currentTimeStamp;\\n    Map<Integer, Integer> stockMap;\\n    //arr[0] timestamp, arr[1] price\\n    PriorityQueue<int[]> maxHeap;\\n    PriorityQueue<int[]> minHeap;\\n    public StockPrice() {\\n        currentTimeStamp = 0;\\n        stockMap = new HashMap<>();\\n        maxHeap = new PriorityQueue<>((a, b) -> (b[1]-a[1]));\\n        minHeap = new PriorityQueue<>((a, b) -> (a[1]-b[1]));\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        currentTimeStamp = Math.max(currentTimeStamp, timestamp);\\n        stockMap.put(timestamp, price);\\n        maxHeap.add(new int[]{timestamp, price});\\n        minHeap.add(new int[]{timestamp, price});\\n    }\\n    \\n    public int current() {\\n        return stockMap.get(currentTimeStamp);\\n    }\\n    \\n    public int maximum() {\\n        //Below while loop is used to invalidate and remove from heap ,if later price has updated with same timestamp, it will check against stockMap\\n        while(maxHeap.size() > 0 && maxHeap.peek()[1] != stockMap.get(maxHeap.peek()[0])){\\n            maxHeap.add(new int[]{maxHeap.peek()[0], stockMap.get(maxHeap.peek()[0])});\\n            maxHeap.poll();\\n        }\\n        return maxHeap.peek()[1];\\n    }\\n    \\n    public int minimum() {\\n        while(minHeap.size() > 0 && minHeap.peek()[1] != stockMap.get(minHeap.peek()[0])){\\n            minHeap.add(new int[]{minHeap.peek()[0], stockMap.get(minHeap.peek()[0])});\\n            minHeap.poll();\\n        }\\n        return minHeap.peek()[1];\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977491,
                "title": "two-maps-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass StockPrice {\\npublic:\\n    map<int,int>m;\\n    map<int,int>maxmin;\\n    StockPrice() {\\n        \\n    }   \\n    void update(int timestamp, int price) {\\n        if(m.count(timestamp)){\\n            maxmin[m[timestamp]]--;\\n            if(maxmin[m[timestamp]]==0)maxmin.erase(m[timestamp]);\\n        }       \\n        m[timestamp]=price;  \\n        maxmin[price]++;\\n    \\n        \\n    }\\n    \\n    int current() {\\n        return prev(m.end())->second;\\n    }\\n    \\n    int maximum() {\\n        return prev(maxmin.end())->first;\\n        \\n    }    \\n    int minimum() {\\n        return maxmin.begin()->first;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    map<int,int>m;\\n    map<int,int>maxmin;\\n    StockPrice() {\\n        \\n    }   \\n    void update(int timestamp, int price) {\\n        if(m.count(timestamp)){\\n            maxmin[m[timestamp]]--;\\n            if(maxmin[m[timestamp]]==0)maxmin.erase(m[timestamp]);\\n        }       \\n        m[timestamp]=price;  \\n        maxmin[price]++;\\n    \\n        \\n    }\\n    \\n    int current() {\\n        return prev(m.end())->second;\\n    }\\n    \\n    int maximum() {\\n        return prev(maxmin.end())->first;\\n        \\n    }    \\n    int minimum() {\\n        return maxmin.begin()->first;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964883,
                "title": "priority-queue-map",
                "content": "\\n# Code\\n```\\nclass StockPrice {\\n    unordered_map<int,int> mp;\\n    priority_queue<pair<int,int>, vector<pair<int,int>>> maxi;\\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > mini;\\n    int last;\\npublic:\\n    StockPrice() {\\n        mp.clear();\\n        // maxi.clear();\\n        // mini.empty();\\n        last = -1;\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        mp[timestamp] = price;\\n        mini.push({price, timestamp});\\n        maxi.push({price, timestamp});\\n        last = max(timestamp,last);\\n    }\\n    \\n    int current() {\\n        return mp[last];\\n    }\\n    \\n    int maximum() {\\n        if(maxi.empty())return -1;\\n        while( mp[maxi.top().second] != maxi.top().first){\\n            auto tmp = maxi.top(); maxi.pop();\\n            auto newprice = mp[tmp.second];\\n            maxi.push({newprice,tmp.second});\\n        }\\n        return maxi.top().first;\\n    }\\n    \\n    int minimum() {\\n        if(mini.empty())return -1;\\n        while( mp[mini.top().second] != mini.top().first){\\n            auto tmp = mini.top(); mini.pop();\\n            auto newprice = mp[tmp.second];\\n            mini.push({newprice,tmp.second});\\n        }\\n        return mini.top().first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass StockPrice {\\n    unordered_map<int,int> mp;\\n    priority_queue<pair<int,int>, vector<pair<int,int>>> maxi;\\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > mini;\\n    int last;\\npublic:\\n    StockPrice() {\\n        mp.clear();\\n        // maxi.clear();\\n        // mini.empty();\\n        last = -1;\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        mp[timestamp] = price;\\n        mini.push({price, timestamp});\\n        maxi.push({price, timestamp});\\n        last = max(timestamp,last);\\n    }\\n    \\n    int current() {\\n        return mp[last];\\n    }\\n    \\n    int maximum() {\\n        if(maxi.empty())return -1;\\n        while( mp[maxi.top().second] != maxi.top().first){\\n            auto tmp = maxi.top(); maxi.pop();\\n            auto newprice = mp[tmp.second];\\n            maxi.push({newprice,tmp.second});\\n        }\\n        return maxi.top().first;\\n    }\\n    \\n    int minimum() {\\n        if(mini.empty())return -1;\\n        while( mp[mini.top().second] != mini.top().first){\\n            auto tmp = mini.top(); mini.pop();\\n            auto newprice = mp[tmp.second];\\n            mini.push({newprice,tmp.second});\\n        }\\n        return mini.top().first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927030,
                "title": "hashmap-and-priority-queues",
                "content": "# Code\\n```\\nclass StockPrice {\\n\\nclass Stock{\\n\\tint price;\\n\\tint timestamp;\\n\\tpublic Stock(int price,int timestamp){\\n\\t\\tthis.price = price;\\n\\t\\tthis.timestamp = timestamp;\\n\\t}\\n}\\n\\n\\tint current;\\n\\tPriorityQueue<Stock> maxQ ;\\n\\tPriorityQueue<Stock> minQ ;\\n\\tMap<Integer,Integer> priceMap;\\n\\tpublic StockPrice() {\\n   \\t    current=0;\\n\\t\\tpriceMap = new HashMap<>();\\n\\t\\tmaxQ =new PriorityQueue<>((s1,s2)-> s2.price-s1.price);\\n\\t\\tminQ =new PriorityQueue<>((s1,s2)-> s1.price-s2.price);\\n\\t}\\n    \\n\\tpublic void update(int timestamp, int price) {\\n   \\t priceMap.put(timestamp,price);\\n\\t\\t\\t\\tif(timestamp>current){\\n\\t\\t\\t\\t\\tcurrent= timestamp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tStock s = new Stock(price,timestamp);\\n\\t\\t\\t\\tmaxQ.offer(s);\\n\\t\\t\\t\\tminQ.offer(s);\\n\\t}\\n    \\n\\tpublic int current() {\\n   \\t return priceMap.get(current);\\n\\t}\\n    \\n\\tpublic int maximum() {\\n\\t\\t\\twhile(maxQ.peek().price!=priceMap.get(maxQ.peek().timestamp)){\\n\\t\\t\\t\\tmaxQ.poll();\\n\\t\\t\\t}\\n   \\t return maxQ.peek().price;\\n\\t}\\n    \\n\\tpublic int minimum() {\\n\\t\\t\\twhile(minQ.peek().price!=priceMap.get(minQ.peek().timestamp)){\\n\\t\\t\\t\\tminQ.poll();\\n\\t\\t\\t}\\n   \\t return minQ.peek().price;\\n\\t}\\n\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */ \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StockPrice {\\n\\nclass Stock{\\n\\tint price;\\n\\tint timestamp;\\n\\tpublic Stock(int price,int timestamp){\\n\\t\\tthis.price = price;\\n\\t\\tthis.timestamp = timestamp;\\n\\t}\\n}\\n\\n\\tint current;\\n\\tPriorityQueue<Stock> maxQ ;\\n\\tPriorityQueue<Stock> minQ ;\\n\\tMap<Integer,Integer> priceMap;\\n\\tpublic StockPrice() {\\n   \\t    current=0;\\n\\t\\tpriceMap = new HashMap<>();\\n\\t\\tmaxQ =new PriorityQueue<>((s1,s2)-> s2.price-s1.price);\\n\\t\\tminQ =new PriorityQueue<>((s1,s2)-> s1.price-s2.price);\\n\\t}\\n    \\n\\tpublic void update(int timestamp, int price) {\\n   \\t priceMap.put(timestamp,price);\\n\\t\\t\\t\\tif(timestamp>current){\\n\\t\\t\\t\\t\\tcurrent= timestamp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tStock s = new Stock(price,timestamp);\\n\\t\\t\\t\\tmaxQ.offer(s);\\n\\t\\t\\t\\tminQ.offer(s);\\n\\t}\\n    \\n\\tpublic int current() {\\n   \\t return priceMap.get(current);\\n\\t}\\n    \\n\\tpublic int maximum() {\\n\\t\\t\\twhile(maxQ.peek().price!=priceMap.get(maxQ.peek().timestamp)){\\n\\t\\t\\t\\tmaxQ.poll();\\n\\t\\t\\t}\\n   \\t return maxQ.peek().price;\\n\\t}\\n    \\n\\tpublic int minimum() {\\n\\t\\t\\twhile(minQ.peek().price!=priceMap.get(minQ.peek().timestamp)){\\n\\t\\t\\t\\tminQ.poll();\\n\\t\\t\\t}\\n   \\t return minQ.peek().price;\\n\\t}\\n\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */ \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926587,
                "title": "beat-java-solution-priority-queue-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass StockRecord {\\n    int timestamp;\\n    int price;\\n    \\n    public StockRecord(){}\\n    \\n    public StockRecord(int t, int p) {\\n        timestamp = t;\\n        price = p;\\n    }\\n}\\n\\nclass StockPrice {\\n    \\n    PriorityQueue<StockRecord> max = new PriorityQueue<>((sr1, sr2) -> (sr2.price - sr1.price));\\n    PriorityQueue<StockRecord> min = new PriorityQueue<>((sr1, sr2) -> (sr1.price - sr2.price));\\n    StockRecord current_record;\\n    Map<Integer, Integer> map = new HashMap<>();\\n\\n    \\n    public StockPrice() {\\n        current_record = new StockRecord();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= current_record.timestamp) {\\n            current_record.timestamp = timestamp;\\n            current_record.price = price;\\n        }\\n        \\n        StockRecord sr = new StockRecord(timestamp, price);\\n        max.add(sr);\\n        min.add(sr);\\n        map.put(timestamp, price);\\n    }\\n    \\n    public int current() {\\n        return current_record.price;\\n    }\\n    \\n    public int maximum() {\\n        StockRecord sp = max.peek();\\n        while(true) {\\n            sp = max.peek();\\n            if(sp.price != map.get(sp.timestamp))\\n                max.poll();\\n            else break;\\n        }\\n        return sp.price;\\n    }\\n    \\n    public int minimum() {\\n        StockRecord sp = min.peek();\\n         while(true) {\\n            sp = min.peek();\\n            if(sp.price != map.get(sp.timestamp))\\n                min.poll();\\n            else break;\\n        }\\n        return sp.price;\\n    }\\n}\\n\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StockRecord {\\n    int timestamp;\\n    int price;\\n    \\n    public StockRecord(){}\\n    \\n    public StockRecord(int t, int p) {\\n        timestamp = t;\\n        price = p;\\n    }\\n}\\n\\nclass StockPrice {\\n    \\n    PriorityQueue<StockRecord> max = new PriorityQueue<>((sr1, sr2) -> (sr2.price - sr1.price));\\n    PriorityQueue<StockRecord> min = new PriorityQueue<>((sr1, sr2) -> (sr1.price - sr2.price));\\n    StockRecord current_record;\\n    Map<Integer, Integer> map = new HashMap<>();\\n\\n    \\n    public StockPrice() {\\n        current_record = new StockRecord();\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= current_record.timestamp) {\\n            current_record.timestamp = timestamp;\\n            current_record.price = price;\\n        }\\n        \\n        StockRecord sr = new StockRecord(timestamp, price);\\n        max.add(sr);\\n        min.add(sr);\\n        map.put(timestamp, price);\\n    }\\n    \\n    public int current() {\\n        return current_record.price;\\n    }\\n    \\n    public int maximum() {\\n        StockRecord sp = max.peek();\\n        while(true) {\\n            sp = max.peek();\\n            if(sp.price != map.get(sp.timestamp))\\n                max.poll();\\n            else break;\\n        }\\n        return sp.price;\\n    }\\n    \\n    public int minimum() {\\n        StockRecord sp = min.peek();\\n         while(true) {\\n            sp = min.peek();\\n            if(sp.price != map.get(sp.timestamp))\\n                min.poll();\\n            else break;\\n        }\\n        return sp.price;\\n    }\\n}\\n\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918559,
                "title": "using-two-sets-and-unordered-map",
                "content": "class StockPrice {\\n    private:\\n    set<pair<int,int>> set_stock;\\n    unordered_map<int,int> map_id;\\n    set<int> set_curr;\\npublic:\\n    StockPrice() {\\n        set_stock.clear();\\n        map_id.clear();\\n        set_curr.clear();\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(map_id.count(timestamp)){\\n            int oPrice=map_id[timestamp];\\n            set_stock.erase({oPrice,timestamp});\\n            map_id.erase(timestamp);\\n        }\\n        map_id[timestamp]=price;\\n        set_stock.insert({price,timestamp});\\n        set_curr.insert(timestamp);\\n    }\\n    \\n    int current() {\\n        auto it=set_curr.rbegin();\\n        int ans=map_id[*it];\\n        return ans;\\n    }\\n    \\n    int maximum() {\\n        auto it=set_stock.rbegin();\\n        int ans=it->first;\\n        return ans;\\n    }\\n    \\n    int minimum() {\\n        auto it=set_stock.begin();\\n        int ans=it->first;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */",
                "solutionTags": [],
                "code": "class StockPrice {\\n    private:\\n    set<pair<int,int>> set_stock;\\n    unordered_map<int,int> map_id;\\n    set<int> set_curr;\\npublic:\\n    StockPrice() {\\n        set_stock.clear();\\n        map_id.clear();\\n        set_curr.clear();\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(map_id.count(timestamp)){\\n            int oPrice=map_id[timestamp];\\n            set_stock.erase({oPrice,timestamp});\\n            map_id.erase(timestamp);\\n        }\\n        map_id[timestamp]=price;\\n        set_stock.insert({price,timestamp});\\n        set_curr.insert(timestamp);\\n    }\\n    \\n    int current() {\\n        auto it=set_curr.rbegin();\\n        int ans=map_id[*it];\\n        return ans;\\n    }\\n    \\n    int maximum() {\\n        auto it=set_stock.rbegin();\\n        int ans=it->first;\\n        return ans;\\n    }\\n    \\n    int minimum() {\\n        auto it=set_stock.begin();\\n        int ans=it->first;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3907714,
                "title": "golang-beats-100-two-heaps-maps-o-1",
                "content": "# Code\\n```\\ntype StockPrice struct {\\n    cache map[int]*element\\n    max *DynamicHeap\\n    min *DynamicHeap\\n    maxTS int\\n    maxPrice int\\n}\\n\\n\\nfunc Constructor() StockPrice {    \\n    return StockPrice{\\n        cache:map[int]*element{},\\n        min:&DynamicHeap{min:true},\\n        max:&DynamicHeap{},\\n    }\\n}\\n\\n\\nfunc (this *StockPrice) Update(timestamp int, price int)  {\\n    if timestamp>=this.maxTS{\\n        this.maxTS=timestamp\\n        this.maxPrice=price\\n    }\\n\\n    e,ok:=this.cache[timestamp]\\n    if ok{\\n        e.price=price\\n        heap.Fix(this.min,e.minIdx)\\n        heap.Fix(this.max,e.maxIdx)\\n        return\\n    }\\n\\n    e=&element{price:price}\\n    heap.Push(this.min,e)    \\n    heap.Push(this.max,e)    \\n    this.cache[timestamp]=e\\n}\\n\\n\\nfunc (this *StockPrice) Current() int {    \\n    return this.maxPrice\\n}\\n\\n\\nfunc (this *StockPrice) Minimum() int {        \\n    return this.min.elements[0].price\\n}\\n\\n\\nfunc (this *StockPrice) Maximum() int {    \\n    return this.max.elements[0].price\\n}\\n\\n\\ntype element struct {    \\n    price int\\n    minIdx int\\n    maxIdx int\\n}\\n\\n// A DynamicHeap implements heap.Interface and holds Items.\\ntype DynamicHeap struct{\\n    elements []*element    \\n    min bool\\n}\\n\\nfunc (dh DynamicHeap) Len() int { return len(dh.elements) }\\n\\nfunc (dh DynamicHeap) Less(i, j int) bool {\\n    if dh.min {\\n        return dh.elements[i].price<dh.elements[j].price\\n    }\\n\\n\\treturn dh.elements[i].price>dh.elements[j].price\\n}\\n\\nfunc (dh DynamicHeap) Swap(i, j int) {\\n\\tdh.elements[i], dh.elements[j] = dh.elements[j], dh.elements[i]\\t    \\n    if dh.min {\\n        dh.elements[i].minIdx = i\\n        dh.elements[j].minIdx = j        \\n        return\\n    }\\n    dh.elements[i].maxIdx = i\\n    dh.elements[j].maxIdx = j    \\n}\\n\\nfunc (dh *DynamicHeap) Push(x any) {\\n\\tn := len(dh.elements)\\n\\titem := x.(*element)\\n    dh.elements = append(dh.elements, item)\\n    if dh.min {\\n\\t    item.minIdx = n\\n        return\\n    }\\n    item.maxIdx = n    \\n}\\n\\n// noop\\nfunc (dh *DynamicHeap) Pop() any {\\n\\treturn nil\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Update(timestamp,price);\\n * param_2 := obj.Current();\\n * param_3 := obj.Maximum();\\n * param_4 := obj.Minimum();\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype StockPrice struct {\\n    cache map[int]*element\\n    max *DynamicHeap\\n    min *DynamicHeap\\n    maxTS int\\n    maxPrice int\\n}\\n\\n\\nfunc Constructor() StockPrice {    \\n    return StockPrice{\\n        cache:map[int]*element{},\\n        min:&DynamicHeap{min:true},\\n        max:&DynamicHeap{},\\n    }\\n}\\n\\n\\nfunc (this *StockPrice) Update(timestamp int, price int)  {\\n    if timestamp>=this.maxTS{\\n        this.maxTS=timestamp\\n        this.maxPrice=price\\n    }\\n\\n    e,ok:=this.cache[timestamp]\\n    if ok{\\n        e.price=price\\n        heap.Fix(this.min,e.minIdx)\\n        heap.Fix(this.max,e.maxIdx)\\n        return\\n    }\\n\\n    e=&element{price:price}\\n    heap.Push(this.min,e)    \\n    heap.Push(this.max,e)    \\n    this.cache[timestamp]=e\\n}\\n\\n\\nfunc (this *StockPrice) Current() int {    \\n    return this.maxPrice\\n}\\n\\n\\nfunc (this *StockPrice) Minimum() int {        \\n    return this.min.elements[0].price\\n}\\n\\n\\nfunc (this *StockPrice) Maximum() int {    \\n    return this.max.elements[0].price\\n}\\n\\n\\ntype element struct {    \\n    price int\\n    minIdx int\\n    maxIdx int\\n}\\n\\n// A DynamicHeap implements heap.Interface and holds Items.\\ntype DynamicHeap struct{\\n    elements []*element    \\n    min bool\\n}\\n\\nfunc (dh DynamicHeap) Len() int { return len(dh.elements) }\\n\\nfunc (dh DynamicHeap) Less(i, j int) bool {\\n    if dh.min {\\n        return dh.elements[i].price<dh.elements[j].price\\n    }\\n\\n\\treturn dh.elements[i].price>dh.elements[j].price\\n}\\n\\nfunc (dh DynamicHeap) Swap(i, j int) {\\n\\tdh.elements[i], dh.elements[j] = dh.elements[j], dh.elements[i]\\t    \\n    if dh.min {\\n        dh.elements[i].minIdx = i\\n        dh.elements[j].minIdx = j        \\n        return\\n    }\\n    dh.elements[i].maxIdx = i\\n    dh.elements[j].maxIdx = j    \\n}\\n\\nfunc (dh *DynamicHeap) Push(x any) {\\n\\tn := len(dh.elements)\\n\\titem := x.(*element)\\n    dh.elements = append(dh.elements, item)\\n    if dh.min {\\n\\t    item.minIdx = n\\n        return\\n    }\\n    item.maxIdx = n    \\n}\\n\\n// noop\\nfunc (dh *DynamicHeap) Pop() any {\\n\\treturn nil\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Update(timestamp,price);\\n * param_2 := obj.Current();\\n * param_3 := obj.Maximum();\\n * param_4 := obj.Minimum();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3826066,
                "title": "python-using-2-heaps",
                "content": "# Intuition\\n1. Maintain dictonary to track timestamp, stock price\\n2. Maintain a variable latestTime to track the latest price of stock\\n3. Keep a maxHeap which will have (-price, timestamp). The max price will always be at 0th index\\n4. Keep a min heap which will have (price, timestamp). Min price will always be at 0th index\\n\\nDuring max, min function call, pop value from maxHeap and minHeap till the value of (timestamp, stockprice) matches in the dictonary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.stockDict = collections.defaultdict(int)\\n        self.latestTime = 0\\n        self.maxHeap = []\\n        self.minHeap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.latestTime = max(timestamp, self.latestTime)        \\n        self.stockDict[timestamp] = price\\n\\n        heapq.heappush(self.maxHeap, (-price, timestamp))\\n        heapq.heappush(self.minHeap, (price, timestamp))\\n        \\n    def current(self) -> int:\\n        return self.stockDict[self.latestTime]\\n\\n    def maximum(self) -> int:\\n        price, timestamp = self.maxHeap[0]\\n        while -price != self.stockDict[timestamp]:\\n            heapq.heappop(self.maxHeap)\\n            price, timestamp = self.maxHeap[0]\\n        return -price\\n\\n    def minimum(self) -> int:\\n        price, timestamp = self.minHeap[0]\\n        while price != self.stockDict[timestamp]:\\n            heapq.heappop(self.minHeap)\\n            price, timestamp = self.minHeap[0]\\n        return price\\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.stockDict = collections.defaultdict(int)\\n        self.latestTime = 0\\n        self.maxHeap = []\\n        self.minHeap = []\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.latestTime = max(timestamp, self.latestTime)        \\n        self.stockDict[timestamp] = price\\n\\n        heapq.heappush(self.maxHeap, (-price, timestamp))\\n        heapq.heappush(self.minHeap, (price, timestamp))\\n        \\n    def current(self) -> int:\\n        return self.stockDict[self.latestTime]\\n\\n    def maximum(self) -> int:\\n        price, timestamp = self.maxHeap[0]\\n        while -price != self.stockDict[timestamp]:\\n            heapq.heappop(self.maxHeap)\\n            price, timestamp = self.maxHeap[0]\\n        return -price\\n\\n    def minimum(self) -> int:\\n        price, timestamp = self.minHeap[0]\\n        while price != self.stockDict[timestamp]:\\n            heapq.heappop(self.minHeap)\\n            price, timestamp = self.minHeap[0]\\n        return price\\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806401,
                "title": "java-sorted-map-hashmap",
                "content": "```\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.Map;\\nimport java.util.Set;\\nimport java.util.SortedMap;\\nimport java.util.TreeMap;\\n\\nimport static java.lang.Integer.MIN_VALUE;\\n\\npublic class StockPrice {\\n    private final Map<Integer, Integer> m;\\n    private final SortedMap<Integer, Set<Integer>> sm;\\n\\n    private int latestTs, latestPrice;\\n\\n    public StockPrice() {\\n        this.m = new HashMap<>(); // mapping from timestamp to corresponding latest price\\n        this.sm = new TreeMap<>(); // mapping from price to corresponding timestamps\\n        this.latestTs = MIN_VALUE;\\n    }\\n\\n    public void update(int timestamp, int price) {\\n        if (timestamp >= latestTs) {\\n            latestPrice = price;\\n\\n            if (timestamp > latestTs)\\n                latestTs = timestamp;\\n        }\\n\\n        var oldPrice = m.put(timestamp, price);\\n\\n        if (oldPrice != null) {\\n            var ts = sm.get(oldPrice);\\n            ts.remove(timestamp);\\n\\n            if (ts.isEmpty())\\n                sm.remove(oldPrice);\\n        }\\n\\n        sm.computeIfAbsent(price, p -> new HashSet<>()).add(timestamp);\\n    }\\n\\n    public int current() {\\n        return latestPrice; // O(1)\\n    }\\n\\n    public int maximum() {\\n        return sm.lastKey(); // O(log(n)) where n is number of unique prices seen\\n    }\\n\\n    public int minimum() {\\n        return sm.firstKey(); // O(log(n)) where n is number of unique prices seen\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.Map;\\nimport java.util.Set;\\nimport java.util.SortedMap;\\nimport java.util.TreeMap;\\n\\nimport static java.lang.Integer.MIN_VALUE;\\n\\npublic class StockPrice {\\n    private final Map<Integer, Integer> m;\\n    private final SortedMap<Integer, Set<Integer>> sm;\\n\\n    private int latestTs, latestPrice;\\n\\n    public StockPrice() {\\n        this.m = new HashMap<>(); // mapping from timestamp to corresponding latest price\\n        this.sm = new TreeMap<>(); // mapping from price to corresponding timestamps\\n        this.latestTs = MIN_VALUE;\\n    }\\n\\n    public void update(int timestamp, int price) {\\n        if (timestamp >= latestTs) {\\n            latestPrice = price;\\n\\n            if (timestamp > latestTs)\\n                latestTs = timestamp;\\n        }\\n\\n        var oldPrice = m.put(timestamp, price);\\n\\n        if (oldPrice != null) {\\n            var ts = sm.get(oldPrice);\\n            ts.remove(timestamp);\\n\\n            if (ts.isEmpty())\\n                sm.remove(oldPrice);\\n        }\\n\\n        sm.computeIfAbsent(price, p -> new HashSet<>()).add(timestamp);\\n    }\\n\\n    public int current() {\\n        return latestPrice; // O(1)\\n    }\\n\\n    public int maximum() {\\n        return sm.lastKey(); // O(log(n)) where n is number of unique prices seen\\n    }\\n\\n    public int minimum() {\\n        return sm.firstKey(); // O(log(n)) where n is number of unique prices seen\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776055,
                "title": "c-solution-using-two-maps",
                "content": "# Code\\n```\\n// Space Complexity = O(n)\\n// Time Complexity  = O(nlogn)\\n\\nclass StockPrice {\\npublic:\\n    int maxtimestamp = 0;\\n    unordered_map<int,int> timeprice;\\n    map<int,int> pricecount;\\n\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        maxtimestamp = max(maxtimestamp, timestamp);\\n        int curprice = timeprice[timestamp];\\n        if (curprice != 0) {\\n            --pricecount[curprice];\\n            if (pricecount[curprice] == 0) {\\n                pricecount.erase(curprice);\\n                // solution using an extra set gives TLE\\n                // auto it = lower_bound(ms.begin(), ms.end(), curprice);\\n                // ms.erase(it);\\n            }\\n        }\\n        pricecount[price]++;\\n        timeprice[timestamp] = price;\\n    }\\n    \\n    int current() {\\n        return timeprice[maxtimestamp];\\n    }\\n    \\n    int maximum() {\\n        auto it = pricecount.end();\\n        --it;\\n        return (*it).first;\\n    }\\n    \\n    int minimum() {\\n        auto it = pricecount.begin();\\n        return (*it).first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Space Complexity = O(n)\\n// Time Complexity  = O(nlogn)\\n\\nclass StockPrice {\\npublic:\\n    int maxtimestamp = 0;\\n    unordered_map<int,int> timeprice;\\n    map<int,int> pricecount;\\n\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        maxtimestamp = max(maxtimestamp, timestamp);\\n        int curprice = timeprice[timestamp];\\n        if (curprice != 0) {\\n            --pricecount[curprice];\\n            if (pricecount[curprice] == 0) {\\n                pricecount.erase(curprice);\\n                // solution using an extra set gives TLE\\n                // auto it = lower_bound(ms.begin(), ms.end(), curprice);\\n                // ms.erase(it);\\n            }\\n        }\\n        pricecount[price]++;\\n        timeprice[timestamp] = price;\\n    }\\n    \\n    int current() {\\n        return timeprice[maxtimestamp];\\n    }\\n    \\n    int maximum() {\\n        auto it = pricecount.end();\\n        --it;\\n        return (*it).first;\\n    }\\n    \\n    int minimum() {\\n        auto it = pricecount.begin();\\n        return (*it).first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722813,
                "title": "c-made-simple-2-priorityqueues-hashmap",
                "content": "# Code\\n```\\npublic class StockPrice {\\n\\n    Dictionary<int, int> records;\\n    PriorityQueue<(int, int), int> maxQueue;\\n    PriorityQueue<(int, int), int> minQueue;\\n    int latestRecord;\\n\\n    public StockPrice() {\\n        this.records = new Dictionary<int, int>();\\n        this.latestRecord = 0;\\n        this.maxQueue = new PriorityQueue<(int, int), int>();\\n        this.minQueue = new PriorityQueue<(int, int), int>();\\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        this.records[timestamp] = price;\\n        this.latestRecord = Math.Max(this.latestRecord, timestamp);\\n        this.minQueue.Enqueue((timestamp, price), price);\\n        this.maxQueue.Enqueue((timestamp, price), -price);\\n\\n        while (maxQueue.Count > 0){\\n            var temp = this.maxQueue.Peek();\\n            var tempTime = temp.Item1;\\n            var tempCost = temp.Item2;\\n\\n            if (this.records[tempTime] == tempCost){\\n                break;\\n            }\\n\\n            _ = maxQueue.Dequeue();\\n        }\\n\\n        while (minQueue.Count > 0){\\n            var temp = this.minQueue.Peek();\\n            var tempTime = temp.Item1;\\n            var tempCost = temp.Item2;\\n\\n            if (this.records[tempTime] == tempCost){\\n                break;\\n            }\\n\\n            _ = minQueue.Dequeue();\\n        }\\n    }\\n    \\n    public int Current() {\\n        return this.records[this.latestRecord];\\n    }\\n    \\n    public int Maximum() {\\n        var temp = this.maxQueue.Peek();\\n        return temp.Item2;\\n    }\\n    \\n    public int Minimum() {\\n        var temp = this.minQueue.Peek();\\n        return temp.Item2;\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.Update(timestamp,price);\\n * int param_2 = obj.Current();\\n * int param_3 = obj.Maximum();\\n * int param_4 = obj.Minimum();\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class StockPrice {\\n\\n    Dictionary<int, int> records;\\n    PriorityQueue<(int, int), int> maxQueue;\\n    PriorityQueue<(int, int), int> minQueue;\\n    int latestRecord;\\n\\n    public StockPrice() {\\n        this.records = new Dictionary<int, int>();\\n        this.latestRecord = 0;\\n        this.maxQueue = new PriorityQueue<(int, int), int>();\\n        this.minQueue = new PriorityQueue<(int, int), int>();\\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        this.records[timestamp] = price;\\n        this.latestRecord = Math.Max(this.latestRecord, timestamp);\\n        this.minQueue.Enqueue((timestamp, price), price);\\n        this.maxQueue.Enqueue((timestamp, price), -price);\\n\\n        while (maxQueue.Count > 0){\\n            var temp = this.maxQueue.Peek();\\n            var tempTime = temp.Item1;\\n            var tempCost = temp.Item2;\\n\\n            if (this.records[tempTime] == tempCost){\\n                break;\\n            }\\n\\n            _ = maxQueue.Dequeue();\\n        }\\n\\n        while (minQueue.Count > 0){\\n            var temp = this.minQueue.Peek();\\n            var tempTime = temp.Item1;\\n            var tempCost = temp.Item2;\\n\\n            if (this.records[tempTime] == tempCost){\\n                break;\\n            }\\n\\n            _ = minQueue.Dequeue();\\n        }\\n    }\\n    \\n    public int Current() {\\n        return this.records[this.latestRecord];\\n    }\\n    \\n    public int Maximum() {\\n        var temp = this.maxQueue.Peek();\\n        return temp.Item2;\\n    }\\n    \\n    public int Minimum() {\\n        var temp = this.minQueue.Peek();\\n        return temp.Item2;\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.Update(timestamp,price);\\n * int param_2 = obj.Current();\\n * int param_3 = obj.Maximum();\\n * int param_4 = obj.Minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613800,
                "title": "c-priority-queue-map-o-nlog-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need minimum and maximum stock until latest timestamp. We can handle this with priority queue. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll maintain two priority queues, minStock and maxStock storing minimum and maximum stocks first among all the stocks we have. Also we\\'ll maintain the valid stocks (e.g. latest updates only, older stocks with same timestamp must be ommited). To maintain the valid stocks we\\'ll use a map that stores the latest stock value in a specific timestamp.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass StockPrice {\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minStock;\\n    priority_queue<pair<int, int>> maxStock;\\n    map<int, int> stockValue;\\npublic:\\n    StockPrice() {\\n        while (!minStock.empty()) minStock.pop();\\n        while (!maxStock.empty()) maxStock.pop();\\n        stockValue.clear();\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        stockValue[timestamp] = price;\\n        minStock.push({price, timestamp});\\n        maxStock.push({price, timestamp});\\n    }\\n    \\n    int current() {\\n        return stockValue.rbegin()->second;\\n    }\\n    \\n    int maximum() {\\n        while (!maxStock.empty() && stockValue[maxStock.top().second] != maxStock.top().first) {\\n            maxStock.pop();\\n        }\\n        return maxStock.top().first;\\n    }\\n    \\n    int minimum() {\\n        while (!minStock.empty() && stockValue[minStock.top().second] != minStock.top().first) {\\n            minStock.pop();\\n        }\\n        return minStock.top().first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass StockPrice {\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minStock;\\n    priority_queue<pair<int, int>> maxStock;\\n    map<int, int> stockValue;\\npublic:\\n    StockPrice() {\\n        while (!minStock.empty()) minStock.pop();\\n        while (!maxStock.empty()) maxStock.pop();\\n        stockValue.clear();\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        stockValue[timestamp] = price;\\n        minStock.push({price, timestamp});\\n        maxStock.push({price, timestamp});\\n    }\\n    \\n    int current() {\\n        return stockValue.rbegin()->second;\\n    }\\n    \\n    int maximum() {\\n        while (!maxStock.empty() && stockValue[maxStock.top().second] != maxStock.top().first) {\\n            maxStock.pop();\\n        }\\n        return maxStock.top().first;\\n    }\\n    \\n    int minimum() {\\n        while (!minStock.empty() && stockValue[minStock.top().second] != minStock.top().first) {\\n            minStock.pop();\\n        }\\n        return minStock.top().first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602213,
                "title": "scala-solution-with-sortedset-sortedmap",
                "content": "```\\nclass StockPrice() {\\n  val set = collection.mutable.SortedSet.empty[(Int,Int)]\\n  val map = collection.mutable.SortedMap.empty[Int,Int]\\n\\n  def update(timestamp: Int, price: Int): Unit =  {\\n    if(map.contains(timestamp)) { set -= ((map(timestamp),timestamp))}\\n    set += ((price,timestamp))\\n    map += ((timestamp,price))\\n  }\\n\\n  def current(): Int = map.last._2\\n\\n  def maximum(): Int = set.last._1\\n\\n  def minimum(): Int = set.head._1\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * var obj = new StockPrice()\\n * obj.update(timestamp,price)\\n * var param_2 = obj.current()\\n * var param_3 = obj.maximum()\\n * var param_4 = obj.minimum()\\n */\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nclass StockPrice() {\\n  val set = collection.mutable.SortedSet.empty[(Int,Int)]\\n  val map = collection.mutable.SortedMap.empty[Int,Int]\\n\\n  def update(timestamp: Int, price: Int): Unit =  {\\n    if(map.contains(timestamp)) { set -= ((map(timestamp),timestamp))}\\n    set += ((price,timestamp))\\n    map += ((timestamp,price))\\n  }\\n\\n  def current(): Int = map.last._2\\n\\n  def maximum(): Int = set.last._1\\n\\n  def minimum(): Int = set.head._1\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * var obj = new StockPrice()\\n * obj.update(timestamp,price)\\n * var param_2 = obj.current()\\n * var param_3 = obj.maximum()\\n * var param_4 = obj.minimum()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583496,
                "title": "c-solution-using-heap",
                "content": "# Code\\n```\\npublic class StockPrice {\\n    private Dictionary<int, int> cache;\\n    private int latestTimestamp;\\n    private PriorityQueue<int, int> minHeap, maxHeap;\\n\\n    public StockPrice() {\\n        cache = new Dictionary<int, int>();\\n        minHeap = new PriorityQueue<int, int>();\\n        maxHeap = new PriorityQueue<int, int>();\\n        latestTimestamp = 0;        \\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        cache[timestamp] = price;\\n        minHeap.Enqueue(timestamp, price);\\n        maxHeap.Enqueue(timestamp, -price);\\n        latestTimestamp = Math.Max(latestTimestamp, timestamp);           \\n    }\\n    \\n    public int Current() {\\n        return cache[latestTimestamp];\\n    }\\n    \\n    public int Maximum() {\\n        maxHeap.TryPeek(out int topTimestamp, out int topPrice);\\n        topPrice *= -1;\\n        while(cache[topTimestamp] != topPrice) {\\n            maxHeap.Dequeue();\\n            maxHeap.TryPeek(out topTimestamp,out topPrice);   \\n            topPrice *= -1;\\n        }\\n\\n        return topPrice;\\n    }\\n    \\n    public int Minimum() {\\n        minHeap.TryPeek(out int topTimestamp, out int topPrice);\\n        while(cache[topTimestamp] != topPrice) {\\n            minHeap.Dequeue();\\n            minHeap.TryPeek(out topTimestamp,out topPrice);   \\n        }\\n\\n        return topPrice;\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.Update(timestamp,price);\\n * int param_2 = obj.Current();\\n * int param_3 = obj.Maximum();\\n * int param_4 = obj.Minimum();\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class StockPrice {\\n    private Dictionary<int, int> cache;\\n    private int latestTimestamp;\\n    private PriorityQueue<int, int> minHeap, maxHeap;\\n\\n    public StockPrice() {\\n        cache = new Dictionary<int, int>();\\n        minHeap = new PriorityQueue<int, int>();\\n        maxHeap = new PriorityQueue<int, int>();\\n        latestTimestamp = 0;        \\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        cache[timestamp] = price;\\n        minHeap.Enqueue(timestamp, price);\\n        maxHeap.Enqueue(timestamp, -price);\\n        latestTimestamp = Math.Max(latestTimestamp, timestamp);           \\n    }\\n    \\n    public int Current() {\\n        return cache[latestTimestamp];\\n    }\\n    \\n    public int Maximum() {\\n        maxHeap.TryPeek(out int topTimestamp, out int topPrice);\\n        topPrice *= -1;\\n        while(cache[topTimestamp] != topPrice) {\\n            maxHeap.Dequeue();\\n            maxHeap.TryPeek(out topTimestamp,out topPrice);   \\n            topPrice *= -1;\\n        }\\n\\n        return topPrice;\\n    }\\n    \\n    public int Minimum() {\\n        minHeap.TryPeek(out int topTimestamp, out int topPrice);\\n        while(cache[topTimestamp] != topPrice) {\\n            minHeap.Dequeue();\\n            minHeap.TryPeek(out topTimestamp,out topPrice);   \\n        }\\n\\n        return topPrice;\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.Update(timestamp,price);\\n * int param_2 = obj.Current();\\n * int param_3 = obj.Maximum();\\n * int param_4 = obj.Minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581679,
                "title": "using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass StockPrice {\\npublic:\\n    int cur;\\n    int maxx = INT_MIN;\\n    unordered_map<int,int>mp;\\n    map<int,int>mpp;\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(maxx<=timestamp){\\n            maxx = timestamp;\\n            cur = price;\\n        }\\n        if(mp.find(timestamp)==mp.end()){\\n              mpp[price]++;\\n              mp[timestamp]=price;\\n        }\\n        else{\\n           mpp[mp[timestamp]]--;\\n           if(mpp[mp[timestamp]]==0)mpp.erase(mp[timestamp]);\\n           mpp[price]++;\\n           mp[timestamp] = price;\\n        } \\n    }\\n    \\n    int current() {\\n        return cur;\\n    }\\n    \\n    int maximum() {\\n        auto it = mpp.rbegin();\\n        return it->first;\\n    }\\n    \\n    int minimum() {\\n        auto it = mpp.begin();\\n        return it->first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    int cur;\\n    int maxx = INT_MIN;\\n    unordered_map<int,int>mp;\\n    map<int,int>mpp;\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if(maxx<=timestamp){\\n            maxx = timestamp;\\n            cur = price;\\n        }\\n        if(mp.find(timestamp)==mp.end()){\\n              mpp[price]++;\\n              mp[timestamp]=price;\\n        }\\n        else{\\n           mpp[mp[timestamp]]--;\\n           if(mpp[mp[timestamp]]==0)mpp.erase(mp[timestamp]);\\n           mpp[price]++;\\n           mp[timestamp] = price;\\n        } \\n    }\\n    \\n    int current() {\\n        return cur;\\n    }\\n    \\n    int maximum() {\\n        auto it = mpp.rbegin();\\n        return it->first;\\n    }\\n    \\n    int minimum() {\\n        auto it = mpp.begin();\\n        return it->first;\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577844,
                "title": "cpp-simple-solution-using-map-and-multiset",
                "content": "```\\nclass StockPrice {\\npublic:\\n    unordered_map<int,int> mpp;\\n    multiset<int> st;\\n    long long lat=0;\\n\\t\\n    StockPrice() { }\\n    \\n    void update(int timestamp, int price) {\\n        if(mpp.count(timestamp)==0)\\n        {\\n            mpp[timestamp]=price;\\n            if(lat<=timestamp)\\n            lat = timestamp;\\n            st.insert(price);\\n        }\\n        else{\\n            auto it = st.find(mpp[timestamp]);\\n            if(it!=st.end())\\n            st.erase(it);\\n            mpp[timestamp]=price;\\n            st.insert(price);\\n        }\\n    }\\n    \\n    int current() { return mpp[lat]; }\\n    \\n    int maximum() { return *st.rbegin(); }\\n    \\n    int minimum() { return *st.begin(); }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass StockPrice {\\npublic:\\n    unordered_map<int,int> mpp;\\n    multiset<int> st;\\n    long long lat=0;\\n\\t\\n    StockPrice() { }\\n    \\n    void update(int timestamp, int price) {\\n        if(mpp.count(timestamp)==0)\\n        {\\n            mpp[timestamp]=price;\\n            if(lat<=timestamp)\\n            lat = timestamp;\\n            st.insert(price);\\n        }\\n        else{\\n            auto it = st.find(mpp[timestamp]);\\n            if(it!=st.end())\\n            st.erase(it);\\n            mpp[timestamp]=price;\\n            st.insert(price);\\n        }\\n    }\\n    \\n    int current() { return mpp[lat]; }\\n    \\n    int maximum() { return *st.rbegin(); }\\n    \\n    int minimum() { return *st.begin(); }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514730,
                "title": "using-set-pair-and-hashmap",
                "content": "```\\nclass StockPrice {\\nprivate:\\n    map<int, int> prices;\\n    set<pair<int, int>> max_prices;\\n    set<pair<int, int>> min_prices;\\npublic:\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        // Update the price at the given timestamp\\n        auto it = prices.find(timestamp);\\n        if(it != prices.end()) {\\n            // Remove the old price-timestamp pairs from the max and min prices sets\\n            max_prices.erase({it->second, timestamp});\\n            min_prices.erase({it->second, timestamp});\\n        }\\n        prices[timestamp] = price;\\n\\n        // Update the max price\\n        max_prices.insert({price, timestamp});\\n\\n        // Update the min price\\n        min_prices.insert({price, timestamp});\\n    }\\n    \\n    int current() {\\n        // Return the latest price of the stock\\n        return prices.rbegin()->second;\\n    }\\n    \\n    int maximum() {\\n        // Return the maximum price of the stock\\n        auto max_pair = *max_prices.rbegin();\\n        if(prices[max_pair.second] == max_pair.first) {\\n            // If the max price is from the latest timestamp, return it directly\\n            return max_pair.first;\\n        } \\n        else {\\n            // Otherwise, search for the latest price with the same value\\n            for(auto it = prices.rbegin(); it != prices.rend(); ++it) {\\n                if(it->second == max_pair.first) {\\n                    return max_pair.first;\\n                }\\n            }\\n        }\\n        return -1; // No max price found\\n    }\\n    \\n    int minimum() {\\n        // Return the minimum price of the stock\\n        auto min_pair = *min_prices.begin();\\n        if(prices[min_pair.second] == min_pair.first) {\\n            // If the min price is from the latest timestamp, return it directly\\n            return min_pair.first;\\n        } \\n        else {\\n            // Otherwise, search for the latest price with the same value\\n            for(auto it = prices.rbegin(); it != prices.rend(); ++it) {\\n                if(it->second == min_pair.first) {\\n                    return min_pair.first;\\n                }\\n            }\\n        }\\n        return -1; // No min price found\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass StockPrice {\\nprivate:\\n    map<int, int> prices;\\n    set<pair<int, int>> max_prices;\\n    set<pair<int, int>> min_prices;\\npublic:\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        // Update the price at the given timestamp\\n        auto it = prices.find(timestamp);\\n        if(it != prices.end()) {\\n            // Remove the old price-timestamp pairs from the max and min prices sets\\n            max_prices.erase({it->second, timestamp});\\n            min_prices.erase({it->second, timestamp});\\n        }\\n        prices[timestamp] = price;\\n\\n        // Update the max price\\n        max_prices.insert({price, timestamp});\\n\\n        // Update the min price\\n        min_prices.insert({price, timestamp});\\n    }\\n    \\n    int current() {\\n        // Return the latest price of the stock\\n        return prices.rbegin()->second;\\n    }\\n    \\n    int maximum() {\\n        // Return the maximum price of the stock\\n        auto max_pair = *max_prices.rbegin();\\n        if(prices[max_pair.second] == max_pair.first) {\\n            // If the max price is from the latest timestamp, return it directly\\n            return max_pair.first;\\n        } \\n        else {\\n            // Otherwise, search for the latest price with the same value\\n            for(auto it = prices.rbegin(); it != prices.rend(); ++it) {\\n                if(it->second == max_pair.first) {\\n                    return max_pair.first;\\n                }\\n            }\\n        }\\n        return -1; // No max price found\\n    }\\n    \\n    int minimum() {\\n        // Return the minimum price of the stock\\n        auto min_pair = *min_prices.begin();\\n        if(prices[min_pair.second] == min_pair.first) {\\n            // If the min price is from the latest timestamp, return it directly\\n            return min_pair.first;\\n        } \\n        else {\\n            // Otherwise, search for the latest price with the same value\\n            for(auto it = prices.rbegin(); it != prices.rend(); ++it) {\\n                if(it->second == min_pair.first) {\\n                    return min_pair.first;\\n                }\\n            }\\n        }\\n        return -1; // No min price found\\n    }\\n};\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice* obj = new StockPrice();\\n * obj->update(timestamp,price);\\n * int param_2 = obj->current();\\n * int param_3 = obj->maximum();\\n * int param_4 = obj->minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478816,
                "title": "python3-sortedcontainers",
                "content": "\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass StockPrice:\\n\\n    def __init__(self):\\n        \\n        \\n        self.r=defaultdict(int)\\n        self.mt=0\\n        self.mx=SortedList()\\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        \\n        \\n        if timestamp in self.r:\\n            self.mx.remove(self.r[timestamp])\\n            self.mx.add(price)\\n        else:\\n            self.mx.add(price)\\n        \\n        self.r[timestamp]=price\\n        self.mt=max(self.mt,timestamp)\\n        \\n        \\n\\n    def current(self) -> int:\\n        return self.r[self.mt]\\n        \\n        \\n\\n    def maximum(self) -> int:\\n        return self.mx[-1]\\n        \\n\\n    def minimum(self) -> int:\\n        return self.mx[0]\\n        \\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass StockPrice:\\n\\n    def __init__(self):\\n        \\n        \\n        self.r=defaultdict(int)\\n        self.mt=0\\n        self.mx=SortedList()\\n        \\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        \\n        \\n        if timestamp in self.r:\\n            self.mx.remove(self.r[timestamp])\\n            self.mx.add(price)\\n        else:\\n            self.mx.add(price)\\n        \\n        self.r[timestamp]=price\\n        self.mt=max(self.mt,timestamp)\\n        \\n        \\n\\n    def current(self) -> int:\\n        return self.r[self.mt]\\n        \\n        \\n\\n    def maximum(self) -> int:\\n        return self.mx[-1]\\n        \\n\\n    def minimum(self) -> int:\\n        return self.mx[0]\\n        \\n\\n\\n# Your StockPrice object will be instantiated and called as such:\\n# obj = StockPrice()\\n# obj.update(timestamp,price)\\n# param_2 = obj.current()\\n# param_3 = obj.maximum()\\n# param_4 = obj.minimum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455553,
                "title": "straightforward-rust-solution-beats-100",
                "content": "The use of the two heaps can possibly be eliminated in favor of a sorted list but here\\'s a pretty simple, \"dumb\" implementation.\\n\\nThe simple algorithm stores the timestamp and prices in a hashmap and TWO heaps - one min heap and one max heap. Then for maximum you do something like:\\n\\n\\t\\t//get top of heap\\n\\t\\t//get that timestamp from hashmap\\n\\t\\t//if prices are the same,\\n\\t\\t//\\treturn price\\n\\t\\t//else\\n\\t\\t//\\tpop the top of heap\\n\\t\\t//\\tupdate its price with the hashmap price\\n\\t\\t//\\tpush it back into the heap\\n\\n\\t\\t//repeat this loop from the first step, until you find a timestamp whose price is in line with the hashmap price.\\n\\n\\t\\t// Do this for maximum and minimum.\\n\\t\\t\\n```rust\\nuse std::cmp::{Ordering, Reverse};\\nuse std::collections::{BinaryHeap, HashMap};\\n\\nstruct PriceRecord {\\n\\ttimestamp: i32,\\n\\tprice: i32,\\n}\\n\\nimpl Ord for PriceRecord {\\n\\tfn cmp(&self, other: &Self) -> Ordering {\\n\\t   self.price.cmp(&other.price)\\n\\t}\\n}\\n\\nimpl PartialOrd for PriceRecord {\\n\\tfn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n\\t   Some(self.cmp(other))\\n\\t}\\n}\\n\\nimpl PartialEq for PriceRecord {\\n\\tfn eq(&self, other: &Self) -> bool {\\n\\t   self.price == other.price\\n\\t}\\n}\\n\\nimpl Eq for PriceRecord {}\\n\\nstruct StockPrice {\\n\\tprice_history: HashMap<i32, i32>,\\n\\tlatest_timestamp : i32,\\n\\tlatest_price : i32,\\n\\tmax_price : BinaryHeap<PriceRecord>,\\n\\tmin_price : BinaryHeap<Reverse<PriceRecord>>, //in rust, you insert values wrapped in `core::cmp::Reverse` for a min heap (or declare a custom Ord, but we can\\'t do that here.)\\n}\\n\\nimpl StockPrice {\\n\\n\\tfn new() -> Self {\\n\\t\\tStockPrice {\\n\\t\\t\\tprice_history : HashMap::<i32, i32>::new(),\\n\\t\\t\\tlatest_timestamp : 0,\\n\\t\\t\\tlatest_price : 0,\\n\\t\\t\\tmax_price : BinaryHeap::<PriceRecord>::new(),\\n\\t\\t\\tmin_price : BinaryHeap::<Reverse<PriceRecord>>::new(),\\n\\t\\t}\\n\\t}\\n\\n\\tfn update(&mut self, timestamp: i32, price: i32) {\\n\\t   *self.price_history.entry(timestamp).or_insert(price) = price;\\n\\t   if timestamp >= self.latest_timestamp {\\n\\t\\t\\tself.latest_timestamp = timestamp;\\n\\t\\t\\tself.latest_price = price;\\n\\t   }\\n\\n\\t   // we can push a new value easily, but how do we edit an old value that is being corrected?\\n\\t   //\\n\\t   // one way is to pop all values until we find the timestamp that needs to be updated.\\n\\t   // another way is to only correct the values in the hashmap and use the heap simply to keep track of the timestamps\\n\\t   // So when returning min or max values, you somehow check if it needs to be corrected.\\n\\t   \\n\\t   // If the value in hashmap and heap are different for the \\'top\\' timestamp for a given heap,\\n\\t   // we probably want to update the node, reinsert, and re-pop. That should solve it.\\n\\n\\t   // Seems clunky, is there a better way?\\n\\n\\t   self.max_price.push(PriceRecord{timestamp, price});\\n\\t   self.min_price.push(Reverse(PriceRecord{timestamp, price}));\\n\\t}\\n\\n\\tfn current(&self) -> i32 {\\n\\t   self.latest_price\\n\\t}\\n\\n\\tfn maximum(&mut self) -> i32 {\\n\\t\\tloop {\\n\\t\\t\\tif let Some(current_max) = self.max_price.peek() {\\n\\t\\t\\t\\tif let Some(updated_price_at_timestamp) = self.price_history.get(&current_max.timestamp) {\\n\\t\\t\\t\\t\\tif current_max.price != *updated_price_at_timestamp {\\n\\t\\t\\t\\t\\t\\tif let Some(mut popped) = self.max_price.pop() {\\n\\t\\t\\t\\t\\t\\t\\tpopped.price = *updated_price_at_timestamp;\\n\\t\\t\\t\\t\\t\\t\\tself.max_price.push(popped);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn *updated_price_at_timestamp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfn minimum(&mut self) -> i32 {\\n\\t\\t//the same logic as maximum, but for minimum.\\n\\t\\tloop {\\n\\t\\t\\tif let Some(current_min) = self.min_price.peek() {\\n\\t\\t\\t\\tif let Some(updated_price_at_timestamp) = self.price_history.get(&current_min.0.timestamp) {\\n\\t\\t\\t\\t\\tif current_min.0.price != *updated_price_at_timestamp {\\n\\t\\t\\t\\t\\t\\tif let Some(mut popped) = self.min_price.pop() {\\n\\t\\t\\t\\t\\t\\t\\tpopped.0.price = *updated_price_at_timestamp;\\n\\t\\t\\t\\t\\t\\t\\tself.min_price.push(popped);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn *updated_price_at_timestamp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```rust\\nuse std::cmp::{Ordering, Reverse};\\nuse std::collections::{BinaryHeap, HashMap};\\n\\nstruct PriceRecord {\\n\\ttimestamp: i32,\\n\\tprice: i32,\\n}\\n\\nimpl Ord for PriceRecord {\\n\\tfn cmp(&self, other: &Self) -> Ordering {\\n\\t   self.price.cmp(&other.price)\\n\\t}\\n}\\n\\nimpl PartialOrd for PriceRecord {\\n\\tfn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n\\t   Some(self.cmp(other))\\n\\t}\\n}\\n\\nimpl PartialEq for PriceRecord {\\n\\tfn eq(&self, other: &Self) -> bool {\\n\\t   self.price == other.price\\n\\t}\\n}\\n\\nimpl Eq for PriceRecord {}\\n\\nstruct StockPrice {\\n\\tprice_history: HashMap<i32, i32>,\\n\\tlatest_timestamp : i32,\\n\\tlatest_price : i32,\\n\\tmax_price : BinaryHeap<PriceRecord>,\\n\\tmin_price : BinaryHeap<Reverse<PriceRecord>>, //in rust, you insert values wrapped in `core::cmp::Reverse` for a min heap (or declare a custom Ord, but we can\\'t do that here.)\\n}\\n\\nimpl StockPrice {\\n\\n\\tfn new() -> Self {\\n\\t\\tStockPrice {\\n\\t\\t\\tprice_history : HashMap::<i32, i32>::new(),\\n\\t\\t\\tlatest_timestamp : 0,\\n\\t\\t\\tlatest_price : 0,\\n\\t\\t\\tmax_price : BinaryHeap::<PriceRecord>::new(),\\n\\t\\t\\tmin_price : BinaryHeap::<Reverse<PriceRecord>>::new(),\\n\\t\\t}\\n\\t}\\n\\n\\tfn update(&mut self, timestamp: i32, price: i32) {\\n\\t   *self.price_history.entry(timestamp).or_insert(price) = price;\\n\\t   if timestamp >= self.latest_timestamp {\\n\\t\\t\\tself.latest_timestamp = timestamp;\\n\\t\\t\\tself.latest_price = price;\\n\\t   }\\n\\n\\t   // we can push a new value easily, but how do we edit an old value that is being corrected?\\n\\t   //\\n\\t   // one way is to pop all values until we find the timestamp that needs to be updated.\\n\\t   // another way is to only correct the values in the hashmap and use the heap simply to keep track of the timestamps\\n\\t   // So when returning min or max values, you somehow check if it needs to be corrected.\\n\\t   \\n\\t   // If the value in hashmap and heap are different for the \\'top\\' timestamp for a given heap,\\n\\t   // we probably want to update the node, reinsert, and re-pop. That should solve it.\\n\\n\\t   // Seems clunky, is there a better way?\\n\\n\\t   self.max_price.push(PriceRecord{timestamp, price});\\n\\t   self.min_price.push(Reverse(PriceRecord{timestamp, price}));\\n\\t}\\n\\n\\tfn current(&self) -> i32 {\\n\\t   self.latest_price\\n\\t}\\n\\n\\tfn maximum(&mut self) -> i32 {\\n\\t\\tloop {\\n\\t\\t\\tif let Some(current_max) = self.max_price.peek() {\\n\\t\\t\\t\\tif let Some(updated_price_at_timestamp) = self.price_history.get(&current_max.timestamp) {\\n\\t\\t\\t\\t\\tif current_max.price != *updated_price_at_timestamp {\\n\\t\\t\\t\\t\\t\\tif let Some(mut popped) = self.max_price.pop() {\\n\\t\\t\\t\\t\\t\\t\\tpopped.price = *updated_price_at_timestamp;\\n\\t\\t\\t\\t\\t\\t\\tself.max_price.push(popped);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn *updated_price_at_timestamp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfn minimum(&mut self) -> i32 {\\n\\t\\t//the same logic as maximum, but for minimum.\\n\\t\\tloop {\\n\\t\\t\\tif let Some(current_min) = self.min_price.peek() {\\n\\t\\t\\t\\tif let Some(updated_price_at_timestamp) = self.price_history.get(&current_min.0.timestamp) {\\n\\t\\t\\t\\t\\tif current_min.0.price != *updated_price_at_timestamp {\\n\\t\\t\\t\\t\\t\\tif let Some(mut popped) = self.min_price.pop() {\\n\\t\\t\\t\\t\\t\\t\\tpopped.0.price = *updated_price_at_timestamp;\\n\\t\\t\\t\\t\\t\\t\\tself.min_price.push(popped);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn *updated_price_at_timestamp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432372,
                "title": "c-priorityqueue-and-dictionary-solution",
                "content": "# Intuition\\nWe need to remember all history prices. If the min is changed, the second min can be the new min price.\\nUse a hashmap/dictionary to store the time -> price keyvalue pairs.\\nUse a priorityqueue to store the min prices, and the max prices.\\nNote we use a lambada expression to create a max heap where max priority is dequeue first.\\n`maxPrice = new PriorityQueue<int, int>(Comparer<int>.Create((x, y) => y - x));`\\n\\n# Code\\n```\\npublic class StockPrice {\\n    private int latestTime;\\n    private PriorityQueue<int, int> minPrice;\\n    private PriorityQueue<int, int> maxPrice;\\n    private Dictionary<int, int> timedPrice;\\n    public StockPrice() {\\n        minPrice = new PriorityQueue<int, int>(); // min heap\\n        maxPrice = new PriorityQueue<int, int>(Comparer<int>.Create((x, y) => y - x)); // reverse order, max heap\\n        timedPrice = new Dictionary<int, int>();\\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        latestTime = Math.Max(latestTime, timestamp);\\n        timedPrice[timestamp] = price;\\n        // update the history min and max price.\\n        minPrice.Enqueue(timestamp, price);\\n        maxPrice.Enqueue(timestamp, price);\\n    }\\n    \\n    public int Current() {\\n        return timedPrice[latestTime];\\n    }\\n    \\n    public int Maximum() {\\n        maxPrice.TryDequeue(out var timestamp, out var price);\\n        while(timedPrice[timestamp] != price) {\\n            maxPrice.TryDequeue(out timestamp, out price);\\n        }\\n        maxPrice.Enqueue(timestamp, price);\\n        return price;\\n    }\\n    \\n    public int Minimum() {\\n        minPrice.TryDequeue(out var timestamp, out var price);\\n        while(timedPrice[timestamp] != price) {\\n            minPrice.TryDequeue(out timestamp, out price);\\n        }\\n        minPrice.Enqueue(timestamp, price);\\n        return price;\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.Update(timestamp,price);\\n * int param_2 = obj.Current();\\n * int param_3 = obj.Maximum();\\n * int param_4 = obj.Minimum();\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class StockPrice {\\n    private int latestTime;\\n    private PriorityQueue<int, int> minPrice;\\n    private PriorityQueue<int, int> maxPrice;\\n    private Dictionary<int, int> timedPrice;\\n    public StockPrice() {\\n        minPrice = new PriorityQueue<int, int>(); // min heap\\n        maxPrice = new PriorityQueue<int, int>(Comparer<int>.Create((x, y) => y - x)); // reverse order, max heap\\n        timedPrice = new Dictionary<int, int>();\\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        latestTime = Math.Max(latestTime, timestamp);\\n        timedPrice[timestamp] = price;\\n        // update the history min and max price.\\n        minPrice.Enqueue(timestamp, price);\\n        maxPrice.Enqueue(timestamp, price);\\n    }\\n    \\n    public int Current() {\\n        return timedPrice[latestTime];\\n    }\\n    \\n    public int Maximum() {\\n        maxPrice.TryDequeue(out var timestamp, out var price);\\n        while(timedPrice[timestamp] != price) {\\n            maxPrice.TryDequeue(out timestamp, out price);\\n        }\\n        maxPrice.Enqueue(timestamp, price);\\n        return price;\\n    }\\n    \\n    public int Minimum() {\\n        minPrice.TryDequeue(out var timestamp, out var price);\\n        while(timedPrice[timestamp] != price) {\\n            minPrice.TryDequeue(out timestamp, out price);\\n        }\\n        minPrice.Enqueue(timestamp, price);\\n        return price;\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.Update(timestamp,price);\\n * int param_2 = obj.Current();\\n * int param_3 = obj.Maximum();\\n * int param_4 = obj.Minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428970,
                "title": "my-solution",
                "content": "```\\nclass StockPrice {\\n public:\\n  StockPrice() : latest_timestamp_(0) {\\n  }\\n\\n  /**\\n   * Time Complexity: O(log(n_prices))\\n   * Space Complexity: O(1)\\n   * where `n_prices` is the length of the multiset `prices_`\\n   */\\n  void update(const int timestamp, const int price) {\\n    latest_timestamp_ = max(latest_timestamp_, timestamp);\\n    \\n    auto itr = timestamp_to_price_itr_.find(timestamp);\\n    if (itr == timestamp_to_price_itr_.end()) {\\n      timestamp_to_price_itr_[timestamp] = prices_.emplace(price);\\n    } else {\\n      if (*itr->second != price) {\\n        prices_.erase(itr->second);\\n        itr->second = prices_.emplace(price);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Time Complexity: O(1)\\n   * Space Complexity: O(1)\\n   */\\n  int current() {\\n    return *timestamp_to_price_itr_[latest_timestamp_];\\n  }\\n\\n  /**\\n   * Time Complexity: O(1)\\n   * Space Complexity: O(1)\\n   */\\n  int maximum() {\\n    return *prices_.rbegin();\\n  }\\n\\n  /**\\n   * Time Complexity: O(1)\\n   * Space Complexity: O(1)\\n   */\\n  int minimum() {\\n    return *prices_.begin();\\n  }\\n  \\n private:\\n  int latest_timestamp_;\\n  multiset<int> prices_;\\n  unordered_map<int, multiset<int>::iterator> timestamp_to_price_itr_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StockPrice {\\n public:\\n  StockPrice() : latest_timestamp_(0) {\\n  }\\n\\n  /**\\n   * Time Complexity: O(log(n_prices))\\n   * Space Complexity: O(1)\\n   * where `n_prices` is the length of the multiset `prices_`\\n   */\\n  void update(const int timestamp, const int price) {\\n    latest_timestamp_ = max(latest_timestamp_, timestamp);\\n    \\n    auto itr = timestamp_to_price_itr_.find(timestamp);\\n    if (itr == timestamp_to_price_itr_.end()) {\\n      timestamp_to_price_itr_[timestamp] = prices_.emplace(price);\\n    } else {\\n      if (*itr->second != price) {\\n        prices_.erase(itr->second);\\n        itr->second = prices_.emplace(price);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Time Complexity: O(1)\\n   * Space Complexity: O(1)\\n   */\\n  int current() {\\n    return *timestamp_to_price_itr_[latest_timestamp_];\\n  }\\n\\n  /**\\n   * Time Complexity: O(1)\\n   * Space Complexity: O(1)\\n   */\\n  int maximum() {\\n    return *prices_.rbegin();\\n  }\\n\\n  /**\\n   * Time Complexity: O(1)\\n   * Space Complexity: O(1)\\n   */\\n  int minimum() {\\n    return *prices_.begin();\\n  }\\n  \\n private:\\n  int latest_timestamp_;\\n  multiset<int> prices_;\\n  unordered_map<int, multiset<int>::iterator> timestamp_to_price_itr_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389808,
                "title": "hashing-easy-c-solution",
                "content": "# Code\\n```\\nclass StockPrice \\n{\\npublic:\\n    map<int,int> timePrice;\\n    map<int,int> m;\\n    StockPrice() {}\\n    \\n    void update(int timestamp, int price) \\n    {\\n        if(timePrice.find(timestamp)!=timePrice.end())\\n        {\\n            m[timePrice[timestamp]]--;\\n            if(m[timePrice[timestamp]]==0) m.erase(timePrice[timestamp]);\\n        }\\n        timePrice[timestamp]=price;\\n        m[price]++;\\n    }\\n    \\n    int current() \\n    {\\n        auto it=--timePrice.end();\\n        return it->second;\\n    }\\n    \\n    int maximum() \\n    {\\n        auto it=--m.end();\\n        return it->first;\\n    }\\n    \\n    int minimum() \\n    {\\n        auto it=m.begin();\\n        return it->first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass StockPrice \\n{\\npublic:\\n    map<int,int> timePrice;\\n    map<int,int> m;\\n    StockPrice() {}\\n    \\n    void update(int timestamp, int price) \\n    {\\n        if(timePrice.find(timestamp)!=timePrice.end())\\n        {\\n            m[timePrice[timestamp]]--;\\n            if(m[timePrice[timestamp]]==0) m.erase(timePrice[timestamp]);\\n        }\\n        timePrice[timestamp]=price;\\n        m[price]++;\\n    }\\n    \\n    int current() \\n    {\\n        auto it=--timePrice.end();\\n        return it->second;\\n    }\\n    \\n    int maximum() \\n    {\\n        auto it=--m.end();\\n        return it->first;\\n    }\\n    \\n    int minimum() \\n    {\\n        auto it=m.begin();\\n        return it->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373790,
                "title": "c-sortedset",
                "content": "```\\npublic class StockPrice {\\n    Comparer<(int k,int c)> cmp=Comparer<(int k,int c)>.Create((x,y)=>x.k.CompareTo(y.k));\\n    SortedSet<(int k,int c)> ss;\\n    Dictionary<int,int> map=new Dictionary<int,int>();\\n    int current=0;\\n    public StockPrice() {\\n        ss =new SortedSet<(int k,int c)>(cmp);\\n\\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        current=Math.Max(current,timestamp);\\n        (int k,int c) v;\\n        if(!map.ContainsKey(timestamp))\\n        {\\n            map.Add(timestamp,price);\\n            if(ss.TryGetValue((price,1),out v))\\n            {\\n                ss.Remove(v);\\n                ss.Add((price,v.c+1));\\n            }\\n            else\\n                ss.Add((price,1));\\n        }\\n        else\\n        {\\n            int oldprice=map[timestamp];\\n            map[timestamp]=price;\\n            //decrement old price\\n            if(ss.TryGetValue((oldprice,1),out v))\\n            {\\n                ss.Remove(v);\\n                if(v.c>1)\\n                    ss.Add((oldprice,v.c-1));\\n            }\\n                \\n\\n            // increment new price\\n            if(ss.TryGetValue((price,1),out v))\\n            {\\n                ss.Remove(v);\\n                \\n                ss.Add((price,v.c+1));\\n            }\\n            else\\n                ss.Add((price,1));\\n\\n\\n            \\n        }\\n    }\\n    \\n    public int Current() {\\n        return map[current];\\n    }\\n    \\n    public int Maximum() {\\n        return ss.Max.k;\\n    }\\n    \\n    public int Minimum() {\\n        return ss.Min.k;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class StockPrice {\\n    Comparer<(int k,int c)> cmp=Comparer<(int k,int c)>.Create((x,y)=>x.k.CompareTo(y.k));\\n    SortedSet<(int k,int c)> ss;\\n    Dictionary<int,int> map=new Dictionary<int,int>();\\n    int current=0;\\n    public StockPrice() {\\n        ss =new SortedSet<(int k,int c)>(cmp);\\n\\n    }\\n    \\n    public void Update(int timestamp, int price) {\\n        current=Math.Max(current,timestamp);\\n        (int k,int c) v;\\n        if(!map.ContainsKey(timestamp))\\n        {\\n            map.Add(timestamp,price);\\n            if(ss.TryGetValue((price,1),out v))\\n            {\\n                ss.Remove(v);\\n                ss.Add((price,v.c+1));\\n            }\\n            else\\n                ss.Add((price,1));\\n        }\\n        else\\n        {\\n            int oldprice=map[timestamp];\\n            map[timestamp]=price;\\n            //decrement old price\\n            if(ss.TryGetValue((oldprice,1),out v))\\n            {\\n                ss.Remove(v);\\n                if(v.c>1)\\n                    ss.Add((oldprice,v.c-1));\\n            }\\n                \\n\\n            // increment new price\\n            if(ss.TryGetValue((price,1),out v))\\n            {\\n                ss.Remove(v);\\n                \\n                ss.Add((price,v.c+1));\\n            }\\n            else\\n                ss.Add((price,1));\\n\\n\\n            \\n        }\\n    }\\n    \\n    public int Current() {\\n        return map[current];\\n    }\\n    \\n    public int Maximum() {\\n        return ss.Max.k;\\n    }\\n    \\n    public int Minimum() {\\n        return ss.Min.k;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359893,
                "title": "using-2-maps-treemap-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- use map to keep-- timestamp -> price\\n- use treemap to keep-- price -> {timestamps}\\n-  when updating a timestamp, update treemap value set.\\n- return first and last entry from treemap for min and max values\\n\\n\\n# Code\\n```\\nclass StockPrice {\\n\\n    Map<Integer, Integer> map;\\n    TreeMap<Integer, Set<Integer>> sort;\\n    int currtimestamp;\\n    int currval;\\n\\n    public StockPrice() {\\n        map= new HashMap<>();\\n        sort= new TreeMap<>();\\n        currtimestamp=0;\\n        currval=0;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= currtimestamp){\\n            currval=price;\\n            currtimestamp=timestamp;\\n        }\\n        if(map.containsKey(timestamp)){\\n            int prev= map.get(timestamp);\\n            map.put(timestamp, price);\\n\\n            sort.get(prev).remove(timestamp);\\n            if(sort.get(prev).size()==0)\\n                sort.remove(prev);\\n        }\\n        else{\\n            map.put(timestamp, price);\\n        }\\n        //add new price  to sort\\n        if(sort.containsKey(price)){\\n            sort.get(price).add(timestamp);\\n        }else{\\n            Set<Integer> set= new HashSet<>();\\n            set.add(timestamp);\\n            sort.put(price, set);\\n        }\\n    }\\n    \\n    public int current() {\\n\\n        return currval;\\n    }\\n    \\n    public int maximum() {\\n        return sort.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return sort.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StockPrice {\\n\\n    Map<Integer, Integer> map;\\n    TreeMap<Integer, Set<Integer>> sort;\\n    int currtimestamp;\\n    int currval;\\n\\n    public StockPrice() {\\n        map= new HashMap<>();\\n        sort= new TreeMap<>();\\n        currtimestamp=0;\\n        currval=0;\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(timestamp >= currtimestamp){\\n            currval=price;\\n            currtimestamp=timestamp;\\n        }\\n        if(map.containsKey(timestamp)){\\n            int prev= map.get(timestamp);\\n            map.put(timestamp, price);\\n\\n            sort.get(prev).remove(timestamp);\\n            if(sort.get(prev).size()==0)\\n                sort.remove(prev);\\n        }\\n        else{\\n            map.put(timestamp, price);\\n        }\\n        //add new price  to sort\\n        if(sort.containsKey(price)){\\n            sort.get(price).add(timestamp);\\n        }else{\\n            Set<Integer> set= new HashSet<>();\\n            set.add(timestamp);\\n            sort.put(price, set);\\n        }\\n    }\\n    \\n    public int current() {\\n\\n        return currval;\\n    }\\n    \\n    public int maximum() {\\n        return sort.lastKey();\\n    }\\n    \\n    public int minimum() {\\n        return sort.firstKey();\\n    }\\n}\\n\\n/**\\n * Your StockPrice object will be instantiated and called as such:\\n * StockPrice obj = new StockPrice();\\n * obj.update(timestamp,price);\\n * int param_2 = obj.current();\\n * int param_3 = obj.maximum();\\n * int param_4 = obj.minimum();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328957,
                "title": "easiest-solution-ever-i-can-bet-on-this",
                "content": "# Intuition\\nNow based on the question we need to do following task:\\n- Maintain the price of timestamps\\n- Maintain price of latest timestamp\\n- Maximum price of timestamp\\n- Minimum price of timestamp\\n\\n# Approach\\n- Maintain the price of timestamps\\n\\nNow to maintain the price of timestamps we\\'ll use unordered_map.\\n**Why unordered_map?** \\uD83E\\uDDD0\\uD83E\\uDDD0\\nCoz we don\\'t need to maintain the order of timestamp. Its not required in the question.\\nUnordered_map reduces our complexity from logn to constant.\\n\\n\\n- Maintain price of latest timestamp\\n\\nFor this we just need two pointers timestamp and corresponding price. If the new timestamp is greater than or equal to current timestamp. We\\'ll change these pointer.\\n\\n- Maximum Price of timestamp\\n\\nFor this we\\'ll use maxHeap. In update function we\\'ll push pair of {price,timestamp} in maxHeap.\\n\\n- Minimum Price of timestamp\\n\\nFor this we\\'ll use minHeap. In update function we\\'ll push pair of {price,timestamp} in minHeap.\\n\\n**Now there\\'s a problem?**\\nWhen pushing new element in maxHeap/minHeap we are not removing previous pair. So in future we might encounter that value which is now not a valid value.\\n\\nThere are two methods:\\n\\n1. Check for the invalid pair by checking all elements before pushing. (\\u274C not an ideal approach. I mean why to remove those elements that we don\\'t need in future.)\\n2. When calling maximum or minimum function pop pair from heaps and check whether that pair is valid. You can check that from our unordered_map. And let me remind you complexity to check is constant. (\\u2705 This approach is very time efficient we are removing only those values that we are encountering)\\n\\n\\n# Complexity\\n- Time complexity:\\n\\nFor update(): O(logn)\\nFor current(): O(1)\\nFor maximum(): O(k*log(n)) where k is the invalid pairs encountered\\nFor minimum(): O(k*log(n)) where k is the invalid pairs encountered\\n\\n- Space complexity:\\nMap: O(n)\\nMax Heap: O(n)\\nMin Heap: O(n)\\nPair: O(1)\\n\\nIf you like the solution, do give an upvote \\uD83D\\uDC4D\\n\\n# Code\\n```\\n#define pp pair<int,int>\\n\\nclass StockPrice {\\npublic:\\n    unordered_map<int,int> mp;\\n    priority_queue<pp> maxH;\\n    priority_queue<pp,vector<pp>, greater<pp>> minH;\\n    pp latest;\\n    StockPrice() {  \\n        latest = {0,0};     // time stamp and price\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        mp[timestamp] = price;\\n        maxH.push({price,timestamp});   // push price and time stamp in max heap\\n        minH.push({price,timestamp});   // push price and time stamp in min heap\\n        if(timestamp>=latest.first)\\n        {\\n            latest = {timestamp,price};\\n        }\\n    }\\n    \\n    int current() {\\n        return latest.second;\\n    }\\n    \\n    int maximum() {\\n        while(!maxH.empty())\\n        {\\n            auto top = maxH.top();\\n\\n            if(mp[top.second]==top.first)\\n            {\\n                return top.first;\\n            }\\n            else\\n                maxH.pop();     // this timestamp has been updated and hence is invalid\\n        }\\n        return -1;  // never reaching case\\n    }\\n    \\n    int minimum() {\\n        while(!minH.empty())\\n        {\\n            auto top = minH.top();\\n\\n            if(mp[top.second]==top.first)\\n            {\\n                return top.first;\\n            }\\n            else\\n                minH.pop();     // this timestamp has been updated and hence is invalid\\n        }\\n\\n        return -1; // never reaching case\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "Heap (Priority Queue)",
                    "Data Stream"
                ],
                "code": "# Intuition\\nNow based on the question we need to do following task:\\n- Maintain the price of timestamps\\n- Maintain price of latest timestamp\\n- Maximum price of timestamp\\n- Minimum price of timestamp\\n\\n# Approach\\n- Maintain the price of timestamps\\n\\nNow to maintain the price of timestamps we\\'ll use unordered_map.\\n**Why unordered_map?** \\uD83E\\uDDD0\\uD83E\\uDDD0\\nCoz we don\\'t need to maintain the order of timestamp. Its not required in the question.\\nUnordered_map reduces our complexity from logn to constant.\\n\\n\\n- Maintain price of latest timestamp\\n\\nFor this we just need two pointers timestamp and corresponding price. If the new timestamp is greater than or equal to current timestamp. We\\'ll change these pointer.\\n\\n- Maximum Price of timestamp\\n\\nFor this we\\'ll use maxHeap. In update function we\\'ll push pair of {price,timestamp} in maxHeap.\\n\\n- Minimum Price of timestamp\\n\\nFor this we\\'ll use minHeap. In update function we\\'ll push pair of {price,timestamp} in minHeap.\\n\\n**Now there\\'s a problem?**\\nWhen pushing new element in maxHeap/minHeap we are not removing previous pair. So in future we might encounter that value which is now not a valid value.\\n\\nThere are two methods:\\n\\n1. Check for the invalid pair by checking all elements before pushing. (\\u274C not an ideal approach. I mean why to remove those elements that we don\\'t need in future.)\\n2. When calling maximum or minimum function pop pair from heaps and check whether that pair is valid. You can check that from our unordered_map. And let me remind you complexity to check is constant. (\\u2705 This approach is very time efficient we are removing only those values that we are encountering)\\n\\n\\n# Complexity\\n- Time complexity:\\n\\nFor update(): O(logn)\\nFor current(): O(1)\\nFor maximum(): O(k*log(n)) where k is the invalid pairs encountered\\nFor minimum(): O(k*log(n)) where k is the invalid pairs encountered\\n\\n- Space complexity:\\nMap: O(n)\\nMax Heap: O(n)\\nMin Heap: O(n)\\nPair: O(1)\\n\\nIf you like the solution, do give an upvote \\uD83D\\uDC4D\\n\\n# Code\\n```\\n#define pp pair<int,int>\\n\\nclass StockPrice {\\npublic:\\n    unordered_map<int,int> mp;\\n    priority_queue<pp> maxH;\\n    priority_queue<pp,vector<pp>, greater<pp>> minH;\\n    pp latest;\\n    StockPrice() {  \\n        latest = {0,0};     // time stamp and price\\n    }\\n    \\n    void update(int timestamp, int price) {\\n        mp[timestamp] = price;\\n        maxH.push({price,timestamp});   // push price and time stamp in max heap\\n        minH.push({price,timestamp});   // push price and time stamp in min heap\\n        if(timestamp>=latest.first)\\n        {\\n            latest = {timestamp,price};\\n        }\\n    }\\n    \\n    int current() {\\n        return latest.second;\\n    }\\n    \\n    int maximum() {\\n        while(!maxH.empty())\\n        {\\n            auto top = maxH.top();\\n\\n            if(mp[top.second]==top.first)\\n            {\\n                return top.first;\\n            }\\n            else\\n                maxH.pop();     // this timestamp has been updated and hence is invalid\\n        }\\n        return -1;  // never reaching case\\n    }\\n    \\n    int minimum() {\\n        while(!minH.empty())\\n        {\\n            auto top = minH.top();\\n\\n            if(mp[top.second]==top.first)\\n            {\\n                return top.first;\\n            }\\n            else\\n                minH.pop();     // this timestamp has been updated and hence is invalid\\n        }\\n\\n        return -1; // never reaching case\\n    }\\n};\\n",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570746,
                "content": [
                    {
                        "username": "Movely",
                        "content": "How would you tackle this question in a system design interview? Comment below. What comes to my mind is:\\n\\n- Consider how this is used. Probably a REST API over HTTP would be a good choice.\\n- How much traffic do we expect? It\\'s probably not used for just a single stock, but more to the tune of like a 1000 stocks. If this is some kind of high frequency trading, then would it be reasonable to approximate this as one tick per stock per milisecond, for 8 hours each working day? If so, then the number of records in one day we could  expect would be 1000 stocks * 1 tick/stock/ms * 8 hours * 1 record/tick =~ 1000 * 8 * 4000,000ms * 1 records/ms =~ 30 billion records in one day.\\n- While it\\'s not part of the requirements, it makes sense to expect that the users would not require to update records older than a specified amount. For example, perhaps it is not necessary to be able to update records older than 1 day? \\n- If so, this makes it easier to manage the storage - because we only need to keep one day\\'s worth of records, and for all earlier data we just have to keep the minimum, maximum and youngest values.\\n- We could store the data in a NoSQL database, partitioned by stock+date of the timestamp and for each stock, use a sorted set of price+timestamp pairs and a table of prices indexes by timestamp. For example to update the data, we insert the new timestamp+price pair in the sorted set (without removing the possible previous value) and insert or update the record in the table. To get the minimum, check the timestamp+price in the sorted set with the minimum price; verify if the same price is stored in the table for the specified timestamp. If it\\'s not, then it means that an update has occurred, in which case remove that record from the sorted set and try again. If the minimum for data older than 1 day is lower, return that instead. Note that if there were a lot of updates for already stored timestamps, then it\\'s possible to generate even more storage load than approximated above.\\n- Possibly worth discussing the availability and consistency requirements for the NoSQL solution.\\n\\nWhat do you think?"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "IMO Rest API over HTTP is not a good idea, this is going to be a crazy load and if the service is down even for a minute, whole data in the consumer side would be messed up. Instead if we use distributed queue like Kafka, we will get 100 percent availability. Now even if the application is down or something it can always come back and start consuming. \\nTo get parallelism here we can have multiple partitions in the queue. To make sure we always consume the updates after insertion, we can use timestamp and stock name as the key (simple hashing concept is used, if partition count can increase or decrease at runtime consistent hashing could be used but that is not the case with Kafka, I believe).  "
                    },
                    {
                        "username": "AndrewEmoryTate",
                        "content": "Any idea why it doesn\\'t work `your \\nclass StockPrice {\\npublic:\\n    map<int, int> mp;\\n    set<int> prices;\\n    int currPrice;\\n\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if (mp.find(timestamp) == mp.end()) {\\n            mp[timestamp] = price;\\n            prices.insert(price);\\n        } else {\\n            int x = mp[timestamp];\\n            set<int>::reverse_iterator it = prices.rbegin();\\n            std::set<int>::iterator it2 = prices.begin();\\n            int firstElem = *it2;\\n            int lastElem = *it;\\n            if (x == lastElem) {\\n                prices.erase(std::next(it).base());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else if (x == firstElem) {\\n                prices.erase(prices.begin());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else {\\n                mp[timestamp] = price;\\n                prices.insert(price);\\n            }\\n        }\\n    }\\n    \\n    int current() {\\n        map<int, int>::reverse_iterator it = mp.rbegin();\\n        return it->second;\\n    }\\n    \\n    int maximum() {\\n        return *prices.rbegin();\\n    }\\n\\n    int minimum() {\\n        return *prices.begin();\\n    }\\n\\n};"
                    },
                    {
                        "username": "rajshah008",
                        "content": "Why I m getting TLE can anyone explain?\\nclass StockPrice {\\n    Map<Integer,Integer> mp ;\\n    PriorityQueue<Integer> max,min;\\n    int current=0;\\n    public StockPrice() {\\n        mp = new HashMap<>();\\n        min = new PriorityQueue<>();\\n        max = new PriorityQueue<>(Collections.reverseOrder());\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(mp.containsKey(timestamp)){\\n            max.remove(mp.get(timestamp));\\n            min.remove(mp.get(timestamp));    \\n        }\\n        max.add(price);\\n        min.add(price);\\n        if(timestamp>current)\\n             current=timestamp;\\n        mp.put(timestamp , price);\\n    }\\n    \\n    public int current() {\\n        return mp.get(current);\\n    }\\n    \\n    public int maximum() {\\n        return max.peek();\\n    }\\n    \\n    public int minimum() {\\n        return min.peek();\\n    }\\n}\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Try to use Map. For storing current element in multiset(so that it can store duplicate too if any)..\nRemove old value from set and insert new value.(For Update)\nuse rbegin and begin for maximum and minimum."
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "I am getting timeout when using 2 heaps (min/max heap) but I see other solutions which are working using the same - any optimisation you all think I can do. \nhttps://leetcode.com/problems/stock-price-fluctuation/solutions/1513293/python-clean-2-heaps-commented-code/ and https://leetcode.com/problems/stock-price-fluctuation/solutions/1513302/simple-solution-using-max-heap-and-min-heap/\n\n\n ```\n\nclass StockPrice {\n\n    Map<Integer, Container> map = new HashMap<>();\n    PriorityQueue<Container> max = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container2.price, container1.price);\n        }\n    });\n\n    PriorityQueue<Container> min = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container1.price, container2.price);\n        }\n    });\n    int current = -1;\n    int latestTimeStamp = -1;\n    public StockPrice() {\n        \n    }\n    \n    public void update(int timestamp, int price) {\n        if(timestamp>=latestTimeStamp) {\n            latestTimeStamp = timestamp;\n            current = price;\n        }\n        if(map.containsKey(timestamp)) {\n            Container container = map.get(timestamp);\n            container.price = price;\n            max.remove(container);\n            min.remove(container);\n            max.add(container);\n            min.add(container);\n        } else {\n            Container container = new Container(price, timestamp);\n            map.put(timestamp, container);\n            max.add(container);\n            min.add(container);\n        }\n    }\n    \n    public int current() {\n        return current;\n    }\n    \n    public int maximum() {\n        return max.peek().price;\n    }\n    \n    public int minimum() {\n        return min.peek().price;\n    }\n\n    public static class Container {\n        int price;\n        int timestamp;\n\n        public Container(int price, int timestamp) {\n            this.price = price;\n            this.timestamp = timestamp;\n        }\n    }\n}.\n\n```"
                    },
                    {
                        "username": "Irving09",
                        "content": "[@harshit_bangar](/harshit_bangar)\\n\\nYou cant just max.peek().price or min.peek().price, I had the same code and it turns out heapify doesnt get triggered for adding and removing.\\n\\n```\\nclass StockPrice {\\n\\n  class Record {\\n    int timestamp;\\n    int price;\\n    public Record(int timestamp, int price) {\\n      this.timestamp = timestamp;\\n      this.price = price;\\n    }\\n  }\\n\\n  private Map<Integer, Record> records;\\n  private Queue<Record> max;\\n  private Queue<Record> min;\\n  private int latestTimestamp;\\n\\n  public StockPrice() {\\n    records = new HashMap<>();\\n    max = new PriorityQueue<>((r1, r2) -> r2.price - r1.price);\\n    min = new PriorityQueue<>((r1, r2) -> r1.price - r2.price);\\n    latestTimestamp = 1;\\n  }\\n  \\n  public void update(int timestamp, int price) { // O(logn)\\n    if (records.containsKey(timestamp)) {\\n      records.get(timestamp).price = price;\\n    } else {\\n      Record record = new Record(timestamp, price);\\n      records.put(timestamp, record);\\n      max.offer(record);\\n      min.offer(record);\\n    }\\n\\n    max.offer(max.poll()); // didnt actually re-trigger heapify\\n    min.offer(min.poll()); // didnt actually re-trigger heapify\\n    latestTimestamp = Math.max(latestTimestamp, timestamp);\\n  }\\n  \\n  public int current() { // O(1)\\n    return records.get(latestTimestamp).price;\\n  }\\n  \\n  public int maximum() { // logn\\n    return max.peek().price;\\n  }\\n  \\n  public int minimum() { // logn\\n    return min.peek().price;\\n  }\\n}\\n\\n/**\\n* Your StockPrice object will be instantiated and called as such:\\n* StockPrice obj = new StockPrice();\\n* obj.update(timestamp,price);\\n* int param_2 = obj.current();\\n* int param_3 = obj.maximum();\\n* int param_4 = obj.minimum();\\n*/\\n```"
                    },
                    {
                        "username": "user1325DR",
                        "content": "what is wrong with this implementation : - \n--------------\nimport java.util.NavigableMap;\nclass StockPrice {\n    SortedSet timestamps;\n    Map<Integer, Integer> priceMap;\n    \n    int currPrice = -1;\n    int currTimestamp = -1;\n    \n    public StockPrice() {\n        timestamps = new TreeSet<>((a, b) -> priceMap.get(a) - priceMap.get(b));\n        priceMap = new HashMap<>();\n    }\n    \n    public void update(int timestamp, int price) {\n        if(priceMap.containsKey(timestamp))\n        {\n            timestamps.remove(timestamp);\n        }\n        priceMap.put(timestamp, price);\n        timestamps.add(timestamp);\n        if(timestamp >= currTimestamp)\n        {\n            currTimestamp = timestamp;\n            currPrice = price;\n        }\n    }\n    \n    public int current() {\n        return currPrice;\n    }\n    \n    public int maximum() {\n        return priceMap.get(timestamps.last());\n    }\n    \n    public int minimum() {\n        return priceMap.get(timestamps.first());\n    }\n}\n\n--------------"
                    },
                    {
                        "username": "vetty",
                        "content": "Same q"
                    },
                    {
                        "username": "vinayakprasad96",
                        "content": "#ff"
                    }
                ]
            },
            {
                "id": 2051881,
                "content": [
                    {
                        "username": "Movely",
                        "content": "How would you tackle this question in a system design interview? Comment below. What comes to my mind is:\\n\\n- Consider how this is used. Probably a REST API over HTTP would be a good choice.\\n- How much traffic do we expect? It\\'s probably not used for just a single stock, but more to the tune of like a 1000 stocks. If this is some kind of high frequency trading, then would it be reasonable to approximate this as one tick per stock per milisecond, for 8 hours each working day? If so, then the number of records in one day we could  expect would be 1000 stocks * 1 tick/stock/ms * 8 hours * 1 record/tick =~ 1000 * 8 * 4000,000ms * 1 records/ms =~ 30 billion records in one day.\\n- While it\\'s not part of the requirements, it makes sense to expect that the users would not require to update records older than a specified amount. For example, perhaps it is not necessary to be able to update records older than 1 day? \\n- If so, this makes it easier to manage the storage - because we only need to keep one day\\'s worth of records, and for all earlier data we just have to keep the minimum, maximum and youngest values.\\n- We could store the data in a NoSQL database, partitioned by stock+date of the timestamp and for each stock, use a sorted set of price+timestamp pairs and a table of prices indexes by timestamp. For example to update the data, we insert the new timestamp+price pair in the sorted set (without removing the possible previous value) and insert or update the record in the table. To get the minimum, check the timestamp+price in the sorted set with the minimum price; verify if the same price is stored in the table for the specified timestamp. If it\\'s not, then it means that an update has occurred, in which case remove that record from the sorted set and try again. If the minimum for data older than 1 day is lower, return that instead. Note that if there were a lot of updates for already stored timestamps, then it\\'s possible to generate even more storage load than approximated above.\\n- Possibly worth discussing the availability and consistency requirements for the NoSQL solution.\\n\\nWhat do you think?"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "IMO Rest API over HTTP is not a good idea, this is going to be a crazy load and if the service is down even for a minute, whole data in the consumer side would be messed up. Instead if we use distributed queue like Kafka, we will get 100 percent availability. Now even if the application is down or something it can always come back and start consuming. \\nTo get parallelism here we can have multiple partitions in the queue. To make sure we always consume the updates after insertion, we can use timestamp and stock name as the key (simple hashing concept is used, if partition count can increase or decrease at runtime consistent hashing could be used but that is not the case with Kafka, I believe).  "
                    },
                    {
                        "username": "AndrewEmoryTate",
                        "content": "Any idea why it doesn\\'t work `your \\nclass StockPrice {\\npublic:\\n    map<int, int> mp;\\n    set<int> prices;\\n    int currPrice;\\n\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if (mp.find(timestamp) == mp.end()) {\\n            mp[timestamp] = price;\\n            prices.insert(price);\\n        } else {\\n            int x = mp[timestamp];\\n            set<int>::reverse_iterator it = prices.rbegin();\\n            std::set<int>::iterator it2 = prices.begin();\\n            int firstElem = *it2;\\n            int lastElem = *it;\\n            if (x == lastElem) {\\n                prices.erase(std::next(it).base());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else if (x == firstElem) {\\n                prices.erase(prices.begin());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else {\\n                mp[timestamp] = price;\\n                prices.insert(price);\\n            }\\n        }\\n    }\\n    \\n    int current() {\\n        map<int, int>::reverse_iterator it = mp.rbegin();\\n        return it->second;\\n    }\\n    \\n    int maximum() {\\n        return *prices.rbegin();\\n    }\\n\\n    int minimum() {\\n        return *prices.begin();\\n    }\\n\\n};"
                    },
                    {
                        "username": "rajshah008",
                        "content": "Why I m getting TLE can anyone explain?\\nclass StockPrice {\\n    Map<Integer,Integer> mp ;\\n    PriorityQueue<Integer> max,min;\\n    int current=0;\\n    public StockPrice() {\\n        mp = new HashMap<>();\\n        min = new PriorityQueue<>();\\n        max = new PriorityQueue<>(Collections.reverseOrder());\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(mp.containsKey(timestamp)){\\n            max.remove(mp.get(timestamp));\\n            min.remove(mp.get(timestamp));    \\n        }\\n        max.add(price);\\n        min.add(price);\\n        if(timestamp>current)\\n             current=timestamp;\\n        mp.put(timestamp , price);\\n    }\\n    \\n    public int current() {\\n        return mp.get(current);\\n    }\\n    \\n    public int maximum() {\\n        return max.peek();\\n    }\\n    \\n    public int minimum() {\\n        return min.peek();\\n    }\\n}\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Try to use Map. For storing current element in multiset(so that it can store duplicate too if any)..\nRemove old value from set and insert new value.(For Update)\nuse rbegin and begin for maximum and minimum."
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "I am getting timeout when using 2 heaps (min/max heap) but I see other solutions which are working using the same - any optimisation you all think I can do. \nhttps://leetcode.com/problems/stock-price-fluctuation/solutions/1513293/python-clean-2-heaps-commented-code/ and https://leetcode.com/problems/stock-price-fluctuation/solutions/1513302/simple-solution-using-max-heap-and-min-heap/\n\n\n ```\n\nclass StockPrice {\n\n    Map<Integer, Container> map = new HashMap<>();\n    PriorityQueue<Container> max = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container2.price, container1.price);\n        }\n    });\n\n    PriorityQueue<Container> min = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container1.price, container2.price);\n        }\n    });\n    int current = -1;\n    int latestTimeStamp = -1;\n    public StockPrice() {\n        \n    }\n    \n    public void update(int timestamp, int price) {\n        if(timestamp>=latestTimeStamp) {\n            latestTimeStamp = timestamp;\n            current = price;\n        }\n        if(map.containsKey(timestamp)) {\n            Container container = map.get(timestamp);\n            container.price = price;\n            max.remove(container);\n            min.remove(container);\n            max.add(container);\n            min.add(container);\n        } else {\n            Container container = new Container(price, timestamp);\n            map.put(timestamp, container);\n            max.add(container);\n            min.add(container);\n        }\n    }\n    \n    public int current() {\n        return current;\n    }\n    \n    public int maximum() {\n        return max.peek().price;\n    }\n    \n    public int minimum() {\n        return min.peek().price;\n    }\n\n    public static class Container {\n        int price;\n        int timestamp;\n\n        public Container(int price, int timestamp) {\n            this.price = price;\n            this.timestamp = timestamp;\n        }\n    }\n}.\n\n```"
                    },
                    {
                        "username": "Irving09",
                        "content": "[@harshit_bangar](/harshit_bangar)\\n\\nYou cant just max.peek().price or min.peek().price, I had the same code and it turns out heapify doesnt get triggered for adding and removing.\\n\\n```\\nclass StockPrice {\\n\\n  class Record {\\n    int timestamp;\\n    int price;\\n    public Record(int timestamp, int price) {\\n      this.timestamp = timestamp;\\n      this.price = price;\\n    }\\n  }\\n\\n  private Map<Integer, Record> records;\\n  private Queue<Record> max;\\n  private Queue<Record> min;\\n  private int latestTimestamp;\\n\\n  public StockPrice() {\\n    records = new HashMap<>();\\n    max = new PriorityQueue<>((r1, r2) -> r2.price - r1.price);\\n    min = new PriorityQueue<>((r1, r2) -> r1.price - r2.price);\\n    latestTimestamp = 1;\\n  }\\n  \\n  public void update(int timestamp, int price) { // O(logn)\\n    if (records.containsKey(timestamp)) {\\n      records.get(timestamp).price = price;\\n    } else {\\n      Record record = new Record(timestamp, price);\\n      records.put(timestamp, record);\\n      max.offer(record);\\n      min.offer(record);\\n    }\\n\\n    max.offer(max.poll()); // didnt actually re-trigger heapify\\n    min.offer(min.poll()); // didnt actually re-trigger heapify\\n    latestTimestamp = Math.max(latestTimestamp, timestamp);\\n  }\\n  \\n  public int current() { // O(1)\\n    return records.get(latestTimestamp).price;\\n  }\\n  \\n  public int maximum() { // logn\\n    return max.peek().price;\\n  }\\n  \\n  public int minimum() { // logn\\n    return min.peek().price;\\n  }\\n}\\n\\n/**\\n* Your StockPrice object will be instantiated and called as such:\\n* StockPrice obj = new StockPrice();\\n* obj.update(timestamp,price);\\n* int param_2 = obj.current();\\n* int param_3 = obj.maximum();\\n* int param_4 = obj.minimum();\\n*/\\n```"
                    },
                    {
                        "username": "user1325DR",
                        "content": "what is wrong with this implementation : - \n--------------\nimport java.util.NavigableMap;\nclass StockPrice {\n    SortedSet timestamps;\n    Map<Integer, Integer> priceMap;\n    \n    int currPrice = -1;\n    int currTimestamp = -1;\n    \n    public StockPrice() {\n        timestamps = new TreeSet<>((a, b) -> priceMap.get(a) - priceMap.get(b));\n        priceMap = new HashMap<>();\n    }\n    \n    public void update(int timestamp, int price) {\n        if(priceMap.containsKey(timestamp))\n        {\n            timestamps.remove(timestamp);\n        }\n        priceMap.put(timestamp, price);\n        timestamps.add(timestamp);\n        if(timestamp >= currTimestamp)\n        {\n            currTimestamp = timestamp;\n            currPrice = price;\n        }\n    }\n    \n    public int current() {\n        return currPrice;\n    }\n    \n    public int maximum() {\n        return priceMap.get(timestamps.last());\n    }\n    \n    public int minimum() {\n        return priceMap.get(timestamps.first());\n    }\n}\n\n--------------"
                    },
                    {
                        "username": "vetty",
                        "content": "Same q"
                    },
                    {
                        "username": "vinayakprasad96",
                        "content": "#ff"
                    }
                ]
            },
            {
                "id": 1802336,
                "content": [
                    {
                        "username": "Movely",
                        "content": "How would you tackle this question in a system design interview? Comment below. What comes to my mind is:\\n\\n- Consider how this is used. Probably a REST API over HTTP would be a good choice.\\n- How much traffic do we expect? It\\'s probably not used for just a single stock, but more to the tune of like a 1000 stocks. If this is some kind of high frequency trading, then would it be reasonable to approximate this as one tick per stock per milisecond, for 8 hours each working day? If so, then the number of records in one day we could  expect would be 1000 stocks * 1 tick/stock/ms * 8 hours * 1 record/tick =~ 1000 * 8 * 4000,000ms * 1 records/ms =~ 30 billion records in one day.\\n- While it\\'s not part of the requirements, it makes sense to expect that the users would not require to update records older than a specified amount. For example, perhaps it is not necessary to be able to update records older than 1 day? \\n- If so, this makes it easier to manage the storage - because we only need to keep one day\\'s worth of records, and for all earlier data we just have to keep the minimum, maximum and youngest values.\\n- We could store the data in a NoSQL database, partitioned by stock+date of the timestamp and for each stock, use a sorted set of price+timestamp pairs and a table of prices indexes by timestamp. For example to update the data, we insert the new timestamp+price pair in the sorted set (without removing the possible previous value) and insert or update the record in the table. To get the minimum, check the timestamp+price in the sorted set with the minimum price; verify if the same price is stored in the table for the specified timestamp. If it\\'s not, then it means that an update has occurred, in which case remove that record from the sorted set and try again. If the minimum for data older than 1 day is lower, return that instead. Note that if there were a lot of updates for already stored timestamps, then it\\'s possible to generate even more storage load than approximated above.\\n- Possibly worth discussing the availability and consistency requirements for the NoSQL solution.\\n\\nWhat do you think?"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "IMO Rest API over HTTP is not a good idea, this is going to be a crazy load and if the service is down even for a minute, whole data in the consumer side would be messed up. Instead if we use distributed queue like Kafka, we will get 100 percent availability. Now even if the application is down or something it can always come back and start consuming. \\nTo get parallelism here we can have multiple partitions in the queue. To make sure we always consume the updates after insertion, we can use timestamp and stock name as the key (simple hashing concept is used, if partition count can increase or decrease at runtime consistent hashing could be used but that is not the case with Kafka, I believe).  "
                    },
                    {
                        "username": "AndrewEmoryTate",
                        "content": "Any idea why it doesn\\'t work `your \\nclass StockPrice {\\npublic:\\n    map<int, int> mp;\\n    set<int> prices;\\n    int currPrice;\\n\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if (mp.find(timestamp) == mp.end()) {\\n            mp[timestamp] = price;\\n            prices.insert(price);\\n        } else {\\n            int x = mp[timestamp];\\n            set<int>::reverse_iterator it = prices.rbegin();\\n            std::set<int>::iterator it2 = prices.begin();\\n            int firstElem = *it2;\\n            int lastElem = *it;\\n            if (x == lastElem) {\\n                prices.erase(std::next(it).base());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else if (x == firstElem) {\\n                prices.erase(prices.begin());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else {\\n                mp[timestamp] = price;\\n                prices.insert(price);\\n            }\\n        }\\n    }\\n    \\n    int current() {\\n        map<int, int>::reverse_iterator it = mp.rbegin();\\n        return it->second;\\n    }\\n    \\n    int maximum() {\\n        return *prices.rbegin();\\n    }\\n\\n    int minimum() {\\n        return *prices.begin();\\n    }\\n\\n};"
                    },
                    {
                        "username": "rajshah008",
                        "content": "Why I m getting TLE can anyone explain?\\nclass StockPrice {\\n    Map<Integer,Integer> mp ;\\n    PriorityQueue<Integer> max,min;\\n    int current=0;\\n    public StockPrice() {\\n        mp = new HashMap<>();\\n        min = new PriorityQueue<>();\\n        max = new PriorityQueue<>(Collections.reverseOrder());\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(mp.containsKey(timestamp)){\\n            max.remove(mp.get(timestamp));\\n            min.remove(mp.get(timestamp));    \\n        }\\n        max.add(price);\\n        min.add(price);\\n        if(timestamp>current)\\n             current=timestamp;\\n        mp.put(timestamp , price);\\n    }\\n    \\n    public int current() {\\n        return mp.get(current);\\n    }\\n    \\n    public int maximum() {\\n        return max.peek();\\n    }\\n    \\n    public int minimum() {\\n        return min.peek();\\n    }\\n}\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Try to use Map. For storing current element in multiset(so that it can store duplicate too if any)..\nRemove old value from set and insert new value.(For Update)\nuse rbegin and begin for maximum and minimum."
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "I am getting timeout when using 2 heaps (min/max heap) but I see other solutions which are working using the same - any optimisation you all think I can do. \nhttps://leetcode.com/problems/stock-price-fluctuation/solutions/1513293/python-clean-2-heaps-commented-code/ and https://leetcode.com/problems/stock-price-fluctuation/solutions/1513302/simple-solution-using-max-heap-and-min-heap/\n\n\n ```\n\nclass StockPrice {\n\n    Map<Integer, Container> map = new HashMap<>();\n    PriorityQueue<Container> max = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container2.price, container1.price);\n        }\n    });\n\n    PriorityQueue<Container> min = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container1.price, container2.price);\n        }\n    });\n    int current = -1;\n    int latestTimeStamp = -1;\n    public StockPrice() {\n        \n    }\n    \n    public void update(int timestamp, int price) {\n        if(timestamp>=latestTimeStamp) {\n            latestTimeStamp = timestamp;\n            current = price;\n        }\n        if(map.containsKey(timestamp)) {\n            Container container = map.get(timestamp);\n            container.price = price;\n            max.remove(container);\n            min.remove(container);\n            max.add(container);\n            min.add(container);\n        } else {\n            Container container = new Container(price, timestamp);\n            map.put(timestamp, container);\n            max.add(container);\n            min.add(container);\n        }\n    }\n    \n    public int current() {\n        return current;\n    }\n    \n    public int maximum() {\n        return max.peek().price;\n    }\n    \n    public int minimum() {\n        return min.peek().price;\n    }\n\n    public static class Container {\n        int price;\n        int timestamp;\n\n        public Container(int price, int timestamp) {\n            this.price = price;\n            this.timestamp = timestamp;\n        }\n    }\n}.\n\n```"
                    },
                    {
                        "username": "Irving09",
                        "content": "[@harshit_bangar](/harshit_bangar)\\n\\nYou cant just max.peek().price or min.peek().price, I had the same code and it turns out heapify doesnt get triggered for adding and removing.\\n\\n```\\nclass StockPrice {\\n\\n  class Record {\\n    int timestamp;\\n    int price;\\n    public Record(int timestamp, int price) {\\n      this.timestamp = timestamp;\\n      this.price = price;\\n    }\\n  }\\n\\n  private Map<Integer, Record> records;\\n  private Queue<Record> max;\\n  private Queue<Record> min;\\n  private int latestTimestamp;\\n\\n  public StockPrice() {\\n    records = new HashMap<>();\\n    max = new PriorityQueue<>((r1, r2) -> r2.price - r1.price);\\n    min = new PriorityQueue<>((r1, r2) -> r1.price - r2.price);\\n    latestTimestamp = 1;\\n  }\\n  \\n  public void update(int timestamp, int price) { // O(logn)\\n    if (records.containsKey(timestamp)) {\\n      records.get(timestamp).price = price;\\n    } else {\\n      Record record = new Record(timestamp, price);\\n      records.put(timestamp, record);\\n      max.offer(record);\\n      min.offer(record);\\n    }\\n\\n    max.offer(max.poll()); // didnt actually re-trigger heapify\\n    min.offer(min.poll()); // didnt actually re-trigger heapify\\n    latestTimestamp = Math.max(latestTimestamp, timestamp);\\n  }\\n  \\n  public int current() { // O(1)\\n    return records.get(latestTimestamp).price;\\n  }\\n  \\n  public int maximum() { // logn\\n    return max.peek().price;\\n  }\\n  \\n  public int minimum() { // logn\\n    return min.peek().price;\\n  }\\n}\\n\\n/**\\n* Your StockPrice object will be instantiated and called as such:\\n* StockPrice obj = new StockPrice();\\n* obj.update(timestamp,price);\\n* int param_2 = obj.current();\\n* int param_3 = obj.maximum();\\n* int param_4 = obj.minimum();\\n*/\\n```"
                    },
                    {
                        "username": "user1325DR",
                        "content": "what is wrong with this implementation : - \n--------------\nimport java.util.NavigableMap;\nclass StockPrice {\n    SortedSet timestamps;\n    Map<Integer, Integer> priceMap;\n    \n    int currPrice = -1;\n    int currTimestamp = -1;\n    \n    public StockPrice() {\n        timestamps = new TreeSet<>((a, b) -> priceMap.get(a) - priceMap.get(b));\n        priceMap = new HashMap<>();\n    }\n    \n    public void update(int timestamp, int price) {\n        if(priceMap.containsKey(timestamp))\n        {\n            timestamps.remove(timestamp);\n        }\n        priceMap.put(timestamp, price);\n        timestamps.add(timestamp);\n        if(timestamp >= currTimestamp)\n        {\n            currTimestamp = timestamp;\n            currPrice = price;\n        }\n    }\n    \n    public int current() {\n        return currPrice;\n    }\n    \n    public int maximum() {\n        return priceMap.get(timestamps.last());\n    }\n    \n    public int minimum() {\n        return priceMap.get(timestamps.first());\n    }\n}\n\n--------------"
                    },
                    {
                        "username": "vetty",
                        "content": "Same q"
                    },
                    {
                        "username": "vinayakprasad96",
                        "content": "#ff"
                    }
                ]
            },
            {
                "id": 1757981,
                "content": [
                    {
                        "username": "Movely",
                        "content": "How would you tackle this question in a system design interview? Comment below. What comes to my mind is:\\n\\n- Consider how this is used. Probably a REST API over HTTP would be a good choice.\\n- How much traffic do we expect? It\\'s probably not used for just a single stock, but more to the tune of like a 1000 stocks. If this is some kind of high frequency trading, then would it be reasonable to approximate this as one tick per stock per milisecond, for 8 hours each working day? If so, then the number of records in one day we could  expect would be 1000 stocks * 1 tick/stock/ms * 8 hours * 1 record/tick =~ 1000 * 8 * 4000,000ms * 1 records/ms =~ 30 billion records in one day.\\n- While it\\'s not part of the requirements, it makes sense to expect that the users would not require to update records older than a specified amount. For example, perhaps it is not necessary to be able to update records older than 1 day? \\n- If so, this makes it easier to manage the storage - because we only need to keep one day\\'s worth of records, and for all earlier data we just have to keep the minimum, maximum and youngest values.\\n- We could store the data in a NoSQL database, partitioned by stock+date of the timestamp and for each stock, use a sorted set of price+timestamp pairs and a table of prices indexes by timestamp. For example to update the data, we insert the new timestamp+price pair in the sorted set (without removing the possible previous value) and insert or update the record in the table. To get the minimum, check the timestamp+price in the sorted set with the minimum price; verify if the same price is stored in the table for the specified timestamp. If it\\'s not, then it means that an update has occurred, in which case remove that record from the sorted set and try again. If the minimum for data older than 1 day is lower, return that instead. Note that if there were a lot of updates for already stored timestamps, then it\\'s possible to generate even more storage load than approximated above.\\n- Possibly worth discussing the availability and consistency requirements for the NoSQL solution.\\n\\nWhat do you think?"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "IMO Rest API over HTTP is not a good idea, this is going to be a crazy load and if the service is down even for a minute, whole data in the consumer side would be messed up. Instead if we use distributed queue like Kafka, we will get 100 percent availability. Now even if the application is down or something it can always come back and start consuming. \\nTo get parallelism here we can have multiple partitions in the queue. To make sure we always consume the updates after insertion, we can use timestamp and stock name as the key (simple hashing concept is used, if partition count can increase or decrease at runtime consistent hashing could be used but that is not the case with Kafka, I believe).  "
                    },
                    {
                        "username": "AndrewEmoryTate",
                        "content": "Any idea why it doesn\\'t work `your \\nclass StockPrice {\\npublic:\\n    map<int, int> mp;\\n    set<int> prices;\\n    int currPrice;\\n\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if (mp.find(timestamp) == mp.end()) {\\n            mp[timestamp] = price;\\n            prices.insert(price);\\n        } else {\\n            int x = mp[timestamp];\\n            set<int>::reverse_iterator it = prices.rbegin();\\n            std::set<int>::iterator it2 = prices.begin();\\n            int firstElem = *it2;\\n            int lastElem = *it;\\n            if (x == lastElem) {\\n                prices.erase(std::next(it).base());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else if (x == firstElem) {\\n                prices.erase(prices.begin());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else {\\n                mp[timestamp] = price;\\n                prices.insert(price);\\n            }\\n        }\\n    }\\n    \\n    int current() {\\n        map<int, int>::reverse_iterator it = mp.rbegin();\\n        return it->second;\\n    }\\n    \\n    int maximum() {\\n        return *prices.rbegin();\\n    }\\n\\n    int minimum() {\\n        return *prices.begin();\\n    }\\n\\n};"
                    },
                    {
                        "username": "rajshah008",
                        "content": "Why I m getting TLE can anyone explain?\\nclass StockPrice {\\n    Map<Integer,Integer> mp ;\\n    PriorityQueue<Integer> max,min;\\n    int current=0;\\n    public StockPrice() {\\n        mp = new HashMap<>();\\n        min = new PriorityQueue<>();\\n        max = new PriorityQueue<>(Collections.reverseOrder());\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(mp.containsKey(timestamp)){\\n            max.remove(mp.get(timestamp));\\n            min.remove(mp.get(timestamp));    \\n        }\\n        max.add(price);\\n        min.add(price);\\n        if(timestamp>current)\\n             current=timestamp;\\n        mp.put(timestamp , price);\\n    }\\n    \\n    public int current() {\\n        return mp.get(current);\\n    }\\n    \\n    public int maximum() {\\n        return max.peek();\\n    }\\n    \\n    public int minimum() {\\n        return min.peek();\\n    }\\n}\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Try to use Map. For storing current element in multiset(so that it can store duplicate too if any)..\nRemove old value from set and insert new value.(For Update)\nuse rbegin and begin for maximum and minimum."
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "I am getting timeout when using 2 heaps (min/max heap) but I see other solutions which are working using the same - any optimisation you all think I can do. \nhttps://leetcode.com/problems/stock-price-fluctuation/solutions/1513293/python-clean-2-heaps-commented-code/ and https://leetcode.com/problems/stock-price-fluctuation/solutions/1513302/simple-solution-using-max-heap-and-min-heap/\n\n\n ```\n\nclass StockPrice {\n\n    Map<Integer, Container> map = new HashMap<>();\n    PriorityQueue<Container> max = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container2.price, container1.price);\n        }\n    });\n\n    PriorityQueue<Container> min = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container1.price, container2.price);\n        }\n    });\n    int current = -1;\n    int latestTimeStamp = -1;\n    public StockPrice() {\n        \n    }\n    \n    public void update(int timestamp, int price) {\n        if(timestamp>=latestTimeStamp) {\n            latestTimeStamp = timestamp;\n            current = price;\n        }\n        if(map.containsKey(timestamp)) {\n            Container container = map.get(timestamp);\n            container.price = price;\n            max.remove(container);\n            min.remove(container);\n            max.add(container);\n            min.add(container);\n        } else {\n            Container container = new Container(price, timestamp);\n            map.put(timestamp, container);\n            max.add(container);\n            min.add(container);\n        }\n    }\n    \n    public int current() {\n        return current;\n    }\n    \n    public int maximum() {\n        return max.peek().price;\n    }\n    \n    public int minimum() {\n        return min.peek().price;\n    }\n\n    public static class Container {\n        int price;\n        int timestamp;\n\n        public Container(int price, int timestamp) {\n            this.price = price;\n            this.timestamp = timestamp;\n        }\n    }\n}.\n\n```"
                    },
                    {
                        "username": "Irving09",
                        "content": "[@harshit_bangar](/harshit_bangar)\\n\\nYou cant just max.peek().price or min.peek().price, I had the same code and it turns out heapify doesnt get triggered for adding and removing.\\n\\n```\\nclass StockPrice {\\n\\n  class Record {\\n    int timestamp;\\n    int price;\\n    public Record(int timestamp, int price) {\\n      this.timestamp = timestamp;\\n      this.price = price;\\n    }\\n  }\\n\\n  private Map<Integer, Record> records;\\n  private Queue<Record> max;\\n  private Queue<Record> min;\\n  private int latestTimestamp;\\n\\n  public StockPrice() {\\n    records = new HashMap<>();\\n    max = new PriorityQueue<>((r1, r2) -> r2.price - r1.price);\\n    min = new PriorityQueue<>((r1, r2) -> r1.price - r2.price);\\n    latestTimestamp = 1;\\n  }\\n  \\n  public void update(int timestamp, int price) { // O(logn)\\n    if (records.containsKey(timestamp)) {\\n      records.get(timestamp).price = price;\\n    } else {\\n      Record record = new Record(timestamp, price);\\n      records.put(timestamp, record);\\n      max.offer(record);\\n      min.offer(record);\\n    }\\n\\n    max.offer(max.poll()); // didnt actually re-trigger heapify\\n    min.offer(min.poll()); // didnt actually re-trigger heapify\\n    latestTimestamp = Math.max(latestTimestamp, timestamp);\\n  }\\n  \\n  public int current() { // O(1)\\n    return records.get(latestTimestamp).price;\\n  }\\n  \\n  public int maximum() { // logn\\n    return max.peek().price;\\n  }\\n  \\n  public int minimum() { // logn\\n    return min.peek().price;\\n  }\\n}\\n\\n/**\\n* Your StockPrice object will be instantiated and called as such:\\n* StockPrice obj = new StockPrice();\\n* obj.update(timestamp,price);\\n* int param_2 = obj.current();\\n* int param_3 = obj.maximum();\\n* int param_4 = obj.minimum();\\n*/\\n```"
                    },
                    {
                        "username": "user1325DR",
                        "content": "what is wrong with this implementation : - \n--------------\nimport java.util.NavigableMap;\nclass StockPrice {\n    SortedSet timestamps;\n    Map<Integer, Integer> priceMap;\n    \n    int currPrice = -1;\n    int currTimestamp = -1;\n    \n    public StockPrice() {\n        timestamps = new TreeSet<>((a, b) -> priceMap.get(a) - priceMap.get(b));\n        priceMap = new HashMap<>();\n    }\n    \n    public void update(int timestamp, int price) {\n        if(priceMap.containsKey(timestamp))\n        {\n            timestamps.remove(timestamp);\n        }\n        priceMap.put(timestamp, price);\n        timestamps.add(timestamp);\n        if(timestamp >= currTimestamp)\n        {\n            currTimestamp = timestamp;\n            currPrice = price;\n        }\n    }\n    \n    public int current() {\n        return currPrice;\n    }\n    \n    public int maximum() {\n        return priceMap.get(timestamps.last());\n    }\n    \n    public int minimum() {\n        return priceMap.get(timestamps.first());\n    }\n}\n\n--------------"
                    },
                    {
                        "username": "vetty",
                        "content": "Same q"
                    },
                    {
                        "username": "vinayakprasad96",
                        "content": "#ff"
                    }
                ]
            },
            {
                "id": 1721517,
                "content": [
                    {
                        "username": "Movely",
                        "content": "How would you tackle this question in a system design interview? Comment below. What comes to my mind is:\\n\\n- Consider how this is used. Probably a REST API over HTTP would be a good choice.\\n- How much traffic do we expect? It\\'s probably not used for just a single stock, but more to the tune of like a 1000 stocks. If this is some kind of high frequency trading, then would it be reasonable to approximate this as one tick per stock per milisecond, for 8 hours each working day? If so, then the number of records in one day we could  expect would be 1000 stocks * 1 tick/stock/ms * 8 hours * 1 record/tick =~ 1000 * 8 * 4000,000ms * 1 records/ms =~ 30 billion records in one day.\\n- While it\\'s not part of the requirements, it makes sense to expect that the users would not require to update records older than a specified amount. For example, perhaps it is not necessary to be able to update records older than 1 day? \\n- If so, this makes it easier to manage the storage - because we only need to keep one day\\'s worth of records, and for all earlier data we just have to keep the minimum, maximum and youngest values.\\n- We could store the data in a NoSQL database, partitioned by stock+date of the timestamp and for each stock, use a sorted set of price+timestamp pairs and a table of prices indexes by timestamp. For example to update the data, we insert the new timestamp+price pair in the sorted set (without removing the possible previous value) and insert or update the record in the table. To get the minimum, check the timestamp+price in the sorted set with the minimum price; verify if the same price is stored in the table for the specified timestamp. If it\\'s not, then it means that an update has occurred, in which case remove that record from the sorted set and try again. If the minimum for data older than 1 day is lower, return that instead. Note that if there were a lot of updates for already stored timestamps, then it\\'s possible to generate even more storage load than approximated above.\\n- Possibly worth discussing the availability and consistency requirements for the NoSQL solution.\\n\\nWhat do you think?"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "IMO Rest API over HTTP is not a good idea, this is going to be a crazy load and if the service is down even for a minute, whole data in the consumer side would be messed up. Instead if we use distributed queue like Kafka, we will get 100 percent availability. Now even if the application is down or something it can always come back and start consuming. \\nTo get parallelism here we can have multiple partitions in the queue. To make sure we always consume the updates after insertion, we can use timestamp and stock name as the key (simple hashing concept is used, if partition count can increase or decrease at runtime consistent hashing could be used but that is not the case with Kafka, I believe).  "
                    },
                    {
                        "username": "AndrewEmoryTate",
                        "content": "Any idea why it doesn\\'t work `your \\nclass StockPrice {\\npublic:\\n    map<int, int> mp;\\n    set<int> prices;\\n    int currPrice;\\n\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if (mp.find(timestamp) == mp.end()) {\\n            mp[timestamp] = price;\\n            prices.insert(price);\\n        } else {\\n            int x = mp[timestamp];\\n            set<int>::reverse_iterator it = prices.rbegin();\\n            std::set<int>::iterator it2 = prices.begin();\\n            int firstElem = *it2;\\n            int lastElem = *it;\\n            if (x == lastElem) {\\n                prices.erase(std::next(it).base());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else if (x == firstElem) {\\n                prices.erase(prices.begin());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else {\\n                mp[timestamp] = price;\\n                prices.insert(price);\\n            }\\n        }\\n    }\\n    \\n    int current() {\\n        map<int, int>::reverse_iterator it = mp.rbegin();\\n        return it->second;\\n    }\\n    \\n    int maximum() {\\n        return *prices.rbegin();\\n    }\\n\\n    int minimum() {\\n        return *prices.begin();\\n    }\\n\\n};"
                    },
                    {
                        "username": "rajshah008",
                        "content": "Why I m getting TLE can anyone explain?\\nclass StockPrice {\\n    Map<Integer,Integer> mp ;\\n    PriorityQueue<Integer> max,min;\\n    int current=0;\\n    public StockPrice() {\\n        mp = new HashMap<>();\\n        min = new PriorityQueue<>();\\n        max = new PriorityQueue<>(Collections.reverseOrder());\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(mp.containsKey(timestamp)){\\n            max.remove(mp.get(timestamp));\\n            min.remove(mp.get(timestamp));    \\n        }\\n        max.add(price);\\n        min.add(price);\\n        if(timestamp>current)\\n             current=timestamp;\\n        mp.put(timestamp , price);\\n    }\\n    \\n    public int current() {\\n        return mp.get(current);\\n    }\\n    \\n    public int maximum() {\\n        return max.peek();\\n    }\\n    \\n    public int minimum() {\\n        return min.peek();\\n    }\\n}\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Try to use Map. For storing current element in multiset(so that it can store duplicate too if any)..\nRemove old value from set and insert new value.(For Update)\nuse rbegin and begin for maximum and minimum."
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "I am getting timeout when using 2 heaps (min/max heap) but I see other solutions which are working using the same - any optimisation you all think I can do. \nhttps://leetcode.com/problems/stock-price-fluctuation/solutions/1513293/python-clean-2-heaps-commented-code/ and https://leetcode.com/problems/stock-price-fluctuation/solutions/1513302/simple-solution-using-max-heap-and-min-heap/\n\n\n ```\n\nclass StockPrice {\n\n    Map<Integer, Container> map = new HashMap<>();\n    PriorityQueue<Container> max = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container2.price, container1.price);\n        }\n    });\n\n    PriorityQueue<Container> min = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container1.price, container2.price);\n        }\n    });\n    int current = -1;\n    int latestTimeStamp = -1;\n    public StockPrice() {\n        \n    }\n    \n    public void update(int timestamp, int price) {\n        if(timestamp>=latestTimeStamp) {\n            latestTimeStamp = timestamp;\n            current = price;\n        }\n        if(map.containsKey(timestamp)) {\n            Container container = map.get(timestamp);\n            container.price = price;\n            max.remove(container);\n            min.remove(container);\n            max.add(container);\n            min.add(container);\n        } else {\n            Container container = new Container(price, timestamp);\n            map.put(timestamp, container);\n            max.add(container);\n            min.add(container);\n        }\n    }\n    \n    public int current() {\n        return current;\n    }\n    \n    public int maximum() {\n        return max.peek().price;\n    }\n    \n    public int minimum() {\n        return min.peek().price;\n    }\n\n    public static class Container {\n        int price;\n        int timestamp;\n\n        public Container(int price, int timestamp) {\n            this.price = price;\n            this.timestamp = timestamp;\n        }\n    }\n}.\n\n```"
                    },
                    {
                        "username": "Irving09",
                        "content": "[@harshit_bangar](/harshit_bangar)\\n\\nYou cant just max.peek().price or min.peek().price, I had the same code and it turns out heapify doesnt get triggered for adding and removing.\\n\\n```\\nclass StockPrice {\\n\\n  class Record {\\n    int timestamp;\\n    int price;\\n    public Record(int timestamp, int price) {\\n      this.timestamp = timestamp;\\n      this.price = price;\\n    }\\n  }\\n\\n  private Map<Integer, Record> records;\\n  private Queue<Record> max;\\n  private Queue<Record> min;\\n  private int latestTimestamp;\\n\\n  public StockPrice() {\\n    records = new HashMap<>();\\n    max = new PriorityQueue<>((r1, r2) -> r2.price - r1.price);\\n    min = new PriorityQueue<>((r1, r2) -> r1.price - r2.price);\\n    latestTimestamp = 1;\\n  }\\n  \\n  public void update(int timestamp, int price) { // O(logn)\\n    if (records.containsKey(timestamp)) {\\n      records.get(timestamp).price = price;\\n    } else {\\n      Record record = new Record(timestamp, price);\\n      records.put(timestamp, record);\\n      max.offer(record);\\n      min.offer(record);\\n    }\\n\\n    max.offer(max.poll()); // didnt actually re-trigger heapify\\n    min.offer(min.poll()); // didnt actually re-trigger heapify\\n    latestTimestamp = Math.max(latestTimestamp, timestamp);\\n  }\\n  \\n  public int current() { // O(1)\\n    return records.get(latestTimestamp).price;\\n  }\\n  \\n  public int maximum() { // logn\\n    return max.peek().price;\\n  }\\n  \\n  public int minimum() { // logn\\n    return min.peek().price;\\n  }\\n}\\n\\n/**\\n* Your StockPrice object will be instantiated and called as such:\\n* StockPrice obj = new StockPrice();\\n* obj.update(timestamp,price);\\n* int param_2 = obj.current();\\n* int param_3 = obj.maximum();\\n* int param_4 = obj.minimum();\\n*/\\n```"
                    },
                    {
                        "username": "user1325DR",
                        "content": "what is wrong with this implementation : - \n--------------\nimport java.util.NavigableMap;\nclass StockPrice {\n    SortedSet timestamps;\n    Map<Integer, Integer> priceMap;\n    \n    int currPrice = -1;\n    int currTimestamp = -1;\n    \n    public StockPrice() {\n        timestamps = new TreeSet<>((a, b) -> priceMap.get(a) - priceMap.get(b));\n        priceMap = new HashMap<>();\n    }\n    \n    public void update(int timestamp, int price) {\n        if(priceMap.containsKey(timestamp))\n        {\n            timestamps.remove(timestamp);\n        }\n        priceMap.put(timestamp, price);\n        timestamps.add(timestamp);\n        if(timestamp >= currTimestamp)\n        {\n            currTimestamp = timestamp;\n            currPrice = price;\n        }\n    }\n    \n    public int current() {\n        return currPrice;\n    }\n    \n    public int maximum() {\n        return priceMap.get(timestamps.last());\n    }\n    \n    public int minimum() {\n        return priceMap.get(timestamps.first());\n    }\n}\n\n--------------"
                    },
                    {
                        "username": "vetty",
                        "content": "Same q"
                    },
                    {
                        "username": "vinayakprasad96",
                        "content": "#ff"
                    }
                ]
            },
            {
                "id": 1698137,
                "content": [
                    {
                        "username": "Movely",
                        "content": "How would you tackle this question in a system design interview? Comment below. What comes to my mind is:\\n\\n- Consider how this is used. Probably a REST API over HTTP would be a good choice.\\n- How much traffic do we expect? It\\'s probably not used for just a single stock, but more to the tune of like a 1000 stocks. If this is some kind of high frequency trading, then would it be reasonable to approximate this as one tick per stock per milisecond, for 8 hours each working day? If so, then the number of records in one day we could  expect would be 1000 stocks * 1 tick/stock/ms * 8 hours * 1 record/tick =~ 1000 * 8 * 4000,000ms * 1 records/ms =~ 30 billion records in one day.\\n- While it\\'s not part of the requirements, it makes sense to expect that the users would not require to update records older than a specified amount. For example, perhaps it is not necessary to be able to update records older than 1 day? \\n- If so, this makes it easier to manage the storage - because we only need to keep one day\\'s worth of records, and for all earlier data we just have to keep the minimum, maximum and youngest values.\\n- We could store the data in a NoSQL database, partitioned by stock+date of the timestamp and for each stock, use a sorted set of price+timestamp pairs and a table of prices indexes by timestamp. For example to update the data, we insert the new timestamp+price pair in the sorted set (without removing the possible previous value) and insert or update the record in the table. To get the minimum, check the timestamp+price in the sorted set with the minimum price; verify if the same price is stored in the table for the specified timestamp. If it\\'s not, then it means that an update has occurred, in which case remove that record from the sorted set and try again. If the minimum for data older than 1 day is lower, return that instead. Note that if there were a lot of updates for already stored timestamps, then it\\'s possible to generate even more storage load than approximated above.\\n- Possibly worth discussing the availability and consistency requirements for the NoSQL solution.\\n\\nWhat do you think?"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "IMO Rest API over HTTP is not a good idea, this is going to be a crazy load and if the service is down even for a minute, whole data in the consumer side would be messed up. Instead if we use distributed queue like Kafka, we will get 100 percent availability. Now even if the application is down or something it can always come back and start consuming. \\nTo get parallelism here we can have multiple partitions in the queue. To make sure we always consume the updates after insertion, we can use timestamp and stock name as the key (simple hashing concept is used, if partition count can increase or decrease at runtime consistent hashing could be used but that is not the case with Kafka, I believe).  "
                    },
                    {
                        "username": "AndrewEmoryTate",
                        "content": "Any idea why it doesn\\'t work `your \\nclass StockPrice {\\npublic:\\n    map<int, int> mp;\\n    set<int> prices;\\n    int currPrice;\\n\\n    StockPrice() {\\n        \\n    }\\n    \\n    void update(int timestamp, int price) {\\n        if (mp.find(timestamp) == mp.end()) {\\n            mp[timestamp] = price;\\n            prices.insert(price);\\n        } else {\\n            int x = mp[timestamp];\\n            set<int>::reverse_iterator it = prices.rbegin();\\n            std::set<int>::iterator it2 = prices.begin();\\n            int firstElem = *it2;\\n            int lastElem = *it;\\n            if (x == lastElem) {\\n                prices.erase(std::next(it).base());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else if (x == firstElem) {\\n                prices.erase(prices.begin());\\n                prices.insert(price);\\n                mp[timestamp] = price;\\n            } else {\\n                mp[timestamp] = price;\\n                prices.insert(price);\\n            }\\n        }\\n    }\\n    \\n    int current() {\\n        map<int, int>::reverse_iterator it = mp.rbegin();\\n        return it->second;\\n    }\\n    \\n    int maximum() {\\n        return *prices.rbegin();\\n    }\\n\\n    int minimum() {\\n        return *prices.begin();\\n    }\\n\\n};"
                    },
                    {
                        "username": "rajshah008",
                        "content": "Why I m getting TLE can anyone explain?\\nclass StockPrice {\\n    Map<Integer,Integer> mp ;\\n    PriorityQueue<Integer> max,min;\\n    int current=0;\\n    public StockPrice() {\\n        mp = new HashMap<>();\\n        min = new PriorityQueue<>();\\n        max = new PriorityQueue<>(Collections.reverseOrder());\\n    }\\n    \\n    public void update(int timestamp, int price) {\\n        if(mp.containsKey(timestamp)){\\n            max.remove(mp.get(timestamp));\\n            min.remove(mp.get(timestamp));    \\n        }\\n        max.add(price);\\n        min.add(price);\\n        if(timestamp>current)\\n             current=timestamp;\\n        mp.put(timestamp , price);\\n    }\\n    \\n    public int current() {\\n        return mp.get(current);\\n    }\\n    \\n    public int maximum() {\\n        return max.peek();\\n    }\\n    \\n    public int minimum() {\\n        return min.peek();\\n    }\\n}\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Try to use Map. For storing current element in multiset(so that it can store duplicate too if any)..\nRemove old value from set and insert new value.(For Update)\nuse rbegin and begin for maximum and minimum."
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "I am getting timeout when using 2 heaps (min/max heap) but I see other solutions which are working using the same - any optimisation you all think I can do. \nhttps://leetcode.com/problems/stock-price-fluctuation/solutions/1513293/python-clean-2-heaps-commented-code/ and https://leetcode.com/problems/stock-price-fluctuation/solutions/1513302/simple-solution-using-max-heap-and-min-heap/\n\n\n ```\n\nclass StockPrice {\n\n    Map<Integer, Container> map = new HashMap<>();\n    PriorityQueue<Container> max = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container2.price, container1.price);\n        }\n    });\n\n    PriorityQueue<Container> min = new PriorityQueue<>(new Comparator<Container>(){\n\n        @Override\n        public int compare(Container container1, Container container2) {\n            return Integer.compare(container1.price, container2.price);\n        }\n    });\n    int current = -1;\n    int latestTimeStamp = -1;\n    public StockPrice() {\n        \n    }\n    \n    public void update(int timestamp, int price) {\n        if(timestamp>=latestTimeStamp) {\n            latestTimeStamp = timestamp;\n            current = price;\n        }\n        if(map.containsKey(timestamp)) {\n            Container container = map.get(timestamp);\n            container.price = price;\n            max.remove(container);\n            min.remove(container);\n            max.add(container);\n            min.add(container);\n        } else {\n            Container container = new Container(price, timestamp);\n            map.put(timestamp, container);\n            max.add(container);\n            min.add(container);\n        }\n    }\n    \n    public int current() {\n        return current;\n    }\n    \n    public int maximum() {\n        return max.peek().price;\n    }\n    \n    public int minimum() {\n        return min.peek().price;\n    }\n\n    public static class Container {\n        int price;\n        int timestamp;\n\n        public Container(int price, int timestamp) {\n            this.price = price;\n            this.timestamp = timestamp;\n        }\n    }\n}.\n\n```"
                    },
                    {
                        "username": "Irving09",
                        "content": "[@harshit_bangar](/harshit_bangar)\\n\\nYou cant just max.peek().price or min.peek().price, I had the same code and it turns out heapify doesnt get triggered for adding and removing.\\n\\n```\\nclass StockPrice {\\n\\n  class Record {\\n    int timestamp;\\n    int price;\\n    public Record(int timestamp, int price) {\\n      this.timestamp = timestamp;\\n      this.price = price;\\n    }\\n  }\\n\\n  private Map<Integer, Record> records;\\n  private Queue<Record> max;\\n  private Queue<Record> min;\\n  private int latestTimestamp;\\n\\n  public StockPrice() {\\n    records = new HashMap<>();\\n    max = new PriorityQueue<>((r1, r2) -> r2.price - r1.price);\\n    min = new PriorityQueue<>((r1, r2) -> r1.price - r2.price);\\n    latestTimestamp = 1;\\n  }\\n  \\n  public void update(int timestamp, int price) { // O(logn)\\n    if (records.containsKey(timestamp)) {\\n      records.get(timestamp).price = price;\\n    } else {\\n      Record record = new Record(timestamp, price);\\n      records.put(timestamp, record);\\n      max.offer(record);\\n      min.offer(record);\\n    }\\n\\n    max.offer(max.poll()); // didnt actually re-trigger heapify\\n    min.offer(min.poll()); // didnt actually re-trigger heapify\\n    latestTimestamp = Math.max(latestTimestamp, timestamp);\\n  }\\n  \\n  public int current() { // O(1)\\n    return records.get(latestTimestamp).price;\\n  }\\n  \\n  public int maximum() { // logn\\n    return max.peek().price;\\n  }\\n  \\n  public int minimum() { // logn\\n    return min.peek().price;\\n  }\\n}\\n\\n/**\\n* Your StockPrice object will be instantiated and called as such:\\n* StockPrice obj = new StockPrice();\\n* obj.update(timestamp,price);\\n* int param_2 = obj.current();\\n* int param_3 = obj.maximum();\\n* int param_4 = obj.minimum();\\n*/\\n```"
                    },
                    {
                        "username": "user1325DR",
                        "content": "what is wrong with this implementation : - \n--------------\nimport java.util.NavigableMap;\nclass StockPrice {\n    SortedSet timestamps;\n    Map<Integer, Integer> priceMap;\n    \n    int currPrice = -1;\n    int currTimestamp = -1;\n    \n    public StockPrice() {\n        timestamps = new TreeSet<>((a, b) -> priceMap.get(a) - priceMap.get(b));\n        priceMap = new HashMap<>();\n    }\n    \n    public void update(int timestamp, int price) {\n        if(priceMap.containsKey(timestamp))\n        {\n            timestamps.remove(timestamp);\n        }\n        priceMap.put(timestamp, price);\n        timestamps.add(timestamp);\n        if(timestamp >= currTimestamp)\n        {\n            currTimestamp = timestamp;\n            currPrice = price;\n        }\n    }\n    \n    public int current() {\n        return currPrice;\n    }\n    \n    public int maximum() {\n        return priceMap.get(timestamps.last());\n    }\n    \n    public int minimum() {\n        return priceMap.get(timestamps.first());\n    }\n}\n\n--------------"
                    },
                    {
                        "username": "vetty",
                        "content": "Same q"
                    },
                    {
                        "username": "vinayakprasad96",
                        "content": "#ff"
                    }
                ]
            }
        ]
    }
]