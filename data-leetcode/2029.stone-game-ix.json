[
    {
        "title": "Stone Game IX",
        "question_content": "Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array stones, where stones[i] is the value of the ith stone.\nAlice and Bob take turns, with Alice starting first. On each turn, the player may remove any stone from stones. The player who removes a stone loses if the sum of the values of all removed stones is divisible by 3. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).\nAssuming both players play optimally, return true if Alice wins and false if Bob wins.\n&nbsp;\nExample 1:\n\nInput: stones = [2,1]\nOutput: true\nExplanation:&nbsp;The game will be played as follows:\n- Turn 1: Alice can remove either stone.\n- Turn 2: Bob removes the remaining stone. \nThe sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.\n\nExample 2:\n\nInput: stones = [2]\nOutput: false\nExplanation:&nbsp;Alice will remove the only stone, and the sum of the values on the removed stones is 2. \nSince all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.\n\nExample 3:\n\nInput: stones = [5,1,2,4,3]\nOutput: false\nExplanation: Bob will always win. One possible way for Bob to win is shown below:\n- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\nAlice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.\n\n&nbsp;\nConstraints:\n\n\t1 <= stones.length <= 105\n\t1 <= stones[i] <= 104",
        "solutions": [
            {
                "id": 1500245,
                "title": "java-c-python-easy-and-concise-6-lines-o-n",
                "content": "# **Observation**\\nCount the frequency of mod3 = 0,1,2.\\n\\nFirstly, don\\'t consider the multiples of 3.\\nAlice starts with `mod3 = 1`, Alice and Bob have to pick 1,1,2,1,2... in order.\\nAlice starts with `mod3 = 2`, Alice and Bob have to pick 2,2,1,2,1... in order.\\n\\nIf Alice starts with 1, then Alice needs 1 and Bob needs 2.\\nIf 1 is much more than 2, then Bob is going to lose.\\n\\nSo if `cnt[0] == 0`, the result can be decided by Alice.\\n\\nThen, consider the number of multiples of 3.\\nIf `cnt[0]` is even,\\nBob picks a 3, Alice can always picks one another.\\nthe result won\\'t be affected.\\n\\nIf `cnt[0]` is odd,\\nthe final result will be reversed,\\n(unless the case Bob win for all numbers consumed)\\n<br>\\n\\n#  Missing Case\\n[1,1,1,3] gave by @mittal582 and @qingqi_lei,\\nwhich can hack some solution.\\n<br>\\n\\n# **Explanation**\\nIf `cnt[1] == 0`, Alice needs to start with `mod3 = 2`,\\nIf `cnt[2] == 0`, Alice needs to start with `mod3 = 1`.\\nAlice can win if `max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0`,\\nfor example [1,1,1,3].\\n\\nIf `cnt[0] % 2 == 0`, easy case for Alice.\\nAlice can win in at leasy one of the two options, picking the less one.\\n\\nOtherwise `cnt[0] % 2 == 1`, this will reverse the result.\\nIf `abs(cnt[1] - cnt[2]) > 2`,\\nAlice will pick `mod3=2` if `mod3=2` is more\\nAlice will pick `mod3=1` if `mod3=1` is more\\nIf `abs(cnt[1] - cnt[2]) <= 2`,\\nAlice will lose for no number remaining.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public boolean stoneGameIX(int[] stones) {\\n        int[] cnt = new int[3];\\n        for (int a: stones)\\n            cnt[a % 3]++;\\n        if (Math.min(cnt[1], cnt[2]) == 0)\\n            return Math.max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0;\\n        return Math.abs(cnt[1] - cnt[2]) > 2 || cnt[0] % 2 == 0;\\n    }\\n```\\n**C++**\\n```cpp\\n    bool stoneGameIX(vector<int>& stones) {\\n        int cnt[3] = {};\\n        for (int a: stones)\\n            cnt[a % 3]++;\\n        if (min(cnt[1], cnt[2]) == 0)\\n            return max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0;\\n        return abs(cnt[1] - cnt[2]) > 2 || cnt[0] % 2 == 0;\\n    }\\n```\\n**Python**\\n```py\\n    def stoneGameIX(self, stones):\\n        cnt = collections.Counter(a % 3 for a in stones)\\n        if min(cnt[1], cnt[2]) == 0:\\n            return max(cnt[1], cnt[2]) > 2 and cnt[0] % 2 > 0\\n        return abs(cnt[1] - cnt[2]) > 2 or cnt[0] % 2 == 0\\n```\\n\\n# **Solution 2**\\n@ye15 help improving the conditions check\\n**Java**\\n```java\\n    public boolean stoneGameIX(int[] stones) {\\n        int[] cnt = new int[3];\\n        for (int a : stones)\\n            cnt[a % 3]++;\\n        if (cnt[0] % 2 == 0)\\n            return cnt[1] > 0 && cnt[2] > 0;\\n        return Math.abs(cnt[1] - cnt[2]) > 2;\\n    }\\n```\\n**C++**\\n```cpp\\n    bool stoneGameIX(vector<int>& stones) {\\n        int cnt[3] = {};\\n        for (int a: stones)\\n            cnt[a % 3]++;\\n        if (cnt[0] % 2 == 0)\\n            return cnt[1] > 0 && cnt[2] > 0;\\n        return abs(cnt[1] - cnt[2]) > 2;\\n    }\\n```\\n**Python**\\n```py\\n    def stoneGameIX(self, stones):\\n        cnt = collections.Counter(a % 3 for a in stones)\\n        if cnt[0] % 2 == 0:\\n            return cnt[1] > 0 and cnt[2] > 0\\n        return abs(cnt[1] - cnt[2]) > 2\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean stoneGameIX(int[] stones) {\\n        int[] cnt = new int[3];\\n        for (int a: stones)\\n            cnt[a % 3]++;\\n        if (Math.min(cnt[1], cnt[2]) == 0)\\n            return Math.max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0;\\n        return Math.abs(cnt[1] - cnt[2]) > 2 || cnt[0] % 2 == 0;\\n    }\\n```\n```cpp\\n    bool stoneGameIX(vector<int>& stones) {\\n        int cnt[3] = {};\\n        for (int a: stones)\\n            cnt[a % 3]++;\\n        if (min(cnt[1], cnt[2]) == 0)\\n            return max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0;\\n        return abs(cnt[1] - cnt[2]) > 2 || cnt[0] % 2 == 0;\\n    }\\n```\n```py\\n    def stoneGameIX(self, stones):\\n        cnt = collections.Counter(a % 3 for a in stones)\\n        if min(cnt[1], cnt[2]) == 0:\\n            return max(cnt[1], cnt[2]) > 2 and cnt[0] % 2 > 0\\n        return abs(cnt[1] - cnt[2]) > 2 or cnt[0] % 2 == 0\\n```\n```java\\n    public boolean stoneGameIX(int[] stones) {\\n        int[] cnt = new int[3];\\n        for (int a : stones)\\n            cnt[a % 3]++;\\n        if (cnt[0] % 2 == 0)\\n            return cnt[1] > 0 && cnt[2] > 0;\\n        return Math.abs(cnt[1] - cnt[2]) > 2;\\n    }\\n```\n```cpp\\n    bool stoneGameIX(vector<int>& stones) {\\n        int cnt[3] = {};\\n        for (int a: stones)\\n            cnt[a % 3]++;\\n        if (cnt[0] % 2 == 0)\\n            return cnt[1] > 0 && cnt[2] > 0;\\n        return abs(cnt[1] - cnt[2]) > 2;\\n    }\\n```\n```py\\n    def stoneGameIX(self, stones):\\n        cnt = collections.Counter(a % 3 for a in stones)\\n        if cnt[0] % 2 == 0:\\n            return cnt[1] > 0 and cnt[2] > 0\\n        return abs(cnt[1] - cnt[2]) > 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1500243,
                "title": "simple-greedy",
                "content": "Start with any element with mod3  equal to 1 or 2 and greedily take elements that do not form sum divisible by 3.\\nThe crux is that we can take elements in any order as long as they don\\'t from equal number of 1\\'s and 2\\'s in the prefix.\\n\\n```\\nclass Solution\\n{\\n  public:\\n    bool get(vector<int> mod, int n, int k)\\n    {\\n        if (mod[k] < 1)\\n            return false;\\n        mod[k]--;\\n        int sum = k;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (mod[1] && (sum + 1) % 3 != 0)\\n                mod[1]--, sum += 1;\\n            else if (mod[2] && (sum + 2) % 3 != 0)\\n                mod[2]--, sum += 2;\\n            else if (mod[0] > 0 && (sum) % 3 != 0)\\n                mod[0]--;\\n            else\\n                return i & 1;\\n        }\\n        return false;\\n    }\\n\\n    bool stoneGameIX(vector<int> &v)\\n    {\\n        vector<int> mod(3);\\n        int n = v.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mod[v[i] % 3]++;\\n        }\\n        return get(mod, n, 2) || get(mod, n, 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n  public:\\n    bool get(vector<int> mod, int n, int k)\\n    {\\n        if (mod[k] < 1)\\n            return false;\\n        mod[k]--;\\n        int sum = k;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (mod[1] && (sum + 1) % 3 != 0)\\n                mod[1]--, sum += 1;\\n            else if (mod[2] && (sum + 2) % 3 != 0)\\n                mod[2]--, sum += 2;\\n            else if (mod[0] > 0 && (sum) % 3 != 0)\\n                mod[0]--;\\n            else\\n                return i & 1;\\n        }\\n        return false;\\n    }\\n\\n    bool stoneGameIX(vector<int> &v)\\n    {\\n        vector<int> mod(3);\\n        int n = v.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mod[v[i] % 3]++;\\n        }\\n        return get(mod, n, 2) || get(mod, n, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500274,
                "title": "c-o-n-short-clean-explained",
                "content": "This involved some massive case-work! However, the final code is clean. Here\\'s some key observations that can help :\\n\\n- Reduce all numbers to remainders of 3. (4 + 1) % 3 has the same effect as ((4 % 3) + (1 % 3)) % 3. This makes comparison much easier as it boils down to counts of 0\\'s, 1\\'s and 2\\'s.\\n- Realize that a multiple of 3 (i.e. mod value of 0) does not change the net sum. HOWEVER, it can be used to flip the winner - but only if it\\'s an odd number of times. This is because, if it\\'s an even number of times, each player can play it equally and it won\\'t make any difference to the outcome. However, with an odd number of occurances, it can flip the winner.\\n- If there are no 1\\'s (i.e. no 1, 4, 7, etc.) then all you have are 2\\'s\\n\\t- If there\\'s less than three 2\\'s, Bob always wins (since they both play one or two 2\\'s and eventually the game runs out while never meeting a multiple of 3). \\n\\t- If there are three or more 2\\'s, then Bob wins as well, UNLESS there\\'s a flip available.\\n- Same as above if there are no 2\\'s.\\n- Next, if the gap between 1\\'s and 2\\'s exceeds 2, then Alice always wins. This is because Alice plays the minority number first. Then Bob is forced to play the same minority number, then Alice plays the majority number, until that number is exhausted (on Bob\\'s turn). If there is a flip available, then Alice plays the majority number first, leading to the same outcome.\\n- Finally, if none of the above work, Alice will be the default winner, unless there is a flip involved.\\n- Phew. I think the code\\'s a lot shorter than this explanation.\\n\\n```\\n#define ALICE true\\n#define BOB false\\n\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        vector<int> a(3, 0);\\n        for (auto &x : stones)\\n            a[x % 3]++;\\n        bool flip = (a[0] % 2 > 0);\\n        if (!a[1])\\n            return (a[2] < 3 ? BOB : flip);\\n        if (!a[2])\\n            return (a[1] < 3 ? BOB : flip);\\n        if (abs(a[1] - a[2]) > 2)\\n            return ALICE;\\n        return !flip;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ALICE true\\n#define BOB false\\n\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        vector<int> a(3, 0);\\n        for (auto &x : stones)\\n            a[x % 3]++;\\n        bool flip = (a[0] % 2 > 0);\\n        if (!a[1])\\n            return (a[2] < 3 ? BOB : flip);\\n        if (!a[2])\\n            return (a[1] < 3 ? BOB : flip);\\n        if (abs(a[1] - a[2]) > 2)\\n            return ALICE;\\n        return !flip;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500207,
                "title": "simple-python-optimal-strategy-explained",
                "content": "Denote n0 as the number of stones that have % 3 == 0\\nDenote n1 as the number of stones that have % 3 == 1\\nDenote n2 as the number of stones that have % 3 == 2\\nConsider the  simple case n0 == 0,\\nAlice could win by taking the from the smaller number of n1 and n2, Bob would be forced to make a losing move. If n1 == n2, Alice also wins because the last choice from Bob would make sum % 3 == 0\\n\\nFor n0 % 2 == 0, the zeros act as \"buffers\", prolonging the game. Knowing from the case n0 == 0, Bob will lose if he doesn\\'t(cannot) pick n0, so he will pick n0, but alice can counter that by also picking n0. Since n0 % 2 == 0, Alice still wins, so one may solve this case as if n0 == 0.\\n\\nFor n0 % 2 == 1: Alice may start from picking the larger pile of (n1,n2). by doing so, she forces Bob to make the losing move. The order of taking stones from n0 does not matter at all, the winning/losing scenario could be imagined by taking n1 or n2 first, and when one pile of (n1,n2) is depleted, and the other one is the losing move,  start taking stones from n0 until the game is resolved.\\n\\nNow we only need to deal with the cases where the stones are depleted, in which case Bob wins instead. For n0 % 2 == 0, if the smaller pile of (n1,n2) = 0, then Alice would be forced to choose from the larger pile, she would lose instead. For n0 % 2 == 1 if the difference between n1 and n2 is not greater than two, the stones would be depleted first, so she also loses. (Ex : n0 = 3, n1 = 3, n2 = 1, A1 -> B1 -> A2 -> B1 -> A0 -> B0 -> A0,  If there is at least one more n1, B1 would be forced and Alice wins, else Alice loses)\\n\\n```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        from collections import Counter\\n        mod = Counter([x%3 for x in stones])\\n        if mod[0] % 2 == 0:\\n            if min(mod[1],mod[2]) == 0:\\n                return False\\n            else:\\n                return True\\n        else:\\n            if abs(mod[1] - mod[2]) <= 2:\\n                return False\\n            return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        from collections import Counter\\n        mod = Counter([x%3 for x in stones])\\n        if mod[0] % 2 == 0:\\n            if min(mod[1],mod[2]) == 0:\\n                return False\\n            else:\\n                return True\\n        else:\\n            if abs(mod[1] - mod[2]) <= 2:\\n                return False\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500177,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n        int zero = 0, one = 0, two = 0;\\n        for(int i: stones) {\\n            if(i %3 == 0) zero++;\\n            else if(i%3 == 1) one ++;\\n            else if(i%3 == 2) two ++;\\n        }\\n        if(one == 0 && two == 0) return false;\\n        int max = Math.max(one, two), min = Math.min(one, two);\\n        if(zero%2 == 0){\\n            if(min == 0) return false;\\n            return true;\\n        }\\n        if(zero%2 == 1){\\n            if(max -2 > min) return true;\\n            return false;\\n        }\\n        return false;\\n        \\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n        int zero = 0, one = 0, two = 0;\\n        for(int i: stones) {\\n            if(i %3 == 0) zero++;\\n            else if(i%3 == 1) one ++;\\n            else if(i%3 == 2) two ++;\\n        }\\n        if(one == 0 && two == 0) return false;\\n        int max = Math.max(one, two), min = Math.min(one, two);\\n        if(zero%2 == 0){\\n            if(min == 0) return false;\\n            return true;\\n        }\\n        if(zero%2 == 1){\\n            if(max -2 > min) return true;\\n            return false;\\n        }\\n        return false;\\n        \\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502086,
                "title": "dfs-thought-process",
                "content": "We need to count remainders of `mod 3` instead of working with input numbers directly. \\n\\nHaving those counts, we could come up with some formula, but I could not see it at that time. \\n\\nSo instead, I went for a generic DFS approach. We start with the counts of numbers with remainders 0, 1, and 2, and track the remainder of the removed stones in `r`.\\n- If the remainder `r` is zero (divisible by 3), the current players win so the player who made the last turn loses.\\n- If we run out of stones, Bob wins - we need to track who\\'s turn it is (`isAlice`).\\n- Otherwise, we see if picking 0, 1 or 2 remainder would give us a win.\\n\\nThis approach initially gave me TLE, and then I realized that, if Alice picks `3`, and Bob responds by picking `6`, it does not affect the remainder of the removed pile. So we should only care whether the count of numbers with `mod 3 == 0` is even or odd. That was sufficient to get this solution AC.\\n\\n**C++**\\n```cpp\\nbool dfs(int r0, int r1, int r2, int r, bool isAlice) {\\n    if (r == 0 || r0 < 0 || r1 < 0 || r2 < 0)\\n        return true;\\n    if (r0 == 0 && r1 == 0 && r2 == 0)\\n        return !isAlice;\\n    return !dfs(r0 - 1, r1, r2, r, !isAlice) \\n        || !dfs(r0, r1 - 1, r2, (r + 1) % 3, !isAlice) \\n        || !dfs(r0, r1, r2 - 1, (r + 2) % 3, !isAlice);\\n}\\nbool stoneGameIX(vector<int>& stones) {\\n    int r[3] = {};\\n    for (auto s : stones)\\n        ++r[s % 3];\\n    return dfs(r[0] % 2, r[1], r[2], 3, true);\\n}\\n```\\n**Update**\\nYou can still get TLE because the count of `r1` and `r2` could be hight. Using the same logic as we did for `r0`, players can keep picking `1` after `2`, and get the same remainder. So, we can reduce both counts by the minimum of two.\\n\\n```cpp\\nbool stoneGameIX(vector<int>& stones) {\\n    int r[3] = {};\\n    for (auto s : stones)\\n        ++r[s % 3];\\n    int min12 = min(r[1], r[2]) - (min(r[1], r[2]) == 0 ? 0 : 1) ;\\n    return dfs(r[0] % 2, r[1] - min12, r[2] - min12, 3, true);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool dfs(int r0, int r1, int r2, int r, bool isAlice) {\\n    if (r == 0 || r0 < 0 || r1 < 0 || r2 < 0)\\n        return true;\\n    if (r0 == 0 && r1 == 0 && r2 == 0)\\n        return !isAlice;\\n    return !dfs(r0 - 1, r1, r2, r, !isAlice) \\n        || !dfs(r0, r1 - 1, r2, (r + 1) % 3, !isAlice) \\n        || !dfs(r0, r1, r2 - 1, (r + 2) % 3, !isAlice);\\n}\\nbool stoneGameIX(vector<int>& stones) {\\n    int r[3] = {};\\n    for (auto s : stones)\\n        ++r[s % 3];\\n    return dfs(r[0] % 2, r[1], r[2], 3, true);\\n}\\n```\n```cpp\\nbool stoneGameIX(vector<int>& stones) {\\n    int r[3] = {};\\n    for (auto s : stones)\\n        ++r[s % 3];\\n    int min12 = min(r[1], r[2]) - (min(r[1], r[2]) == 0 ? 0 : 1) ;\\n    return dfs(r[0] % 2, r[1] - min12, r[2] - min12, 3, true);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502340,
                "title": "code-very-detailed-explanation",
                "content": "#### Preliminaries\\n**Observation 1:** We only need to consider the stones modulo 3. Taking a stone that is 4, for example, is practically equivalent to taking a stone that is 1.\\n\\n**Observation 2:** The ordering of the stones don\\'t matter. That is, stones {1, 2, 2} is effectively the same as stones {2, 1, 2}.\\n\\n**Consequence of Observation 1 and 2:** We only need to consider the number of stones that are 0, 1, and 2 mod 3. That will give enough information. The rest of the information is irrelevant.\\n\\n#### Part 1: Only Ones and Twos\\nNow suppose that we simplify the problem a little bit and only consider the case in which no element is 0 modulo 3. That is, we have `x` stones that are 1 modulo 3 and `y` stones that are 2 modulo 3. Obviously, if either `x = 0` or `y = 0`, then Bob wins: nobody will pick something, which causes them to lose, and the game will end when all stones are taken (this by default means that Bob wins). \\n\\nWhat about the more interesting case when `x!=0` and `y!=0`? Then, suppose Alice takes a stone that is 1 modulo 3. Bob cannot take a stone that is 2 modulo 3 and hence must take a stone that is likewise 1 mod 3 (provided that it exists). After that, Alice takes stone 2, Bob takes stone 1, Alice takes stone 2, etc. The order of the stones taken looks like this: `112121212...`. On the other hand, if Alice picks a 2 first, then the order of the stones looks like this: `2212121212...`. It\\'s not hard to show (or convice yourself) that in at least one of these cases, Alice will win. A simple argument is as follows: if there are more twoes than ones, then Alice should start by placing a one. If there are more ones than twoes, Alice should start by placing a 2.\\n\\n#### Part 2: Even Number of Zeroes\\nWhat happens if there are an even number of zeroes? In such a case, it doesn\\'t really matter actually! Suppose that had there been no zeroes, Alice would\\'ve won. Then, with an even number of zeroes, Alice can still win (her strategy is to keep doing her winning strategy, but whenever Bob places a zero, she also places a zero). Likewise, if Bob would\\'ve won with an even number of zeroes (i.e. there are no ones or twos), then Bob will still win because the game will terminate with no stones to pick from.\\n\\nSo, if there are an even number of zeroes but some ones and twos, Alice wins. Otherwise, if there are an even number of zeroes, but no ones or twos, then Bob wins.\\n\\n#### Part 3: Odd Number of Zeroes\\nThe way I see the zeroes is as kind of passing the turn. You\\'re not changing the result of the game, but you are making the other person move. So let\\'s remove the zeroes from the game for a minute and see what happens. It looks like `112121212...` or `2212121212...`, as described before. In particular, let Alice play the majority number. Whenver Bob plays zero, she plays a zero. If Bob plays a nonzero number, then she plays a nonzero number. Eventually, this means that Alice can win but IF ONLY IF `abs(x - y) >= 3`. This may seem really arbitrary (you can convince yourself it\\'s true with sample data, though). Even better, you can convince yourself with induction and dynamic programming.\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        int count[3];\\n        count[0] = count[1] = count[2] = 0;\\n        for(int i = 0; i < stones.size(); i++) {\\n            stones[i] %= 3;\\n            count[stones[i]]++;\\n        }\\n        if (count[0] % 2 == 0) {\\n            return (count[1] != 0 && count[2] != 0);\\n        } else {\\n            return (abs(count[2] - count[1]) >= 3);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        int count[3];\\n        count[0] = count[1] = count[2] = 0;\\n        for(int i = 0; i < stones.size(); i++) {\\n            stones[i] %= 3;\\n            count[stones[i]]++;\\n        }\\n        if (count[0] % 2 == 0) {\\n            return (count[1] != 0 && count[2] != 0);\\n        } else {\\n            return (abs(count[2] - count[1]) >= 3);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501975,
                "title": "java-o-n-simple-mathematical-solution-explained",
                "content": "Using examples to generalize and understand the best path is the best way to reach this solution.\\nTime complexity is O(n) and space complexity is O(1).\\n```\\nclass Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n        Map<Integer, Integer> div3 = new HashMap<>();\\n        div3.put(0, 0);\\n        div3.put(1, 0);\\n        div3.put(2, 0);\\n        \\n        for(int stone : stones){\\n            div3.put(stone%3, div3.get(stone%3)+1);\\n        }\\n\\t\\t// the count of 3\\'s don\\'t matter, only whether it is even or odd\\n        div3.put(0, div3.get(0)%2);\\n        \\n        \\n        if(div3.get(1) == 0 && div3.get(2) == 0){\\n            return false;\\n        }\\n        \\n        int smaller = Math.min(div3.get(1), div3.get(2));\\n        int larger = Math.max(div3.get(2), div3.get(1));\\n\\t\\t// the combinations of 1\\'s and 2\\'s will work with each other in a complementary way. \\n\\t\\t// A pair of 1 and 2 makes modulo 3 to be 0\\n\\t\\t// Three counts of 1 or 2 makes modulo 3 to be 0\\n\\t\\t// so, we need only relative counts\\n        \\n        // if there are even 3\\'s, then bob can\\'t reverse alice\\'s win\\n        // so, if all three digits chosen are the same then bob wins, but if there is another option then alice wins\\n        // [1,2,2,2] -> alice picks 1 and wins\\n        // [1,3,3,2] -> alice picks 1 or two and wins\\n        // [2,2,2] -> alice has to pick the third 2 and loses\\n\\n        if(div3.get(0) == 0){\\n            return smaller != 0;\\n        }\\n        \\n        // all cases now have odd number of 3\\'s, so result can be reversed\\n        \\n        // [1,1,1,1,3] -> 1,1,3,1 picked or 1,3,1,1 picked means alice wins\\n        // similar for 2 because the other number doesn\\'t exist to make a %3 pair\\n        \\n        // if the difference of number counts is more than 2 then alice can always force bob\\n        // [3,1,2,2,2] -> \\n\\t\\t// [3,1,2,2,2,2] ->\\n        if(larger > smaller + 2){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n**Please upvote if you likes the solution.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n        Map<Integer, Integer> div3 = new HashMap<>();\\n        div3.put(0, 0);\\n        div3.put(1, 0);\\n        div3.put(2, 0);\\n        \\n        for(int stone : stones){\\n            div3.put(stone%3, div3.get(stone%3)+1);\\n        }\\n\\t\\t// the count of 3\\'s don\\'t matter, only whether it is even or odd\\n        div3.put(0, div3.get(0)%2);\\n        \\n        \\n        if(div3.get(1) == 0 && div3.get(2) == 0){\\n            return false;\\n        }\\n        \\n        int smaller = Math.min(div3.get(1), div3.get(2));\\n        int larger = Math.max(div3.get(2), div3.get(1));\\n\\t\\t// the combinations of 1\\'s and 2\\'s will work with each other in a complementary way. \\n\\t\\t// A pair of 1 and 2 makes modulo 3 to be 0\\n\\t\\t// Three counts of 1 or 2 makes modulo 3 to be 0\\n\\t\\t// so, we need only relative counts\\n        \\n        // if there are even 3\\'s, then bob can\\'t reverse alice\\'s win\\n        // so, if all three digits chosen are the same then bob wins, but if there is another option then alice wins\\n        // [1,2,2,2] -> alice picks 1 and wins\\n        // [1,3,3,2] -> alice picks 1 or two and wins\\n        // [2,2,2] -> alice has to pick the third 2 and loses\\n\\n        if(div3.get(0) == 0){\\n            return smaller != 0;\\n        }\\n        \\n        // all cases now have odd number of 3\\'s, so result can be reversed\\n        \\n        // [1,1,1,1,3] -> 1,1,3,1 picked or 1,3,1,1 picked means alice wins\\n        // similar for 2 because the other number doesn\\'t exist to make a %3 pair\\n        \\n        // if the difference of number counts is more than 2 then alice can always force bob\\n        // [3,1,2,2,2] -> \\n\\t\\t// [3,1,2,2,2,2] ->\\n        if(larger > smaller + 2){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500214,
                "title": "4-line-java-solution",
                "content": "```Java\\npublic boolean stoneGameIX(int[] stones) {\\n\\tint[] count = new int[3];\\n\\tfor (int stone : stones) count[stone % 3]++;\\n\\tif (count[0] % 2 == 0 && (count[1] == 0 || count[2] == 0)) return false;\\n\\treturn count[0] % 2 == 1 && Math.abs(count[1] - count[2]) < 3 ? false : true;\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\npublic boolean stoneGameIX(int[] stones) {\\n\\tint[] count = new int[3];\\n\\tfor (int stone : stones) count[stone % 3]++;\\n\\tif (count[0] % 2 == 0 && (count[1] == 0 || count[2] == 0)) return false;\\n\\treturn count[0] % 2 == 1 && Math.abs(count[1] - count[2]) < 3 ? false : true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500189,
                "title": "python-3-simulation-with-remainders",
                "content": "Only divisibility is important. We can substitute each number```x``` with ```x%3```.\\n```stones=[x%3 for x in stones]```\\n\\nThen only numbers ```0```,```1```, and ```2``` would be in the array ```stones```.\\nWe can count each remainder.\\nWe use array ```remainders``` as a counter.\\nIt means: array ```stones``` contains ```remainders[0]``` numbers divisible by 3.\\n\\nStrategy ideas:\\n0 doesn\\'t change divisibility\\ntake 1 if actualRemovedStones remainder is 1\\ntake 2 if actualRemovedStones remainder is 2\\n\\nAlice starting first.\\nIf Alice starts with 1, Bob can\\'t take 2, he would be lost (1+2 is 3).\\nIf Alice starts with 2, Bob can\\'t take 1, he would be lost (2+1 is 3).\\n\\nWe are simulating the game with remainders only.\\n```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        remainders=[0]*3\\n        for x in stones:\\n            remainders[x%3]+=1\\n        \\n        def play(s,r0,r1,r2,Alice):\\n            if not sum([r0,r1,r2]):\\n                return False\\n            if s==1:\\n                if r1:\\n                    return play(2,r0,r1-1,r2,not Alice)\\n                elif r0:\\n                    return play(1,r0-1,r1,r2,not Alice)\\n                else:\\n                    return not Alice\\n            elif s==2:\\n                if r2:\\n                    return play(1,r0,r1,r2-1,not Alice)\\n                elif r0:\\n                    return play(2,r0-1,r1,r2,not Alice)\\n                else:\\n                    return not Alice\\n         \\n        r0,r1,r2 = remainders\\n        return r1 and play(1,r0,r1-1,r2,False) or r2 and play(2,r0,r1,r2-1,False)\\n```",
                "solutionTags": [],
                "code": "```x```\n```x%3```\n```stones=[x%3 for x in stones]```\n```0```\n```1```\n```2```\n```stones```\n```remainders```\n```stones```\n```remainders[0]```\n```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        remainders=[0]*3\\n        for x in stones:\\n            remainders[x%3]+=1\\n        \\n        def play(s,r0,r1,r2,Alice):\\n            if not sum([r0,r1,r2]):\\n                return False\\n            if s==1:\\n                if r1:\\n                    return play(2,r0,r1-1,r2,not Alice)\\n                elif r0:\\n                    return play(1,r0-1,r1,r2,not Alice)\\n                else:\\n                    return not Alice\\n            elif s==2:\\n                if r2:\\n                    return play(1,r0,r1,r2-1,not Alice)\\n                elif r0:\\n                    return play(2,r0-1,r1,r2,not Alice)\\n                else:\\n                    return not Alice\\n         \\n        r0,r1,r2 = remainders\\n        return r1 and play(1,r0,r1-1,r2,False) or r2 and play(2,r0,r1,r2-1,False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500459,
                "title": "c-o-n-comments",
                "content": "**C++**\\n```\\nclass Solution {\\n#define ALICE true\\n#define BOB false\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        int n = stones.size();\\n        \\n        //Counting all the frequency of the remainders\\n        int r0 = 0, r1 = 0, r2 = 0;\\n        for(int i = 0; i < n ; i++) {\\n            if(stones[i] % 3 == 0) r0++;\\n            if(stones[i] % 3 == 1) r1++;\\n            if(stones[i] % 3 == 2) r2++;\\n        }\\n        \\n        //Condition when their is no remainder of either 1 or 2\\n        if(min(r1,r2) == 0) {\\n            if(max(r1,r2) > 2 and r0 % 2 > 0) return ALICE;\\n            else return BOB;\\n        }\\n        \\n        //when their is more than 2 pairs of remainder 1 and 2\\n        if(abs(r1- r2) > 2) return ALICE;\\n        \\n        //when their is even number of 3 multiples \\n        if(r0 % 2 == 0) return ALICE;\\n        \\n        //In any other case Bob will win always\\n        return BOB;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define ALICE true\\n#define BOB false\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        int n = stones.size();\\n        \\n        //Counting all the frequency of the remainders\\n        int r0 = 0, r1 = 0, r2 = 0;\\n        for(int i = 0; i < n ; i++) {\\n            if(stones[i] % 3 == 0) r0++;\\n            if(stones[i] % 3 == 1) r1++;\\n            if(stones[i] % 3 == 2) r2++;\\n        }\\n        \\n        //Condition when their is no remainder of either 1 or 2\\n        if(min(r1,r2) == 0) {\\n            if(max(r1,r2) > 2 and r0 % 2 > 0) return ALICE;\\n            else return BOB;\\n        }\\n        \\n        //when their is more than 2 pairs of remainder 1 and 2\\n        if(abs(r1- r2) > 2) return ALICE;\\n        \\n        //when their is even number of 3 multiples \\n        if(r0 % 2 == 0) return ALICE;\\n        \\n        //In any other case Bob will win always\\n        return BOB;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500190,
                "title": "observation-based-solution-c-o-n",
                "content": "The important thing to observe is how can a player play optimally.\\nlet\\'s take the count of stones with remainder(when divided by 3) 0 , 1 & 2 .\\n\\ni) first player can never take a stone whose remainder is 0\\nii) so to start the game Alice can take either 1 remainder stone or 2 remainder stone and that\\'s the only thing that Alice has control over or is needed to find our answer\\niii) after first stone with non 0 remainder is taken any 0 remainder stone can be taken that will be optimal.\\n\\nNow , the question is how to takes non zero remainder stones optimally ?\\nThere is only 1 way of doing it. \\nFirst take any two same non zero remainder stones then after it take 0 remainder and 1 remainder stones alternatively\\n\\nSo, we just have to observe that if starting with either of 1 remainder stone or 2 remainder stone is it possible for Alice to win and if yes return true otherwise return false;\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& s) {\\n        int cnt_rem_0,cnt_rem_1,cnt_rem_2;\\n        cnt_rem_1=cnt_rem_0=cnt_rem_2=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]%3==0)cnt_rem_0++;\\n            else if(s[i]%3==1)cnt_rem_1++;\\n            else cnt_rem_2++;\\n        }\\n        if(cnt_rem_1==0 && cnt_rem_2==0){\\n            return false;\\n        }\\n        else{\\n            int max_rem_cnt,min_rem_cnt;\\n            int ans=0;\\n            max_rem_cnt=max(cnt_rem_1,cnt_rem_2);\\n            min_rem_cnt=min(cnt_rem_1,cnt_rem_2);\\n            \\n            if(max_rem_cnt==1){\\n              ans= cnt_rem_0+1;\\n                if(ans%2==0 || (ans%2==1 && ans==n))return false;\\n                else return true;\\n            }\\n            else{\\n                if(min_rem_cnt>=2 && (min_rem_cnt+ min_rem_cnt-1 +cnt_rem_0)%2==1){\\n                    return true;\\n                }\\n                else if(min_rem_cnt==1 && (min_rem_cnt+cnt_rem_0)%2==1 && min_rem_cnt+cnt_rem_0!= n)return true;\\n                else{\\n                    if(max_rem_cnt==min_rem_cnt){\\n                        if( (max_rem_cnt+min_rem_cnt-1+cnt_rem_0)%2==1)return true;\\n                        else return false;\\n                    }\\n                    else if(max_rem_cnt-min_rem_cnt==1){\\n                        if((max_rem_cnt+min_rem_cnt+cnt_rem_0)%2==1 && (max_rem_cnt+min_rem_cnt+cnt_rem_0)!=n)return true;\\n                        else return false;\\n                    }\\n                    else{\\n                        if((2*min_rem_cnt +2 +cnt_rem_0)%2==1 && (2*min_rem_cnt+2+cnt_rem_0)!=n)return true;\\n                        else return false;\\n                    }\\n                }\\n                    \\n                }\\n            }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& s) {\\n        int cnt_rem_0,cnt_rem_1,cnt_rem_2;\\n        cnt_rem_1=cnt_rem_0=cnt_rem_2=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]%3==0)cnt_rem_0++;\\n            else if(s[i]%3==1)cnt_rem_1++;\\n            else cnt_rem_2++;\\n        }\\n        if(cnt_rem_1==0 && cnt_rem_2==0){\\n            return false;\\n        }\\n        else{\\n            int max_rem_cnt,min_rem_cnt;\\n            int ans=0;\\n            max_rem_cnt=max(cnt_rem_1,cnt_rem_2);\\n            min_rem_cnt=min(cnt_rem_1,cnt_rem_2);\\n            \\n            if(max_rem_cnt==1){\\n              ans= cnt_rem_0+1;\\n                if(ans%2==0 || (ans%2==1 && ans==n))return false;\\n                else return true;\\n            }\\n            else{\\n                if(min_rem_cnt>=2 && (min_rem_cnt+ min_rem_cnt-1 +cnt_rem_0)%2==1){\\n                    return true;\\n                }\\n                else if(min_rem_cnt==1 && (min_rem_cnt+cnt_rem_0)%2==1 && min_rem_cnt+cnt_rem_0!= n)return true;\\n                else{\\n                    if(max_rem_cnt==min_rem_cnt){\\n                        if( (max_rem_cnt+min_rem_cnt-1+cnt_rem_0)%2==1)return true;\\n                        else return false;\\n                    }\\n                    else if(max_rem_cnt-min_rem_cnt==1){\\n                        if((max_rem_cnt+min_rem_cnt+cnt_rem_0)%2==1 && (max_rem_cnt+min_rem_cnt+cnt_rem_0)!=n)return true;\\n                        else return false;\\n                    }\\n                    else{\\n                        if((2*min_rem_cnt +2 +cnt_rem_0)%2==1 && (2*min_rem_cnt+2+cnt_rem_0)!=n)return true;\\n                        else return false;\\n                    }\\n                }\\n                    \\n                }\\n            }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500343,
                "title": "python3-freq-table",
                "content": "**Intuition**\\nHere, the specific numbers don\\'t matter. Only the modulos do. \\nIn order for Alice to win, the sequence would be like \\n1) 1(12)(12)...(12)2 with even number of 0\\'s between first 1 and final 2\\n2) 1(12)(12)...(12)11 with odd number of 0\\'s between first 1 and final 1\\n\\nwhere 1\\'s and 2\\'s are interchangable due to symmetry. So the strategy is \\n1) if there are even number of 0\\'s, Alice would choose 1 or 2 whoever is less or equal frequent as long as they both exist. Without loss of generality, let\\'s say 1 is less frequent. In this case, it is guranteed to be Bob\\'s turn to place the last number 2 when they run out of 1\\'s. \\n2) if there are odd number of 0\\'s, Alice would choose 1 or 2 whoever is more frequent. Let\\'s say 1 is more frequent in the input. In this case, Alice need three extra 1\\'s to win. Besides, it is not difficult to figure out that as long as there are three (or more) extra 1\\'s Alice will win. \\n\\n```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        freq = defaultdict(int)\\n        for x in stones: freq[x % 3] += 1\\n        \\n        if freq[0]%2 == 0: return freq[1] and freq[2]\\n        return abs(freq[1] - freq[2]) >= 3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        freq = defaultdict(int)\\n        for x in stones: freq[x % 3] += 1\\n        \\n        if freq[0]%2 == 0: return freq[1] and freq[2]\\n        return abs(freq[1] - freq[2]) >= 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501251,
                "title": "java-with-picture-optimal-solution-vs-simulation-w-memoization",
                "content": "Providing two solutions - the first one requiring specific insight into the game rules, while the second is a full simulation of game steps with memoization.\\n\\n**1. Optimal solution**\\nWe count the numbers with respect to modulo 3 in O(N), based on that we know the outcome in O(1).\\nSee picture to gain intuition:\\n- only parity of the count of 0 (mod 3) matters\\n- problem is symmetric with respect to 1 (mod 3)  and 2 (mod 3) numbers, so consider only count 1 >= count 2\\n- Alice needs three 1\\'s to form a full cycle 0 -> 1 -> 2 -> 0, on Bob\\'s turn\\n- consider two cases: a. count 2 == 0 and b. count 2 > 0  \\n```\\npublic boolean stoneGameIX(int[] stones) {\\n        int[] f= new int[3];\\n        for(int s:stones) ++f[s%3];\\n        // each pair of numbers divisible by 3 cancel each other out, so only parity count of such numbers matters\\n\\t\\tf[0]%= 2;  \\n        // assert f1>=f2, as problem is symmetric wrt. 1 and 2 (see picture below)\\n        if(f[2]>f[1]) { int t= f[1]; f[1]= f[2]; f[2]= t;}\\n\\t\\t// Alice wins only if sum (mod 3) comes back to 0 on Bob\\'s turn, that is:\\n\\t\\t// a) when there are no 2\\'s, Alice needs (an unmatched) break (0 = num divisible by 3) and count of 1\\'s of at least 3, or\\n\\t\\t// b) when there are 2\\'s (at most as many as 1\\'s), she wins when Bob can\\'t take (an unmatched) break (Alice plays 2 first in such case) \\n\\t\\t//     or the count of 1\\'s unmatched by 2\\'s is at least 3 (Alice plays 1 first)\\n        return f[2]==0 ? f[0]==1 && f[1]>=3 : f[0]==0 || f[1]-f[2]>=3;\\n    }\\n```\\t\\n![image](https://assets.leetcode.com/users/images/604f8a86-b041-4c09-a873-f7ca452640fe_1633273530.0525293.png)\\n\\n**2. Game simulation with memoization**\\nWe still need the basic piece of insight to avoid TLE - ignoring all but one (if the count f[0] is odd) numbers divisible by 3:  f[0]%= 2;\\n```\\nclass Solution {\\n    static int A= 0, B= 1;\\n    public boolean stoneGameIX(int[] stones) {\\n        int[] f= new int[3];\\n        for(int s:stones) ++f[s%3];\\n        f[0]%= 2;\\n        Map<Long, Boolean> memo= new HashMap<>();\\n        return f[1]>0 && sim(B, 1, f[0], f[1]-1, f[2], memo) || f[2]>0 && sim(B, 2, f[0], f[1], f[2]-1, memo);\\n    }\\n    \\n    long key(int AB, int sum, int f0, int f1, int f2){\\n        return (((AB*10+sum)*10+f0)*100000+f1)*100000+f2;\\n    }\\n\\n    boolean sim(int AB, int sum, int f0, int f1, int f2, Map<Long, Boolean> memo){\\n        if(sum==0) return AB==A;\\n        if(f0==0 && f1==0 && f2==0) return false;\\n        \\n\\t\\tlong memoKey= key(AB, sum, f0, f1, f2);\\n        Boolean memoAns= memo.get(memoKey);\\n        if(memoAns!=null) return memoAns;\\n        \\n\\t\\tboolean ans= f0>0 && sim(1-AB, sum, f0-1, f1, f2, memo)\\n            // playing optimally, we don\\'t play 1 unless sum!=2 or there is no other numbers (0 or 2) to play\\n            || (sum!=2 || f0==0 && f2==0) && f1>0 && sim(1-AB, (sum+1)%3, f0, f1-1, f2, memo)\\n            //  playing optimally, we don\\'t play 2 unless sum!=1 or there is no other numbers (0 or 1) to play\\n            || (sum!=1 || f0==0 && f1==0) && f2>0 && sim(1-AB, (sum+2)%3, f0, f1, f2-1, memo);\\n        \\n\\t\\tmemo.put(memoKey, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean stoneGameIX(int[] stones) {\\n        int[] f= new int[3];\\n        for(int s:stones) ++f[s%3];\\n        // each pair of numbers divisible by 3 cancel each other out, so only parity count of such numbers matters\\n\\t\\tf[0]%= 2;  \\n        // assert f1>=f2, as problem is symmetric wrt. 1 and 2 (see picture below)\\n        if(f[2]>f[1]) { int t= f[1]; f[1]= f[2]; f[2]= t;}\\n\\t\\t// Alice wins only if sum (mod 3) comes back to 0 on Bob\\'s turn, that is:\\n\\t\\t// a) when there are no 2\\'s, Alice needs (an unmatched) break (0 = num divisible by 3) and count of 1\\'s of at least 3, or\\n\\t\\t// b) when there are 2\\'s (at most as many as 1\\'s), she wins when Bob can\\'t take (an unmatched) break (Alice plays 2 first in such case) \\n\\t\\t//     or the count of 1\\'s unmatched by 2\\'s is at least 3 (Alice plays 1 first)\\n        return f[2]==0 ? f[0]==1 && f[1]>=3 : f[0]==0 || f[1]-f[2]>=3;\\n    }\\n```\n```\\nclass Solution {\\n    static int A= 0, B= 1;\\n    public boolean stoneGameIX(int[] stones) {\\n        int[] f= new int[3];\\n        for(int s:stones) ++f[s%3];\\n        f[0]%= 2;\\n        Map<Long, Boolean> memo= new HashMap<>();\\n        return f[1]>0 && sim(B, 1, f[0], f[1]-1, f[2], memo) || f[2]>0 && sim(B, 2, f[0], f[1], f[2]-1, memo);\\n    }\\n    \\n    long key(int AB, int sum, int f0, int f1, int f2){\\n        return (((AB*10+sum)*10+f0)*100000+f1)*100000+f2;\\n    }\\n\\n    boolean sim(int AB, int sum, int f0, int f1, int f2, Map<Long, Boolean> memo){\\n        if(sum==0) return AB==A;\\n        if(f0==0 && f1==0 && f2==0) return false;\\n        \\n\\t\\tlong memoKey= key(AB, sum, f0, f1, f2);\\n        Boolean memoAns= memo.get(memoKey);\\n        if(memoAns!=null) return memoAns;\\n        \\n\\t\\tboolean ans= f0>0 && sim(1-AB, sum, f0-1, f1, f2, memo)\\n            // playing optimally, we don\\'t play 1 unless sum!=2 or there is no other numbers (0 or 2) to play\\n            || (sum!=2 || f0==0 && f2==0) && f1>0 && sim(1-AB, (sum+1)%3, f0, f1-1, f2, memo)\\n            //  playing optimally, we don\\'t play 2 unless sum!=1 or there is no other numbers (0 or 1) to play\\n            || (sum!=1 || f0==0 && f1==0) && f2>0 && sim(1-AB, (sum+2)%3, f0, f1, f2-1, memo);\\n        \\n\\t\\tmemo.put(memoKey, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500519,
                "title": "python-explained-2-lines-1-pass-o-1-memory",
                "content": "Please feel free to ask questions or give suggestions. Upvote if you liked the solution.\\n\\n```\\ndef stoneGameIX(self, stones: List[int]) -> bool:\\n\\t\"\"\"\\n\\tStones can be of 3 types: ones with mod 0, ones with mod 1 and ones with mod 2\\n\\t\\n\\tCase 1: even number of 0s, they do nothing to change winner (can always be countered, so ignore)\\n\\tThen, Alice wins as long as both type 1 and type 2 stones are there (1 in mod and 2 in mod)\\n\\tLet a and b be the stone types with smaller and bigger counts respectively\\n\\tThen best moves in the game (ignoring 0s) are:       \\n\\t\\t\\t\\t\\t   Alice -> [a, b, b, b...]\\n\\t\\t\\t\\t\\t   Bob   -> [a, a, a, a...] or [b]\\n\\n\\tCase 2: odd number of 0s, 0s can flip winner at most once\\n\\tAlice starts with bigger pile and wins as long as the bigger pile is at least 3 larger than the smaller pile (abs(mod[1]-mod[2])>2)\\n\\t\"\"\"\\n\\n\\tmod = Counter(x%3 for x in stones)\\n\\n\\treturn abs(mod[1]-mod[2])>2 if mod[0]%2 else 1 in mod and 2 in mod\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef stoneGameIX(self, stones: List[int]) -> bool:\\n\\t\"\"\"\\n\\tStones can be of 3 types: ones with mod 0, ones with mod 1 and ones with mod 2\\n\\t\\n\\tCase 1: even number of 0s, they do nothing to change winner (can always be countered, so ignore)\\n\\tThen, Alice wins as long as both type 1 and type 2 stones are there (1 in mod and 2 in mod)\\n\\tLet a and b be the stone types with smaller and bigger counts respectively\\n\\tThen best moves in the game (ignoring 0s) are:       \\n\\t\\t\\t\\t\\t   Alice -> [a, b, b, b...]\\n\\t\\t\\t\\t\\t   Bob   -> [a, a, a, a...] or [b]\\n\\n\\tCase 2: odd number of 0s, 0s can flip winner at most once\\n\\tAlice starts with bigger pile and wins as long as the bigger pile is at least 3 larger than the smaller pile (abs(mod[1]-mod[2])>2)\\n\\t\"\"\"\\n\\n\\tmod = Counter(x%3 for x in stones)\\n\\n\\treturn abs(mod[1]-mod[2])>2 if mod[0]%2 else 1 in mod and 2 in mod\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1500302,
                "title": "simple-c-if-else",
                "content": "I simply consider all the possible cases and logically handle them using if and else statement\\nIf you have any doubt ask in comment section.\\t\\n\\t\\n\\t\\tbool stoneGameIX(vector<int>& stones) {\\n        int n=stones.size();\\n        int arr[3]={0};\\n        for(int i=0;i<n;i++)\\n            arr[stones[i]%3]++;\\n        if(arr[0]%2==1)\\n            if(abs(arr[1]-arr[2])>=3)return true;\\n            else return false;\\n        else\\n            if(arr[1]==0 || arr[2]==0)return false;\\n            else return true;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "I simply consider all the possible cases and logically handle them using if and else statement\\nIf you have any doubt ask in comment section.\\t\\n\\t\\n\\t\\tbool stoneGameIX(vector<int>& stones) {\\n        int n=stones.size();\\n        int arr[3]={0};\\n        for(int i=0;i<n;i++)\\n            arr[stones[i]%3]++;\\n        if(arr[0]%2==1)\\n            if(abs(arr[1]-arr[2])>=3)return true;\\n            else return false;\\n        else\\n            if(arr[1]==0 || arr[2]==0)return false;\\n            else return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1500291,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n        int zero=0, one=0, two=0;\\n        for (int s : stones) {\\n            if (s%3 == 0) zero++;\\n            if (s%3 == 1) one++;\\n            if (s%3 == 2) two++;\\n        }\\n        \\n        Map<String, Boolean> dp =  new HashMap<>();\\n        return helper(0, zero, one, two, 0, dp);\\n        \\n    }\\n    \\n    private boolean helper(int sum, int zero, int one, int two, int turn, Map<String, Boolean> dp) {\\n        // sum of removed stones is divisible by 3 for previous player, current player wins\\n        if (turn != 0 && sum % 3 == 0) return true;\\n\\n        if (zero == 0 && one == 0 && two == 0) {\\n            // no stones, bob wins\\n            return turn % 2 == 1;\\n        }\\n        String key = sum +\"|\"+zero%2+\"|\"+one%2+\"|\"+two%2;\\n        if (dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n        \\n        boolean r1 = true,r2=true, r3=true;\\n        if (zero > 0) {\\n            r1 = helper(sum% 3, zero - 1, one, two, turn+1, dp);\\n        }\\n        if (one > 0) {\\n            r2 = helper((sum+1) % 3, zero, one-1, two, turn+1, dp);\\n        }\\n        if (two > 0) {\\n            r3 = helper((sum+2) % 3, zero, one, two-1, turn+1, dp);\\n        }\\n        \\n        // current player wins if he can find out a way for the other player to lose in next turn\\n        boolean res = (!r1 || !r2 || !r3);\\n        dp.put(key, res);\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n        int zero=0, one=0, two=0;\\n        for (int s : stones) {\\n            if (s%3 == 0) zero++;\\n            if (s%3 == 1) one++;\\n            if (s%3 == 2) two++;\\n        }\\n        \\n        Map<String, Boolean> dp =  new HashMap<>();\\n        return helper(0, zero, one, two, 0, dp);\\n        \\n    }\\n    \\n    private boolean helper(int sum, int zero, int one, int two, int turn, Map<String, Boolean> dp) {\\n        // sum of removed stones is divisible by 3 for previous player, current player wins\\n        if (turn != 0 && sum % 3 == 0) return true;\\n\\n        if (zero == 0 && one == 0 && two == 0) {\\n            // no stones, bob wins\\n            return turn % 2 == 1;\\n        }\\n        String key = sum +\"|\"+zero%2+\"|\"+one%2+\"|\"+two%2;\\n        if (dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n        \\n        boolean r1 = true,r2=true, r3=true;\\n        if (zero > 0) {\\n            r1 = helper(sum% 3, zero - 1, one, two, turn+1, dp);\\n        }\\n        if (one > 0) {\\n            r2 = helper((sum+1) % 3, zero, one-1, two, turn+1, dp);\\n        }\\n        if (two > 0) {\\n            r3 = helper((sum+2) % 3, zero, one, two-1, turn+1, dp);\\n        }\\n        \\n        // current player wins if he can find out a way for the other player to lose in next turn\\n        boolean res = (!r1 || !r2 || !r3);\\n        dp.put(key, res);\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402060,
                "title": "very-intuitive-with-explanation",
                "content": "see first divide the whole array in three parts first remainder 1 , second remainder 2 and third remainder 0 ...... now see what remainder 0 work is its work is to switch the positions between alice and bob like if bob is working on remainder 1 it will start to work on remainder 2 now if alice choosed remainder 0 element in her chance ...... and this is a big hint which after which you all can build up the inituition ........\\n// code \\n\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n     int count1=0;\\n        int count2=0;\\n        int count0=0;\\n        for(int i=0;i<stones.size();i++){\\n            if(stones[i]%3==1){\\n                count1++;\\n            }\\n            else if(stones[i]%3==2){\\n                count2++;\\n            }\\n            else{\\n                count0++;\\n            }\\n        }\\n        if(count1==0 && count2==0){\\n            return false;\\n        }\\n        if(count1==0 || count2==0){\\n            if(count1==1|| count2==1 || count1==2 || count2==2){\\n                return false;\\n            }\\n            if(count0%2){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(count1==count2){\\n            if(count0%2){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        else{\\n            if(count0%2){\\n                int min_val=min(count1,count2);\\n                int max_val=max(count1,count2);\\n                if(max_val-2<=min_val){\\n                    return false;\\n                }\\n                else{\\n                    return true;\\n                }\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n     int count1=0;\\n        int count2=0;\\n        int count0=0;\\n        for(int i=0;i<stones.size();i++){\\n            if(stones[i]%3==1){\\n                count1++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2323640,
                "title": "python-simple-maths",
                "content": "\\n    def stoneGameIX(self, stones):\\n        dict1 = Counter([i%3 for i in stones])\\n        \\n        if dict1[0]%2 == 0:\\n            return dict1[1] and dict1[2]\\n        \\n        return abs(dict1[1] - dict1[2]) > 2",
                "solutionTags": [],
                "code": "\\n    def stoneGameIX(self, stones):\\n        dict1 = Counter([i%3 for i in stones])\\n        \\n        if dict1[0]%2 == 0:\\n            return dict1[1] and dict1[2]\\n        \\n        return abs(dict1[1] - dict1[2]) > 2",
                "codeTag": "Python3"
            },
            {
                "id": 1928090,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        int n = stones.size();\\n        int zero = 0;\\n        int one = 0;\\n        int two = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (stones[i] % 3 == 0) ++zero;\\n            else if (stones[i] % 3 == 1) ++one;\\n            else ++two;\\n        }\\n        if (one == 0 && two == 0) return false;\\n        if (one == 0) {\\n            if ((zero + 1) % 2 == 0) {\\n                if (two - 1 <= 1) return false;\\n                return true;\\n            }\\n            return false;\\n        }\\n        else if (two == 0) {\\n            if ((zero + 1) % 2 == 0) {\\n                if (one - 1 <= 1) return false;\\n                return true;\\n            }\\n            return false;\\n        }\\n        if ((zero + 1) % 2 == 0) {\\n            if (two - 2 >  one) {\\n                return true;\\n            }\\n            if (one - 2 > two) return true;\\n        }\\n        else {\\n            if (one - 2 < two) return true;\\n            if (two - 2 < one) return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        int n = stones.size();\\n        int zero = 0;\\n        int one = 0;\\n        int two = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (stones[i] % 3 == 0) ++zero;\\n            else if (stones[i] % 3 == 1) ++one;\\n            else ++two;\\n        }\\n        if (one == 0 && two == 0) return false;\\n        if (one == 0) {\\n            if ((zero + 1) % 2 == 0) {\\n                if (two - 1 <= 1) return false;\\n                return true;\\n            }\\n            return false;\\n        }\\n        else if (two == 0) {\\n            if ((zero + 1) % 2 == 0) {\\n                if (one - 1 <= 1) return false;\\n                return true;\\n            }\\n            return false;\\n        }\\n        if ((zero + 1) % 2 == 0) {\\n            if (two - 2 >  one) {\\n                return true;\\n            }\\n            if (one - 2 > two) return true;\\n        }\\n        else {\\n            if (one - 2 < two) return true;\\n            if (two - 2 < one) return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835049,
                "title": "ruby-beats-100-100",
                "content": "```\\n# @param {Integer[]} stones\\n# @return {Boolean}\\ndef stone_game_ix(stones)\\n  h = stones.map { _1 % 3 }.tally\\n  c0 = h[0] || 0\\n  c1 = h[1] || 0\\n  c2 = h[2] || 0\\n  c0.even? ? (c1*c2 > 0) : (c1 - c2).abs > 2\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} stones\\n# @return {Boolean}\\ndef stone_game_ix(stones)\\n  h = stones.map { _1 % 3 }.tally\\n  c0 = h[0] || 0\\n  c1 = h[1] || 0\\n  c2 = h[2] || 0\\n  c0.even? ? (c1*c2 > 0) : (c1 - c2).abs > 2\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1720317,
                "title": "python-3-recursion",
                "content": "aWin1(cnt0,cnt1,cnt2): A will win with current sum 1 and the remaining counts of stones, cnt0, cnt1, and cnt2\\nbWin1(cnt0,cnt1,cnt2): B will win with current sum 1 and the remaining counts of stones, cnt0, cnt1, and cnt2\\n\\nThree things to note:\\n1. xWin1(cnt0,cnt1,cnt2)=xWin1(cnt0-2,cnt1,cnt2) : if cnt0>1\\n2. xWin1(cnt0,cnt1,cnt2)=xWin1(cnt0,cnt1-1,cnt2-1) : if cnt1,cnt2>0\\n3. xWin1(cnt0,cnt1,cnt2)=xWin2(cnt0,cnt2,cnt1)\\n\\n```\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        dictC = Counter(s%3 for s in stones)\\n        dictC[0] &= 1                                                #(noted from 1 above)\\n        if dictC[1]==dictC[2]==0:           return False\\n        \\n        AWin1 = { (0,0,1): False, (1,0,1):  True, (0,1,0): False, (1,1,0): False, (0,1,1): False, (1,1,1): False }\\n        def aWin1(a,b,c):\\n            minBC = min(b,c);           b,c = b-minBC,c-minBC        #(noted from 2 above)\\n            if a==b==0:                 return False\\n            if b==c==0:                 return False\\n            if (a,b,c)   in AWin1:      return AWin1[a,b,c]\\n            AWin1[a,b,c] = any( not bWin1(*t) for t in [(a-1,b,c),(a,c,b-1)] if all( e>=0 for e in t ) )\\n            return AWin1[a,b,c]\\n        BWin1 = { (0,0,1): False, (1,0,1):  True, (0,1,0):  True, (1,1,0):  True, (0,1,1):  True, (1,1,1): True  }\\n        def bWin1(a,b,c):\\n            minBC = min(b,c);           b,c = b-minBC,c-minBC        #(noted from 2 above)\\n            if a==b==0:                 return not c\\n            if b==c==0:                 return True\\n            if (a,b,c)   in BWin1:      return BWin1[a,b,c]\\n            BWin1[a,b,c] = any( not aWin1(*t) for t in [(a-1,b,c),(a,c,b-1)] if all( e>=0 for e in t ) )\\n            return BWin1[a,b,c]\\n            \\n        return any( not bWin1(*t) for t in [(dictC[0],dictC[1]-1,dictC[2]), (dictC[0],dictC[2]-1,dictC[1])]  if all( e>=0 for e in t ) )        \\n```",
                "solutionTags": [],
                "code": "```\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        dictC = Counter(s%3 for s in stones)\\n        dictC[0] &= 1                                                #(noted from 1 above)\\n        if dictC[1]==dictC[2]==0:           return False\\n        \\n        AWin1 = { (0,0,1): False, (1,0,1):  True, (0,1,0): False, (1,1,0): False, (0,1,1): False, (1,1,1): False }\\n        def aWin1(a,b,c):\\n            minBC = min(b,c);           b,c = b-minBC,c-minBC        #(noted from 2 above)\\n            if a==b==0:                 return False\\n            if b==c==0:                 return False\\n            if (a,b,c)   in AWin1:      return AWin1[a,b,c]\\n            AWin1[a,b,c] = any( not bWin1(*t) for t in [(a-1,b,c),(a,c,b-1)] if all( e>=0 for e in t ) )\\n            return AWin1[a,b,c]\\n        BWin1 = { (0,0,1): False, (1,0,1):  True, (0,1,0):  True, (1,1,0):  True, (0,1,1):  True, (1,1,1): True  }\\n        def bWin1(a,b,c):\\n            minBC = min(b,c);           b,c = b-minBC,c-minBC        #(noted from 2 above)\\n            if a==b==0:                 return not c\\n            if b==c==0:                 return True\\n            if (a,b,c)   in BWin1:      return BWin1[a,b,c]\\n            BWin1[a,b,c] = any( not aWin1(*t) for t in [(a-1,b,c),(a,c,b-1)] if all( e>=0 for e in t ) )\\n            return BWin1[a,b,c]\\n            \\n        return any( not bWin1(*t) for t in [(dictC[0],dictC[1]-1,dictC[2]), (dictC[0],dictC[2]-1,dictC[1])]  if all( e>=0 for e in t ) )        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1618468,
                "title": "golang-o-n-solution-with-explanation",
                "content": "```go\\nfunc stoneGameIX(stones []int) bool {\\n\\tres0, res1, res2 := 0, 0, 0\\n\\tfor _, s := range stones {\\n\\t\\tswitch s % 3 {\\n\\t\\tcase 0:\\n\\t\\t\\tres0++\\n\\t\\tcase 1:\\n\\t\\t\\tres1++\\n\\t\\tcase 2:\\n\\t\\t\\tres2++\\n\\t\\t}\\n\\t}\\n\\t// we suppose res1 <= res2\\n\\tif res2 < res1 {\\n\\t\\tres1, res2 = res2, res1\\n\\t}\\n\\t// only res0 exists, Alice picks one and lose the game\\n\\tif res1 == 0 && res2 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tif res1 == 0 {\\n\\t\\tif res2 <= 2 {\\n\\t\\t\\t// nothing left after pick all elements, Bob will win\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\t// the player who acts first loses the game\\n\\t\\t// res0 change the order if odd\\n\\t\\treturn res0%2 == 1\\n\\t}\\n\\t// res0 is even, Alice picks 1 and win\\n\\tif res0%2 == 0 {\\n\\t\\treturn true\\n\\t}\\n\\t// res0 is odd, Alice picks 2, Bob has to pick 1, if 1 used up first, Alice wins\\n    // 2->3->2->1->2->(no 1, but 2 exits now)\\n\\treturn res2 > res1+2\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc stoneGameIX(stones []int) bool {\\n\\tres0, res1, res2 := 0, 0, 0\\n\\tfor _, s := range stones {\\n\\t\\tswitch s % 3 {\\n\\t\\tcase 0:\\n\\t\\t\\tres0++\\n\\t\\tcase 1:\\n\\t\\t\\tres1++\\n\\t\\tcase 2:\\n\\t\\t\\tres2++\\n\\t\\t}\\n\\t}\\n\\t// we suppose res1 <= res2\\n\\tif res2 < res1 {\\n\\t\\tres1, res2 = res2, res1\\n\\t}\\n\\t// only res0 exists, Alice picks one and lose the game\\n\\tif res1 == 0 && res2 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tif res1 == 0 {\\n\\t\\tif res2 <= 2 {\\n\\t\\t\\t// nothing left after pick all elements, Bob will win\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\t// the player who acts first loses the game\\n\\t\\t// res0 change the order if odd\\n\\t\\treturn res0%2 == 1\\n\\t}\\n\\t// res0 is even, Alice picks 1 and win\\n\\tif res0%2 == 0 {\\n\\t\\treturn true\\n\\t}\\n\\t// res0 is odd, Alice picks 2, Bob has to pick 1, if 1 used up first, Alice wins\\n    // 2->3->2->1->2->(no 1, but 2 exits now)\\n\\treturn res2 > res1+2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1535196,
                "title": "go-solution-with-clean-code-and-comments",
                "content": "It takes a long time to figure out the right way to describe the patterns. Comments are inlined. Hope this is helpful.\\n\\n```\\nfunc stoneGameIX(stones []int) bool {\\n\\n\\tcnt := [3]int{}\\n\\tfor i, _ := range stones {\\n\\t\\tidx := stones[i] % 3\\n\\t\\tcnt[idx] = cnt[idx] + 1\\n\\t}\\n\\t\\n\\t// Ignoring cnt[0], possible paths without failing the game are:\\n\\t// 11212121..\\n\\t//  2212121..\\n\\t// If the above patterns can be strictly followed, cnt[0] cannot flip the result since all\\n\\t// numbers can be picked eventually.\\n\\t// Otherwise, odd number of cnt[0] can flip the result.\\n\\twin1 := false\\n\\twin2 := false\\n    oddZero := cnt[0] & 1 == 1\\n\\tx := cnt[1] - cnt[2]\\n    // Alice can only start from 1 or 2, check each path respectively.\\n\\t// Start from 1\\n\\tif cnt[1] > 0 {\\n\\t    // x >= 1, 1121 or 112 or 1121111 ....\\n\\t\\twin1 = !(x >= 1)\\n        // Do XOR (!= for bool) to flip the result (ignoring x==2 || x==1 since they follow the patterns)\\n\\t\\twin1 = win1 != (oddZero && !(x == 2 || x == 1))\\n\\t}\\n\\n\\t// Start from 2\\n\\tif cnt[2] > 0 {\\n\\t    // x <= -1, 221 or 22121 or 2212 or 2212222....\\n\\t\\twin2 = !(x <= -1)\\n        // Do XOR (!= for bool) to flip the result (ignoring x==-1 || x==-2 since they follow the patterns)\\n\\t\\twin2 = win2 != (oddZero && !(x == -1 || x == -2))\\n\\t}\\n    // Alice has the advantage to choose the path, hence she will always pick the winning path\\n\\treturn win1 || win2\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc stoneGameIX(stones []int) bool {\\n\\n\\tcnt := [3]int{}\\n\\tfor i, _ := range stones {\\n\\t\\tidx := stones[i] % 3\\n\\t\\tcnt[idx] = cnt[idx] + 1\\n\\t}\\n\\t\\n\\t// Ignoring cnt[0], possible paths without failing the game are:\\n\\t// 11212121..\\n\\t//  2212121..\\n\\t// If the above patterns can be strictly followed, cnt[0] cannot flip the result since all\\n\\t// numbers can be picked eventually.\\n\\t// Otherwise, odd number of cnt[0] can flip the result.\\n\\twin1 := false\\n\\twin2 := false\\n    oddZero := cnt[0] & 1 == 1\\n\\tx := cnt[1] - cnt[2]\\n    // Alice can only start from 1 or 2, check each path respectively.\\n\\t// Start from 1\\n\\tif cnt[1] > 0 {\\n\\t    // x >= 1, 1121 or 112 or 1121111 ....\\n\\t\\twin1 = !(x >= 1)\\n        // Do XOR (!= for bool) to flip the result (ignoring x==2 || x==1 since they follow the patterns)\\n\\t\\twin1 = win1 != (oddZero && !(x == 2 || x == 1))\\n\\t}\\n\\n\\t// Start from 2\\n\\tif cnt[2] > 0 {\\n\\t    // x <= -1, 221 or 22121 or 2212 or 2212222....\\n\\t\\twin2 = !(x <= -1)\\n        // Do XOR (!= for bool) to flip the result (ignoring x==-1 || x==-2 since they follow the patterns)\\n\\t\\twin2 = win2 != (oddZero && !(x == -1 || x == -2))\\n\\t}\\n    // Alice has the advantage to choose the path, hence she will always pick the winning path\\n\\treturn win1 || win2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1501697,
                "title": "python-clean-and-short-solution",
                "content": "```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        stones = [v % 3 for v in stones]\\n        \\n        d = defaultdict(int)\\n        for v in stones:\\n            d[v] += 1\\n        \\n        while d[1] >= 2 and d[2] >= 2:\\n            d[2] -= 1\\n            d[1] -= 1\\n        \\n        if d[0] % 2 == 0: # number of 0s will not influent the result\\n            if (d[1] == 1 and d[2] >= 1) or (d[2] == 1 and d[1] >= 1):\\n                return True\\n        else:\\n            if (d[1] == 0 and d[2] >= 3) or (d[2] == 0 and d[1] >= 3):\\n                return True\\n            if (d[1] == 1 and d[2] >= 4) or (d[2] == 1 and d[1] >= 4):\\n                return True\\n\\n        return False\\n````\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        stones = [v % 3 for v in stones]\\n        \\n        d = defaultdict(int)\\n        for v in stones:\\n            d[v] += 1\\n        \\n        while d[1] >= 2 and d[2] >= 2:\\n            d[2] -= 1\\n            d[1] -= 1\\n        \\n        if d[0] % 2 == 0: # number of 0s will not influent the result\\n            if (d[1] == 1 and d[2] >= 1) or (d[2] == 1 and d[1] >= 1):\\n                return True\\n        else:\\n            if (d[1] == 0 and d[2] >= 3) or (d[2] == 0 and d[1] >= 3):\\n                return True\\n            if (d[1] == 1 and d[2] >= 4) or (d[2] == 1 and d[1] >= 4):\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501324,
                "title": "python-o-n-6-lines",
                "content": "Turn all stone values to mod 3 to get zeros, ones and twos.\\n\\nInsights:\\n* Alice wins if Bob picks up a running sum of 0 mod 3 before either Alice does or stones run out.\\n* Think of Alice always starting the play at ones or twos(for the most part). Also think of play as only using ones and twos as playsets. \\n\\t* Without zeros, Bob would follow Alice\\'s choice as his first play, then they would start playing in a alternate fashion, i.e. each one choosing the complement of the other\\'s last play (1->2 or 2->1). If Bob cannot follow Alice\\'s choice as his first play, he loses.\\n\\t* With even number of zeros, this trend wouldnt be interrupted and Alice can ensure she will start the alternation(i.e. play number 3 of the game) if alternation is possible.\\n\\t* With odd number of zeros, Alice can force Bob to start the alternation.\\n* If alternation is not possible, Alice will win if Bob starts play (by choosing zeros as a stalling mechanism - this is the reason for the \"**for the most part** caveat above-)  and there are atleast three of the single play set (ones or twos).\\n* If alternation is possible, Alice will win if she starts alternating at the larger of the two sets or Bob starts alternating at the smaller of the two sets. In other words, Alice wins if \\n\\t* even number of zeros: she starts play at the smaller/either (if equal size) of the two play sets so that she will begin the alternation at what will then be the larger play set\\n\\t* odd number of zeros: she starts play at the larger of the two sets, forces Bob to start alternation and *to ensure he starts alternating at the smaller of the two play sets, the first two plays must still leave the larger of the two sets larger when alternation begins - this requires a difference of atleast 3*.\\n\\n**Combining all of this, we get that for Alice to win:\\n1. \\twith even number of zeros: alternation should be possible\\n2. \\twith odd number of zeros: difference between play set sizes should be atleast 3**\\n\\t\\n\\n\\n```\\nfrom collections import Counter\\nclass Solution(object):\\n    def stoneGameIX(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        counts = Counter(stone%3 for stone in stones) \\n        \\n        if counts[0]%2 == 1 and abs(counts[1]-counts[2]) >= 3:\\n            return True\\n        \\n        if counts[0]%2 == 0 and counts[1] > 0 and counts[2] > 0:\\n            return True\\n        \\n        return False\\n        \\n",
                "solutionTags": [],
                "code": "Turn all stone values to mod 3 to get zeros, ones and twos.\\n\\nInsights:\\n* Alice wins if Bob picks up a running sum of 0 mod 3 before either Alice does or stones run out.\\n* Think of Alice always starting the play at ones or twos(for the most part). Also think of play as only using ones and twos as playsets. \\n\\t* Without zeros, Bob would follow Alice\\'s choice as his first play, then they would start playing in a alternate fashion, i.e. each one choosing the complement of the other\\'s last play (1->2 or 2->1). If Bob cannot follow Alice\\'s choice as his first play, he loses.\\n\\t* With even number of zeros, this trend wouldnt be interrupted and Alice can ensure she will start the alternation(i.e. play number 3 of the game) if alternation is possible.\\n\\t* With odd number of zeros, Alice can force Bob to start the alternation.\\n* If alternation is not possible, Alice will win if Bob starts play (by choosing zeros as a stalling mechanism - this is the reason for the \"**for the most part** caveat above-)  and there are atleast three of the single play set (ones or twos).\\n* If alternation is possible, Alice will win if she starts alternating at the larger of the two sets or Bob starts alternating at the smaller of the two sets. In other words, Alice wins if \\n\\t* even number of zeros: she starts play at the smaller/either (if equal size) of the two play sets so that she will begin the alternation at what will then be the larger play set\\n\\t* odd number of zeros: she starts play at the larger of the two sets, forces Bob to start alternation and *to ensure he starts alternating at the smaller of the two play sets, the first two plays must still leave the larger of the two sets larger when alternation begins - this requires a difference of atleast 3*.\\n\\n**Combining all of this, we get that for Alice to win:\\n1. \\twith even number of zeros: alternation should be possible\\n2. \\twith odd number of zeros: difference between play set sizes should be atleast 3**\\n\\t\\n\\n\\n```\\nfrom collections import Counter\\nclass Solution(object):\\n    def stoneGameIX(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        counts = Counter(stone%3 for stone in stones) \\n        \\n        if counts[0]%2 == 1 and abs(counts[1]-counts[2]) >= 3:\\n            return True\\n        \\n        if counts[0]%2 == 0 and counts[1] > 0 and counts[2] > 0:\\n            return True\\n        \\n        return False\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1500588,
                "title": "javascript-greedy-112ms",
                "content": "```\\nconst stoneGameIX = (a) => {\\n    let f = Array(3).fill(0);\\n    for (const x of a) f[x % 3]++;\\n    f[0] %= 2;\\n    if (f[0] == 0) {\\n        if (f[1] == 0 || f[2] == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    return Math.abs(f[1] - f[2]) <= 2 ? false : true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst stoneGameIX = (a) => {\\n    let f = Array(3).fill(0);\\n    for (const x of a) f[x % 3]++;\\n    f[0] %= 2;\\n    if (f[0] == 0) {\\n        if (f[1] == 0 || f[2] == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    return Math.abs(f[1] - f[2]) <= 2 ? false : true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500246,
                "title": "c-o-n-without-simulation-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        // Alice will take the only stone. Bob wins. \\n        if (stones.size() == 1) {\\n            return false;\\n        }\\n        \\n        // Collect a histogram of stone values modulo 3.\\n        std::array<int, 3> histo;\\n        histo.fill(0);\\n        for (int val : stones) {\\n            ++histo[val % 3];\\n        }\\n        \\n        // Anything Alice picks is divisible by 3. Bob wins.\\n        if ((histo[1] == 0) && (histo[2] == 0)) {\\n            return false;\\n        }\\n        \\n        // Picking a value divisible by 3 will shift the state \\n        // (i.e. current remainder) to the opponent. As a result,\\n        // an even number of those would not have any effect. \\n        if (histo[0] % 2 == 0) {\\n            // Alice will pick a value with a smaller number of occurrences. \\n            // Without loss of generality, assume it is 2. \\n            // Eventually the players will move the game into a state where\\n            // there are one or more of 1s and the state is 2, with Bob playing next move.\\n            // In this case, he would have to choose 1 and lose the game. \\n            return (histo[1] > 0) && (histo[2] > 0);\\n            \\n            // Notice that the situation above only works when we have stones with both values.\\n            // Otherwise, the game will end up in the situation where \\n            // the current state is 2 and there are one or more 2s, with Bob playing next move.\\n            // If there is only one stone left, Bob wins by removing it.\\n            // If there are more stones, Bob removes the 2 and the game state becomes 1.\\n            // Alice loses by removing the next stone. \\n        }\\n        \\n        // When the number of stones with value divisible by 3 is odd, \\n        // the game state will shift back to Alice. \\n        // Assume one kind of stone has more than two counts than the other, \\n        // without loss of generality, say it is 1. The game will eventually \\n        // be in a state of 1 and there are at least two stones left with \\n        // the same modulo 3 value (i.e. 1), with Alice playing next. \\n        // Alice removes 1, transitioning the state into 2, and hand it over to Bob.\\n        // There are still at least one stone with value 1, and Bob loses by removing it. \\n        return std::abs(histo[1] - histo[2]) > 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        // Alice will take the only stone. Bob wins. \\n        if (stones.size() == 1) {\\n            return false;\\n        }\\n        \\n        // Collect a histogram of stone values modulo 3.\\n        std::array<int, 3> histo;\\n        histo.fill(0);\\n        for (int val : stones) {\\n            ++histo[val % 3];\\n        }\\n        \\n        // Anything Alice picks is divisible by 3. Bob wins.\\n        if ((histo[1] == 0) && (histo[2] == 0)) {\\n            return false;\\n        }\\n        \\n        // Picking a value divisible by 3 will shift the state \\n        // (i.e. current remainder) to the opponent. As a result,\\n        // an even number of those would not have any effect. \\n        if (histo[0] % 2 == 0) {\\n            // Alice will pick a value with a smaller number of occurrences. \\n            // Without loss of generality, assume it is 2. \\n            // Eventually the players will move the game into a state where\\n            // there are one or more of 1s and the state is 2, with Bob playing next move.\\n            // In this case, he would have to choose 1 and lose the game. \\n            return (histo[1] > 0) && (histo[2] > 0);\\n            \\n            // Notice that the situation above only works when we have stones with both values.\\n            // Otherwise, the game will end up in the situation where \\n            // the current state is 2 and there are one or more 2s, with Bob playing next move.\\n            // If there is only one stone left, Bob wins by removing it.\\n            // If there are more stones, Bob removes the 2 and the game state becomes 1.\\n            // Alice loses by removing the next stone. \\n        }\\n        \\n        // When the number of stones with value divisible by 3 is odd, \\n        // the game state will shift back to Alice. \\n        // Assume one kind of stone has more than two counts than the other, \\n        // without loss of generality, say it is 1. The game will eventually \\n        // be in a state of 1 and there are at least two stones left with \\n        // the same modulo 3 value (i.e. 1), with Alice playing next. \\n        // Alice removes 1, transitioning the state into 2, and hand it over to Bob.\\n        // There are still at least one stone with value 1, and Bob loses by removing it. \\n        return std::abs(histo[1] - histo[2]) > 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500235,
                "title": "greedy-solution",
                "content": "a[3] denote frequency of remainder of 3\\nAlice start with either stone a[1] or a[2]\\nif a[0] is even then it doesn\\'t effect anythink as they both take equal no. of stone from a[0].\\nif a[0] is odd it will change turn.\\n```\\neg. [1,1,3,1..] \\nalice pick 1\\nif bob pick 3\\nagain alice has to pick.\\n\\neg.[1,1,3,3....]\\nalice pick 1\\nif bob pick 3 then alice will also pick 3\\nso bob has to pick now with same remainder\\n```\\nwhen a[0] is odd then game is in alice hand if the diff of stone in a[1] and a[2] is more than 2. \\nas she will start with a[1] if this is more\\nelse start with a[2]\\nif diff is less then she loss because of no stone left to play.\\n\\nwhen a[0] is even \\nshe will start a[1] if it is less\\nelse she will start with a[2]\\nbut if any of them is zero she will loss.\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return 0;\\n        int a[3] = {0};\\n        for(int& x : s){\\n            a[x%3]++;\\n        }\\n        if(a[0] & 1) {\\n            if(abs(a[1]-a[2]) > 2) return 1;\\n            else return 0;\\n        }\\n        else {\\n            if(a[1] == 0 || a[2] == 0) return 0;\\n            else return 1;\\n        }\\n    }\\n};\\n```\\nupvote if this helps",
                "solutionTags": [],
                "code": "```\\neg. [1,1,3,1..] \\nalice pick 1\\nif bob pick 3\\nagain alice has to pick.\\n\\neg.[1,1,3,3....]\\nalice pick 1\\nif bob pick 3 then alice will also pick 3\\nso bob has to pick now with same remainder\\n```\n```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return 0;\\n        int a[3] = {0};\\n        for(int& x : s){\\n            a[x%3]++;\\n        }\\n        if(a[0] & 1) {\\n            if(abs(a[1]-a[2]) > 2) return 1;\\n            else return 0;\\n        }\\n        else {\\n            if(a[1] == 0 || a[2] == 0) return 0;\\n            else return 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500201,
                "title": "python-infer-from-maximum-sequence-lengths",
                "content": "The first step is to consider each element after modulo 3.\\n\\nThis approach considers what is the maximum sequence length you can get from the stones.\\n\\nWe can assume there is no zeros for now.\\n\\nIf Alice starts with taking a one, to avoid getting 0 mod 3 the sequence is \\n\\n[1] 1 2 1 2 1 2 1 2 (... ending with 1 or 2)\\n\\nIf Alice starts with taking a two, to avoid getting 0 mod 3 the sequence is \\n\\n[2] 2 1 2 1 2 1 2 1 (... ending with 1 or 2)\\n\\nIf there are no ones or twos at the start, Alice cannot pick any stone and Bob wins.\\nIf the sequence length is equal to the total number of stones, Bob wins (see question).\\nIf the sequence length is odd, the last stone is taken by Alice, Alice wins.\\nIf the sequence length is even, the last stone is taken by Bob, Bob wins.\\n\\nIf Alice can choose a winning sequence, Alice wins.\\n\\nHow do zeroes change the game?\\n\\nAfter Alice first takes the first one or two, either player can take a zero. The sequence length is simply extended by the number of zeroes.\\n\\n```python\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        stones = [x%3 for x in stones]        \\n        c = Counter(stones)\\n        print()\\n        print(c)\\n\\n        # 2 2 1 2 1 2 1 2 ... 0 0 0 0\\n        \\n        if c[2]:\\n            len_sequence = c[0] + 1\\n            c[2] -= 1\\n            now_2 = True\\n            while True:\\n                if now_2:\\n                    if c[2]:\\n                        c[2] -= 1\\n                        len_sequence += 1\\n                    else:\\n                        break\\n                else:\\n                    if c[1]:\\n                        c[1] -= 1\\n                        len_sequence += 1\\n                    else:\\n                        break\\n                now_2 = not now_2\\n                \\n            print(\"start 2\", len_sequence)\\n            if len_sequence == len(stones):\\n                pass\\n            elif len_sequence%2:  # last stone drawn by alice\\n                return True\\n            \\n        c = Counter(stones)\\n            \\n        if c[1]:\\n            len_sequence = c[0] + 1\\n            c[1] -= 1\\n            now_1 = True\\n            while True:\\n                if now_1:\\n                    if c[1]:\\n                        c[1] -= 1\\n                        len_sequence += 1\\n                    else:\\n                        break\\n                else:\\n                    if c[2]:\\n                        c[2] -= 1\\n                        len_sequence += 1\\n                    else:\\n                        break\\n                now_1 = not now_1\\n                \\n            print(\"start 1\", len_sequence)\\n            if len_sequence == len(stones):\\n                pass\\n            elif len_sequence%2:  # last stone drawn by alice\\n                return True\\n\\n            \\n        # no ones and twos\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        stones = [x%3 for x in stones]        \\n        c = Counter(stones)\\n        print()\\n        print(c)\\n\\n        # 2 2 1 2 1 2 1 2 ... 0 0 0 0\\n        \\n        if c[2]:\\n            len_sequence = c[0] + 1\\n            c[2] -= 1\\n            now_2 = True\\n            while True:\\n                if now_2:\\n                    if c[2]:\\n                        c[2] -= 1\\n                        len_sequence += 1\\n                    else:\\n                        break\\n                else:\\n                    if c[1]:\\n                        c[1] -= 1\\n                        len_sequence += 1\\n                    else:\\n                        break\\n                now_2 = not now_2\\n                \\n            print(\"start 2\", len_sequence)\\n            if len_sequence == len(stones):\\n                pass\\n            elif len_sequence%2:  # last stone drawn by alice\\n                return True\\n            \\n        c = Counter(stones)\\n            \\n        if c[1]:\\n            len_sequence = c[0] + 1\\n            c[1] -= 1\\n            now_1 = True\\n            while True:\\n                if now_1:\\n                    if c[1]:\\n                        c[1] -= 1\\n                        len_sequence += 1\\n                    else:\\n                        break\\n                else:\\n                    if c[2]:\\n                        c[2] -= 1\\n                        len_sequence += 1\\n                    else:\\n                        break\\n                now_1 = not now_1\\n                \\n            print(\"start 1\", len_sequence)\\n            if len_sequence == len(stones):\\n                pass\\n            elif len_sequence%2:  # last stone drawn by alice\\n                return True\\n\\n            \\n        # no ones and twos\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970739,
                "title": "greedy-o-n",
                "content": "# Intuition\\nThis take me very long trial and error to arrive at this conclusion:\\n- We can easily see that the actual value of the stones does not matter much, only it\\'s value in modulo 3 is important. Let $group(i)$ be the number of stones that has value $i$ in modulo 3\\n- The game entirely depends on the first pick from Alice\\n    - Alice pick 1, the game would be 1,1,2,1,2,1,2 ...\\n    - Alice pick 2, the game would be 2,2,1,2,1,2,1,2 ...\\n    - The game end when 1 person fail to match the pick\\n    - Pick 0 will result in reverse play (making other person to match his own previous pick)\\n- If $group(0)$ is even, and $group(1) > 0, group(2) > 0$, Alice can always force a win by picking the group with less number. If $group(1) = 0$ or $group(2) = 0$, Alice will always end up running out of good number to pick and thus losing\\n- If $group(0)$ is odd, Alice need to pick a group has more than at least 2 number than the other group, otherwise she will always lose\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn stone_game_ix(stones: Vec<i32>) -> bool {\\n        let n = stones.len();\\n        let mut group = vec![0i32;3];\\n        for x in stones {\\n            group[(x%3) as usize] += 1;\\n        }\\n        if group[0]%2 == 0  {\\n            group[1] > 0 && group[2] > 0\\n        } else {\\n            (group[1] - group[2]).abs() > 2\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn stone_game_ix(stones: Vec<i32>) -> bool {\\n        let n = stones.len();\\n        let mut group = vec![0i32;3];\\n        for x in stones {\\n            group[(x%3) as usize] += 1;\\n        }\\n        if group[0]%2 == 0  {\\n            group[1] > 0 && group[2] > 0\\n        } else {\\n            (group[1] - group[2]).abs() > 2\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740185,
                "title": "most-detailed-explanation-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to analyze the counts of stones with values congruent to 0, 1, and 2 modulo 3. By understanding the relationship between these counts, we can determine if the first player can win the game or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start by counting the number of stones with values congruent to 0, 1, and 2 modulo 3. We can use an array count to keep track of these counts.\\n\\n- Check if the count of stones with value congruent to 0 modulo 3 is even. If it is, the first player cannot lose because they can always select a stone with value congruent to 0 modulo 3 and force the second player to make a move.\\n\\n- If the count of stones with value congruent to 0 modulo 3 is odd, we need to check if there is a significant difference between the counts of stones with values congruent to 1 and 2 modulo 3. If the absolute difference is greater than 2, the first player can strategically select stones to force the second player into making a losing move.\\n\\n- Return the appropriate result based on the conditions mentioned above. If the first player can win, return true; otherwise, return false.\\n\\n- By analyzing the counts of stones modulo 3 and considering the parity of the count of stones with value congruent to 0 modulo 3, we can determine if the first player has a winning strategy. This approach avoids the need for simulating the game and directly uses the properties of the stone values to make the decision.\\n\\n# **Explaination**\\nThis solution is based on the observation that the outcome of the game only depends on the counts of stones with values congruent to 0, 1, and 2 modulo 3.\\n\\n- The code uses an array count of size 3 to keep track of the counts. Initially, all elements of count are set to 0.\\n\\n- The for loop iterates over each stone value in the stones vector. For each stone, it increments the count corresponding to its value modulo 3. This is done using the expression ++count[stone % 3].\\n\\nAfter counting the stones, the code checks the conditions for winning the game:\\n\\n- If the count of stones with value congruent to 0 modulo 3 is even (count[0] % 2 == 0), it means the first player can take all the stones with this value, and the second player can do the same. In this case, the first player cannot lose since they have an even number of stones to choose from. However, if either the count of stones with value congruent to 1 modulo 3 or the count of stones with value congruent to 2 modulo 3 is 0 (count[1] == 0 or count[2] == 0), then the first player cannot win since they have no stones to choose from that give them a valid move. Therefore, the condition count[1] > 0 && count[2] > 0 is checked.\\n\\n- If the count of stones with value congruent to 0 modulo 3 is odd (count[0] % 2 == 1), it means the first player can take one stone with this value, and the second player can do the same. In this case, the first player can potentially lose if there is a significant difference in the counts of stones with values congruent to 1 modulo 3 and 2 modulo 3. To check for this condition, the absolute difference between count[1] and count[2] is calculated using std::abs(count[1] - count[2]), and it is checked if it is greater than 2 (std::abs(count[1] - count[2]) > 2).\\n\\nBased on these conditions, the code returns true if the first player wins and false otherwise.\\n\\n# Code\\n```\\nconst static auto initialize = [] {\\n    // Function to initialize input/output operations for faster execution\\n    std::ios::sync_with_stdio(false); // Allows faster input/output\\n    std::cin.tie(nullptr); // Ensures input is synchronized with output\\n    std::cout.tie(nullptr); // Ensures output is synchronized with input\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        // Create an array to count the different types of stones\\n        auto count = array<int, 3>{};\\n        \\n        // Count the different types of stones\\n        for (auto stone : stones) {\\n            ++count[stone % 3];\\n        }\\n        \\n        // Check if the first player can win the game based on the stone counts\\n        return count[0] % 2 == 0 ?\\n            count[1] > 0 && count[2] > 0 :\\n            abs(count[1] - count[2]) > 2;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst static auto initialize = [] {\\n    // Function to initialize input/output operations for faster execution\\n    std::ios::sync_with_stdio(false); // Allows faster input/output\\n    std::cin.tie(nullptr); // Ensures input is synchronized with output\\n    std::cout.tie(nullptr); // Ensures output is synchronized with input\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        // Create an array to count the different types of stones\\n        auto count = array<int, 3>{};\\n        \\n        // Count the different types of stones\\n        for (auto stone : stones) {\\n            ++count[stone % 3];\\n        }\\n        \\n        // Check if the first player can win the game based on the stone counts\\n        return count[0] % 2 == 0 ?\\n            count[1] > 0 && count[2] > 0 :\\n            abs(count[1] - count[2]) > 2;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3604761,
                "title": "4-line-ruby-solution-with-detailed-explanation-100-100",
                "content": "# Intuition\\nThe actual numbers of stones don\\'t matter, just the values mod 3 and the number for each category.\\n\\n# Approach\\nCount the number of stones with remainders of 0, 1, and 2 when divided by 3.\\n\\nThe win conditions are a bit complicated, so here\\'s how it goes:\\n\\nIf there are an even number of three stones, we can ignore them (when one player takes one, the other can take one also, so it doesn\\'t change the poisition).\\n-In that case, Alice can win if there\\'s at least 1 one stone and at least one three stone.  Her stategy is to take from whichever pile is smaller (or either if they\\'re equal).  Bob will have to take from the same pile (pile 1), then Alice take from pile 2 and Bob will take from pile 1 until it runs out.  Eventually, Bob has to take from pile 2, making the total a multiple of 3.\\n-Conversely, if there are no one stones or no two stones, Alice takes from one pile, Bob takes from the same pile, and then Alice takes a third stone from that same pile, at which point it\\'s a multiple of three and Bob wins.  (Or the pile has fewer then 3 stones, it which case it runs out and Bob wins.)\\n\\nNow let\\'s consider the case with an odd number of three stones.  For simplicity, consider this to be 1 three stone.  Also, we\\'re going to pick ones as the bigger (or equal) pile; it\\'s equivalent for twos.\\n-If the ones pile is much bigger (at least 3 more), Alice can force a win by picking from the ones pile.  Bob picks one or three, Alice picks the other, and then Bob keeps picking two and Alice keeps picking one until the twos run out and Bob has to pick one.\\n\\nBob can force a win in all other cases:\\n-If the piles are equal or ones are 1 bigger, Bob picks three for his first pick, then keeps picking the opposite of what Alice picks.  Eventually, Alice runs out of stones.\\n-If ones are 2 bigger, Alice picks one and then Bob picks one, and then we have the situation of equal piles again.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef stone_game_ix(stones)\\n    count = Hash.new(0)\\n    stones.each { |stone| count[stone % 3] += 1 }\\n\\n    return count[1] * count[2] > 0 if count[0] % 2 == 0\\n    (count[1] - count[2]).abs > 2\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef stone_game_ix(stones)\\n    count = Hash.new(0)\\n    stones.each { |stone| count[stone % 3] += 1 }\\n\\n    return count[1] * count[2] > 0 if count[0] % 2 == 0\\n    (count[1] - count[2]).abs > 2\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3600242,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun stoneGameIX(stones: IntArray): Boolean {\\n        var m = IntArray(3){ 0 }\\n        stones.forEach{ m[it % 3]++ }\\n\\n        return if(m[0] % 2 == 0) m[1] > 0 && m[2] > 0 else Math.abs(m[1] - m[2]) > 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun stoneGameIX(stones: IntArray): Boolean {\\n        var m = IntArray(3){ 0 }\\n        stones.forEach{ m[it % 3]++ }\\n\\n        return if(m[0] % 2 == 0) m[1] > 0 && m[2] > 0 else Math.abs(m[1] - m[2]) > 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126443,
                "title": "lengthy-questions-but-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n\\t    int[] count = new int[3];\\n\\t    for(int stone:stones){\\n            count[stone%3]++;\\n        }\\n\\t    if(count[0] % 2 == 0 && (count[1] == 0 || count[2] == 0)) return false;\\n\\t    return count[0] % 2 == 1 && Math.abs(count[1] - count[2]) < 3 ? false : true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n\\t    int[] count = new int[3];\\n\\t    for(int stone:stones){\\n            count[stone%3]++;\\n        }\\n\\t    if(count[0] % 2 == 0 && (count[1] == 0 || count[2] == 0)) return false;\\n\\t    return count[0] % 2 == 1 && Math.abs(count[1] - count[2]) < 3 ? false : true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884311,
                "title": "long-and-detailed-easy-code-c-99-17-faster",
                "content": "```\\nbool getmod2( vector<int>arr , int n , int sum )\\n    {\\n       \\n        if( arr[sum] != 0 )\\n        {\\n            arr[sum]-- ;\\n        }\\n        else{\\n            return false ;\\n        }\\n        for( int i = 1 ; i < n ; i++ )\\n        {\\n            int r = sum%3 ;\\n            \\n            if( r == 0 )\\n            {\\n                if( arr[1] != 0 )\\n                {\\n                    sum += 1 ;\\n                    arr[1]-- ;\\n                }\\n                else if( arr[2] != 0 )\\n                {\\n                    sum += 2 ;\\n                    arr[2]-- ;\\n                }\\n                else{\\n                    \\n                    if( i%2 == 0 ) return false ;\\n                    else{\\n                        return true ;\\n                    }\\n                }\\n            }\\n            else if( r == 1 )\\n            {\\n                if( arr[0] != 0 )\\n                {\\n                    sum += 0 ;\\n                    arr[0]-- ;\\n                }\\n                else if( arr[1] != 0 )\\n                {\\n                    sum += 1 ;\\n                    arr[1]-- ;\\n                }\\n                else{\\n                    \\n                    if( i%2 == 0 ) return false ;\\n                    else{\\n                        return true ;\\n                    }\\n                }\\n            }\\n            else if( r == 2 )\\n            {\\n                if( arr[0] != 0 )\\n                {\\n                    sum += 0 ;\\n                    arr[0]-- ;\\n                }\\n                else if( arr[2] != 0 )\\n                {\\n                    sum += 2 ;\\n                    arr[2]-- ;\\n                }\\n                else{\\n                    \\n                    if( i%2 == 0 ) return false ;\\n                    else{\\n                        return true ;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false ;\\n    }\\n    \\n   \\n    bool stoneGameIX(vector<int>& stones) {\\n        \\n        \\n        vector<int>arr( 3 , 0 ) ;\\n        \\n        int n = stones.size()  ;\\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            arr[stones[i]%3]++ ;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        return getmod2( arr , n , 2 ) || getmod2( arr , n , 1 ) ;;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool getmod2( vector<int>arr , int n , int sum )\\n    {\\n       \\n        if( arr[sum] != 0 )\\n        {\\n            arr[sum]-- ;\\n        }\\n        else{\\n            return false ;\\n        }\\n        for( int i = 1 ; i < n ; i++ )\\n        {\\n            int r = sum%3 ;\\n            \\n            if( r == 0 )\\n            {\\n                if( arr[1] != 0 )\\n                {\\n                    sum += 1 ;\\n                    arr[1]-- ;\\n                }\\n                else if( arr[2] != 0 )\\n                {\\n                    sum += 2 ;\\n                    arr[2]-- ;\\n                }\\n                else{\\n                    \\n                    if( i%2 == 0 ) return false ;\\n                    else{\\n                        return true ;\\n                    }\\n                }\\n            }\\n            else if( r == 1 )\\n            {\\n                if( arr[0] != 0 )\\n                {\\n                    sum += 0 ;\\n                    arr[0]-- ;\\n                }\\n                else if( arr[1] != 0 )\\n                {\\n                    sum += 1 ;\\n                    arr[1]-- ;\\n                }\\n                else{\\n                    \\n                    if( i%2 == 0 ) return false ;\\n                    else{\\n                        return true ;\\n                    }\\n                }\\n            }\\n            else if( r == 2 )\\n            {\\n                if( arr[0] != 0 )\\n                {\\n                    sum += 0 ;\\n                    arr[0]-- ;\\n                }\\n                else if( arr[2] != 0 )\\n                {\\n                    sum += 2 ;\\n                    arr[2]-- ;\\n                }\\n                else{\\n                    \\n                    if( i%2 == 0 ) return false ;\\n                    else{\\n                        return true ;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false ;\\n    }\\n    \\n   \\n    bool stoneGameIX(vector<int>& stones) {\\n        \\n        \\n        vector<int>arr( 3 , 0 ) ;\\n        \\n        int n = stones.size()  ;\\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            arr[stones[i]%3]++ ;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        return getmod2( arr , n , 2 ) || getmod2( arr , n , 1 ) ;;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2719948,
                "title": "very-detailed-and-understandable-explanation",
                "content": "```\\n    bool stoneGameIX(vector<int>& stones) {\\n        vector<int> cnt(3);\\n        for (int num: stones) {\\n            cnt[num % 3]++;\\n        }\\n        // cnt[0] % 2 == 0 is equivalent to cnt[0] == 0, because a pair can be canceled out\\n        \\n        if (cnt[1] == 0 || cnt[2] == 0) {\\n            // if cnt[0] == 0, e.g. (1, 1, 1) then Alice lose\\n            // if max(cnt[1], cnt[2]) <= 2, then all numbers are exhausted, Alice lose\\n            // otherwise, Alice win, e.g. (1, 1, 1, 3)\\n            return cnt[0] % 2 == 1 && max(cnt[1], cnt[2]) >= 3;\\n        } else {\\n            // if there are both 1 and 2, then the pattern is\\n            //    [1, 1, 2, 1, 2, 1, 2...], after 1st step, Alice needs 2 and Bob needs 1\\n            // or [2, 2, 1, 2, 1, 2, 1...], after 1st step, Alice needs 1 and Bob needs 2\\n            // the one who runs out of 1 or 2 first will lose\\n            \\n            // if cnt[0] == 0, then Alice win by starting with lower-count one, and Bob will runs out first. e.g. (1, 1, 2, 2) => [2, 2, 1,  (Bob lose with no more 2)]\\n            if (cnt[0] % 2 == 0) {\\n                return true;\\n            }\\n            \\n            // now consider cnt[0] == 1, if abs(cnt[1] - cnt[2]) >= 3, Alice start with the higher-count one, this means Alice should lose, but since there is a 0, Alice can use it to force Bob to choose the lower one later\\n            // e.g. (1, 1, 1, 1, 2, 0) => \\n            // [1, 1, 0] + \"now Bob is forced to choose lower one\"\\n            // overall it\\'s [1, 1, 0, 2, 1,  (Bob lose with no more 2)]\\n            \\n            // what if Bob act first and use 0? the same outcome!\\n            // [1, 0, 1] + \"now Bob is forced to choose lower one\" \\n            // overall it\\'s [1, 0, 1, 2, 1,  (Bob lose with no more 2)]\\n            \\n            if (abs(cnt[1] - cnt[2]) >= 3) {\\n                return true;\\n            }\\n            \\n            // however, the above case needs at least 3 more 1 than 2, otherwise, all numbers are exhausted and Alice lose, e.g. (1, 0, 1, 2, 1)\\n            return false;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool stoneGameIX(vector<int>& stones) {\\n        vector<int> cnt(3);\\n        for (int num: stones) {\\n            cnt[num % 3]++;\\n        }\\n        // cnt[0] % 2 == 0 is equivalent to cnt[0] == 0, because a pair can be canceled out\\n        \\n        if (cnt[1] == 0 || cnt[2] == 0) {\\n            // if cnt[0] == 0, e.g. (1, 1, 1) then Alice lose\\n            // if max(cnt[1], cnt[2]) <= 2, then all numbers are exhausted, Alice lose\\n            // otherwise, Alice win, e.g. (1, 1, 1, 3)\\n            return cnt[0] % 2 == 1 && max(cnt[1], cnt[2]) >= 3;\\n        } else {\\n            // if there are both 1 and 2, then the pattern is\\n            //    [1, 1, 2, 1, 2, 1, 2...], after 1st step, Alice needs 2 and Bob needs 1\\n            // or [2, 2, 1, 2, 1, 2, 1...], after 1st step, Alice needs 1 and Bob needs 2\\n            // the one who runs out of 1 or 2 first will lose\\n            \\n            // if cnt[0] == 0, then Alice win by starting with lower-count one, and Bob will runs out first. e.g. (1, 1, 2, 2) => [2, 2, 1,  (Bob lose with no more 2)]\\n            if (cnt[0] % 2 == 0) {\\n                return true;\\n            }\\n            \\n            // now consider cnt[0] == 1, if abs(cnt[1] - cnt[2]) >= 3, Alice start with the higher-count one, this means Alice should lose, but since there is a 0, Alice can use it to force Bob to choose the lower one later\\n            // e.g. (1, 1, 1, 1, 2, 0) => \\n            // [1, 1, 0] + \"now Bob is forced to choose lower one\"\\n            // overall it\\'s [1, 1, 0, 2, 1,  (Bob lose with no more 2)]\\n            \\n            // what if Bob act first and use 0? the same outcome!\\n            // [1, 0, 1] + \"now Bob is forced to choose lower one\" \\n            // overall it\\'s [1, 0, 1, 2, 1,  (Bob lose with no more 2)]\\n            \\n            if (abs(cnt[1] - cnt[2]) >= 3) {\\n                return true;\\n            }\\n            \\n            // however, the above case needs at least 3 more 1 than 2, otherwise, all numbers are exhausted and Alice lose, e.g. (1, 0, 1, 2, 1)\\n            return false;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2642350,
                "title": "c-easy-to-understand-step-by-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     bool stoneGameIX(vector<int>& stones) {\\n        int cnt[3] = {};\\n        for (int a: stones)\\n            cnt[a % 3]++;\\n        if (min(cnt[1], cnt[2]) == 0)\\n            return max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0;\\n        return abs(cnt[1] - cnt[2]) > 2 || cnt[0] % 2 == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool stoneGameIX(vector<int>& stones) {\\n        int cnt[3] = {};\\n        for (int a: stones)\\n            cnt[a % 3]++;\\n        if (min(cnt[1], cnt[2]) == 0)\\n            return max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0;\\n        return abs(cnt[1] - cnt[2]) > 2 || cnt[0] % 2 == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472648,
                "title": "o-n-time-o-n-space-clear-explanation-game-theory",
                "content": "![image](https://assets.leetcode.com/users/images/fdf84d1e-c078-4a93-848d-4fdf33af2d2d_1661334051.3906698.png)\\n\\n\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        \"\"\" O(N)TS \"\"\"\\n        cnt = collections.Counter(n % 3 for n in stones)\\n        return abs(cnt[1]-cnt[2]) >= 3 if cnt[0] % 2 else cnt[1] and cnt[2]",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/fdf84d1e-c078-4a93-848d-4fdf33af2d2d_1661334051.3906698.png)\\n\\n\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        \"\"\" O(N)TS \"\"\"\\n        cnt = collections.Counter(n % 3 for n in stones)\\n        return abs(cnt[1]-cnt[2]) >= 3 if cnt[0] % 2 else cnt[1] and cnt[2]",
                "codeTag": "Python3"
            },
            {
                "id": 2449432,
                "title": "c-short-and-clean-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        vector<int> cnt(10, 0);\\n        for (auto val : stones) cnt[val%3]++;\\n        \\n        if (!cnt[1]&&!cnt[2]) return false;\\n        if (cnt[0] & 1)       return abs(cnt[1]-cnt[2])>=3;\\n        else                  return min(cnt[1],cnt[2])!=0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        vector<int> cnt(10, 0);\\n        for (auto val : stones) cnt[val%3]++;\\n        \\n        if (!cnt[1]&&!cnt[2]) return false;\\n        if (cnt[0] & 1)       return abs(cnt[1]-cnt[2])>=3;\\n        else                  return min(cnt[1],cnt[2])!=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276369,
                "title": "greedy-logical-approach-with-detailed-explanation",
                "content": "```\\n/*\\n\\n    the first player will always chose the number which gives a remainder > 0\\n    now whenever a player is playing, he should pick up some number such that the resultant sum is not divisible by 3\\n    there are a couple of cases\\n    1) the remainder of the sum of values picked up till now is 1\\n    2) the remainder of the sum of values picked up till now is 2\\n    \\n    it cannot be zero, because when it becomes zero the game ends\\n    \\n    in case 1 : the currrent player can only pick up some number which gives a remainder 1 or remainder 0\\n    in case 2 : the current player  can only pick up some number which gives a remainder 2 or 0\\n    \\n    see that 0 is useful in both cases, no we will avoid using 0 as much as possible\\n    means in case1, we will try to pick up guy with remainder 1, if it is not availble, we go for 0\\n    if both are not available the current player loses\\n    \\n    similarly in case2 we will try to pick up the one with remainder 2, if not availble, we are forced to look for 0\\n    if both are not available, the current player loses\\n    \\n*/\\nclass Solution {\\npublic:\\n    \\n    int f(int rem, vector<int> remCnt) {\\n        int turn = 1;\\n        \\n        while(remCnt[0] + remCnt[1] + remCnt[2] > 0) {\\n            \\n            if(rem == 1) {\\n                if(remCnt[1]) {\\n                    remCnt[1]--;\\n                    rem = 2;\\n                }\\n                else if(remCnt[0]) {\\n                    remCnt[0]--;\\n                    rem = 1;\\n                }\\n                else return turn != 0;\\n            } else {\\n                // when rem == 2;\\n                if(remCnt[2]) {\\n                    remCnt[2]--;\\n                    rem = 1;\\n                } else if(remCnt[0]) {\\n                    remCnt[0]--;\\n                    rem = 2;\\n                } else return turn != 0;\\n            }\\n            \\n            turn = 1 - turn;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool stoneGameIX(vector<int>& a) {\\n        int n = a.size();\\n        int turn = 1;\\n        \\n        \\n        vector<int> remCnt(3, 0);\\n        for(int x : a) remCnt[x%3]++;\\n        \\n        bool ans = false;\\n        if(remCnt[1] == 0  && remCnt[2] == 0) return false;\\n        if(remCnt[1]) {\\n            // player 0 starting off with 1\\n            remCnt[1]--;\\n            ans = ans  or f(1, remCnt);\\n            remCnt[1]++;\\n        }\\n        if(remCnt[2]) {\\n            // player 0 starting off with 2\\n            remCnt[2]--;\\n            ans = ans or f(2, remCnt);\\n            remCnt[2]++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n/*\\n\\n    the first player will always chose the number which gives a remainder > 0\\n    now whenever a player is playing, he should pick up some number such that the resultant sum is not divisible by 3\\n    there are a couple of cases\\n    1) the remainder of the sum of values picked up till now is 1\\n    2) the remainder of the sum of values picked up till now is 2\\n    \\n    it cannot be zero, because when it becomes zero the game ends\\n    \\n    in case 1 : the currrent player can only pick up some number which gives a remainder 1 or remainder 0\\n    in case 2 : the current player  can only pick up some number which gives a remainder 2 or 0\\n    \\n    see that 0 is useful in both cases, no we will avoid using 0 as much as possible\\n    means in case1, we will try to pick up guy with remainder 1, if it is not availble, we go for 0\\n    if both are not available the current player loses\\n    \\n    similarly in case2 we will try to pick up the one with remainder 2, if not availble, we are forced to look for 0\\n    if both are not available, the current player loses\\n    \\n*/\\nclass Solution {\\npublic:\\n    \\n    int f(int rem, vector<int> remCnt) {\\n        int turn = 1;\\n        \\n        while(remCnt[0] + remCnt[1] + remCnt[2] > 0) {\\n            \\n            if(rem == 1) {\\n                if(remCnt[1]) {\\n                    remCnt[1]--;\\n                    rem = 2;\\n                }\\n                else if(remCnt[0]) {\\n                    remCnt[0]--;\\n                    rem = 1;\\n                }\\n                else return turn != 0;\\n            } else {\\n                // when rem == 2;\\n                if(remCnt[2]) {\\n                    remCnt[2]--;\\n                    rem = 1;\\n                } else if(remCnt[0]) {\\n                    remCnt[0]--;\\n                    rem = 2;\\n                } else return turn != 0;\\n            }\\n            \\n            turn = 1 - turn;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool stoneGameIX(vector<int>& a) {\\n        int n = a.size();\\n        int turn = 1;\\n        \\n        \\n        vector<int> remCnt(3, 0);\\n        for(int x : a) remCnt[x%3]++;\\n        \\n        bool ans = false;\\n        if(remCnt[1] == 0  && remCnt[2] == 0) return false;\\n        if(remCnt[1]) {\\n            // player 0 starting off with 1\\n            remCnt[1]--;\\n            ans = ans  or f(1, remCnt);\\n            remCnt[1]++;\\n        }\\n        if(remCnt[2]) {\\n            // player 0 starting off with 2\\n            remCnt[2]--;\\n            ans = ans or f(2, remCnt);\\n            remCnt[2]++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085378,
                "title": "python-intuitive-mathematical-solution-o-n-time-essentially-o-1",
                "content": "The first thing you need to know is that, essentially, there are three types of numbers, namely: u (num % 3 == 1), d (% 3 == 2), t (num % 3 == 0).\\nThen, to make the problem easier, let\\'s talk about the case where t == 0 first (that is there are only u and d numbers).\\nAbove all, let\\'s say that Alice pick a u number, then Bob must also pick a u number. Then, Alice must pick a d number, and Bob must pick a u number...\\nSimilarly, if Alice starts with a d number, the following sequence is also very much fixed.\\nTo sum up, if there is no t number, the sequence must go like one of the following two for the game to continue:\\nuududududud....\\nor\\nddududududu....\\n\\nFrom observation of this, the only difference between u and d is that in the beginning, there is an extra u or d if it is picked first, and the following sequece is just u and d coming intertwined. That is, the biggest difference comes after picking the initial two numbers, and their difference becomes 2.\\nIt\\'s intuitively to think of, from here, that, if the difference between u and d number are larger than 2, then Alice will have the absolute control of the game by just pick **the type that has smaller amount** in the beginning, because in this way, she will start picking the other type starting the 3rd time, and she will always run up later than Bob so that in this way Bob has no way to win no matter what. Even if there are t numbers, Alice just need to play the other way around accordingly. Let\\'s call this the default situation.\\nNext, we talk about the case when Alice does not have complete control. Basically, these are the cases when there is no such a **smaller-amount number**. \\nThere are case when either player doesn\\'t have choice at all and let\\'s talk bout them first.\\n**Situation 1**: **part 1**: If there is no u or no d number, then the game is pretty much determined from the begining. Let\\'s say there are only [2,2,2] or [2,2,2,2], then Alice doesn\\'t have a choice but to lose. But if there are t numbers, the result will be reversed based on whether the amount of t numbers are odd or even. **Part 2**: notice that, based on the rule, if it\\'s [2] or [2,2], in both case Alice loses.\\n**Situation 2**: if u and d have the same amount, there is also no choice for either players, and the result can be deducted easily.\\n**Situation 3**: lastly, the most difficult part is that, u > 0 and d > 0 and the difference between u and d is smaller than 2. Then, though there seem to be choices for Alice, actually there isn\\'t. The easiest way to explain is that, no matter how, one of u and d must come to zero first compared to the other one, and, depending on who picked last, this situation is partly coming back to situation 1. Partly means the result also depends on who picked lastly before this. If it is Bobs, it is the same with sitation 1. If it is Alice, it\\'s on the contrary.\\n```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        u, d, t = 0, 0, 0\\n        for stone in stones:\\n            if stone % 3 == 1:\\n                u += 1\\n            elif stone % 3 == 2:\\n                d += 1\\n            else:\\n                t += 1\\n        if not u and d <= 2 or u <= 2 and not d: #situation 1 part 2\\n            return False\\n        if not u and d > 2 or u > 2 and not d: #situation 1 part 1\\n            if not t % 2:\\n                return False\\n            else:\\n                return True\\n        if u == d or abs(u - d) <= 2: #situation 2 and situation 3\\n            if t % 2:\\n                return False\\n            else:\\n                return True\\n        return True #default situation",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "The first thing you need to know is that, essentially, there are three types of numbers, namely: u (num % 3 == 1), d (% 3 == 2), t (num % 3 == 0).\\nThen, to make the problem easier, let\\'s talk about the case where t == 0 first (that is there are only u and d numbers).\\nAbove all, let\\'s say that Alice pick a u number, then Bob must also pick a u number. Then, Alice must pick a d number, and Bob must pick a u number...\\nSimilarly, if Alice starts with a d number, the following sequence is also very much fixed.\\nTo sum up, if there is no t number, the sequence must go like one of the following two for the game to continue:\\nuududududud....\\nor\\nddududududu....\\n\\nFrom observation of this, the only difference between u and d is that in the beginning, there is an extra u or d if it is picked first, and the following sequece is just u and d coming intertwined. That is, the biggest difference comes after picking the initial two numbers, and their difference becomes 2.\\nIt\\'s intuitively to think of, from here, that, if the difference between u and d number are larger than 2, then Alice will have the absolute control of the game by just pick **the type that has smaller amount** in the beginning, because in this way, she will start picking the other type starting the 3rd time, and she will always run up later than Bob so that in this way Bob has no way to win no matter what. Even if there are t numbers, Alice just need to play the other way around accordingly. Let\\'s call this the default situation.\\nNext, we talk about the case when Alice does not have complete control. Basically, these are the cases when there is no such a **smaller-amount number**. \\nThere are case when either player doesn\\'t have choice at all and let\\'s talk bout them first.\\n**Situation 1**: **part 1**: If there is no u or no d number, then the game is pretty much determined from the begining. Let\\'s say there are only [2,2,2] or [2,2,2,2], then Alice doesn\\'t have a choice but to lose. But if there are t numbers, the result will be reversed based on whether the amount of t numbers are odd or even. **Part 2**: notice that, based on the rule, if it\\'s [2] or [2,2], in both case Alice loses.\\n**Situation 2**: if u and d have the same amount, there is also no choice for either players, and the result can be deducted easily.\\n**Situation 3**: lastly, the most difficult part is that, u > 0 and d > 0 and the difference between u and d is smaller than 2. Then, though there seem to be choices for Alice, actually there isn\\'t. The easiest way to explain is that, no matter how, one of u and d must come to zero first compared to the other one, and, depending on who picked last, this situation is partly coming back to situation 1. Partly means the result also depends on who picked lastly before this. If it is Bobs, it is the same with sitation 1. If it is Alice, it\\'s on the contrary.\\n```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        u, d, t = 0, 0, 0\\n        for stone in stones:\\n            if stone % 3 == 1:\\n                u += 1\\n            elif stone % 3 == 2:\\n                d += 1\\n            else:\\n                t += 1\\n        if not u and d <= 2 or u <= 2 and not d: #situation 1 part 2\\n            return False\\n        if not u and d > 2 or u > 2 and not d: #situation 1 part 1\\n            if not t % 2:\\n                return False\\n            else:\\n                return True\\n        if u == d or abs(u - d) <= 2: #situation 2 and situation 3\\n            if t % 2:\\n                return False\\n            else:\\n                return True\\n        return True #default situation",
                "codeTag": "Java"
            },
            {
                "id": 1993546,
                "title": "o-n-rust-solution-with-explanation-using-state-machine",
                "content": "The state of the game is tied to the sum of the removed stones modulo 3. The stones\\' values can also be converted to modulo 3. \\n\\nThus there are three possible states for the game to be in: 0, 1, and 2 and three possible stone types: 0, 1, 2. We can represent the game as a DFA with starting state 0 (initially the sum is 0) and with transitions between states representing what would happen if a player removed such a stone from the remaining stones. The final state is state 0 again as the game ends as soon as the first person reaches a sum divisible by 3. \\n\\n![image](https://assets.leetcode.com/users/images/40a02a94-6574-4430-b9e8-fa5da3ab161e_1651300896.212427.png)\\n\\n\\nWe also add two special edges from node-1 and node-2 that uses a special stone `$` that transitions to the final state 0. We implicitly enforce the rule that this symbol appears after all the existing stones have been used up. Moving through any of the other edges also toggles the parity of the players but this special edge sets the player to Alice. The player that ends up in the final state 0 loses. \\n\\nNow, for a non-trivial game to begin there must be at least one stone 1 or one stone 2. These are used to oscillate between these states 1 and 2 and to formally end the game from these states. 0 stones are useful for skipping turns and hence they can toggle the parity of the players. Let `n0`, `n1` and `n2` represent the counts of stones 0, 1 and 2 respectively. \\n\\nLet us take `nx` and `nn` to be the respective maximum and minimum of `n1` and `n2`. WLOG (only because this is a ring modulo 3) let us use state/stone `x` to represent that state/stone which corresponds to `nx` stones and state/stone `n` to represent that state/stone which corresponds to `nn`. Stone `x` takes us from state `x` to state `n` and vice versa. Stone `n` in state `x` is \"poisonous\" as it can be used to formally end the game, and vice versa. \\n\\nAs the modulus operation forms a ring that is closed under addition, we can consider stone-0 parity switching operation separately from the oscillating operation between nodes `x` and `n`. Since both players are playing optimally, neither of them would want to prematurely terminate the game with a \"poisonous\" stone in the middle and they will try to battle it out till there is no option left but for one of the players to take the poision stone and lose the game or Alice loses the game when all the stones run out. \\n\\nSay we first start off the game with stone `x`. Now we are left with `nx-1` stones of type `x` and we are also in state `x`.\\n\\nFor oscillating between `x` and `n` we have three cases when it comes to where we finally land and what the player\\'s parity might be:\\n\\n**Case-1:** `nx-1 < nn`\\nThis case is possible only when `nx == nn`. So `nx-1 = nn-1`. \\n\\nIn this case we will end up getting stuck at state `x` back again with player Bob to make the next move, as we will eventually run out of `x` stones to go back to state `n`. And we will have one extra stone of type `n` for the final player to lose the game. Till that time we toggle the parity of the players until we run out of stone-0. \\n\\n**Case-2:** `nx-1 == nn`\\nIn this case we will run out of stones as we vacillate and land at state x again with Bob to make the next move, and after toggling the parity of the players with stone 0s, there won\\'t be a final \"poison pill\" for the unlucky player to formally end the game with. This means that Alice will lose the game according to the rules. \\n\\n**Case-3:** `nx-1 > nn`\\nIn this case there is a subtle edge case where we need to enforce `nx - nn > 2` for us to finally land in state `n` with Alice to make the next move, and with at least one \"poison\" stone `x` using which one of the players can formally enter state 0 after toggling their parities with stone 0. Otherwise if `nx == nn + 2` we will end up in state `n` without the poison stone `x` to end the game. This way Alice will end up losing the game inevitably after all the 0 stones are used up.\\n\\nWhenever we have a poison option the parity of the player (Alice = 0; Bob = 1) who is to make the next move must *not* match the parity of `n0` in order for them to win. This means that in case-1 and case-2 we want `n0%2 == 0` and in case-3 we want `n0%2 == 1`. \\n\\nSo putting all this together we see that if we pick `x` stone first to start off the game, we win only if `(nx > nn + 2 && n0%2 == 1) || (nx == nn && nn > 0 && n0%2 == 0)`. Note that the condition for entry that `nx > 0` is satisfied in both of these because `nn > 0`. \\n\\nIf we start off with stone `n` after entry into state `n` we will have `nn-1` stones of type `n`. Now we only have the one case for oscillation: `nn-1 < nx`, which will always be true. So similar to case-1 we will end up in state `n` back again with player Bob to make the next move and with at least one poison stone of type `x` to formally end the game. \\n\\nSo we have `(nn > 0 && n0%2 == 0)` for Alice to win. Note that the case where `nx-1 == nn` where Alice would have definitely lost had she picked stone `x` first turns into a possible win for Alice if she just picks stone `n` first. And of course, when `nx == nn` it does not matter which stone we pick. \\n\\nCombining the two together we get this simplified condition:\\n\\n`(nx > nn + 2 && n0%2 == 1) || (nn > 0 && n0%2 == 0)`\\n\\nThe following is the Rust code implementing this logic\\n```rust\\nuse std::cmp::{min, max};\\n\\nimpl Solution {\\n    pub fn stone_game_ix(stones: Vec<i32>) -> bool {\\n        let (n0, n1, n2) = stones.into_iter()\\n                            .map(|stone| ((stone%3 == 0), (stone%3 == 1), (stone%3 == 2))) // tuple of bool\\n                            .map(|(n0, n1, n2)| (n0 as usize, n1 as usize, n2 as usize)) // tuple of 1s for true and 0s for false\\n                            .fold((0, 0, 0), |(nacc0, nacc1, nacc2), (n0, n1, n2)| (nacc0+n0, nacc1+n1, nacc2+n2));\\n        \\n        let nx = max(n1, n2);\\n        let nn = min(n1, n2);\\n        \\n        (nn != 0 && n0%2 == 0) || (nx > nn + 2 && n0%2 == 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::{min, max};\\n\\nimpl Solution {\\n    pub fn stone_game_ix(stones: Vec<i32>) -> bool {\\n        let (n0, n1, n2) = stones.into_iter()\\n                            .map(|stone| ((stone%3 == 0), (stone%3 == 1), (stone%3 == 2))) // tuple of bool\\n                            .map(|(n0, n1, n2)| (n0 as usize, n1 as usize, n2 as usize)) // tuple of 1s for true and 0s for false\\n                            .fold((0, 0, 0), |(nacc0, nacc1, nacc2), (n0, n1, n2)| (nacc0+n0, nacc1+n1, nacc2+n2));\\n        \\n        let nx = max(n1, n2);\\n        let nn = min(n1, n2);\\n        \\n        (nn != 0 && n0%2 == 0) || (nx > nn + 2 && n0%2 == 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673061,
                "title": "simple-intutive-solution",
                "content": "Approach:\\n     1. Alice starts with 1 or 2 and on each turn look for option that avoids the sum to be multiple of 3.\\n     2. Ex: If sum is 1 look for 1 or 0 and if sum is 2 look for 2 or 0.\\n     3. Lastly if number of turns played is divisble by 2 or is equal to len of stones Bob or else Alice wins .\\n\\n```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        def solve(x):\\n            d = defaultdict(lambda:0)\\n            for y in stones:\\n                d[y%3]+=1\\n            sums = 0\\n            if d[x]==0:\\n                return False \\n            d[x]-=1\\n            sums+=x\\n            res = 1\\n            while(sums%3!=0):\\n                if sums%3==1:\\n                    if d[1]>0:\\n                        d[1]-=1\\n                        sums = 2\\n                    elif d[1]==0 and d[0]>0:\\n                        d[0]-=1\\n                        sums = 1 \\n                    else:\\n                        break\\n                else:\\n                    if d[2]>0:\\n                        d[2]-=1\\n                        sums = 1\\n                    elif d[2]==0 and d[0]>0:\\n                        d[0]-=1\\n                        sums = 2\\n                    else:\\n                        break \\n                res+=1\\n            if res!=len(stones) and res%2==1:\\n                return True \\n            return False \\n        if solve(1) or solve(2):\\n            return True \\n        return False \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        def solve(x):\\n            d = defaultdict(lambda:0)\\n            for y in stones:\\n                d[y%3]+=1\\n            sums = 0\\n            if d[x]==0:\\n                return False \\n            d[x]-=1\\n            sums+=x\\n            res = 1\\n            while(sums%3!=0):\\n                if sums%3==1:\\n                    if d[1]>0:\\n                        d[1]-=1\\n                        sums = 2\\n                    elif d[1]==0 and d[0]>0:\\n                        d[0]-=1\\n                        sums = 1 \\n                    else:\\n                        break\\n                else:\\n                    if d[2]>0:\\n                        d[2]-=1\\n                        sums = 1\\n                    elif d[2]==0 and d[0]>0:\\n                        d[0]-=1\\n                        sums = 2\\n                    else:\\n                        break \\n                res+=1\\n            if res!=len(stones) and res%2==1:\\n                return True \\n            return False \\n        if solve(1) or solve(2):\\n            return True \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651879,
                "title": "python-beat-99-with-line-by-line-touch-up",
                "content": "Read through blogs listed, but constantly stuck at \"who and when to do the flip?\".\\nAssume I am either Alice or Bob, why and when I would do flip? \\nFor some context, please refer to [here](https://leetcode.com/problems/stone-game-ix/discuss/1514529/simulation-solution) or [here](https://leetcode.com/problems/stone-game-ix/discuss/1500245/JavaC%2B%2BPython-Easy-and-Concise-6-lines-O(n)).\\nThen by some rumination, found the answer to the question - whenever possible (meaning mod[0]%2 == 1), Alice will do flipping on her second shot.\\nBefore explaining why, let\\'s first look at case when no flipping is possible, meaning mod[0]%2 is 0, under this occasion Alice would always win by picking the mod that is less. For example, suppose we have [1,1,2,2,2], then mod[1] is 2 and mod[2] is 3, by having Alice taking 1, we will have:\\n\\n```\\nA B A B A B\\n1 1 2 ?\\n```\\n\\nB lose the game.\\nBut what if the mod that is less is zero so Alice has to pick the bigger one? \\nBob would win. For example, if we have [1]:\\n\\n```\\nA B A B\\n1 \\n```\\nB wins by running out of options. If we have [1,1]:\\n\\n```\\nA B A B\\n1 1 \\n```\\nSame as above, then what if it is [1,1,1]?\\n\\n```\\nA B A B A\\n1 1 ?\\n```\\nThis is no 2, so A lose.\\nThat\\'s all for mod[0]%2 == 0.\\n\\nThen for mod[0]%2==1, what strategy should A take to maximize the chance of winning? The anwer is rightly the opposite - A will start with mod that is bigger. For example, if we have [3,1,1,2,2,2,2], then mod[1] is 2 and mod[2] is 4, A **must not** start with 1 because B will immeidately use flipping to prevent A\\'s holding of 2 since the 3rd rd:\\n\\n```\\nA B A B A B\\n1 0 1 2 ?\\n```\\n\\nBy B flipping at 2nd rd (and he will), A will be forced to stick to the mod that is less, and thereby bound to loss in the end. \\nSo, how about letting A start with the mod that has more occurrance? \\n\\n```\\nA B A B A B A B \\n2 2 0 1 2 1 2 \\n```\\n\\nBe taking the bigger mod and flipping at 3rd rd, A would withhold her ownership of the mod that has more occurrance and gurrantee her victory - wait ... in above case Alice still lose, why?\\nBecause the mod are exhausted! So we have to assure Alice\\'s success by a condition:\\n\\n```\\nmod[more] - mod[less] >= 3\\n```\\n\\nFor example, suppose we now have [3,1,1,2,2,2,2,2], mod[2] - mod[1] = 3, then the story would be like:\\n\\n```\\nA B A B A B A B\\n2 2 0 1 2 1 2 ?\\n```\\n\\nNow B lose since he needs 1 but only another 2 left!\\nHence we have the code:\\n\\n```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        mods = [0] * 3\\n        for stone in stones: mods[stone%3] += 1\\n        if mods[0]%2 == 0:\\n            if mods[1] == 0 or mods[2] == 0: return False\\n            return True\\n        else:\\n            if abs(mods[1]-mods[2]) >= 3: return True\\n            return False\\n```\\n\\nBefore ending the doc, why not B do flipping on his first turn even that A start with 2 for [3,1,1,2,2,2,2,2]?\\nLike:\\n\\n```\\nA B A B A B A B\\n2 0 2 1 2 1 2 ?\\n```\\n\\nSee the problem here? B\\'s flipping makes little difference since A gets the winning mod(2) whatsoever, so why bother? \\nFinally, if asked with this problem during an interview, don\\'t think I could make it.",
                "solutionTags": [],
                "code": "```\\nA B A B A B\\n1 1 2 ?\\n```\n```\\nA B A B\\n1 \\n```\n```\\nA B A B\\n1 1 \\n```\n```\\nA B A B A\\n1 1 ?\\n```\n```\\nA B A B A B\\n1 0 1 2 ?\\n```\n```\\nA B A B A B A B \\n2 2 0 1 2 1 2 \\n```\n```\\nmod[more] - mod[less] >= 3\\n```\n```\\nA B A B A B A B\\n2 2 0 1 2 1 2 ?\\n```\n```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        mods = [0] * 3\\n        for stone in stones: mods[stone%3] += 1\\n        if mods[0]%2 == 0:\\n            if mods[1] == 0 or mods[2] == 0: return False\\n            return True\\n        else:\\n            if abs(mods[1]-mods[2]) >= 3: return True\\n            return False\\n```\n```\\nA B A B A B A B\\n2 0 2 1 2 1 2 ?\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571382,
                "title": "why-my-solution-passes-51-106-test-cases",
                "content": "```Fails on:```\\nInput: [1,1,7,10,8,17,10,20,2,10]\\nOutput: false\\nExpected: true\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        int n = stones.size();\\n        int sum=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int begin=0;\\n            while(begin<stones.size() && (sum+stones[begin])%3==0)\\n            {\\n                begin++;\\n            }\\n            if(begin==stones.size())return i%2==0 ? false : true;\\n            sum+=stones[begin];\\n            stones.erase(stones.begin()+begin);\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```Fails on:```\n```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        int n = stones.size();\\n        int sum=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int begin=0;\\n            while(begin<stones.size() && (sum+stones[begin])%3==0)\\n            {\\n                begin++;\\n            }\\n            if(begin==stones.size())return i%2==0 ? false : true;\\n            sum+=stones[begin];\\n            stones.erase(stones.begin()+begin);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535834,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        mod = {}\\n        mod[0] = 0\\n        mod[1] = 0\\n        mod[2] = 0\\n        for i in stones:\\n            mod[i%3] += 1\\n        if(mod[0]%2==0):\\n            if(min(mod[1],mod[2])==0):\\n                return False\\n            else:\\n                return True\\n        else:\\n            if(abs(mod[1]-mod[2])>2):\\n                return True\\n            else:\\n                return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        mod = {}\\n        mod[0] = 0\\n        mod[1] = 0\\n        mod[2] = 0\\n        for i in stones:\\n            mod[i%3] += 1\\n        if(mod[0]%2==0):\\n            if(min(mod[1],mod[2])==0):\\n                return False\\n            else:\\n                return True\\n        else:\\n            if(abs(mod[1]-mod[2])>2):\\n                return True\\n            else:\\n                return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514529,
                "title": "simulation-solution",
                "content": "This question is down voted heavily because many can\\'t solve it and top rated solutions answer it by constructing complex rules. This make it a brain teaser.\\n\\nThe key insights are few\\n\\n* Convert each stone to mod 3 results: 0, 1, or 2.\\n* If there\\'s no \"0\", after alice choose 1 or 2, each player\\'s decision is determined. They must pick 2 if current sum is mod 2 or pick 1 if current sum is mod 1. Then the sum switch between mod 1 and mod 2.\\n* If the number of zero is even, it\\'s as if there\\'s no \"0\", because whoever for all Alice\\'s winning play, if Bob pick one zero to divert the game from the plan, Alice can pick another zero to move it back.\\n* If the numer of zero is odd, it\\'s as if there\\'s only one \"0\". Whenever that zero is picked, Alick and Bob switch position. Then Alice\\'s winning play must assume it is picked because Bob can choose to pick it or not.\\n\\n```python\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        count = [0] * 3\\n        for v in stones:\\n            count[v % 3] += 1\\n        flip = count[0] % 2 == 1\\n        \\n        print(count)\\n        \\n        def switch(who):\\n            return \\'alice\\' if who == \\'bob\\' else \\'bob\\'\\n        \\n        def alice_win(who, status, one, two):\\n            if one + two == 0:\\n                return False\\n            #print(who, status, one, two)\\n            assert status in (1, 2)\\n            if status == 1:\\n                if one == 0:\\n                    return who == \\'bob\\'\\n                return alice_win(switch(who), 2, one-1, two)\\n            if status == 2:\\n                if two == 0:\\n                    return who == \\'bob\\'\\n                return alice_win(switch(who), 1, one, two-1)\\n            \\n        if count[1] > 0:\\n            if not flip and alice_win(\\'bob\\', 1, count[1]-1, count[2]):\\n                return True\\n            if flip and alice_win(\\'alice\\', 1, count[1]-1, count[2]):\\n                return True\\n\\n        if count[2] > 0:\\n            if not flip and alice_win(\\'bob\\', 2, count[1], count[2]-1):\\n                return True\\n            if flip and alice_win(\\'alice\\', 2, count[1], count[2]-1):\\n                return True\\n            \\n        return False   \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        count = [0] * 3\\n        for v in stones:\\n            count[v % 3] += 1\\n        flip = count[0] % 2 == 1\\n        \\n        print(count)\\n        \\n        def switch(who):\\n            return \\'alice\\' if who == \\'bob\\' else \\'bob\\'\\n        \\n        def alice_win(who, status, one, two):\\n            if one + two == 0:\\n                return False\\n            #print(who, status, one, two)\\n            assert status in (1, 2)\\n            if status == 1:\\n                if one == 0:\\n                    return who == \\'bob\\'\\n                return alice_win(switch(who), 2, one-1, two)\\n            if status == 2:\\n                if two == 0:\\n                    return who == \\'bob\\'\\n                return alice_win(switch(who), 1, one, two-1)\\n            \\n        if count[1] > 0:\\n            if not flip and alice_win(\\'bob\\', 1, count[1]-1, count[2]):\\n                return True\\n            if flip and alice_win(\\'alice\\', 1, count[1]-1, count[2]):\\n                return True\\n\\n        if count[2] > 0:\\n            if not flip and alice_win(\\'bob\\', 2, count[1], count[2]-1):\\n                return True\\n            if flip and alice_win(\\'alice\\', 2, count[1], count[2]-1):\\n                return True\\n            \\n        return False   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510565,
                "title": "question-about-the-problem",
                "content": "Is there a reason why my code isnt returning the desired output leetCode wants,\\nI assumed that Alice or Bob will pick the first stone that when added to the sum wont be divisible by 3, and it\\'s working how I anticipated, can anyone explain what optimall means in the description?\\n\\nThank you\\n\\n```\\nclass Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n         //Whatever Alice plays if its only one stone, she is destined to lose\\n\\t\\t if(stones.length == 1)\\n             return false;\\n\\t\\t\\t \\n        return helper(stones,0,true);\\n    }\\n    \\n    public boolean helper(int[] stones, int sum,boolean turn){\\n        //if not stones are left and the game hasn\\'t stopped until now , Bob automaticlly wins\\n\\t\\tif(stones.length == 0)\\n            return false;\\n        \\n            // creating another array with one less stone\\n        int[] temp = new int[stones.length-1];\\n        \\n\\t\\t//checking for a stone that when added to the sum, it isnt divisible by 3\\n        for(int i = 0 ; i< stones.length;i++){\\n            if((stones[i]+sum)%3 != 0){\\n                int k = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//filling the temp array\\n                for(int j = 0 ; j<temp.length;j++){\\n                    if(j == i){\\n                          k++;\\n                    }\\n                    temp[j] = stones[j+k];\\n                }\\n\\t\\t\\t\\t//continuing the game\\n            return true && helper(temp,sum+stones[i],!turn);\\n            }\\n    }\\n\\t  //if every stone when added to sum is divisble by 3 then the current player loses\\n        return !turn;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n         //Whatever Alice plays if its only one stone, she is destined to lose\\n\\t\\t if(stones.length == 1)\\n             return false;\\n\\t\\t\\t \\n        return helper(stones,0,true);\\n    }\\n    \\n    public boolean helper(int[] stones, int sum,boolean turn){\\n        //if not stones are left and the game hasn\\'t stopped until now , Bob automaticlly wins\\n\\t\\tif(stones.length == 0)\\n            return false;\\n        \\n            // creating another array with one less stone\\n        int[] temp = new int[stones.length-1];\\n        \\n\\t\\t//checking for a stone that when added to the sum, it isnt divisible by 3\\n        for(int i = 0 ; i< stones.length;i++){\\n            if((stones[i]+sum)%3 != 0){\\n                int k = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//filling the temp array\\n                for(int j = 0 ; j<temp.length;j++){\\n                    if(j == i){\\n                          k++;\\n                    }\\n                    temp[j] = stones[j+k];\\n                }\\n\\t\\t\\t\\t//continuing the game\\n            return true && helper(temp,sum+stones[i],!turn);\\n            }\\n    }\\n\\t  //if every stone when added to sum is divisble by 3 then the current player loses\\n        return !turn;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510479,
                "title": "c-dfs-with-explanation",
                "content": "<b>Idea</b>\\nThe obvious strategy of every player is :\\n1. If any move is left which will form a number not divisible by 3, then the player will choose that move and continue the game.\\n2. If no such move is left, the player looses the game\\n3. At last, if no move is left, then Bob is the obvious winner ( as per the question ).\\n\\nNote that since Alice starts first, she has the freedom to decide which out of 1 or 2 ( if available ) she has to pick in order to win. Rest is simple dfs.\\nTime : O(n)\\n```\\nclass Solution {\\npublic:\\nbool help(vector<int> &v,int sum,bool aliceTurn){\\n    if(sum==1 && v[1]){\\n        v[1]--;\\n        bool tmp=help(v,(sum+1)%3,!aliceTurn);\\n        v[1]++;\\n        return tmp;\\n    }else if(sum==1 && v[0]){\\n        v[0]--;\\n        bool tmp=help(v,sum,!aliceTurn);\\n        v[0]++;\\n        return tmp;\\n    }else if(sum==2 && v[2]){\\n        v[2]--;\\n        bool tmp=help(v,(sum+2)%3,!aliceTurn);\\n        v[2]++;\\n        return tmp;\\n    }else if(sum==2 && v[0]){\\n        v[0]--;\\n        bool tmp=help(v,sum,!aliceTurn);\\n        v[0]++;\\n        return tmp;        \\n    }else if(max({v[0],v[1],v[2]})){\\n        // a divisible of 3 is formed by the current player\\n        if(aliceTurn) return false;\\n        return true;\\n    }else{\\n        // nothing left\\n        return false;   //  bob wins\\n    }\\n}\\n\\nbool stoneGameIX(vector<int>& ar) {\\n    vector<int> v(3, 0);\\n    for (auto it : ar) v[it % 3]++;\\n    bool aliceWins=false;\\n    if(v[1]){\\n        v[1]--;\\n        aliceWins=(aliceWins||help(v,1,false));\\n        v[1]++;\\n    }\\n    if(v[2]){\\n        v[2]--;\\n        aliceWins=(aliceWins||help(v,2,false));\\n        v[2]++;\\n    }\\n    return aliceWins;\\n}\\n};\\n```\\n\\n<b>Note</b> that this code is also accepted. The only change is changing the position of `if(sum==1 && v[1])` and `if(sum==1 && v[0])`  in the <b>help</b> function . ( which implies there\\'s no compulsion to choose 1 instead of 2 or vice versa if both options are available ). \\n```\\nclass Solution {\\npublic:\\nbool help(vector<int> &v,int sum,bool aliceTurn){\\n    if(sum==2 && v[2]){\\n        v[2]--;\\n        bool tmp=help(v,(sum+2)%3,!aliceTurn);\\n        v[2]++;\\n        return tmp;\\n    }else if(sum==2 && v[0]){\\n        v[0]--;\\n        bool tmp=help(v,sum,!aliceTurn);\\n        v[0]++;\\n        return tmp;        \\n    }else if(sum==1 && v[1]){\\n        v[1]--;\\n        bool tmp=help(v,(sum+1)%3,!aliceTurn);\\n        v[1]++;\\n        return tmp;\\n    }else if(sum==1 && v[0]){\\n        v[0]--;\\n        bool tmp=help(v,sum,!aliceTurn);\\n        v[0]++;\\n        return tmp;\\n    }else if(max({v[0],v[1],v[2]})){\\n        // a divisible of 3 is formed by the current player\\n        if(aliceTurn) return false;\\n        return true;\\n    }else{\\n        // nothing left\\n        return false;   //  bob wins\\n    }\\n}\\n\\nbool stoneGameIX(vector<int>& ar) {\\n    vector<int> v(3, 0);\\n    for (auto it : ar) v[it % 3]++;\\n    bool aliceWins=false;\\n    if(v[1]){\\n        v[1]--;\\n        aliceWins=(aliceWins||help(v,1,false));\\n        v[1]++;\\n    }\\n    if(v[2]){\\n        v[2]--;\\n        aliceWins=(aliceWins||help(v,2,false));\\n        v[2]++;\\n    }\\n    return aliceWins;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nbool help(vector<int> &v,int sum,bool aliceTurn){\\n    if(sum==1 && v[1]){\\n        v[1]--;\\n        bool tmp=help(v,(sum+1)%3,!aliceTurn);\\n        v[1]++;\\n        return tmp;\\n    }else if(sum==1 && v[0]){\\n        v[0]--;\\n        bool tmp=help(v,sum,!aliceTurn);\\n        v[0]++;\\n        return tmp;\\n    }else if(sum==2 && v[2]){\\n        v[2]--;\\n        bool tmp=help(v,(sum+2)%3,!aliceTurn);\\n        v[2]++;\\n        return tmp;\\n    }else if(sum==2 && v[0]){\\n        v[0]--;\\n        bool tmp=help(v,sum,!aliceTurn);\\n        v[0]++;\\n        return tmp;        \\n    }else if(max({v[0],v[1],v[2]})){\\n        // a divisible of 3 is formed by the current player\\n        if(aliceTurn) return false;\\n        return true;\\n    }else{\\n        // nothing left\\n        return false;   //  bob wins\\n    }\\n}\\n\\nbool stoneGameIX(vector<int>& ar) {\\n    vector<int> v(3, 0);\\n    for (auto it : ar) v[it % 3]++;\\n    bool aliceWins=false;\\n    if(v[1]){\\n        v[1]--;\\n        aliceWins=(aliceWins||help(v,1,false));\\n        v[1]++;\\n    }\\n    if(v[2]){\\n        v[2]--;\\n        aliceWins=(aliceWins||help(v,2,false));\\n        v[2]++;\\n    }\\n    return aliceWins;\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\nbool help(vector<int> &v,int sum,bool aliceTurn){\\n    if(sum==2 && v[2]){\\n        v[2]--;\\n        bool tmp=help(v,(sum+2)%3,!aliceTurn);\\n        v[2]++;\\n        return tmp;\\n    }else if(sum==2 && v[0]){\\n        v[0]--;\\n        bool tmp=help(v,sum,!aliceTurn);\\n        v[0]++;\\n        return tmp;        \\n    }else if(sum==1 && v[1]){\\n        v[1]--;\\n        bool tmp=help(v,(sum+1)%3,!aliceTurn);\\n        v[1]++;\\n        return tmp;\\n    }else if(sum==1 && v[0]){\\n        v[0]--;\\n        bool tmp=help(v,sum,!aliceTurn);\\n        v[0]++;\\n        return tmp;\\n    }else if(max({v[0],v[1],v[2]})){\\n        // a divisible of 3 is formed by the current player\\n        if(aliceTurn) return false;\\n        return true;\\n    }else{\\n        // nothing left\\n        return false;   //  bob wins\\n    }\\n}\\n\\nbool stoneGameIX(vector<int>& ar) {\\n    vector<int> v(3, 0);\\n    for (auto it : ar) v[it % 3]++;\\n    bool aliceWins=false;\\n    if(v[1]){\\n        v[1]--;\\n        aliceWins=(aliceWins||help(v,1,false));\\n        v[1]++;\\n    }\\n    if(v[2]){\\n        v[2]--;\\n        aliceWins=(aliceWins||help(v,2,false));\\n        v[2]++;\\n    }\\n    return aliceWins;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503819,
                "title": "java-easy-to-understand-guarnteed",
                "content": "```\\nclass Solution {\\n    int[] stones;\\n    public boolean stoneGameIX(int[] stones) {\\n        this.stones = stones;\\n        int [] freq = new int[3];\\n        \\n        for (int i : stones) {\\n            if (i % 3 == 0) freq[0]++;\\n            else if (i % 3 == 1) freq[1]++;\\n            else freq[2]++;\\n        }\\n        \\n        boolean A = false;\\n        boolean B = false;\\n        int[] a = freq.clone();\\n        int[] b = freq.clone();\\n        if (a[1] > 0) {\\n            a[1]--;\\n            A = fun(a, 1);\\n        }\\n        if (b[2] > 0) {\\n            b[2]--;\\n            B = fun(b, 2);\\n        }\\n        return A || B ;\\n    }\\n    \\n    private boolean fun (int[] freq, int sum) {\\n        int n = stones.length;\\n        int i = 1;\\n        while (i < n) {\\n            if (i % 2 == 0) {   // alice turn\\n                if (sum % 3 == 1) {\\n                    if (freq[0] > 0) freq[0]--;\\n                    else if (freq[1] > 0) {\\n                        freq[1]--;\\n                        sum += 1;\\n                    } else return false;\\n                    \\n                } else if (sum % 3 == 2) {\\n                    if (freq[0] > 0) freq[0]--;\\n                    else if (freq[2] > 0) {\\n                        freq[2]--;\\n                        sum += 2;\\n                    }\\n                    else return false;\\n                }\\n                    \\n            } else {    // bob\\'s turn\\n                if (sum % 3 == 2) {\\n                    if (freq[0] > 0) freq[0]--;\\n                    else if (freq[2] > 0) {\\n                        freq[2]--;\\n                        sum += 2;\\n                    }\\n                    else return true;\\n                    \\n                } else if (sum % 3 == 1) {\\n                    if (freq[0] > 0) freq[0]--;\\n                    else if (freq[1] > 0) {\\n                        freq[1]--;\\n                        sum += 1;\\n                    } else return true;\\n                }\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] stones;\\n    public boolean stoneGameIX(int[] stones) {\\n        this.stones = stones;\\n        int [] freq = new int[3];\\n        \\n        for (int i : stones) {\\n            if (i % 3 == 0) freq[0]++;\\n            else if (i % 3 == 1) freq[1]++;\\n            else freq[2]++;\\n        }\\n        \\n        boolean A = false;\\n        boolean B = false;\\n        int[] a = freq.clone();\\n        int[] b = freq.clone();\\n        if (a[1] > 0) {\\n            a[1]--;\\n            A = fun(a, 1);\\n        }\\n        if (b[2] > 0) {\\n            b[2]--;\\n            B = fun(b, 2);\\n        }\\n        return A || B ;\\n    }\\n    \\n    private boolean fun (int[] freq, int sum) {\\n        int n = stones.length;\\n        int i = 1;\\n        while (i < n) {\\n            if (i % 2 == 0) {   // alice turn\\n                if (sum % 3 == 1) {\\n                    if (freq[0] > 0) freq[0]--;\\n                    else if (freq[1] > 0) {\\n                        freq[1]--;\\n                        sum += 1;\\n                    } else return false;\\n                    \\n                } else if (sum % 3 == 2) {\\n                    if (freq[0] > 0) freq[0]--;\\n                    else if (freq[2] > 0) {\\n                        freq[2]--;\\n                        sum += 2;\\n                    }\\n                    else return false;\\n                }\\n                    \\n            } else {    // bob\\'s turn\\n                if (sum % 3 == 2) {\\n                    if (freq[0] > 0) freq[0]--;\\n                    else if (freq[2] > 0) {\\n                        freq[2]--;\\n                        sum += 2;\\n                    }\\n                    else return true;\\n                    \\n                } else if (sum % 3 == 1) {\\n                    if (freq[0] > 0) freq[0]--;\\n                    else if (freq[1] > 0) {\\n                        freq[1]--;\\n                        sum += 1;\\n                    } else return true;\\n                }\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503659,
                "title": "golang-one-pass-o-1-memory",
                "content": "1. We can thow away any even number of stones with stones[i]%3==0 because player wi winning strategy can play it\\'s game until opponent not take stones[i]%3==0 and at next move take stones[j]%3==0\\n2. If we hane no stones divisable by 3, Alice strategy is take more deficite stone by first move. She wins always except all stones with the same modulo 3.\\n3. If we have one stone%3==0 (odd number of them), Alice should take most popular modulo by first move and take stone%3==0 only if she have no other moves. Alice wins if abs(cnt2-cnt1)>2\\n\\n\\n```\\nfunc stoneGameIX(stones []int) bool {\\n    rest:=make([]int,3)\\n    for _,v := range stones {\\n        rest[v%3]++\\n    }\\n    if rest[1]<rest[2] {\\n        rest[1],rest[2] = rest[2],rest[1]\\n    }\\n    if rest[0] %2 == 0 {\\n        if rest[2] == 0 {\\n            return false\\n        }\\n        return true\\n    } \\n    return rest[1] - rest[2]>2\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc stoneGameIX(stones []int) bool {\\n    rest:=make([]int,3)\\n    for _,v := range stones {\\n        rest[v%3]++\\n    }\\n    if rest[1]<rest[2] {\\n        rest[1],rest[2] = rest[2],rest[1]\\n    }\\n    if rest[0] %2 == 0 {\\n        if rest[2] == 0 {\\n            return false\\n        }\\n        return true\\n    } \\n    return rest[1] - rest[2]>2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502622,
                "title": "c-217ms-72-recursia",
                "content": "Runtime: 217 ms, faster than 72.22% of C++ online submissions for Stone Game IX.\\nMemory Usage: 127.2 MB, less than 50.00% of C++ online submissions for Stone Game IX.\\n```\\nclass Solution {\\npublic:\\n  int helper(unsigned long s, unsigned long n0, unsigned long n1, unsigned long n2, int turn){\\n    if(n0 == 0 && n1 == 0 && n2 == 0) return 1;\\n    \\n    int next_turn = 1^turn;\\n    int tmp = next_turn;\\n    \\n    if(s == 0){\\n      if(n1 || n2){\\n        if(n1)                tmp = helper(1, n0, n1-1, n2, next_turn);\\n        if(tmp != turn && n2) tmp = helper(2, n0, n1, n2-1, next_turn);\\n      }\\n    }\\n    else if(s == 1){\\n      if(n0 || n1){\\n        if(n0)                tmp = helper(1, n0-1, n1, n2, next_turn);\\n        if(tmp != turn && n1) tmp = helper(2, n0, n1-1, n2, next_turn);\\n      }\\n    }\\n    else{\\n      if(n0 || n2){\\n        if(n0)                tmp = helper(2, n0-1, n1, n2, next_turn);\\n        if(tmp != turn && n2) tmp = helper(1, n0, n1, n2-1, next_turn);\\n      }\\n    }\\n    \\n    return tmp;\\n  }\\n  \\n  \\n  bool stoneGameIX(vector<int>& stones) {\\n    int n0 = 0, n1 = 0, n2 = 0;\\n    \\n    for(auto &x: stones){\\n      int tmp = x % 3;\\n      if(tmp == 0) n0++;\\n      else if(tmp == 1) n1++;\\n    }\\n   \\n    n2 = stones.size() - n0 - n1;\\n    n0 = n0%2;                                      //without this small line we will have TLE and whan I wrote contest I don\\'t consider it =(\\n    return helper(0, n0, n1, n2, 0) == 0;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int helper(unsigned long s, unsigned long n0, unsigned long n1, unsigned long n2, int turn){\\n    if(n0 == 0 && n1 == 0 && n2 == 0) return 1;\\n    \\n    int next_turn = 1^turn;\\n    int tmp = next_turn;\\n    \\n    if(s == 0){\\n      if(n1 || n2){\\n        if(n1)                tmp = helper(1, n0, n1-1, n2, next_turn);\\n        if(tmp != turn && n2) tmp = helper(2, n0, n1, n2-1, next_turn);\\n      }\\n    }\\n    else if(s == 1){\\n      if(n0 || n1){\\n        if(n0)                tmp = helper(1, n0-1, n1, n2, next_turn);\\n        if(tmp != turn && n1) tmp = helper(2, n0, n1-1, n2, next_turn);\\n      }\\n    }\\n    else{\\n      if(n0 || n2){\\n        if(n0)                tmp = helper(2, n0-1, n1, n2, next_turn);\\n        if(tmp != turn && n2) tmp = helper(1, n0, n1, n2-1, next_turn);\\n      }\\n    }\\n    \\n    return tmp;\\n  }\\n  \\n  \\n  bool stoneGameIX(vector<int>& stones) {\\n    int n0 = 0, n1 = 0, n2 = 0;\\n    \\n    for(auto &x: stones){\\n      int tmp = x % 3;\\n      if(tmp == 0) n0++;\\n      else if(tmp == 1) n1++;\\n    }\\n   \\n    n2 = stones.size() - n0 - n1;\\n    n0 = n0%2;                                      //without this small line we will have TLE and whan I wrote contest I don\\'t consider it =(\\n    return helper(0, n0, n1, n2, 0) == 0;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502009,
                "title": "c-2029-stone-game-ix",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        unordered_map<int, int> freq; \\n        for (auto& x : stones) freq[x % 3]++; \\n        if (freq[0] & 1) return abs(freq[1] - freq[2]) >= 3; \\n        return freq[1] && freq[2]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        unordered_map<int, int> freq; \\n        for (auto& x : stones) freq[x % 3]++; \\n        if (freq[0] & 1) return abs(freq[1] - freq[2]) >= 3; \\n        return freq[1] && freq[2]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501766,
                "title": "simple-and-clear-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        vector<int> count(3, 0);\\n        \\n        for (auto val: stones) \\n            ++count[val % 3];\\n        \\n        if (count[0] % 2) {\\n            return abs(count[1] - count[2]) > 2;\\n        }\\n        \\n        return count[1] != 0 && count[2] != 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        vector<int> count(3, 0);\\n        \\n        for (auto val: stones) \\n            ++count[val % 3];\\n        \\n        if (count[0] % 2) {\\n            return abs(count[1] - count[2]) > 2;\\n        }\\n        \\n        return count[1] != 0 && count[2] != 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501765,
                "title": "test-case-unclear",
                "content": "```\\n\\n[1,1,7,10,8,17,10,20,2,10]\\n\\nOutput : True\\n```\\n\\nI am missing something in this test case.\\n\\nMy manual understand of stones taken out and removed stone sum is this -\\n\\n```\\n\\n[1,1,8,7,17,10,20,10,2,10]\\n\\nand removed sum is -\\n\\n[1,2,10,17,34,44,64,74,76,86]\\n\\n```\\n\\nAt the end of this, its now Alice\\'s turn but no stones are left. Since none of these removed sums are divisible by 3, \\n\\nand this part of the question \"Bob will win automatically if there are no remaining stones (even if it is Alice\\'s turn).\", the answer should be False (or Bob wins)\\n\\nCan someone explain this?\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\n[1,1,7,10,8,17,10,20,2,10]\\n\\nOutput : True\\n```\n```\\n\\n[1,1,8,7,17,10,20,10,2,10]\\n\\nand removed sum is -\\n\\n[1,2,10,17,34,44,64,74,76,86]\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1501760,
                "title": "java-dfs-memo-solution-with-prune",
                "content": "```\\nclass Solution {\\n    private int len;\\n    private Map<String, Boolean> cache;\\n    public boolean stoneGameIX(int[] stones) {\\n        cache = new HashMap<>();\\n        len = stones.length;\\n        int zeros = 0, ones = 0, twos = 0;\\n        for(int stone : stones){\\n            zeros += (stone % 3 == 0 ? 1 : 0);\\n            ones += (stone % 3 == 1 ? 1 : 0);\\n            twos += (stone % 3 == 2 ? 1 : 0);\\n        }\\n        //zeros % 2, duplicate zeros doesn\\'t change the result\\n        return helper(3, zeros % 2, ones, twos);\\n    }\\n    private boolean helper(int num, int zeros, int ones, int twos){\\n        if(num == 0){\\n            return true;\\n        }\\n        String key = zeros + \",\" + ones +\",\" + twos + \",\" + num;\\n        if(cache.containsKey(key)){\\n            return cache.get(key);\\n        }\\n        if(zeros == 0 && ones == 0 && twos == 0){\\n            return len % 2 != 0; \\n        }\\n        boolean canWin = false;\\n        //try pick zero, one or two\\n        if(!canWin && zeros > 0 && num % 3 != 0){ \\n            if(!helper((num + 0) % 3, zeros - 1, ones, twos)){\\n                canWin = true;\\n            }\\n        }\\n        if(!canWin && ones > 0 && num % 3 != 2){\\n            if(!helper((num + 1) % 3, zeros, ones - 1, twos)){\\n                canWin = true;\\n            }\\n        }\\n        if(!canWin && twos > 0 && num % 3 != 1){\\n            if(!helper((num + 2) % 3, zeros, ones, twos - 1)){\\n                canWin = true;\\n            }\\n        }\\n        cache.put(key, canWin);\\n        return canWin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int len;\\n    private Map<String, Boolean> cache;\\n    public boolean stoneGameIX(int[] stones) {\\n        cache = new HashMap<>();\\n        len = stones.length;\\n        int zeros = 0, ones = 0, twos = 0;\\n        for(int stone : stones){\\n            zeros += (stone % 3 == 0 ? 1 : 0);\\n            ones += (stone % 3 == 1 ? 1 : 0);\\n            twos += (stone % 3 == 2 ? 1 : 0);\\n        }\\n        //zeros % 2, duplicate zeros doesn\\'t change the result\\n        return helper(3, zeros % 2, ones, twos);\\n    }\\n    private boolean helper(int num, int zeros, int ones, int twos){\\n        if(num == 0){\\n            return true;\\n        }\\n        String key = zeros + \",\" + ones +\",\" + twos + \",\" + num;\\n        if(cache.containsKey(key)){\\n            return cache.get(key);\\n        }\\n        if(zeros == 0 && ones == 0 && twos == 0){\\n            return len % 2 != 0; \\n        }\\n        boolean canWin = false;\\n        //try pick zero, one or two\\n        if(!canWin && zeros > 0 && num % 3 != 0){ \\n            if(!helper((num + 0) % 3, zeros - 1, ones, twos)){\\n                canWin = true;\\n            }\\n        }\\n        if(!canWin && ones > 0 && num % 3 != 2){\\n            if(!helper((num + 1) % 3, zeros, ones - 1, twos)){\\n                canWin = true;\\n            }\\n        }\\n        if(!canWin && twos > 0 && num % 3 != 1){\\n            if(!helper((num + 2) % 3, zeros, ones, twos - 1)){\\n                canWin = true;\\n            }\\n        }\\n        cache.put(key, canWin);\\n        return canWin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501611,
                "title": "the-dummy-way-case-by-case",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        int n = stones.size(), zero = 0, one = 0, two = 0;\\n        for (int stone : stones) {\\n            switch (stone % 3) {\\n                case 0: ++zero; break;\\n                case 1: ++one; break;\\n                case 2: ++two; break;\\n            }\\n        }\\n        if (one == 0) {\\n            if (two < 3) {\\n                return false;\\n            } else if (zero % 2) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (two == 0) {\\n            if (one < 3) {\\n                return false;\\n            } else if (zero % 2) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (one == 1 && two == 1) {\\n            return zero % 2 == 0;\\n        }\\n        if (one == 1 && two == 2) {\\n            return zero % 2 == 0;\\n        }\\n        if (one == 2 && two == 1) {\\n            return zero % 2 == 0;\\n        }\\n        if (zero % 2 == 0) {\\n            return true;\\n        }\\n        if (abs(one - two) <= 2) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGameIX(vector<int>& stones) {\\n        int n = stones.size(), zero = 0, one = 0, two = 0;\\n        for (int stone : stones) {\\n            switch (stone % 3) {\\n                case 0: ++zero; break;\\n                case 1: ++one; break;\\n                case 2: ++two; break;\\n            }\\n        }\\n        if (one == 0) {\\n            if (two < 3) {\\n                return false;\\n            } else if (zero % 2) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (two == 0) {\\n            if (one < 3) {\\n                return false;\\n            } else if (zero % 2) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (one == 1 && two == 1) {\\n            return zero % 2 == 0;\\n        }\\n        if (one == 1 && two == 2) {\\n            return zero % 2 == 0;\\n        }\\n        if (one == 2 && two == 1) {\\n            return zero % 2 == 0;\\n        }\\n        if (zero % 2 == 0) {\\n            return true;\\n        }\\n        if (abs(one - two) <= 2) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501195,
                "title": "understanding-the-question-any-help-appreciated",
                "content": "Hi, if possible, can anyone explain this use case: [5,1,1,2,2]\\nAlice - 5\\nBob - 2\\nAlice - 1\\nBob - 2\\nAlice - 1\\nSo sum of all removed stones = 11 and Bob doesnt have any stones left to remove. So shouldnt bob be the winner (return false)? But the expected answer is true (Alice wins)",
                "solutionTags": [],
                "code": "Hi, if possible, can anyone explain this use case: [5,1,1,2,2]\\nAlice - 5\\nBob - 2\\nAlice - 1\\nBob - 2\\nAlice - 1\\nSo sum of all removed stones = 11 and Bob doesnt have any stones left to remove. So shouldnt bob be the winner (return false)? But the expected answer is true (Alice wins)",
                "codeTag": "Unknown"
            },
            {
                "id": 1501162,
                "title": "java-consider-2-cases",
                "content": "I think it take liner time compixity.\\nI consider alice take one case or take two case\\n```\\n    public boolean stoneGameIX(int[] stones) {\\n        int size = stones.length;\\n        int[] mod1 = new int[3];\\n        for (int i = 0; i < size; i++) {\\n            mod1[stones[i] % 3] += 1;\\n        }\\n        int[] mod2 = Arrays.copyOf(mod1, 3);\\n        return get(mod1, size, 1) || get(mod2, size, 2);\\n    }\\n\\n    public boolean get(int[] mod, int n, int startVal) {\\n        if (mod[startVal] == 0) {\\n            return false;\\n        }\\n        int sum = startVal;\\n        mod[startVal]--;\\n        for (int i = 1; i < n; i++) {\\n            if (mod[0] > 0 && sum % 3 != 0) {\\n                mod[0]--;\\n            } else if (mod[1] > 0 && (sum + 1) % 3 != 0) {\\n                sum += 1;\\n                mod[1]--;\\n            } else if (mod[2] > 0 && (sum + 2) % 3 != 0) {\\n                sum += 2;\\n                mod[2]--;\\n            } else {\\n                // odd -> bob turn, alice win; even -> alice turn, bob win\\n                if(i % 2 == 0){\\n                    return false;\\n                }else{\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean stoneGameIX(int[] stones) {\\n        int size = stones.length;\\n        int[] mod1 = new int[3];\\n        for (int i = 0; i < size; i++) {\\n            mod1[stones[i] % 3] += 1;\\n        }\\n        int[] mod2 = Arrays.copyOf(mod1, 3);\\n        return get(mod1, size, 1) || get(mod2, size, 2);\\n    }\\n\\n    public boolean get(int[] mod, int n, int startVal) {\\n        if (mod[startVal] == 0) {\\n            return false;\\n        }\\n        int sum = startVal;\\n        mod[startVal]--;\\n        for (int i = 1; i < n; i++) {\\n            if (mod[0] > 0 && sum % 3 != 0) {\\n                mod[0]--;\\n            } else if (mod[1] > 0 && (sum + 1) % 3 != 0) {\\n                sum += 1;\\n                mod[1]--;\\n            } else if (mod[2] > 0 && (sum + 2) % 3 != 0) {\\n                sum += 2;\\n                mod[2]--;\\n            } else {\\n                // odd -> bob turn, alice win; even -> alice turn, bob win\\n                if(i % 2 == 0){\\n                    return false;\\n                }else{\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564609,
                "content": [
                    {
                        "username": "chemEn",
                        "content": "Spent an hour without any clue what to do :(\\n\\nUPD : [@lee215](https://leetcode.com/lee215/) commented on my post, sort of an achievement for me :)"
                    },
                    {
                        "username": "workcool",
                        "content": "Only mod 3 matters, so we first process it by mod 3, then we have only 0, 1, 2 in the stones. Next, the general idea is that, after Alice takes the first move, the rest becomes deterministic, and can be simulated to see the final result.\\n\\nNow imagine there is no 0s, then after Alice choose either 1 or 2, the sequence becomes determinstic, that is, either 1, 1, 2, 1, 2, 1, 2, ... or  2, 2, 1, 2, 1, 2, 1,... so we can just run 2 simulations to see who wins last by letting Alice taking 1 first, and letting Alice taking 2 first. As long as one of the two simulation leads to Alice win, she wins.\\n\\nNow we need to insert those 0s into these two fixed sequences. ***The key observation here is that, after we fix the sequence of 1s and 2s, it doesn\\'t matter where we insert these 0s, that is, if we just play those 0s at the very end after 1s or 2s are depleted, it suffices to give us the correct result.***\\n\\nThe reason is that, as long as the first 0 appears, it just reverses the resources (1 or 2) Alice or Bob needs. As long as the second 0 appears, it reverses back to the original config, so on and so forth. Therefore, we might just play those 0s at the very end. This enables us to just simulate it to find out who wins, since the sequence becomes determinstic after all. \\n\\nHere is one example, suppose we have stones = [1 1 2  1 2 1 0]\\ncase 1: the original sequence Alice plays 1 first (Bob wins), now we need to insert a single 0:\\nA B A B A B A\\n1 1 2  1 2 1 \\n1 1 2  1 2 1 0\\n1 0 1 2  1 2 1  \\nno matter we place the 0 at the last position or the 2nd position, the last two rows return the same result (Bob wins).\\n\\ncase 2: the original sequence Alice plays 2 first (Alice wins),\\nA B A B A\\n2 2 1  1 \\n2 2 1  0 1\\n2 2 0  1 1\\n2 0 2  1 1 \\nnow we want to insert the 0, no matter where we insert it (last 3 rows show all possible insertion locations), all these positions would lead to the same result (Bob wins). \\nIn summary, Bob wins.\\n\\nInspried from post (it has code)\\nhttps://leetcode.com/problems/stone-game-ix/discuss/1500189/Python-3-simulation-with-remainders/1103927\\n\\n"
                    },
                    {
                        "username": "khushalmakhija201",
                        "content": "Someone Please explain how Bob wins this test case:\\n\\n**`[2,3]`**"
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "[@PerkeCode](/PerkeCode) Alice loses in test cases"
                    },
                    {
                        "username": "PerkeCode",
                        "content": "[@simonfallong](/simonfallong) but in test cases Bob losses"
                    },
                    {
                        "username": "simonfallong",
                        "content": " Bob will win automatically if there are no remaining stones (even if it is Alice\\'s turn)."
                    },
                    {
                        "username": "sukiboo",
                        "content": " `Stone Game IX: Alice and Bob continue their games with stones.`\\n\\nGuys, stop playing with the stones and go do something useful.\\nI\\'m so tired of figuring out who will win \\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1570633,
                "content": [
                    {
                        "username": "chemEn",
                        "content": "Spent an hour without any clue what to do :(\\n\\nUPD : [@lee215](https://leetcode.com/lee215/) commented on my post, sort of an achievement for me :)"
                    },
                    {
                        "username": "workcool",
                        "content": "Only mod 3 matters, so we first process it by mod 3, then we have only 0, 1, 2 in the stones. Next, the general idea is that, after Alice takes the first move, the rest becomes deterministic, and can be simulated to see the final result.\\n\\nNow imagine there is no 0s, then after Alice choose either 1 or 2, the sequence becomes determinstic, that is, either 1, 1, 2, 1, 2, 1, 2, ... or  2, 2, 1, 2, 1, 2, 1,... so we can just run 2 simulations to see who wins last by letting Alice taking 1 first, and letting Alice taking 2 first. As long as one of the two simulation leads to Alice win, she wins.\\n\\nNow we need to insert those 0s into these two fixed sequences. ***The key observation here is that, after we fix the sequence of 1s and 2s, it doesn\\'t matter where we insert these 0s, that is, if we just play those 0s at the very end after 1s or 2s are depleted, it suffices to give us the correct result.***\\n\\nThe reason is that, as long as the first 0 appears, it just reverses the resources (1 or 2) Alice or Bob needs. As long as the second 0 appears, it reverses back to the original config, so on and so forth. Therefore, we might just play those 0s at the very end. This enables us to just simulate it to find out who wins, since the sequence becomes determinstic after all. \\n\\nHere is one example, suppose we have stones = [1 1 2  1 2 1 0]\\ncase 1: the original sequence Alice plays 1 first (Bob wins), now we need to insert a single 0:\\nA B A B A B A\\n1 1 2  1 2 1 \\n1 1 2  1 2 1 0\\n1 0 1 2  1 2 1  \\nno matter we place the 0 at the last position or the 2nd position, the last two rows return the same result (Bob wins).\\n\\ncase 2: the original sequence Alice plays 2 first (Alice wins),\\nA B A B A\\n2 2 1  1 \\n2 2 1  0 1\\n2 2 0  1 1\\n2 0 2  1 1 \\nnow we want to insert the 0, no matter where we insert it (last 3 rows show all possible insertion locations), all these positions would lead to the same result (Bob wins). \\nIn summary, Bob wins.\\n\\nInspried from post (it has code)\\nhttps://leetcode.com/problems/stone-game-ix/discuss/1500189/Python-3-simulation-with-remainders/1103927\\n\\n"
                    },
                    {
                        "username": "khushalmakhija201",
                        "content": "Someone Please explain how Bob wins this test case:\\n\\n**`[2,3]`**"
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "[@PerkeCode](/PerkeCode) Alice loses in test cases"
                    },
                    {
                        "username": "PerkeCode",
                        "content": "[@simonfallong](/simonfallong) but in test cases Bob losses"
                    },
                    {
                        "username": "simonfallong",
                        "content": " Bob will win automatically if there are no remaining stones (even if it is Alice\\'s turn)."
                    },
                    {
                        "username": "sukiboo",
                        "content": " `Stone Game IX: Alice and Bob continue their games with stones.`\\n\\nGuys, stop playing with the stones and go do something useful.\\nI\\'m so tired of figuring out who will win \\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1575804,
                "content": [
                    {
                        "username": "chemEn",
                        "content": "Spent an hour without any clue what to do :(\\n\\nUPD : [@lee215](https://leetcode.com/lee215/) commented on my post, sort of an achievement for me :)"
                    },
                    {
                        "username": "workcool",
                        "content": "Only mod 3 matters, so we first process it by mod 3, then we have only 0, 1, 2 in the stones. Next, the general idea is that, after Alice takes the first move, the rest becomes deterministic, and can be simulated to see the final result.\\n\\nNow imagine there is no 0s, then after Alice choose either 1 or 2, the sequence becomes determinstic, that is, either 1, 1, 2, 1, 2, 1, 2, ... or  2, 2, 1, 2, 1, 2, 1,... so we can just run 2 simulations to see who wins last by letting Alice taking 1 first, and letting Alice taking 2 first. As long as one of the two simulation leads to Alice win, she wins.\\n\\nNow we need to insert those 0s into these two fixed sequences. ***The key observation here is that, after we fix the sequence of 1s and 2s, it doesn\\'t matter where we insert these 0s, that is, if we just play those 0s at the very end after 1s or 2s are depleted, it suffices to give us the correct result.***\\n\\nThe reason is that, as long as the first 0 appears, it just reverses the resources (1 or 2) Alice or Bob needs. As long as the second 0 appears, it reverses back to the original config, so on and so forth. Therefore, we might just play those 0s at the very end. This enables us to just simulate it to find out who wins, since the sequence becomes determinstic after all. \\n\\nHere is one example, suppose we have stones = [1 1 2  1 2 1 0]\\ncase 1: the original sequence Alice plays 1 first (Bob wins), now we need to insert a single 0:\\nA B A B A B A\\n1 1 2  1 2 1 \\n1 1 2  1 2 1 0\\n1 0 1 2  1 2 1  \\nno matter we place the 0 at the last position or the 2nd position, the last two rows return the same result (Bob wins).\\n\\ncase 2: the original sequence Alice plays 2 first (Alice wins),\\nA B A B A\\n2 2 1  1 \\n2 2 1  0 1\\n2 2 0  1 1\\n2 0 2  1 1 \\nnow we want to insert the 0, no matter where we insert it (last 3 rows show all possible insertion locations), all these positions would lead to the same result (Bob wins). \\nIn summary, Bob wins.\\n\\nInspried from post (it has code)\\nhttps://leetcode.com/problems/stone-game-ix/discuss/1500189/Python-3-simulation-with-remainders/1103927\\n\\n"
                    },
                    {
                        "username": "khushalmakhija201",
                        "content": "Someone Please explain how Bob wins this test case:\\n\\n**`[2,3]`**"
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "[@PerkeCode](/PerkeCode) Alice loses in test cases"
                    },
                    {
                        "username": "PerkeCode",
                        "content": "[@simonfallong](/simonfallong) but in test cases Bob losses"
                    },
                    {
                        "username": "simonfallong",
                        "content": " Bob will win automatically if there are no remaining stones (even if it is Alice\\'s turn)."
                    },
                    {
                        "username": "sukiboo",
                        "content": " `Stone Game IX: Alice and Bob continue their games with stones.`\\n\\nGuys, stop playing with the stones and go do something useful.\\nI\\'m so tired of figuring out who will win \\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1923987,
                "content": [
                    {
                        "username": "chemEn",
                        "content": "Spent an hour without any clue what to do :(\\n\\nUPD : [@lee215](https://leetcode.com/lee215/) commented on my post, sort of an achievement for me :)"
                    },
                    {
                        "username": "workcool",
                        "content": "Only mod 3 matters, so we first process it by mod 3, then we have only 0, 1, 2 in the stones. Next, the general idea is that, after Alice takes the first move, the rest becomes deterministic, and can be simulated to see the final result.\\n\\nNow imagine there is no 0s, then after Alice choose either 1 or 2, the sequence becomes determinstic, that is, either 1, 1, 2, 1, 2, 1, 2, ... or  2, 2, 1, 2, 1, 2, 1,... so we can just run 2 simulations to see who wins last by letting Alice taking 1 first, and letting Alice taking 2 first. As long as one of the two simulation leads to Alice win, she wins.\\n\\nNow we need to insert those 0s into these two fixed sequences. ***The key observation here is that, after we fix the sequence of 1s and 2s, it doesn\\'t matter where we insert these 0s, that is, if we just play those 0s at the very end after 1s or 2s are depleted, it suffices to give us the correct result.***\\n\\nThe reason is that, as long as the first 0 appears, it just reverses the resources (1 or 2) Alice or Bob needs. As long as the second 0 appears, it reverses back to the original config, so on and so forth. Therefore, we might just play those 0s at the very end. This enables us to just simulate it to find out who wins, since the sequence becomes determinstic after all. \\n\\nHere is one example, suppose we have stones = [1 1 2  1 2 1 0]\\ncase 1: the original sequence Alice plays 1 first (Bob wins), now we need to insert a single 0:\\nA B A B A B A\\n1 1 2  1 2 1 \\n1 1 2  1 2 1 0\\n1 0 1 2  1 2 1  \\nno matter we place the 0 at the last position or the 2nd position, the last two rows return the same result (Bob wins).\\n\\ncase 2: the original sequence Alice plays 2 first (Alice wins),\\nA B A B A\\n2 2 1  1 \\n2 2 1  0 1\\n2 2 0  1 1\\n2 0 2  1 1 \\nnow we want to insert the 0, no matter where we insert it (last 3 rows show all possible insertion locations), all these positions would lead to the same result (Bob wins). \\nIn summary, Bob wins.\\n\\nInspried from post (it has code)\\nhttps://leetcode.com/problems/stone-game-ix/discuss/1500189/Python-3-simulation-with-remainders/1103927\\n\\n"
                    },
                    {
                        "username": "khushalmakhija201",
                        "content": "Someone Please explain how Bob wins this test case:\\n\\n**`[2,3]`**"
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "[@PerkeCode](/PerkeCode) Alice loses in test cases"
                    },
                    {
                        "username": "PerkeCode",
                        "content": "[@simonfallong](/simonfallong) but in test cases Bob losses"
                    },
                    {
                        "username": "simonfallong",
                        "content": " Bob will win automatically if there are no remaining stones (even if it is Alice\\'s turn)."
                    },
                    {
                        "username": "sukiboo",
                        "content": " `Stone Game IX: Alice and Bob continue their games with stones.`\\n\\nGuys, stop playing with the stones and go do something useful.\\nI\\'m so tired of figuring out who will win \\uD83D\\uDE2D"
                    }
                ]
            }
        ]
    }
]