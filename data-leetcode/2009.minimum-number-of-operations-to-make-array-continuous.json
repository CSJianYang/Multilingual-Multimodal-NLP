[
    {
        "title": "Score of Parentheses",
        "question_content": "Given a balanced parentheses string s, return the score of the string.\nThe score of a balanced parentheses string is based on the following rule:\n\n\t\"()\" has score 1.\n\tAB has score A + B, where A and B are balanced parentheses strings.\n\t(A) has score 2 * A, where A is a balanced parentheses string.\n\n&nbsp;\nExample 1:\n\nInput: s = \"()\"\nOutput: 1\n\nExample 2:\n\nInput: s = \"(())\"\nOutput: 2\n\nExample 3:\n\nInput: s = \"()()\"\nOutput: 2\n\n&nbsp;\nConstraints:\n\n\t2 <= s.length <= 50\n\ts consists of only '(' and ')'.\n\ts is a balanced parentheses string.",
        "solutions": [
            {
                "id": 1856519,
                "title": "java-c-visually-explained",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Score of Parentheses**\\n\\nIn order to solve this problem we are assigned with few rules :-\\n```\\n\"()\" has score 1.\\nAB has score A + B, where A and B are balanced parentheses strings.\\n(A) has score 2 * A, where A is a balanced parentheses string.\\n```\\n\\nLet\\'s understand our rule\\'s first of all :-\\n* If our input string is **\"()\"** then our score will be **`1`**, so this is our first rule\\n\\n\\n* If we have input string **\"()()\"** then our score will be **1 + 1** i.e. **`2`**, where `1` is a score of a balanced parentheses. So, this is our second rule\\n* Now last rule say\\'s, if we have given something like **\"(())\"** in our input string, our score will be **2 X 1** i.e. **`2`**, it means that we have something like `nested parenthesis`. Then multiply it by 2.\\n\\nLet\\'s take one example, inorder to solve this problem :-\\n\\n**Input :** \"( ( ) ( ( ) ) )\"\\n**Output :** 6\\n\\n![image](https://assets.leetcode.com/users/images/d4cd1104-d9d1-48b7-ada3-f3f4b98568da_1647481533.8082087.png)\\n\\nOkay, so first thing came in our mind is can we solve this problem using stack, and I say yes we\\'ll solve this problem using stack.\\n\\n* First create one stack of **Integer** not ~~**Character**~~\\n* So, as we are using Integer, what we gonna put in stack is intially **0** when we encounter `(`\\n* And we\\'ll calculate the score when we encounter `)`\\n\\n```\\nLet\\'s Understand it visually :-\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b80fe1d1-6ffc-4d49-b52e-a9749b50bdaf_1647483490.0576897.gif)\\n\\n*I hope you got the idea* **Let\\'s Code it up :-**\\n\\n**Java**\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int score = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.pop() + Math.max(2 * score, 1);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int score = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.top() + max(2 * score, 1);\\n                st.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n\"()\" has score 1.\\nAB has score A + B, where A and B are balanced parentheses strings.\\n(A) has score 2 * A, where A is a balanced parentheses string.\\n```\n```\\nLet\\'s Understand it visually :-\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int score = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.pop() + Math.max(2 * score, 1);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int score = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.top() + max(2 * score, 1);\\n                st.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856699,
                "title": "c-beats-100-omg-o-1-space-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nLet\\'s take a look how do we calculate the score on following examples: \\n\\n`()()` => `1+1`\\n`(()())` => `2*(1+1)`\\n`((()()))` => `2*2*(1+1)`\\n`((()(())))` => `2*2*(1+2*1)`\\n\\nWe can see that any `()` in the string gives a score depending on its depth. If `()` is located on the higher possible level (depth=0), the score is simply a 1. If it\\'s located deeper, we just multiply it by 2 as many times as its depth. The found score we can just add to the final result. Why can we do that? Remember that, for example, this expression `2*2*(1+1)` can be expressed as `2*2+2*2`. No matter how deep parenthesis, the final expression of score can be represented as a sum of `()` scores.\\n\\nTime: **O(N)** - traversing\\nSpace: **O(1)** - OMAGAD!!! (\\xB4\\u25BD`\\u0283\\u01AA)\\n\\nRuntime: 0 ms, faster than **100.00%** of C++ online submissions for Score of Parentheses.\\nMemory Usage: 6.1 MB, less than **83.25%** of C++ online submissions for Score of Parentheses.\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856520,
                "title": "java-easy-to-understand-intuition-and-solution-o-n-o-1",
                "content": "****\\nPlease upvote if the solution helps, as it keeps up the motivation to provide such posts.\\n\\n****\\n\\u2318 **Explanation Flow :**\\n* Observations.\\n* Code Flow : Rules and Dry Run\\n* Implementations\\n\\t* Using Stack of Character\\n\\t* Using Stack of Integer\\n\\t* Constant Space Solution\\n\\t* Complexity Analysis\\n\\n\\u2318 **Observations :**\\n\\nAs the given string is balanced, thus it makes our task easy. \\nWe solve the self-dependant `()` and store the result in stack and follow the simulation acc. to the given rules.\\n\\nRight off the bat, first intuition is always using a `stack` here, but we can definately reduce the `SC` to `O(1)` as input constraints to use just two chars `( and )`.\\n\\n# Code Flow : \\n**Rules**:\\n1. \"()\" has score 1.\\n2. AB has score A + B, where A and B are balanced parentheses strings.\\n3. (A) has score 2 * A, where A is a balanced parentheses string.\\n\\n\\n`str =  ( () ( () ) )`\\n\\n* if `ch == (`:\\n\\t* push `ch` in stack\\n* if `ch == )`:\\n\\t* Check the top of stack. It can either of two :\\n\\t\\t* `stack.top() == (` : \\n\\t\\t\\t* i.e. we got a pair `()`. Thus, we push `1`  as per the `1st rule`\\n\\t\\t* `stack.top() == \\'NUMBER\\'`\\n\\t\\t\\t* `Using rule 2 & rule 3` : We add all the numbers till we find the starting `(` of this. ( let `A`)\\n\\t\\t\\t* `Push 2*A back in the stack`\\n* Check if stack is empty. If not, use `rule #2` \\n\\n\\n# \\u2318Code Dry Run States :\\n\\n* `( () ( () ) )`\\n* `( 1 ( () ) )`\\n* `( 1 ( 1 ) )`\\n* `( 1 2 )`\\n* `( 3 )`\\n* `6`\\n\\n****\\n\\n\\uD83D\\uDCCE **First Implementation :** \\n\\nUsing stack of `Character`\\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\') {\\n                stack.push(ch);\\n            } else {\\n                // if top of stack is \\'(\\'\\n                if(!stack.isEmpty() && stack.peek() == \\'(\\') {\\n                    stack.pop();\\n                    stack.push(\\'1\\');\\n                } else {\\n                    // if top of stack is a \\'(char) number\\'\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=\\'(\\') {\\n                        sum += stack.pop()-\\'0\\';\\n                    }\\n                    // pop \\'(\\'\\n                    stack.pop();\\n                    stack.push((char)(2*sum+\\'0\\'));\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += (stack.pop()-\\'0\\');\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n****\\n\\n\\uD83D\\uDCCE **Second Implementation :** \\n\\nUsing `stack of int`\\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\')\\n                stack.push(-1);\\n            else {\\n                if(!stack.isEmpty() && stack.peek() == -1)\\n                {\\n                    stack.pop(); // remove \\'(\\'\\n                    stack.push(1);\\n                }\\n                else {\\n                    // top of the stack is number\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=-1) {\\n                        sum += stack.pop();\\n                    }\\n                    \\n                    stack.pop();\\n                    stack.push(2*sum);\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n\\u2318 **Complexity Analysis** : \\n\\n`TC : O(n)\\nSC: O(n)\\n`\\n****\\n\\n\\uD83D\\uDCCE **Constant Space :** \\n\\nAs the string is balanced, a `(` bracket could be used to mark the start of a new depth (`i.e. 2 times the depth`) & a `)` bracket would indicate us the end of a valid sub-portion of paranthesis. Hence, \\n\\n* We need to update the depth of a paranthesis.\\n\\t* If `(` - our depth increases\\n\\t* If `)` - our depth decreases \\n\\t\\t* If at any point, we see a valid balanced pair `()`, then we need to update the output acc to `Rule #3`\\n\\nFor eg: \\n\\n```\\nstr =    (   (   (   (   )  (   )  (   )   )  )  )\\ndepth =  1   2   3   4   3  4   3  4   3   2  1  0\\nR =                      8      8      8\\n\\nFinal result = 8 + 8 + 8 = 24\\n\\nWhy are we decrementing when we find a `)` ? It is because the intermediate `()` lies at d-1 depth. \\neg: (   (   (  **(   )** - this valid pair lies at depth 3.\\n```\\n\\n# Code Implementation : \\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int n = s.length(), d = 0, R = 0;\\n        \\n        for(int i=0;i<n;i++) {\\n            char ch = s.charAt(i);\\n            // if `(` increase the depth\\n            if(ch == \\'(\\')\\n                d++;\\n            else {\\n            // if `)` decrease the depth\\n                --d;\\n                // check if a balanced pair is getting formed, if yes update the result\\n                if(s.charAt(i-1) == \\'(\\')\\n                    R += Math.pow(2, d);\\n            }\\n        }\\n        return R;\\n    }\\n}\\n\\n```\\n\\n\\u2318 **Complexity Analysis** : \\n\\n`TC : O(n)\\nSC: O(1)\\n`",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\') {\\n                stack.push(ch);\\n            } else {\\n                // if top of stack is \\'(\\'\\n                if(!stack.isEmpty() && stack.peek() == \\'(\\') {\\n                    stack.pop();\\n                    stack.push(\\'1\\');\\n                } else {\\n                    // if top of stack is a \\'(char) number\\'\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=\\'(\\') {\\n                        sum += stack.pop()-\\'0\\';\\n                    }\\n                    // pop \\'(\\'\\n                    stack.pop();\\n                    stack.push((char)(2*sum+\\'0\\'));\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += (stack.pop()-\\'0\\');\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\')\\n                stack.push(-1);\\n            else {\\n                if(!stack.isEmpty() && stack.peek() == -1)\\n                {\\n                    stack.pop(); // remove \\'(\\'\\n                    stack.push(1);\\n                }\\n                else {\\n                    // top of the stack is number\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=-1) {\\n                        sum += stack.pop();\\n                    }\\n                    \\n                    stack.pop();\\n                    stack.push(2*sum);\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nstr =    (   (   (   (   )  (   )  (   )   )  )  )\\ndepth =  1   2   3   4   3  4   3  4   3   2  1  0\\nR =                      8      8      8\\n\\nFinal result = 8 + 8 + 8 = 24\\n\\nWhy are we decrementing when we find a `)` ? It is because the intermediate `()` lies at d-1 depth. \\neg: (   (   (  **(   )** - this valid pair lies at depth 3.\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int n = s.length(), d = 0, R = 0;\\n        \\n        for(int i=0;i<n;i++) {\\n            char ch = s.charAt(i);\\n            // if `(` increase the depth\\n            if(ch == \\'(\\')\\n                d++;\\n            else {\\n            // if `)` decrease the depth\\n                --d;\\n                // check if a balanced pair is getting formed, if yes update the result\\n                if(s.charAt(i-1) == \\'(\\')\\n                    R += Math.pow(2, d);\\n            }\\n        }\\n        return R;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141777,
                "title": "c-java-python-o-1-space",
                "content": "# **Approach 0: Stack**\\n\\n`cur` record the score at the current layer level.\\n\\nIf we meet `\\'(\\'`,\\nwe push the current score to `stack`,\\nenter the next inner layer level,\\nand reset `cur = 0`.\\n\\nIf we meet `\\')\\'`,\\nthe `cur` score will be doubled and will be at least 1.\\nWe exit the current layer level,\\nand set `cur += stack.pop() + cur`\\n\\n**Complexity:** `O(N)` time and `O(N)` space\\n\\n**Java**\\n```java\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int cur = 0;\\n        for (char i : S)\\n            if (i == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            }\\n            else {\\n                cur += stack.top() + max(cur, 1);\\n                stack.pop();\\n            }\\n        return cur;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def scoreOfParentheses(self, S):\\n        stack, cur = [], 0\\n        for i in S:\\n            if i == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur += stack.pop() + max(cur, 1)\\n        return cur\\n```\\n<br>\\n\\n# **Approach 1: Array**\\n\\nSame as stack, I do it with an array.\\nWe change a pointer instead of pushing/popping repeatedly.\\n\\nComplexity: `O(N)` time and `O(N)` space\\n\\n\\n**Java:**\\n```java\\n    public int scoreOfParentheses(String S) {\\n        int res[] = new int[30], i = 0;\\n        for (char c : S.toCharArray())\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += Math.max(res[i--] * 2, 1);\\n        return res[0];\\n    }\\n```\\n**C++:**\\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res[30] = {0}, i = 0;\\n        for (char c : S)\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += max(res[i] * 2, 1), i--;\\n        return res[0];\\n    }\\n```\\n**Python:**\\n```py\\n    def scoreOfParentheses(self, S):\\n        res, i = [0] * 30, 0\\n        for c in S:\\n            i += 1 if c == \\'(\\' else -1\\n            res[i] = res[i] + max(res[i + 1] * 2, 1) if c == \\')\\' else 0\\n        return res[0]\\n```\\n<br>\\n\\n# **Follow-Up**\\nCan you solve it in `O(1)` space?\\n<br>\\n\\n# **Approach 2: O(1) Space**\\n\\nWe count the number of layers.\\nIf we meet `\\'(\\'` layers number `l++`\\nelse we meet `\\')\\'` layers number `l--`\\n\\nIf we meet `\"()\"`, we know the number of layer outside,\\nso we can calculate the score `res += 1 << l`.\\n\\n**C++:**\\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S[i] == \\'(\\') l++; else l--;\\n            if (S[i] == \\')\\' && S[i - 1] == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```jave\\n    public int scoreOfParentheses(String S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S.charAt(i) == \\'(\\') l++; else l--;\\n            if (S.charAt(i) == \\')\\' && S.charAt(i - 1) == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def scoreOfParentheses(self, S):\\n        res = l = 0\\n        for a, b in itertools.izip(S, S[1:]):\\n            if a + b == \\'()\\': res += 2 ** l\\n            l += 1 if a == \\'(\\' else -1\\n        return res\\n```\\n<br>\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n[1130. Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n[901. Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n[856. Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n[503. Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n496. Next Greater Element I\\n84. Largest Rectangle in Histogram\\n42. Trapping Rain Water\\n",
                "solutionTags": [],
                "code": "```java\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n```\n```cpp\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int cur = 0;\\n        for (char i : S)\\n            if (i == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            }\\n            else {\\n                cur += stack.top() + max(cur, 1);\\n                stack.pop();\\n            }\\n        return cur;\\n    }\\n```\n```py\\n    def scoreOfParentheses(self, S):\\n        stack, cur = [], 0\\n        for i in S:\\n            if i == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur += stack.pop() + max(cur, 1)\\n        return cur\\n```\n```java\\n    public int scoreOfParentheses(String S) {\\n        int res[] = new int[30], i = 0;\\n        for (char c : S.toCharArray())\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += Math.max(res[i--] * 2, 1);\\n        return res[0];\\n    }\\n```\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res[30] = {0}, i = 0;\\n        for (char c : S)\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += max(res[i] * 2, 1), i--;\\n        return res[0];\\n    }\\n```\n```py\\n    def scoreOfParentheses(self, S):\\n        res, i = [0] * 30, 0\\n        for c in S:\\n            i += 1 if c == \\'(\\' else -1\\n            res[i] = res[i] + max(res[i + 1] * 2, 1) if c == \\')\\' else 0\\n        return res[0]\\n```\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S[i] == \\'(\\') l++; else l--;\\n            if (S[i] == \\')\\' && S[i - 1] == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\n```jave\\n    public int scoreOfParentheses(String S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S.charAt(i) == \\'(\\') l++; else l--;\\n            if (S.charAt(i) == \\')\\' && S.charAt(i - 1) == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def scoreOfParentheses(self, S):\\n        res = l = 0\\n        for a, b in itertools.izip(S, S[1:]):\\n            if a + b == \\'()\\': res += 2 ** l\\n            l += 1 if a == \\'(\\' else -1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 141975,
                "title": "c-solution-using-stack-5ms-detail-explained",
                "content": "When travel through S, only meets \\')\\', we need to calculate the score of this pair of parenthese. If we know the score of inner parentheses, such as 3, we can double it and pass to the outer parenthese.  But the question is how do we know the score of inner parentheses? Using stack.\\n\\nexplain with \"( ( ) ( ( ) ) )\"\\n\\nstack: 0-> \\nstring_traveled :\"\"\\nWhen start only 0 in stack, this int will store the total score\\n\\nstack: 0->0->0->\\nstring_traveled:\"( (\"\\nMeet two \\'(\\', push two zeros to the stack\\n\\nstack: 0->1->\\nstring_traveled: \"( ( )\"\\nFirst time meets \\')\\', it balance the last \\'(\\', so pop the stack. But 0 indicates no inner parentheses exists, so just pass 1 to parent parenthese.\\n\\nstack: 0->1->0->0->\\nstring_traveled: \"( ( ) ( (\"\\nKeep pushing zeros\\n\\nstack 0->1->1->\\nstring_traveled: \"( ( ) ( ( )\"\\nBalance one \\'(\\', and still no inner parenthese, so pass 1 to parent\\n\\nstack 0->3->\\nstring_traveled: \"( ( ) ( ( ) )\"\\nBalance another \\'(\\', but the inner is not zero, so double it and add to parent\\'s score\\n\\nstack 6->\\nstring_traveled: \"( ( ) ( ( ) ) )\"\\nSame as last step, double the inner score and add to parent\\'s\\n\\n```\\nint scoreOfParentheses(string S)\\n{\\n    stack<int> m_stack;\\n    m_stack.push(0); // to keep the total score\\n    for(char c:S){\\n        if(c==\\'(\\')\\n            m_stack.push(0); //When meets \\'(\\', just push a zero to stack\\n        else{\\n            int tmp=m_stack.top(); //  balance the last \\'(\\', it stored the score of inner parentheses\\n            m_stack.pop();\\n            int val=0;\\n            if(tmp>0) // not zero means inner parentheses exists and double it\\n                val=tmp*2;\\n            else // zero means no inner parentheses, just using 1\\n                val=1;\\n            m_stack.top()+=val; // pass the score of this level to parent parenthese\\n        }   \\n    }\\n    return m_stack.top();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string S)\\n{\\n    stack<int> m_stack;\\n    m_stack.push(0); // to keep the total score\\n    for(char c:S){\\n        if(c==\\'(\\')\\n            m_stack.push(0); //When meets \\'(\\', just push a zero to stack\\n        else{\\n            int tmp=m_stack.top(); //  balance the last \\'(\\', it stored the score of inner parentheses\\n            m_stack.pop();\\n            int val=0;\\n            if(tmp>0) // not zero means inner parentheses exists and double it\\n                val=tmp*2;\\n            else // zero means no inner parentheses, just using 1\\n                val=1;\\n            m_stack.top()+=val; // pass the score of this level to parent parenthese\\n        }   \\n    }\\n    return m_stack.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141778,
                "title": "1-line-python",
                "content": "```\\n    def scoreOfParentheses(self, S):\\n        return eval(S.replace(\\')(\\', \\')+(\\').replace(\\'()\\', \\'1\\').replace(\\')\\', \\')*2\\'))\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def scoreOfParentheses(self, S):\\n        return eval(S.replace(\\')(\\', \\')+(\\').replace(\\'()\\', \\'1\\').replace(\\')\\', \\')*2\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 141763,
                "title": "java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(-1);\\n            } else {\\n                int cur = 0;\\n                while (stack.peek() != -1) {\\n                    cur += stack.pop();\\n                }\\n                stack.pop();\\n                stack.push(cur == 0 ? 1 : cur * 2);\\n            }\\n        }\\n        int sum = 0;\\n        while (!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(-1);\\n            } else {\\n                int cur = 0;\\n                while (stack.peek() != -1) {\\n                    cur += stack.pop();\\n                }\\n                stack.pop();\\n                stack.push(cur == 0 ? 1 : cur * 2);\\n            }\\n        }\\n        int sum = 0;\\n        while (!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856417,
                "title": "c-explained-with-algorithm-0ms-100-easy-simple",
                "content": "# 856. Score of Parentheses\\n**KNOCKCAT**\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Approach with initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n``` ```\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n``` ```\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**ALGORITHM**\\n1. **\"()\"** has a **score of 1.**\\n2. **\"xy**\" has a **score of x + y** ,  here x & y are balanced pairs of balanced parenthese.\\n3. **\"(x) \"** has a **score of x , (i.e) 2 * score of x.**\\n\\tExample.\\n\\t**Input: str = \\u201C()()\\u201D\\n\\tOutput: 2**\\n\\t\\tExplanation: There are are two individual pairs of balanced parenthesis \\u201C() ()\\u201D. Therefore, **score = score of \\u201C()\\u201D + score of \\u201C()\\u201D = 1 + 1 = 2**\\n\\n\\tInput: str = \\u201C(())\\u201D\\n\\tOutput: 2\\n\\t\\tExplanation: Since the input is of the form \\u201C(x)\\u201D, **the total score = 2 * score of \\u201C()\\u201D = 2 * 1 = 2**\\n\\t\\t\\n* **Take a Stack**, **Iterate  over the characters of string.**\\n* For every i**th character check if the character is \\u2018(\\u2018 or not.** If found to be true, then **insert the character score into the stack.**\\n* Initialize a **stack to store the current traversed character score** of inner balanced parenthesis.\\n* For every i check for the conditions.\\n\\t* **if the current character is \\'(\\' push the current score into stack** , enter the next inner layer and **reset score to 0.**\\n\\t* if the **current character is \\')\\'** then **ind score will be doubled and will be at  least one .**\\n\\t* we **exit the current level**  and **set ind = stack.top() + max(ind * 2, 1).**\\n\\t* and pop the  score from the stack.\\n\\t\\nANALYSIS :-\\n* \\t**Time Complexity : O(N)**\\n\\n* \\t**Space Complexity : O(N)**\\n\\n\\n![image](https://assets.leetcode.com/users/images/096896ec-5acf-4e04-b049-6f70de10349d_1647479213.4339418.png)\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        int ind = 0;\\n        \\n        for(auto i : s)\\n        {\\n\\t\\t\\t// if we find open parenthesis\\n\\t\\t\\t// push the current score into the stack\\n            if(i == \\'(\\')\\n            {\\n                st.push(ind);\\n\\t\\t\\t\\t// reset the score to 0\\n                ind = 0;\\n            }\\n            else // if we find close parenthesis\\n            {\\n                ind = st.top() + max(ind*2 ,1);\\n                st.pop();\\n            }\\n                \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Approach with initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        int ind = 0;\\n        \\n        for(auto i : s)\\n        {\\n\\t\\t\\t// if we find open parenthesis\\n\\t\\t\\t// push the current score into the stack\\n            if(i == \\'(\\')\\n            {\\n                st.push(ind);\\n\\t\\t\\t\\t// reset the score to 0\\n                ind = 0;\\n            }\\n            else // if we find close parenthesis\\n            {\\n                ind = st.top() + max(ind*2 ,1);\\n                st.pop();\\n            }\\n                \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080518,
                "title": "python-o-1-space-solution-explained",
                "content": "When you see parentheses in problem forlumation you should think about stack and indeed, there is stack solution for this problem. This solution will be optimal in time, but in place we can do better! Let us look at the following string:\\n`(((()))(()(())))` and try tu understand what will be the score of such string.\\nFirst of all it can be written as 2 * `((()))(()(()))`, which can be written as `2*((())) + 2*(()(())) = 2*2*(()) + 2*2*() + 2*2*(()) = 2*2*2 + 2*2 + 2*2*2 = 20` and it helps us to notice that what acutally matters is how many `()` we meet in our string, and how deep they are located. So, let us traverse through our string, keep `bal`: balance, or depth of current place, that is how many brackets we need to close to get correct expression, and also if we see `()`, we update `ans += 1<< bal`.\\n\\n**Complexity**: time complexity is `O(n)`: we need to traverse our string once, space complexity is just `O(1)`.\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        ans, bal = 0, 0\\n        for i, s in enumerate(S):\\n            bal = bal + 1 if s == \"(\" else bal - 1\\n            if i > 0 and S[i-1:i+1] == \"()\":\\n                ans += 1 << bal\\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        ans, bal = 0, 0\\n        for i, s in enumerate(S):\\n            bal = bal + 1 if s == \"(\" else bal - 1\\n            if i > 0 and S[i-1:i+1] == \"()\":\\n                ans += 1 << bal\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141779,
                "title": "java-8ms-11-lines-recursion-with-explanation",
                "content": "```\\nclass Solution {\\n    int i=0;\\n    public int scoreOfParentheses(String S) {\\n        int res=0;\\n        while(i<S.length()){\\n            char c=S.charAt(i++);\\n            if (c==\\'(\\'){\\n                if (S.charAt(i)==\\')\\'){\\n                    res+=1;\\n                    i++;\\n                } else res+=2*scoreOfParentheses(S);\\n            }else return res;\\n        }\\n        return res;\\n    }\\n}\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/caraxin/image_1529810228.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int i=0;\\n    public int scoreOfParentheses(String S) {\\n        int res=0;\\n        while(i<S.length()){\\n            char c=S.charAt(i++);\\n            if (c==\\'(\\'){\\n                if (S.charAt(i)==\\')\\'){\\n                    res+=1;\\n                    i++;\\n                } else res+=2*scoreOfParentheses(S);\\n            }else return res;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141828,
                "title": "python-javascript-simple-and-readable-stack-solution",
                "content": "When we see \"(\" character, we are entering new valid paranthesis cluster, so we append initalized value 0 to stack.\\nWhen we see \")\" character, we should process currently open valid paranthesis cluster(Stack.pop()). If valid paranthesis cluster is still valued 0, it is a valid empty paranthesis cluster, so value is 1. Otherwise multiply inside value by 2. Add processed value to outer valid paranthesis cluster(Stack[-1]) \\n* Python\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for c in S:\\n            if c == \"(\":\\n                stack.append(0)\\n            else:\\n                last = stack.pop()\\n                stack[-1] += 2 * last or 1\\n        return stack.pop()\\n```\\n* Javascript\\n```\\nvar scoreOfParentheses = function(S) {\\n    let stack = [0];\\n    for (i in S) {\\n        if (S[i] == \"(\") {\\n            stack.push(0);\\n        }\\n        else {\\n            last = stack.pop();\\n            stack[stack.length - 1] += 2 * last || 1\\n        }\\n    }\\n    return stack.pop();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for c in S:\\n            if c == \"(\":\\n                stack.append(0)\\n            else:\\n                last = stack.pop()\\n                stack[-1] += 2 * last or 1\\n        return stack.pop()\\n```\n```\\nvar scoreOfParentheses = function(S) {\\n    let stack = [0];\\n    for (i in S) {\\n        if (S[i] == \"(\") {\\n            stack.push(0);\\n        }\\n        else {\\n            last = stack.pop();\\n            stack[stack.length - 1] += 2 * last || 1\\n        }\\n    }\\n    return stack.pop();\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204576,
                "title": "simple-python-stack-solution-o-n-time-beats-100-easy-to-understand",
                "content": "Please give me some upvotes if you like it.\\n```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for par in S:\\n            if par == \"(\": stack.append(0)\\n            else:\\n                last = stack.pop()\\n                if last == 0: score = 1\\n                else: score = last * 2\\n                stack[-1] += score\\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for par in S:\\n            if par == \"(\": stack.append(0)\\n            else:\\n                last = stack.pop()\\n                if last == 0: score = 1\\n                else: score = last * 2\\n                stack[-1] += score\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080625,
                "title": "js-python-java-c-easy-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nAny time we see a problem that describes a doubling operation and an incrementing operation, we should at least think about a potential binary solution. In this case, those are really the only two operations. Nested doubling operations means powers of **2** depending on the nesting depth, and a simple closed pair of parentheses is a **+1**.\\n\\nAt first glance, the addition operation would seem to cause a problem, but math once again comes to our aid.\\n\\nConsider the following:\\n```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\\nAs we can see, we don\\'t *really* have to wait for the summation before applying the power operation, because it will get distributed across the summation anyway. And since we know how many nested parentheses there are (**pwr**) when we finish a simple parentheses pair, we can immediately add the appropriate value to our answer (**ans**).\\n\\nThis means that we can solve this problem in **O(n) time** and **O(1) space**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor JavaScript **S.charAt(i)** is faster at processing string iteration than **S[i]**.\\n\\nWe can start our iteration at **i = 1** because we know the first character is going to be **\"(\"**. We *could* start at **i = 0**, but then we\\'d have to either start with **pwr = 1** or make sure to decrement **pwr** before the power operation instead of after.\\n\\nWe can use a **bitwise shift** for the power operation to more accurately reflect the solution\\'s binary nature.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **64ms / 38.4MB** (beats 99% / 77%).\\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.0MB** (beats 96% / 90%).\\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 37.0MB** (beats 100% / 60%).\\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.9MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568087,
                "title": "c-easy-to-understand-well-commented-solution-stack-solution-100-time-100-space",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int n=S.size();\\n        stack<int> s;\\n        for(int i=0;i<n;i++){\\n            if(S[i]==\\'(\\'){ //Whenever we get opening brackets, we will push it in the stack, it tells we have to do some calculation\\n                // \\'(\\' will be represented by -1, as any computaitional value can become ascii value of \\'(\\' i.e. 40\\n                s.push(-1);\\n            }\\n            else{   //S[i]==\\')\\'  ,now we have to do calculation\\n                //We have to see top of the stack\\n                if(s.top()==-1){ //Case 1- ()=1\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else{ //We have some number \\n                    int res=s.top();\\n                    s.pop();\\n                    if(s.top()==-1){ //Case 2- (A)=2*A\\n                        s.pop();\\n                        s.push(2*res);\\n                    }\\n                    else{  //Case 3- ABC..=A+B+C+..\\n                        //I will keep adding elements until I get to opening loop\\n                        while(!s.empty()&&s.top()!=-1){\\n                            res+=s.top();\\n                            s.pop();\\n                        }\\n                        if(!s.empty()&&s.top()==-1){\\n                            s.pop();\\n                            res=res*2;\\n                        }\\n                        s.push(res);//I will add calculated value in stack after popping out all brackets within which value is calculated\\n                    }\\n                }\\n            }\\n        }\\n        //I have eliminated all brackets \\n        //I only have numbers remaining in my stack like 1,2,3...\\n        //So I have to do AB= A+B\\n        int ans=0;\\n        while(!s.empty()){\\n            ans+=s.top();\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int n=S.size();\\n        stack<int> s;\\n        for(int i=0;i<n;i++){\\n            if(S[i]==\\'(\\'){ //Whenever we get opening brackets, we will push it in the stack, it tells we have to do some calculation\\n                // \\'(\\' will be represented by -1, as any computaitional value can become ascii value of \\'(\\' i.e. 40\\n                s.push(-1);\\n            }\\n            else{   //S[i]==\\')\\'  ,now we have to do calculation\\n                //We have to see top of the stack\\n                if(s.top()==-1){ //Case 1- ()=1\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else{ //We have some number \\n                    int res=s.top();\\n                    s.pop();\\n                    if(s.top()==-1){ //Case 2- (A)=2*A\\n                        s.pop();\\n                        s.push(2*res);\\n                    }\\n                    else{  //Case 3- ABC..=A+B+C+..\\n                        //I will keep adding elements until I get to opening loop\\n                        while(!s.empty()&&s.top()!=-1){\\n                            res+=s.top();\\n                            s.pop();\\n                        }\\n                        if(!s.empty()&&s.top()==-1){\\n                            s.pop();\\n                            res=res*2;\\n                        }\\n                        s.push(res);//I will add calculated value in stack after popping out all brackets within which value is calculated\\n                    }\\n                }\\n            }\\n        }\\n        //I have eliminated all brackets \\n        //I only have numbers remaining in my stack like 1,2,3...\\n        //So I have to do AB= A+B\\n        int ans=0;\\n        while(!s.empty()){\\n            ans+=s.top();\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856451,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time complexity : O(n)**\\n\\n```java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        int cur = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(1, cur*2);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```\\n```javascript []\\nvar scoreOfParentheses = function(s) {\\n    let stack = []\\n    let cur = 0;\\n    for(let c of s) {\\n        if(c == \\'(\\') {\\n            stack.push(cur);\\n            cur = 0;\\n        } else {\\n            cur = stack.pop() + Math.max(1, cur*2);\\n        }\\n    }\\n    return cur;\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        cur = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur = stack.pop() + max(1, cur*2)\\n        return cur \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        int cur = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(1, cur*2);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```\n```javascript []\\nvar scoreOfParentheses = function(s) {\\n    let stack = []\\n    let cur = 0;\\n    for(let c of s) {\\n        if(c == \\'(\\') {\\n            stack.push(cur);\\n            cur = 0;\\n        } else {\\n            cur = stack.pop() + Math.max(1, cur*2);\\n        }\\n    }\\n    return cur;\\n};\\n```\n```python []\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        cur = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur = stack.pop() + max(1, cur*2)\\n        return cur \\n```",
                "codeTag": "Java"
            },
            {
                "id": 332150,
                "title": "python3-recursion-solution-beats-100",
                "content": "\\tclass Solution:\\n\\t\\tdef scoreOfParentheses(self, S: str) -> int:\\n\\t\\t\\treturn self.helper(S,0,len(S)-1)        \\n\\t\\tdef helper(self,S,l,r):\\n\\t\\t\\tif r-l==1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(l,r):\\n\\t\\t\\t\\tif S[i]==\\'(\\':\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\tif S[i]==\\')\\':\\n\\t\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\tif count==0:\\n\\t\\t\\t\\t\\treturn self.helper(S,l,i)+self.helper(S,i+1,r)\\n\\t\\t\\treturn 2*self.helper(S,l+1,r-1)",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef scoreOfParentheses(self, S: str) -> int:\\n\\t\\t\\treturn self.helper(S,0,len(S)-1)        \\n\\t\\tdef helper(self,S,l,r):\\n\\t\\t\\tif r-l==1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(l,r):\\n\\t\\t\\t\\tif S[i]==\\'(\\':\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\tif S[i]==\\')\\':\\n\\t\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\tif count==0:\\n\\t\\t\\t\\t\\treturn self.helper(S,l,i)+self.helper(S,i+1,r)\\n\\t\\t\\treturn 2*self.helper(S,l+1,r-1)",
                "codeTag": "Java"
            },
            {
                "id": 1857157,
                "title": "detail-explanation-using-stack",
                "content": "\\n\\n```\\n/*\\nfirst ->we are gonna create a stack of int . . .\\nmain motive is whenever we find \\'(\\' just push -1  into the stack  . . .\\n\\nafter that we have to do this operations --->\\n\\t\\t1) when stack\\'s top == -1 and we find a \\')\\' then it\\'s mean we found () and its value is 1 . so pop the\\n\\t\\t    front element and push 1 . . .\\n\\t\\t2) in 2nd scenario we find a \\')\\' but the stack\\'s top == 1 it\\'s mean the 3rd rule applied here and we have to\\n\\t\\t    calculate all the () parentheses value and after that push the calculated value in the stack . . .\\n\\t\\t3) now if the provided string is \\'()()()\\' then you have to calculate all the value present in the stack . . .\\n\\t\\t4) calculate the stack and return the ans . . .\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int i = 0 ;\\n        while(s[i] != \\'\\\\0\\'){\\n\\t\\t\\n\\t\\t\\t// when we find a open parentheses . . .\\n            if(s[i] == \\'(\\') st.push(-1);\\n\\t\\t\\t\\n\\t\\t\\t// when we find a close parentheses . . .\\n            else{\\n\\t\\t\\t\\t// when we find a () . . .\\n                if(st.top() == -1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n\\t\\t\\t\\t//apply the 3rd rule\\n                else{\\n                    int ans = 0;\\n                    while(st.top() != -1){\\n                        ans += st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*ans);\\n                }\\n            }\\n            i++;\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n## If(solution == helpfull ) upvote \\uD83E\\uDD17 . . .",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n/*\\nfirst ->we are gonna create a stack of int . . .\\nmain motive is whenever we find \\'(\\' just push -1  into the stack  . . .\\n\\nafter that we have to do this operations --->\\n\\t\\t1) when stack\\'s top == -1 and we find a \\')\\' then it\\'s mean we found () and its value is 1 . so pop the\\n\\t\\t    front element and push 1 . . .\\n\\t\\t2) in 2nd scenario we find a \\')\\' but the stack\\'s top == 1 it\\'s mean the 3rd rule applied here and we have to\\n\\t\\t    calculate all the () parentheses value and after that push the calculated value in the stack . . .\\n\\t\\t3) now if the provided string is \\'()()()\\' then you have to calculate all the value present in the stack . . .\\n\\t\\t4) calculate the stack and return the ans . . .\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int i = 0 ;\\n        while(s[i] != \\'\\\\0\\'){\\n\\t\\t\\n\\t\\t\\t// when we find a open parentheses . . .\\n            if(s[i] == \\'(\\') st.push(-1);\\n\\t\\t\\t\\n\\t\\t\\t// when we find a close parentheses . . .\\n            else{\\n\\t\\t\\t\\t// when we find a () . . .\\n                if(st.top() == -1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n\\t\\t\\t\\t//apply the 3rd rule\\n                else{\\n                    int ans = 0;\\n                    while(st.top() != -1){\\n                        ans += st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*ans);\\n                }\\n            }\\n            i++;\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288667,
                "title": "easy-c-solution-using-stack-passess-100-submission",
                "content": "Time Complexity: O(n)\\nSpace Complexiy: O(n)  // using stack\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> a;  // lets assume 0 as (\\n        for(char c : s){\\n            if(c==\\'(\\'){\\n                a.push(0);\\n            } else if(c==\\')\\'){\\n                if(a.top() ==0){   // detect () and replace that with 1\\n                    a.pop();\\n                    a.push(1);\\n                }else {\\n                    int x=0;\\n                    while(a.top() != 0){   // detects complex nested (()) types cases and replaces the block with sum *2 \\n                        x+=a.top();\\n                        a.pop();\\n                    }\\n                    a.pop();\\n                    a.push(2*x);\\n                }\\n            }\\n        }\\n        int x=0;\\n        while(a.size()>0){   // sum the stack value and store in x\\n            x+=a.top();\\n            a.pop();\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> a;  // lets assume 0 as (\\n        for(char c : s){\\n            if(c==\\'(\\'){\\n                a.push(0);\\n            } else if(c==\\')\\'){\\n                if(a.top() ==0){   // detect () and replace that with 1\\n                    a.pop();\\n                    a.push(1);\\n                }else {\\n                    int x=0;\\n                    while(a.top() != 0){   // detects complex nested (()) types cases and replaces the block with sum *2 \\n                        x+=a.top();\\n                        a.pop();\\n                    }\\n                    a.pop();\\n                    a.push(2*x);\\n                }\\n            }\\n        }\\n        int x=0;\\n        while(a.size()>0){   // sum the stack value and store in x\\n            x+=a.top();\\n            a.pop();\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856782,
                "title": "c-efficient-stack-tc-o-n-sc-o-n-with-explanation-clean-solution",
                "content": "##### *Please, Upvote , if you find its helpful :)*\\n##### Let\\'s understand our rule\\'s first of all :-\\n```\\nIf our input string is \"()\" then our score will be 1, so this is our first rule\\nIf we have input string \"()()\" then our score will be 1 + 1 i.e. 2, where 1 is a score of a balanced parentheses. So, this is our second rule\\nNow last rule say\\'s, if we have given something like \"(())\" in our input string, our score will be 2 X 1 i.e. 2, it means that we have something like nested parenthesis. \\nThen multiply it by 2.\\n\\nLet\\'s take a look how do we calculate the score on following examples:\\n()() => 1+1\\n(()()) => 2*(1+1)\\n((()())) => 2*2*(1+1)\\n((()(()))) => 2*2*(1+2*1)\\n```\\n#### Code:-\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        int score=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){//if we find open parenthesis, push the current score into the stack\\n                st.push(score);\\n                score=0;//reset the score to 0\\n            }\\n            else if(s[i]==\\')\\'){//if we find close parenthesis\\n                score=st.top()+ max(2* score , 1);\\n                st.pop();\\n            }\\n        }\\n        return score;//return score\\n    }\\n};\\n```\\n*Time Complexity :- O(N)\\nSpace Complexity :- O(N)*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nIf our input string is \"()\" then our score will be 1, so this is our first rule\\nIf we have input string \"()()\" then our score will be 1 + 1 i.e. 2, where 1 is a score of a balanced parentheses. So, this is our second rule\\nNow last rule say\\'s, if we have given something like \"(())\" in our input string, our score will be 2 X 1 i.e. 2, it means that we have something like nested parenthesis. \\nThen multiply it by 2.\\n\\nLet\\'s take a look how do we calculate the score on following examples:\\n()() => 1+1\\n(()()) => 2*(1+1)\\n((()())) => 2*2*(1+1)\\n((()(()))) => 2*2*(1+2*1)\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        int score=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){//if we find open parenthesis, push the current score into the stack\\n                st.push(score);\\n                score=0;//reset the score to 0\\n            }\\n            else if(s[i]==\\')\\'){//if we find close parenthesis\\n                score=st.top()+ max(2* score , 1);\\n                st.pop();\\n            }\\n        }\\n        return score;//return score\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281710,
                "title": "c-code-easy-to-understand-stack-use",
                "content": "int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else {\\n                    int val=0;\\n                    while(st.top()!=-1){\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        int val=0;\\n        while(st.size()>0){\\n            val+=st.top();\\n            st.pop();\\n        }\\n        return val;\\n    }",
                "solutionTags": [],
                "code": "int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else {\\n                    int val=0;\\n                    while(st.top()!=-1){\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        int val=0;\\n        while(st.size()>0){\\n            val+=st.top();\\n            st.pop();\\n        }\\n        return val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1858780,
                "title": "multiple-c-solutions-with-explanations-using-stack",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019re using a stack to store the values, to store parentheses we\\u2019re using -1, else the value for the parentheses.\\n- There can be 3 cases:\\n    - `if(x == \\'(\\')` we\\u2019ll **push *-1*** in this case to our stack, as it\\u2019s a open parentheses.\\n    - `else if(x == \\')\\' && st.top() == -1)` in this case we are getting open and close parentheses side by side, which derives the value 1, so we pop the top element and **push *1*** to the stack.\\n    - `else if(x == \\')\\' && st.top() != -1)` in this case we\\u2019ve some value in the stack, before a open parentheses. Here we\\u2019ll use a while loop to pop the elements till we found a open parentheses(-1) & add the values to count. After breaking this loop we have a open parentheses at top, we pop that & **push *count*2***\\n- Now add the stack integers to ans and return it.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- This is the optimal solution of the previous one.\\n- Here we\\u2019re pushing the count only if it is an open parentheses.\\n- If it\\u2019s a closing parentheses then we\\u2019ll update the count with `max(1, 2*count)` & add the top element from stack, then pop it. Next time when there is a open parentheses then it\\u2019ll push it to stack and update count to 0.\\n- return count.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size();\\n        int count = 0, ans = 0;\\n        stack<int> st;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(x == \\')\\' && st.top() == -1){\\n                st.pop();\\n                st.push(1);\\n            }\\n            else if(x == \\')\\' && st.top() != -1){\\n                while(st.top() != -1){\\n                    count += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*count);\\n                count = 0;\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(count);\\n                count = 0;\\n            }\\n            else{\\n                count = st.top() + max(1, 2*count);\\n                st.pop();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size();\\n        int count = 0, ans = 0;\\n        stack<int> st;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(x == \\')\\' && st.top() == -1){\\n                st.pop();\\n                st.push(1);\\n            }\\n            else if(x == \\')\\' && st.top() != -1){\\n                while(st.top() != -1){\\n                    count += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*count);\\n                count = 0;\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(count);\\n                count = 0;\\n            }\\n            else{\\n                count = st.top() + max(1, 2*count);\\n                st.pop();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655150,
                "title": "2-approaches-o-1-space-c",
                "content": "Implementation\\n\\n**1st Approach\\nUsing stack\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0);\\n        \\n        for(auto itr : s){\\n            // if meets this \\'(\\' then just add 0 to stack\\n            if(itr == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                // if we meets \\')\\' then take out the top value, and\\n                // check if its 0 then simply add 1 to the next top of the stack, or\\n                // if its more than 0 it means we are already in one inside the level, then\\n                // simply multiply that value by 2, and add it into the next top of the stack\\n                int val = st.top();\\n                st.pop();\\n                int newValue = 0;\\n                if(val){\\n                    newValue = val * 2;\\n                }\\n                else{                    \\n                    newValue = 1;\\n                }\\n                st.top() += newValue;                \\n            }\\n        }\\n        return st.top();\\n    }\\n};\\n```\\n\\n\\n**2nd Approach\\nMost Efficient Approach\\nTime Complexity = O(N), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        \\n        for(int itr = 0; itr < s.size(); itr++){\\n            if(s[itr] == \\'(\\') depth++;\\n            else depth--;\\n            \\n\\t\\t\\t// we need to add the 2^depth, when we are getting any pair like ()\\n            if(s[itr] == \\')\\' && s[itr-1] == \\'(\\'){\\n                res += pow(2, depth);\\n            }            \\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0);\\n        \\n        for(auto itr : s){\\n            // if meets this \\'(\\' then just add 0 to stack\\n            if(itr == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                // if we meets \\')\\' then take out the top value, and\\n                // check if its 0 then simply add 1 to the next top of the stack, or\\n                // if its more than 0 it means we are already in one inside the level, then\\n                // simply multiply that value by 2, and add it into the next top of the stack\\n                int val = st.top();\\n                st.pop();\\n                int newValue = 0;\\n                if(val){\\n                    newValue = val * 2;\\n                }\\n                else{                    \\n                    newValue = 1;\\n                }\\n                st.top() += newValue;                \\n            }\\n        }\\n        return st.top();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        \\n        for(int itr = 0; itr < s.size(); itr++){\\n            if(s[itr] == \\'(\\') depth++;\\n            else depth--;\\n            \\n\\t\\t\\t// we need to add the 2^depth, when we are getting any pair like ()\\n            if(s[itr] == \\')\\' && s[itr-1] == \\'(\\'){\\n                res += pow(2, depth);\\n            }            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141848,
                "title": "c-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int a=0;\\n        int result=0;\\n        for(int i=0;i<S.length()-1;++i)\\n        {\\n            if(S[i]==\\'(\\')\\n            {\\n                if(S[i+1]==\\')\\')\\n                    result+=1<<a;\\n                a++;\\n            }\\n            else\\n                a--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int a=0;\\n        int result=0;\\n        for(int i=0;i<S.length()-1;++i)\\n        {\\n            if(S[i]==\\'(\\')\\n            {\\n                if(S[i+1]==\\')\\')\\n                    result+=1<<a;\\n                a++;\\n            }\\n            else\\n                a--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299821,
                "title": "python-faster-than-83-easy-understanding-explaining-with-comments",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stk = [0]   # temp value to help us\\n\\n        for char in s:\\n            if char == \\'(\\':\\n                stk.append(0)   # new parent: current sum = 0\\n            else:\\n                # An expression will be closed\\n                # Find its value: either 1 for empty () or 2 * its sub-expressions\\n                # we can calc both with a simple max()\\n                value = max(2 * stk.pop(), 1)\\n\\n                # Add the expression sum to its parent current sum\\n                #  Assume we have expression E that is (CHD)\\n                # where C, H, D are valid-subexpressions with values 5, 10, 4\\n                # then E is (5+10+4) = (19) = 38\\n                # Every time we finish an expression, we add its value to its parent\\n                # get the parent and update its sum with a finished sub-expression\\n                stk[-1] += value\\n\\n        return stk.pop()\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stk = [0]   # temp value to help us\\n\\n        for char in s:\\n            if char == \\'(\\':\\n                stk.append(0)   # new parent: current sum = 0\\n            else:\\n                # An expression will be closed\\n                # Find its value: either 1 for empty () or 2 * its sub-expressions\\n                # we can calc both with a simple max()\\n                value = max(2 * stk.pop(), 1)\\n\\n                # Add the expression sum to its parent current sum\\n                #  Assume we have expression E that is (CHD)\\n                # where C, H, D are valid-subexpressions with values 5, 10, 4\\n                # then E is (5+10+4) = (19) = 38\\n                # Every time we finish an expression, we add its value to its parent\\n                # get the parent and update its sum with a finished sub-expression\\n                stk[-1] += value\\n\\n        return stk.pop()\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1149968,
                "title": "c-o-n-time-o-1-space-have-illustration-very-straightforward-and-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/1097015d-9a3d-4aa5-ab1c-f541f4fdb844_1617961993.5570076.png)\\n\\nBy apply rules in the question, we get:\\n**Score**= 2 x (  2x(1+(2x1)+1) + 1 + 2x1 )\\n### = (2x2x1)+ (2x2x2x1) + (2x2x1) + (2x1) + (2x2x1) (**\\\\***)\\n= 22\\n\\nLook at above (\\\\*) expression and line-chart, I see some logical: \\n1. **number of 1s is equal to number of top** in line-chart\\n2. **number of 2s of each sub-expression == (height_of_top  - 1)**\\n\\nExample: Assume height of top is 4 (the second top of above chart), so we have to **multiply 1 by 2^3** \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int top=0, ans=0;\\n        for(int i=0; i<S.size(); i++)\\n        {\\n          if(S[i]==\\'(\\') {\\n            top++;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(S[i+1]==\\')\\') ans+=pow(2,top-1);  // on top\\n\\t\\t  } else top--;\\n        }\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int top=0, ans=0;\\n        for(int i=0; i<S.size(); i++)\\n        {\\n          if(S[i]==\\'(\\') {\\n            top++;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(S[i+1]==\\')\\') ans+=pow(2,top-1);  // on top\\n\\t\\t  } else top--;\\n        }\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080600,
                "title": "score-of-parentheses-stack-python-3-o-n",
                "content": "crr record the score at the current layer level.\\n\\n**If we meet \\'(\\':**\\n1. we push the current score to stack,\\n1. enter the next inner layer level,\\n1. and reset crr = 0.\\n\\n**If we meet \\')\\':**\\n1. we cumulative points of crr while not meet \\'(\\' yet.\\n1. We exit the current layer level,\\n1. and set crr = stack.pop() + crr\\n\\nComplexity: O(N) time and O(N) space\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        crr, stack = 0, []\\n        for pos in range(len(S)):\\n            if S[pos] == \\'(\\':\\n                stack.append(\\'(\\')\\n            else:\\n                while stack[-1] != \\'(\\':\\n                    crr += stack[-1]\\n                    stack.pop()\\n                stack[-1] = crr * 2 if crr else 1\\n                crr = 0\\n        return sum(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        crr, stack = 0, []\\n        for pos in range(len(S)):\\n            if S[pos] == \\'(\\':\\n                stack.append(\\'(\\')\\n            else:\\n                while stack[-1] != \\'(\\':\\n                    crr += stack[-1]\\n                    stack.pop()\\n                stack[-1] = crr * 2 if crr else 1\\n                crr = 0\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080516,
                "title": "c-easy-stack-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int res = 0;\\n        for (auto c : S) {\\n            if (c == \\'(\\') {\\n                stack.push(res);\\n                res = 0;\\n            }\\n            else {\\n                int prev = stack.top();\\n                stack.pop();\\n                res += prev + max(res, 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int res = 0;\\n        for (auto c : S) {\\n            if (c == \\'(\\') {\\n                stack.push(res);\\n                res = 0;\\n            }\\n            else {\\n                int prev = stack.top();\\n                stack.pop();\\n                res += prev + max(res, 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718346,
                "title": "java-use-stack",
                "content": "```\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> st = new Stack<>();\\n        int res = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                st.push(res);\\n                res = 0;\\n            } else {\\n                res = Math.max(1, res * 2);\\n                res += st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> st = new Stack<>();\\n        int res = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                st.push(res);\\n                res = 0;\\n            } else {\\n                res = Math.max(1, res * 2);\\n                res += st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189588,
                "title": "python-concise-100-solution",
                "content": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        stack = [0]\\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                num = stack.pop()\\n                stack[-1] += (1 if num==0 else 2*num)\\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        stack = [0]\\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                num = stack.pop()\\n                stack[-1] += (1 if num==0 else 2*num)\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856351,
                "title": "single-pass-o-n-no-stack-no-recursion",
                "content": "\\n\\n```csharp\\npublic class Solution\\n{\\n    public int ScoreOfParentheses(string s)\\n    {\\n        int res = 0;\\n        int n = 1;\\n        \\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                n *= 2;\\n            }\\n            else\\n            {\\n                n /= 2;\\n                if (s[i - 1] == \\'(\\') res += n;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int ScoreOfParentheses(string s)\\n    {\\n        int res = 0;\\n        int n = 1;\\n        \\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                n *= 2;\\n            }\\n            else\\n            {\\n                n /= 2;\\n                if (s[i - 1] == \\'(\\') res += n;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248095,
                "title": "solution-swift-score-of-parentheses",
                "content": "```swift\\nclass Solution {\\n    func scoreOfParentheses(_ s: String) -> Int {\\n        \\n        var arr = Array(s), val = 0, res = 0\\n        \\n        for i in 0 ..< arr.count {\\n            if arr[i] == \"(\" {\\n                val += 1\\n            } else {\\n                val -= 1\\n                if arr[i-1] == \"(\" { res += 1 << val }\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.008 (0.009) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.scoreOfParentheses(\"()\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.scoreOfParentheses(\"(())\")\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.scoreOfParentheses(\"()()\")\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func scoreOfParentheses(_ s: String) -> Int {\\n        \\n        var arr = Array(s), val = 0, res = 0\\n        \\n        for i in 0 ..< arr.count {\\n            if arr[i] == \"(\" {\\n                val += 1\\n            } else {\\n                val -= 1\\n                if arr[i-1] == \"(\" { res += 1 << val }\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.scoreOfParentheses(\"()\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.scoreOfParentheses(\"(())\")\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.scoreOfParentheses(\"()()\")\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354283,
                "title": "python-using-stack",
                "content": "class Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        if not S:\\n            return 0\\n\\n        count = 0\\n        stack = []\\n        flag = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                flag = 1\\n                stack.append(\"(\")\\n            if S[i] == \")\":\\n                if flag == 1:\\n                    count += 2**(len(stack)-1)\\n                    flag = 0                \\n                stack.pop()\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        if not S:\\n            return 0\\n\\n        count = 0\\n        stack = []\\n        flag = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                flag = 1\\n                stack.append(\"(\")\\n            if S[i] == \")\":\\n                if flag == 1:\\n                    count += 2**(len(stack)-1)\\n                    flag = 0                \\n                stack.pop()\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 3100132,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int x=0;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                st.push(x);\\n                x=0;\\n            }\\n            else\\n            {\\n                if(x==0)\\n                x=1;\\n                else\\n                x*=2;\\n                x+=st.top();\\n                st.pop();\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int x=0;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                st.push(x);\\n                x=0;\\n            }\\n            else\\n            {\\n                if(x==0)\\n                x=1;\\n                else\\n                x*=2;\\n                x+=st.top();\\n                st.pop();\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197544,
                "title": "java-basic-stack-based-solution-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int res = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            char c = S.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(0);\\n            } else if (c == \\')\\') {\\n                int pop = stack.pop() * 2;\\n                pop = (pop == 0) ? 1 : pop;\\n                if (! stack.isEmpty()) {\\n                    int top = stack.pop();\\n                    stack.push(top + pop);\\n                } else {\\n                    res += pop;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nOur line of thinking is like this: when you see a new opening bracket, you\\'ll later need to double the \"score\" of everything inside of it. When you see a closing bracket, pop the stack to retrieve the \"score\" of what\\'s inside the pair, double the score (because of (A) = 2 * A, given in problem), then use it as a sum term; if it\\'s inside another bracket, then add that to what\\'s now at the top of the stack, because it needs to be part of that \"doubling\" operation. If the stack is empty, then just add it straight to your final answer.\\n\\nThe ternary operator in the popping operation area is because if you end up with \\'()\\', there is nothing inside of it, but the score should be 1, not 0. So, we treat that as a special case.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int res = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            char c = S.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(0);\\n            } else if (c == \\')\\') {\\n                int pop = stack.pop() * 2;\\n                pop = (pop == 0) ? 1 : pop;\\n                if (! stack.isEmpty()) {\\n                    int top = stack.pop();\\n                    stack.push(top + pop);\\n                } else {\\n                    res += pop;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142807,
                "title": "a-few-solutions",
                "content": "Perform a linear scan of the input string `s` keeping track of the parenthesis `depth` to accumulate the answer `ans` by performing reductions when the previous `pre` and current `cur` characters are `\\'(\\'` and `\\')\\'` correspondingly.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun scoreOfParentheses(s: String): Int {\\n        var ans = 0\\n        var pre = \\'0\\'\\n        var depth = 0\\n        for (cur in s) {\\n            depth += if (cur == \\'(\\') 1 else -1\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 shl depth\\n            pre = cur\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet scoreOfParentheses = (s, depth = 0, pre = \\'0\\', ans = 0) => {\\n    for (cur of s) {\\n        depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n        if (pre == \\'(\\' && cur == \\')\\')\\n            ans += 1 << depth;\\n        pre = cur;\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str, depth = 0, pre = \\'0\\', ans = 0) -> int:\\n        for cur in s:\\n            depth += 1 if cur == \\'(\\' else -1\\n            if pre == \\'(\\' and cur == \\')\\':\\n                ans += 1 << depth\\n            pre = cur\\n        return ans\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut ans = 0;\\n        let mut pre = \\'0\\';\\n        let mut depth = 0;\\n        for cur in s.chars() {\\n            depth += if cur == \\'(\\' { 1 } else { -1 };\\n            if pre == \\'(\\' && cur == \\')\\' {\\n                ans += 1 << depth;\\n            }\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int depth = 0, char pre = \\'0\\', int ans = 0) {\\n        for (auto cur: s) {\\n            depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 << depth;\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun scoreOfParentheses(s: String): Int {\\n        var ans = 0\\n        var pre = \\'0\\'\\n        var depth = 0\\n        for (cur in s) {\\n            depth += if (cur == \\'(\\') 1 else -1\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 shl depth\\n            pre = cur\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nlet scoreOfParentheses = (s, depth = 0, pre = \\'0\\', ans = 0) => {\\n    for (cur of s) {\\n        depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n        if (pre == \\'(\\' && cur == \\')\\')\\n            ans += 1 << depth;\\n        pre = cur;\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str, depth = 0, pre = \\'0\\', ans = 0) -> int:\\n        for cur in s:\\n            depth += 1 if cur == \\'(\\' else -1\\n            if pre == \\'(\\' and cur == \\')\\':\\n                ans += 1 << depth\\n            pre = cur\\n        return ans\\n```\n```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut ans = 0;\\n        let mut pre = \\'0\\';\\n        let mut depth = 0;\\n        for cur in s.chars() {\\n            depth += if cur == \\'(\\' { 1 } else { -1 };\\n            if pre == \\'(\\' && cur == \\')\\' {\\n                ans += 1 << depth;\\n            }\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int depth = 0, char pre = \\'0\\', int ans = 0) {\\n        for (auto cur: s) {\\n            depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 << depth;\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141786,
                "title": "c-java-3-lines-recursion",
                "content": "Search for the first balanced group, multiply by 2 the value of the inner string, and add the value of the remaning string.\\n```\\nint scoreOfParentheses(string S, int i = 1) {\\n  if (S.size() == 0) return 0;\\n  for (auto ch = 1; ch != 0; ++i) ch += S[i] == \\'(\\' ? 1 : -1;\\n  return (i == 2 ? 1 : 2 * scoreOfParentheses(S.substr(1, i - 2))) + scoreOfParentheses(S.substr(i));\\n}\\n```\\nJava version:\\n```\\npublic int scoreOfParentheses(String S) {\\n    int ch = S.length() == 0 ? 0 : 1, i = 1;\\n    for (; ch != 0; ++i) ch += S.charAt(i) == \\'(\\' ? 1 : -1;\\n    return i == 1 ? 0 : (i == 2 ? 1 : 2 * scoreOfParentheses(S.substring(1, i - 1))) + scoreOfParentheses(S.substring(i));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string S, int i = 1) {\\n  if (S.size() == 0) return 0;\\n  for (auto ch = 1; ch != 0; ++i) ch += S[i] == \\'(\\' ? 1 : -1;\\n  return (i == 2 ? 1 : 2 * scoreOfParentheses(S.substr(1, i - 2))) + scoreOfParentheses(S.substr(i));\\n}\\n```\n```\\npublic int scoreOfParentheses(String S) {\\n    int ch = S.length() == 0 ? 0 : 1, i = 1;\\n    for (; ch != 0; ++i) ch += S.charAt(i) == \\'(\\' ? 1 : -1;\\n    return i == 1 ? 0 : (i == 2 ? 1 : 2 * scoreOfParentheses(S.substring(1, i - 1))) + scoreOfParentheses(S.substring(i));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858290,
                "title": "score-of-parentheses-o-n-simple-java-for-loop",
                "content": "Hello everyone,\\n\\nThe description looks like an easy one, but little tricks are there.\\n\\nI did not use data structures as the restrictions are straightforward.\\nThe idea and thought process behind this is as follows:\\n\\t1. Based on the conditions, we could see the first character will be an open bracket\\n\\t2. Whenever open bracket and close bracket comes together -> () we will sum the result\\n\\t3. Another thing is we have to double the bracket whenever we see an open bracket -> \\'(\\'  and divide the bracket whenever we see close bracket -> \\')\\'\\n\\nThese 3 points will work even with any loops. Please upvote if its helpful.. Happy learning :)\\n\\n```\\n    public int scoreOfParentheses(String s) {\\n        int res = 0;\\n        int bracket = 0;\\n        for(int i=0; i<s.length(); i++){\\n        \\tif(s.charAt(i)==\\'(\\')\\n            \\tbracket*=2;\\n        \\tif(bracket==0)\\n        \\t\\tbracket=1;\\n        \\tif(s.charAt(i)==\\')\\' && s.charAt(i-1)==\\'(\\')\\n        \\t\\tres = res + bracket;\\n        \\tif(s.charAt(i)==\\')\\')\\n        \\t\\tbracket/=2;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hello everyone,\\n\\nThe description looks like an easy one, but little tricks are there.\\n\\nI did not use data structures as the restrictions are straightforward.\\nThe idea and thought process behind this is as follows:\\n\\t1. Based on the conditions, we could see the first character will be an open bracket\\n\\t2. Whenever open bracket and close bracket comes together -> () we will sum the result\\n\\t3. Another thing is we have to double the bracket whenever we see an open bracket -> \\'(\\'  and divide the bracket whenever we see close bracket -> \\')\\'\\n\\nThese 3 points will work even with any loops. Please upvote if its helpful.. Happy learning :)\\n\\n```\\n    public int scoreOfParentheses(String s) {\\n        int res = 0;\\n        int bracket = 0;\\n        for(int i=0; i<s.length(); i++){\\n        \\tif(s.charAt(i)==\\'(\\')\\n            \\tbracket*=2;\\n        \\tif(bracket==0)\\n        \\t\\tbracket=1;\\n        \\tif(s.charAt(i)==\\')\\' && s.charAt(i-1)==\\'(\\')\\n        \\t\\tres = res + bracket;\\n        \\tif(s.charAt(i)==\\')\\')\\n        \\t\\tbracket/=2;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1857804,
                "title": "c-3-approach-stack-in-place-stack-counter",
                "content": "# 1. stack approach\\nBy intuitation of this problem, many people can use stack to solve it.\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                stk.push( stk.empty()?1:stk.top()*2);\\n            } else {//s[i]==\\')\\'\\n                sum +=stk.top();\\n                stk.pop();\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        return sum;        \\t\\n\\t}\\n};\\n```\\nTime complexity = O(n), Space complexity = O(n)\\nNow, we want to improve space complexity from O(n) to O(1)\\n\\n\\n# in-place stack approach but out of value\\n\\nWe use the space in left part of string s as the in-place stack. \\nWe can have the following solution but character only can show 0~255. \\nbut 2^50 is larget than 255. \\nSo, the in-place stack approach is out of char value for this algorithm.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?1:s[stk_idx]*2;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                sum +=s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\n\\t}\\n};\\n```\\n# 2. in-place stack approach \\nBecause the sum always add value of power(2, x). \\nwe can save x in the in-place stack. so the in-place stack \\nwill not out of value. \\n\\nTime complexity O(n)\\nSpace complexity O(1)\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?0:s[stk_idx]+1;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                //sum +=s[stk_idx];\\n                sum += 1<<s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\\n\\n# in-place stack approach that simplify into one variable\\nIn the previous method, you can observe the values store in your stack \\nis somethign like [1,2,3,4,5,...,t]. Thus one variable can represent this stack. \\nWe have the following code to use one variable to represent this stack.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int stk= -1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++stk;\\n            } else {\\n                sum += 1<<(stk);\\n                --stk;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    ++i;\\n                    --stk;\\n                }\\n            }\\n        }\\n        return sum;        \\n\\t}\\n};\\n```\\n\\nThat\\'s so interesting, the stack is become a counter.\\nAnd we need to observe more and find out new approach. \\n`()` = 1 = 2^`0` .The substring lead by `()` is `()`.\\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 0\\n\\n((((`()`)))) = 2^`4`  The substring lead by `()` is (((((), \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\n\\nObserve this string\\n((((`()`)(`()`))))\\n\\nthere are two `()` in this string, and each `()` mean one value.\\nso we need to sum of this two values. \\nThe substring lead by left `()` is (((((), so \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\nSo, the value for left  `()` is 2^4. \\n\\nThe substring lead by right `()` is (((((), so \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\nSo, the value for left  `()` is 2^4. \\n\\nFor the right `()`, the substring it lead is ((((())(() , so \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\nThe value of right `()` is 2^4. \\n\\nSo the value of \"((((())(()))))\" is 2^4 + 2^4 = 32 \\n\\nFor this observation , we can write the following counter approach.\\n# 3. counter approach\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++cnt;\\n            } else if(s[i]==\\')\\') {\\n                --cnt;\\n            }\\n            if(i-1>=0 && s[i-1]==\\'(\\' && s[i]==\\')\\') {\\n                sum += 1<<cnt;\\n            }\\n            \\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\\nTime complexity : O(n)\\nSpace complexity: O(1)\\n\\nThere is something intresting here. \\nIf you compare the two source code from \\n**in-place stack approach that simplify into one variable**  \\nand **counter approach**. these two source code  are almost the same. \\n\\nBy the way, if you want to optimize the code of counter approach, we can do this\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0, ans =0, n = s.length();\\n        for(int i = 0;i<n;i++) \\n            if(s[i] == \\'(\\')\\n                ++cnt;\\n            else\\n                ans += (s[i-1]==\\'(\\')<<--cnt;\\n        return ans;\\t\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                stk.push( stk.empty()?1:stk.top()*2);\\n            } else {//s[i]==\\')\\'\\n                sum +=stk.top();\\n                stk.pop();\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        return sum;        \\t\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?1:s[stk_idx]*2;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                sum +=s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?0:s[stk_idx]+1;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                //sum +=s[stk_idx];\\n                sum += 1<<s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int stk= -1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++stk;\\n            } else {\\n                sum += 1<<(stk);\\n                --stk;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    ++i;\\n                    --stk;\\n                }\\n            }\\n        }\\n        return sum;        \\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++cnt;\\n            } else if(s[i]==\\')\\') {\\n                --cnt;\\n            }\\n            if(i-1>=0 && s[i-1]==\\'(\\' && s[i]==\\')\\') {\\n                sum += 1<<cnt;\\n            }\\n            \\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0, ans =0, n = s.length();\\n        for(int i = 0;i<n;i++) \\n            if(s[i] == \\'(\\')\\n                ++cnt;\\n            else\\n                ans += (s[i-1]==\\'(\\')<<--cnt;\\n        return ans;\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856605,
                "title": "c-simplest-solution-0ms-w-explanation",
                "content": "The approach is to use stack but it\\'s a little different from our intuition. We do not push the characters in the given string. \\nInstead, we push the score onto stack.\\n\\n**APPROACH :**\\n\\n* We start with ```score = 0```.\\n\\n* If the current char is ```(```, we push the curr score on to the stack & reset the score to ```0```.\\n\\n*  Else if the current character is ```)```, we calculate the score & pop the top of the stack :\\n\\n         1. ```score = st.top() + max(score*2 + 1)``` .\\n         \\n         2. This is because, we need to add the previous score as we traverse the string & compute the current score (```st.top()```)\\n         \\n         3. If the score is set back to ```0```, after a ```(``` is pushed, then the score has to be ```1``` when ```)``` is encountered.\\n         \\n         4. If the parantheses are this way -- ```( ( ) )```, then the inner parantheses score is computed as ```1``` & then we encounter the outer ```)```.\\n         \\n         5. Now, the score is ```1```, so we need to do ```2*score```.\\n         \\n         6. Add the current score to the previous : ```curr score+ st.top()```\\n\\n\\n**Time Complexity :** O(n) - We are visiting each character only once.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size(), score = 0;\\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\') {\\n                st.push(score);\\n                score = 0;\\n            } else {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return score;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```score = 0```\n```(```\n```0```\n```)```\n```score = st.top() + max(score*2 + 1)```\n```st.top()```\n```0```\n```(```\n```1```\n```)```\n```( ( ) )```\n```1```\n```)```\n```1```\n```2*score```\n```curr score+ st.top()```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size(), score = 0;\\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\') {\\n                st.push(score);\\n                score = 0;\\n            } else {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231515,
                "title": "c-0ms-sol-beats-100-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                //we store the \\'(\\' as -1 in stack\\n                stk.push(-1);\\n            }\\n            else{\\n                int res=0;\\n                    while(stk.top()!=-1)\\n                    {\\n                        //until a opening bracket\\n                        //we sum up all the numbers \\n                        //multiply by 2 and we push it\\n                        res+=stk.top();\\n                        stk.pop();\\n                    }\\n                //remove the opening bracket\\n                stk.pop();\\n                (res==0) ? stk.push(1) : stk.push(2*res);\\n            }\\n        }\\n        int ans=0;\\n        while (!stk.empty()){\\n            ans+=stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                //we store the \\'(\\' as -1 in stack\\n                stk.push(-1);\\n            }\\n            else{\\n                int res=0;\\n                    while(stk.top()!=-1)\\n                    {\\n                        //until a opening bracket\\n                        //we sum up all the numbers \\n                        //multiply by 2 and we push it\\n                        res+=stk.top();\\n                        stk.pop();\\n                    }\\n                //remove the opening bracket\\n                stk.pop();\\n                (res==0) ? stk.push(1) : stk.push(2*res);\\n            }\\n        }\\n        int ans=0;\\n        while (!stk.empty()){\\n            ans+=stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098596,
                "title": "2-solutions-with-pictures",
                "content": "The first idea is straightforward:\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/b908f74e-09de-4e16-b417-a529bc2bdecd_1615384272.95443.png)\\n\\n<br>\\n\\nIn order to store the results of `B` calculation we need a separate variable from the one we used for `A`. After we are done with `B` we no longer need it as we add it to \\'A\\'. But in the process of calculating `B` we may need new variable to calculate say `C`. It seems like we have recursion and we need a stack to store the calculations on the current recursive call. Also there are two alternatives:\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/428b95c1-25b5-47fd-a4dc-68fd0c01920a_1615386243.2236943.png)\\n\\n\\n<br>\\n\\nThat\\'s not that important, you can do it either way.\\n\\n**`Stack` based \"delayed\" calculations**: time `O(N)`, space `O(N)`\\nAs we have seen the basic idea is the following:\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/617dfffb-40f5-448a-96af-3ed18cbb45fa_1615301025.9395669.png)\\n\\n<br>\\n\\nHere the caller does the doubling and adding.\\nYou can think about it like a company that has bank account(stack frame). Inside a mother company there are multiple projects(labs). Every time a new project is created it\\'s given it\\'s own bank account with `0` money on it. At the end of the project it\\'s earned money is funnelled back into the mother organization. Projects are allowed to open it\\'s own subprojects. That\\'s recursion, hence the use of stack.\\n\\nHere\\'s implementation and a more accurate picture. The calee does the doubling and the caller does the adding. New stack is created every time `\\'(\\'` is encountered and is closed in case of `\\')\\'`.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/86ed0703-b119-489d-bd03-4acc2c0aef20_1615397817.871677.png)\\n\\n<br>\\n\\nAll in all the above algo is **DFS** in the following tree.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/fdcd1f99-6a9a-4725-9eee-ea7bab0084e8_1615402799.2036629.png)\\n\\n<br>\\n\\n*Iterative*\\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tstack<int> st({0});\\n\\tfor(const auto & c : s)\\n\\t\\tif(c==\\')\\')\\n\\t\\t{\\n\\t\\t\\tauto t{max(1, 2*st.top())};\\n\\t\\t\\tst.pop();\\n\\t\\t\\tst.top() += t;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tst.push(0);\\n\\n\\treturn st.top();\\n}\\n```\\n*Recursive*\\n```\\nint scoreOfParentheses(string & s, int && i = -1) \\n{\\n\\tint out{0};\\n\\tfor( ; ++i<size(s); )\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\tout+=scoreOfParentheses(s, move(i)); \\n\\t\\telse\\n\\t\\t\\treturn max(1, 2*out);\\n\\n\\treturn out;\\n}\\n```\\n**Global_state_variable based \"global\" calculations**:  time `O(N)`, space `O(1)`\\nAs we can see all we do is the doubling and adding (in other words we are adding the powers of two). Instead of adding `b` and `c` and then adding the `out` variable, we can add `b` to result and  `c` to `out` **directly**.\\nThus the adding is done only at the **leaf-nodes** of the tree, but to do that they need to know their height.\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/e339f56e-5836-4b07-9146-e0dbd3c145fb_1615402274.453685.png)\\n\\n\\n<br>\\n\\nIn fact you don\\'t need stacks and trees, you can use one variable to track height (or power of two) and modify `out` when you encounter `()`(leaf).\\n\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/06b5736c-5fab-4a1b-91ee-1de12514b9d1_1615298484.7858808.png)\\n\\n*Iterative*\\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t{\\n\\t\\tp = s[i]==\\')\\' ? p/2 : p*2;\\n\\t\\tif(s[i]==\\')\\' and s[i-1]==\\'(\\') out+=p;            \\n\\t}\\n\\n\\treturn out;\\n}\\n```\\n||\\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\')\\')\\n\\t\\t{\\n\\t\\t\\tp>>=1;\\n\\t\\t\\tif(s[i-1]==\\'(\\') out+=p;   \\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tp<<=1;\\n\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint scoreOfParentheses(string s) \\n{\\n\\tstack<int> st({0});\\n\\tfor(const auto & c : s)\\n\\t\\tif(c==\\')\\')\\n\\t\\t{\\n\\t\\t\\tauto t{max(1, 2*st.top())};\\n\\t\\t\\tst.pop();\\n\\t\\t\\tst.top() += t;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tst.push(0);\\n\\n\\treturn st.top();\\n}\\n```\n```\\nint scoreOfParentheses(string & s, int && i = -1) \\n{\\n\\tint out{0};\\n\\tfor( ; ++i<size(s); )\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\tout+=scoreOfParentheses(s, move(i)); \\n\\t\\telse\\n\\t\\t\\treturn max(1, 2*out);\\n\\n\\treturn out;\\n}\\n```\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t{\\n\\t\\tp = s[i]==\\')\\' ? p/2 : p*2;\\n\\t\\tif(s[i]==\\')\\' and s[i-1]==\\'(\\') out+=p;            \\n\\t}\\n\\n\\treturn out;\\n}\\n```\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\')\\')\\n\\t\\t{\\n\\t\\t\\tp>>=1;\\n\\t\\t\\tif(s[i-1]==\\'(\\') out+=p;   \\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tp<<=1;\\n\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081394,
                "title": "c-single-pass-constant-space-solutions-explained-100-time-80-space",
                "content": "Read this problem this morning, had an intuition (well, a partial one) and my mind kept working on it in any break I took.\\n\\nAnd this is the final version.\\n\\nThe key intuition was to navigate it like a tree, but possibly in constant time; and then I realised that the trick is to keep track of how deep we go and add something to an accumulator variable only when we find `\\'(\\'` immediately followed by `\\')\\'` - which means we found a base expression `\"()\"` whose score is going to be equal to `pow(2, depthOfTheExpression)`.\\n\\nAny other instance of `\\'(\\'` or `\\')\\'` will just mean to go either deeper or up in an ideally nested tree.\\n\\nTo do so, we declared a few support variables:\\n* `res` is going to be our accumulator, initially set to `0`;\\n* `isOpen` is a boolean to keep track of the logic above and we will set it to `true` after each `\\'(\\'` and to `false` after each `\\')\\'`.\\n\\nTime then for the main loop, going with `i` up to `lmt` (the length of the string), setting also a counting variable `c = 0` and:\\n* when `s[i] == \\'(\\'` we will:\\n\\t* set `isOpen` to `true`;\\n\\t* increase `c`;\\n* otherwise:\\n\\t* decrease `c`;\\n\\t* if `isOpen` we will additionally:\\n\\t\\t* increase `res` by `pow(2, c)` (note that we decrease `c` in advance, not to count the current level);\\n\\t\\t* reset `isOpen` to `false`.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        bool isOpen;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') {\\n                c++;\\n                isOpen = true;\\n            }\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (isOpen) {\\n                    isOpen = false;\\n                    res += pow(2, c);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\nAnd then it occurred to me that we do not really need even the boolean flag, since just looking at the previous character (and we know that since the string is balance we will never encounter a `\\')\\'` at the beginning of the string) tells us just the same; surprisingly, we save a good chunk of memory this way - I guess mostly for not having to do needless operations:\\n\\n```cpp\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') c++;\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (s[i - 1] == \\'(\\') res += pow(2, c);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFinally, same logic in recursive format, just for the lolZ - going as fast, just burning a bit more memory:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int pos = 0, int c = 0, int res = 0) {\\n        return pos == s.size() ? res : scoreOfParentheses(s, pos + 1, c + (s[pos] == \\'(\\' ? 1 : -1), res + ((c && s[pos - 1] == \\'(\\' && s[pos] == \\')\\') ? pow(2, c - 1) : 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        bool isOpen;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') {\\n                c++;\\n                isOpen = true;\\n            }\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (isOpen) {\\n                    isOpen = false;\\n                    res += pow(2, c);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') c++;\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (s[i - 1] == \\'(\\') res += pow(2, c);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int pos = 0, int c = 0, int res = 0) {\\n        return pos == s.size() ? res : scoreOfParentheses(s, pos + 1, c + (s[pos] == \\'(\\' ? 1 : -1), res + ((c && s[pos - 1] == \\'(\\' && s[pos] == \\')\\') ? pow(2, c - 1) : 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081329,
                "title": "score-of-parentheses-easy-to-understand-explanation-javascript-code",
                "content": "Initially I read this and it seemed quite easy.  However once I tried to implement it, I was caught up in odd recursive calls which sometimes worked, and others didn\\'t.  After passing my 30minute self timer I gave up and went to the solution.  Even understanding that was a challenge so I will attempt to improve on the solution explanation.\\n\\nOk, one way to think of this problem is in the number of \\'()\\' or cores.  I dont mean nesting, I mean the literal \\'()\\'.  The answer is the sum of those values.  The nesting only serves to double their value.  So, no need to do a recursive call, or even use a stack.  \\n\\nHow can we do this in a linear fashion?  Ok, loop though your string.  Every time u notice a (, you increment your depth counter.  If the current char is not a (, it must be a ).  Now you have two possibilities, the previous char could have been a (, in which case, u\\'ve got a core (), so add its value to the score (more on the calc later, see next paragraph).  Or the previous character could have been another ), ie )).  In that case u don\\'t have a core, but you still need to decrement the nesting level, which previously you had incremented on a prior iteration of seeing (.  \\n\\nRegarding that core value.  What is it?  Well check how many levels it is nested and double its value that many times.  So (()) would be 1*2^depth or using a bitwise operator, 1 shifted 1 place, so 1 << 1 = 2  \\n\\nIn summary: The trick is to evaluate each \\'core\\' as you encounter it, adding its value to the score. For it\\'s score, you\\'ll keep track of how deep the nesting is, sometimes decrementing the nesting as necessary when you find closing parens.\\n\\n```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth;  //binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth;  //binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1080564,
                "title": "python-o-n-by-stack-w-comment",
                "content": "Python O(n) by stack\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        \\n        stack = []\\n\\t\\t\\n\\t\\t# cur: total score so far\\n\\t\\t# prev: previous score\\n        cur, prev = 0, 0\\n        \\n        \\n        # scan each symbol in input S\\n        for char in S:\\n            \\n            if char == \\'(\\':\\n                \\n                # \\'(\\', push in with current socre\\n                stack.append( cur )\\n                \\n                # reset previous and current to zero\\n                prev, cur = 0, 0\\n            \\n            else:\\n                \\n                # \\')\\' match with latest \\'(\\', get top score\\n                top = stack.pop()\\n                \\n                if prev:\\n                    # we have valid parenthesis pair inside, add prev\\n                    cur += top + prev\\n                else:\\n                    # no parenthesis pair inside, directly add 1\\n                    cur += top + 1\\n            \\n            # update previous as current\\n            prev = cur\\n        \\n        \\n        # total score so far\\n        return cur\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        \\n        stack = []\\n\\t\\t\\n\\t\\t# cur: total score so far\\n\\t\\t# prev: previous score\\n        cur, prev = 0, 0\\n        \\n        \\n        # scan each symbol in input S\\n        for char in S:\\n            \\n            if char == \\'(\\':\\n                \\n                # \\'(\\', push in with current socre\\n                stack.append( cur )\\n                \\n                # reset previous and current to zero\\n                prev, cur = 0, 0\\n            \\n            else:\\n                \\n                # \\')\\' match with latest \\'(\\', get top score\\n                top = stack.pop()\\n                \\n                if prev:\\n                    # we have valid parenthesis pair inside, add prev\\n                    cur += top + prev\\n                else:\\n                    # no parenthesis pair inside, directly add 1\\n                    cur += top + 1\\n            \\n            # update previous as current\\n            prev = cur\\n        \\n        \\n        # total score so far\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939553,
                "title": "python3-stack-o-n",
                "content": "Approach 1 - stack `O(N)` space \\nDefine `stack` to store values when entering into a pair parenthesis. \\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, stack = 0, []\\n        for c in S: \\n            if c == \"(\": \\n                stack.append(ans)\\n                ans = 0\\n            else: ans = max(1, 2*ans) + stack.pop()\\n        return ans\\n```\\n\\nApproach 2 - `O(1)` space \\nThe required value is related to the depth of parenthesis via `2**k`. \\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans = k = 0\\n        for i in range(len(S)): \\n            k += 1 if S[i] == \"(\" else -1\\n            if S[i-1:i+1] == \"()\": ans += 2**k\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, stack = 0, []\\n        for c in S: \\n            if c == \"(\": \\n                stack.append(ans)\\n                ans = 0\\n            else: ans = max(1, 2*ans) + stack.pop()\\n        return ans\\n```\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans = k = 0\\n        for i in range(len(S)): \\n            k += 1 if S[i] == \"(\" else -1\\n            if S[i-1:i+1] == \"()\": ans += 2**k\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 512631,
                "title": "python-simple-readable-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, val = 0, 1\\n        for i in range(len(S) - 1):\\n            if S[i: i+2] == \\'((\\': val *= 2\\n            if S[i: i+2] == \\'()\\': ans += val\\n            if S[i: i+2] == \\'))\\': val //= 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, val = 0, 1\\n        for i in range(len(S) - 1):\\n            if S[i: i+2] == \\'((\\': val *= 2\\n            if S[i: i+2] == \\'()\\': ans += val\\n            if S[i: i+2] == \\'))\\': val //= 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141823,
                "title": "c-recursive",
                "content": "This is how many of the top scorers solved the problem.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(string s, int a, int b) {\\n        \\n        int v = 0;\\n        \\n        if (b - a == 1)  return 1; // \"()\"\\n                \\n        for (int i=a; i<=b; i++) {\\n            \\n            if (s[i] == \\'(\\') v++;\\n            else if (s[i] == \\')\\') v--;\\n            \\n            if (v==0 && i!=b)\\n                return helper(s, a, i) + helper(s, i+1, b); // (...) + (...)\\n        }\\n        \\n        return 2*helper(s, a+1, b-1); // (...)\\n\\n    }\\n\\n    \\n    int scoreOfParentheses(string S) {\\n        return helper(S, 0, S.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(string s, int a, int b) {\\n        \\n        int v = 0;\\n        \\n        if (b - a == 1)  return 1; // \"()\"\\n                \\n        for (int i=a; i<=b; i++) {\\n            \\n            if (s[i] == \\'(\\') v++;\\n            else if (s[i] == \\')\\') v--;\\n            \\n            if (v==0 && i!=b)\\n                return helper(s, a, i) + helper(s, i+1, b); // (...) + (...)\\n        }\\n        \\n        return 2*helper(s, a+1, b-1); // (...)\\n\\n    }\\n\\n    \\n    int scoreOfParentheses(string S) {\\n        return helper(S, 0, S.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405044,
                "title": "c-100-beats-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n\\n        for(auto it : s)    {\\n            if(it == \\'(\\')   st.push(-1);\\n            else if(st.top()==-1)    {\\n                st.pop();\\n                st.push(1);\\n            }\\n            else    {\\n                int x = 0;\\n                while(st.top() != -1)   {\\n                    x += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*x);\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty())  {\\n            ans += st.top();\\n            st.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n\\n        for(auto it : s)    {\\n            if(it == \\'(\\')   st.push(-1);\\n            else if(st.top()==-1)    {\\n                st.pop();\\n                st.push(1);\\n            }\\n            else    {\\n                int x = 0;\\n                while(st.top() != -1)   {\\n                    x += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*x);\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty())  {\\n            ans += st.top();\\n            st.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860335,
                "title": "explained-go-clean-solution-using-stack-beats-100-on-runtime-92-on-memory",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe Stack is a common data structure we use when dealing with parentheses problems.\\n\\nSo let\\'s implement a simple slice-based Stack:\\n    1. Create a Stack structure that holds the data field of type []rune.\\n    2. Define the Push method to add a new value to the Stack using simple append().\\n    3. Define the Pop method to remove the top element from the Stack returning this very element. We can remove the last element of the array using slicing: slice = slice[:len(slice)-1].\\n\\nThen we implement our business logic:\\n1. Initialize an empty stack and a multiplier equal to 1. The multiplier variable will be added to the answer every time we see the \"()\" in our input string.\\n2. Let\\'s loop through the input string: \\n    a. Pop the element from the top of the stack.\\n    b. If the top element is \\'(\\' and we got \\')\\' as the current character, add the multiplier to the answer.\\n    c. If we get two consecutive \"((\", then, as stated in the problem description, multiply the multiplier by 2.\\n    d. If we get two consecutive \"))\", then we divide the multiplier by 2.\\n    e. Push the current character to the stack.\\n\\n# Complexity\\n- Time complexity: $O(n)$ - one pass through the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ - we need to store **at most** half of the input string in our stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Stack struct {\\n    data []rune\\n}\\n\\nfunc (s *Stack) Push(val rune) {\\n    s.data = append(s.data, val)\\n}\\n\\nfunc (s *Stack) Pop() rune {\\n    if len(s.data) == 0 {\\n        var r rune\\n        return r\\n    }\\n\\n    top := s.data[len(s.data) - 1]\\n    (*s).data = s.data[:len(s.data) - 1]\\n    return top\\n}\\n\\nfunc scoreOfParentheses(s string) int {\\n    var stack Stack\\n\\n    ans := 0\\n    multiplier := 1\\n    for _, c := range s {\\n        top := stack.Pop()\\n\\n        switch {\\n        case top == \\'(\\' && c == \\')\\':\\n            ans += multiplier\\n        case top == \\'(\\' && c == \\'(\\':\\n            multiplier *= 2\\n        case top == \\')\\' && c == \\')\\':\\n            multiplier /= 2\\n        }\\n\\n        stack.Push(c)\\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Stack"
                ],
                "code": "```\\ntype Stack struct {\\n    data []rune\\n}\\n\\nfunc (s *Stack) Push(val rune) {\\n    s.data = append(s.data, val)\\n}\\n\\nfunc (s *Stack) Pop() rune {\\n    if len(s.data) == 0 {\\n        var r rune\\n        return r\\n    }\\n\\n    top := s.data[len(s.data) - 1]\\n    (*s).data = s.data[:len(s.data) - 1]\\n    return top\\n}\\n\\nfunc scoreOfParentheses(s string) int {\\n    var stack Stack\\n\\n    ans := 0\\n    multiplier := 1\\n    for _, c := range s {\\n        top := stack.Pop()\\n\\n        switch {\\n        case top == \\'(\\' && c == \\')\\':\\n            ans += multiplier\\n        case top == \\'(\\' && c == \\'(\\':\\n            multiplier *= 2\\n        case top == \\')\\' && c == \\')\\':\\n            multiplier /= 2\\n        }\\n\\n        stack.Push(c)\\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1857575,
                "title": "python-solution-using-stack-with-explanation",
                "content": "```\\n######################################################\\n\\n#   Runtime: 28ms   -   94.45%\\n#   Memory: 13.8MB  -   70.86%\\n\\n######################################################\\n\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n\\n        stack = []\\n        # Looping through string\\n        for char in s:\\n            # If char is \"(\" we add it to stack\\n            if char == \"(\":\\n                stack.append(\"(\")\\n            else:\\n                # If char is \")\", we pop out the top element from stack till\\n                # we find \"(\". The popped elements will be 2 * score of child\\n                # balanced parentheses of current closed parentheses we have found\\n                # So we will add them to score var\\n                score = 0\\n                while stack[-1] != \"(\":\\n                    score += stack.pop()\\n                # If score is 0, that means the top of stack is \"(\" and we have\\n                # () in the string. So we make score 1\\n                if score == 0: score = 1\\n                # We remove \"(\" from stack\\n                stack.pop()\\n                # We append twice the actual score that a balanced parentheses should\\n                # have into the stack\\n                stack.append( 2 * score)\\n        # stack will have only 1 element if s is of format \"(A)\"\\n        # Else it will have > 1 element.\\n        # Each element will be int of scores multiplied by 2.\\n        # We add them and divide by 2 to remove that extra multiple 2 which we have done\\n        # in our logic\\n        return sum(stack) // 2\\n\\n        \"\"\"\\n            Example: \"(()())()\"\\n            char        stack\\n             (            [\"(\"]\\n             (            [\"(\", \"(\"]\\n             )            [\"(\", 2]\\n             (            [\"(\", 2, \"(\"]\\n             )            [\"(\", 2, 2]\\n             )            [8]\\n             (            [8, \"(\"]\\n             )            [8, 2]\\n\\n            Finally sum(stack) // 2\\n                    = (8 + 2) // 2\\n                    = 5\\n            which is the score of that string\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n######################################################\\n\\n#   Runtime: 28ms   -   94.45%\\n#   Memory: 13.8MB  -   70.86%\\n\\n######################################################\\n\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n\\n        stack = []\\n        # Looping through string\\n        for char in s:\\n            # If char is \"(\" we add it to stack\\n            if char == \"(\":\\n                stack.append(\"(\")\\n            else:\\n                # If char is \")\", we pop out the top element from stack till\\n                # we find \"(\". The popped elements will be 2 * score of child\\n                # balanced parentheses of current closed parentheses we have found\\n                # So we will add them to score var\\n                score = 0\\n                while stack[-1] != \"(\":\\n                    score += stack.pop()\\n                # If score is 0, that means the top of stack is \"(\" and we have\\n                # () in the string. So we make score 1\\n                if score == 0: score = 1\\n                # We remove \"(\" from stack\\n                stack.pop()\\n                # We append twice the actual score that a balanced parentheses should\\n                # have into the stack\\n                stack.append( 2 * score)\\n        # stack will have only 1 element if s is of format \"(A)\"\\n        # Else it will have > 1 element.\\n        # Each element will be int of scores multiplied by 2.\\n        # We add them and divide by 2 to remove that extra multiple 2 which we have done\\n        # in our logic\\n        return sum(stack) // 2\\n\\n        \"\"\"\\n            Example: \"(()())()\"\\n            char        stack\\n             (            [\"(\"]\\n             (            [\"(\", \"(\"]\\n             )            [\"(\", 2]\\n             (            [\"(\", 2, \"(\"]\\n             )            [\"(\", 2, 2]\\n             )            [8]\\n             (            [8, \"(\"]\\n             )            [8, 2]\\n\\n            Finally sum(stack) // 2\\n                    = (8 + 2) // 2\\n                    = 5\\n            which is the score of that string\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857281,
                "title": "java-0ms-no-stack-use-with-simple-math-based-on-depth-intuitive-with-explanation-o-1-space",
                "content": "## Score of Parentheses\\n[Based on the Amazing c++ solution given by @artod](https://leetcode.com/problems/score-of-parentheses/discuss/1856699/C%2B%2B-BEATS-100-OMG!!!)\\n\\nCredit to [Soba_1](https://leetcode.com/Soba_1/) for recommending the use of left shift operator on the original post to calculate the power of 2 which can increase the effeciency even more.\\n\\nFirst of all, wow, what an amazing solution by Artod for c++, it\\'s so simple and at the same time genius.\\nI am just adding on a bit more thought into it and trying to explain a bit more in depth about why it works with a solution in Java.\\n**Time: O(N) \\n Space: O(1)**\\n\\n**Explanation**\\n\\n**Problem with the simple detect nesting and add/multiply approach/ What didn\\'t work so smoothly:**\\n\\nWhile we can get caught up on the fact that how we can add the score when there is no nestin and how we can multiply it by 2 when there is nesting, when you start to code it, you realize that it becomes very complicated when you have to detect deep nesting, let\\'s say something like (()(((((()))))))). Trying to use a stack and a loop to track where the nesting starts and stops is possible but kind of complicated and can lead to a lot of issues which I faced as well when I was trying to brute force my way through it, I tried assigning a 1 every time opening and closing brackets were next to one another then I quickly realised there could be something like this (((()()())))()() and now I\\'ll need too many functions and loops with potential infinity loop problems if I tried to brute force my way through this.\\n\\n**How it was avoided with Math**\\n**Approach:** Score for each pair is actually dependent on how deep the pair is inside.\\n1. This Appraoch in comparison to brute forcing to detect nesting notices a very simple thing, instead of looking at a string (()()) as 2(1+1) we can also look at it like `2*1 +2*1` or `2^1 + 2^1`.\\n2. You can also look at something like ((( () () ) () ) as `2^3 + 2^3 + 2^2` instead of `((1+1)*2+1)*2`\\n3. What does this signify? For a deep bracket ((())) it\\'s going to be `2*2*1` which is actually just 2^how deep the pair without nesting was, hence if we calculate the individual score based upon the depth of non nested parentheses and add those, we\\'ll get the correct score.\\n4. If we look at it for a while, we\\'ll realise that we\\'re first following the distributive property of multiplication over addition and after that instead of multiplying by 2 for every level of nesting, we\\'re just using the power of 2.\\n\\nHence for example ((( () () ) () ) answer is more like\\n> score of how deep first () was + score of how deep second () was +score of how deep third () was.\\n which is in other words, 2^how deep the first () was+2^how deep the second () was + 2^ how deep the third () was.\\n \\n \\n **Code:**\\n```\\n class Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score =0;\\n        int depth=0;\\n        int s_length=s.length();\\n        char prev=\\' \\';\\n        for(int i=0;i<s_length;i++){\\n            if(s.charAt(i)==\\'(\\')\\n                depth++;\\n            else{\\n                depth--;// ignore the parentheses we found just before ) as it\\'s not contributing to the depth\\n                if(prev==\\'(\\'){\\n                    score+=Math.pow(2,depth); //Calculate score for the () we just found and add it\\n\\t\\t\\t\\t\\t//score+=1<<depth; this can calculate the power even more effeciently. Thanks soba_1 <3\\n                }\\n            }\\n            prev=s.charAt(i);//Keep track of the last character we found for deciding if we\\'re just decreasing the depth or we\\'ve also got a new ()? Why this?\\n\\t\\t\\t\\t\\t\\t//Two reasons, one to detect the () non nested bracket\\n\\t\\t\\t\\t\\t\\t//other one:\\n\\t\\t\\t\\t\\t\\t//For example; (()) ()  -> (()) | after this point previous depth doesn\\'t matter to us, so in this case we\\'re just decreasing the depth and moving forward. the () in the end has a depth of 1\\n        }\\n        return score;\\n    }\\n}\\n \\n```",
                "solutionTags": [
                    "Math",
                    "Stack"
                ],
                "code": "```\\n class Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score =0;\\n        int depth=0;\\n        int s_length=s.length();\\n        char prev=\\' \\';\\n        for(int i=0;i<s_length;i++){\\n            if(s.charAt(i)==\\'(\\')\\n                depth++;\\n            else{\\n                depth--;// ignore the parentheses we found just before ) as it\\'s not contributing to the depth\\n                if(prev==\\'(\\'){\\n                    score+=Math.pow(2,depth); //Calculate score for the () we just found and add it\\n\\t\\t\\t\\t\\t//score+=1<<depth; this can calculate the power even more effeciently. Thanks soba_1 <3\\n                }\\n            }\\n            prev=s.charAt(i);//Keep track of the last character we found for deciding if we\\'re just decreasing the depth or we\\'ve also got a new ()? Why this?\\n\\t\\t\\t\\t\\t\\t//Two reasons, one to detect the () non nested bracket\\n\\t\\t\\t\\t\\t\\t//other one:\\n\\t\\t\\t\\t\\t\\t//For example; (()) ()  -> (()) | after this point previous depth doesn\\'t matter to us, so in this case we\\'re just decreasing the depth and moving forward. the () in the end has a depth of 1\\n        }\\n        return score;\\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857252,
                "title": "python-solution",
                "content": "\\n    class Solution:\\n\\t\\tdef scoreOfParentheses(self, s: str) -> int:\\n\\t\\t\\tif s == \"()\":           # Base condition for recursion\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tstack = []\\n\\t\\t\\ti = j = 0\\n\\t\\t\\tans = 0\\n\\t\\t\\tlength = len(s)\\n\\t\\t\\twhile i < length:\\n\\t\\t\\t\\tstack.append(i)   \\'\\'\\'It will be surely opening parentheses\\'\\'\\'\\n\\t\\t\\t\\tj = i              \\'\\'\\'Now we will look for it\\'s closing parentheses \\'\\'\\'\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tif s[j] == \\'(\\':\\n\\t\\t\\t\\t\\t\\tstack.append(j)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tif (i+1) != j:      \\'\\'\\'If string b/w parentheses (found above) is not empty \\'\\'\\'\\n\\t\\t\\t\\t\\tans += 2 * self.scoreOfParentheses(s[i+1:j])    #recursion\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += 1\\n\\t\\t\\t\\ti = j+1     \\'\\'\\'Continuing ahead closing parentheses \\'\\'\\'\\n\\t\\t\\treturn ans\\n\\n                    \\n        \\n                \\n                    \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\n    class Solution:\\n\\t\\tdef scoreOfParentheses(self, s: str) -> int:\\n\\t\\t\\tif s == \"()\":           # Base condition for recursion\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tstack = []\\n\\t\\t\\ti = j = 0\\n\\t\\t\\tans = 0\\n\\t\\t\\tlength = len(s)\\n\\t\\t\\twhile i < length:\\n\\t\\t\\t\\tstack.append(i)   \\'\\'\\'It will be surely opening parentheses\\'\\'\\'\\n\\t\\t\\t\\tj = i              \\'\\'\\'Now we will look for it\\'s closing parentheses \\'\\'\\'\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tif s[j] == \\'(\\':\\n\\t\\t\\t\\t\\t\\tstack.append(j)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tif (i+1) != j:      \\'\\'\\'If string b/w parentheses (found above) is not empty \\'\\'\\'\\n\\t\\t\\t\\t\\tans += 2 * self.scoreOfParentheses(s[i+1:j])    #recursion\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += 1\\n\\t\\t\\t\\ti = j+1     \\'\\'\\'Continuing ahead closing parentheses \\'\\'\\'\\n\\t\\t\\treturn ans\\n\\n                    \\n        \\n                \\n                    \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1857214,
                "title": "c-easy-to-understand-algorithm-daily-leetcoding-challenge-march-day-17",
                "content": "Please Upvote if it helps\\u2B06\\uFE0F\\n\\n**Algorithm**\\n\\n* Just create an **empty stack** to store the **pair of parenthesis**\\n\\n* Iterate over the given string then checked **2 cases**:\\n     1.      if we found \\'(\\' parenthesis **store it into stack** and set score of pair 0 again \\n     2.      if we found \\')\\' parenthesis calculate the score for that parensthis by using formula **score = stack.top() + max(2*score, 1)** **and pop**\\n* After whole iteration **return the score**\\n\\n**Time Complexity: O(N)** \\n**Space Complexity: O(N)**\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int score = 0;\\n        stack<int> st;\\n        \\n        for(auto it : s)\\n        {\\n            // when we found ( just push it to the stack\\n            if(it==\\'(\\')\\n            {\\n                // pushing a pair\\n                st.push(score);\\n                \\n                // set score to 0 again for new pair\\n                score = 0;\\n            }\\n            \\n            // if we found ) parenthesis for a pair then change the score\\n            else\\n            {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n        }\\n        \\n        return score;\\n    }\\n};\\n```\\nPlease Upvote if it helps\\u2B06\\uFE0F",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int score = 0;\\n        stack<int> st;\\n        \\n        for(auto it : s)\\n        {\\n            // when we found ( just push it to the stack\\n            if(it==\\'(\\')\\n            {\\n                // pushing a pair\\n                st.push(score);\\n                \\n                // set score to 0 again for new pair\\n                score = 0;\\n            }\\n            \\n            // if we found ) parenthesis for a pair then change the score\\n            else\\n            {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857005,
                "title": "python3-runtime-24-ms-faster-than-98-71-memory-13-8-mb-less-than-97-15",
                "content": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        ans = 0\\n        for i in s:\\n            if i == \")\":\\n                ans += stack.pop()+ max(ans,1)   \\n            else:\\n                stack.append(ans)\\n                ans = 0   \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        ans = 0\\n        for i in s:\\n            if i == \")\":\\n                ans += stack.pop()+ max(ans,1)   \\n            else:\\n                stack.append(ans)\\n                ans = 0   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856804,
                "title": "c-java-easy-to-understand-o-1-without-stack-simple-efficient",
                "content": "**856. Score of Parentheses**\\n\\n##### **APPROACH -**\\n* **`() = 1, (()) = 2, ((())) = 4, (((()))) = 8; ==> score = 2^(level - 1)`**\\n\\n*Create `level` to store current level, i.e. number of continuously nested pair of parentheses\\n**Level increases at every open parenthesis and decreases at every close parenthesis**\\nWhenever a set of continously nested pair of parenthesis ends, add the score for this set*\\n\\n<br/>\\n\\n##### **ANALYSIS -**\\n* **Time Complexity : O(N)**, where N = length of string\\n* **Space Complexity : O(1)**\\n\\n<br/>\\n\\n##### **IMPLEMENTATION -**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s[i] == \\'(\\')    \\n\\t\\t\\t\\tlevel++;\\n            else    \\n\\t\\t\\t\\tlevel--;\\n            if(s[i] == \\')\\' && s[i-1] == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'(\\')    \\n                level++;\\n            else    \\n                level--;\\n            if(s.charAt(i) == \\')\\' && s.charAt(i-1) == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n}\\n```\\n**If you found this helpful, please Upvote \\u2B06\\uFE0F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s[i] == \\'(\\')    \\n\\t\\t\\t\\tlevel++;\\n            else    \\n\\t\\t\\t\\tlevel--;\\n            if(s[i] == \\')\\' && s[i-1] == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'(\\')    \\n                level++;\\n            else    \\n                level--;\\n            if(s.charAt(i) == \\')\\' && s.charAt(i-1) == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856797,
                "title": "856-c-o-n-solution-with-explanation",
                "content": "**Please upvote if you find this solution helpful :)**\\n\\n**Approach:**\\n* Use stack to store the score of the parenthesis pair.\\n* Iterate over the string if we find open parenthesis put current_score into the stack and initialize current_score to 0 (for the new parenthesis pair).\\n* If we find close parenthesis we calculate the current score by using the formula **current_score = stack.top() + max(2*current_score, 1)** and pop out the top most element.\\n* At the end return the current_score.\\n**Time Complexity: O(N), Space Complexity: O(N)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        stack<int> st;\\n        int ind=0;\\n        \\n        for(auto i : s)\\n        {\\n            //if we found open parenthesis\\n            if(i==\\'(\\')\\n            {\\n                st.push(ind);\\n                \\n                //set ind to 0\\n                ind = 0;    \\n            }\\n            //if we found close parenthesis\\n            else\\n            {\\n                ind = st.top() + max(2*ind, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if you find this solution helpful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        stack<int> st;\\n        int ind=0;\\n        \\n        for(auto i : s)\\n        {\\n            //if we found open parenthesis\\n            if(i==\\'(\\')\\n            {\\n                st.push(ind);\\n                \\n                //set ind to 0\\n                ind = 0;    \\n            }\\n            //if we found close parenthesis\\n            else\\n            {\\n                ind = st.top() + max(2*ind, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856359,
                "title": "time-o-n-space-o-n-recursion-solution-in-python",
                "content": "Move the index from left to right.\\nWhen we find open parenthesis `(`, we call recursion from the next character.\\nWhen we find close parenthesis `)`, we return the values inside the recursion, and also return the length of the expression inside parenthesis.\\n\\nAll numbers are stored in the `stack`, and we return the sum of the value in `stack` and the end. When `stack` is empty, that means there was a `()` pair with nothing inside, so return 1 as value.\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        def rec(s):\\n            stack = []\\n            idx = 0\\n            L = len(s)\\n            while idx < L:\\n                if s[idx] == \\'(\\':\\n                    val, length = rec(s[idx + 1:])\\n                    idx += length + 1\\n                    stack.append(val)\\n                elif s[idx] == \\')\\':\\n                    val = 2 * sum(stack) if stack else 1\\n                    return val, idx\\n                idx += 1\\n            \\n            val = sum(stack) if stack else 1\\n            return val, idx\\n            \\n        return rec(s)[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        def rec(s):\\n            stack = []\\n            idx = 0\\n            L = len(s)\\n            while idx < L:\\n                if s[idx] == \\'(\\':\\n                    val, length = rec(s[idx + 1:])\\n                    idx += length + 1\\n                    stack.append(val)\\n                elif s[idx] == \\')\\':\\n                    val = 2 * sum(stack) if stack else 1\\n                    return val, idx\\n                idx += 1\\n            \\n            val = sum(stack) if stack else 1\\n            return val, idx\\n            \\n        return rec(s)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374384,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int sum=0;\\n        int level=1;\\n        Deque<Character> stack =new ArrayDeque<>();\\n        \\n        s = s.replace(\"()\", \"1\");\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\'){\\n                level*=2;\\n            }else if(c==\\')\\'){\\n                level/=2;\\n            }else if(c==\\'1\\'){\\n                sum += level*1;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int sum=0;\\n        int level=1;\\n        Deque<Character> stack =new ArrayDeque<>();\\n        \\n        s = s.replace(\"()\", \"1\");\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\'){\\n                level*=2;\\n            }else if(c==\\')\\'){\\n                level/=2;\\n            }else if(c==\\'1\\'){\\n                sum += level*1;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195998,
                "title": "java-stack-easy-solution",
                "content": "\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\'){\\n            stack.push(-1);\\n          }\\n          else if(stack.peek()==-1){\\n            stack.pop();\\n            stack.push(1);\\n          }\\n          else{\\n            int score=0;\\n            while(stack.peek()!=-1){\\n              score+=stack.pop();\\n            }\\n            stack.pop();\\n            stack.push(2*score);\\n          }\\n        }\\n      int score=0;\\n      while(stack.size()>0){\\n        score+=stack.pop();\\n      }\\n      return score;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\'){\\n            stack.push(-1);\\n          }\\n          else if(stack.peek()==-1){\\n            stack.pop();\\n            stack.push(1);\\n          }\\n          else{\\n            int score=0;\\n            while(stack.peek()!=-1){\\n              score+=stack.pop();\\n            }\\n            stack.pop();\\n            stack.push(2*score);\\n          }\\n        }\\n      int score=0;\\n      while(stack.size()>0){\\n        score+=stack.pop();\\n      }\\n      return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187189,
                "title": "o-1-space-o-n-time-intuitive-concise-and-efficient",
                "content": "Approach:\\n(()(())) = (()) + ((())) = 2 + 4\\n(1+2)  \\n6\\n\\nAt every \\'(\\' we are moving deeper, so we multiply the current depth with 2\\nAt the first \\')\\', add the current depth to final score; \\nAt every \\')\\' (including first) reduce the depth by dividing by 2\\n\\n```\\n// Time O(n), Space O(1)\\n// No stack\\n\\nfunc scoreOfParentheses(S string) int {\\n    \\n    var score int\\n    depth := 1  \\n    flag := false\\n    \\n    for _, ch := range S {\\n        if ch == \\'(\\' {\\n            depth *= 2\\n            flag = true\\n        } else {\\n            depth /= 2\\n            if flag {\\n                score += depth\\n                flag = false\\n            }\\n        }    \\n    }\\n    \\n    return score\\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// Time O(n), Space O(1)\\n// No stack\\n\\nfunc scoreOfParentheses(S string) int {\\n    \\n    var score int\\n    depth := 1  \\n    flag := false\\n    \\n    for _, ch := range S {\\n        if ch == \\'(\\' {\\n            depth *= 2\\n            flag = true\\n        } else {\\n            depth /= 2\\n            if flag {\\n                score += depth\\n                flag = false\\n            }\\n        }    \\n    }\\n    \\n    return score\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085077,
                "title": "java-recursion-beats-100-14-line-code",
                "content": "```\\nclass Solution {\\n    int index = 0;\\n    public int scoreOfParentheses(String S) {\\n        int score = 0;\\n        while(index<S.length()){\\n            if(S.charAt(index)==\\'(\\'){\\n                index++;\\n                score+=scoreOfParentheses(S);\\n            }\\n            else if(S.charAt(index)==\\')\\'){\\n                index++;\\n                score= score==0 ? 1 : 2*score;\\n                return score;\\n            }   \\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int index = 0;\\n    public int scoreOfParentheses(String S) {\\n        int score = 0;\\n        while(index<S.length()){\\n            if(S.charAt(index)==\\'(\\'){\\n                index++;\\n                score+=scoreOfParentheses(S);\\n            }\\n            else if(S.charAt(index)==\\')\\'){\\n                index++;\\n                score= score==0 ? 1 : 2*score;\\n                return score;\\n            }   \\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082430,
                "title": "c-2-approaches-o-n-0ms-beats-100-no-extra-space-best-easy-to-understand",
                "content": "**APPROACH 1 ( Using Stack ) CODE IMPLEMENTATION**\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>st;\\n        int ans=0;\\n        st.push(0);\\n        int i=1;\\n        while(i<S.length()){\\n            if(S[i]==\\'(\\'){\\n                st.push(0);\\n            }            \\n            else{\\n                int top=st.top();                                           \\n                st.pop();\\n                int curr = top ? top : 1;\\n                if(st.empty()){\\n                    ans+=curr;  \\n                }\\n                else{\\n                    int new_top=st.top();\\n                    st.pop();\\n                    curr=curr<<1; // curr*2 = curr<<1\\n                    st.push(new_top+curr); \\n                }\\n            }\\n            ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(n)**\\n\\n---\\n\\n**APPROACH 2 ( No Extra Space ) CODE IMPLEMENTATION**\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int ans=0;\\n        int dm=2; // depth-multiplier\\n        for(int i=1;i<S.length();++i){\\n            if(S[i]==\\'(\\'){\\n                dm=dm<<1; // dm=dm*2\\n            } \\n            else{\\n                dm=dm>>1; // dm=dm/2\\n                if(S[i-1]==\\'(\\') ans += dm; // \"()\" is encountered        \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>st;\\n        int ans=0;\\n        st.push(0);\\n        int i=1;\\n        while(i<S.length()){\\n            if(S[i]==\\'(\\'){\\n                st.push(0);\\n            }            \\n            else{\\n                int top=st.top();                                           \\n                st.pop();\\n                int curr = top ? top : 1;\\n                if(st.empty()){\\n                    ans+=curr;  \\n                }\\n                else{\\n                    int new_top=st.top();\\n                    st.pop();\\n                    curr=curr<<1; // curr*2 = curr<<1\\n                    st.push(new_top+curr); \\n                }\\n            }\\n            ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int ans=0;\\n        int dm=2; // depth-multiplier\\n        for(int i=1;i<S.length();++i){\\n            if(S[i]==\\'(\\'){\\n                dm=dm<<1; // dm=dm*2\\n            } \\n            else{\\n                dm=dm>>1; // dm=dm/2\\n                if(S[i-1]==\\'(\\') ans += dm; // \"()\" is encountered        \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081068,
                "title": "score-of-parentheses-c-easy-using-stack",
                "content": "\\t\\tint n=s.size();\\n        int count=0;\\n        stack<int> st;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                sum=0;\\n                st.push(0);\\n            }\\n            else\\n            {\\n                if(st.top()==0)\\n                {\\n                    sum+=1;\\n                    st.pop();\\n                    st.push(sum);\\n                    \\n                }\\n                else if(st.top()>0)\\n                {\\n                    int val=0;\\n                    while(st.top()!=0)\\n                    {\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        sum=0;\\n        while(!st.empty())\\n        {\\n            sum+=st.top();\\n            st.pop();\\n        }\\n        return sum;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\tint n=s.size();\\n        int count=0;\\n        stack<int> st;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                sum=0;\\n                st.push(0);\\n            }\\n            else\\n            {\\n                if(st.top()==0)\\n                {\\n                    sum+=1;\\n                    st.pop();\\n                    st.push(sum);\\n                    \\n                }\\n                else if(st.top()>0)\\n                {\\n                    int val=0;\\n                    while(st.top()!=0)\\n                    {\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        sum=0;\\n        while(!st.empty())\\n        {\\n            sum+=st.top();\\n            st.pop();\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 1080638,
                "title": "c-0-ms-faster-than-100-00-o-1-space-super-simple-solution",
                "content": "```\\nint scoreOfParentheses(char * S){\\n    int res = 0, balance = 0;\\n    for ( int index = 0; S[index]; ++index )\\n    {\\n        balance += S[index] == \\'(\\' ? 1 : -1;\\n        if ( index && S[index - 1] == \\'(\\' && S[index] == \\')\\' )\\n            res += pow( 2, balance );\\n    }\\n    return res;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint scoreOfParentheses(char * S){\\n    int res = 0, balance = 0;\\n    for ( int index = 0; S[index]; ++index )\\n    {\\n        balance += S[index] == \\'(\\' ? 1 : -1;\\n        if ( index && S[index - 1] == \\'(\\' && S[index] == \\')\\' )\\n            res += pow( 2, balance );\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1080614,
                "title": "python-super-simple-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, balance = 0, 0\\n        for index, par in enumerate(S):\\n            balance += 1 if par == \"(\" else -1\\n            if index and S[index - 1] + par == \"()\":\\n                res += 2 ** balance\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, balance = 0, 0\\n        for index, par in enumerate(S):\\n            balance += 1 if par == \"(\" else -1\\n            if index and S[index - 1] + par == \"()\":\\n                res += 2 ** balance\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1080527,
                "title": "python-o-n-time-o-1-or-o-n-space-with-stack-and-without-stack-1-pass",
                "content": "#### Solution I\\nscan the string, \\n1. char is `(`,  push it into the stack and record it\\'s inner `val` to `0`.  `val` is used to record all its inner value;\\n2. char is `)`,  then last elem in the stack is the match one. \\n\\t* \\tif its inner value is 0, which means there is no inner parentheses in it, set `val=1`\\n\\t* \\telse, there are some parentheses in it, we need to double it;\\n\\t* \\tthen we need to check whether is has outer parentheses\\n\\t\\t* \\tif not, just add it to the result;\\n\\t\\t* \\telse, record to its outer parentheses\\' val, which is the last element in the stack;\\n\\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res = 0\\n        st = []\\n        for c in S:\\n            if c == \\'(\\': st.append(0)\\n            elif c == \\')\\':\\n                inner_val = st.pop()\\n                val = 2 * inner_val if inner_val > 0 else 1\\n                if not st: res += val\\n                else: st[-1] += val\\n        return res\\n```\\n\\n\\n#### Solution II\\n1. using `depth` to record depth of `(` in current group;\\n2. If we come across a leaf node `()`,  we know the `result` of current group; \\n\\n\\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth = 0, 0\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                if S[idx + 1] == \\')\\': res += 1 << (depth-1)\\n            else:\\n                depth -= 1\\n        return res\\n```\\n\\n\\nIf there are same useless chars in the string, we\\'ll have to identify the leaf node by some trick.\\n\\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth, isleaf = 0, 0, False\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                isleaf = True\\n            else:\\n                depth -= 1\\n                if isleaf: res += 1 << depth\\n                isleaf = False\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res = 0\\n        st = []\\n        for c in S:\\n            if c == \\'(\\': st.append(0)\\n            elif c == \\')\\':\\n                inner_val = st.pop()\\n                val = 2 * inner_val if inner_val > 0 else 1\\n                if not st: res += val\\n                else: st[-1] += val\\n        return res\\n```\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth = 0, 0\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                if S[idx + 1] == \\')\\': res += 1 << (depth-1)\\n            else:\\n                depth -= 1\\n        return res\\n```\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth, isleaf = 0, 0, False\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                isleaf = True\\n            else:\\n                depth -= 1\\n                if isleaf: res += 1 << depth\\n                isleaf = False\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 907389,
                "title": "very-simple-o-1-space-linear-solution-without-stack",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int depth = 0;\\n        int ans = 0;\\n        \\n        for( int i=0; i<S.length(); i++){\\n            \\n            if( S.charAt(i) == \\'(\\' && S.charAt(i+1) == \\')\\' ) {\\n                ans += Math.pow(2, depth);\\n\\t\\t\\t\\t//skipping the next closing paranthesis\\n                i++; \\n            }\\n            \\n            else if( S.charAt(i) == \\'(\\')\\n                depth++;\\n            \\n            else if( S.charAt(i) == \\')\\')\\n                depth--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int depth = 0;\\n        int ans = 0;\\n        \\n        for( int i=0; i<S.length(); i++){\\n            \\n            if( S.charAt(i) == \\'(\\' && S.charAt(i+1) == \\')\\' ) {\\n                ans += Math.pow(2, depth);\\n\\t\\t\\t\\t//skipping the next closing paranthesis\\n                i++; \\n            }\\n            \\n            else if( S.charAt(i) == \\'(\\')\\n                depth++;\\n            \\n            else if( S.charAt(i) == \\')\\')\\n                depth--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746700,
                "title": "java-0ms-100-solution",
                "content": "```\\n   public int scoreOfParentheses(String S) {\\n        \\n        int i = 0, n = S.length(), open = -1, ans = 0;\\n        while (i < n) {\\n            while (i < n && S.charAt(i++) == \\'(\\') open++;\\n            \\n            ans += Math.pow(2, open);\\n            \\n            while(i < n && S.charAt(i++) == \\')\\') open--;\\n        }\\n            \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n   public int scoreOfParentheses(String S) {\\n        \\n        int i = 0, n = S.length(), open = -1, ans = 0;\\n        while (i < n) {\\n            while (i < n && S.charAt(i++) == \\'(\\') open++;\\n            \\n            ans += Math.pow(2, open);\\n            \\n            while(i < n && S.charAt(i++) == \\')\\') open--;\\n        }\\n            \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 545261,
                "title": "beats-100-c-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Score of Parentheses.\\nMemory Usage: 5.1 MB, less than 100.00% of C online submissions for Score of Parentheses.\\n```\\n\\nint scoreOfParentheses(char * s){\\n    int score=0,flag=0;\\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\'){\\n            flag++;\\n        }\\n        else{\\n            flag--;\\n            if(s[i-1]==\\'(\\')\\n                score += 1 << flag;\\n        }\\n    }\\n    return score;\\n}\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C online submissions for Score of Parentheses.\\nMemory Usage: 5.1 MB, less than 100.00% of C online submissions for Score of Parentheses.\\n```\\n\\nint scoreOfParentheses(char * s){\\n    int score=0,flag=0;\\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\'){\\n            flag++;\\n        }\\n        else{\\n            flag--;\\n            if(s[i-1]==\\'(\\')\\n                score += 1 << flag;\\n        }\\n    }\\n    return score;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 497396,
                "title": "java-solution-with-code-templates-for-similar-problems",
                "content": "The solution might not as concise as others, but can be used as the template to solve most similar string interpretor problem like 729 Number of Atoms, 394 Decode string...etc\\nPlease check the comments in the code\\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        if(S == null || S.length() == 0) return 0;\\n\\t\\t\\n\\t//Need initialize the Stack with String for all Number/Symbol/Letter\\n        Stack<String> stack = new Stack<>();\\n        \\n\\t/**Loop through the entire string and each character\\n\\tUsing if/else statement to think about all the cases for each character:\\n\\t\\'(\\' , \\')\\', \\'[\\', \\']\\', \\'number\\', \\'letter\\', \\'upperCase\\', \\'lowerCase\\' depends on the input of the problem**/\\n        for(int i = 0; i<S.length(); i++) {\\n            char c = S.charAt(i);\\n            \\n            if(c == \\'(\\') {\\n\\t\\t\\t\\n\\t\\t/**Usually need push the symbol like \\'(\\' to be the stop sign when you loop back**/\\n                stack.push(\"(\");\\n            }\\n\\t\\t\\t\\n\\t\\t/**And \\')\\' would be the symbol to start looking back, \\n\\t\\twhich needs to popup previous element until the stop sign, \\n\\t\\tand calculate the values according to the problem, \\n\\t\\tthen push back the new value to the stack**/\\n            else if(c == \\')\\'){\\n                //()\\n                if(stack.peek() == \"(\") {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                //(1234...)\\n                else{\\n                    int num = 0;\\n                    while(!stack.isEmpty() && stack.peek() != \"(\") {\\n                        num += Integer.parseInt(stack.pop());\\n                    }\\n                    stack.pop();\\n                    stack.push(String.valueOf(num * 2));\\n                }\\n            }\\n        }\\n        \\n\\t//finally popup all the elements from the stack \\n        int res = 0;\\n        while(!stack.isEmpty()) {\\n            res += Integer.parseInt(stack.pop());\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        if(S == null || S.length() == 0) return 0;\\n\\t\\t\\n\\t//Need initialize the Stack with String for all Number/Symbol/Letter\\n        Stack<String> stack = new Stack<>();\\n        \\n\\t/**Loop through the entire string and each character\\n\\tUsing if/else statement to think about all the cases for each character:\\n\\t\\'(\\' , \\')\\', \\'[\\', \\']\\', \\'number\\', \\'letter\\', \\'upperCase\\', \\'lowerCase\\' depends on the input of the problem**/\\n        for(int i = 0; i<S.length(); i++) {\\n            char c = S.charAt(i);\\n            \\n            if(c == \\'(\\') {\\n\\t\\t\\t\\n\\t\\t/**Usually need push the symbol like \\'(\\' to be the stop sign when you loop back**/\\n                stack.push(\"(\");\\n            }\\n\\t\\t\\t\\n\\t\\t/**And \\')\\' would be the symbol to start looking back, \\n\\t\\twhich needs to popup previous element until the stop sign, \\n\\t\\tand calculate the values according to the problem, \\n\\t\\tthen push back the new value to the stack**/\\n            else if(c == \\')\\'){\\n                //()\\n                if(stack.peek() == \"(\") {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                //(1234...)\\n                else{\\n                    int num = 0;\\n                    while(!stack.isEmpty() && stack.peek() != \"(\") {\\n                        num += Integer.parseInt(stack.pop());\\n                    }\\n                    stack.pop();\\n                    stack.push(String.valueOf(num * 2));\\n                }\\n            }\\n        }\\n        \\n\\t//finally popup all the elements from the stack \\n        int res = 0;\\n        while(!stack.isEmpty()) {\\n            res += Integer.parseInt(stack.pop());\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188525,
                "title": "c-solution-0ms-no-stack-no-recursion-with-explanation-o-n-runtime",
                "content": "Move forward through the string and meanwhile keep track of the number visited open and close parenthesis. \\nOnce we reach each close parenthesis followed by an open parenthesis, do calculation. The calculation is as simple as subtracting the visited closed parenthesis from visited open parenthesis used till now. \\nLet\\u2019s call it diff (cnt = open - close).\\nThen add the pow(2,cnt) and add it to result.\\nRunning Complexity O(n)\\nSpace Complexity O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {      \\n      int res=0;  int cnt=1;        \\n      if (S.size()==0)\\n           return res;\\n      for (int i=1; i<S.size();++i) {\\n          if (S[i]==\\'(\\')\\n             cnt++;\\n          else {\\n              cnt--;\\n              if (S[i-1]==\\'(\\') {\\n                  res+= pow(2,(cnt));  // or  1<<cnt;           \\n              }              \\n          }              \\n      }\\n      return res;\\n    }           \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {      \\n      int res=0;  int cnt=1;        \\n      if (S.size()==0)\\n           return res;\\n      for (int i=1; i<S.size();++i) {\\n          if (S[i]==\\'(\\')\\n             cnt++;\\n          else {\\n              cnt--;\\n              if (S[i-1]==\\'(\\') {\\n                  res+= pow(2,(cnt));  // or  1<<cnt;           \\n              }              \\n          }              \\n      }\\n      return res;\\n    }           \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624991,
                "title": "easy-to-understand-c-solution-stack-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<string>st;\\n        for(auto ch: s){\\n            if(ch == \\'(\\') st.push(\"(\");\\n            else{\\n                int temp = 0;\\n                while(st.top() != \"(\"){\\n                    temp += (stoi(st.top()));\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(temp == 0) st.push(\"1\");\\n                else st.push(to_string(2 * temp));\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += stoi(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<string>st;\\n        for(auto ch: s){\\n            if(ch == \\'(\\') st.push(\"(\");\\n            else{\\n                int temp = 0;\\n                while(st.top() != \"(\"){\\n                    temp += (stoi(st.top()));\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(temp == 0) st.push(\"1\");\\n                else st.push(to_string(2 * temp));\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += stoi(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495372,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans=0;\\n        stack<int> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(st.top()==-1){\\n               st.pop();\\n               st.push(1);\\n            }\\n            else{\\n                int temp=0;\\n                while(st.top()!=-1){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*temp);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = [0]\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                v = stack.pop()\\n                stack[-1] += max(2 * v, 1)\\n        return stack.pop()        \\n```\\n\\n```Java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans=0;\\n        stack<int> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(st.top()==-1){\\n               st.pop();\\n               st.push(1);\\n            }\\n            else{\\n                int temp=0;\\n                while(st.top()!=-1){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*temp);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = [0]\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                v = stack.pop()\\n                stack[-1] += max(2 * v, 1)\\n        return stack.pop()        \\n```\n```Java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758390,
                "title": "c-easy-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637318,
                "title": "100-fastest-solution-simple-stack-implementation",
                "content": "The idea is that whenever we encouter any opening \\')\\' we put in stack and when we get a closing \\'(\\' and if it is \\'( )\\' then we add 1 in stack so that we can keep track of no of balanced bracket for outer one.\\nAs the brackets are balanced so there exist a \\'(\\' for every \\')\\' .\\nwe move in stack till we dont get a \\')\\' for any oter bracket and add all the previous inside parenthesis value and multiply it by 2 and push int stack.\\n\\n\\n\\n\\n```\\nclass Solution\\n{\\n    public:\\n        int scoreOfParentheses(string s)\\n        {\\n            stack<int> st;\\n            int ans = 0;\\n            for (int i = s.size() - 1; i >= 0; i--)\\n            {\\n                if (s[i] == \\')\\')\\n                    st.push(s[i]);\\n\\n                else\\n                {\\n                    if (s[i + 1] == \\')\\')\\n                    {\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        int cnt = 0;\\n                        while (st.top() != \\')\\')\\n                        {\\n                            cnt += st.top();\\n                            st.pop();\\n                        }\\n                        st.pop();\\n                        st.push(cnt *2);\\n                    }\\n                }\\n            }\\n            while (st.size() != 0)\\n            {\\n                ans += st.top();\\n                st.pop();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int scoreOfParentheses(string s)\\n        {\\n            stack<int> st;\\n            int ans = 0;\\n            for (int i = s.size() - 1; i >= 0; i--)\\n            {\\n                if (s[i] == \\')\\')\\n                    st.push(s[i]);\\n\\n                else\\n                {\\n                    if (s[i + 1] == \\')\\')\\n                    {\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        int cnt = 0;\\n                        while (st.top() != \\')\\')\\n                        {\\n                            cnt += st.top();\\n                            st.pop();\\n                        }\\n                        st.pop();\\n                        st.push(cnt *2);\\n                    }\\n                }\\n            }\\n            while (st.size() != 0)\\n            {\\n                ans += st.top();\\n                st.pop();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589641,
                "title": "c-solution-score-of-parentheses",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        char lastChar = \\'(\\';\\n        int n = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\')\\n                n++;\\n            else{\\n                n--;\\n                if(lastChar == \\'(\\')\\n                    ans = ans + pow(2 , n);\\n            }\\n            lastChar = s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        char lastChar = \\'(\\';\\n        int n = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\')\\n                n++;\\n            else{\\n                n--;\\n                if(lastChar == \\'(\\')\\n                    ans = ans + pow(2 , n);\\n            }\\n            lastChar = s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323927,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-score-of-parentheses",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE :**\\n```\\nint scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0); // to keep the total score\\n        for(char i:s) {\\n            if(i==\\'(\\') {\\n                st.push(0);\\n            }\\n            else {\\n                int A = st.top(), val=0;\\n                st.pop();\\n                if(A>0) \\n                    val = 2*A;\\n                else\\n                    val = 1;\\n                st.top() += val;\\n            }\\n        }\\n        return st.top();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0); // to keep the total score\\n        for(char i:s) {\\n            if(i==\\'(\\') {\\n                st.push(0);\\n            }\\n            else {\\n                int A = st.top(), val=0;\\n                st.pop();\\n                if(A>0) \\n                    val = 2*A;\\n                else\\n                    val = 1;\\n                st.top() += val;\\n            }\\n        }\\n        return st.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152478,
                "title": "recursive-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(string &s,int i,int j){\\n        if(j == i+1)\\n            return 1;\\n        int ans = 0;\\n        int x = 0;\\n        int st = i;\\n        int n = s.length();\\n        while(i < j){\\n            if(s[i] == \\'(\\')\\n                x++;\\n            if(s[i] == \\')\\')\\n                x--;\\n            if(x == 0){\\n                return helper(s,st,i)+helper(s,i+1,j);\\n            }\\n            i++;\\n        }\\n        return 2*helper(s,st+1,j-1);\\n    }\\n    int scoreOfParentheses(string s) {\\n        return helper(s,0,s.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string &s,int i,int j){\\n        if(j == i+1)\\n            return 1;\\n        int ans = 0;\\n        int x = 0;\\n        int st = i;\\n        int n = s.length();\\n        while(i < j){\\n            if(s[i] == \\'(\\')\\n                x++;\\n            if(s[i] == \\')\\')\\n                x--;\\n            if(x == 0){\\n                return helper(s,st,i)+helper(s,i+1,j);\\n            }\\n            i++;\\n        }\\n        return 2*helper(s,st+1,j-1);\\n    }\\n    int scoreOfParentheses(string s) {\\n        return helper(s,0,s.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019616,
                "title": "100-fastest-solution-constant-space-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n=s.size(),ans=0;\\n        int d=0,i=0;\\n        while(i<n) {\\n            if(s[i]==\\'(\\') d++;\\n            else {\\n                d--;\\n                if(i>0 && s[i-1]==\\'(\\') ans+=1<<d;\\n                }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n=s.size(),ans=0;\\n        int d=0,i=0;\\n        while(i<n) {\\n            if(s[i]==\\'(\\') d++;\\n            else {\\n                d--;\\n                if(i>0 && s[i-1]==\\'(\\') ans+=1<<d;\\n                }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858474,
                "title": "cpp-solution-runtime-0ms",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        \\n     stack<pair<int,char>>st1; //this stack is used for the follow the \\'(\\'\\n       stack<pair<int,int>>st2;// this stack is used for the  count the score of a where  the string is \"(a)\".\\n        for(int i=0; i<s.length(); ){\\n            if(st1.empty()){\\n                st1.push({i,\\'(\\'});\\n                i++;\\n            }else{\\n                if(s[i] == \\')\\'){\\n                    \\n                    while(!st1.empty() && i < s.length() && s[i] == \\')\\'){\\n                       if(st2.empty()){\\n                           st2.push({1,st1.top().first});\\n                           st1.pop(); \\n                           i++;\\n                       }else{\\n                           int res = 0;\\n                           \\n                           while(!st2.empty() && st2.top().second > st1.top().first){ \\n\\t\\t\\t\\t\\t\\t   // here is the main idea if you understand above condition \\n\\t\\t\\t\\t\\t\\t   // then you will be able  to understand whole code.\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t   // here i basically do the thing that while(curr = st1.top().first) \\n\\t\\t\\t\\t\\t\\t   //means current index of \\'(\\'   is smaller than the st2.top().first\\n\\t\\t\\t\\t\\t\\t   //we remove the element from the st2 and take the total sum\\n\\t\\t\\t\\t\\t\\t   //of all popped elements  \\n\\t\\t\\n\\t\\t\\n\\t\\t\\t\\t\\t\\n                               res += st2.top().first;\\n                               st2.pop();\\n                               \\n                           }\\n                           if(res != 0)\\n                           st2.push({2*res,st1.top().first});\\n                           else\\n                               st2.push({1,st1.top().first});\\n                           st1.pop();\\n                           i++;\\n                       }\\n                    }\\n                }else{\\n                    st1.push({i,\\'(\\'});\\n                    i++;\\n                }\\n            }\\n        }\\n        int res = 0;\\n        while(!st2.empty()){\\n            res += st2.top().first;\\n            st2.pop();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        \\n     stack<pair<int,char>>st1; //this stack is used for the follow the \\'(\\'\\n       stack<pair<int,int>>st2;// this stack is used for the  count the score of a where  the string is \"(a)\".\\n        for(int i=0; i<s.length(); ){\\n            if(st1.empty()){\\n                st1.push({i,\\'(\\'});\\n                i++;\\n            }else{\\n                if(s[i] == \\')\\'){\\n                    \\n                    while(!st1.empty() && i < s.length() && s[i] == \\')\\'){\\n                       if(st2.empty()){\\n                           st2.push({1,st1.top().first});\\n                           st1.pop(); \\n                           i++;\\n                       }else{\\n                           int res = 0;\\n                           \\n                           while(!st2.empty() && st2.top().second > st1.top().first){ \\n\\t\\t\\t\\t\\t\\t   // here is the main idea if you understand above condition \\n\\t\\t\\t\\t\\t\\t   // then you will be able  to understand whole code.\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t   // here i basically do the thing that while(curr = st1.top().first) \\n\\t\\t\\t\\t\\t\\t   //means current index of \\'(\\'   is smaller than the st2.top().first\\n\\t\\t\\t\\t\\t\\t   //we remove the element from the st2 and take the total sum\\n\\t\\t\\t\\t\\t\\t   //of all popped elements  \\n\\t\\t\\n\\t\\t\\n\\t\\t\\t\\t\\t\\n                               res += st2.top().first;\\n                               st2.pop();\\n                               \\n                           }\\n                           if(res != 0)\\n                           st2.push({2*res,st1.top().first});\\n                           else\\n                               st2.push({1,st1.top().first});\\n                           st1.pop();\\n                           i++;\\n                       }\\n                    }\\n                }else{\\n                    st1.push({i,\\'(\\'});\\n                    i++;\\n                }\\n            }\\n        }\\n        int res = 0;\\n        while(!st2.empty()){\\n            res += st2.top().first;\\n            st2.pop();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858163,
                "title": "easy-cpp-solution",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int result=0,d=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                d++;\\n            }\\n            else{\\n                d--;\\n                if(s[i-1]==\\'(\\')\\n                    result+=pow(2,d);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int result=0,d=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                d++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1857834,
                "title": "easy-c-100-faster-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n       \\n        int count=0;//for opening parentheses count\\n        int rcount=0;//for closing parentheses count\\n        int ans=0;\\n        int i=0;//for iterating over string s\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){ //counting opening bracket\\n                count++;\\n                i++;\\n            }\\n            else { // if closing bracket then count it in rcount, think of case. (()((())))\\n                while(s[i]==\\')\\'){\\n                    rcount++;\\n                    i++;\\n                }\\n                ans+=pow(2,count-1); //(A)--> 2*A  , see in question explanation\\n                count-=rcount; //if count==rcount, both equal and counted in answer and if count!=rcount,we will do the operations for rcount only\\n                rcount=0;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n       \\n        int count=0;//for opening parentheses count\\n        int rcount=0;//for closing parentheses count\\n        int ans=0;\\n        int i=0;//for iterating over string s\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){ //counting opening bracket\\n                count++;\\n                i++;\\n            }\\n            else { // if closing bracket then count it in rcount, think of case. (()((())))\\n                while(s[i]==\\')\\'){\\n                    rcount++;\\n                    i++;\\n                }\\n                ans+=pow(2,count-1); //(A)--> 2*A  , see in question explanation\\n                count-=rcount; //if count==rcount, both equal and counted in answer and if count!=rcount,we will do the operations for rcount only\\n                rcount=0;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857674,
                "title": "python-stack-simplest-solution",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for ch in s:\\n            if ch == \\')\\':\\n\\t\\t\\t\\t# If ch is \\')\\' then calculate the score till previous \\'(\\' as per the formula and append the score into stack.\\n                score = 0\\n                while stack and stack[-1] != \\'(\\':\\n                    score += stack.pop()\\n                if stack and stack[-1] == \\'(\\':\\n                    stack.pop()\\n                stack.append(2*score if score > 0 else 1)\\n            else:\\n\\t\\t\\t\\t# If ch is \\'(\\' then simple put it into stack\\n                stack.append(ch)\\n        return sum(stack)\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for ch in s:\\n            if ch == \\')\\':\\n\\t\\t\\t\\t# If ch is \\')\\' then calculate the score till previous \\'(\\' as per the formula and append the score into stack.\\n                score = 0\\n                while stack and stack[-1] != \\'(\\':\\n                    score += stack.pop()\\n                if stack and stack[-1] == \\'(\\':\\n                    stack.pop()\\n                stack.append(2*score if score > 0 else 1)\\n            else:\\n\\t\\t\\t\\t# If ch is \\'(\\' then simple put it into stack\\n                stack.append(ch)\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857442,
                "title": "score-of-parentheses-t-c-o-n-s-c-o-1",
                "content": "() maximum depth is 0. hence 2^0 will result as 1.\\n()() maximum depth is 0, and is occuring twice, hence (2^0) + (2^0) = 2;\\n(()()) maximum depth is 1, and is occuring twice, hence (2^1) + (2^1) = 4;\\n(()) maximum depth is 1, and is occuring once, hence (2^1) = 2;\\nin same manner the below code is implemented.\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int d = 1; // Varibale d measures the depth of the current parenteses.\\n        int ans = 0; // ans stores the total score of the parentheses, till the current parentheses.\\n        int n = s.size();\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (s[i] == \\'(\\')  // Increment the depth whenever you encounter a opening bracket.\\n                d++;\\n            else  // Decrement the depth whenever you encounter a closing bracket.\\n                d--;\\n            if (s[i] == \\')\\' && s[i - 1] == \\'(\\') whenever this condition satisfy. get the score by 2 power the depth.\\n                ans += pow(2, d);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote the solution.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int d = 1; // Varibale d measures the depth of the current parenteses.\\n        int ans = 0; // ans stores the total score of the parentheses, till the current parentheses.\\n        int n = s.size();\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (s[i] == \\'(\\')  // Increment the depth whenever you encounter a opening bracket.\\n                d++;\\n            else  // Decrement the depth whenever you encounter a closing bracket.\\n                d--;\\n            if (s[i] == \\')\\' && s[i - 1] == \\'(\\') whenever this condition satisfy. get the score by 2 power the depth.\\n                ans += pow(2, d);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856716,
                "title": "c-0ms-better-then-100-cpp-solution",
                "content": "# Please Upvote if tou find this helpfull\\n![image](https://assets.leetcode.com/users/images/a73b9a52-854b-4c00-832e-d05db3e803c6_1647489700.5493279.png)\\n```\\nclass Solution {\\npublic:\\n\\tint scoreOfParentheses(string s) {\\n\\t\\t  stack<int> st;\\n\\t\\tint ans=0;\\n\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\tif(s[i]==\\'(\\') st.push(0);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(st.top()==0){\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tst.push(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint temp=0;\\n\\t\\t\\t\\t\\twhile(!st.empty() && st.top()!=0){\\n\\t\\t\\t\\t\\t\\ttemp+=st.top();\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tst.push(2*temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(!st.empty())\\n\\t\\t{\\n\\t\\t\\tans+=st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\tint scoreOfParentheses(string s) {\\n\\t\\t  stack<int> st;\\n\\t\\tint ans=0;\\n\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\tif(s[i]==\\'(\\') st.push(0);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(st.top()==0){\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tst.push(1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1856432,
                "title": "java-using-stack",
                "content": "Approach 1: Using Stack\\n```\\n\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n       Stack<Integer> stack = new Stack<>();\\n        int score = 0;\\n        for(char c: s.toCharArray()){\\n            if(c == \\'(\\'){\\n                // when you encounter a opening paranthesis you add current score to stack to be popped in future to calculate score with its pair closing paranthesis\\n\\t\\t\\t\\tstack.push(score);\\n\\t\\t\\t\\t// reset score here for next open paranthesis\\n                score = 0;\\n            }else{\\n\\t\\t\\t// when ever you meet a closing parantheses score will be updated\\n                score = stack.pop() + Math.max(2*score,1);\\n            }\\n        }\\n    return score;\\n    }\\n}\\n```\\n\\n```\\nExample 1 : ()\\n\\nstep 1 : 0 // current score will be pushed to stack at initial if\\nstep 2: In else block score will be updated as score = 0 + max(2*0 + 1) = 1\\nnote : in else block you need to get max of 2*(count of open parantheses encounter sofar until you find a closing)  + 1(minimum score for a pair of () )\\n```\\n```\\nExample 2 : ()()\\nstep 1: 0 // for initial opening stack will be pushed with current score\\nstep 2: score will be updated as score = 0 + max(2*0,1) = 1 // for the first pair encountered sofar ()\\nstep 3: 1 // current score will be pushed to stack for second opening and score will be reset to 0\\nstep 4: score will be updated as score  = 1 + max(2*0,1) = 1 + 1 = 2\\n\\nNote : In case of adjacent valid pairs AB = A + B stack.pop() will always give calculated score sofar  and max(2*score,1) will give score for current closing paranthesis. It is important to reset score after pushing to stack because for every new opening score should start with 0\\n\\n```\\n\\n```\\nExample 3 : (())\\nstep 1: 0 // current stack\\nstep 2: 0 0 // updated stack for second opening paranthesis\\nstep 3: calculate score = 0 + max(2*0,1) = 0 + 1 = 1 (which is for inside nested pair ())\\nstep 4 : calculate score = 0 + max(2*1,1) = 0 + 2 = 2 (which is for outer pair 2*(score of innner pair 1))\\n\\nNote : In case of nested pairs max(2*current_score,1) will provide multiplication factor for nested pairs\\n\\nsimilary \\nif you have nested at 3 (2*(2*(1))) levels score = 2*(2*(1))  = 4\\nif you have nested at 4 (2*(2*(2*(1)))) levels score = 2*(2*(2*(1)))  = 8\\n\\n```\\n\\nApproach 2: Without additional data structure O(1) memory\\n\\n```\\npublic int scoreOfParentheses(String S) {\\n    int score = 0;\\n    int depth = 0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            depth++;\\n        } else {\\n            depth--;\\n        }\\n\\n        if (s.charAt(i) == \\')\\' && s.charAt(i - 1) == \\'(\\') {\\n            // Whenever you meet a () pair, you multiply 1 by all the 2 outside of it, and accumulate the result\\n            score += Math.pow(2, depth);\\n        }\\n    }\\n\\n    return score;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n       Stack<Integer> stack = new Stack<>();\\n        int score = 0;\\n        for(char c: s.toCharArray()){\\n            if(c == \\'(\\'){\\n                // when you encounter a opening paranthesis you add current score to stack to be popped in future to calculate score with its pair closing paranthesis\\n\\t\\t\\t\\tstack.push(score);\\n\\t\\t\\t\\t// reset score here for next open paranthesis\\n                score = 0;\\n            }else{\\n\\t\\t\\t// when ever you meet a closing parantheses score will be updated\\n                score = stack.pop() + Math.max(2*score,1);\\n            }\\n        }\\n    return score;\\n    }\\n}\\n```\n```\\nExample 1 : ()\\n\\nstep 1 : 0 // current score will be pushed to stack at initial if\\nstep 2: In else block score will be updated as score = 0 + max(2*0 + 1) = 1\\nnote : in else block you need to get max of 2*(count of open parantheses encounter sofar until you find a closing)  + 1(minimum score for a pair of () )\\n```\n```\\nExample 2 : ()()\\nstep 1: 0 // for initial opening stack will be pushed with current score\\nstep 2: score will be updated as score = 0 + max(2*0,1) = 1 // for the first pair encountered sofar ()\\nstep 3: 1 // current score will be pushed to stack for second opening and score will be reset to 0\\nstep 4: score will be updated as score  = 1 + max(2*0,1) = 1 + 1 = 2\\n\\nNote : In case of adjacent valid pairs AB = A + B stack.pop() will always give calculated score sofar  and max(2*score,1) will give score for current closing paranthesis. It is important to reset score after pushing to stack because for every new opening score should start with 0\\n\\n```\n```\\nExample 3 : (())\\nstep 1: 0 // current stack\\nstep 2: 0 0 // updated stack for second opening paranthesis\\nstep 3: calculate score = 0 + max(2*0,1) = 0 + 1 = 1 (which is for inside nested pair ())\\nstep 4 : calculate score = 0 + max(2*1,1) = 0 + 2 = 2 (which is for outer pair 2*(score of innner pair 1))\\n\\nNote : In case of nested pairs max(2*current_score,1) will provide multiplication factor for nested pairs\\n\\nsimilary \\nif you have nested at 3 (2*(2*(1))) levels score = 2*(2*(1))  = 4\\nif you have nested at 4 (2*(2*(2*(1)))) levels score = 2*(2*(2*(1)))  = 8\\n\\n```\n```\\npublic int scoreOfParentheses(String S) {\\n    int score = 0;\\n    int depth = 0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            depth++;\\n        } else {\\n            depth--;\\n        }\\n\\n        if (s.charAt(i) == \\')\\' && s.charAt(i - 1) == \\'(\\') {\\n            // Whenever you meet a () pair, you multiply 1 by all the 2 outside of it, and accumulate the result\\n            score += Math.pow(2, depth);\\n        }\\n    }\\n\\n    return score;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818803,
                "title": "easy-based-solution-c-fcuk-u",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string x) {\\n        stack<int>s;\\n        //here we are putting these scores in here eyou can see\\n        for(int i=0;i<x.length();i++)\\n        {\\n            if(x[i]==\\'(\\')\\n            {\\n                s.push(0);\\n            }\\n            else if(x[i]==\\')\\')\\n            {\\n                //here we make two cases of simple and complex \\n                if(s.top()==0)\\n                {\\n                    //simple ()\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else\\n                {\\n                    //for complex case\\n                    int ans=0;\\n                    while(s.top()!=0)\\n                    {\\n                        ans=ans+s.top();\\n                        s.pop();\\n                    }\\n                    s.pop();\\n                    s.push(2*ans);\\n                }\\n            }\\n                \\n        }\\n        int count=0;\\n        while(!s.empty())\\n        {\\n            count=count+s.top();\\n            s.pop();\\n        }\\n        return count;\\n    }\\n};\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string x) {\\n        stack<int>s;\\n        //here we are putting these scores in here eyou can see\\n        for(int i=0;i<x.length();i++)\\n        {\\n            if(x[i]==\\'(\\')\\n            {\\n                s.push(0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1496748,
                "title": "o-n-solution",
                "content": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n    int cur=0;\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                st.push(cur);\\n                cur=0;\\n            }\\n            else{\\n                cur=st.pop()+Math.max(2*cur,1);\\n            }\\n        }\\n        return cur;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n    int cur=0;\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                st.push(cur);\\n                cur=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1487703,
                "title": "cpp-using-stack-o-n",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string st) {\\n        stack<int> s;\\n        int val=0;\\n        for(int i=0;i<st.length();i++)\\n        {\\n            if(st[i]==\\'(\\')\\n                s.push(-1);\\n            else\\n            {\\n                if(s.top()==-1)\\n                {\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else\\n                {\\n                     val=0;\\n                    while(!s.empty()&&s.top()!=-1)\\n                    {\\n                        val+=s.top();\\n                        s.pop();\\n                    }\\n                    s.pop();\\n                    s.push(2*val);\\n                }\\n            }\\n        }\\n        val=0;\\n        while(!s.empty())\\n        {\\n            val+=s.top();\\n            s.pop();\\n        }\\n        return val;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string st) {\\n        stack<int> s;\\n        int val=0;\\n        for(int i=0;i<st.length();i++)\\n        {\\n            if(st[i]==\\'(\\')\\n                s.push(-1);\\n            else\\n            {\\n                if(s.top()==-1)\\n                {\\n                    s.pop();\\n                    s.push(1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1219205,
                "title": "100-faster-intuitive-recursive-solution-with-proper-comments",
                "content": "```\\n    int scoreOfParentheses(string s) \\n    {\\n        unordered_map<int,int> map;  //key will be index of \\'(\\' and value will be index of corresponding closing bracket\\n        stack<int> stack; //stack will be used to find index of \\')\\' corresponding to each \\'(\\'\\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)  // fill entries in map(preprocessing)\\n        {\\n            if(s[i]==\\'(\\')\\n                stack.push(i);\\n            else\\n            {\\n                int ind=stack.top();\\n                stack.pop();\\n                map[ind]=i;\\n            }\\n                \\n        }\\n        \\n        return score(0,n-1,map); //calling recursive function to calculate score for whole expression\\n    }\\n\\t\\n\\tint score(int start,int end,unordered_map<int,int> map)\\n    {\\n        \\n        if(start+1==end and map[start]==end) // if \\'(\\' and \\')\\' are adjacent like \"()\"\\n        {\\n            return 1;\\n        }\\n        else if(map[start]==end) // if \\')\\' corresponding to first \\'(\\' is at last index like \"(..........)\"\\n            return 2*score(start+1,end-1,map);\\n        else\\n            return score(start,map[start],map)+score(map[start]+1,end,map); //case where \"()()\" \\n            \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n    int scoreOfParentheses(string s) \\n    {\\n        unordered_map<int,int> map;  //key will be index of \\'(\\' and value will be index of corresponding closing bracket\\n        stack<int> stack; //stack will be used to find index of \\')\\' corresponding to each \\'(\\'\\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)  // fill entries in map(preprocessing)\\n        {\\n            if(s[i]==\\'(\\')\\n                stack.push(i);\\n            else\\n            {\\n                int ind=stack.top();\\n                stack.pop();\\n                map[ind]=i;\\n            }\\n                \\n        }\\n        \\n        return score(0,n-1,map); //calling recursive function to calculate score for whole expression\\n    }\\n\\t\\n\\tint score(int start,int end,unordered_map<int,int> map)\\n    {\\n        \\n        if(start+1==end and map[start]==end) // if \\'(\\' and \\')\\' are adjacent like \"()\"\\n        {\\n            return 1;\\n        }\\n        else if(map[start]==end) // if \\')\\' corresponding to first \\'(\\' is at last index like \"(..........)\"\\n            return 2*score(start+1,end-1,map);\\n        else\\n            return score(start,map[start],map)+score(map[start]+1,end,map); //case where \"()()\" \\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081334,
                "title": "score-of-parentheses-easy-to-understand-explanation-javascript-code",
                "content": "Initially I read this and it seemed quite easy.  However once I tried to implement it, I was caught up in odd recursive calls which sometimes worked, and others didn\\'t.  After passing my 30minute self timer I gave up and went to the solution.  Even understanding that was a challenge so I will attempt to improve on the solution explanation.\\n\\nOk, one way to think of this problem is in the number of \\'()\\' or cores.  I dont mean nesting, I mean the literal \\'()\\'.  The answer is the sum of those values.  The nesting only serves to double their value.  So, no need to do a recursive call, or even use a stack.  \\n\\nHow can we do this in a linear fashion?  Ok, loop though your string.  Every time u notice a (, you increment your depth counter.  If the current char is not a (, it must be a ).  Now you have two possibilities, the previous char could have been a (, in which case, u\\'ve got a core (), so add its value to the score (more on the calc later, see next paragraph).  Or the previous character could have been another ), ie )).  In that case u don\\'t have a core, but you still need to decrement the nesting level, which previously you had incremented on a prior iteration of seeing (.  \\n\\nRegarding that core value.  What is it?  Well check how many levels it is nested and double its value that many times.  So (()) would be 1*2^depth or using a bitwise operator, 1 shifted 1 place, so 1 << 1 = 2  \\n\\nIn summary: The trick is to evaluate each \\'core\\' as you encounter it, adding its value to the score. For it\\'s score, you\\'ll keep track of how deep the nesting is, sometimes decrementing the nesting as necessary when you find closing parens.\\n\\n```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth; // binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth; // binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081212,
                "title": "score-of-parentheses-python-recursive-solution",
                "content": "The variable \"layer\" is equal to 0 when the iterator is between two balanced parentheses while not inside any parentheses.\\n```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        if S == \"()\":\\n            return 1\\n        layer = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                layer += 1\\n            elif S[i] == \")\":\\n                layer -= 1\\n                if layer == 0 and i < len(S)-1:\\n                    return self.scoreOfParentheses(S[:i+1]) + self.scoreOfParentheses(S[i+1:])\\n        return 2 * self.scoreOfParentheses(S[1:len(S)-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        if S == \"()\":\\n            return 1\\n        layer = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                layer += 1\\n            elif S[i] == \")\":\\n                layer -= 1\\n                if layer == 0 and i < len(S)-1:\\n                    return self.scoreOfParentheses(S[:i+1]) + self.scoreOfParentheses(S[i+1:])\\n        return 2 * self.scoreOfParentheses(S[1:len(S)-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080627,
                "title": "score-of-parentheses-js-python-java-c-easy-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nAny time we see a problem that describes a doubling operation and an incrementing operation, we should at least think about a potential binary solution. In this case, those are really the only two operations. Nested doubling operations means powers of **2** depending on the nesting depth, and a simple closed pair of parentheses is a **+1**.\\n\\nAt first glance, the addition operation would seem to cause a problem, but math once again comes to our aid.\\n\\nConsider the following:\\n```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\\nAs we can see, we don\\'t *really* have to wait for the summation before applying the power operation, because it will get distributed across the summation anyway. And since we know how many nested parentheses there are (**pwr**) when we finish a simple parentheses pair, we can immediately add the appropriate value to our answer (**ans**).\\n\\nThis means that we can solve this problem in **O(n) time** and **O(1) space**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor JavaScript **S.charAt(i)** is faster at processing string iteration than **S[i]**.\\n\\nWe can start our iteration at **i = 1** because we know the first character is going to be **\"(\"**. We *could* start at **i = 0**, but then we\\'d have to either start with **pwr = 1** or make sure to decrement **pwr** before the power operation instead of after.\\n\\nWe can use a **bitwise shift** for the power operation to more accurately reflect the solution\\'s binary nature.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **64ms / 38.4MB** (beats 99% / 77%).\\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.0MB** (beats 96% / 90%).\\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 37.0MB** (beats 100% / 60%).\\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.9MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070470,
                "title": "java-easy-to-understand-stack-solution",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n        for(char ch: S.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n            {\\n                stack.push(\"(\");\\n            }\\n            else\\n            {\\n                if(stack.peek().equals(\"(\"))\\n                {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                else\\n                {\\n                    int val = 0;\\n                    while(!stack.isEmpty() && !stack.peek().equals(\"(\"))\\n                        val += Integer.parseInt(stack.pop());\\n                    val *= 2;\\n                    stack.pop();\\n                    stack.push(String.valueOf(val));\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        while(!stack.isEmpty())\\n        {\\n            \\n            ans += Integer.parseInt(stack.pop());\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n        for(char ch: S.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n            {\\n                stack.push(\"(\");\\n            }\\n            else\\n            {\\n                if(stack.peek().equals(\"(\"))\\n                {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                else\\n                {\\n                    int val = 0;\\n                    while(!stack.isEmpty() && !stack.peek().equals(\"(\"))\\n                        val += Integer.parseInt(stack.pop());\\n                    val *= 2;\\n                    stack.pop();\\n                    stack.push(String.valueOf(val));\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        while(!stack.isEmpty())\\n        {\\n            \\n            ans += Integer.parseInt(stack.pop());\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906001,
                "title": "c-o-n-solution-beats-100-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/score-of-parentheses/submissions/\\n    \\n    Since the scoring happens based on the nested braces, we need a way\\n    to know the level of nested braces. To indicate each nested level we\\n    use 0 when a \\'(\\' is encountered. Then everytime we get a \\')\\', we find \\n    the total score between the start of the \\'(\\' and current \\')\\', \\n    use the rule 2 * A and push the result back.\\n    \\n    Eg: ()()\\n    ( Stack: 0,\\n    ) Stack: 1,\\n    ( Stack: 1, 0\\n    ) Stack: 1, 1\\n    \\n    Final: 1 + 1 = 2\\n    \\n    TC: O(N)\\n    SC: O(N)\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int total = 0;\\n        int curr_score = 0;\\n        \\n        stack<int> vals;\\n        \\n        for(char &c: s) {\\n            // opening bracket\\n            if(c == \\'(\\') { \\n                vals.emplace(0);\\n            }\\n            else {\\n                int curr_val = 0;\\n                // find the total sum\\n                while(vals.top() != 0) {\\n                    curr_val += vals.top();\\n                    vals.pop(); \\n                }\\n                // remove score for the opening brace of current )\\n                vals.pop();\\n                // assign score based on whether the current \\n                // closing brace has enclosed brace \\n                curr_val = curr_val == 0 ? 1 : 2 * curr_val;\\n                vals.emplace(curr_val);\\n            }\\n        }\\n        // final score is sum of all remaining brace scores\\n        while(!vals.empty()) {\\n            total += vals.top();\\n            vals.pop();\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/score-of-parentheses/submissions/\\n    \\n    Since the scoring happens based on the nested braces, we need a way\\n    to know the level of nested braces. To indicate each nested level we\\n    use 0 when a \\'(\\' is encountered. Then everytime we get a \\')\\', we find \\n    the total score between the start of the \\'(\\' and current \\')\\', \\n    use the rule 2 * A and push the result back.\\n    \\n    Eg: ()()\\n    ( Stack: 0,\\n    ) Stack: 1,\\n    ( Stack: 1, 0\\n    ) Stack: 1, 1\\n    \\n    Final: 1 + 1 = 2\\n    \\n    TC: O(N)\\n    SC: O(N)\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int total = 0;\\n        int curr_score = 0;\\n        \\n        stack<int> vals;\\n        \\n        for(char &c: s) {\\n            // opening bracket\\n            if(c == \\'(\\') { \\n                vals.emplace(0);\\n            }\\n            else {\\n                int curr_val = 0;\\n                // find the total sum\\n                while(vals.top() != 0) {\\n                    curr_val += vals.top();\\n                    vals.pop(); \\n                }\\n                // remove score for the opening brace of current )\\n                vals.pop();\\n                // assign score based on whether the current \\n                // closing brace has enclosed brace \\n                curr_val = curr_val == 0 ? 1 : 2 * curr_val;\\n                vals.emplace(curr_val);\\n            }\\n        }\\n        // final score is sum of all remaining brace scores\\n        while(!vals.empty()) {\\n            total += vals.top();\\n            vals.pop();\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877174,
                "title": "python-stack-o-n-explanations",
                "content": "The solution is below. The intuition follows.\\n\\n```python\\ndef scoreOfParentheses(self, S: str) -> int:\\n                \\n        stack = []\\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(0)\\n            \\n            else:\\n                score = 0\\n                while stack[-1]:       # case AB: score(A) + score(B)\\n                    score += stack[-1]\\n                    stack.pop()\\n                stack.pop() # pop 0 that corresponds to \\'(\\'\\n                stack.append(2 * score if score else 1) # if score = 0 => case: \"()\" if score>0 => case \"(A)\"\\n              \\n        return sum(stack)\\n\\t\\t\\n```\\n\\nIntuition: \\nFor every character in S:\\n- if it\\'s an `(` push 0 to the stack\\n- If it\\'s an `)`:\\n\\t- `pop` and `sum` all values of the stack unitl reaching `0` which corresponds to the open `(`\\n\\t- if the `sum = 0`, this means we\\'re in the case `()`, then push `1` to the stack\\n\\t- if the `sum > 0`, this means we\\'re in the case `(A)`, then push `2 * sum` to the stack\\n- Finally, return the `sum` of all remaining values of the stack\\n\\nComplexity Analysis:\\n\\t- Time Complexity: `O(n)`\\n\\t- Space Complexity: `O(n/2) = O(n)`\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef scoreOfParentheses(self, S: str) -> int:\\n                \\n        stack = []\\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(0)\\n            \\n            else:\\n                score = 0\\n                while stack[-1]:       # case AB: score(A) + score(B)\\n                    score += stack[-1]\\n                    stack.pop()\\n                stack.pop() # pop 0 that corresponds to \\'(\\'\\n                stack.append(2 * score if score else 1) # if score = 0 => case: \"()\" if score>0 => case \"(A)\"\\n              \\n        return sum(stack)\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 750647,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int t = 0;\\n        int res = 0;\\n        for (int i = 0; i < S.length() - 1; i++) {\\n            if (S[i] == \\'(\\') {\\n                t++;\\n                if (S[i + 1] == \\')\\') {\\n                    res += pow(2, t - 1);\\n                }\\n            } else {\\n                t--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int t = 0;\\n        int res = 0;\\n        for (int i = 0; i < S.length() - 1; i++) {\\n            if (S[i] == \\'(\\') {\\n                t++;\\n                if (S[i + 1] == \\')\\') {\\n                    res += pow(2, t - 1);\\n                }\\n            } else {\\n                t--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740991,
                "title": "c-0ms-runtime-100-using-stack-14-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>stackk;\\n        int result=0;\\n        for(int i=0;i<S.size();i++){\\n            if(S[i]==\\'(\\'){stackk.push(0);}\\n            else{\\n                int score = (stackk.top()==0)? 1 : stackk.top();\\n                stackk.pop();\\n                if(stackk.empty()){result+=score;}\\n                else{stackk.top() += 2*score;}\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>stackk;\\n        int result=0;\\n        for(int i=0;i<S.size();i++){\\n            if(S[i]==\\'(\\'){stackk.push(0);}\\n            else{\\n                int score = (stackk.top()==0)? 1 : stackk.top();\\n                stackk.pop();\\n                if(stackk.empty()){result+=score;}\\n                else{stackk.top() += 2*score;}\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630695,
                "title": "java-4-lines-recursive",
                "content": "```\\nclass Solution {\\n    int i = 0;\\n    public int scoreOfParentheses(String S) {\\n\\n        int k = 0;\\n        while ( i < S.length()) {\\n            if (S.charAt(i++) == \\')\\')\\n                return k == 0 ? 1 : k;\\n            k += 2 * scoreOfParentheses(S);\\n        }\\n        return k/2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int i = 0;\\n    public int scoreOfParentheses(String S) {\\n\\n        int k = 0;\\n        while ( i < S.length()) {\\n            if (S.charAt(i++) == \\')\\')\\n                return k == 0 ? 1 : k;\\n            k += 2 * scoreOfParentheses(S);\\n        }\\n        return k/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581799,
                "title": "java-recursion-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        return helper(S, 0, S.length()-1);\\n        \\n    }\\n    \\n    public int helper(String S, int l, int r){\\n        if(r-l == 1) return 1;\\n        \\n        int count = 0;\\n        for(int i = l; i < r; i++){\\n            \\n            if (S.charAt(i) == \\'(\\') count++;\\n            if (S.charAt(i) == \\')\\') count--;\\n            \\n            if (count == 0){\\n                return helper(S, l, i) + helper(S, i+1, r);\\n            }\\n        }\\n        \\n        return 2 * helper(S, l+1, r-1);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        return helper(S, 0, S.length()-1);\\n        \\n    }\\n    \\n    public int helper(String S, int l, int r){\\n        if(r-l == 1) return 1;\\n        \\n        int count = 0;\\n        for(int i = l; i < r; i++){\\n            \\n            if (S.charAt(i) == \\'(\\') count++;\\n            if (S.charAt(i) == \\')\\') count--;\\n            \\n            if (count == 0){\\n                return helper(S, l, i) + helper(S, i+1, r);\\n            }\\n        }\\n        \\n        return 2 * helper(S, l+1, r-1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522559,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        vector<pair<char, int>> stack;\\n        int sum = 0, score;\\n        for(int i = 0; i < S.size(); i++){\\n            if(stack.empty() || S[i] == \\'(\\'){\\n                stack.push_back(make_pair(S[i], 0));\\n            }\\n            else{ //S is valid so S[i] == \\')\\' and stack.back().first == \\'(\\'\\n                score = stack.back().second * 2;\\n                score = score == 0? 1 : score;\\n                stack.pop_back();\\n                if(stack.empty()){\\n                    sum += score;\\n                }\\n                else{ //S is valid so stack.back().fist ==\\'(\\'\\n                    stack.back().second += score;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        vector<pair<char, int>> stack;\\n        int sum = 0, score;\\n        for(int i = 0; i < S.size(); i++){\\n            if(stack.empty() || S[i] == \\'(\\'){\\n                stack.push_back(make_pair(S[i], 0));\\n            }\\n            else{ //S is valid so S[i] == \\')\\' and stack.back().first == \\'(\\'\\n                score = stack.back().second * 2;\\n                score = score == 0? 1 : score;\\n                stack.pop_back();\\n                if(stack.empty()){\\n                    sum += score;\\n                }\\n                else{ //S is valid so stack.back().fist ==\\'(\\'\\n                    stack.back().second += score;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442398,
                "title": "c-0ms-solution",
                "content": "````\\n#include<bits/stdc++.h>\\n#define FOR(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\\n#define RFOR(i,a,b) for(long long i = (long long)(a); i >= (long long)(b); i--)\\n#define MIN3(a,b,c) (a)<(b)?((a)<(c)?(a):(c)):((b)<(c)?(b):(c))\\n#define MAX(a,b) (a)>(b)?(a):(b)\\n#define MIN2(a,b) (a)<(b)?(a):(b)\\nusing namespace std;\\ntypedef pair<int, int> ii;\\ntypedef pair<int, ii> iii;\\ntypedef vector<ii> vii;\\ntypedef vector<int> vi;\\ntypedef long long ll;\\n#define ull unsigned long long\\ntypedef long double ld;\\ntypedef vector<ll> vll;\\ntypedef pair<ll,ll> lll;\\n#define deb(x )     cerr << #x << \" here \"<< x << endl;\\n#define endl    \"\\\\n\"\\n#define printCase() \"Case #\" << caseNum << \": \"\\ninline bool is_palindrome(const string& s){ return std::equal(s.begin(), s.end(), s.rbegin()); }\\nconst ll MOD = 1000000007;\\nconst ll INF = 1e9+5;\\nconst double eps = 1e-7;\\nconst double PI = acos(-1.0);\\n#define coud(a,d) cout << fixed << showpoint << setprecision(d) << a;\\ninline void debug_vi(vi a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\ninline void debug_vll(vll a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> st;\\n        int cnt = 0;\\n        // ) = 0  ( = -1\\n        FOR(i,0,S.length()) {\\n            if(S[i] == \\')\\') {\\n                int a = st.top();\\n                st.pop();\\n                int n = 0;\\n                while(a != 0) {\\n                    n+=a;\\n                    a = st.top();\\n                    st.pop();\\n                }\\n                st.push(n== 0?1:2*n);\\n            } else {\\n                st.push(0);\\n            }\\n        }\\n        int n = 0;\\n        while(!st.empty()) {\\n            n+=st.top();\\n            st.pop();\\n        }\\n        return n;\\n    }\\n};\\n```\\n\\nimplemented using stack . \\nPlease tell if you find any error in this approach",
                "solutionTags": [],
                "code": "````\\n#include<bits/stdc++.h>\\n#define FOR(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\\n#define RFOR(i,a,b) for(long long i = (long long)(a); i >= (long long)(b); i--)\\n#define MIN3(a,b,c) (a)<(b)?((a)<(c)?(a):(c)):((b)<(c)?(b):(c))\\n#define MAX(a,b) (a)>(b)?(a):(b)\\n#define MIN2(a,b) (a)<(b)?(a):(b)\\nusing namespace std;\\ntypedef pair<int, int> ii;\\ntypedef pair<int, ii> iii;\\ntypedef vector<ii> vii;\\ntypedef vector<int> vi;\\ntypedef long long ll;\\n#define ull unsigned long long\\ntypedef long double ld;\\ntypedef vector<ll> vll;\\ntypedef pair<ll,ll> lll;\\n#define deb(x )     cerr << #x << \" here \"<< x << endl;\\n#define endl    \"\\\\n\"\\n#define printCase() \"Case #\" << caseNum << \": \"\\ninline bool is_palindrome(const string& s){ return std::equal(s.begin(), s.end(), s.rbegin()); }\\nconst ll MOD = 1000000007;\\nconst ll INF = 1e9+5;\\nconst double eps = 1e-7;\\nconst double PI = acos(-1.0);\\n#define coud(a,d) cout << fixed << showpoint << setprecision(d) << a;\\ninline void debug_vi(vi a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\ninline void debug_vll(vll a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> st;\\n        int cnt = 0;\\n        // ) = 0  ( = -1\\n        FOR(i,0,S.length()) {\\n            if(S[i] == \\')\\') {\\n                int a = st.top();\\n                st.pop();\\n                int n = 0;\\n                while(a != 0) {\\n                    n+=a;\\n                    a = st.top();\\n                    st.pop();\\n                }\\n                st.push(n== 0?1:2*n);\\n            } else {\\n                st.push(0);\\n            }\\n        }\\n        int n = 0;\\n        while(!st.empty()) {\\n            n+=st.top();\\n            st.pop();\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 263080,
                "title": "javascript-recursive-solution",
                "content": "```js\\nconst scoreOfParentheses = (S) => {\\n    if (S === \\'()\\') return 1;\\n    \\n    const stack = [], parts = [];\\n    let part = \\'\\';\\n    for (const char of S) {\\n        part += char;\\n        if (char === \\'(\\') {\\n            stack.push(0);\\n        } else {\\n            stack.pop();\\n            if (stack.length === 0) {\\n                parts.push(part);\\n                part = \\'\\';\\n            }\\n        }\\n    }\\n    if (parts.length === 1) {\\n        return scoreOfParentheses(S.slice(1, S.length - 1)) * 2;\\n    }\\n    return parts.reduce((prev, item) => prev + scoreOfParentheses(item), 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\nconst scoreOfParentheses = (S) => {\\n    if (S === \\'()\\') return 1;\\n    \\n    const stack = [], parts = [];\\n    let part = \\'\\';\\n    for (const char of S) {\\n        part += char;\\n        if (char === \\'(\\') {\\n            stack.push(0);\\n        } else {\\n            stack.pop();\\n            if (stack.length === 0) {\\n                parts.push(part);\\n                part = \\'\\';\\n            }\\n        }\\n    }\\n    if (parts.length === 1) {\\n        return scoreOfParentheses(S.slice(1, S.length - 1)) * 2;\\n    }\\n    return parts.reduce((prev, item) => prev + scoreOfParentheses(item), 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150131,
                "title": "java-solution-o-1-space-o-n-time",
                "content": "The key is to recognize that we only add to result when a \\')\\' is found right after a \\'(\\'. Use an interger to keep track of how much we should add to result when a \"()\" pattern is found.\\n\\n```\\npublic int scoreOfParentheses(String S) {\\n    int mult = 0, res = 0;  //Multiplier determines how much should be added to result when a \"()\" is found\\n    for (int i = 0; i < S.length(); i++){\\n        if (S.charAt(i)==\\'(\\'){\\n            mult+=mult==0?1:mult;\\n        }else{\\n            if (S.charAt(i-1)==\\'(\\'){\\n                res+=mult;\\n            }\\n            mult/=2;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int scoreOfParentheses(String S) {\\n    int mult = 0, res = 0;  //Multiplier determines how much should be added to result when a \"()\" is found\\n    for (int i = 0; i < S.length(); i++){\\n        if (S.charAt(i)==\\'(\\'){\\n            mult+=mult==0?1:mult;\\n        }else{\\n            if (S.charAt(i-1)==\\'(\\'){\\n                res+=mult;\\n            }\\n            mult/=2;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142048,
                "title": "python-o-n-solution-with-explanation",
                "content": "Each element or collection of elements in the string can be considered a primitive or an object. Primitives are single elements `(` or `)` while objects are constructs that can be created out of primitives, such as `(())` or `()()`. By keeping track of the score of objects as we traverse the string, the total score can be computed easily.\\n\\nThe stack contains tuples of the form `(x, y)` where `x` is a boolean indicating whether the item is a primitive or object and `y` is an integer describing the primitive/object\\'s score.\\n* When encountering `(`, we push `(` onto the stack as a primitive with score 0\\n* When encountering `)`, there are two cases: the `)` either (1) the closes a `(` primitive or (2) encompasses an object or series of objects that contains a `(` in the beginning. For (1), we can construct an object `()` with score `1` and push it onto the stack. For (2), we can compute the score of the series of objects, multiply it by two when we discover a `(`, then push the newly formed object onto the stack.\\n\\nIn the end, the stack will contain a series of objects since all primitives will have turned into objects. Therefore, we can simply compute the score of all objects, which is the result.\\n\\n    def scoreOfParentheses(self, S):\\n        stack = []\\n        res = 0\\n        \\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append((False, 0))\\n            if c == \\')\\':\\n                obj, new_score = stack.pop()\\n                if obj:\\n                    while obj:\\n                        obj, score = stack.pop()\\n                        new_score += score\\n                    stack.append((True, new_score * 2))\\n                else:\\n                    stack.append((True, 1))\\n\\n        while stack:\\n            obj, score = stack.pop()\\n            res += score\\n        \\n        return res",
                "solutionTags": [],
                "code": "Each element or collection of elements in the string can be considered a primitive or an object. Primitives are single elements `(` or `)` while objects are constructs that can be created out of primitives, such as `(())` or `()()`. By keeping track of the score of objects as we traverse the string, the total score can be computed easily.\\n\\nThe stack contains tuples of the form `(x, y)` where `x` is a boolean indicating whether the item is a primitive or object and `y` is an integer describing the primitive/object\\'s score.\\n* When encountering `(`, we push `(` onto the stack as a primitive with score 0\\n* When encountering `)`, there are two cases: the `)` either (1) the closes a `(` primitive or (2) encompasses an object or series of objects that contains a `(` in the beginning. For (1), we can construct an object `()` with score `1` and push it onto the stack. For (2), we can compute the score of the series of objects, multiply it by two when we discover a `(`, then push the newly formed object onto the stack.\\n\\nIn the end, the stack will contain a series of objects since all primitives will have turned into objects. Therefore, we can simply compute the score of all objects, which is the result.\\n\\n    def scoreOfParentheses(self, S):\\n        stack = []\\n        res = 0\\n        \\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append((False, 0))\\n            if c == \\')\\':\\n                obj, new_score = stack.pop()\\n                if obj:\\n                    while obj:\\n                        obj, score = stack.pop()\\n                        new_score += score\\n                    stack.append((True, new_score * 2))\\n                else:\\n                    stack.append((True, 1))\\n\\n        while stack:\\n            obj, score = stack.pop()\\n            res += score\\n        \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 141865,
                "title": "short-java-solution",
                "content": "```\\n    public int scoreOfParentheses(String S) {\\n        int ans = 0, depth = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            depth += S.charAt(i) == \\'(\\' ? 1 : -1;\\n            if (S.charAt(i) == \\'(\\' && S.charAt(i + 1) == \\')\\') ans += 1 << (depth - 1); \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int scoreOfParentheses(String S) {\\n        int ans = 0, depth = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            depth += S.charAt(i) == \\'(\\' ? 1 : -1;\\n            if (S.charAt(i) == \\'(\\' && S.charAt(i + 1) == \\')\\') ans += 1 << (depth - 1); \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141804,
                "title": "java-o-n-one-pass-non-recursive-using-stack",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int[] sum = new int[S.length() * 2];\\n        int top = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            if (S.charAt(i) == \\'(\\') {\\n                sum[++top] = 0;\\n            } else {\\n                sum[top - 1] += (S.charAt(i - 1) == \\'(\\' ? 1 : 2 * sum[top]);\\n                top--;\\n            }\\n        }\\n        return sum[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int[] sum = new int[S.length() * 2];\\n        int top = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            if (S.charAt(i) == \\'(\\') {\\n                sum[++top] = 0;\\n            } else {\\n                sum[top - 1] += (S.charAt(i - 1) == \\'(\\' ? 1 : 2 * sum[top]);\\n                top--;\\n            }\\n        }\\n        return sum[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141803,
                "title": "no-3-4-liners-easily-understood-c-recursive-solution-with-explanation",
                "content": "No Hard feelings against 3-4 liners. But I just feel that its sometimes too difficult to come up with 3-4 lines of optimal solution during an actual interview :)\\n\\nThe idea is simple. Once you encounter a \\'(\\', you check whether the next element is \\')\\'. If it is, then you add 1 to the current result, else you recursively calculate the inner parentheses pattern value and multiply it by 2 and add to the current result.\\nSince we are using C++, so we can use pass by reference for index. \\nPlease do let me know if solution can be optimized further.\\n\\n```\\nclass Solution {\\npublic:\\n    int util(string& S,int& index){\\n        int result = 0;\\n        while(index < S.length()){\\n            if(S[index] == \\')\\') return result;\\n            else{\\n                if(S[index + 1] == \\')\\'){\\n                    result += 1;\\n                    index++;\\n                }\\n                else result += 2*util(S,++index);\\n            }\\n            index++;\\n        }\\n        return result;\\n    }\\n    \\n    int scoreOfParentheses(string S) {\\n        int n = S.length();\\n        if(n == 2) return 1;\\n        int index = 0;\\n        return util(S,index);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int util(string& S,int& index){\\n        int result = 0;\\n        while(index < S.length()){\\n            if(S[index] == \\')\\') return result;\\n            else{\\n                if(S[index + 1] == \\')\\'){\\n                    result += 1;\\n                    index++;\\n                }\\n                else result += 2*util(S,++index);\\n            }\\n            index++;\\n        }\\n        return result;\\n    }\\n    \\n    int scoreOfParentheses(string S) {\\n        int n = S.length();\\n        if(n == 2) return 1;\\n        int index = 0;\\n        return util(S,index);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011105,
                "title": "very-easy-soln-stack-greedy-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        # Initialize an empty stack to keep track of scores\\n        st = []\\n        # Initialize a variable to store the final result\\n        res = 0\\n        \\n        # Iterate through each character in the input string \\'s\\'\\n        for i in s:\\n            if i == \"(\":\\n                # When an opening parenthesis is encountered, push the current result onto the stack\\n                st.append(res)\\n                # Reset the current result to 0\\n                res = 0\\n            else:\\n                # When a closing parenthesis is encountered, pop the last result from the stack\\n                popd = st.pop()\\n                # Calculate the new result for the current parenthesis pair and update \\'res\\'\\n                res = popd + max(2 * res, 1)\\n        \\n        # The final \\'res\\' will contain the score of the entire expression\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        # Initialize an empty stack to keep track of scores\\n        st = []\\n        # Initialize a variable to store the final result\\n        res = 0\\n        \\n        # Iterate through each character in the input string \\'s\\'\\n        for i in s:\\n            if i == \"(\":\\n                # When an opening parenthesis is encountered, push the current result onto the stack\\n                st.append(res)\\n                # Reset the current result to 0\\n                res = 0\\n            else:\\n                # When a closing parenthesis is encountered, pop the last result from the stack\\n                popd = st.pop()\\n                # Calculate the new result for the current parenthesis pair and update \\'res\\'\\n                res = popd + max(2 * res, 1)\\n        \\n        # The final \\'res\\' will contain the score of the entire expression\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005820,
                "title": "simple-cpp-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans = 0;\\n\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'(\\')st.push(-1);\\n            if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    int temp = 0;\\n                    while(st.top()!=-1){\\n                        temp+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*temp);\\n                }\\n            }\\n        }\\n\\n        while(st.size()){ans+=st.top(); st.pop();}\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans = 0;\\n\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'(\\')st.push(-1);\\n            if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    int temp = 0;\\n                    while(st.top()!=-1){\\n                        temp+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*temp);\\n                }\\n            }\\n        }\\n\\n        while(st.size()){ans+=st.top(); st.pop();}\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756768,
                "title": "c-beats-100-recursive-simple-beginner-solution-commented",
                "content": "\\n# Approach\\nThink it as :- If we encounter a \\'(\\', then we see next char to it , if the next char is \\')\\' ,then we simply add 1 to ans ,else we call recursively to the next index and multiply the recursive sub-solution with 2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(string &s,int &i)\\n    {\\n        int ans=0;\\n        while(i<s.size() && s[i]!=\\')\\')\\n        {\\n            // if we have entered the loop => s[i]==\\'(\\' , now look for next char, so i++;\\n            i++;\\n            if(s[i]==\\')\\')  // now if next char is \\')\\' , => we got one pair so ans++;  \\n            ans++;\\n            else // if next char is \\'(\\' then we call recursion to i and multiply the recursive  \\n            ans += 2*solve(s,i);    //sub-solution with 2 , as per the rule of problem\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n    int scoreOfParentheses(string s) {\\n        int i=0;\\n        return solve(s,i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(string &s,int &i)\\n    {\\n        int ans=0;\\n        while(i<s.size() && s[i]!=\\')\\')\\n        {\\n            // if we have entered the loop => s[i]==\\'(\\' , now look for next char, so i++;\\n            i++;\\n            if(s[i]==\\')\\')  // now if next char is \\')\\' , => we got one pair so ans++;  \\n            ans++;\\n            else // if next char is \\'(\\' then we call recursion to i and multiply the recursive  \\n            ans += 2*solve(s,i);    //sub-solution with 2 , as per the rule of problem\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n    int scoreOfParentheses(string s) {\\n        int i=0;\\n        return solve(s,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643447,
                "title": "easy-to-understand-stack-c-solution",
                "content": "# Intuition\\nWhenever we see a parenthesis problem first intuition is using stacks.\\nThis is a special problem as here we have to carry the previous scores of the closed parenthesis.\\nThe code written below is a true beauty.\\nU will easily understand the logic behind it however it took time to come this solution on paper using many Testcases.\\n Below is the most beautiful line which reinitialise score as 0 .\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nUsing s.top() is understood but max function is used because score is being calculated inside which can be at times 0 so in that case we add to s.top(). rest applies to the condition\\n (()()\\')\\'\\nthis bracket is used for multiplication only.\\n\\nBasically every ( is carying the past scores in the stack and reinstatting its own score =0;\\n\\nupvote if you find it helpful !\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n\\n        stack<char> s;\\n        int n=str.size();\\n        int score=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(str[i]==\\'(\\'){\\n\\n                s.push(score);\\n                score=0;\\n\\n            }\\n\\n            else{\\n\\n                score=s.top()+max(2*score,1);\\n                s.pop();\\n            }\\n\\n        }\\n\\n\\n        return score;\\n\\n       \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n\\n        stack<char> s;\\n        int n=str.size();\\n        int score=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(str[i]==\\'(\\'){\\n\\n                s.push(score);\\n                score=0;\\n\\n            }\\n\\n            else{\\n\\n                score=s.top()+max(2*score,1);\\n                s.pop();\\n            }\\n\\n        }\\n\\n\\n        return score;\\n\\n       \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338104,
                "title": "very-simple-java-solution-beats-100-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        \\n        // instead of calculating like 2*(2*(1+1)+1). calculating like : 4*1 + 4*1 + 2*1\\n        int mul = 1;\\n        int add = 0;\\n        int ans = 0;\\n\\n        for(int i=0;i<s.length();i++){\\n\\n            char ch = s.charAt(i);\\n\\n            // keeping track of depth\\n            if(ch==\\'(\\' && s.charAt(i+1)==\\'(\\') mul *=2;  // for each nesting having a multiplier 2\\n\\n            else if(ch==\\'(\\' && s.charAt(i+1)==\\')\\'){\\n                add++;\\n                ans += add*mul;         // seperatly calculating the score\\n                add = 0;\\n                i++;\\n            }else if(ch==\\')\\'){\\n                mul /= 2;           // moving out of a nesting\\n            }\\n        }\\n\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        \\n        // instead of calculating like 2*(2*(1+1)+1). calculating like : 4*1 + 4*1 + 2*1\\n        int mul = 1;\\n        int add = 0;\\n        int ans = 0;\\n\\n        for(int i=0;i<s.length();i++){\\n\\n            char ch = s.charAt(i);\\n\\n            // keeping track of depth\\n            if(ch==\\'(\\' && s.charAt(i+1)==\\'(\\') mul *=2;  // for each nesting having a multiplier 2\\n\\n            else if(ch==\\'(\\' && s.charAt(i+1)==\\')\\'){\\n                add++;\\n                ans += add*mul;         // seperatly calculating the score\\n                add = 0;\\n                i++;\\n            }else if(ch==\\')\\'){\\n                mul /= 2;           // moving out of a nesting\\n            }\\n        }\\n\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217612,
                "title": "python-96-faster-easy-sliding-window",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        a,n=[],len(s)\\n        c=t=0\\n        for i in range(1,n):\\n            if s[i]==\\'(\\':\\n                t+=1\\n            elif s[i-1]==\\'(\\':\\n                c+=1<<t\\n                t-=1\\n            else:\\n                t-=1\\n        return c\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        a,n=[],len(s)\\n        c=t=0\\n        for i in range(1,n):\\n            if s[i]==\\'(\\':\\n                t+=1\\n            elif s[i-1]==\\'(\\':\\n                c+=1<<t\\n                t-=1\\n            else:\\n                t-=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019659,
                "title": "use-stack-to-store-intermediate-values-as-well-push-1-when-you-see",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.length();\\n        stack<int> st;\\n        int res = 0;\\n        bool f = false;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(-1);\\n            }\\n            else\\n            {\\n                int temp=0;\\n                while(!st.empty() && st.top()>-1)\\n                {\\n                    temp+=st.top();\\n                    st.pop();\\n                    f=1;\\n                }\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    if(!f){\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        f=0;\\n                        st.pop();\\n                        st.push(temp*2);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            if(st.top()!=-1)\\n                res+=st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.length();\\n        stack<int> st;\\n        int res = 0;\\n        bool f = false;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(-1);\\n            }\\n            else\\n            {\\n                int temp=0;\\n                while(!st.empty() && st.top()>-1)\\n                {\\n                    temp+=st.top();\\n                    st.pop();\\n                    f=1;\\n                }\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    if(!f){\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        f=0;\\n                        st.pop();\\n                        st.push(temp*2);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            if(st.top()!=-1)\\n                res+=st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959716,
                "title": "c-runtime-beats-100-using-stack-basics",
                "content": "**856. Score of Parentheses \\u23E9 An implementation problem**\\n\\nIf `s[i]==\\'(\\'` we will push it in stack as something to add to score has come.\\nif `s[i]==\\')\\'` now is the time to increment our score by factor ***k*** because it is time for this balanced bracket to leave. \\n\\n**Q.** How much should ***k*** be?\\n**Ans:** If `(((` is a sequence and a `)` comes, we can see that ( ( **( )** the bold balanced-bracket comes after 2 continuous brackets and it is given that `(A) = 2*A`. \\nTherefore, here `((()` will be `2*2*1` as `()` = 1 Or we can see this as `2^(size_of_stack-1)`, hence ***k*** = `pow(2,size_of_stack-1)`.\\n**Then we stop adding scores for upcoming continuous `)` brackets as obviously they are already included in `2^x`**.\\n\\nNote: Approach is very simple, but if you find the explanation unclear, kindly go through the code and dry-run for `s = \"(())((())())\"` and you\\'ll understand it. \\n\\nSome examples:\\n```\\n* ()() => 1+1\\n* (()()) => 2*(1+1)\\n* ((()())) => 2*2*(1+1)\\n* ((()(()))) => 2*2*(1+2*1)\\n```\\n\\n\\nTime: **O(N)** \\nSpace: **O(N)** \\n\\n**`C++ CODE` \\u2B07**\\n\\n```\\nint scoreOfParentheses(string s) {\\n        stack<char>st;\\n        int score=0;\\n        bool addScore=false;\\n        for(int i=0;i<s.size();i++){\\n            int sz = st.size()-1;\\n            if(s[i]==\\')\\'){\\n                if(addScore) \\n                    score+=pow(2,sz), addScore=false;\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n                addScore=true;\\n            }\\n        }\\n        return score;\\n}\\n```\\n\\n**UPVOTE if you like \\uD83D\\uDE07, feel free to ask doubts, I\\'ll try to reply asap.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n* ()() => 1+1\\n* (()()) => 2*(1+1)\\n* ((()())) => 2*2*(1+1)\\n* ((()(()))) => 2*2*(1+2*1)\\n```\n```\\nint scoreOfParentheses(string s) {\\n        stack<char>st;\\n        int score=0;\\n        bool addScore=false;\\n        for(int i=0;i<s.size();i++){\\n            int sz = st.size()-1;\\n            if(s[i]==\\')\\'){\\n                if(addScore) \\n                    score+=pow(2,sz), addScore=false;\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n                addScore=true;\\n            }\\n        }\\n        return score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704363,
                "title": "javascript-most-intuitive-solution",
                "content": "I think it\\'s much more intuitive solution than others, also Larry from video below\\nwas able to come up with it on spot which partly proves that it\\'s more intuitive, \\nthe easiest way to understand it is to dry run this test case:\\n\\'(()()())\\'\\nEsentially we push \\'(\\' if there is opening brackets and we calculate current sum if there is closing bracket, \\ncurrent sum might be spread across many groups, so we need to loop till we find previous opening bracket which we also going to \\npop as we found closing bracket to that particular opening bracket.\\n\\nFull explaination:\\nhttps://www.youtube.com/watch?v=QM7YYNFcgAU\\n\\n```\\nvar scoreOfParentheses = function(s) {\\n  const stack = []  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      const curr = s[i]\\n      \\n      if(curr===\\'(\\') {\\n          stack.push(\\'(\\')\\n          continue\\n      }\\n      \\n      let currSum = 0\\n      while(stack.length && stack[stack.length-1] !== \\'(\\') {\\n         currSum += stack.pop()\\n      }\\n      \\n      stack.pop()\\n      \\n      if(currSum===0) {\\n          stack.push(1)\\n      } else {\\n          stack.push(2*currSum)\\n      }\\n  }\\n    \\n    return stack.reduce((a,b) => a+b,0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar scoreOfParentheses = function(s) {\\n  const stack = []  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      const curr = s[i]\\n      \\n      if(curr===\\'(\\') {\\n          stack.push(\\'(\\')\\n          continue\\n      }\\n      \\n      let currSum = 0\\n      while(stack.length && stack[stack.length-1] !== \\'(\\') {\\n         currSum += stack.pop()\\n      }\\n      \\n      stack.pop()\\n      \\n      if(currSum===0) {\\n          stack.push(1)\\n      } else {\\n          stack.push(2*currSum)\\n      }\\n  }\\n    \\n    return stack.reduce((a,b) => a+b,0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682015,
                "title": "c-solution",
                "content": "```\\npublic int ScoreOfParentheses(string s) {\\n\\tStack<int> stack = new Stack<int>();\\n\\tint score = 0;\\n\\tchar[] chars = s.ToCharArray();\\n\\tforeach(char c in chars)\\n\\t{\\n\\t\\tint val = 0;\\n\\t\\tif (c == \\'(\\') stack.Push(0);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// calculate\\n\\t\\t\\twhile (stack.Peek() != 0) val = val + stack.Pop();\\n\\t\\t\\tval = Math.Max(2 * val, 1);\\n\\t\\t\\tstack.Pop();\\n\\t\\t\\tstack.Push(val);\\n\\t\\t}\\n\\t}\\n\\twhile(stack.Count > 0)\\n\\t\\tscore = score + stack.Pop();\\n\\treturn score;\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack"
                ],
                "code": "```\\npublic int ScoreOfParentheses(string s) {\\n\\tStack<int> stack = new Stack<int>();\\n\\tint score = 0;\\n\\tchar[] chars = s.ToCharArray();\\n\\tforeach(char c in chars)\\n\\t{\\n\\t\\tint val = 0;\\n\\t\\tif (c == \\'(\\') stack.Push(0);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// calculate\\n\\t\\t\\twhile (stack.Peek() != 0) val = val + stack.Pop();\\n\\t\\t\\tval = Math.Max(2 * val, 1);\\n\\t\\t\\tstack.Pop();\\n\\t\\t\\tstack.Push(val);\\n\\t\\t}\\n\\t}\\n\\twhile(stack.Count > 0)\\n\\t\\tscore = score + stack.Pop();\\n\\treturn score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664560,
                "title": "python-solution-explained-line-by-line",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int: \\n        st=[] #stack declared\\n        \\n        for i in s:\\n            #if ( is found put in stack\\n            if i==\\'(\\': \\n                st.append(i)\\n                \\n            #if ) is found \\n            elif i==\\')\\': \\n                \\n                #and stack top is opening bracket then need to enter the score 1\\n                #as said in question => \"()\" has score 1\\n                if st[-1]==\\'(\\': \\n                    st.pop()\\n                    st.append(1)\\n                \\n                #but if opening bracket is not found in st then there must me score numbers\\n                #are present in above opening bracket => 2nd rule (check in ques)\\n                #eg: st=[(,(,1,1,1,)] , closing bracket in st only for understanding, we are not really append it\\n                else:\\n                    #calculate the score till the opening bracket found\\n                    score=0\\n                    while st[-1]!=\\'(\\':\\n                        score+=st.pop()\\n                        \\n                    #so pop the opening bracket as we have calculated the score above it and \\n                    #now we have reached the 3rd rule => (A) has score 2 * A\\n                    #eg: st=[(,(,3,)] , closing bracket in st only for understanding, we are not really append it\\n                    st.pop()\\n                    st.append(2*score)\\n                    \\n        #return total sum of numbers present in st\\n        return sum(st)\\n        \\n```\\n**PLEASE UPVOTE IF YOU FOUND THE SOLUTION HELPFUL, THANKS !!**\\n**AND FREELY ASK YOUR DOUBTS** \\uD83C\\uDF3A",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int: \\n        st=[] #stack declared\\n        \\n        for i in s:\\n            #if ( is found put in stack\\n            if i==\\'(\\': \\n                st.append(i)\\n                \\n            #if ) is found \\n            elif i==\\')\\': \\n                \\n                #and stack top is opening bracket then need to enter the score 1\\n                #as said in question => \"()\" has score 1\\n                if st[-1]==\\'(\\': \\n                    st.pop()\\n                    st.append(1)\\n                \\n                #but if opening bracket is not found in st then there must me score numbers\\n                #are present in above opening bracket => 2nd rule (check in ques)\\n                #eg: st=[(,(,1,1,1,)] , closing bracket in st only for understanding, we are not really append it\\n                else:\\n                    #calculate the score till the opening bracket found\\n                    score=0\\n                    while st[-1]!=\\'(\\':\\n                        score+=st.pop()\\n                        \\n                    #so pop the opening bracket as we have calculated the score above it and \\n                    #now we have reached the 3rd rule => (A) has score 2 * A\\n                    #eg: st=[(,(,3,)] , closing bracket in st only for understanding, we are not really append it\\n                    st.pop()\\n                    st.append(2*score)\\n                    \\n        #return total sum of numbers present in st\\n        return sum(st)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639620,
                "title": "c-o-n-simple-solution",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else\\n            {\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    int count=1;\\n                    st.pop();\\n                    while(!st.empty() && st.top()!=-1)\\n                    {\\n                        count=count+st.top();\\n                        st.pop();\\n                    }\\n                    st.push(count);\\n                }\\n                else \\n                {\\n                    int count=0;\\n                    while(!st.empty() && st.top()!=-1)\\n                    {\\n                        count=count+st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(count*2);\\n                }\\n            }\\n            \\n        }\\n        int res=0;\\n        while(!st.empty()){\\n            res+=(int)st.top();st.pop();}\\n        return(res);\\n    }\\n};\\nWe simply assume \\'(\\' to be -1 and make a stack of integers and simply follow the instructions given in the question.",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else\\n            {\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    int count=1;\\n                    st.pop();\\n                    while(!st.empty() && st.top()!=-1)\\n                    {\\n                        count=count+st.top();\\n                        st.pop();\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2603270,
                "title": "easy-javascript-solution",
                "content": "```\\nvar scoreOfParentheses = function(s) {\\n    let stack = [0];\\n    \\n    for (let el of s) {\\n        if (el === \\'(\\') stack.push(0);\\n        \\n        else {\\n            let popped = stack.pop();\\n            \\n            if (popped === 0) stack[stack.length - 1] += 1;\\n            else {\\n                popped *= 2;\\n                stack[stack.length - 1] += popped;\\n            }\\n        }\\n    }\\n    \\n    return stack[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar scoreOfParentheses = function(s) {\\n    let stack = [0];\\n    \\n    for (let el of s) {\\n        if (el === \\'(\\') stack.push(0);\\n        \\n        else {\\n            let popped = stack.pop();\\n            \\n            if (popped === 0) stack[stack.length - 1] += 1;\\n            else {\\n                popped *= 2;\\n                stack[stack.length - 1] += popped;\\n            }\\n        }\\n    }\\n    \\n    return stack[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522600,
                "title": "c-100-fastest-easy-solution",
                "content": "Push -1 for \\'(\\' and push the value of corresponding balanced paranthesis string when you encounter \\')\\'.\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        \\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            st.push(-1);\\n            else\\n            {\\n                int x=0;\\n                while(st.size() and st.top()>0) // pop all numbers stored and store sum in x\\n                {\\n                    x+=st.top();\\n                    st.pop();\\n                }\\n                st.pop(); // pop the \\'(\\' char\\n                if(x==0) // if there was no number push 1 [for simple () ]\\n                st.push(1);\\n                else\\n                st.push(x*2); // else push total value * 2\\n            }\\n        }\\n        int ans=0;\\n        while(st.size()) //  sum all the remaining numbers and return sum\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        \\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            st.push(-1);\\n            else\\n            {\\n                int x=0;\\n                while(st.size() and st.top()>0) // pop all numbers stored and store sum in x\\n                {\\n                    x+=st.top();\\n                    st.pop();\\n                }\\n                st.pop(); // pop the \\'(\\' char\\n                if(x==0) // if there was no number push 1 [for simple () ]\\n                st.push(1);\\n                else\\n                st.push(x*2); // else push total value * 2\\n            }\\n        }\\n        int ans=0;\\n        while(st.size()) //  sum all the remaining numbers and return sum\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457022,
                "title": "java-solution-stack",
                "content": "```java \\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int a = 0;\\n                while(st.peek()!=0)\\n                    a+=st.pop();\\n                st.pop();\\n                st.push(Math.max(1,2*a));\\n            }\\n        }\\n        int score=0;\\n        while(!st.isEmpty()){\\n            score+=st.pop();\\n        }\\n        return score;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int a = 0;\\n                while(st.peek()!=0)\\n                    a+=st.pop();\\n                st.pop();\\n                st.push(Math.max(1,2*a));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2366247,
                "title": "easy-gredy-without-stack-o-n",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        \\n        level = 0\\n        result = 0\\n        prev = \"\"\\n        \\n        for c in s:           \\n            if c == \"(\":\\n                level += 1\\n            if c == \")\":\\n                if prev == \"(\":\\n                    result += 2 ** (level - 1)\\n                level -= 1                \\n            prev = c\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        \\n        level = 0\\n        result = 0\\n        prev = \"\"\\n        \\n        for c in s:           \\n            if c == \"(\":\\n                level += 1\\n            if c == \")\":\\n                if prev == \"(\":\\n                    result += 2 ** (level - 1)\\n                level -= 1                \\n            prev = c\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347385,
                "title": "c-iterative-stack-solution",
                "content": "(i) for a single opening brace, push score 0\\n(ii) if we found a closing brace then caluculate the score and push the curr score into the stack\\n(iii) at the end sum up all the scores and return \\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans =0;\\n        for(char c : s){\\n            int curr = 0;\\n            if(c == \\'(\\') st.push(0);\\n            else{\\n                while(st.top() != 0){\\n                    curr += st.top();\\n                    st.pop();\\n                }\\n                curr = max(curr*2,1);\\n                st.pop();\\n                st.push(curr);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans =0;\\n        for(char c : s){\\n            int curr = 0;\\n            if(c == \\'(\\') st.push(0);\\n            else{\\n                while(st.top() != 0){\\n                    curr += st.top();\\n                    st.pop();\\n                }\\n                curr = max(curr*2,1);\\n                st.pop();\\n                st.push(curr);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322146,
                "title": "c-stack-o-n-time-complexity",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        for(int i=0;i<s.length();i++)\\n            if(s[i]==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int flag=0;\\n                if(!st.top())\\n                {\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else\\n                {\\n                    while(st.top())\\n                    {\\n                        flag+=st.top();\\n                        st.pop();\\n                    }\\n                st.pop();\\n                st.push(2*flag);\\n                }\\n            }\\n        int result=0;\\n        while(!st.empty())\\n        {\\n            result+=st.top();\\n            st.pop();\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        for(int i=0;i<s.length();i++)\\n            if(s[i]==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int flag=0;\\n                if(!st.top())\\n                {\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else\\n                {\\n                    while(st.top())\\n                    {\\n                        flag+=st.top();\\n                        st.pop();\\n                    }\\n                st.pop();\\n                st.push(2*flag);\\n                }\\n            }\\n        int result=0;\\n        while(!st.empty())\\n        {\\n            result+=st.top();\\n            st.pop();\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2219644,
                "title": "c-easy-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        int ans =0;\\n        char prev;\\n        for(auto &e : s){\\n            if(e == \\'(\\') st.push(e);\\n            else{\\n              st.pop();\\n              if(prev == \\'(\\') ans+= pow(2, st.size());               \\n            }\\n            prev = e;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        int ans =0;\\n        char prev;\\n        for(auto &e : s){\\n            if(e == \\'(\\') st.push(e);\\n            else{\\n              st.pop();\\n              if(prev == \\'(\\') ans+= pow(2, st.size());               \\n            }\\n            prev = e;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166066,
                "title": "c-simple-implementation-0ms-without-stack",
                "content": "**Please do upvote if you liked my efforts :)**\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int ans = 0, open = 0, idx = 0;\\n                \\n        while(idx < s.length())\\n        {\\n            if(s[idx] == \\'(\\') ++open;\\n            else\\n            {\\n                --open;\\n                if(s[idx-1] == \\'(\\') ans += (1 << open);\\n            }\\n            ++idx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int ans = 0, open = 0, idx = 0;\\n                \\n        while(idx < s.length())\\n        {\\n            if(s[idx] == \\'(\\') ++open;\\n            else\\n            {\\n                --open;\\n                if(s[idx-1] == \\'(\\') ans += (1 << open);\\n            }\\n            ++idx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134388,
                "title": "python-856-solution",
                "content": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if 2 == len(s):\\n            return 1\\n        if 0 == len(s):\\n\\t        return 0\\n        left_count = 0\\n        right_count = 0\\n        for i in range(len(s)): \\n            if s[i] == \\'(\\':\\n\\t\\t        left_count += 1\\n            if s[i] == \\')\\':\\n\\t\\t        right_count += 1\\n\\n            if left_count == right_count:\\n                if left_count > 1:\\n                    return 2*self.scoreOfParentheses(s[1:i]) + self.scoreOfParentheses(s[i+1:])\\n                else:\\n                    return self.scoreOfParentheses(s[:i+1]) + self.scoreOfParentheses(s[i+1:])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if 2 == len(s):\\n            return 1\\n        if 0 == len(s):\\n\\t        return 0\\n        left_count = 0\\n        right_count = 0\\n        for i in range(len(s)): \\n            if s[i] == \\'(\\':\\n\\t\\t        left_count += 1\\n            if s[i] == \\')\\':\\n\\t\\t        right_count += 1\\n\\n            if left_count == right_count:\\n                if left_count > 1:\\n                    return 2*self.scoreOfParentheses(s[1:i]) + self.scoreOfParentheses(s[i+1:])\\n                else:\\n                    return self.scoreOfParentheses(s[:i+1]) + self.scoreOfParentheses(s[i+1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117775,
                "title": "java-2ms-easy-code",
                "content": "class Solution {\\n\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int ans  = 0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                st.push(-1);\\n            }\\n            else{\\n                if(st.peek() == -1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else{\\n                    int sum = 0;\\n                    while(st.peek()!=-1){\\n                        sum += st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*sum);\\n                }\\n            }\\n        }\\n        while(st.size()>0){\\n            ans +=st.pop();\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int ans  = 0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                st.push(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2092537,
                "title": "intuitive-solution-with-commentary-hope-this-is-helpful",
                "content": "\\n```\\nExample: ()(()())\\n\\nVisualization :\\n\\tStep 1: [1 ,(1,1)]\\n\\tStep 2: [1, (2)]\\n\\tStep 3: [1, 4]\\n\\tStep 4: [5]\\n\\n```\\n\\n```\\nclass Solution {\\n    \\n    public int scoreOfParentheses(String s) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int ans = 0;\\n        \\n        int i=0;\\n        while(i< s.length()){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                // I\\'m using -1 to represent \\'(\\' in the stack\\n                st.push(-1);\\n            }\\n            else {\\n                if(st.peek() == -1){\\n                    // Solve case:() and push the answer into the stack\\n                    st.pop(); // pop -1 i.e \\'(\\'\\n                    st.push(1);// push the answer\\n                }else{\\n                    // Sum while we do not encounter \\'(\\' \\n                    // End of while loop represents case: ( A+B+C... )\\n                    int sum = 0;\\n                    while(st.peek()!=-1){\\n                        sum+=st.pop();\\n                    }\\n                    \\n                    // Remove the \\'(\\' and multiple by 2 \\n                    // same as 2 * [A+B+C]\\n                    // Push the result into the stack\\n                    st.pop(); // Pop the \\'(\\' in the beginning of case: ( A+B+C... )\\n                    st.push(2*sum); // sum = A+B+C+..\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        // At the end, stack will have \\n        // a) one element : Case : (()()) : everything is enclosed inside one ()\\n        // b) multiple elements: Case: ()(()())\\n        while(!st.isEmpty()){\\n            ans+=st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n\\nPlease upvote if this was helpful. I\\'d use that as an indicator that it\\'s helping folks and I\\'d try to post more.",
                "solutionTags": [],
                "code": "```\\nExample: ()(()())\\n\\nVisualization :\\n\\tStep 1: [1 ,(1,1)]\\n\\tStep 2: [1, (2)]\\n\\tStep 3: [1, 4]\\n\\tStep 4: [5]\\n\\n```\n```\\nclass Solution {\\n    \\n    public int scoreOfParentheses(String s) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int ans = 0;\\n        \\n        int i=0;\\n        while(i< s.length()){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                // I\\'m using -1 to represent \\'(\\' in the stack\\n                st.push(-1);\\n            }\\n            else {\\n                if(st.peek() == -1){\\n                    // Solve case:() and push the answer into the stack\\n                    st.pop(); // pop -1 i.e \\'(\\'\\n                    st.push(1);// push the answer\\n                }else{\\n                    // Sum while we do not encounter \\'(\\' \\n                    // End of while loop represents case: ( A+B+C... )\\n                    int sum = 0;\\n                    while(st.peek()!=-1){\\n                        sum+=st.pop();\\n                    }\\n                    \\n                    // Remove the \\'(\\' and multiple by 2 \\n                    // same as 2 * [A+B+C]\\n                    // Push the result into the stack\\n                    st.pop(); // Pop the \\'(\\' in the beginning of case: ( A+B+C... )\\n                    st.push(2*sum); // sum = A+B+C+..\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        // At the end, stack will have \\n        // a) one element : Case : (()()) : everything is enclosed inside one ()\\n        // b) multiple elements: Case: ()(()())\\n        while(!st.isEmpty()){\\n            ans+=st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085095,
                "title": "go-faster-than-100-without-stack",
                "content": "Counting the power of 2 by using bit shift:\\n\\n```\\nfunc scoreOfParentheses(s string) int {\\n    var open, result int\\n    var closeLast bool\\n    for _, letter := range s {\\n        if letter == \\'(\\' {\\n            closeLast = false\\n            open++\\n            continue\\n        }\\n        open--\\n        if closeLast {\\n            continue\\n        }\\n        result+= 1 << open\\n        closeLast = true \\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc scoreOfParentheses(s string) int {\\n    var open, result int\\n    var closeLast bool\\n    for _, letter := range s {\\n        if letter == \\'(\\' {\\n            closeLast = false\\n            open++\\n            continue\\n        }\\n        open--\\n        if closeLast {\\n            continue\\n        }\\n        result+= 1 << open\\n        closeLast = true \\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074800,
                "title": "100-faster-simply-explained",
                "content": "Whenever the incoming character is opening parathesis,-1 will be pushed into stack. if closing is occuring, top element of stack will be checked whether it is -1 ( indicating that the last character was opening paranthesis) or other positive number ( indicating that last character was a closing paranthesis).\\n\\n-1 -> (last char was opening paranthesis) 1 will be pushed in in place of -1 ( indication tha one valid paranthesis) \\npoitiive number other than -1 ->(last char was closing paranthesis) all positive numbers will be added and popped out untill we reach -1 again ( in order to put valid paranthesis value in stack)\\n![image](https://assets.leetcode.com/users/images/d882a64b-d40c-4371-be17-7bb5bf13aabd_1653543491.691877.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                st.push(-1);        \\n            }else{\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    ans=0;\\n                    while(st.top()!=-1){\\n                        ans+=st.top();\\n                        st.pop();\\n                    }\\n                    \\n                    st.pop();\\n                    \\n                    ans*=2;\\n                    st.push(ans);\\n                }\\n            }\\n            \\n        }\\n        \\n        ans=0;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                st.push(-1);        \\n            }else{\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    ans=0;\\n                    while(st.top()!=-1){\\n                        ans+=st.top();\\n                        st.pop();\\n                    }\\n                    \\n                    st.pop();\\n                    \\n                    ans*=2;\\n                    st.push(ans);\\n                }\\n            }\\n            \\n        }\\n        \\n        ans=0;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071648,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if i == \"(\":\\n                stack.append(i)\\n                \\n            #checking for this ()\\n            elif stack[-1] == \"(\" and i == \")\":\\n                stack.pop()\\n                stack.append(1)\\n                \\n            else:\\n                \\n                #until did not found open parentheses adding the numbers\\n                count = 0\\n                while stack[-1] != \"(\":\\n                    count += stack.pop()\\n                if(stack[-1] == \"(\"):\\n                    stack.pop()\\n                    stack.append(count*2)\\n        return sum(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if i == \"(\":\\n                stack.append(i)\\n                \\n            #checking for this ()\\n            elif stack[-1] == \"(\" and i == \")\":\\n                stack.pop()\\n                stack.append(1)\\n                \\n            else:\\n                \\n                #until did not found open parentheses adding the numbers\\n                count = 0\\n                while stack[-1] != \"(\":\\n                    count += stack.pop()\\n                if(stack[-1] == \"(\"):\\n                    stack.pop()\\n                    stack.append(count*2)\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870460,
                "title": "java-0ms-submission-with-o-1-space",
                "content": "Basically when you open a bracket, you times the base with 2, when you close the bracket, you devided by 2. You only settle up the score when you meet a `()` i.e. (when `s.charAt(i) == \\')\\' && s.charAt(i-1) == \\'(\\'`.\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int res = 0, base = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                base *= 2;\\n            }\\n            else {\\n                base /= 2;\\n                if (s.charAt(i-1) == \\'(\\') {\\n                    res += base;\\n                }   \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int res = 0, base = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                base *= 2;\\n            }\\n            else {\\n                base /= 2;\\n                if (s.charAt(i-1) == \\'(\\') {\\n                    res += base;\\n                }   \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861572,
                "title": "c-clear-solution-o-n-time-o-1-space",
                "content": "```\\n\\tpublic int ScoreOfParentheses(string s) {\\n\\t\\tvar result = 0;\\n        var level = 0;\\n        for (int i=0; i<s.Length; i++) {\\n            if (s[i] == \\'(\\')\\n                level++;\\n            if (s[i] == \\')\\') {\\n                level--;\\n                result += s[i-1] == \\'(\\' ? 1 << level : 0;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int ScoreOfParentheses(string s) {\\n\\t\\tvar result = 0;\\n        var level = 0;\\n        for (int i=0; i<s.Length; i++) {\\n            if (s[i] == \\'(\\')\\n                level++;\\n            if (s[i] == \\')\\') {\\n                level--;\\n                result += s[i-1] == \\'(\\' ? 1 << level : 0;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1859699,
                "title": "easy-cpp-based-solution-0ms",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        stack<int>s1;\\n        int n=0;\\n        int sum=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                s1.push(sum);\\n                sum=0;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                sum=s1.top() + max(2*sum,1);\\n                s1.pop();\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        stack<int>s1;\\n        int n=0;\\n        int sum=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                s1.push(sum);\\n                sum=0;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                sum=s1.top() + max(2*sum,1);\\n                s1.pop();\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1859042,
                "title": "rust-0ms-2mb",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Score of Parentheses.\\nMemory Usage: 2 MB, less than 100.00% of Rust online submissions for Score of Parentheses.\\n\\n```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut stack = vec![0];\\n        for ch in s.chars() { \\n            match ch  { \\n                \\'(\\' => stack.push(0),\\n                _ => { \\n                    let v = stack.pop().unwrap();\\n                    *stack.last_mut().unwrap() += i32::max(2 * v, 1)\\n                }\\n            }\\n        }\\n        stack.pop().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut stack = vec![0];\\n        for ch in s.chars() { \\n            match ch  { \\n                \\'(\\' => stack.push(0),\\n                _ => { \\n                    let v = stack.pop().unwrap();\\n                    *stack.last_mut().unwrap() += i32::max(2 * v, 1)\\n                }\\n            }\\n        }\\n        stack.pop().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858745,
                "title": "python-o-n-approach-stack-simple-and-easy",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack, ans = [0], 0\\n        for i in range(len(s)):\\n            if s[i] == \\')\\':\\n                curr = stack.pop()\\n                if curr == 0: ans = 1\\n                else: ans = 2*curr\\n                stack[-1] += ans\\n            else:\\n                stack.append(0)\\n        return stack[0]\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack, ans = [0], 0\\n        for i in range(len(s)):\\n            if s[i] == \\')\\':\\n                curr = stack.pop()\\n                if curr == 0: ans = 1\\n                else: ans = 2*curr\\n                stack[-1] += ans\\n            else:\\n                stack.append(0)\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858447,
                "title": "this-easy-code-is-not-mentioned-anywhere",
                "content": "Just push the character until you are getting \\'(\\' and when you iterator pointing to the closing braces \\')\\', then you have to check the stack size, if the stack size is 1, then ans++. Why.? For this type of cases \\'()\\', If stack size is greater than 1, than you just need to add the power of 2 raise to the stack.size()-1. \\nYou get the answer....!!!\\nTime Complexity - O(n)\\nSpace Complexity - O(n)\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        stack<char> st;\\n        int i = 0;\\n        int n = s.length();\\n        \\n        while(i<n){\\n            while(i <n && s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            if(st.size() > 1){\\n                int sz = st.size();\\n                sz--;\\n                ans += (int)(pow(2, sz) + 1e-9);\\n            }\\n            else if(st.size() == 1){\\n                ans++;\\n            }\\n            while(i<n && s[i] == \\')\\'){\\n                st.pop();\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        stack<char> st;\\n        int i = 0;\\n        int n = s.length();\\n        \\n        while(i<n){\\n            while(i <n && s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            if(st.size() > 1){\\n                int sz = st.size();\\n                sz--;\\n                ans += (int)(pow(2, sz) + 1e-9);\\n            }\\n            else if(st.size() == 1){\\n                ans++;\\n            }\\n            while(i<n && s[i] == \\')\\'){\\n                st.pop();\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858440,
                "title": "both-s-n-s-1-easiest-way-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    // O(N) && S(N)  \\n//     int scoreOfParentheses(string str) {\\n//         int ans=0;\\n//         stack<int> s;\\n//         for(auto it:str)\\n//             if(it==\\'(\\')\\n//                 s.push(ans),ans=0;\\n//             else\\n//                 ans=s.top()+max(2*ans,1),s.pop();\\n            \\n\\n//         return ans;\\n//     }\\n    \\n    //O(N) && S(1)\\n    int scoreOfParentheses(string str) {\\n        int ans=0;\\n        int score=1;\\n        int f=1;\\n        for(auto it:str)\\n            if(it==\\'(\\')\\n                score*=2,f=1;\\n            else{\\n                score/=2;\\n                if(f){\\n                    f=0;\\n                    ans+=score;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(N) && S(N)  \\n//     int scoreOfParentheses(string str) {\\n//         int ans=0;\\n//         stack<int> s;\\n//         for(auto it:str)\\n//             if(it==\\'(\\')\\n//                 s.push(ans),ans=0;\\n//             else\\n//                 ans=s.top()+max(2*ans,1),s.pop();\\n            \\n\\n//         return ans;\\n//     }\\n    \\n    //O(N) && S(1)\\n    int scoreOfParentheses(string str) {\\n        int ans=0;\\n        int score=1;\\n        int f=1;\\n        for(auto it:str)\\n            if(it==\\'(\\')\\n                score*=2,f=1;\\n            else{\\n                score/=2;\\n                if(f){\\n                    f=0;\\n                    ans+=score;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858355,
                "title": "c-solution-0ms-time-using-stack-brief-explanation",
                "content": "Here\\'s my C++ Solution using Stack ( 0ms time taken, 100% faster )-\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        stack<int> st;\\n        \\n        /* An Extra value to get final answer starting as 0 */\\n        st.push(0);\\n\\n        for(auto it:s){\\n            /* Simply add 0 in cases of opening braces */\\n            if(it==\\'(\\'){\\n                st.push(0);\\n            }\\n            \\n            /* start manipulating values when getting closing braces */\\n            else{\\n                /* Got the top of the Stack and removed it*/\\n                int k = st.top();\\n                st.pop();\\n                \\n                /* If the top was storing 0 that indicates this was first pair of opening and closing   braces, In this case just increase value by 1 */\\n                if(k== 0) k = k=1;\\n                \\n                /* If the value of top was greater than 0 that indicates inner pairs of so we\\'ll increase value by 2 */\\n                else k *= 2;\\n                \\n                /* This value will be added to the next top element to contribute in final answer */\\n                st.top()+=k;\\n            }\\n            \\n        }\\n       \\n        // Our extra 0 stored in the starting now actually contains the final answer\\n        return st.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        stack<int> st;\\n        \\n        /* An Extra value to get final answer starting as 0 */\\n        st.push(0);\\n\\n        for(auto it:s){\\n            /* Simply add 0 in cases of opening braces */\\n            if(it==\\'(\\'){\\n                st.push(0);\\n            }\\n            \\n            /* start manipulating values when getting closing braces */\\n            else{\\n                /* Got the top of the Stack and removed it*/\\n                int k = st.top();\\n                st.pop();\\n                \\n                /* If the top was storing 0 that indicates this was first pair of opening and closing   braces, In this case just increase value by 1 */\\n                if(k== 0) k = k=1;\\n                \\n                /* If the value of top was greater than 0 that indicates inner pairs of so we\\'ll increase value by 2 */\\n                else k *= 2;\\n                \\n                /* This value will be added to the next top element to contribute in final answer */\\n                st.top()+=k;\\n            }\\n            \\n        }\\n       \\n        // Our extra 0 stored in the starting now actually contains the final answer\\n        return st.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858298,
                "title": "c-faster-than-100-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        vector<int> dp(26,0);\\n        for(int i=0;i<s.length();i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(\\'(\\');\\n            } else {\\n                int idx = st.size();\\n                if(dp[idx] == 0)\\n                    dp[idx-1] += 1;\\n                else {\\n                    dp[idx-1] += 2*dp[idx];\\n                    dp[idx] = 0;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        vector<int> dp(26,0);\\n        for(int i=0;i<s.length();i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(\\'(\\');\\n            } else {\\n                int idx = st.size();\\n                if(dp[idx] == 0)\\n                    dp[idx-1] += 1;\\n                else {\\n                    dp[idx-1] += 2*dp[idx];\\n                    dp[idx] = 0;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858222,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n        \\n        int n = str.length();\\n        \\n        stack<int>s;\\n         \\n        for(int i=0;i<n;i++)\\n        {\\n            if(str[i]==\\'(\\')\\n            {\\n                s.push(-1);\\n            }\\n            else\\n            {\\n                if(s.top()==-1)\\n                {\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else\\n                {\\n                    int x = s.top();\\n                    s.pop();\\n                    if(!s.empty() and s.top()<0)\\n                    {\\n                        s.pop();\\n                    }\\n                    s.push(x*2);\\n                }\\n            }\\n            int y=0;\\n            while(!s.empty() and s.top()>0)\\n            {\\n               y += s.top();\\n                s.pop();\\n            }\\n            if(y)\\n                s.push(y);\\n        }\\n        return s.top();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n        \\n        int n = str.length();\\n        \\n        stack<int>s;\\n         \\n        for(int i=0;i<n;i++)\\n        {\\n            if(str[i]==\\'(\\')\\n            {\\n                s.push(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1858111,
                "title": "simple-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>stk;\\n        for(auto x:s){\\n            if(x==\\'(\\'){\\n                stk.push(-1);\\n            }else{\\n                if(stk.top()==-1){\\n                    stk.pop();\\n                    stk.push(1);\\n                }else{\\n                    int val=0;\\n                    while(stk.top()!=-1){\\n                        val+=stk.top();stk.pop();\\n                    }\\n                    stk.pop();\\n                    stk.push(2*val);\\n                }\\n            }\\n        }\\n        int val=0;\\n        while(stk.size()>0){\\n            val+=stk.top();stk.pop();\\n        }\\n        return val;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>stk;\\n        for(auto x:s){\\n            if(x==\\'(\\'){\\n                stk.push(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1858043,
                "title": "100-faster-time-o-n-space-o-n",
                "content": "***Upvote if you like it*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int res = 0;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                while(!st.empty() && st.top() != 0){\\n                    count += st.top(); // To calculate the inner brackets\\n                    st.pop();\\n                }\\n                count = max(2 * count , 1); // If () is the case\\n                st.pop();\\n                st.push(count);\\n                count = 0;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int res = 0;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                while(!st.empty() && st.top() != 0){\\n                    count += st.top(); // To calculate the inner brackets\\n                    st.pop();\\n                }\\n                count = max(2 * count , 1); // If () is the case\\n                st.pop();\\n                st.push(count);\\n                count = 0;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858004,
                "title": "runtime-0ms-o-1-space-no-stack-used-java-100-faster-self-explanatory-code",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int two = 0;\\n        int sum = 0;\\n        boolean wasOpen = true;\\n        for(int i = 0; i< s.length(); i++){\\n           char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n              if(two == 0) two = 1;\\n                else two *= 2;\\n                wasOpen = true;\\n            }\\n            else{\\n                if(wasOpen) sum += two;\\n                wasOpen = false;\\n                two = two/2;\\n            }\\n        }\\n    return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n        int two = 0;\\n        int sum = 0;\\n        boolean wasOpen = true;\\n        for(int i = 0; i< s.length(); i++){\\n           char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n              if(two == 0) two = 1;\\n                else two *= 2;\\n                wasOpen = true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1857975,
                "title": "o-1-counting-open-paranthesis",
                "content": "We just find out the number of open paranthesis. There are only two cases:\\n1. `()` (paranthesis with no content inside) will contribute to answer by +1. for eg. ()()() = 3;\\n2.  `(()....())` (paranthesis with content inside) will contribute to answer by multiplying by 2;\\nThe depth of paranthesis will decide the power of 2 and the (inner) paranthesis with no content i.e. `s[i-1] == \\'(\\'` will contribute only and the outers will decide the power of 2.\\n\\ncode:\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int opens = 0;\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            char c = s[i];\\n            if (c == \\'(\\') \\n            {\\n                opens++;\\n            } else {\\n                if (s[i-1] == \\'(\\') ans += pow(2, opens-1);  // only applied for solo and the inner ones;\\n                opens--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int opens = 0;\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            char c = s[i];\\n            if (c == \\'(\\') \\n            {\\n                opens++;\\n            } else {\\n                if (s[i-1] == \\'(\\') ans += pow(2, opens-1);  // only applied for solo and the inner ones;\\n                opens--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857925,
                "title": "easy-c-solution-o-1-space-complexity-o-n-time-complexity-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n     int st = 0, score = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st++;\\n            }\\n            else if(s[i]==\\')\\' && s[i-1]==\\'(\\'){\\n               st--;\\n                score+=1<<st;\\n            }\\n            else st--;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n     int st = 0, score = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st++;\\n            }\\n            else if(s[i]==\\')\\' && s[i-1]==\\'(\\'){\\n               st--;\\n                score+=1<<st;\\n            }\\n            else st--;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857884,
                "title": "c-no-stack-100-99-9",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        int ans = 0,two=1;\\n        for(int ind = 0;ind<s.size();ind++){\\n            if(s[ind]==\\'(\\'){\\n                two+=two;\\n            }\\n            else{\\n                two/=2;\\n                if(s[ind-1]==\\'(\\'){\\n                    ans+=two;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nWe keep track of the current depth with the \"two\" variable which we can calculate each time by doubling or halving the value.",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        int ans = 0,two=1;\\n        for(int ind = 0;ind<s.size();ind++){\\n            if(s[ind]==\\'(\\'){\\n                two+=two;\\n            }\\n            else{\\n                two/=2;\\n                if(s[ind-1]==\\'(\\'){\\n                    ans+=two;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1797276,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 1567739,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 1953309,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 1978296,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 2000809,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Number of Nice Subarrays",
        "question_content": "<p>Given an array of integers <code>nums</code> and an integer <code>k</code>. A continuous subarray is called <strong>nice</strong> if there are <code>k</code> odd numbers on it.</p>\r\n\r\n<p>Return <em>the number of <strong>nice</strong> sub-arrays</em>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,2,1,1], k = 3\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [2,4,6], k = 1\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong> There is no odd numbers in the array.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [2,2,2,1,2,2,1,2,2,2], k = 2\r\n<strong>Output:</strong> 16\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= nums.length &lt;= 50000</code></li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>\r\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 419378,
                "title": "java-c-python-sliding-window-o-1-space",
                "content": "# **Solution 1: atMost**\\nHave you read this? [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\nExactly `K` times = at most `K` times - at most `K - 1` times\\n<br>\\n\\n# **Complexity**\\nTime `O(N)` for one pass\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numberOfSubarrays(int[] A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n\\n    public int atMost(int[] A, int k) {\\n        int res = 0, i = 0, n = A.length;\\n        for (int j = 0; j < n; j++) {\\n            k -= A[j] % 2;\\n            while (k < 0)\\n                k += A[i++] % 2;\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n\\n    int atMost(vector<int>& A, int k) {\\n        int res = 0, i = 0, n = A.size();\\n        for (int j = 0; j < n; j++) {\\n            k -= A[j] % 2;\\n            while (k < 0)\\n                k += A[i++] % 2;\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def numberOfSubarrays(self, A, k):\\n        def atMost(k):\\n            res = i = 0\\n            for j in xrange(len(A)):\\n                k -= A[j] % 2\\n                while k < 0:\\n                    k += A[i] % 2\\n                    i += 1\\n                res += j - i + 1\\n            return res\\n\\n        return atMost(k) - atMost(k - 1)\\n```\\n<br><br>\\n\\n# Solution II: One pass\\n\\nActually it\\'s same as three pointers.\\nThough we use `count` to count the number of even numebers.\\nInsprired by @yannlecun.\\n\\nTime `O(N)` for one pass\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numberOfSubarrays(int[] A, int k) {\\n        int res = 0, i = 0, count = 0, n = A.length;\\n        for (int j = 0; j < n; j++) {\\n            if (A[j] % 2 == 1) {\\n                --k;\\n                count = 0;\\n            }\\n            while (k == 0) {\\n                k += A[i++] & 1;\\n                ++count;\\n            }\\n            res += count;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int res = 0, i = 0, count = 0, n = A.size();\\n        for (int j = 0; j < n; j++) {\\n            if (A[j] & 1)\\n                --k, count = 0;\\n            while (k == 0)\\n                k += A[i++] & 1, ++count;\\n            res += count;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def numberOfSubarrays(self, A, k):\\n        i = count = res = 0\\n        for j in xrange(len(A)):\\n            if A[j] & 1:\\n                k -= 1\\n                count = 0\\n            while k == 0:\\n                k += A[i] & 1\\n                i += 1\\n                count += 1\\n            res += count\\n        return res\\n```\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int numberOfSubarrays(int[] A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n\\n    public int atMost(int[] A, int k) {\\n        int res = 0, i = 0, n = A.length;\\n        for (int j = 0; j < n; j++) {\\n            k -= A[j] % 2;\\n            while (k < 0)\\n                k += A[i++] % 2;\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n\\n    int atMost(vector<int>& A, int k) {\\n        int res = 0, i = 0, n = A.size();\\n        for (int j = 0; j < n; j++) {\\n            k -= A[j] % 2;\\n            while (k < 0)\\n                k += A[i++] % 2;\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def numberOfSubarrays(self, A, k):\\n        def atMost(k):\\n            res = i = 0\\n            for j in xrange(len(A)):\\n                k -= A[j] % 2\\n                while k < 0:\\n                    k += A[i] % 2\\n                    i += 1\\n                res += j - i + 1\\n            return res\\n\\n        return atMost(k) - atMost(k - 1)\\n```\n```java\\n    public int numberOfSubarrays(int[] A, int k) {\\n        int res = 0, i = 0, count = 0, n = A.length;\\n        for (int j = 0; j < n; j++) {\\n            if (A[j] % 2 == 1) {\\n                --k;\\n                count = 0;\\n            }\\n            while (k == 0) {\\n                k += A[i++] & 1;\\n                ++count;\\n            }\\n            res += count;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int res = 0, i = 0, count = 0, n = A.size();\\n        for (int j = 0; j < n; j++) {\\n            if (A[j] & 1)\\n                --k, count = 0;\\n            while (k == 0)\\n                k += A[i++] & 1, ++count;\\n            res += count;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def numberOfSubarrays(self, A, k):\\n        i = count = res = 0\\n        for j in xrange(len(A)):\\n            if A[j] & 1:\\n                k -= 1\\n                count = 0\\n            while k == 0:\\n                k += A[i] & 1\\n                i += 1\\n                count += 1\\n            res += count\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 508217,
                "title": "c-visual-explanation-o-1-space-two-pointers",
                "content": "##### Algorithm\\nThe best way to explain this approach is to look at the example:\\nLet\\'s say **k = 2** and we have the following array:\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1582094442.png)\\n\\nWe only going to work with numbers `1` and `2` because we are only interested in if number is odd or even, we don\\'t care what the actual value is.\\n1. Using `i` iterate over the array counting **only odd** numbers:\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1582094637.png)\\n\\n2. When **odd** is equal to **k**, we can analyse our **left part** and count how many subarrays with **odd == k** we can produce.\\nWe are doing it with `j` iterating until we get to **odd number**.\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1582094795.png)\\n\\nWe can see that there are `3` subarrays we can produce with **odd == k**.\\n\\n3. Continue with `i` again. Since **odd >= k** then every next **even number** we meet is going to **double previous count**. Let\\'s see:\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1582095218.png)\\n\\n4. When we meet **odd number** again we need to reset `count=1` and repeat step (2) with `j` again. In our example there\\'s going to be only one subarray:\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1582095418.png)\\n\\n5. And finish with counting last **even number** as in step (3).\\n\\nSince we are reseting `count` variable to 0, we are adding sum of all subarrays in `total` variable.\\n\\n##### Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int j = 0, odd = 0, count = 0, total = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] & 1) {\\n                odd++;\\n                if (odd >= k) {\\n                    count = 1;\\n                    while (!(nums[j++] & 1)) count++;\\n                    total += count;\\n                }\\n            } else if (odd >= k) total += count;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int j = 0, odd = 0, count = 0, total = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] & 1) {\\n                odd++;\\n                if (odd >= k) {\\n                    count = 1;\\n                    while (!(nums[j++] & 1)) count++;\\n                    total += count;\\n                }\\n            } else if (odd >= k) total += count;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419545,
                "title": "deque-with-picture",
                "content": "#### Intuition\\nThis is similar to [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C%2B%2BJava-with-picture-prefixed-sliding-window).\\n\\nWhen we find `k` odd numbers, we have one nice subarray, plus an additional subarray for each even number preceding the first odd number. This is also true for each even number that follows.\\n\\nFor example, in the picture below we found `k == 2` odd numbers at index `4`. We have 3 nice subarrays therefore: `[2, 4], [1, 4], [0, 4]`. For even number at index `5`, we also have 3 nice subarrays: `[2, 5], [1, 5], [0, 5]`. Plus 3 subarrays for index `6`.\\n\\nWhen we encounter `k + 1` odd number at index `7`, we need to get rid of the first odd number (at index `2`) to have exactly `k` odd numbers. So, we count nice subarrays as if the array starts at index `3`. \\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1572762880.png)\\n\\n#### Approach 1: Deque\\nWe do not have to use `deque`, but it makes tracking the window easier (comparing to moving pointers). Note that in Java, the deque interface does not provide a random access, so we\\'ll just use `LinkedList` instead.\\n\\n**Java**\\n```java\\npublic int numberOfSubarrays(int[] nums, int k) {\\n  LinkedList<Integer> deq = new LinkedList();\\n  deq.add(-1);\\n  int res = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    if (nums[i] % 2 == 1) \\n        deq.add(i);\\n    if (deq.size() > k + 1) \\n        deq.pop();\\n    if (deq.size() == k + 1) \\n        res += deq.get(1) - deq.get(0);\\n  }\\n  return res;\\n}\\n```\\n**C++**\\n```cpp\\nint numberOfSubarrays(vector<int>& nums, int k, int res = 0) {\\n  deque<int> deq = { -1 };\\n  for (int i = 0; i < nums.size(); ++i) {\\n    if (nums[i] % 2)\\n        deq.push_back(i);\\n    if (deq.size() > k + 1)\\n        deq.pop_front();\\n    if (deq.size() == k + 1)\\n        res += deq[1] - deq[0];\\n  }\\n  return res;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n).\\n- Memory: O(k) for the deque.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int numberOfSubarrays(int[] nums, int k) {\\n  LinkedList<Integer> deq = new LinkedList();\\n  deq.add(-1);\\n  int res = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    if (nums[i] % 2 == 1) \\n        deq.add(i);\\n    if (deq.size() > k + 1) \\n        deq.pop();\\n    if (deq.size() == k + 1) \\n        res += deq.get(1) - deq.get(0);\\n  }\\n  return res;\\n}\\n```\n```cpp\\nint numberOfSubarrays(vector<int>& nums, int k, int res = 0) {\\n  deque<int> deq = { -1 };\\n  for (int i = 0; i < nums.size(); ++i) {\\n    if (nums[i] % 2)\\n        deq.push_back(i);\\n    if (deq.size() > k + 1)\\n        deq.pop_front();\\n    if (deq.size() == k + 1)\\n        res += deq[1] - deq[0];\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419483,
                "title": "subarray-sum-equals-k",
                "content": "If you transform the input array into binary, then the problem becomes the \\'Subarray Sum Equals K\\' problem. You can think of k odd numbers means sum of then is k.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        const int n = nums.size();\\n        int rst = 0;\\n        int acc = 0;\\n        m[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            acc += (nums[i]%2);\\n            rst += m[acc-k];\\n            m[acc]++;\\n        }\\n        return rst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        const int n = nums.size();\\n        int rst = 0;\\n        int acc = 0;\\n        m[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            acc += (nums[i]%2);\\n            rst += m[acc-k];\\n            m[acc]++;\\n        }\\n        return rst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419502,
                "title": "java-prefixsum-1pass-10line-7ms",
                "content": "At index i, if current odd numbers from the beginning is M,\\nand we checked there was N previous index with (M - K) oddnum, then we got N subarrays\\nres += N\\n\\n\\n```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cur = 0, ans = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        for (int i = 0; i < nums.length; i++) {\\n            cur += nums[i] % 2 == 1 ? 1 : 0;\\n            map.put(cur, map.getOrDefault(cur, 0) + 1);\\n            ans += map.getOrDefault(cur - k, 0);\\n        }\\n        return ans;\\n    }\\n```\\n\\nArray version 7ms, faster then sliding window\\n```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cur = 0, ans = 0;\\n        int[] visited = new int[nums.length + 1];\\n        visited[0] = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            cur += nums[i] % 2 == 1 ? 1 : 0;\\n            visited[cur] += 1;\\n            ans += cur >= k ? visited[cur - k] : 0;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cur = 0, ans = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        for (int i = 0; i < nums.length; i++) {\\n            cur += nums[i] % 2 == 1 ? 1 : 0;\\n            map.put(cur, map.getOrDefault(cur, 0) + 1);\\n            ans += map.getOrDefault(cur - k, 0);\\n        }\\n        return ans;\\n    }\\n```\n```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cur = 0, ans = 0;\\n        int[] visited = new int[nums.length + 1];\\n        visited[0] = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            cur += nums[i] % 2 == 1 ? 1 : 0;\\n            visited[cur] += 1;\\n            ans += cur >= k ? visited[cur - k] : 0;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419321,
                "title": "java-python-3-1-pass-sliding-window-o-n-time-o-1-space-w-brief-explanation",
                "content": "1. Whenever the count of odd numbers reach `k`, for each high boundary of the sliding window, we have `indexOfLeftMostOddInWin - lowBound` options for the low boundary, where `indexOfLeftMostOddInWin` is the index of the leftmost odd number within the window, and `lowBound` is the index of the low boundary exclusively;\\n2. Whenever the count of odd numbers more than `k`, shrink the low boundary so that the count back to `k`;\\n```java\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int ans = 0, indexOfLeftMostOddInWin = 0, lowBound = -1;\\n        for (int num : nums) {\\n            k -= num % 2;\\n            if (nums[indexOfLeftMostOddInWin] % 2 == 0) // move to the index of first odd.\\n                ++indexOfLeftMostOddInWin;\\n            if (k < 0) { // more than k odds in window, need to shrink from low bound.\\n                lowBound = indexOfLeftMostOddInWin; // update the low bound value.\\n            }\\n            while (k < 0) {\\n                k += nums[++indexOfLeftMostOddInWin] % 2; // move to the index of next odd.\\n            }\\n            if (k == 0) { // accumulated k odd numbers in window.\\n                ans += indexOfLeftMostOddInWin - lowBound; // update result.\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        low_bound, index_of_left_most_odd_in_win, ans = -1, 0, 0\\n        for num in nums:\\n            k -= num % 2\\n            if nums[index_of_left_most_odd_in_win] % 2 == 0:\\n                index_of_left_most_odd_in_win += 1\\n            if k < 0:\\n                low_bound = index_of_left_most_odd_in_win\\n            while k < 0:    \\n                index_of_left_most_odd_in_win += 1\\n                k += nums[index_of_left_most_odd_in_win] % 2\\n            if k == 0:\\n                ans += index_of_left_most_odd_in_win - low_bound\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int ans = 0, indexOfLeftMostOddInWin = 0, lowBound = -1;\\n        for (int num : nums) {\\n            k -= num % 2;\\n            if (nums[indexOfLeftMostOddInWin] % 2 == 0) // move to the index of first odd.\\n                ++indexOfLeftMostOddInWin;\\n            if (k < 0) { // more than k odds in window, need to shrink from low bound.\\n                lowBound = indexOfLeftMostOddInWin; // update the low bound value.\\n            }\\n            while (k < 0) {\\n                k += nums[++indexOfLeftMostOddInWin] % 2; // move to the index of next odd.\\n            }\\n            if (k == 0) { // accumulated k odd numbers in window.\\n                ans += indexOfLeftMostOddInWin - lowBound; // update result.\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        low_bound, index_of_left_most_odd_in_win, ans = -1, 0, 0\\n        for num in nums:\\n            k -= num % 2\\n            if nums[index_of_left_most_odd_in_win] % 2 == 0:\\n                index_of_left_most_odd_in_win += 1\\n            if k < 0:\\n                low_bound = index_of_left_most_odd_in_win\\n            while k < 0:    \\n                index_of_left_most_odd_in_win += 1\\n                k += nums[index_of_left_most_odd_in_win] % 2\\n            if k == 0:\\n                ans += index_of_left_most_odd_in_win - low_bound\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1265615,
                "title": "python-two-pointer",
                "content": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        right ,left = 0,0\\n        ans = 0 \\n        odd_cnt = 0\\n        ans = 0\\n        cur_sub_cnt = 0\\n        for right in range(len(nums)):\\n            \\n            if nums[right]%2 == 1:\\n                odd_cnt += 1\\n                cur_sub_cnt = 0\\n                \\n            while odd_cnt == k:\\n                if nums[left]%2 == 1:\\n                    odd_cnt -= 1\\n                cur_sub_cnt += 1\\n                left += 1\\n                \\n            ans += cur_sub_cnt\\n            \\n        return ans  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        right ,left = 0,0\\n        ans = 0 \\n        odd_cnt = 0\\n        ans = 0\\n        cur_sub_cnt = 0\\n        for right in range(len(nums)):\\n            \\n            if nums[right]%2 == 1:\\n                odd_cnt += 1\\n                cur_sub_cnt = 0\\n                \\n            while odd_cnt == k:\\n                if nums[left]%2 == 1:\\n                    odd_cnt -= 1\\n                cur_sub_cnt += 1\\n                left += 1\\n                \\n            ans += cur_sub_cnt\\n            \\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 419992,
                "title": "easy-peasy-python-solution-with-explanation",
                "content": "\\t# Just keep count of the current odd number.\\n\\t# Look in the dictionary if we can find (currendOds - k), \\n\\t# if it exisits that means I can get an subarray with k odds.\\n\\t# Also keep count of number of different types of odds too,\\n\\t# because for K =1 , [2,2,1] is a valid list, so does, [2,1] and [1].\\n\\t\\n        def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tdic = { 0: 1 }\\n\\t\\t\\tcnt = res = 0\\n\\t\\t\\tfor idx, num in enumerate(nums):\\n\\t\\t\\t\\tif num % 2 == 1:\\n\\t\\t\\t\\t\\tcnt += 1\\n\\n\\t\\t\\t\\tif cnt - k in dic:\\n\\t\\t\\t\\t\\tres += dic[cnt-k]\\n\\n\\t\\t\\t\\tdic[cnt] = dic.get(cnt, 0) + 1\\n\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# Just keep count of the current odd number.\\n\\t# Look in the dictionary if we can find (currendOds - k), \\n\\t# if it exisits that means I can get an subarray with k odds.\\n\\t# Also keep count of number of different types of odds too,\\n\\t# because for K =1 , [2,2,1] is a valid list, so does, [2,1] and [1].\\n\\t\\n        def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tdic = { 0: 1 }\\n\\t\\t\\tcnt = res = 0\\n\\t\\t\\tfor idx, num in enumerate(nums):\\n\\t\\t\\t\\tif num % 2 == 1:\\n\\t\\t\\t\\t\\tcnt += 1\\n\\n\\t\\t\\t\\tif cnt - k in dic:\\n\\t\\t\\t\\t\\tres += dic[cnt-k]\\n\\n\\t\\t\\t\\tdic[cnt] = dic.get(cnt, 0) + 1\\n\\n\\t\\t\\treturn res",
                "codeTag": "Python3"
            },
            {
                "id": 1315238,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int oddcount=0;\\n        int res=0;\\n        int i=0;\\n        int count=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]%2==1){\\n                oddcount++;\\n                count=0;\\n            }\\n            while(oddcount==k){\\n                if(nums[i++]%2==1) oddcount--;\\n                count++;\\n            }\\n            res+=count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int oddcount=0;\\n        int res=0;\\n        int i=0;\\n        int count=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]%2==1){\\n                oddcount++;\\n                count=0;\\n            }\\n            while(oddcount==k){\\n                if(nums[i++]%2==1) oddcount--;\\n                count++;\\n            }\\n            res+=count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478035,
                "title": "c-two-pointers-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0,odd = 0,cnt = 0;\\n        int l = 0,r = 0;\\n        while(r<n)\\n        {\\n            if(nums[r]%2 != 0)\\n            {\\n                odd++;\\n                cnt = 0;\\n            }\\n            while(odd == k)\\n            {\\n                ++cnt;\\n                odd -= nums[l++]&1; \\n            }\\n            ans += cnt;\\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# If you find my solution useful , then kindly upvote it.",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0,odd = 0,cnt = 0;\\n        int l = 0,r = 0;\\n        while(r<n)\\n        {\\n            if(nums[r]%2 != 0)\\n            {\\n                odd++;\\n                cnt = 0;\\n            }\\n            while(odd == k)\\n            {\\n                ++cnt;\\n                odd -= nums[l++]&1; \\n            }\\n            ans += cnt;\\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824621,
                "title": "c-sliding-window-solution-o-1-space",
                "content": "Similar to https://leetcode.com/problems/subarrays-with-k-different-integers/\\n```\\npublic:\\n    int numarr(vector<int>&nums,int k){\\n        int ans=0;\\n        int count=0;\\n        int i=0,j=0,n=nums.size();\\n        while(j<n){\\n            if(nums[j]%2==1){\\n                count++;\\n            }\\n            if(count>k){\\n                while(i<=j && count>k){\\n                    if(nums[i]%2==1){\\n                        count--;\\n                    }\\n                    i++;\\n                }\\n            }\\n            ans+=(j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return numarr(nums,k)-numarr(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int numarr(vector<int>&nums,int k){\\n        int ans=0;\\n        int count=0;\\n        int i=0,j=0,n=nums.size();\\n        while(j<n){\\n            if(nums[j]%2==1){\\n                count++;\\n            }\\n            if(count>k){\\n                while(i<=j && count>k){\\n                    if(nums[i]%2==1){\\n                        count--;\\n                    }\\n                    i++;\\n                }\\n            }\\n            ans+=(j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return numarr(nums,k)-numarr(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560994,
                "title": "c-3-approaches-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        int result=0;\\n        int first_occur=0;\\n        vector<int>occur(nums.size(),0);\\n        int index=0;\\n        int current=0;\\n        // Variable window size problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            if(nums[j]%2!=0)\\n            {count++;\\n             occur[index++]=j;}\\n            // Play with condition\\n            if(count<k)\\n                j++;\\n            else\\n            {\\n              while(count>k)\\n              {\\n                  // remove calculation for i\\n                  if(nums[i]%2!=0)\\n                  {count--;current++;}\\n                  i++;\\n              }\\n                \\n                // Store result\\n                result+=occur[current]+1-i;\\n                j++;\\n            }\\n            \\n            \\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // Replace all odd with 1 and even with 0\\n        for(auto &num:nums)\\n            if(num%2)\\n                num=1;\\n            else\\n                num=0;\\n        \\n        // Now find the subarray with sum at most k and k-1\\n        return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n    int atMost(vector<int>&nums,int k)\\n    {\\n        int i=0;\\n        int j=0;\\n        int result=0;\\n        int sum=0;\\n        // Variable size window problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            sum+=nums[j];\\n            \\n           \\n                while(sum>k)\\n                {\\n                    // remove calculation for i\\n                    sum-=nums[i];\\n                    i++;\\n                }\\n                // store result\\n                result+=j-i+1;\\n                j++;\\n            \\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity: O(3*n)\\nSpace Complexity: O(1)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        // Replace odd with 1 and even with 0\\n        for(auto &num:nums)\\n            if(num%2)\\n                num=1;\\n            else \\n                num=0;\\n        mp[0]=1;\\n        int sum=0;\\n        int count=0;\\n        for(auto num:nums)\\n        {\\n            sum+=num;\\n            count+=mp[sum-k];\\n            mp[sum]++;\\n        }\\n        return count;\\n    }\\n    \\n};\\n\\nTime Complexity: O(2*n)\\nSpace Complexity: O(n)\\n```\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        int result=0;\\n        int first_occur=0;\\n        vector<int>occur(nums.size(),0);\\n        int index=0;\\n        int current=0;\\n        // Variable window size problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            if(nums[j]%2!=0)\\n            {count++;\\n             occur[index++]=j;}\\n            // Play with condition\\n            if(count<k)\\n                j++;\\n            else\\n            {\\n              while(count>k)\\n              {\\n                  // remove calculation for i\\n                  if(nums[i]%2!=0)\\n                  {count--;current++;}\\n                  i++;\\n              }\\n                \\n                // Store result\\n                result+=occur[current]+1-i;\\n                j++;\\n            }\\n            \\n            \\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // Replace all odd with 1 and even with 0\\n        for(auto &num:nums)\\n            if(num%2)\\n                num=1;\\n            else\\n                num=0;\\n        \\n        // Now find the subarray with sum at most k and k-1\\n        return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n    int atMost(vector<int>&nums,int k)\\n    {\\n        int i=0;\\n        int j=0;\\n        int result=0;\\n        int sum=0;\\n        // Variable size window problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            sum+=nums[j];\\n            \\n           \\n                while(sum>k)\\n                {\\n                    // remove calculation for i\\n                    sum-=nums[i];\\n                    i++;\\n                }\\n                // store result\\n                result+=j-i+1;\\n                j++;\\n            \\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity: O(3*n)\\nSpace Complexity: O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        // Replace odd with 1 and even with 0\\n        for(auto &num:nums)\\n            if(num%2)\\n                num=1;\\n            else \\n                num=0;\\n        mp[0]=1;\\n        int sum=0;\\n        int count=0;\\n        for(auto num:nums)\\n        {\\n            sum+=num;\\n            count+=mp[sum-k];\\n            mp[sum]++;\\n        }\\n        return count;\\n    }\\n    \\n};\\n\\nTime Complexity: O(2*n)\\nSpace Complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500001,
                "title": "java-sliding-window-two-pinter",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int i=0;\\n        int j=0;\\n        int oddCount=0;\\n        int count=0;\\n        int temp=0;\\n        \\n        while(j<nums.length){\\n            if(nums[j]%2==1){\\n                oddCount++;\\n                temp=0;\\n            }\\n            while(oddCount==k){\\n                temp++;\\n                if(nums[i]%2==1){\\n                    oddCount--;\\n                }\\n                i++;\\n            }\\n            count+=temp;\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int i=0;\\n        int j=0;\\n        int oddCount=0;\\n        int count=0;\\n        int temp=0;\\n        \\n        while(j<nums.length){\\n            if(nums[j]%2==1){\\n                oddCount++;\\n                temp=0;\\n            }\\n            while(oddCount==k){\\n                temp++;\\n                if(nums[i]%2==1){\\n                    oddCount--;\\n                }\\n                i++;\\n            }\\n            count+=temp;\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600316,
                "title": "nice-subarrays-c-easy",
                "content": "//exactly similar to the problem:subarrays sum equal to given sum(k)\\n// we just need to convert odds with 1 and even with 0\\n//and find the given sub arrays having sum k\\nUPVOTE IF YOU GET:)\\n```\\nclass Solution {\\npublic:\\n    \\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int ans=0,sum=0,n=a.size();\\n        map<int,int>mp;\\n        mp[0]=1;\\n        for(int i=0;i<n;i++){\\n            sum+=a[i]%2; // converting even with 0 & odd wiht 1;\\n            if(mp.find(sum-k)!=mp.end())\\n                ans+=mp[sum-k];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int ans=0,sum=0,n=a.size();\\n        map<int,int>mp;\\n        mp[0]=1;\\n        for(int i=0;i<n;i++){\\n            sum+=a[i]%2; // converting even with 0 & odd wiht 1;\\n            if(mp.find(sum-k)!=mp.end())\\n                ans+=mp[sum-k];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331485,
                "title": "c-sliding-window-solution-probability-rule-o-n",
                "content": "Runtime: 112 ms, faster than 93.17% of C++ online submissions for Count Number of Nice Subarrays.\\nMemory Usage: 67.5 MB, less than 91.98% of C++ online submissions for Count Number of Nice Subarrays.\\n\\n```\\nInorder to solve the problem we can easily find the main subarray containing K odd numbers using Sliding\\nWindow approach. Here main subarray means the subarray which has window such as all left most values\\nof first odd number are even if possible and all right most values of last odd number are even if possible\\ncause there can be exactly K odd numbers and this main subarray will get the subarrays where all odd\\nnumbers of the window wil be present. So, we expand window in each step and shrink window if odd count >K. \\nWhen odd count == K, we have to find the main subarray and so we expand the window as long as there\\nis no new odd number. Now we need the possible subarrays from this main subarray where al odd numbers\\nwill be present. For calculating the number of such possible subarrays we can consider the subarry from the\\nfirst to last occurence of odd number as a single number X. Then we have to count the number of even\\nnumbers EL at the left of X and the number of even numbers ER at the right of X cause they will make the\\npossible subarrays from main subarray. \\nFor the current main subarray the possible subarray count = (EL +1) * (ER+1)\\n```\\n\\n```\\nThis equation comes from the Independent Probability Rule: P(AB) = P(A) * P(B)\\nFor example given array : [a,b,c,d,e] and X = c then the number of possible subarray where X exists are,\\nNo of way of taking or not taking element from the left of X = EL + 1\\nNo of way of taking or not taking element from the right of X = ER + 1\\nSo, total possible subarrays with element X = (EL + 1) * (ER + 1) cause here taking element from left and\\nright of element X in the subarray is Independent.\\nFor  [a,b,c,d,e] and X = c => Subarray count = (2+1) * (2+1) = 3\\n{a,b,c}, {b,c},{c}, {a,b,c,d},{b,c,d},{a,b,c,d,e},{b,c,d,e},{c,d},{c,d,e}\\n\\nSo using above formula we can count the total subarray from a main subarray and sum up the count of \\nall main subarrays in the given array and get the result.\\n\\nExample Input: nums = [2,2,1,2,1,2,2,1,2,2], k = 2,  Output: 15 Below is the simulation of this example\\n```\\n\\n![image](https://assets.leetcode.com/users/images/93861dec-986d-45f7-89e8-d79b938a0c7e_1626024085.1761098.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        // total number of calid subarray\\n        int res = 0;\\n        \\n        // count the odd numbers in the window\\n        int cnt = 0;\\n        \\n        // first and last pointer of sliding window\\n        int i = 0;\\n        int j = 0;\\n        while(j<n)\\n        {\\n            // update count of the odd number in window\\n            if((nums[j++]&1)==1)cnt++;            \\n            \\n            // shrink window until odd number count == k\\n            while(cnt>k)if((nums[i++]&1)==1)cnt--;      \\n            \\n            // if odd number count == k then we found our main subarray\\n            if(cnt==k)\\n            {\\n                int lc = 0, rc = 0;\\n                \\n                // shrink window from left till any odd number found\\n                // means, count number of even number at the left of first odd number in window, EL\\n                while(j<n && (nums[j]&1)==0)j++,rc++;\\n\\n                // expand window to right till any odd number found\\n                // means, count number of even number at the right of last odd number in window, ER\\n                while(i<n && (nums[i]&1)==0)i++,lc++;\\n                \\n                // based on probability formula the total possible subarray inclusing all odd numbers\\n                // of the main subarray window is (EL + 1) * (ER + 1)\\n                res+= ((lc+1) * (rc+1));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window",
                    "Probability and Statistics"
                ],
                "code": "```\\nInorder to solve the problem we can easily find the main subarray containing K odd numbers using Sliding\\nWindow approach. Here main subarray means the subarray which has window such as all left most values\\nof first odd number are even if possible and all right most values of last odd number are even if possible\\ncause there can be exactly K odd numbers and this main subarray will get the subarrays where all odd\\nnumbers of the window wil be present. So, we expand window in each step and shrink window if odd count >K. \\nWhen odd count == K, we have to find the main subarray and so we expand the window as long as there\\nis no new odd number. Now we need the possible subarrays from this main subarray where al odd numbers\\nwill be present. For calculating the number of such possible subarrays we can consider the subarry from the\\nfirst to last occurence of odd number as a single number X. Then we have to count the number of even\\nnumbers EL at the left of X and the number of even numbers ER at the right of X cause they will make the\\npossible subarrays from main subarray. \\nFor the current main subarray the possible subarray count = (EL +1) * (ER+1)\\n```\n```\\nThis equation comes from the Independent Probability Rule: P(AB) = P(A) * P(B)\\nFor example given array : [a,b,c,d,e] and X = c then the number of possible subarray where X exists are,\\nNo of way of taking or not taking element from the left of X = EL + 1\\nNo of way of taking or not taking element from the right of X = ER + 1\\nSo, total possible subarrays with element X = (EL + 1) * (ER + 1) cause here taking element from left and\\nright of element X in the subarray is Independent.\\nFor  [a,b,c,d,e] and X = c => Subarray count = (2+1) * (2+1) = 3\\n{a,b,c}, {b,c},{c}, {a,b,c,d},{b,c,d},{a,b,c,d,e},{b,c,d,e},{c,d},{c,d,e}\\n\\nSo using above formula we can count the total subarray from a main subarray and sum up the count of \\nall main subarrays in the given array and get the result.\\n\\nExample Input: nums = [2,2,1,2,1,2,2,1,2,2], k = 2,  Output: 15 Below is the simulation of this example\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        // total number of calid subarray\\n        int res = 0;\\n        \\n        // count the odd numbers in the window\\n        int cnt = 0;\\n        \\n        // first and last pointer of sliding window\\n        int i = 0;\\n        int j = 0;\\n        while(j<n)\\n        {\\n            // update count of the odd number in window\\n            if((nums[j++]&1)==1)cnt++;            \\n            \\n            // shrink window until odd number count == k\\n            while(cnt>k)if((nums[i++]&1)==1)cnt--;      \\n            \\n            // if odd number count == k then we found our main subarray\\n            if(cnt==k)\\n            {\\n                int lc = 0, rc = 0;\\n                \\n                // shrink window from left till any odd number found\\n                // means, count number of even number at the left of first odd number in window, EL\\n                while(j<n && (nums[j]&1)==0)j++,rc++;\\n\\n                // expand window to right till any odd number found\\n                // means, count number of even number at the right of last odd number in window, ER\\n                while(i<n && (nums[i]&1)==0)i++,lc++;\\n                \\n                // based on probability formula the total possible subarray inclusing all odd numbers\\n                // of the main subarray window is (EL + 1) * (ER + 1)\\n                res+= ((lc+1) * (rc+1));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832587,
                "title": "java-solution",
                "content": "Replace all odd numbers with 1 and even with zeroes\\n\\nNow the problem becomes\\n[https://leetcode.com/problems/subarray-sum-equals-k/](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\nFind number of sub arrys with sum = K\\n```\\npublic int numberOfSubarrays(int[] nums, int k) {\\n         //Replace all odd by 1 and even by 0\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = (nums[i] %2 == 0) ? 0 : 1;\\n        }\\n        \\n        //problem becomes number of subarrays with sum = k\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;//cumulative sum\\n        map.put(0,1);\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            if(map.containsKey(sum - k)){\\n                res+=map.get(sum - k);\\n            }\\n            map.put(sum,map.getOrDefault(sum,0)+1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numberOfSubarrays(int[] nums, int k) {\\n         //Replace all odd by 1 and even by 0\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = (nums[i] %2 == 0) ? 0 : 1;\\n        }\\n        \\n        //problem becomes number of subarrays with sum = k\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;//cumulative sum\\n        map.put(0,1);\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            if(map.containsKey(sum - k)){\\n                res+=map.get(sum - k);\\n            }\\n            map.put(sum,map.getOrDefault(sum,0)+1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419362,
                "title": "python-solution-prefix-sum",
                "content": "```\\ndef numberOfSubarrays(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        count = 0\\n        prefix = {}\\n        prefix[0] = 1\\n        for i in range(len(nums)):\\n            \\n            if nums[i] % 2 != 0:\\n                count += 1\\n            if count in prefix:\\n                prefix[count] += 1\\n            else: \\n                prefix[count] = 1\\n\\t\"\"\"the key of prefix represent the number of odd number untill  certain position, the value represent the number of positions\"\"\"\\n        \\n        for c in prefix:\\n            if c - k in prefix:\\n                res += prefix[c] *prefix[c - k]\\n        return res\\n ```",
                "solutionTags": [],
                "code": "```\\ndef numberOfSubarrays(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        count = 0\\n        prefix = {}\\n        prefix[0] = 1\\n        for i in range(len(nums)):\\n            \\n            if nums[i] % 2 != 0:\\n                count += 1\\n            if count in prefix:\\n                prefix[count] += 1\\n            else: \\n                prefix[count] = 1\\n\\t\"\"\"the key of prefix represent the number of odd number untill  certain position, the value represent the number of positions\"\"\"\\n        \\n        for c in prefix:\\n            if c - k in prefix:\\n                res += prefix[c] *prefix[c - k]\\n        return res\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 3405192,
                "title": "c-sliding-window-with-explaination-easy-to-understand",
                "content": "# Intuition:\\r\\nThe problem requires finding the number of subarrays having exactly k odd integers. We can solve the problem using sliding window technique where we maintain a window of contiguous subarray and slide it from left to right. While sliding the window, we keep track of the number of odd integers inside the window and count the number of subarrays having exactly k odd integers.\\r\\n\\r\\n# Approach:\\r\\nWe initialize two pointers, start and end, to the first element of the array. We also initialize count to zero and ans to zero. We then traverse the array using the end pointer and for each element, we increment count if it is odd. We then slide the window to the right until count becomes equal to k. At each step, we update ans with the number of subarrays having exactly k odd integers. Finally, we return ans.\\r\\n\\r\\nTo find the number of subarrays having exactly k odd integers, we subtract the number of subarrays having less than k odd integers from the number of subarrays having at most k-1 odd integers. We can reuse the same subArray function to compute both.\\r\\n\\r\\n# Complexity:\\r\\n- Time complexity: O(n), where n is the size of the array. We traverse the array only once.\\r\\n- Space complexity: O(1), as we use constant extra space.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int subArray(vector<int>& nums, int k) {\\r\\n        int count = 0, ans = 0, start = 0, end = 0;\\r\\n        int n = nums.size();\\r\\n        while(end<n){\\r\\n            if(nums[end]%2==1){\\r\\n                count++;\\r\\n            }\\r\\n            while(count>k){\\r\\n                if(nums[start]%2==1){\\r\\n                    count--;\\r\\n                }\\r\\n                start++;\\r\\n            }\\r\\n            ans += end-start+1;\\r\\n            end++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n      return subArray(nums, k) - subArray(nums, k - 1);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int subArray(vector<int>& nums, int k) {\\r\\n        int count = 0, ans = 0, start = 0, end = 0;\\r\\n        int n = nums.size();\\r\\n        while(end<n){\\r\\n            if(nums[end]%2==1){\\r\\n                count++;\\r\\n            }\\r\\n            while(count>k){\\r\\n                if(nums[start]%2==1){\\r\\n                    count--;\\r\\n                }\\r\\n                start++;\\r\\n            }\\r\\n            ans += end-start+1;\\r\\n            end++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n      return subArray(nums, k) - subArray(nums, k - 1);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567466,
                "title": "easiest-best-code-in-c-with-explanation-hashmap",
                "content": "**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int size=nums.size(),i=0,j=0;\\n        for(auto &it:nums){\\n            if((it & 1)==0)\\n                it=0;\\n            else           //Replacing all the even nos. with 0 & odd nos. with 1 \\n                it=1;\\n        }\\n       //Now simply to get the ans we have to return the no of subarrays with sum = k\\n        unordered_map<int,int> mp;\\n        int prefixSum=0,ans=0;\\n        for(auto it:nums){\\n            prefixSum+=it;\\n            if(prefixSum==k)\\n                ans++;\\n            if(mp.find(prefixSum-k)!=mp.end())\\n                ans+=mp[prefixSum-k];\\n            mp[prefixSum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Happy LeetCoding\\uD83D\\uDCAF\\nPlease Upvote**\\uD83D\\uDE42",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int size=nums.size(),i=0,j=0;\\n        for(auto &it:nums){\\n            if((it & 1)==0)\\n                it=0;\\n            else           //Replacing all the even nos. with 0 & odd nos. with 1 \\n                it=1;\\n        }\\n       //Now simply to get the ans we have to return the no of subarrays with sum = k\\n        unordered_map<int,int> mp;\\n        int prefixSum=0,ans=0;\\n        for(auto it:nums){\\n            prefixSum+=it;\\n            if(prefixSum==k)\\n                ans++;\\n            if(mp.find(prefixSum-k)!=mp.end())\\n                ans+=mp[prefixSum-k];\\n            mp[prefixSum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768342,
                "title": "c-sliding-window-two-pointers-o-n-space",
                "content": "This question is slightly based on sliding window, however one needs proper idea of whats going on.\\nWe actually just need to maintain the condition of (Oddnumbers==k), once we get it equal.\\nTill the time our odd number count is less than k, we just simply keep updating **\"end\"**.\\nOnce our oddnum count is equal to k, we start increamenting **\"start\"**, till the time we reach an odd number(this actually gives us the number of nice subarrays till that end point, let it be **\"cnt\"**).\\nAfter this , we continue our quest till we get our (k+1)th odd number but before that each even number means that we again have cnt number of nice subarrays possible so we keep updating total.\\nOnce we get an odd number , we increament **\"start\"**, reduce oddnumber count by 2(because we do not increament end , so just reducing count by 1 would lead us to take the new odd number more than once and an infinte loop would start).\\nSo , like this the process continues.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int start=0,end=0;\\n        int count=0, total=0, cnt=0;\\n        while(end<nums.size())\\n        {\\n            if(nums[end]%2!=0)\\n                count++;\\n            if(nums[end]%2==0 && count==k)\\n               { total+=cnt;end++;continue;}\\n            if(count<k)\\n                end++;\\n            else if(count==k)\\n            {\\n             while(count==k)\\n             {\\n                 cnt++;\\n                 if(nums[start]%2==0)\\n                 {start++;continue;}\\n                 else\\n                 {break;}\\n                 \\n             }\\n                total+=cnt;\\n                \\n                end++;\\n            }\\n            else if(count>k)\\n            {\\n                start++;\\n                cnt=0;\\n                count-=2;\\n               \\n               \\n                \\n            }\\n         \\n        }\\n        return total;\\n    }\\n};\\n\\n```\\nThis is the code !!\\nPlease upvote if you find it even slightly helpful !! : )\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int start=0,end=0;\\n        int count=0, total=0, cnt=0;\\n        while(end<nums.size())\\n        {\\n            if(nums[end]%2!=0)\\n                count++;\\n            if(nums[end]%2==0 && count==k)\\n               { total+=cnt;end++;continue;}\\n            if(count<k)\\n                end++;\\n            else if(count==k)\\n            {\\n             while(count==k)\\n             {\\n                 cnt++;\\n                 if(nums[start]%2==0)\\n                 {start++;continue;}\\n                 else\\n                 {break;}\\n                 \\n             }\\n                total+=cnt;\\n                \\n                end++;\\n            }\\n            else if(count>k)\\n            {\\n                start++;\\n                cnt=0;\\n                count-=2;\\n               \\n               \\n                \\n            }\\n         \\n        }\\n        return total;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532109,
                "title": "java-picture-detail-explanation-prefix-sum-hashmap-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/27b0cd6e-ffd3-4eca-8787-6b8d0b15b43f_1634763142.2267573.png)\\n\\n* In this problem , First we will change the odd digit from 1 and even with zero in given array.\\n* then we use the same approach which we used in the leetcode problem 560. If you want detail explanation then ->\\nHere is the link of the problem \\n[https://leetcode.com/problems/subarray-sum-equals-k/discuss/1532102/java-picture-explanation-2-methods-prefix-sum-hashmap-easy-solution]\\n\\n```\\n  public int numberOfSubarrays(int[] nums, int k) {\\n   \\n     int s=0,e=nums.length;\\n   \\n    for(int i=0;i<e;i++){\\n        if(nums[i]%2!=0){\\n            nums[i]=1;\\n        }else{\\n            nums[i]=0;\\n        }\\n    }\\n      \\n       Map<Integer,Integer> p = new HashMap();\\n        \\n     p.put(0,1);   \\nint ans=0,sum=0;\\n        \\n     for(int i=0;i<nums.length;i++){\\n         sum+=nums[i];\\n        if(p.containsKey(sum-k)){\\n            ans+=p.get(sum-k);\\n        } \\n         p.put(sum,p.getOrDefault(sum,0)+1);\\n     }   \\n       return ans; \\n        \\n    }\\n```\\n\\nif you like it , then please upvote it",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n  public int numberOfSubarrays(int[] nums, int k) {\\n   \\n     int s=0,e=nums.length;\\n   \\n    for(int i=0;i<e;i++){\\n        if(nums[i]%2!=0){\\n            nums[i]=1;\\n        }else{\\n            nums[i]=0;\\n        }\\n    }\\n      \\n       Map<Integer,Integer> p = new HashMap();\\n        \\n     p.put(0,1);   \\nint ans=0,sum=0;\\n        \\n     for(int i=0;i<nums.length;i++){\\n         sum+=nums[i];\\n        if(p.containsKey(sum-k)){\\n            ans+=p.get(sum-k);\\n        } \\n         p.put(sum,p.getOrDefault(sum,0)+1);\\n     }   \\n       return ans; \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419414,
                "title": "c-o-n-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int> prefixSum(nums.size());\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if (nums[i] % 2 == 1){\\n                prefixSum[i] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            prefixSum[i] += prefixSum[i - 1];\\n        }\\n        \\n        unordered_map<int,int> map;\\n        \\n        map[0] = 1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if (prefixSum[i] - k >= 0){\\n                ans += map[prefixSum[i] - k];\\n            }\\n            map[prefixSum[i]]++;\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int> prefixSum(nums.size());\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if (nums[i] % 2 == 1){\\n                prefixSum[i] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            prefixSum[i] += prefixSum[i - 1];\\n        }\\n        \\n        unordered_map<int,int> map;\\n        \\n        map[0] = 1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if (prefixSum[i] - k >= 0){\\n                ans += map[prefixSum[i] - k];\\n            }\\n            map[prefixSum[i]]++;\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575910,
                "title": "python-2-sliding-window-solutions",
                "content": "\\n# **APPROACH 1- NOT O(1) SPACE**\\n\\nThere are some things to take care of in this problem. We cannot simply consider one window to be valid and just increment count by 1.\\n\\nConsider this ->\\n\\n\\t\\tnums = [2,2,2,1,2,2,1,2,2,2] and k = 2\\n\\t\\t\\t\\t0 1 2 3 4 5 6 7 8 9\\n\\t\\t\\nSo, if we use the sliding window approach, then we will start from index 0 and until the count of odd numbers does not become k, we will keep increasing window size. Now just by looking at the array you will see that when index is  6 then it will have two odd numbers from 0th index to 6th index.\\n\\nSo we will have a valid window with k odd numbers -\\n\\n\\t\\t\\t[2,2,2,1,2,2,1]\\n\\nBut, at this moment, we cannot simply do count += 1. Just think about it. If [2,2,2,1,2,2,1] is a valid subarray with k odd numbers, then how many subarrays of this are also valid?\\n\\n\\tThese are all valid subarrays with k odd numbers\\n\\t[2,2,2,1,2,2,1]\\n\\t[2,2,1,2,2,1]\\n\\t[2,1,2,2,1]\\n\\t[1,2,2,1]\\n\\t\\nThis means, we cannot do count += 1 only. We have to check for a particular nice subarray, how many total nice subarrays are possible.\\n\\nAnd to find that, just see above what is the smallest possible subarray. It is [1,2,2,1]. Why we were not able to get more subarrays smaller than it? Because we would\\'ve lost one odd number and that would\\'ve violated the condition of k odd numbers.\\n\\nSo this means, just see how many numbers are there between the beginning of the window and the first odd number in the window i.e., the leftmost odd number.\\n\\nFinally, we will get a general formula as \\n\\t\\n\\t\\t(index of leftmost odd number in current window - index of beginning of window) + 1\\n\\t\\t\\nSo basically, we want to keep track of not just the odd numbers but also their indices. \\n\\nAnd so I used a queue here to keep all the indices in it from left to right as we encounter odd numbers so that to calculate the count, we can simply get the first item in the queue as that will always be the leftmost odd number index of current window.\\n\\nAnd as we shrink the window, we will keep checking if the item we are removing from window is an odd number or not. If yes, that means we need to remove the leftmost item from queue as well. \\n\\n\\n```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        subarrayCount = 0\\n        \\n        i,j = 0,0\\n\\n        queue = deque()\\n        \\n\\n        while( j < len(nums) ):\\n            # If we encounter an odd number push the index of this odd number to queue\\n            if(nums[j] % 2 != 0): queue.append(j)\\n            \\n            #If the number of odd numbers in this window exceeds k, then shrink the window from left until the count of odds is not greater than k\\n            if(len(queue) > k):\\n                while(len(queue) > k):\\n                    #If the number at ith index is odd, that means we have to remove this odd number\\'s index from queue\\n                    if(nums[i] % 2 != 0): queue.popleft()\\n                    #Shrink the window from left by incrementing i\\n                    i += 1\\n            \\n            # If number of odd numbers in current window = k\\n            # Then total subarrays we can get out of this current window with k odd numbers => (leftmost odd number index - starting of window + 1)\\n            if(len(queue) == k): subarrayCount += queue[0] - i + 1\\n            \\n            #Increase window size from right side\\n            j += 1\\n            \\n        \\n        return subarrayCount\\n```\\n\\n# **APPROACH 2 - O(1) SPACE**\\nJust remember one thing for such problems where we have to find how many subarrays have \"exactly\" K something. \\n\\n\\tSubarrays with K something = Subarrays with at most K something - Subarrays with at most K-1 something\\n\\t\\nAt most K means that a subarray should have something <= K. \\n\\t\\nFor this problem, since we have to find subarrays with exactly K odd numbers. That means, \\n\\t\\n\\tSubarrays with exactly K odd numbers  = Subarrays with at most K odd numbers  - Subarrays with at most K-1 odd numbers\\n\\t\\nLet me prove it with an example.\\n\\n\\t\\tnums = [1,1,2,1,1], k = 3\\n\\t\\t\\nSo here, what are the subarrays with <= 3 odd number ? i.e., how many subarrays have at most 3 odd numbers?\\n\\n\\t[1], [1, 1], [1], [1, 1, 2], [1, 2], [2], [1, 1, 2, 1], [1, 2, 1], [2, 1], [1], [1, 2, 1, 1], [2, 1, 1], [1, 1], [1] => 14 Subarrays\\n\\nNow, lets see how many subarrays have <= 2 odd numbers i.e., <= K- 1 odd numbers\\n\\t\\n\\t[1], [1, 1], [1], [1, 1, 2], [1, 2], [2],  [1, 2, 1], [2, 1], [1], [2, 1, 1], [1, 1], [1] => 12 Subarrays\\n\\t\\nSo that means, Subarrays with exactly 3 odd numbers are => 14 - 12 => 2\\n\\nAnd to prove this, here are all the subarrays with exactly 3 odd numbers\\n\\t\\n\\t\\t[1,1,2,1] and [1,2,1,1].\\n\\t\\t\\nAnd these are the only ones that are not in the list of subarrays with <= 2 odd numbers. \\n\\nYou can use this template in many similar problems where we are asked to find how many subarrays have exactly K sum, exactly K odd numbers and so on. And there is little to no change you have to make which makes this solution so damn useful.\\n\\n```\\nclass Solution:\\n    \\n    def atMost(self, nums: List[int], k: int) -> int:\\n        \\n        countOfSubarrays = 0\\n        \\n        i,j = 0,0\\n        n = len(nums)\\n        \\n        countOfOdds = 0\\n        \\n        while j < n:\\n            if nums[j] % 2 != 0 : countOfOdds += 1\\n                \\n            if countOfOdds > k:\\n                while countOfOdds > k:\\n                    if nums[i] % 2 != 0: countOfOdds -= 1\\n                    i += 1\\n            \\n            countOfSubarrays += j - i + 1\\n            j += 1\\n        \\n        return countOfSubarrays\\n        \\n    \\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        return self.atMost(nums, k) - self.atMost(nums, k-1)\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        subarrayCount = 0\\n        \\n        i,j = 0,0\\n\\n        queue = deque()\\n        \\n\\n        while( j < len(nums) ):\\n            # If we encounter an odd number push the index of this odd number to queue\\n            if(nums[j] % 2 != 0): queue.append(j)\\n            \\n            #If the number of odd numbers in this window exceeds k, then shrink the window from left until the count of odds is not greater than k\\n            if(len(queue) > k):\\n                while(len(queue) > k):\\n                    #If the number at ith index is odd, that means we have to remove this odd number\\'s index from queue\\n                    if(nums[i] % 2 != 0): queue.popleft()\\n                    #Shrink the window from left by incrementing i\\n                    i += 1\\n            \\n            # If number of odd numbers in current window = k\\n            # Then total subarrays we can get out of this current window with k odd numbers => (leftmost odd number index - starting of window + 1)\\n            if(len(queue) == k): subarrayCount += queue[0] - i + 1\\n            \\n            #Increase window size from right side\\n            j += 1\\n            \\n        \\n        return subarrayCount\\n```\n```\\nclass Solution:\\n    \\n    def atMost(self, nums: List[int], k: int) -> int:\\n        \\n        countOfSubarrays = 0\\n        \\n        i,j = 0,0\\n        n = len(nums)\\n        \\n        countOfOdds = 0\\n        \\n        while j < n:\\n            if nums[j] % 2 != 0 : countOfOdds += 1\\n                \\n            if countOfOdds > k:\\n                while countOfOdds > k:\\n                    if nums[i] % 2 != 0: countOfOdds -= 1\\n                    i += 1\\n            \\n            countOfSubarrays += j - i + 1\\n            j += 1\\n        \\n        return countOfSubarrays\\n        \\n    \\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        return self.atMost(nums, k) - self.atMost(nums, k-1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515501,
                "title": "c-prefix-state-map-two-pointers-sliding-window",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Prefix State Map\\n\\nUse a map `m` to store the mapping from the count of odd numbers `cnt` to the first index in the array that has `cnt` numbers in front of it and including itself.\\n\\nWhen `cnt >= k`, we add `m[cnt - k + 1] - m[cnt - k]` to the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), cnt = 0, ans = 0;\\n        unordered_map<int, int> m{{0,-1}};\\n        for (int i = 0; i < N; ++i) {\\n            cnt += A[i] % 2;\\n            if (m.count(cnt) == 0) m[cnt] = i;\\n            if (cnt >= k) ans += m[cnt - k + 1] - m[cnt - k]; \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Two Pointers\\n\\nAssume the current pointer is `j` and the corresponding odd number count is `cj`, we need two pointers to get the answer.\\n\\nThe first pointer `i` is the index whose corresponding odd number count is `cj - k + 1`.\\n\\nThe second pointer `prev` is the index whose corresponding odd number count is `cj - k`.\\n\\nSo when `cj >= k`, we add `i - prev` to the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), i = 0, j = 0, prev = -1, ans = 0, ci = 0, cj = 0;\\n        while (j < N) {\\n            cj += A[j++] % 2;\\n            if (ci <= cj - k) {\\n                prev = i;\\n                while (ci <= cj - k) ci += A[i++] % 2;\\n            }\\n            if (cj >= k) ans += i - prev;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nOr use a single count.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), i = 0, j = 0, prev = -1, ans = 0, cnt = 0;\\n        while (j < N) {\\n            int c = A[j++] % 2;\\n            cnt += c;\\n            if (c && cnt >= k) {\\n                prev = i;\\n                while (A[i] % 2 == 0) ++i;\\n                ++i;\\n            }\\n            if (cnt >= k) ans += i - prev;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 3. AtMost to Equal\\n\\nCheck out \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\"\\n\\nExactly `k` times = At Most `k` times - At Most `k - 1` times.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\n// Ref: https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-O(1)-Space\\nclass Solution {\\n    int atMost(vector<int> &A, int k) {\\n        int N = A.size(), i = 0, ans = 0;\\n        for (int j = 0; j < N; ++j) {\\n            k -= A[j] % 2;\\n            while (k < 0) k += A[i++] % 2;\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), cnt = 0, ans = 0;\\n        unordered_map<int, int> m{{0,-1}};\\n        for (int i = 0; i < N; ++i) {\\n            cnt += A[i] % 2;\\n            if (m.count(cnt) == 0) m[cnt] = i;\\n            if (cnt >= k) ans += m[cnt - k + 1] - m[cnt - k]; \\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), i = 0, j = 0, prev = -1, ans = 0, ci = 0, cj = 0;\\n        while (j < N) {\\n            cj += A[j++] % 2;\\n            if (ci <= cj - k) {\\n                prev = i;\\n                while (ci <= cj - k) ci += A[i++] % 2;\\n            }\\n            if (cj >= k) ans += i - prev;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), i = 0, j = 0, prev = -1, ans = 0, cnt = 0;\\n        while (j < N) {\\n            int c = A[j++] % 2;\\n            cnt += c;\\n            if (c && cnt >= k) {\\n                prev = i;\\n                while (A[i] % 2 == 0) ++i;\\n                ++i;\\n            }\\n            if (cnt >= k) ans += i - prev;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\n// Ref: https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-O(1)-Space\\nclass Solution {\\n    int atMost(vector<int> &A, int k) {\\n        int N = A.size(), i = 0, ans = 0;\\n        for (int j = 0; j < N; ++j) {\\n            k -= A[j] % 2;\\n            while (k < 0) k += A[i++] % 2;\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619352,
                "title": "java-solution-current-problem-transformed-to-problem-560-hashmap",
                "content": "#### *Please Upvote !!!* **(\\u25E0\\u203F\\u25E0)**\\nWe traverse the whole array and put 0 in place of even elements and 1 in place of odd elements. \\nSo instead of finding k odd numbers, we now find subarrays whose sum will be equal to k (Because the odd numbers are all 1 and k odd numbers will give a sum of k now).\\n\\nThis takes us to the problem [**560. Subarray Sum Equals K**](https://leetcode.com/problems/subarray-sum-equals-k/).\\n\\nWe can put 0s and 1s in place of even and odd number by simply iterating through the array. \\n```\\nfor (int i = 0; i < nums.length; i++) {\\n\\tnums[i] = (nums[i] % 2 == 0) ? 0 : 1;\\n}\\n```\\nBut that would take an extra O(n) time complexity. \\n\\nSo we won\\'t do that. In Problem 560, we add ```nums[i]``` to ```sum``` at each iteration. So why not decide there itself whether to add 0 or 1 to sum!\\n\\nBelow is the solution, exactly similar to Problem 560.\\n```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int total = 0, sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += (nums[i] % 2 == 0) ? 0 : 1;\\n            int rem = sum - k;\\n\\n            if (map.containsKey(rem)) {\\n                total += map.get(rem);\\n            }\\n\\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n\\n        return total;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfor (int i = 0; i < nums.length; i++) {\\n\\tnums[i] = (nums[i] % 2 == 0) ? 0 : 1;\\n}\\n```\n```nums[i]```\n```sum```\n```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int total = 0, sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += (nums[i] % 2 == 0) ? 0 : 1;\\n            int rem = sum - k;\\n\\n            if (map.containsKey(rem)) {\\n                total += map.get(rem);\\n            }\\n\\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n\\n        return total;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600712,
                "title": "python-easy-prefix-sum-solution",
                "content": "Hi guys,\\n\\nHere is a simple solution using the prefix sum of an array where each element is equal to 1 if nums[i]%2==1 and 0 if nums[i]%2==0. \\n\\nWe initialize the dictionary so that we take into account the arrays with k odd numbers starting at index 0.\\n\\n\\t\\tpref=list(accumulate([0 if num%2==0 else 1 for num in nums]))\\n        dico=defaultdict(int)\\n        res=0\\n        dico[0]=1\\n        for num in pref:\\n            if num-k in dico:\\n                res+=dico[num-k]\\n            dico[num]+=1\\n        return res\\n\\t\\t\\nThen if pref[i]==j it means we have j odd numbers from index 0 to index j. Hence if j-k is in our hash table, it means that for dico[j-k] indices, we had j-k odd numbers. So between these indices and index i, we have a total k odd numbers : j-(j-k)=k.\\n\\nPlease upvote if you liked!\\n\\nCheers,\\nBerthouille",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "Hi guys,\\n\\nHere is a simple solution using the prefix sum of an array where each element is equal to 1 if nums[i]%2==1 and 0 if nums[i]%2==0. \\n\\nWe initialize the dictionary so that we take into account the arrays with k odd numbers starting at index 0.\\n\\n\\t\\tpref=list(accumulate([0 if num%2==0 else 1 for num in nums]))\\n        dico=defaultdict(int)\\n        res=0\\n        dico[0]=1\\n        for num in pref:\\n            if num-k in dico:\\n                res+=dico[num-k]\\n            dico[num]+=1\\n        return res\\n\\t\\t\\nThen if pref[i]==j it means we have j odd numbers from index 0 to index j. Hence if j-k is in our hash table, it means that for dico[j-k] indices, we had j-k odd numbers. So between these indices and index i, we have a total k odd numbers : j-(j-k)=k.\\n\\nPlease upvote if you liked!\\n\\nCheers,\\nBerthouille",
                "codeTag": "Unknown"
            },
            {
                "id": 1487672,
                "title": "c-sliding-window",
                "content": "**Exactly = atMostK(k) - atMostK(k-1)**\\n```\\nint atMostK(vector<int>& a, int k) {\\n        int i=0,count = 0,res =0;\\n        for(int j=0;j<a.size();j++){\\n            if(a[j]%2==1) count++;\\n            if(count > k){\\n                while(count>k){\\n                    if(a[i]%2==1) count--;\\n                    i++;\\n                }\\n            }\\n            res += j-i+1;\\n        }\\n        return res;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        return atMostK(a,k) - atMostK(a,k-1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint atMostK(vector<int>& a, int k) {\\n        int i=0,count = 0,res =0;\\n        for(int j=0;j<a.size();j++){\\n            if(a[j]%2==1) count++;\\n            if(count > k){\\n                while(count>k){\\n                    if(a[i]%2==1) count--;\\n                    i++;\\n                }\\n            }\\n            res += j-i+1;\\n        }\\n        return res;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        return atMostK(a,k) - atMostK(a,k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350447,
                "title": "c-two-pointer-o-n-solution",
                "content": "For finding a subarray with **exactly k odd elements = count(subarray with at most k odd elements) - count(subarray with at most k-1 odd elements)**. This solution consists of passing through the arrays twice (once for k odd elements and once for k-1 odd elements)\\n\\n```\\nclass Solution {\\n    \\n    int atMostK(vector<int> &nums, int k){\\n        \\n        int len = nums.size();\\n        int result = 0;\\n        int start = 0;\\n        int currOddCnt = 0;\\n        \\n        for(int end=0; end<len; end++){\\n            //if the current element is odd\\n            if(nums[end]&1) currOddCnt++;\\n            \\n            //if the number of odd elements in the window exceeds k -> start contarcting the window\\n            while(start<=end && currOddCnt>k){\\n                //reducing the count of odd numbers if the start of window is odd\\n                if(nums[start]&1) currOddCnt--;\\n                start++;\\n            }\\n            \\n            //number of subarrays with at most k odd elements\\n            result += end-start+1;\\n        }\\n        \\n        return result;\\n    }\\n    \\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int atMostK(vector<int> &nums, int k){\\n        \\n        int len = nums.size();\\n        int result = 0;\\n        int start = 0;\\n        int currOddCnt = 0;\\n        \\n        for(int end=0; end<len; end++){\\n            //if the current element is odd\\n            if(nums[end]&1) currOddCnt++;\\n            \\n            //if the number of odd elements in the window exceeds k -> start contarcting the window\\n            while(start<=end && currOddCnt>k){\\n                //reducing the count of odd numbers if the start of window is odd\\n                if(nums[start]&1) currOddCnt--;\\n                start++;\\n            }\\n            \\n            //number of subarrays with at most k odd elements\\n            result += end-start+1;\\n        }\\n        \\n        return result;\\n    }\\n    \\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707970,
                "title": "easy-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nConsider the window with k prime numbers, the number of evens on either side are variables, Maintain evens on left and right of every odd numbers, ans is sum of (evens on left of first number + 1 * evens on right of last number + 1). \\r\\n\\r\\n![lc.jpg](https://assets.leetcode.com/users/images/28f2ce74-3258-44e1-b592-a785dd278d4c_1688292738.8399723.jpeg)\\r\\n\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nStore the evens on left of every number in a vector and evens on the right of last element in last. Slide a window of size k , add (s[i]+1 * s[i+k]+1 ) to the sum. \\r\\n\\r\\n# Complexity\\r\\n- Time complexity:O(N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:O(N)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\nPlease upvote if you find it helpful \\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        // Vector to store the evens between odd numbers\\r\\n        vector<int> t;\\r\\n        int temp = 0, ans = 0; \\r\\n        // Store Evens between odds\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            if(nums[i]%2 == 0) temp++; \\r\\n            else {\\r\\n                t.push_back(temp); temp = 0; \\r\\n            }\\r\\n        }\\r\\n        t.push_back(temp); \\r\\n        int ind = 0; \\r\\n        //sliding window to count number of subarrays\\r\\n        while(ind + k < t.size()){ ans += (t[ind]+1) * (t[ind+k]+1); ind++; }\\r\\n\\r\\n        return ans; \\r\\n\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        // Vector to store the evens between odd numbers\\r\\n        vector<int> t;\\r\\n        int temp = 0, ans = 0; \\r\\n        // Store Evens between odds\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            if(nums[i]%2 == 0) temp++; \\r\\n            else {\\r\\n                t.push_back(temp); temp = 0; \\r\\n            }\\r\\n        }\\r\\n        t.push_back(temp); \\r\\n        int ind = 0; \\r\\n        //sliding window to count number of subarrays\\r\\n        while(ind + k < t.size()){ ans += (t[ind]+1) * (t[ind+k]+1); ind++; }\\r\\n\\r\\n        return ans; \\r\\n\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534455,
                "title": "dont-fall-into-the-two-pointer-sliding-window-trap",
                "content": "This question is a direct variation of running subarray sum. This approach is simple and highly intuitive compared to sliding window and 2 pointers.\\n\\nThe map is storing {key, val} == {num of odds in subarray, num of subarray with these many odds that have been encountered till now}\\n\\nKey insight --> The map only stores subarrays starting from the first element of the array. All the other subarrays are are taken care of using the below logic.\\n\\nSay we want to find all 2 odd num size subarrays. And now we are at a point where we have 5 odd nums with us, we want to look into the map for all the subarrays with 3 odd nums that have been encountered yet(map). This is because if we have a 5 odd num subarray and we know of previous 3 odd num subarrays. All of those 3 odd num sized subarrays when removed out of the 5 sized subarray will give us 2 odd num sized subarrays. Hence add it to result.\\n\\n----------------------\\n```\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int res = 0; int cnt = 0;\\n        unordered_map<int, int> mp; mp[0] = 1;\\n        \\n        for(auto n : nums) {\\n            \\n            if(n % 2) cnt++;\\n            res += mp[cnt - k];\\n            mp[cnt]++;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int res = 0; int cnt = 0;\\n        unordered_map<int, int> mp; mp[0] = 1;\\n        \\n        for(auto n : nums) {\\n            \\n            if(n % 2) cnt++;\\n            res += mp[cnt - k];\\n            mp[cnt]++;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232436,
                "title": "easy-commented-o-n-time-and-o-1-space-window-sliding",
                "content": "```\\nclass Solution {\\n   public:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int l = 0, r = 0, n = nums.size(), kCount = 0, count = 0, prefix = 0;\\n        while (r < n) {\\n            // increase odd count\\n            kCount += (nums[r++] & 1);\\n            if (kCount > k) {\\n                l++;\\n                kCount--;\\n                prefix = 0;\\n            }\\n\\n            // Count the number of prefix which is even because either we include them or not still we get the nice one\\n            while (l < r && (nums[l] % 2 == 0)) prefix++, l++;\\n            if (kCount == k) {\\n                count += (1 + prefix);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int l = 0, r = 0, n = nums.size(), kCount = 0, count = 0, prefix = 0;\\n        while (r < n) {\\n            // increase odd count\\n            kCount += (nums[r++] & 1);\\n            if (kCount > k) {\\n                l++;\\n                kCount--;\\n                prefix = 0;\\n            }\\n\\n            // Count the number of prefix which is even because either we include them or not still we get the nice one\\n            while (l < r && (nums[l] % 2 == 0)) prefix++, l++;\\n            if (kCount == k) {\\n                count += (1 + prefix);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776981,
                "title": "javascript-sliding-window",
                "content": "Move right pointer until odd number reach k, then count even number towards right until reach next odd number or the end, count even number towards left untill left pointer is sitting on an odd number, the product of left and right is the answer for this window, at last move left pointer and reduce odd number for 1 for next window.\\n\\n```\\nvar numberOfSubarrays = function(nums, k) {\\n    let count = 0;\\n    let odd = 0;\\n    let l = 0, r = -1;\\n    while(r < nums.length-1) {\\n        r++;\\n        if (nums[r]%2 !== 0) odd++;\\n        if (odd === k) {\\n            let right = 1;\\n            let left = 1;\\n            // move r if next element is even\\n            while(r < nums.length-1 && nums[r+1]%2 === 0) {\\n                r++;\\n                right++;\\n            }\\n            // move l if current element for l is even\\n            while(l < r && nums[l]%2 === 0) {\\n                l++;\\n                left++;\\n            }\\n            count += left*right;\\n            l++;\\n            odd--;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numberOfSubarrays = function(nums, k) {\\n    let count = 0;\\n    let odd = 0;\\n    let l = 0, r = -1;\\n    while(r < nums.length-1) {\\n        r++;\\n        if (nums[r]%2 !== 0) odd++;\\n        if (odd === k) {\\n            let right = 1;\\n            let left = 1;\\n            // move r if next element is even\\n            while(r < nums.length-1 && nums[r+1]%2 === 0) {\\n                r++;\\n                right++;\\n            }\\n            // move l if current element for l is even\\n            while(l < r && nums[l]%2 === 0) {\\n                l++;\\n                left++;\\n            }\\n            count += left*right;\\n            l++;\\n            odd--;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915838,
                "title": "java-easy-consise-o-n",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        return count(nums,k) - count(nums,k-1); \\n\\t\\t// number of subarrays with k odd integers  = number of subarrays with atmost k odd integer -  number of subarrays with atmost k-1 odd integers\\n    }\\n    public int count(int[] nums,int k){\\n        int res = 0,start = 0,end = 0, count =0;\\n        while(end < nums.length){\\n            if(nums[end] % 2 == 1) count++;\\n            while(start <= end && count > k){\\n                if(nums[start] % 2 == 1) count--;\\n                start++;\\n            }\\n            res += (end - start + 1);\\n            end++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        return count(nums,k) - count(nums,k-1); \\n\\t\\t// number of subarrays with k odd integers  = number of subarrays with atmost k odd integer -  number of subarrays with atmost k-1 odd integers\\n    }\\n    public int count(int[] nums,int k){\\n        int res = 0,start = 0,end = 0, count =0;\\n        while(end < nums.length){\\n            if(nums[end] % 2 == 1) count++;\\n            while(start <= end && count > k){\\n                if(nums[start] % 2 == 1) count--;\\n                start++;\\n            }\\n            res += (end - start + 1);\\n            end++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878351,
                "title": "c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int atmost (vector<int>& arr, int k){\\n        if(arr.size()==0)\\n            return 0 ;\\n        int ans = 0;\\n        int j= 0;\\n        int count = 0;\\n        for ( int i =0;i<arr.size();i++){\\n            if(arr[i]&1){\\n                count++;\\n            }\\n            while(count>k){\\n                if(arr[j]&1)\\n                    count--;\\n                j++;\\n            }\\n            ans+=i-j+1;\\n        }\\n        return ans;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& v, int k) {\\n        return atmost(v,k)-atmost(v,k-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int atmost (vector<int>& arr, int k){\\n        if(arr.size()==0)\\n            return 0 ;\\n        int ans = 0;\\n        int j= 0;\\n        int count = 0;\\n        for ( int i =0;i<arr.size();i++){\\n            if(arr[i]&1){\\n                count++;\\n            }\\n            while(count>k){\\n                if(arr[j]&1)\\n                    count--;\\n                j++;\\n            }\\n            ans+=i-j+1;\\n        }\\n        return ans;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& v, int k) {\\n        return atmost(v,k)-atmost(v,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644359,
                "title": "java-two-pointer-sliding-window-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n     \\n        int odds = 0;\\n        int i = 0, j = 0, flag = 0;\\n        int n = nums.length;\\n        int ans = 0;\\n        while(j < n){\\n            if(nums[j]%2!=0){\\n                odds++;\\n            }\\n            while(odds > k){\\n                if(nums[i++]%2!=0)odds--;\\n                flag = i;\\n            }\\n            if(odds == k){\\n                ans+=(i+1-flag);\\n                while(nums[i]%2==0){\\n                    i++;\\n                    ans++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n     \\n        int odds = 0;\\n        int i = 0, j = 0, flag = 0;\\n        int n = nums.length;\\n        int ans = 0;\\n        while(j < n){\\n            if(nums[j]%2!=0){\\n                odds++;\\n            }\\n            while(odds > k){\\n                if(nums[i++]%2!=0)odds--;\\n                flag = i;\\n            }\\n            if(odds == k){\\n                ans+=(i+1-flag);\\n                while(nums[i]%2==0){\\n                    i++;\\n                    ans++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631869,
                "title": "count-number-of-nice-subarray",
                "content": "\\n\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/edf56675-d477-426e-ae38-2c78ff496b20_1640928608.742415.png)\\n\\n**Discuss**\\n\\n1. In this problem , First we will change the odd digit from 1 and even with zero in given array.\\n2. calculating the sum from start to end index with comparison k value\\ni.e. sum - k == 0\\n3. then we find subarray whose array has k odd value and stored in map. after this check again for another subarray because if we got odd value equal to the given k value then we got the subarray which has k odd value.\\n\\n**Note : this problem basically similar to the find subarray whose sum is equal to 0**\\n\\nclass Solution {\\n\\n    public int numberOfSubarrays(int[] nums, int k) {          \\n        Map<Integer, Integer> mp = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            sum += nums[j] % 2;\\n            if (sum - k == 0) {\\n                res++;\\n            }\\n            if (mp.containsKey(sum - k)) {\\n                res += mp.get(sum - k);\\n            }\\n            mp.put(sum, mp.getOrDefault(sum, 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\n    public int numberOfSubarrays(int[] nums, int k) {          \\n        Map<Integer, Integer> mp = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            sum += nums[j] % 2;\\n            if (sum - k == 0) {\\n                res++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 426285,
                "title": "easy-solution-using-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int odd=0,l=0,res=0;\\n        for(int r=0;r<n;r++)\\n        {\\n            if(nums[r]%2==1)\\n                odd++;\\n            while(l<r && odd>k)\\n            {\\n                if(nums[l]%2==1)\\n                    odd--;\\n                l++;\\n            }\\n            if(odd==k)\\n                res++;\\n            for(int i=l; odd==k && i<r && nums[i]%2==0;i++)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nA problem similar to this:\\nhttps://leetcode.com/problems/binary-subarrays-with-sum/description/\\nsolution:\\nhttps://leetcode.com/problems/binary-subarrays-with-sum/discuss/426284/Easy-Solution-Using-Sliding-Window!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int odd=0,l=0,res=0;\\n        for(int r=0;r<n;r++)\\n        {\\n            if(nums[r]%2==1)\\n                odd++;\\n            while(l<r && odd>k)\\n            {\\n                if(nums[l]%2==1)\\n                    odd--;\\n                l++;\\n            }\\n            if(odd==k)\\n                res++;\\n            for(int i=l; odd==k && i<r && nums[i]%2==0;i++)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419358,
                "title": "java-simple-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        ArrayList<Integer> pos = new ArrayList<>();\\n        pos.add(0);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==1){\\n                pos.add(i+1);\\n            }\\n        }\\n        pos.add(nums.length+1);\\n        int res=0;\\n\\n        for(int i=1;i<=pos.size()-k-1;i++){\\n            int start=pos.get(i)-pos.get(i-1);\\n            int end = pos.get(i+k)-pos.get(i+k-1);\\n            res+=start*end;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        ArrayList<Integer> pos = new ArrayList<>();\\n        pos.add(0);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==1){\\n                pos.add(i+1);\\n            }\\n        }\\n        pos.add(nums.length+1);\\n        int res=0;\\n\\n        for(int i=1;i<=pos.size()-k-1;i++){\\n            int start=pos.get(i)-pos.get(i-1);\\n            int end = pos.get(i+k)-pos.get(i+k-1);\\n            res+=start*end;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419345,
                "title": "simple-java-hashmap-solution-o-n-by-keeping-track-of-count-of-odd-numbers",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int ans = 0;\\n        int currCount = 0;\\n        \\n        map.put(0, 1);\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] % 2 == 1) currCount ++;\\n            if(map.containsKey(currCount - k)) ans += map.get(currCount - k);\\n            if(!map.containsKey(currCount)) map.put(currCount, 1);\\n            else map.put(currCount, 1 + map.get(currCount));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int ans = 0;\\n        int currCount = 0;\\n        \\n        map.put(0, 1);\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] % 2 == 1) currCount ++;\\n            if(map.containsKey(currCount - k)) ans += map.get(currCount - k);\\n            if(!map.containsKey(currCount)) map.put(currCount, 1);\\n            else map.put(currCount, 1 + map.get(currCount));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 419317,
                "title": "java-sliding-window-two-pointers-o-n",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int start = 0, end = 0, len = nums.length;\\n        int count = 0, oddCount = 0, evenCount = 0;\\n        \\n        while(end < len){\\n            \\n            while(end < len && oddCount < k){\\n                if(nums[end++] % 2 != 0)  ++oddCount;\\n            }\\n            \\n           evenCount = 1;\\n           while(end < len && nums[end] % 2 == 0){\\n                ++evenCount;\\n                ++end;\\n           }\\n           \\n           while(start < len && oddCount == k){\\n                count += evenCount;\\n                if(nums[start++] % 2 != 0) --oddCount;\\n           }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int start = 0, end = 0, len = nums.length;\\n        int count = 0, oddCount = 0, evenCount = 0;\\n        \\n        while(end < len){\\n            \\n            while(end < len && oddCount < k){\\n                if(nums[end++] % 2 != 0)  ++oddCount;\\n            }\\n            \\n           evenCount = 1;\\n           while(end < len && nums[end] % 2 == 0){\\n                ++evenCount;\\n                ++end;\\n           }\\n           \\n           while(start < len && oddCount == k){\\n                count += evenCount;\\n                if(nums[start++] % 2 != 0) --oddCount;\\n           }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058966,
                "title": "sliding-window-c",
                "content": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int n = nums.size(), dis = 1, i = 0, cnt = 0, ans = 0;\\r\\n        vector<int> d(n + 1, 1);\\r\\n\\r\\n        for(int i=n-1; i>=0; i--) {\\r\\n            nums[i] % 2 ? dis = 1 : dis++;\\r\\n            d[i] = dis;\\r\\n        }\\r\\n       \\r\\n        for(int j=0; j<n; j++) {\\r\\n            if(nums[j] % 2) cnt++;\\r\\n\\r\\n            while(i <= j && cnt == k) {\\r\\n                ans += d[j + 1];\\r\\n                if(nums[i] % 2) cnt--;\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int n = nums.size(), dis = 1, i = 0, cnt = 0, ans = 0;\\r\\n        vector<int> d(n + 1, 1);\\r\\n\\r\\n        for(int i=n-1; i>=0; i--) {\\r\\n            nums[i] % 2 ? dis = 1 : dis++;\\r\\n            d[i] = dis;\\r\\n        }\\r\\n       \\r\\n        for(int j=0; j<n; j++) {\\r\\n            if(nums[j] % 2) cnt++;\\r\\n\\r\\n            while(i <= j && cnt == k) {\\r\\n                ans += d[j + 1];\\r\\n                if(nums[i] % 2) cnt--;\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368474,
                "title": "c-3-ideas-solution-and-explanation-for-beginners",
                "content": "First, the naive solution, we check every possible subarray and increment the count everytime we encounter a nice subarray.\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            for(int j = i; j < n; j++) {\\n                if(nums[j] & 1 != 0) {\\n                    count++;\\n                }\\n                \\n                if(count == k) sum++;\\n                if(count > k) break;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\nVery standard, not much to talk about. The time complexity is `O(n^2)`while the space complexity is `O(1)`. Submitting this will cause an TLE...so it is clear we must do better on time complexity.\\n\\nHere is an observation, given a minimum length nice subarray with even number surrounding it. The total amount of different subarray we can construct is the \"left wing\" * \"right wing\". Take a look at the following example:\\n```\\n2,2,2,2,1,2,2,1,2,2,2,2       k = 2\\n```\\nHow many nice subarray can we construct? The answer is `5 * 5 = 25`. While we can count everything out, a better way is to notice the following pattern `1,2,2,1 -> 1,2,2,1,2 -> 1,2,2,1,2,2 -> ...`, for every element in the \"left wing\" we can pair it up with every other element in the \"right wing\" and vice versa. Simple math tells us the number of such combination is simply `left wing * right wing`. I will sepereate the two wings to make it clearer `2,2,2,2,1 | 2,2 | 1,2,2,2,2` (notice that we include the odd number in the wing). How we can locate a \"minimum length nice subarray\"? Easy, we can simple store indexs of all odd numbers and create a sliding window of length `k`. For every such window, we will calculate the length of both wing, either terminate at the start or end of an array, or terminate immediate before another odd number. For example, our minimum length nice subarray is from index 7 to index 9. \\n`2,2,1       |       2,2,2,2,1| 2 |1,2,2,2,2        |        1,1`\\nIf you don\\'t get it, stare at it for a while and I\\'m sure it will come to you. Time for the implementation:\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> idx;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] & 1 != 0) idx.push_back(i);\\n        }\\n        \\n        int sum = 0;\\n        \\n        int i = 0;\\n        for(int j = k - 1; j < idx.size(); j++) {\\n            int left = idx[i] - (i == 0 ? -1 : idx[i - 1]);\\n            int right = (j == idx.size() - 1 ? n : idx[j + 1]) - idx[j];\\n            \\n            sum += left * right;\\n            i++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\nTime complexity is `O(n)` while space complexity is also `O(n)`. \\n\\nSubmit and the code runs fine. I always like looking for other solutions even after finishing a question. I find it a good practice and also interesting that 1 problem can have so many different solutions.\\n\\nThis question might remind you of https://leetcode.com/problems/subarrays-with-k-different-integers/. This is a great question and I would definitely recommend checking out. When we do our standard sliding window solutions we get stuck because there is no easy way to slide the window through all possible subarrays. However, we can actually find all subarray with ATMOST `k` odd numbers pretty easily with sliding window. You should try and do this on your own. Eitherway, simple math tells us that `exactly(k) = atmost(k) - atmost(k - 1)`. This gives us a relatively simple algorithm:\\n```\\nclass Solution {\\n    \\n    int atMost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0;\\n        int sum = 0;\\n        \\n        for(int j = 0; j < n; j++) {\\n            if((nums[j] & 1) != 0) k--;\\n            while(k < 0) {\\n                if((nums[i] & 1) != 0) k++;\\n                i++;\\n            }\\n            \\n            sum += j - i + 1;\\n        }\\n        \\n        return sum;\\n    }\\n    \\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMost(nums, k) - atMost(nums, k - 1);\\n    }\\n};\\n```\\nSame time complexity as the solution above, but space complexity is `O(1)`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            for(int j = i; j < n; j++) {\\n                if(nums[j] & 1 != 0) {\\n                    count++;\\n                }\\n                \\n                if(count == k) sum++;\\n                if(count > k) break;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\n2,2,2,2,1,2,2,1,2,2,2,2       k = 2\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> idx;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] & 1 != 0) idx.push_back(i);\\n        }\\n        \\n        int sum = 0;\\n        \\n        int i = 0;\\n        for(int j = k - 1; j < idx.size(); j++) {\\n            int left = idx[i] - (i == 0 ? -1 : idx[i - 1]);\\n            int right = (j == idx.size() - 1 ? n : idx[j + 1]) - idx[j];\\n            \\n            sum += left * right;\\n            i++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    int atMost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0;\\n        int sum = 0;\\n        \\n        for(int j = 0; j < n; j++) {\\n            if((nums[j] & 1) != 0) k--;\\n            while(k < 0) {\\n                if((nums[i] & 1) != 0) k++;\\n                i++;\\n            }\\n            \\n            sum += j - i + 1;\\n        }\\n        \\n        return sum;\\n    }\\n    \\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMost(nums, k) - atMost(nums, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283963,
                "title": "very-easy-c-solution-in-o-n-beats-99-48-submissions",
                "content": "To achieve good time complexity we need to use bit munpulation for checking odd number\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```\\n#pragma GCC optimize(\"Ofast\")  \\n#pragma GCC target(\"avx,avx2,fma\") \\nstatic auto _ = [] ()\\n{ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int j = 0, odd = 0, ctr = 0, ans = 0;\\n        for (int i = 0; i < nums.size(); i++) \\n        {\\n            if (nums[i] & 1)\\n            {\\n                odd++;\\n                if (odd >= k) \\n                {\\n                    ctr = 1;\\n                    while (!(nums[j++] & 1))\\n                        ctr++;\\n                    ans += ctr;\\n                }\\n            \\n            } else if (odd >=k) \\n                ans += ctr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\")  \\n#pragma GCC target(\"avx,avx2,fma\") \\nstatic auto _ = [] ()\\n{ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int j = 0, odd = 0, ctr = 0, ans = 0;\\n        for (int i = 0; i < nums.size(); i++) \\n        {\\n            if (nums[i] & 1)\\n            {\\n                odd++;\\n                if (odd >= k) \\n                {\\n                    ctr = 1;\\n                    while (!(nums[j++] & 1))\\n                        ctr++;\\n                    ans += ctr;\\n                }\\n            \\n            } else if (odd >=k) \\n                ans += ctr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1257767,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    // Function to calculate the number of subarrays having count of odd numbers lees than or equals to k\\n    int helper(vector<int>&nums,int k)\\n    {\\n        int ans=0,i=0,count=0;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            if(nums[j]%2!=0)\\n            {\\n                count++;\\n            }\\n            while(i<=j && count>k)\\n            {\\n                if(nums[i]%2!=0)\\n                {\\n                    count--;\\n                }\\n                i++;\\n            }\\n            ans+=(j-i+1);\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) \\n    {\\n        // Number of subarrays with count of odd numbers <=k = (Numbers of subarrays with count of odd numbers <k + Numbers of subarrays with count of odd numbers =k)\\n        // so if we exclude the number of subarrays with odd number count less than k from number of subarrays with odd number count equals to k , we\\'ll get our answer.\\n        return helper(nums,k)-helper(nums,k-1);\\n    }\\n};\\n```\\n**Please upvote if you have got any help from my code. Thank you.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    // Function to calculate the number of subarrays having count of odd numbers lees than or equals to k\\n    int helper(vector<int>&nums,int k)\\n    {\\n        int ans=0,i=0,count=0;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            if(nums[j]%2!=0)\\n            {\\n                count++;\\n            }\\n            while(i<=j && count>k)\\n            {\\n                if(nums[i]%2!=0)\\n                {\\n                    count--;\\n                }\\n                i++;\\n            }\\n            ans+=(j-i+1);\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) \\n    {\\n        // Number of subarrays with count of odd numbers <=k = (Numbers of subarrays with count of odd numbers <k + Numbers of subarrays with count of odd numbers =k)\\n        // so if we exclude the number of subarrays with odd number count less than k from number of subarrays with odd number count equals to k , we\\'ll get our answer.\\n        return helper(nums,k)-helper(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615004,
                "title": "c-o-1-space-97-faster-100-space-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n    }\\n    int func(vector<int> &nums,int k)\\n    {\\n        int j=0;\\n        int cnt=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2)k--;\\n            while(k<0)\\n            {\\n                if(nums[j]%2)k++;\\n                j++;\\n            }\\n            cnt+=i-j+1;\\n        }\\n        return cnt;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\t\\t\\treturn func(nums,k)-func(nums,k-1);//func calculate for atmost case. exact k=atmost k -atmost k-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n    }\\n    int func(vector<int> &nums,int k)\\n    {\\n        int j=0;\\n        int cnt=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2)k--;\\n            while(k<0)\\n            {\\n                if(nums[j]%2)k++;\\n                j++;\\n            }\\n            cnt+=i-j+1;\\n        }\\n        return cnt;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\t\\t\\treturn func(nums,k)-func(nums,k-1);//func calculate for atmost case. exact k=atmost k -atmost k-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 562635,
                "title": "c-map-solution-easy-implementation",
                "content": "```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n\\tint res = 0, sum = 0, n = nums.size();\\n\\tunordered_map<int, int> mpp;\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tmpp[sum]++;\\n\\t\\tsum += nums[i] & 1;\\n\\t\\tres += mpp[sum - k];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n\\tint res = 0, sum = 0, n = nums.size();\\n\\tunordered_map<int, int> mpp;\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tmpp[sum]++;\\n\\t\\tsum += nums[i] & 1;\\n\\t\\tres += mpp[sum - k];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419934,
                "title": "python-easy-to-understand-sliding-window-left-right-evens-faster-than-100",
                "content": "\\tclass Solution(object):\\n\\t\\tdef numberOfSubarrays(self, nums, k):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\te.g. k = 2\\n\\t\\t\\tnums = [2, 2, 1, 2, 1, 2, 2]\\n\\t\\t\\tindex=  0  1  2  3  4  5  6\\n\\t\\t\\t2 even numbers to left of first 1\\n\\t\\t\\t2 even numbers to right of last 1\\n\\t\\t\\ttotal number of subarrays = pick between 0-2 numbers on left, then, pick between 0-2 numbers on right\\n\\t\\t\\ti.e (left+1)  (right+1)\\n\\t\\t\\tThen slide window to next set of 2 odd numbers\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\todds = []\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] & 1:\\n\\t\\t\\t\\t\\todds.append(i)                      #\\' Find index of all odd numbers \\'\\n\\n\\t\\t\\todds = [-1] + odds + [len(nums)]            #\\' Handle edge cases \\'\\n\\t\\t\\tnice = 0\\n\\n\\t\\t\\tfor i in range(1, len(odds)-k):\\n\\t\\t\\t\\tleft = odds[i] - odds[i-1] - 1          #\\' Number of \\'left\\' even numbers \\'\\n\\t\\t\\t\\tright = odds[i+k] - odds[i+k-1] - 1     #\\' Number of \\'right\\' even numbers \\'\\n\\t\\t\\t\\tnice += (left+1)*(right+1)              #\\' Total sub-arrays in current window \\'\\n\\n\\t\\t\\treturn nice\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef numberOfSubarrays(self, nums, k):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\te.g. k = 2\\n\\t\\t\\tnums = [2, 2, 1, 2, 1, 2, 2]\\n\\t\\t\\tindex=  0  1  2  3  4  5  6\\n\\t\\t\\t2 even numbers to left of first 1\\n\\t\\t\\t2 even numbers to right of last 1\\n\\t\\t\\ttotal number of subarrays = pick between 0-2 numbers on left, then, pick between 0-2 numbers on right\\n\\t\\t\\ti.e (left+1)  (right+1)\\n\\t\\t\\tThen slide window to next set of 2 odd numbers\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\todds = []\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] & 1:\\n\\t\\t\\t\\t\\todds.append(i)                      #\\' Find index of all odd numbers \\'\\n\\n\\t\\t\\todds = [-1] + odds + [len(nums)]            #\\' Handle edge cases \\'\\n\\t\\t\\tnice = 0\\n\\n\\t\\t\\tfor i in range(1, len(odds)-k):\\n\\t\\t\\t\\tleft = odds[i] - odds[i-1] - 1          #\\' Number of \\'left\\' even numbers \\'\\n\\t\\t\\t\\tright = odds[i+k] - odds[i+k-1] - 1     #\\' Number of \\'right\\' even numbers \\'\\n\\t\\t\\t\\tnice += (left+1)*(right+1)              #\\' Total sub-arrays in current window \\'\\n\\n\\t\\t\\treturn nice\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 419350,
                "title": "sliding-window-solution",
                "content": "The idea is sliding window with minor modification. Here is an example:\\n```2, 2, 3, 2, 2```\\nWe want to find 1 odd number. Using sliding window, we can find  `2, 2, 1`. And we delete the first two \\'2\\', which means that there are 3 sub-arrays that contain one 3. \\n\\nBut it\\'s not over, there are still two 2 left in the end. Thus, for any even number afterwards, we add 3 to the final result, which means that, given an even number, we can find 3 sub-arrays. Since there are two 2, we have 2 extra 3.\\n\\nThus, there are in total 3 * 3 = 9 sub-arrays that contain 1 odd number. \\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i = 0, j = 0, odd_cnt = 0, tot_res = 0, tmp_res = 0;\\n        for (i = 0; i < nums.size(); i++) {\\n            if (nums[i] % 2 == 1) odd_cnt++;\\n            while (odd_cnt == k) {\\n                tmp_res++;\\n                if (nums[j] % 2 == 1) odd_cnt--;\\n                j++;\\n            }\\n            tot_res += tmp_res;\\n            i++;\\n            while (i < nums.size() && nums[i] % 2 == 0) {\\n                tot_res += tmp_res;\\n                i++;\\n            }\\n            i--;\\n            tmp_res = 0;\\n        }\\n        \\n        return tot_res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```2, 2, 3, 2, 2```\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i = 0, j = 0, odd_cnt = 0, tot_res = 0, tmp_res = 0;\\n        for (i = 0; i < nums.size(); i++) {\\n            if (nums[i] % 2 == 1) odd_cnt++;\\n            while (odd_cnt == k) {\\n                tmp_res++;\\n                if (nums[j] % 2 == 1) odd_cnt--;\\n                j++;\\n            }\\n            tot_res += tmp_res;\\n            i++;\\n            while (i < nums.size() && nums[i] % 2 == 0) {\\n                tot_res += tmp_res;\\n                i++;\\n            }\\n            i--;\\n            tmp_res = 0;\\n        }\\n        \\n        return tot_res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940024,
                "title": "sliding-window-prefixsum-approach",
                "content": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        prefixsum=0\\n        dic=defaultdict(int)\\n        dic[0]=1\\n        ans=0\\n        for i in nums:\\n            if i%2==1:\\n                prefixsum+=1\\n            ans+=dic[prefixsum-k]\\n            dic[prefixsum]+=1\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        prefixsum=0\\n        dic=defaultdict(int)\\n        dic[0]=1\\n        ans=0\\n        for i in nums:\\n            if i%2==1:\\n                prefixsum+=1\\n            ans+=dic[prefixsum-k]\\n            dic[prefixsum]+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722242,
                "title": "modifying-the-question-making-it-much-more-easier-sliding-window-easy-to-understand",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nTreat odd numbers as 1 and even numbers as 0, then solve as if you want sum of subarray having sum = k.\\r\\n\\r\\nSame as this question: [930. Binary Subarrays With Sum\\r\\n](https://leetcode.com/problems/binary-subarrays-with-sum/)\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. Replace all the odd elements with 1 and all the even elements with 0.\\r\\n2. Now calculate the subarrays with sum = k.\\r\\n3. This can be done by finding the subarrays with **sum <= k** and finding subarrays with **sum <= k - 1** and subtrack later from the previous one.\\r\\n\\r\\n**Feel free to post your doubts in the comments :)**\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: **O(n)**\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: **O(1)**\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int atMost(vector<int>& nums, int k)\\r\\n    {\\r\\n        int left = 0;\\r\\n        int right = 0;\\r\\n        int ans = 0;\\r\\n\\r\\n        for(right = 0; right < nums.size(); right++)\\r\\n        {\\r\\n            k -= nums[right];\\r\\n            while(k < 0)\\r\\n            {\\r\\n                k += nums[left];\\r\\n                left++;\\r\\n            }\\r\\n            ans += right - left + 1;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        for(int i = 0; i < nums.size(); i++)\\r\\n        {\\r\\n            if(nums[i] % 2 == 1) nums[i] = 1;\\r\\n            else nums[i] = 0;\\r\\n        }\\r\\n        return atMost(nums, k) - atMost(nums, k - 1);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int atMost(vector<int>& nums, int k)\\r\\n    {\\r\\n        int left = 0;\\r\\n        int right = 0;\\r\\n        int ans = 0;\\r\\n\\r\\n        for(right = 0; right < nums.size(); right++)\\r\\n        {\\r\\n            k -= nums[right];\\r\\n            while(k < 0)\\r\\n            {\\r\\n                k += nums[left];\\r\\n                left++;\\r\\n            }\\r\\n            ans += right - left + 1;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        for(int i = 0; i < nums.size(); i++)\\r\\n        {\\r\\n            if(nums[i] % 2 == 1) nums[i] = 1;\\r\\n            else nums[i] = 0;\\r\\n        }\\r\\n        return atMost(nums, k) - atMost(nums, k - 1);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488177,
                "title": "java-very-easy",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int i=0;\\r\\n        int j=0;\\r\\n        int oddCount=0;\\r\\n        int ans=0;\\r\\n         int count=0;\\r\\n\\r\\n        while(j<nums.length){\\r\\n            \\r\\n            if(nums[j]%2!=0){\\r\\n                oddCount++;\\r\\n                ans=0;\\r\\n            }\\r\\n            \\r\\n            while(oddCount==k){\\r\\n                ans++;\\r\\n                if(nums[i]%2!=0){  \\r\\n                    oddCount--;\\r\\n    \\r\\n                }\\r\\n                i++;\\r\\n            }\\r\\n            count+=ans;\\r\\n            j++;\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int i=0;\\r\\n        int j=0;\\r\\n        int oddCount=0;\\r\\n        int ans=0;\\r\\n         int count=0;\\r\\n\\r\\n        while(j<nums.length){\\r\\n            \\r\\n            if(nums[j]%2!=0){\\r\\n                oddCount++;\\r\\n                ans=0;\\r\\n            }\\r\\n            \\r\\n            while(oddCount==k){\\r\\n                ans++;\\r\\n                if(nums[i]%2!=0){  \\r\\n                    oddCount--;\\r\\n    \\r\\n                }\\r\\n                i++;\\r\\n            }\\r\\n            count+=ans;\\r\\n            j++;\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270751,
                "title": "easy-sliding-window-solution-with-o-n-time-complexity",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThis Problem is talking about subarrays so the first thought that should come in your mind -> sliding window\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. first take two pointer on index 0\\r\\n2. now the second pointer will diverse from start , until the number of odds are not equals to k\\r\\n3. when the number of equal to k start increasing the second pointer until it eliminates the odd from start and makes number of odds less than k, along with it increase the prefix \\r\\n4.add the prefix in count until the next odd are not found \\r\\n5. Repeat the steps again\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nO(n)\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nO(1)\\r\\n# Code\\r\\n```\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @param {number} k\\r\\n * @return {number}\\r\\n */\\r\\nvar numberOfSubarrays = function(nums, k) {\\r\\n    let odds=0;\\r\\n    let count=0;\\r\\n    let prefix=0\\r\\n\\r\\n    let i=0;\\r\\n\\r\\n    for(let j=0;j<nums.length;j++){\\r\\n        if(nums[j]%2!=0){ \\r\\n            odds+=1\\r\\n            prefix=0\\r\\n            }\\r\\n\\r\\n        while(odds==k && i<=j){\\r\\n         if(nums[i]%2!=0)   odds-=1\\r\\n            i++\\r\\n           prefix++\\r\\n      \\r\\n        }\\r\\n       \\r\\n   count+=prefix\\r\\n\\r\\n    }\\r\\n    return count\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @param {number} k\\r\\n * @return {number}\\r\\n */\\r\\nvar numberOfSubarrays = function(nums, k) {\\r\\n    let odds=0;\\r\\n    let count=0;\\r\\n    let prefix=0\\r\\n\\r\\n    let i=0;\\r\\n\\r\\n    for(let j=0;j<nums.length;j++){\\r\\n        if(nums[j]%2!=0){ \\r\\n            odds+=1\\r\\n            prefix=0\\r\\n            }\\r\\n\\r\\n        while(odds==k && i<=j){\\r\\n         if(nums[i]%2!=0)   odds-=1\\r\\n            i++\\r\\n           prefix++\\r\\n      \\r\\n        }\\r\\n       \\r\\n   count+=prefix\\r\\n\\r\\n    }\\r\\n    return count\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165207,
                "title": "easy-approach-c",
                "content": "# Intuition\\r\\nUsing prefix sum!!\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n       int j=0;\\r\\n       int count=0;\\r\\n       int sum=0;\\r\\n       unordered_map<int,int>m;\\r\\n       while(j<nums.size()){\\r\\n           if(nums[j]%2!=0)\\r\\n               sum+=1;\\r\\n\\r\\n           if(sum==k)\\r\\n           count++;\\r\\n\\r\\n           if(m.find(sum-k)!=m.end())\\r\\n           count+=m[sum-k];\\r\\n\\r\\n           m[sum]++;\\r\\n           j++;\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n       int j=0;\\r\\n       int count=0;\\r\\n       int sum=0;\\r\\n       unordered_map<int,int>m;\\r\\n       while(j<nums.size()){\\r\\n           if(nums[j]%2!=0)\\r\\n               sum+=1;\\r\\n\\r\\n           if(sum==k)\\r\\n           count++;\\r\\n\\r\\n           if(m.find(sum-k)!=m.end())\\r\\n           count+=m[sum-k];\\r\\n\\r\\n           m[sum]++;\\r\\n           j++;\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165203,
                "title": "c-easy-6-lines-of-code",
                "content": "# Intuition\\nIf you remember two sum question you can have refrence \\uD83D\\uDD25 \\uD83D\\uDD25\\nEnjoy !\\n\\n# UPVOTE IF IT HELPED \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i=0 , sum=0 ,count=0;\\n        unordered_map<int,int>map;\\n        while(i<nums.size()){\\n            if(nums[i]%2 != 0) sum+=1;\\n            if(sum == k) count++;\\n             if(map.find(sum-k) != map.end()) count+=map[sum-k];\\n        map[sum]++;\\n         i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i=0 , sum=0 ,count=0;\\n        unordered_map<int,int>map;\\n        while(i<nums.size()){\\n            if(nums[i]%2 != 0) sum+=1;\\n            if(sum == k) count++;\\n             if(map.find(sum-k) != map.end()) count+=map[sum-k];\\n        map[sum]++;\\n         i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979885,
                "title": "c-two-pointer-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCalculating the subarrays having (k) odd numbers and subtracting the value with subarrays having (k-1) odd numbers.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint anss(vector<int>& nums, int k){\\n        int n = nums.size();\\n        vector<int> v(100001,0);\\n        int diff = 0;\\n        int j = 0;\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i]%2){\\n                v[nums[i]]++;\\n                diff++;\\n            }\\n            if(diff <= k){\\n                ans += (i-j+1);\\n            }else{\\n                while(j < n && j <= i && diff > k){\\n                    if(nums[j]%2 == 1){\\n                        v[nums[j]]--;\\n                        diff--;\\n                        \\n                    }\\n                    j++;\\n                }\\n                ans += (i-j +1);\\n            }\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // cout<<anss(nums,k-1)<<endl;\\n        // cout<<anss(nums,k)<<endl;\\n        return (anss(nums,k) - anss(nums,k-1)) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint anss(vector<int>& nums, int k){\\n        int n = nums.size();\\n        vector<int> v(100001,0);\\n        int diff = 0;\\n        int j = 0;\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i]%2){\\n                v[nums[i]]++;\\n                diff++;\\n            }\\n            if(diff <= k){\\n                ans += (i-j+1);\\n            }else{\\n                while(j < n && j <= i && diff > k){\\n                    if(nums[j]%2 == 1){\\n                        v[nums[j]]--;\\n                        diff--;\\n                        \\n                    }\\n                    j++;\\n                }\\n                ans += (i-j +1);\\n            }\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // cout<<anss(nums,k-1)<<endl;\\n        // cout<<anss(nums,k)<<endl;\\n        return (anss(nums,k) - anss(nums,k-1)) ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2334366,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        int odd = 0;\\n        int result = 0;\\n        int temp = 0;\\n        \\n        \\n        /* \\n            Approach : two pointer + sliding window technique\\n            \\n            step 1 : we have fix i and moving j until our count of odd numbers == k\\n            step 2 : when(odd == count) we are counting every possible subarray by reducing the size of subarray from i\\n            \\n        why temp?\\n        from reducing the size of subarray we will count all the possible subarray from between i and j\\n        but when i encounter a odd element the odd count will reduce and that while will stop executing\\n        \\n        now there are two possible cases\\n        1.The leftover elements have a odd number\\n        2.The leftover elements do not have any odd number\\n        \\n        1. if our leftover elements have a odd number \\n                then we cannot include our old possible subarrays into new possible subarrays because now new window for having odd == k is formed\\n                that\\'s why temp = 0;\\n                \\n        2. if out leftover elements do not have any odd element left\\n            then our leftover elements must also take in consideration becuase they will also contribute in forming subarrays\\n        */\\n        while(j< nums.length){\\n            if(nums[j]%2 != 0)\\n            {\\n                odd++;\\n                //if leftover elements have odd element then new window is formed so we set temp = 0;\\n                temp = 0;\\n            }\\n            while(odd ==k){\\n                temp++;\\n                if(nums[i] %2 != 0)\\n                    odd--;\\n                i++;\\n             }\\n          //if no leftover elements is odd, each element will part in forming subarray\\n        //so include them\\n            result += temp;\\n            j++;\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        int odd = 0;\\n        int result = 0;\\n        int temp = 0;\\n        \\n        \\n        /* \\n            Approach : two pointer + sliding window technique\\n            \\n            step 1 : we have fix i and moving j until our count of odd numbers == k\\n            step 2 : when(odd == count) we are counting every possible subarray by reducing the size of subarray from i\\n            \\n        why temp?\\n        from reducing the size of subarray we will count all the possible subarray from between i and j\\n        but when i encounter a odd element the odd count will reduce and that while will stop executing\\n        \\n        now there are two possible cases\\n        1.The leftover elements have a odd number\\n        2.The leftover elements do not have any odd number\\n        \\n        1. if our leftover elements have a odd number \\n                then we cannot include our old possible subarrays into new possible subarrays because now new window for having odd == k is formed\\n                that\\'s why temp = 0;\\n                \\n        2. if out leftover elements do not have any odd element left\\n            then our leftover elements must also take in consideration becuase they will also contribute in forming subarrays\\n        */\\n        while(j< nums.length){\\n            if(nums[j]%2 != 0)\\n            {\\n                odd++;\\n                //if leftover elements have odd element then new window is formed so we set temp = 0;\\n                temp = 0;\\n            }\\n            while(odd ==k){\\n                temp++;\\n                if(nums[i] %2 != 0)\\n                    odd--;\\n                i++;\\n             }\\n          //if no leftover elements is odd, each element will part in forming subarray\\n        //so include them\\n            result += temp;\\n            j++;\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040140,
                "title": "java-solution-similar-to-subarray-sum-equals-k",
                "content": "Just convert all the odds to 1 and even to 0. Now it\\'s the same problem as sum of subarrays equals to k\\n```java\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        for (int i = 0; i<nums.length; i++) {\\n            if (nums[i]%2!=0) nums[i] = 1;\\n            else nums[i] = 0;\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0, ans = 0;\\n        for (int i = 0; i<nums.length; i++) {\\n            map.put(sum, map.getOrDefault(sum, 0)+1);\\n            sum+=nums[i];\\n            if (map.containsKey(sum-k)) {\\n                ans+=map.get(sum-k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        for (int i = 0; i<nums.length; i++) {\\n            if (nums[i]%2!=0) nums[i] = 1;\\n            else nums[i] = 0;\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0, ans = 0;\\n        for (int i = 0; i<nums.length; i++) {\\n            map.put(sum, map.getOrDefault(sum, 0)+1);\\n            sum+=nums[i];\\n            if (map.containsKey(sum-k)) {\\n                ans+=map.get(sum-k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941025,
                "title": "easy-c-solution-6-lines-subarray-with-sum-k",
                "content": "```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n    int ans=0, sum=0;\\n    unordered_map<int,int> freq;\\n    for(auto a:nums){\\n        if(a%2!=0) ++sum;\\n        if(sum==k) ++ans;\\n        if(freq.count(sum-k)) ans += freq[sum-k];\\n        ++freq[sum];\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n    int ans=0, sum=0;\\n    unordered_map<int,int> freq;\\n    for(auto a:nums){\\n        if(a%2!=0) ++sum;\\n        if(sum==k) ++ans;\\n        if(freq.count(sum-k)) ans += freq[sum-k];\\n        ++freq[sum];\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1808819,
                "title": "python-solution-beats-95-81",
                "content": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        odd_ls = []\\n        for i, num in enumerate(nums):\\n            if num % 2 == 1:\\n                odd_ls.append(i)\\n                \\n        odd_ls = [-1] + odd_ls + [len(nums)]\\n        count = 0\\n        for i in range(1, len(odd_ls) - k):\\n            count += (odd_ls[i] - odd_ls[i - 1]) * (odd_ls[i + k] - odd_ls[i + k - 1])\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        odd_ls = []\\n        for i, num in enumerate(nums):\\n            if num % 2 == 1:\\n                odd_ls.append(i)\\n                \\n        odd_ls = [-1] + odd_ls + [len(nums)]\\n        count = 0\\n        for i in range(1, len(odd_ls) - k):\\n            count += (odd_ls[i] - odd_ls[i - 1]) * (odd_ls[i + k] - odd_ls[i + k - 1])\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243159,
                "title": "simple-c-solution-using-map",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>nums, int k) \\n    {\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           nums[i]=nums[i]%2;\\n       }\\n        int ans=0;\\n        int cur_sum=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cur_sum+=nums[i];\\n            if(cur_sum==k)\\n            {\\n                ans++;\\n            }\\n            if(mp.find(cur_sum-k)!=mp.end())\\n            {\\n                ans+=mp[cur_sum-k];\\n            }\\n            mp[cur_sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>nums, int k) \\n    {\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           nums[i]=nums[i]%2;\\n       }\\n        int ans=0;\\n        int cur_sum=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cur_sum+=nums[i];\\n            if(cur_sum==k)\\n            {\\n                ans++;\\n            }\\n            if(mp.find(cur_sum-k)!=mp.end())\\n            {\\n                ans+=mp[cur_sum-k];\\n            }\\n            mp[cur_sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165997,
                "title": "c-two-pointers-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // Suppose we have a nice subarray from indices i to j.\\n        // Then every subarray that includes the even numbers before\\n        // i is also nice. Every subarray that includes the even\\n        // numbers after j is also nice. Suppose we have m contiguous\\n        // even numbers before i and n contiguous even numbers after\\n        // j. Then using the k odd numbers in our nice subarray from\\n        // i to j, we can create (m+1)*(n+1) nice subarrays.\\n        int N = nums.size();\\n        \\n        int i = 0;\\n        // Get i to the starting position\\n        while (i < N && nums[i] % 2 == 0) {\\n            i++;\\n        }\\n        \\n        // Edge case when there are no odd numbers in the array\\n        if (i >= N)\\n            return 0;\\n        \\n        // Get j to the starting position\\n        int j = i;\\n        int num_odd = 0;\\n        while (j < N && num_odd < k) {\\n            if (nums[j] % 2 == 1) {\\n                num_odd++;\\n            }\\n            j++;\\n        }\\n        \\n        if (j >= N && num_odd < k) {\\n            // Edge case when there are less than k odd numbers\\n            // in the array\\n            return 0;\\n        }\\n        \\n        // At this j is the index 1 after the kth odd number, so decrement\\n        j--;\\n        \\n        int prev_i = -1;\\n        int ans = 0;\\n        while (j < N) {\\n            // Find the next odd element after j, and count the gap between\\n            int next_j = j+1;\\n            while (next_j < N && nums[next_j] % 2 == 0)\\n                next_j++;\\n            \\n            // Num even between previous i and current i\\n            int m = i - prev_i - 1;\\n            // Num even between current j and next j\\n            int n = next_j - j - 1;\\n            \\n            // Add nice subarrays to answers\\n            int num_nice_subarrays = (m+1)*(n+1);\\n            ans += (m+1)*(n+1);\\n            \\n            // Update i and j\\n            prev_i = i;\\n            ++i;\\n            while (i < N && nums[i] % 2 == 0) {\\n                ++i;\\n            }\\n            \\n            j = next_j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // Suppose we have a nice subarray from indices i to j.\\n        // Then every subarray that includes the even numbers before\\n        // i is also nice. Every subarray that includes the even\\n        // numbers after j is also nice. Suppose we have m contiguous\\n        // even numbers before i and n contiguous even numbers after\\n        // j. Then using the k odd numbers in our nice subarray from\\n        // i to j, we can create (m+1)*(n+1) nice subarrays.\\n        int N = nums.size();\\n        \\n        int i = 0;\\n        // Get i to the starting position\\n        while (i < N && nums[i] % 2 == 0) {\\n            i++;\\n        }\\n        \\n        // Edge case when there are no odd numbers in the array\\n        if (i >= N)\\n            return 0;\\n        \\n        // Get j to the starting position\\n        int j = i;\\n        int num_odd = 0;\\n        while (j < N && num_odd < k) {\\n            if (nums[j] % 2 == 1) {\\n                num_odd++;\\n            }\\n            j++;\\n        }\\n        \\n        if (j >= N && num_odd < k) {\\n            // Edge case when there are less than k odd numbers\\n            // in the array\\n            return 0;\\n        }\\n        \\n        // At this j is the index 1 after the kth odd number, so decrement\\n        j--;\\n        \\n        int prev_i = -1;\\n        int ans = 0;\\n        while (j < N) {\\n            // Find the next odd element after j, and count the gap between\\n            int next_j = j+1;\\n            while (next_j < N && nums[next_j] % 2 == 0)\\n                next_j++;\\n            \\n            // Num even between previous i and current i\\n            int m = i - prev_i - 1;\\n            // Num even between current j and next j\\n            int n = next_j - j - 1;\\n            \\n            // Add nice subarrays to answers\\n            int num_nice_subarrays = (m+1)*(n+1);\\n            ans += (m+1)*(n+1);\\n            \\n            // Update i and j\\n            prev_i = i;\\n            ++i;\\n            while (i < N && nums[i] % 2 == 0) {\\n                ++i;\\n            }\\n            \\n            j = next_j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649585,
                "title": "three-ways-to-solve",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int atMostKOdds(vector<int>& nums, int k) {\\n        int l = 0, r = 0;\\n        int odds = 0;\\n        int result = 0;\\n        for (; r < nums.size(); r++) {\\n            if (nums[r]&1)\\n                odds++;\\n            while (odds>k) {\\n                if (nums[l]&1)\\n                    odds--;\\n                l++;\\n            }\\n            result += r-l+1;\\n        }\\n        return result;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        // Approach 1: [ACCEPTED]\\n        // Based on \"Subarray sum equals K\" \\n        /*\\n            unordered_map<int,int> mp;\\n            int odds  = 0;\\n            mp[0]++;\\n            int n = nums.size();\\n            int ans = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i]&1) {\\n                    odds++;\\n                }\\n                if (mp.find(odds-k)!=mp.end())\\n                    ans += mp[odds-k];\\n                mp[odds]++;\\n                \\n            }\\n            return ans;\\n        */\\n        \\n        //\\n        \\n        \\n        // Approach 2 : [ACCEPTED] \\n        // Based on sliding window\\n        // The function atMostKOdds(int k) returns count of subarrays with at most k odd numbers.\\n        // So for this question, Ans = atMostKOdds(K)-atMostKOdds(K-1)\\n        /*\\n            return atMostKOdds(nums, k)-atMostKOdds(nums, k-1);\\n        */\\n        \\n        // Approach 3 : [ACCEPTED]\\n        // Based on using two sliding windows\\n        // Keep track of longest and shortest subarrays ending at index \\'r\\' with K odd numbers.\\n        // Add up their difference in length\\n        \\n        int l1 = 0, l2 = 0;\\n        int r1 = 0, r2 = 0;\\n        int odds1 = 0, odds2 = 0;\\n        int ans = 0;\\n        \\n        for (; r1<nums.size(); r1++, r2++) {\\n            if (nums[r1]&1)\\n                odds1++;\\n            if (nums[r2]&1)\\n                odds2++;\\n            while (odds1>k) {\\n                if (nums[l1]&1)\\n                    odds1--;\\n                l1++;\\n            }\\n            while (odds2>=k) {\\n                if (nums[l2]&1) \\n                    odds2--;\\n                l2++;\\n            }\\n            ans += l2-l1;\\n        }\\n        return ans;      \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int atMostKOdds(vector<int>& nums, int k) {\\n        int l = 0, r = 0;\\n        int odds = 0;\\n        int result = 0;\\n        for (; r < nums.size(); r++) {\\n            if (nums[r]&1)\\n                odds++;\\n            while (odds>k) {\\n                if (nums[l]&1)\\n                    odds--;\\n                l++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 625894,
                "title": "python-2-lines",
                "content": "```accumulate([x%2 for x in nums], initial=0)``` calcuates prefix, turns [3,3,4] into [0,1,2,2], for example.\\n```prefix[odd_count] * prefix[odd_count-k]``` calcualtes the subarray counts for prefixes with each odd_count value.\\n\\n\\n```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n    prefix = Counter(accumulate([x%2 for x in nums], initial=0))\\n    return sum(prefix[odd_count] * prefix[odd_count-k] for odd_count in prefix)\\n```",
                "solutionTags": [],
                "code": "```accumulate([x%2 for x in nums], initial=0)```\n```prefix[odd_count] * prefix[odd_count-k]```\n```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n    prefix = Counter(accumulate([x%2 for x in nums], initial=0))\\n    return sum(prefix[odd_count] * prefix[odd_count-k] for odd_count in prefix)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 552854,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int count = 0;\\n        int l = 0;\\n        int r = 0;\\n        int oddCount = 0;\\n        int size = nums.size();\\n        while (r < size) {\\n            while (oddCount < k && r < size) {\\n                if (nums[r] % 2 != 0) {\\n                    oddCount++;\\n                }\\n                r++;\\n            }\\n            int c1 = 1;\\n            while (r < size && nums[r] % 2 == 0) {\\n                r++;\\n                c1++;\\n            } \\n            int c2 = 0;\\n            while (oddCount == k && l < r) {\\n                if (nums[l] % 2 != 0) {\\n                    oddCount--;\\n                }\\n                l++;\\n                c2++;\\n            }\\n            count += c1 * c2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int count = 0;\\n        int l = 0;\\n        int r = 0;\\n        int oddCount = 0;\\n        int size = nums.size();\\n        while (r < size) {\\n            while (oddCount < k && r < size) {\\n                if (nums[r] % 2 != 0) {\\n                    oddCount++;\\n                }\\n                r++;\\n            }\\n            int c1 = 1;\\n            while (r < size && nums[r] % 2 == 0) {\\n                r++;\\n                c1++;\\n            } \\n            int c2 = 0;\\n            while (oddCount == k && l < r) {\\n                if (nums[l] % 2 != 0) {\\n                    oddCount--;\\n                }\\n                l++;\\n                c2++;\\n            }\\n            count += c1 * c2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443122,
                "title": "c-simplest-solution-ever",
                "content": "```\\n int numberOfSubarrays(vector<int>& nums, int k) {\\n         unordered_map<int,int>m;\\n         int res=0,cnt=0;\\n         m[0]=1;\\n \\xA0 \\xA0 \\xA0 \\xA0 for(int i : nums)\\n         {\\n             cnt+=(i%2);\\n             res+=m[cnt-k];\\n             m[cnt]++;\\n         }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int numberOfSubarrays(vector<int>& nums, int k) {\\n         unordered_map<int,int>m;\\n         int res=0,cnt=0;\\n         m[0]=1;\\n \\xA0 \\xA0 \\xA0 \\xA0 for(int i : nums)\\n         {\\n             cnt+=(i%2);\\n             res+=m[cnt-k];\\n             m[cnt]++;\\n         }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 423675,
                "title": "python-solution-beats-99",
                "content": "There is a simple solution, by enumerate list and count the combinations of numbers.\\n\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        # count\\n        arr = []\\n        for i, x in enumerate(nums):\\n            if x % 2 != 0:\\n                arr.append(i)   \\n        arr.append(len(nums))\\n        \\n        # not satisify\\n        if len(arr) <= k:\\n            return 0\\n        \\n        # calculate\\n        count = 0\\n        count +=  (arr[0] + 1) * (arr[k] - arr[k-1])\\n        for i in range(k+1, len(arr)):\\n            count += (arr[i-k] - arr[i-k-1]) * (arr[i] - arr[i-1])\\n            \\n        return count \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        # count\\n        arr = []\\n        for i, x in enumerate(nums):\\n            if x % 2 != 0:\\n                arr.append(i)   \\n        arr.append(len(nums))\\n        \\n        # not satisify\\n        if len(arr) <= k:\\n            return 0\\n        \\n        # calculate\\n        count = 0\\n        count +=  (arr[0] + 1) * (arr[k] - arr[k-1])\\n        for i in range(k+1, len(arr)):\\n            count += (arr[i-k] - arr[i-k-1]) * (arr[i] - arr[i-1])\\n            \\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 421003,
                "title": "python-straightforward-solution",
                "content": "Straightforward Solution: similar to the idea in [the solution for 828. Unique Letter String](https://leetcode.com/problems/unique-letter-string/discuss/128952/One-pass-O(N)-Straight-Forward)\\n```\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        lst = [-1]\\n        for i in range(len(nums)):\\n            if nums[i] % 2:\\n                lst.append(i)\\n        lst.append(len(nums))\\n        res = 0\\n        for i in range(1, len(lst) - k):\\n\\t\\t    # plus the number of windows containing [lst[i], lst[i+k-1]]\\n            res += (lst[i] - lst[i-1]) * (lst[i+k] - lst[i+k-1])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        lst = [-1]\\n        for i in range(len(nums)):\\n            if nums[i] % 2:\\n                lst.append(i)\\n        lst.append(len(nums))\\n        res = 0\\n        for i in range(1, len(lst) - k):\\n\\t\\t    # plus the number of windows containing [lst[i], lst[i+k-1]]\\n            res += (lst[i] - lst[i-1]) * (lst[i+k] - lst[i+k-1])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 419615,
                "title": "java-prefix-array-approach-explained",
                "content": "For each index count is the number increase index of prefix array if it is odd. Increase the value of the prefix array for every element. prefix[0] denotes the number of elements of nums we traversed to get the first odd number. \\n\\nLets take the example nums= 2 2 2 1 2 2 1 2 2 2\\nprefix = 4 3 3 0 0 ....\\n\\nWe found 1st odd number at index 3 so we travesed 4 indexes and similarly second odd number is at index 6 so prefix[1] is 3. Now since k=2 we can start making subarrays. At index 6 we can have 4 subarrays starting at index 0,1,2 or 3 and including index 6 similarly for index we have 4 subarrays and so on.\\n```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) \\n    {\\n        int count=0;\\n        int odd=0;\\n        int ans=0;\\n        int prefix[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prefix[odd]++;\\n            if(nums[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n            if(odd>=k)\\n            {\\n                ans+=prefix[odd-k];\\n            }\\n        }\\n        for(int i:prefix)\\n            System.out.print(i+\" \");\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) \\n    {\\n        int count=0;\\n        int odd=0;\\n        int ans=0;\\n        int prefix[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prefix[odd]++;\\n            if(nums[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n            if(odd>=k)\\n            {\\n                ans+=prefix[odd-k];\\n            }\\n        }\\n        for(int i:prefix)\\n            System.out.print(i+\" \");\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419319,
                "title": "o-n-solution",
                "content": "In the example [2,2,2,1,2,2,1,2,2,2] for k = 2 the first element of a nice subarray can be the first 1 or any 2 before it and the last element can be the second 1 or any 2 after it. We transform this array to [4,3,4] (every number in the new array is the length of subarray of even numbers plus 1). The answer is 16 = 4 (any of the 3 even numbers + 1 odd number at the right end of subarray of even numbers) * 4 (1 odd number at the left end of subarray + any of the 3 even numbers). In general case the distance between multipliers is k for resulting subarray to contain exactly k odd numbers.\\n\\n\\n```\\n    int numberOfSubarrays(vector<int>& nums, int k)\\n    {\\n        int count = 0;\\n        vector<int> groups;\\n        groups.push_back(1);\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] % 2 == 1) groups.push_back(1);\\n            else groups.back()++;\\n        }\\n        for (int i = k; i < groups.size(); i++)\\n            count += groups[i - k] * groups[i];\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numberOfSubarrays(vector<int>& nums, int k)\\n    {\\n        int count = 0;\\n        vector<int> groups;\\n        groups.push_back(1);\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] % 2 == 1) groups.push_back(1);\\n            else groups.back()++;\\n        }\\n        for (int i = k; i < groups.size(); i++)\\n            count += groups[i - k] * groups[i];\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968413,
                "title": "easy-c-solution-using-an-array-in-o-n-time",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nWe will be storing all the indices having odd number in an array and the we will be traversing that array in **window size of k** to find the number of subarrays in that specific window.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n#  **O(n)**\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n# O(n)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int n=nums.size();\\r\\n        vector<int> res;//to store the index of odd numbers\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(nums[i]%2){\\r\\n                res.push_back(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(res.size()==0 || res.size() < k) return 0;\\r\\n        long long ans = 0;\\r\\n        int sz=res.size();\\r\\n\\r\\n        for(int i=0;i<=sz-k;i++){\\r\\n            //st is the index of the first odd number in window of size k\\r\\n            int st = res[i];\\r\\n            //end is the index of the last odd number in window of size k\\r\\n            int end = res[i+k-1];\\r\\n            //left and right are used to store the number of even behind start and after end \\r\\n            int left;int right;\\r\\n            if(i==0){\\r\\n                //if we are taking first index then no of even on left would be index+1.\\r\\n                left = res[i]+1;\\r\\n            }\\r\\n            else{\\r\\n                //to find even numbers between present odd and previous odd we will do res[i]-res[i-1];\\r\\n                left = abs(st - res[i-1]);\\r\\n            }\\r\\n\\r\\n            if((i+k-1)==sz-1) {\\r\\n                //if we are on last odd occurence then even after that number would be nums.size()-end\\r\\n                right = abs(n-end);\\r\\n            }\\r\\n            else{\\r\\n                //to find even numbers between last odd in window size of k and last+1 odd we will do res[i+k]-res[i+k-1];\\r\\n                right = abs(res[i+k] - end);\\r\\n            }\\r\\n            //for that window of size k between index i and i+k-1 ans will be left*right \\r\\n            //we will go on adding sum to get the final answer\\r\\n            ans += (left*right);\\r\\n        }\\r\\n        return ans;\\r\\n\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int n=nums.size();\\r\\n        vector<int> res;//to store the index of odd numbers\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(nums[i]%2){\\r\\n                res.push_back(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(res.size()==0 || res.size() < k) return 0;\\r\\n        long long ans = 0;\\r\\n        int sz=res.size();\\r\\n\\r\\n        for(int i=0;i<=sz-k;i++){\\r\\n            //st is the index of the first odd number in window of size k\\r\\n            int st = res[i];\\r\\n            //end is the index of the last odd number in window of size k\\r\\n            int end = res[i+k-1];\\r\\n            //left and right are used to store the number of even behind start and after end \\r\\n            int left;int right;\\r\\n            if(i==0){\\r\\n                //if we are taking first index then no of even on left would be index+1.\\r\\n                left = res[i]+1;\\r\\n            }\\r\\n            else{\\r\\n                //to find even numbers between present odd and previous odd we will do res[i]-res[i-1];\\r\\n                left = abs(st - res[i-1]);\\r\\n            }\\r\\n\\r\\n            if((i+k-1)==sz-1) {\\r\\n                //if we are on last odd occurence then even after that number would be nums.size()-end\\r\\n                right = abs(n-end);\\r\\n            }\\r\\n            else{\\r\\n                //to find even numbers between last odd in window size of k and last+1 odd we will do res[i+k]-res[i+k-1];\\r\\n                right = abs(res[i+k] - end);\\r\\n            }\\r\\n            //for that window of size k between index i and i+k-1 ans will be left*right \\r\\n            //we will go on adding sum to get the final answer\\r\\n            ans += (left*right);\\r\\n        }\\r\\n        return ans;\\r\\n\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791225,
                "title": "count-number-of-subarrays-with-exactly-k-odd-numbers-easy-solution",
                "content": "# Intuition\\r\\nThe problem requires counting the number of subarrays with exactly \\'k\\' odd numbers. To simplify the counting process, we can convert even elements in the array to 0 and odd elements to 1. This way, we only need to find subarrays with a prefix sum of \\'k\\'.\\r\\n\\r\\n\\r\\n\\r\\n# Approach\\r\\nApproach:\\r\\n\\r\\nConvert the even elements in the \\'nums\\' array to 0 and odd elements to 1.\\r\\nInitialize variables: \\'cnt\\' to count the subarrays with exactly \\'k\\' odd numbers, \\'mpp\\' as an unordered_map to store prefix sum and its occurrences, and \\'sum\\' to keep track of the prefix sum.\\r\\nIterate through the \\'nums\\' array, calculate the prefix sum, and update the \\'cnt\\' accordingly based on prefix sum \\'k\\'.\\r\\nFor each prefix sum, check if the difference \\'rem\\' (sum - k) exists in \\'mpp\\'. If so, there are subarrays with exactly \\'k\\' odd numbers ending at the current index. Update \\'cnt\\' by the number of such subarrays found in \\'mpp\\'.\\r\\nStore the current prefix sum\\'s index in \\'mpp\\'.\\r\\nReturn the final count \\'cnt\\' as the result.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(n), where \\'n\\' is the size of the \\'nums\\' array, as we only need to iterate through the array once.\\r\\n\\r\\n- Space complexity:\\r\\nO(n), since the unordered_map \\'mpp\\' can have up to \\'n\\' elements.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        // Convert even elements to 0 and odd elements to 1 in the \\'nums\\' array.\\r\\n        for (int i = 0; i < nums.size(); i++) {\\r\\n            if (nums[i] % 2 == 0) {\\r\\n                nums[i] = 0;\\r\\n            } else {\\r\\n                nums[i] = 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int cnt = 0; // Initialize the count of subarrays with exactly \\'k\\' odd numbers.\\r\\n        unordered_map<int, list<int>> mpp; // Create a map to store the prefix sum and its occurrences.\\r\\n        int sum = 0; // Initialize the prefix sum.\\r\\n\\r\\n        for (int i = 0; i < nums.size(); i++) {\\r\\n            sum += nums[i]; // Calculate the prefix sum.\\r\\n\\r\\n            if (sum == k) {\\r\\n                cnt++; // If the prefix sum equals \\'k\\', we found one subarray with exactly \\'k\\' odd numbers.\\r\\n            }\\r\\n\\r\\n            int rem = sum - k; // Calculate the difference between the current prefix sum and \\'k\\'.\\r\\n\\r\\n            // If the difference exists in the map, it means there are subarrays with exactly \\'k\\' odd numbers ending at the current index.\\r\\n            if (mpp.find(rem) != mpp.end()) {\\r\\n                cnt += mpp[rem].size(); // Increment the count by the number of such subarrays.\\r\\n            }\\r\\n\\r\\n            mpp[sum].push_back(i); // Store the current prefix sum\\'s index in the map.\\r\\n        }\\r\\n\\r\\n        return cnt; // Return the count of subarrays with exactly \\'k\\' odd numbers.\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        // Convert even elements to 0 and odd elements to 1 in the \\'nums\\' array.\\r\\n        for (int i = 0; i < nums.size(); i++) {\\r\\n            if (nums[i] % 2 == 0) {\\r\\n                nums[i] = 0;\\r\\n            } else {\\r\\n                nums[i] = 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int cnt = 0; // Initialize the count of subarrays with exactly \\'k\\' odd numbers.\\r\\n        unordered_map<int, list<int>> mpp; // Create a map to store the prefix sum and its occurrences.\\r\\n        int sum = 0; // Initialize the prefix sum.\\r\\n\\r\\n        for (int i = 0; i < nums.size(); i++) {\\r\\n            sum += nums[i]; // Calculate the prefix sum.\\r\\n\\r\\n            if (sum == k) {\\r\\n                cnt++; // If the prefix sum equals \\'k\\', we found one subarray with exactly \\'k\\' odd numbers.\\r\\n            }\\r\\n\\r\\n            int rem = sum - k; // Calculate the difference between the current prefix sum and \\'k\\'.\\r\\n\\r\\n            // If the difference exists in the map, it means there are subarrays with exactly \\'k\\' odd numbers ending at the current index.\\r\\n            if (mpp.find(rem) != mpp.end()) {\\r\\n                cnt += mpp[rem].size(); // Increment the count by the number of such subarrays.\\r\\n            }\\r\\n\\r\\n            mpp[sum].push_back(i); // Store the current prefix sum\\'s index in the map.\\r\\n        }\\r\\n\\r\\n        return cnt; // Return the count of subarrays with exactly \\'k\\' odd numbers.\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758219,
                "title": "simple-soln-am-i-the-only-one-who-thought-this-is-similar-to-binary-subarrays-with-sum-beats-92",
                "content": "# Intuition\\nPlzz Refer my soln for **Binary subarrays with sum** question here\\n[https://leetcode.com/problems/binary-subarrays-with-sum/solutions/3102433/c-sliding-window-easy-explanation/]()\\n# Approach\\nTreat the even numbers as Zeroes and odd numbers as Ones.\\nnow change the Nums array accordingly.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]&1) nums[i]=1;\\n            else nums[i]=0;\\n        }\\n        return helper(nums,k,n)-helper(nums,k-1,n);\\n    }\\n//Helper function helps to count the no of subarrays with sum less than or equal to k.\\n    int helper(vector<int>&nums,int k,int n){\\n        int count=0,sum=0,j=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            while(sum>k){\\n                sum-=nums[j++];\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]&1) nums[i]=1;\\n            else nums[i]=0;\\n        }\\n        return helper(nums,k,n)-helper(nums,k-1,n);\\n    }\\n//Helper function helps to count the no of subarrays with sum less than or equal to k.\\n    int helper(vector<int>&nums,int k,int n){\\n        int count=0,sum=0,j=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            while(sum>k){\\n                sum-=nums[j++];\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544150,
                "title": "java-simple-with-complete-explanation",
                "content": "# Approach\\r\\nThe provided solution employs a sliding window technique to solve the problem. Let\\'s break down the approach step by step:\\r\\n\\r\\n- Initialize variables left, right, count, max, and temp. Set len as the length of the input array nums. Here, left and right represent the left and right pointers of the sliding window, count keeps track of the number of odd numbers encountered, max stores the total count of nice subarrays, and temp is a temporary variable to count the number of nice subarrays at each position.\\r\\n\\r\\n- Start iterating through the array using the right pointer until it reaches the end of the array.\\r\\n\\r\\n- At each iteration, check if the current number at position right is odd or even. If it is odd\\r\\n-       (nums[right] % 2 == 1)\\r\\n-  increment the count by 1 to indicate the presence of an odd number in the current subarray. Reset temp to 0 to start counting the number of nice subarrays at the current position.\\r\\n\\r\\n- Inside the while loop, check if the condition of having exactly k odd numbers is satisfied \\r\\n-      (count == k). \\r\\n-   If this condition is met, it means we have found a nice subarray.\\r\\n\\r\\n- Increment temp by 1 to count the number of nice subarrays starting from the current position right.\\r\\n\\r\\n- Move the left pointer inside a nested while loop to shrink the window and find more nice subarrays. We keep moving the left pointer and decrementing the count whenever we encounter an odd number. This step ensures that we maintain exactly k odd numbers in the subarray.\\r\\n\\r\\n- After finding all possible nice subarrays starting from the current right position, add temp to max to update the total count of nice subarrays.\\r\\n\\r\\n- Finally, increment the right pointer to expand the window and continue the process until we reach the end of the array.\\r\\n\\r\\n- Return max, which represents the total number of nice subarrays.- \\r\\n\\r\\n# Complexity\\r\\n- **Time complexity:** \\r\\n\\r\\n-     O(n)\\r\\nThe time complexity of this approach is O(N), where N is the length of the input array nums. The algorithm only iterates through the array once using the sliding window technique.\\r\\n<hr>\\r\\n\\r\\n- **Space complexity:**\\r\\nslid \\r\\n-     O(1)\\r\\nThe space complexity is O(1) because no extra space is used apart from the input array and a few variables to track indices and counts.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int len=nums.length;\\r\\n        int left=0,right=0,count=0,max=0,temp=0;\\r\\n        while(right<len)\\r\\n        {\\r\\n            if(nums[right]%2==1)\\r\\n            {\\r\\n                count++;\\r\\n                temp=0;\\r\\n            }\\r\\n           \\r\\n            while(count==k)\\r\\n            {\\r\\n                temp++;\\r\\n                    if(nums[left]%2==1)\\r\\n                    {\\r\\n                        count--;\\r\\n                    }\\r\\n                   \\r\\n                    left++;\\r\\n            }\\r\\n            max=max+temp;\\r\\n            \\r\\n            right++;\\r\\n        }\\r\\n        return max;\\r\\n        \\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int len=nums.length;\\r\\n        int left=0,right=0,count=0,max=0,temp=0;\\r\\n        while(right<len)\\r\\n        {\\r\\n            if(nums[right]%2==1)\\r\\n            {\\r\\n                count++;\\r\\n                temp=0;\\r\\n            }\\r\\n           \\r\\n            while(count==k)\\r\\n            {\\r\\n                temp++;\\r\\n                    if(nums[left]%2==1)\\r\\n                    {\\r\\n                        count--;\\r\\n                    }\\r\\n                   \\r\\n                    left++;\\r\\n            }\\r\\n            max=max+temp;\\r\\n            \\r\\n            right++;\\r\\n        }\\r\\n        return max;\\r\\n        \\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496223,
                "title": "two-pointer-approach-sliding-window-c-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int start = 0;\\r\\n        int ans = 0;\\r\\n        int odds = 0;\\r\\n        int i, temp = 0;\\r\\n        for( i=0; i<nums.size(); i++){\\r\\n            if(odds < k){\\r\\n                if(nums[i]%2 == 1){\\r\\n                    odds++;\\r\\n                }\\r\\n                if(odds == k) ans++;\\r\\n            }\\r\\n            else if(odds == k && nums[i]%2 == 0){\\r\\n                ans++;\\r\\n                temp++;\\r\\n            }\\r\\n            else{\\r\\n                while(nums[start] % 2 == 0){\\r\\n                    start++;\\r\\n                    ans+=(temp+1);\\r\\n                }\\r\\n                if(nums[i] % 2 == 1){\\r\\n                    temp = 0;\\r\\n                    start++;\\r\\n                    ans++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        while(start < nums.size() && nums[start] % 2 == 0 && odds == k){\\r\\n            start++;\\r\\n            ans+=(temp+1);\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int start = 0;\\r\\n        int ans = 0;\\r\\n        int odds = 0;\\r\\n        int i, temp = 0;\\r\\n        for( i=0; i<nums.size(); i++){\\r\\n            if(odds < k){\\r\\n                if(nums[i]%2 == 1){\\r\\n                    odds++;\\r\\n                }\\r\\n                if(odds == k) ans++;\\r\\n            }\\r\\n            else if(odds == k && nums[i]%2 == 0){\\r\\n                ans++;\\r\\n                temp++;\\r\\n            }\\r\\n            else{\\r\\n                while(nums[start] % 2 == 0){\\r\\n                    start++;\\r\\n                    ans+=(temp+1);\\r\\n                }\\r\\n                if(nums[i] % 2 == 1){\\r\\n                    temp = 0;\\r\\n                    start++;\\r\\n                    ans++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        while(start < nums.size() && nums[start] % 2 == 0 && odds == k){\\r\\n            start++;\\r\\n            ans+=(temp+1);\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338831,
                "title": "easy-map-must-see-easy-to-understand",
                "content": "# Code\\r\\n```\\r\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\r\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\r\\n\\r\\nstatic int fast_io = []() \\r\\n{ \\r\\n    std::ios::sync_with_stdio(false); \\r\\n    cin.tie(nullptr); \\r\\n    cout.tie(nullptr); \\r\\n    return 0; \\r\\n}();\\r\\n\\r\\n#ifdef LOCAL\\r\\n    freopen(\"input.txt\", \"r\" , stdin);\\r\\n    freopen(\"output.txt\", \"w\", stdout);\\r\\n#endif\\r\\n\\r\\nclass Solution {\\r\\npublic:\\r\\n    //for keeping the track of the no of number of subarray haveing \\r\\n    //distinct odd number count\\r\\n    unordered_map<int,int>mp;\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) \\r\\n    {\\r\\n        //initially we dont have any odd number prior to the 0 index\\r\\n        mp[0]++;\\r\\n\\r\\n        //to keep the number of subarrays having \\r\\n        //odd number exactly k times\\r\\n        int ans = 0;\\r\\n\\r\\n        int oddcount = 0;\\r\\n        for(int i=0;i<(nums.size());i++)\\r\\n        {\\r\\n            if((nums[i]%2) != 0)\\r\\n            {\\r\\n                 oddcount++;  \\r\\n            }\\r\\n            if(mp.find(oddcount - k) != mp.end())\\r\\n            {\\r\\n                ans = ans + mp[oddcount-k];\\r\\n            }              \\r\\n            mp[oddcount]++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\r\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\r\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\r\\n\\r\\nstatic int fast_io = []() \\r\\n{ \\r\\n    std::ios::sync_with_stdio(false); \\r\\n    cin.tie(nullptr); \\r\\n    cout.tie(nullptr); \\r\\n    return 0; \\r\\n}();\\r\\n\\r\\n#ifdef LOCAL\\r\\n    freopen(\"input.txt\", \"r\" , stdin);\\r\\n    freopen(\"output.txt\", \"w\", stdout);\\r\\n#endif\\r\\n\\r\\nclass Solution {\\r\\npublic:\\r\\n    //for keeping the track of the no of number of subarray haveing \\r\\n    //distinct odd number count\\r\\n    unordered_map<int,int>mp;\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) \\r\\n    {\\r\\n        //initially we dont have any odd number prior to the 0 index\\r\\n        mp[0]++;\\r\\n\\r\\n        //to keep the number of subarrays having \\r\\n        //odd number exactly k times\\r\\n        int ans = 0;\\r\\n\\r\\n        int oddcount = 0;\\r\\n        for(int i=0;i<(nums.size());i++)\\r\\n        {\\r\\n            if((nums[i]%2) != 0)\\r\\n            {\\r\\n                 oddcount++;  \\r\\n            }\\r\\n            if(mp.find(oddcount - k) != mp.end())\\r\\n            {\\r\\n                ans = ans + mp[oddcount-k];\\r\\n            }              \\r\\n            mp[oddcount]++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3254182,
                "title": "two-pointer-solution-easy",
                "content": "\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nIn this solution we basically take 2 pointers (i and j). If the nums[j] is odd we increase the odd counter. If off is equal to k we count all the subarrays in between i and j by increasing i position till odd == k. We add the result in res.\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int i=0,j=0,odd=0,count=0,res=0;\\r\\n        while(j<nums.length){\\r\\n            if(nums[j]%2!=0){\\r\\n                odd++;\\r\\n                count=0;\\r\\n            }\\r\\n            while(odd==k){\\r\\n                if(nums[i++]%2!=0){\\r\\n                    odd--;\\r\\n                }\\r\\n                count++;\\r\\n            }\\r\\n            res+=count;\\r\\n            j++;\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int i=0,j=0,odd=0,count=0,res=0;\\r\\n        while(j<nums.length){\\r\\n            if(nums[j]%2!=0){\\r\\n                odd++;\\r\\n                count=0;\\r\\n            }\\r\\n            while(odd==k){\\r\\n                if(nums[i++]%2!=0){\\r\\n                    odd--;\\r\\n                }\\r\\n                count++;\\r\\n            }\\r\\n            res+=count;\\r\\n            j++;\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069091,
                "title": "simple-python-prefix-sum-and-hashmap-beats-90-single-pass",
                "content": "Extremely common pattern\\n\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        hashmap = defaultdict(int)\\n        odd_counts,res = 0,0\\n        hashmap[0] = 1\\n        for i in range(len(nums)):\\n            if nums[i]%2 != 0:\\n                odd_counts+=1\\n            res += hashmap[odd_counts-k]\\n            hashmap[odd_counts]+=1\\n        return res",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "Extremely common pattern\\n\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        hashmap = defaultdict(int)\\n        odd_counts,res = 0,0\\n        hashmap[0] = 1\\n        for i in range(len(nums)):\\n            if nums[i]%2 != 0:\\n                odd_counts+=1\\n            res += hashmap[odd_counts-k]\\n            hashmap[odd_counts]+=1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2814913,
                "title": "1248-count-number-of-nice-subarrays",
                "content": "class Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\t\\t#initially take these variables\\n        main_count=0\\n        temp_count=0\\n        start,end=0,0\\n        cur_subarray_count=0\\n\\t\\t\\n\\t\\t#A loop to move across whole length, ie taking window to the last\\n        while end < len(nums):\\n\\t\\t\\t#if current element is even we skip,else we increase temp_count or we can say presence of odd is encountered and added\\n            if nums[end] % 2 != 0 :\\n                temp_count += 1\\n\\t\\t\\t\\t#reset the sub_array_count\\n                cur_subarray_count=0\\n\\t\\t\\t\\t#once number of odds have become equal to k, we count number of subarrays within ie. cur_subarray_count\\n            while temp_count == k :\\n\\t\\t\\t#when an odd is encountered we reduce temp_count or the odd_count\\n                if nums[start] % 2 != 0:\\n                    temp_count -= 1\\n                cur_subarray_count+=1\\n\\t\\t\\t\\t#increment start to shrink the window\\n                start += 1\\n\\t\\t\\t#add number of sub_array count to main_count\\n            main_count += cur_subarray_count\\n            end += 1\\n        return main_count",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\t\\t#initially take these variables\\n        main_count=0\\n        temp_count=0\\n        start,end=0,0\\n        cur_subarray_count=0\\n\\t\\t\\n\\t\\t#A loop to move across whole length, ie taking window to the last\\n        while end < len(nums):\\n\\t\\t\\t#if current element is even we skip,else we increase temp_count or we can say presence of odd is encountered and added\\n            if nums[end] % 2 != 0 :\\n                temp_count += 1\\n\\t\\t\\t\\t#reset the sub_array_count\\n                cur_subarray_count=0\\n\\t\\t\\t\\t#once number of odds have become equal to k, we count number of subarrays within ie. cur_subarray_count\\n            while temp_count == k :\\n\\t\\t\\t#when an odd is encountered we reduce temp_count or the odd_count\\n                if nums[start] % 2 != 0:\\n                    temp_count -= 1\\n                cur_subarray_count+=1\\n\\t\\t\\t\\t#increment start to shrink the window\\n                start += 1\\n\\t\\t\\t#add number of sub_array count to main_count\\n            main_count += cur_subarray_count\\n            end += 1\\n        return main_count",
                "codeTag": "Java"
            },
            {
                "id": 2774830,
                "title": "python-prefix-sum-solution",
                "content": "```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\tremainders = []\\n\\trem = 0\\n\\tnum_subarray = 0\\n\\tfor num in nums:\\n\\t\\trem += num % 2\\n\\t\\tremainders.append(rem)\\n\\tprefix = {0: 1}\\n\\tfor remainder in remainders:\\n\\t\\tif remainder - k in prefix:\\n\\t\\t\\tnum_subarray += prefix[remainder - k]\\n\\t\\tif remainder not in prefix:\\n\\t\\t\\tprefix[remainder] =1\\n\\t\\telse:\\n\\t\\t\\tprefix[remainder] += 1\\n\\treturn num_subarray",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\tremainders = []\\n\\trem = 0\\n\\tnum_subarray = 0\\n\\tfor num in nums:\\n\\t\\trem += num % 2\\n\\t\\tremainders.append(rem)\\n\\tprefix = {0: 1}\\n\\tfor remainder in remainders:\\n\\t\\tif remainder - k in prefix:\\n\\t\\t\\tnum_subarray += prefix[remainder - k]\\n\\t\\tif remainder not in prefix:\\n\\t\\t\\tprefix[remainder] =1\\n\\t\\telse:\\n\\t\\t\\tprefix[remainder] += 1\\n\\treturn num_subarray",
                "codeTag": "Python3"
            },
            {
                "id": 2676369,
                "title": "simple-maths-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int numberOfSubarrays(vector<int> &nums, int k)\\n        {\\n\\n            long ans = 0;\\n            vector<int> vec;\\n            for (int end = 0; end < nums.size(); end++)\\n            {\\n                if ((nums[end] &1) == 1)\\n                    vec.push_back(end);\\n            }\\n            int start = 0;\\n            int end = k - 1;\\n            while (end < vec.size())\\n            {\\n\\n                int left, right;\\n                if (start == 0) left = vec[start];\\n                else left = vec[start] - vec[start - 1] - 1;\\n\\n                if (end == vec.size() - 1) right = nums.size() - vec[end] - 1;\\n                else right = vec[end + 1] - vec[end] - 1;\\n\\n                if (left + right == 0)\\n                    ans += 1;\\n                else\\n                    ans += (left + 1) *(right + 1);\\n\\n                start += 1;\\n                end += 1;\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int numberOfSubarrays(vector<int> &nums, int k)\\n        {\\n\\n            long ans = 0;\\n            vector<int> vec;\\n            for (int end = 0; end < nums.size(); end++)\\n            {\\n                if ((nums[end] &1) == 1)\\n                    vec.push_back(end);\\n            }\\n            int start = 0;\\n            int end = k - 1;\\n            while (end < vec.size())\\n            {\\n\\n                int left, right;\\n                if (start == 0) left = vec[start];\\n                else left = vec[start] - vec[start - 1] - 1;\\n\\n                if (end == vec.size() - 1) right = nums.size() - vec[end] - 1;\\n                else right = vec[end + 1] - vec[end] - 1;\\n\\n                if (left + right == 0)\\n                    ans += 1;\\n                else\\n                    ans += (left + 1) *(right + 1);\\n\\n                start += 1;\\n                end += 1;\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537180,
                "title": "c-solution-sliding-window",
                "content": "```\\nclass Solution {\\n  public:\\n    int numberOfSubarrays(vector < int > & nums, int k) {\\n      int ans = 0;\\n      int n = nums.size();\\n      int oddCount = 0;\\n      int slidingEnd = 0, slidingStart = 0;\\n      queue < int > q;\\n      while (slidingEnd < n) {\\n        if (nums[slidingEnd] % 2 != 0) {\\n          ++oddCount;\\n          q.push(slidingEnd);\\n        }\\n        if (oddCount > k) {\\n          while (oddCount != k) {\\n            if (nums[slidingStart] % 2 != 0) --oddCount;\\n            ++slidingStart;\\n          }\\n          q.pop();\\n        }\\n        if (oddCount == k) ans += (q.front() - slidingStart + 1);\\n        ++slidingEnd;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int numberOfSubarrays(vector < int > & nums, int k) {\\n      int ans = 0;\\n      int n = nums.size();\\n      int oddCount = 0;\\n      int slidingEnd = 0, slidingStart = 0;\\n      queue < int > q;\\n      while (slidingEnd < n) {\\n        if (nums[slidingEnd] % 2 != 0) {\\n          ++oddCount;\\n          q.push(slidingEnd);\\n        }\\n        if (oddCount > k) {\\n          while (oddCount != k) {\\n            if (nums[slidingStart] % 2 != 0) --oddCount;\\n            ++slidingStart;\\n          }\\n          q.pop();\\n        }\\n        if (oddCount == k) ans += (q.front() - slidingStart + 1);\\n        ++slidingEnd;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498838,
                "title": "java-solution-using-sliding-window-explained",
                "content": "**Upvote If this Helped You**\\n```\\n\\n// [2,2,2,1,2,2,1,2,2,2] k-2\\n// [0,1,2,3,4,5,6,7,8,9] -> index\\n\\n// when ws is at index 6 odd==k. So the number of sub array are 4 (0,6),(1,6),(2,6),(3,6) , cur_subcount=4\\n    \\n// no the cur_subcount come into play when ws=7 the subarray from 0->7 are (0,7),(1,7),(2,7),(3,7) =4\\n\\n// when ws=8 the subarray from 0->7 are (0,8),(1,8),(2,8),(3,8) =4,  ... and like this  upto ws=9\\n\\n// so total subarrays possible =4+4+4+4=16\\n\\nclass Solution \\n{\\n    public int numberOfSubarrays(int[] nums, int k) \\n    {\\n        int ws=0,we=0,ans=0,odd=0,cur_subcount=0;\\n        \\n        while(ws<nums.length)\\n        {\\n            if(nums[ws]%2!=0)\\n            {\\n                odd++;\\n                cur_subcount=0;\\n            }\\n            \\n             // time to reduce the window length and find the no. of subarrays\\n            \\n            while(odd==k)\\n            {\\n                if(nums[we]%2!=0)\\n                    odd--;\\n                \\n                cur_subcount+=1;\\n                we++;\\n            }\\n            \\n            ans+=cur_subcount;  // Total possible subarrays\\n            ws++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n\\n// [2,2,2,1,2,2,1,2,2,2] k-2\\n// [0,1,2,3,4,5,6,7,8,9] -> index\\n\\n// when ws is at index 6 odd==k. So the number of sub array are 4 (0,6),(1,6),(2,6),(3,6) , cur_subcount=4\\n    \\n// no the cur_subcount come into play when ws=7 the subarray from 0->7 are (0,7),(1,7),(2,7),(3,7) =4\\n\\n// when ws=8 the subarray from 0->7 are (0,8),(1,8),(2,8),(3,8) =4,  ... and like this  upto ws=9\\n\\n// so total subarrays possible =4+4+4+4=16\\n\\nclass Solution \\n{\\n    public int numberOfSubarrays(int[] nums, int k) \\n    {\\n        int ws=0,we=0,ans=0,odd=0,cur_subcount=0;\\n        \\n        while(ws<nums.length)\\n        {\\n            if(nums[ws]%2!=0)\\n            {\\n                odd++;\\n                cur_subcount=0;\\n            }\\n            \\n             // time to reduce the window length and find the no. of subarrays\\n            \\n            while(odd==k)\\n            {\\n                if(nums[we]%2!=0)\\n                    odd--;\\n                \\n                cur_subcount+=1;\\n                we++;\\n            }\\n            \\n            ans+=cur_subcount;  // Total possible subarrays\\n            ws++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170085,
                "title": "simple-java-solution-based-o-n-and-space-o-n-based-on-leetcode-560",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        int sum = 0, result = 0;\\n        for(int val: nums){\\n            sum += val%2;\\n            int d = sum - k;\\n            if(map.containsKey(d))\\n                result += map.get(d);\\n            map.put(sum, map.getOrDefault(sum, 0)+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        int sum = 0, result = 0;\\n        for(int val: nums){\\n            sum += val%2;\\n            int d = sum - k;\\n            if(map.containsKey(d))\\n                result += map.get(d);\\n            map.put(sum, map.getOrDefault(sum, 0)+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148579,
                "title": "permutation-based-c-solution-o-n-time-and-space",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) \\n    {\\n        int numberOfSubs = 0;\\n        std::vector<int> oddLocations;\\n        \\n        // add every odd number\\'s index to the oddLocations vector\\n\\t\\t// pad the beginning and ends of the oddLocations vector with \\'pseudo\\' locations \\n        oddLocations.push_back(-1);\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 != 0)\\n            {\\n                // the number is odd\\n                oddLocations.push_back(i);\\n            }\\n        }\\n        oddLocations.push_back(nums.size());\\n        \\n        int start = 1;\\n        int end = k;\\n        int rightEvens;\\n        int leftEvens;\\n\\t\\t// loop through the oddLocations and add the permutations of each k-odd number setup\\n        while(end < oddLocations.size() - 1)\\n        {\\n            numberOfSubs += (oddLocations[end + 1] - oddLocations[end]) * (oddLocations[start] - oddLocations[start - 1]);\\n            start++;\\n            end++;\\n        }\\n        \\n        return numberOfSubs;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) \\n    {\\n        int numberOfSubs = 0;\\n        std::vector<int> oddLocations;\\n        \\n        // add every odd number\\'s index to the oddLocations vector\\n\\t\\t// pad the beginning and ends of the oddLocations vector with \\'pseudo\\' locations \\n        oddLocations.push_back(-1);\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 != 0)\\n            {\\n                // the number is odd\\n                oddLocations.push_back(i);\\n            }\\n        }\\n        oddLocations.push_back(nums.size());\\n        \\n        int start = 1;\\n        int end = k;\\n        int rightEvens;\\n        int leftEvens;\\n\\t\\t// loop through the oddLocations and add the permutations of each k-odd number setup\\n        while(end < oddLocations.size() - 1)\\n        {\\n            numberOfSubs += (oddLocations[end + 1] - oddLocations[end]) * (oddLocations[start] - oddLocations[start - 1]);\\n            start++;\\n            end++;\\n        }\\n        \\n        return numberOfSubs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079386,
                "title": "c-using-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                nums[i] =0;\\n            }else{\\n                nums[i] = 1;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            if(mp.find(sum-k)!=mp.end()){\\n                ans+=mp[sum-k];\\n            }\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                nums[i] =0;\\n            }else{\\n                nums[i] = 1;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            if(mp.find(sum-k)!=mp.end()){\\n                ans+=mp[sum-k];\\n            }\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024075,
                "title": "go-solution-w-comments-diagram",
                "content": "```\\n/*\\nExample\\n\\nnums := []int{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}\\nk := 2\\n\\nAlgorithm: Sliding Window (2 pointers)\\n- Outer loop keeps incrementing window end until k odd numbers are found, every time an odd number is found we reset our nice count (case 1)\\n- If k odd numbers are found, in an inner loop, increment nice subbarrays and shift window start until an odd number is popped off (making oddCount < k)\\n- Finally, add the number of nice subarrays to the result (case 1 or case 2)\\n\\ncase1: add all the nice counted subarrays to the total count\\ncase2: encountered a new even number (regardless of the current odd count)\\n       so we need to add all previous nice counted subarrays (with the new even number appended) to the total count\\n\\t   \\ncase summary: \\nultimately add all nice counted subarrays found while oddcount >= k to the total, \\nthen after oddcount if < k, for each new number that is not an odd, add all the nice counted subarrays \\nto the total. If a new odd is encountered we reset the nice counted subarrays \\nbecause that is a new combination!\\n\\n\\nnums              | []int{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}\\n\\nouter-loop 00     | []int{2                           } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 01     | []int{2, 2                        } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 02     | []int{2, 2, 2                     } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 03     | []int{2, 2, 2, 1                  } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 04     | []int{2, 2, 2, 1, 2               } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 05     | []int{2, 2, 2, 1, 2, 2            } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 06     | []int{2, 2, 2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 0 result = 4 // see case 1\\n    inner-loop 00 | []int{   2, 2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 1 result = 0\\n    inner-loop 01 | []int{      2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 2 result = 0\\n    inner-loop 02 | []int{         1, 2, 2, 1         } | oddCount = 2, niceCount = 3 result = 0\\n    inner-loop 04 | []int{            2, 2, 1         } | oddCount = 1, niceCount = 4 result = 0\\nouter-loop 07     | []int{            2, 2, 1, 2      } | oddCount = 1, niceCount = 4 result = 8  (4 + 4) see case 2!\\nouter-loop 08     | []int{            2, 2, 1, 2, 2   } | oddCount = 1, niceCount = 4 result = 12 (8 + 4)\\nouter-loop 09     | []int{            2, 2, 1, 2, 2, 2} | oddCount = 1, niceCount = 4 result = 16 (12 + 4)\\n*/\\n\\nfunc numberOfSubarrays(nums []int, k int) int {\\n    totalCount := 0\\n    oddCount := 0 // keep track of odds to see if odds == k\\n    niceCount := 0 // keep track of current nice subarrays count (reset if a new odd number is found)\\n    \\n    start := 0\\n    for end := 0; end < len(nums); end++ { // outer-loop\\n        if nums[end] % 2 != 0 {\\n            oddCount++\\n            niceCount = 0 // new odd number encountered, reset the nice subarray count\\n        }\\n        \\n        for oddCount == k { // inner-loop\\n            niceCount++\\n            \\n            if nums[start] %2 != 0 {\\n                oddCount--\\n            }\\n            start++\\n        }\\n        \\n        // case 1: we just exited our inner-loop, and we want to add the number of nice subarrays to the total\\n        // case 2: we encountered no odd number, after a prior oddCount in the inner loop and\\n        // // must add the combination the even number added to all the previous nice subarrays.\\n        totalCount += niceCount\\n    }\\n    \\n    return totalCount\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/*\\nExample\\n\\nnums := []int{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}\\nk := 2\\n\\nAlgorithm: Sliding Window (2 pointers)\\n- Outer loop keeps incrementing window end until k odd numbers are found, every time an odd number is found we reset our nice count (case 1)\\n- If k odd numbers are found, in an inner loop, increment nice subbarrays and shift window start until an odd number is popped off (making oddCount < k)\\n- Finally, add the number of nice subarrays to the result (case 1 or case 2)\\n\\ncase1: add all the nice counted subarrays to the total count\\ncase2: encountered a new even number (regardless of the current odd count)\\n       so we need to add all previous nice counted subarrays (with the new even number appended) to the total count\\n\\t   \\ncase summary: \\nultimately add all nice counted subarrays found while oddcount >= k to the total, \\nthen after oddcount if < k, for each new number that is not an odd, add all the nice counted subarrays \\nto the total. If a new odd is encountered we reset the nice counted subarrays \\nbecause that is a new combination!\\n\\n\\nnums              | []int{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}\\n\\nouter-loop 00     | []int{2                           } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 01     | []int{2, 2                        } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 02     | []int{2, 2, 2                     } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 03     | []int{2, 2, 2, 1                  } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 04     | []int{2, 2, 2, 1, 2               } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 05     | []int{2, 2, 2, 1, 2, 2            } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 06     | []int{2, 2, 2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 0 result = 4 // see case 1\\n    inner-loop 00 | []int{   2, 2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 1 result = 0\\n    inner-loop 01 | []int{      2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 2 result = 0\\n    inner-loop 02 | []int{         1, 2, 2, 1         } | oddCount = 2, niceCount = 3 result = 0\\n    inner-loop 04 | []int{            2, 2, 1         } | oddCount = 1, niceCount = 4 result = 0\\nouter-loop 07     | []int{            2, 2, 1, 2      } | oddCount = 1, niceCount = 4 result = 8  (4 + 4) see case 2!\\nouter-loop 08     | []int{            2, 2, 1, 2, 2   } | oddCount = 1, niceCount = 4 result = 12 (8 + 4)\\nouter-loop 09     | []int{            2, 2, 1, 2, 2, 2} | oddCount = 1, niceCount = 4 result = 16 (12 + 4)\\n*/\\n\\nfunc numberOfSubarrays(nums []int, k int) int {\\n    totalCount := 0\\n    oddCount := 0 // keep track of odds to see if odds == k\\n    niceCount := 0 // keep track of current nice subarrays count (reset if a new odd number is found)\\n    \\n    start := 0\\n    for end := 0; end < len(nums); end++ { // outer-loop\\n        if nums[end] % 2 != 0 {\\n            oddCount++\\n            niceCount = 0 // new odd number encountered, reset the nice subarray count\\n        }\\n        \\n        for oddCount == k { // inner-loop\\n            niceCount++\\n            \\n            if nums[start] %2 != 0 {\\n                oddCount--\\n            }\\n            start++\\n        }\\n        \\n        // case 1: we just exited our inner-loop, and we want to add the number of nice subarrays to the total\\n        // case 2: we encountered no odd number, after a prior oddCount in the inner loop and\\n        // // must add the combination the even number added to all the previous nice subarrays.\\n        totalCount += niceCount\\n    }\\n    \\n    return totalCount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1950812,
                "title": "python-all-approaches-explained-with-notes-80-faster",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    Firstly I can think of a brute force approach that will have time complexity of O(n^3)\\n    The idea is to exhaust all the possible subarrays and then find the ones having k odd numbers\\n    if subarray has k odd numbers, add 1 to count\\n    The outer loop will signify the subarray ending at i\\n    The inner loop will signify the subarray starting at j\\n    The innermost loop will be used to calculate the number of odd terms in subarray nums[j..i]\\n    return the count\\n    \\n    Once I thought of above approach, we can try to remove the innermost loop by storing the \\n    number of odd numbers till nums[i] position in another array and use that array for lookup\\n    dp[i] will signify the number of odd numbers till nums[i]\\n    Then we can have the running time complexity of O(n^2)\\n    we need to find indexes where dp[i] - dp[j] == k where i ranges from 0 to len(nums) \\n    and j ranges from 0 to i\\n    \\n    Third approach:\\n    we can identify the number of subarrays in a single pass\\n    keep track of the indexes where odd no has occured.\\n    basically, we need to keep track of the first odd occurence (of the k odd numbers)\\n    and one previous to the first odd occurence (of the k odd numbers)\\n    example: 1 2 2 1 1 2 1\\n    k = 2\\n    we will start iterating, \\n    for i = 0, odd_indices = [0]\\n    for i = 1, odd_indices = [0]\\n    for i = 2, odd_indices = [0, 3]\\n        since len(odd_indices) == k:\\n        count+=1\\n    for i = 3, odd_indices = [0, 3, 4]\\n        since len(odd_indices) > k:\\n            update j = min(odd_indices) #j = 0\\n            odd_indices.pop(j)\\n            count += odd_indices[0] - j\\n    for i = 4, odd_indices = [3, 4]\\n        count += odd_indices[0] - j # 3 - 0\\n        \\n    for i = 5, odd_indices = [3, 4, 6]\\n        since len(odd_indices) > k:\\n            update j = min(odd_indices) # j= 3\\n            odd_indices.pop(j)\\n            count += odd_indices[0] - j # 4 - 3\\n    \"\"\"\\n    # O(n^3) approach\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums)+1)]\\n        for i in range(1, len(nums)+1):\\n            if nums[i-1] % 2 != 0:\\n                dp[i] = dp[i-1] + 1\\n            else:\\n                dp[i] = dp[i-1]\\n        count = 0\\n        for i in range(1, len(nums)+1):\\n            for j in range(1, i+1):\\n                if dp[i] - dp[j-1] == k:\\n                    count+=1\\n                elif dp[i] - dp[j-1] <k:\\n                    break\\n        return count\\n    \\n    #--------------------------\\n    # O(n^2) approach\\n    #---------------------------\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        odd_count_so_far = 0\\n        seen_k_odd = False\\n        for i in range(len(nums)):\\n            if nums[i] % 2 != 0:\\n                # nums[i] is odd then check the odd_count seen so far\\n                odd_count_so_far += 1\\n                if odd_count_so_far == k:\\n                    count = count + 1 \\n                elif odd_count_so_far > k:\\n                    \\n                if seen_k_odd:\\n                    count = count + odd_count_so_far\\n                if not seen_k_odd:\\n                    odd_count_so_far+=1\\n                    if odd_count_so_far == k:\\n                        count+=1\\n                        seen_k_odd = True\\n    \\n    #----------------------\\n    # O(n) approach\\n    #----------------------\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        j = -1\\n        odd_indices = []\\n        count = 0\\n        for i in range(len(nums)):\\n            if nums[i] % 2 != 0:\\n                odd_indices.append(i)\\n            if len(odd_indices) == k:\\n                count += odd_indices[0] - j\\n            elif len(odd_indices) > k:\\n                j = odd_indices[0]\\n                odd_indices.pop(0)\\n                count += odd_indices[0] - j\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    Firstly I can think of a brute force approach that will have time complexity of O(n^3)\\n    The idea is to exhaust all the possible subarrays and then find the ones having k odd numbers\\n    if subarray has k odd numbers, add 1 to count\\n    The outer loop will signify the subarray ending at i\\n    The inner loop will signify the subarray starting at j\\n    The innermost loop will be used to calculate the number of odd terms in subarray nums[j..i]\\n    return the count\\n    \\n    Once I thought of above approach, we can try to remove the innermost loop by storing the \\n    number of odd numbers till nums[i] position in another array and use that array for lookup\\n    dp[i] will signify the number of odd numbers till nums[i]\\n    Then we can have the running time complexity of O(n^2)\\n    we need to find indexes where dp[i] - dp[j] == k where i ranges from 0 to len(nums) \\n    and j ranges from 0 to i\\n    \\n    Third approach:\\n    we can identify the number of subarrays in a single pass\\n    keep track of the indexes where odd no has occured.\\n    basically, we need to keep track of the first odd occurence (of the k odd numbers)\\n    and one previous to the first odd occurence (of the k odd numbers)\\n    example: 1 2 2 1 1 2 1\\n    k = 2\\n    we will start iterating, \\n    for i = 0, odd_indices = [0]\\n    for i = 1, odd_indices = [0]\\n    for i = 2, odd_indices = [0, 3]\\n        since len(odd_indices) == k:\\n        count+=1\\n    for i = 3, odd_indices = [0, 3, 4]\\n        since len(odd_indices) > k:\\n            update j = min(odd_indices) #j = 0\\n            odd_indices.pop(j)\\n            count += odd_indices[0] - j\\n    for i = 4, odd_indices = [3, 4]\\n        count += odd_indices[0] - j # 3 - 0\\n        \\n    for i = 5, odd_indices = [3, 4, 6]\\n        since len(odd_indices) > k:\\n            update j = min(odd_indices) # j= 3\\n            odd_indices.pop(j)\\n            count += odd_indices[0] - j # 4 - 3\\n    \"\"\"\\n    # O(n^3) approach\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums)+1)]\\n        for i in range(1, len(nums)+1):\\n            if nums[i-1] % 2 != 0:\\n                dp[i] = dp[i-1] + 1\\n            else:\\n                dp[i] = dp[i-1]\\n        count = 0\\n        for i in range(1, len(nums)+1):\\n            for j in range(1, i+1):\\n                if dp[i] - dp[j-1] == k:\\n                    count+=1\\n                elif dp[i] - dp[j-1] <k:\\n                    break\\n        return count\\n    \\n    #--------------------------\\n    # O(n^2) approach\\n    #---------------------------\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        odd_count_so_far = 0\\n        seen_k_odd = False\\n        for i in range(len(nums)):\\n            if nums[i] % 2 != 0:\\n                # nums[i] is odd then check the odd_count seen so far\\n                odd_count_so_far += 1\\n                if odd_count_so_far == k:\\n                    count = count + 1 \\n                elif odd_count_so_far > k:\\n                    \\n                if seen_k_odd:\\n                    count = count + odd_count_so_far\\n                if not seen_k_odd:\\n                    odd_count_so_far+=1\\n                    if odd_count_so_far == k:\\n                        count+=1\\n                        seen_k_odd = True\\n    \\n    #----------------------\\n    # O(n) approach\\n    #----------------------\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        j = -1\\n        odd_indices = []\\n        count = 0\\n        for i in range(len(nums)):\\n            if nums[i] % 2 != 0:\\n                odd_indices.append(i)\\n            if len(odd_indices) == k:\\n                count += odd_indices[0] - j\\n            elif len(odd_indices) > k:\\n                j = odd_indices[0]\\n                odd_indices.pop(0)\\n                count += odd_indices[0] - j\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701501,
                "title": "java-o-n-sliding-window-clear-solution-similar-to-lc930-and-lc992",
                "content": "This question is similar to lc930 and lc992. Please upvote if you find it useful! Or leave comments or suggestions below!\\nI will try my best to answer them! Thank you so much!\\n\\n```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        return niceSubarraysAtMostK(nums, k) - niceSubarraysAtMostK(nums, k-1);\\n    }\\n    \\n    private int niceSubarraysAtMostK(int[] nums, int k) {\\n        int numOfOdd = 0, left = 0, right = 0;\\n        int numOfNiceArrays = 0;\\n        \\n        while (right < nums.length) {\\n            int rightNum = nums[right++];\\n            if ((rightNum & 1) == 1) numOfOdd++;\\n            \\n            while (left < right && numOfOdd > k) {\\n                int leftNum = nums[left++];\\n                if ((leftNum & 1) == 1) numOfOdd--;\\n            }\\n            \\n            numOfNiceArrays += (right - left);\\n        }\\n        \\n        return numOfNiceArrays;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        return niceSubarraysAtMostK(nums, k) - niceSubarraysAtMostK(nums, k-1);\\n    }\\n    \\n    private int niceSubarraysAtMostK(int[] nums, int k) {\\n        int numOfOdd = 0, left = 0, right = 0;\\n        int numOfNiceArrays = 0;\\n        \\n        while (right < nums.length) {\\n            int rightNum = nums[right++];\\n            if ((rightNum & 1) == 1) numOfOdd++;\\n            \\n            while (left < right && numOfOdd > k) {\\n                int leftNum = nums[left++];\\n                if ((leftNum & 1) == 1) numOfOdd--;\\n            }\\n            \\n            numOfNiceArrays += (right - left);\\n        }\\n        \\n        return numOfNiceArrays;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673709,
                "title": "python-easy-solution-using-the-concept-of-sliding-window-100-less-memory-usage",
                "content": "\\tdef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        \\n        # This is just converting the even number to 0 and odd numbers to 1 in the array\\n        for i in range(len(nums)):\\n            \\n            if nums[i] % 2 == 0:\\n                nums[i] = 0\\n            else:\\n                nums[i] = 1\\n                \\n        # Then doing exactly the same thing as subarray sum equal k problem\\n                \\n        currsum = 0\\n        subarray = 0\\n        hashmap = {}\\n        \\n        for num in nums:\\n            currsum += num\\n            \\n            if currsum == k:\\n                subarray += 1\\n            \\n            if currsum - k in hashmap:\\n                subarray += hashmap[currsum - k]\\n            \\n            if currsum in hashmap:\\n                hashmap[currsum] += 1\\n            \\n            else:\\n                hashmap[currsum] = 1\\n        \\n        return subarray\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "\\tdef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        \\n        # This is just converting the even number to 0 and odd numbers to 1 in the array\\n        for i in range(len(nums)):\\n            \\n            if nums[i] % 2 == 0:\\n                nums[i] = 0\\n            else:\\n                nums[i] = 1\\n                \\n        # Then doing exactly the same thing as subarray sum equal k problem\\n                \\n        currsum = 0\\n        subarray = 0\\n        hashmap = {}\\n        \\n        for num in nums:\\n            currsum += num\\n            \\n            if currsum == k:\\n                subarray += 1\\n            \\n            if currsum - k in hashmap:\\n                subarray += hashmap[currsum - k]\\n            \\n            if currsum in hashmap:\\n                hashmap[currsum] += 1\\n            \\n            else:\\n                hashmap[currsum] = 1\\n        \\n        return subarray\\n            \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1642587,
                "title": "javascript-solution",
                "content": "```\\nvar numberOfSubarrays = function(nums, k) {\\n    // similar to Question https://leetcode.com/problems/subarray-sum-equals-k/\\n   let map = new Map();\\n    map.set(0, 1);\\n    let sum = 0;\\n    let counter =0;\\n    let len = nums.length;\\n    for(let g=0; g<len; g++){\\n        let curNumModified = (nums[g] %2 == 0) ? 0 : 1;\\n        sum = sum + curNumModified;\\n        if( map.has(sum-k) ) counter = map.get(sum-k)  + counter;\\n        if(map.has(sum)) map.set(sum, map.get(sum) + 1);\\n        else map.set(sum, 1)\\n    }\\n    return counter\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfSubarrays = function(nums, k) {\\n    // similar to Question https://leetcode.com/problems/subarray-sum-equals-k/\\n   let map = new Map();\\n    map.set(0, 1);\\n    let sum = 0;\\n    let counter =0;\\n    let len = nums.length;\\n    for(let g=0; g<len; g++){\\n        let curNumModified = (nums[g] %2 == 0) ? 0 : 1;\\n        sum = sum + curNumModified;\\n        if( map.has(sum-k) ) counter = map.get(sum-k)  + counter;\\n        if(map.has(sum)) map.set(sum, map.get(sum) + 1);\\n        else map.set(sum, 1)\\n    }\\n    return counter\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600149,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int ws = 0,we = 0,c = 0,res = 0,n = nums.size(),odd = 0;\\n        while(we<n){\\n            if(nums[we]%2) odd++;\\n            while(odd>k){\\n                if(nums[ws]%2){\\n                    odd--;\\n                    c = 0;\\n                }\\n                ws++;\\n            }\\n            while(odd == k && nums[ws]%2 == 0){\\n                ws++;\\n                c++;\\n            }\\n            if(odd == k){\\n                res+=c+1;\\n            }\\n            we++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int ws = 0,we = 0,c = 0,res = 0,n = nums.size(),odd = 0;\\n        while(we<n){\\n            if(nums[we]%2) odd++;\\n            while(odd>k){\\n                if(nums[ws]%2){\\n                    odd--;\\n                    c = 0;\\n                }\\n                ws++;\\n            }\\n            while(odd == k && nums[ws]%2 == 0){\\n                ws++;\\n                c++;\\n            }\\n            if(odd == k){\\n                res+=c+1;\\n            }\\n            we++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374009,
                "title": "simple-java-solution",
                "content": "public int numberOfSubarrays(int[] nums, int k) {\\n        //sub array with at most K = subsrray with ATMOST(k) - subarray with ATMOST(k-1)\\n        int ans = func(nums,k) - func(nums,k-1);\\n        return ans;\\n    }\\n    \\n    public int func(int[] nums,int k){\\n        int left = 0;\\n        int ans = 0;\\n        \\n        for(int right=0;right<nums.length;right++){\\n            //subtract whenever we find a odd number, move the sliding window towards right\\n            if(nums[right]%2 != 0){\\n                k--;\\n            }\\n            \\n            //if subarray contains more than required odd numbers, move the array from left\\n            //till we have k odd elements\\n            while(k<0){\\n                if(nums[left]%2 != 0){\\n                    k++;\\n                }\\n                left++;\\n            }\\n            \\n            //will increase whenever we have atmost K odd numbers\\n            ans += right-left+1;\\n            \\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "public int numberOfSubarrays(int[] nums, int k) {\\n        //sub array with at most K = subsrray with ATMOST(k) - subarray with ATMOST(k-1)\\n        int ans = func(nums,k) - func(nums,k-1);\\n        return ans;\\n    }\\n    \\n    public int func(int[] nums,int k){\\n        int left = 0;\\n        int ans = 0;\\n        \\n        for(int right=0;right<nums.length;right++){\\n            //subtract whenever we find a odd number, move the sliding window towards right\\n            if(nums[right]%2 != 0){\\n                k--;\\n            }\\n            \\n            //if subarray contains more than required odd numbers, move the array from left\\n            //till we have k odd elements\\n            while(k<0){\\n                if(nums[left]%2 != 0){\\n                    k++;\\n                }\\n                left++;\\n            }\\n            \\n            //will increase whenever we have atmost K odd numbers\\n            ans += right-left+1;\\n            \\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1273805,
                "title": "simple-c-solution-using-two-pointers-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberofSubarraysAtmost(vector<int>nums,int k){\\n        int j=0,i=0,odd=0,count=0;\\n        int n=nums.size(); \\n        while(j<n){\\n            if(nums[j]%2!=0){odd++;}\\n            j++;\\n            while(i<j&&odd>k){\\n                \\n                if(nums[i]%2!=0)\\n                    odd--;\\n                i++;\\n            }\\n            count+=j-i;\\n        }\\n        return count;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return numberofSubarraysAtmost(nums,k)- numberofSubarraysAtmost(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberofSubarraysAtmost(vector<int>nums,int k){\\n        int j=0,i=0,odd=0,count=0;\\n        int n=nums.size(); \\n        while(j<n){\\n            if(nums[j]%2!=0){odd++;}\\n            j++;\\n            while(i<j&&odd>k){\\n                \\n                if(nums[i]%2!=0)\\n                    odd--;\\n                i++;\\n            }\\n            count+=j-i;\\n        }\\n        return count;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return numberofSubarraysAtmost(nums,k)- numberofSubarraysAtmost(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243550,
                "title": "sliding-window-approach",
                "content": "Firstly Convert the odd elements of array to 1 and even to 0.\\nThen follow the approach to find the no. of subarrays having sum equal to K\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& a, int k)\\n    {\\n        int i=0,j=0,s=0,cnt=0;\\n        while(j<a.size())\\n        {\\n            s=s+a[j];\\n            while(s>k)\\n            {\\n                s=s-a[i];\\n                i++;\\n            }\\n            cnt=cnt+(j-i+1);\\n            j++;\\n        }\\n    \\n        return cnt;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int>a;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n                a.push_back(0);\\n            else\\n                a.push_back(1);\\n        }\\n        return solve(a,k)-solve(a,k-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& a, int k)\\n    {\\n        int i=0,j=0,s=0,cnt=0;\\n        while(j<a.size())\\n        {\\n            s=s+a[j];\\n            while(s>k)\\n            {\\n                s=s-a[i];\\n                i++;\\n            }\\n            cnt=cnt+(j-i+1);\\n            j++;\\n        }\\n    \\n        return cnt;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int>a;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n                a.push_back(0);\\n            else\\n                a.push_back(1);\\n        }\\n        return solve(a,k)-solve(a,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928352,
                "title": "same-idea-as-count-subarrays-with-sum-k-560",
                "content": "```\\n# Same idea as count subarrays with sum k #560\\nfrom collections import defaultdict\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        arr = [1 if num % 2 else 0 for num in nums]\\n        cSum, ans = 0, 0\\n        mem = defaultdict(int)\\n        mem[0] = 1\\n        for i in range(len(nums)):\\n            cSum += arr[i]\\n            # print(cSum, cSum-k, mem, ans)\\n            if (cSum-k in mem):\\n                ans += mem[cSum-k]\\n            mem[cSum] += 1\\n        # print(arr)\\n        return ans",
                "solutionTags": [],
                "code": "```\\n# Same idea as count subarrays with sum k #560\\nfrom collections import defaultdict\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        arr = [1 if num % 2 else 0 for num in nums]\\n        cSum, ans = 0, 0\\n        mem = defaultdict(int)\\n        mem[0] = 1\\n        for i in range(len(nums)):\\n            cSum += arr[i]\\n            # print(cSum, cSum-k, mem, ans)\\n            if (cSum-k in mem):\\n                ans += mem[cSum-k]\\n            mem[cSum] += 1\\n        # print(arr)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 804977,
                "title": "java-sliding-window-with-explanation",
                "content": "The approach is to first find the largest subarray with \\'k\\' odd elements and count the number of subarrays that can be formed out of this.\\n1. Loop through the array and keep a count of odd numbers\\n2. Once the odd numbers exceed k (exceed because we need largest subarry with k odd elements), calculate the total number of subarrays that can be formed.\\neg: \\narray -> 2 2 2 1 2 1 2 2 1 2, k = 2\\nindex-> 0 1 2 3 4 5 6 7 8 9\\nThe first largest subarray with 2 odd elements is from index 0 to index 7. To calculate the total subarrays, find the total left and right elements before encountering odd number. In the above example lcount = 3 and rcount = 2. If you write down the list of all subarrays, you observe that the total subarrays is [lcount * (rcount + 1) + 1 + rcount]\\n```\\nclass Solution {\\n    int res;\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int left = 0, odd = 0, i = 0;\\n        res = 0;\\n        for (i=0;i<n;i++) {\\n            if (nums[i] % 2 == 1)\\n                odd++;\\n\\t\\t\\n            if (odd > k) {\\n                /* Got largest subarray with k odd elements */\\n\\t\\t\\t\\tleft = totSubarray(nums, left, i);\\n                odd--;\\n            }\\n        }\\n        \\n        if (odd == k)\\n            totSubarray(nums, left, i);\\n\\n        return res;\\n    }\\n    \\n    private int totSubarray(int[] a, int left, int i) {\\n        int lcount = 0, rcount = 0;\\n\\t\\t\\n\\t\\t/* Find number of even elements before start of odd */\\n        while (a[left++] % 2 == 0)\\n            lcount++;\\n\\t\\t\\n\\t\\t/* Find the number of even elements after k odd numbers */\\n        while (a[--i] % 2 == 0)\\n            rcount++;\\n\\t\\t\\n        res += lcount * (rcount + 1) + rcount + 1;\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res;\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int left = 0, odd = 0, i = 0;\\n        res = 0;\\n        for (i=0;i<n;i++) {\\n            if (nums[i] % 2 == 1)\\n                odd++;\\n\\t\\t\\n            if (odd > k) {\\n                /* Got largest subarray with k odd elements */\\n\\t\\t\\t\\tleft = totSubarray(nums, left, i);\\n                odd--;\\n            }\\n        }\\n        \\n        if (odd == k)\\n            totSubarray(nums, left, i);\\n\\n        return res;\\n    }\\n    \\n    private int totSubarray(int[] a, int left, int i) {\\n        int lcount = 0, rcount = 0;\\n\\t\\t\\n\\t\\t/* Find number of even elements before start of odd */\\n        while (a[left++] % 2 == 0)\\n            lcount++;\\n\\t\\t\\n\\t\\t/* Find the number of even elements after k odd numbers */\\n        while (a[--i] % 2 == 0)\\n            rcount++;\\n\\t\\t\\n        res += lcount * (rcount + 1) + rcount + 1;\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729535,
                "title": "java-sliding-window-mimic-o-n",
                "content": "```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        List<Integer> l = new ArrayList<>();\\n        int res = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] % 2 != 0) l.add(i);\\n        }\\n        for (int i = 0; i + k <= l.size(); i++) {\\n            int a = l.get(i) - (i == 0 ? -1 : l.get(i - 1)), b = ((i + k >= l.size()) ? n : l.get(i + k)) - l.get(i + k - 1);\\n            res += a * b;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        List<Integer> l = new ArrayList<>();\\n        int res = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] % 2 != 0) l.add(i);\\n        }\\n        for (int i = 0; i + k <= l.size(); i++) {\\n            int a = l.get(i) - (i == 0 ? -1 : l.get(i - 1)), b = ((i + k >= l.size()) ? n : l.get(i + k)) - l.get(i + k - 1);\\n            res += a * b;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719600,
                "title": "javascript-solution-o-n-time-o-n-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar numberOfSubarrays = function(nums, k) {\\n    const oddPrefixCount = new Map();\\n    \\n    oddPrefixCount.set(0, 1);\\n    let oddCount = 0;\\n    let result = 0;\\n    \\n    for (const num of nums) {\\n        if (num % 2 === 1) {\\n            oddCount++;\\n        }\\n        \\n        oddPrefixCount.set(oddCount, oddPrefixCount.get(oddCount) + 1 || 1);\\n        result += oddPrefixCount.has(oddCount - k) ? oddPrefixCount.get(oddCount - k) : 0;\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar numberOfSubarrays = function(nums, k) {\\n    const oddPrefixCount = new Map();\\n    \\n    oddPrefixCount.set(0, 1);\\n    let oddCount = 0;\\n    let result = 0;\\n    \\n    for (const num of nums) {\\n        if (num % 2 === 1) {\\n            oddCount++;\\n        }\\n        \\n        oddPrefixCount.set(oddCount, oddPrefixCount.get(oddCount) + 1 || 1);\\n        result += oddPrefixCount.has(oddCount - k) ? oddPrefixCount.get(oddCount - k) : 0;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 714812,
                "title": "smartest-approach-through-sliding-window",
                "content": "**exactly(nums,k)=atMost(nums,k)-atMost(nums,k-1)**\\nPlease upvote if you like the solution because it will help me to share more solutions\\n```\\n int atMost(vector<int>&nums,int k)\\n    {\\n        int n=nums.size();\\n        int l=0;\\n        int i=0;\\n        int subArray=0;\\n        int count=0;\\n        \\n        \\n        while(i<n)\\n        {\\n            count+=nums[i]%2;\\n            while(l<n&&count>k)\\n            {\\n                count-=nums[l]%2;\\n                l++;\\n                \\n            }\\n            if(count<=k)\\n            subArray+=(i-l+1);\\n            i++;\\n        }\\n       return subArray;\\n    }\\n    \\n    \\n    \\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMost(nums,k)-atMost(nums,k-1);\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "**exactly(nums,k)=atMost(nums,k)-atMost(nums,k-1)**\\nPlease upvote if you like the solution because it will help me to share more solutions\\n```\\n int atMost(vector<int>&nums,int k)\\n    {\\n        int n=nums.size();\\n        int l=0;\\n        int i=0;\\n        int subArray=0;\\n        int count=0;\\n        \\n        \\n        while(i<n)\\n        {\\n            count+=nums[i]%2;\\n            while(l<n&&count>k)\\n            {\\n                count-=nums[l]%2;\\n                l++;\\n                \\n            }\\n            if(count<=k)\\n            subArray+=(i-l+1);\\n            i++;\\n        }\\n       return subArray;\\n    }\\n    \\n    \\n    \\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMost(nums,k)-atMost(nums,k-1);\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 593249,
                "title": "c-single-pass-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, int>hm;\\n        \\n        int sum = 0, res = 0; hm[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            sum += (nums[i] % 2 == 0) ? 0 : 1;\\n            if(hm.find(sum-k) != hm.end())\\n                res += hm[sum-k];\\n            hm[sum]++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, int>hm;\\n        \\n        int sum = 0, res = 0; hm[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            sum += (nums[i] % 2 == 0) ? 0 : 1;\\n            if(hm.find(sum-k) != hm.end())\\n                res += hm[sum-k];\\n            hm[sum]++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545453,
                "title": "c-sliding-window",
                "content": "On each step we expand a right border of a subarray until there are less than k odd numbers.\\nIf we found exactly k numbers, add all subarrays to answer which is built by adding even numbers to the existing valid subarray.\\nThen consider subarray by removing the first item of a window.\\n```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n\\tint n = nums.size();\\n\\n\\tint i = 0, j = 0, m = 0, ans = 0;\\n\\n\\twhile(i < n){\\n\\t\\n\\t\\twhile(j < n && m < k)\\n\\t\\t\\tif(nums[j++] % 2)\\n\\t\\t\\t\\t++m;\\n\\n\\t\\tif(m == k){\\n\\t\\t\\t++ans;\\n\\n\\t\\t\\tint l = j;\\n\\n\\t\\t\\twhile(l < n && !(nums[l++] % 2))\\n\\t\\t\\t\\t++ans;\\n\\t\\t}\\n\\n\\t\\tif(nums[i++] % 2)\\n\\t\\t\\t--m;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n\\tint n = nums.size();\\n\\n\\tint i = 0, j = 0, m = 0, ans = 0;\\n\\n\\twhile(i < n){\\n\\t\\n\\t\\twhile(j < n && m < k)\\n\\t\\t\\tif(nums[j++] % 2)\\n\\t\\t\\t\\t++m;\\n\\n\\t\\tif(m == k){\\n\\t\\t\\t++ans;\\n\\n\\t\\t\\tint l = j;\\n\\n\\t\\t\\twhile(l < n && !(nums[l++] % 2))\\n\\t\\t\\t\\t++ans;\\n\\t\\t}\\n\\n\\t\\tif(nums[i++] % 2)\\n\\t\\t\\t--m;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481920,
                "title": "c",
                "content": "```\\npublic int NumberOfSubarrays(int[] nums, int k) {\\n\\tvar odds = new List<int>();\\n\\tfor (var i = 0; i < nums.Length; i++) {\\n\\t\\tif (nums[i] % 2 == 1) {\\n\\t\\t\\todds.Add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tvar n = odds.Count;\\n\\tif (n < k) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tvar count = 0;\\n\\tfor (var i = 0; i < n - k + 1; i++) {\\n\\t\\tvar left = i == 0 ? odds[0] + 1 : odds[i] - odds[i - 1];\\n\\t\\tvar right = i == n - k ? nums.Length - odds[n - 1] : odds[i + k] - odds[i + k - 1];\\n\\t\\tcount += left * right;\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumberOfSubarrays(int[] nums, int k) {\\n\\tvar odds = new List<int>();\\n\\tfor (var i = 0; i < nums.Length; i++) {\\n\\t\\tif (nums[i] % 2 == 1) {\\n\\t\\t\\todds.Add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tvar n = odds.Count;\\n\\tif (n < k) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tvar count = 0;\\n\\tfor (var i = 0; i < n - k + 1; i++) {\\n\\t\\tvar left = i == 0 ? odds[0] + 1 : odds[i] - odds[i - 1];\\n\\t\\tvar right = i == n - k ? nums.Length - odds[n - 1] : odds[i + k] - odds[i + k - 1];\\n\\t\\tcount += left * right;\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 422627,
                "title": "javascript-easy-to-understand-2-solutions-72ms",
                "content": "The first solution costs O(n) time and O(n) space.\\n\\n- Traversal the nums\\n\\t- treat each odd number as a split point\\n\\t- counting the odd number\\n\\t- save the count for every even part\\n- Loop to odd count and calculate the count of nice subarrays for every split point\\n\\n```js\\nconst numberOfSubarrays = (nums, k) => {\\n  let ret = 0;\\n  let even = new Uint16Array(nums.length + 1);\\n  let odd = 0;\\n  for (let i = 0; i < nums.length; ++i) {\\n    (nums[i] & 1) === 1 ? ++odd : ++even[odd];\\n  }\\n  for (let i = 0; i <= odd - k; ++i) {\\n    ret += even[i] + even[i + k] + 1 + even[i] * even[i + k];\\n  }\\n  return ret;\\n};\\n```\\n\\nThe second solution costs O(n) time and O(1) space.\\n\\n- Initial the sliding window\\n- Move the window forward and counting\\n\\n```\\nconst numberOfSubarrays = (nums, k) => {\\n  let ret = 0;\\n  for (let left = 0, right = 0, c = 1; right < nums.length; ++right) {\\n    k -= nums[right] & 1;\\n    (nums[left] & 1) === 0 && ++left && ++c;\\n    k === 0 && (ret += c);\\n    if (k < 0) {\\n      ++k;\\n      c = 1;\\n      while ((nums[++left] & 1) === 0) ++c;\\n      ret += c;\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst numberOfSubarrays = (nums, k) => {\\n  let ret = 0;\\n  let even = new Uint16Array(nums.length + 1);\\n  let odd = 0;\\n  for (let i = 0; i < nums.length; ++i) {\\n    (nums[i] & 1) === 1 ? ++odd : ++even[odd];\\n  }\\n  for (let i = 0; i <= odd - k; ++i) {\\n    ret += even[i] + even[i + k] + 1 + even[i] * even[i + k];\\n  }\\n  return ret;\\n};\\n```\n```\\nconst numberOfSubarrays = (nums, k) => {\\n  let ret = 0;\\n  for (let left = 0, right = 0, c = 1; right < nums.length; ++right) {\\n    k -= nums[right] & 1;\\n    (nums[left] & 1) === 0 && ++left && ++c;\\n    k === 0 && (ret += c);\\n    if (k < 0) {\\n      ++k;\\n      c = 1;\\n      while ((nums[++left] & 1) === 0) ++c;\\n      ret += c;\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066264,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        helper = [-1] + [i for i, el in enumerate(nums) if el % 2] + [len(nums)]\\n\\n        for i in range(1, len(helper) - k):\\n            ans += (helper[i] - helper[i - 1]) * (helper[i + k] - helper[i + k - 1])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        helper = [-1] + [i for i, el in enumerate(nums) if el % 2] + [len(nums)]\\n\\n        for i in range(1, len(helper) - k):\\n            ans += (helper[i] - helper[i - 1]) * (helper[i + k] - helper[i + k - 1])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720790,
                "title": "using-queue-python-explained",
                "content": "# Intuition\\r\\nIn your queue store the index of all odd elements.\\r\\nNow acc to question each subarray must have only k odd elements so we have to design our window limits such that there are only k odd\\r\\n**So what must be the boundaries?**\\r\\n`window start = curr Index`\\r\\n`atleast window End = min k odd from window start i.e q[k-1]`\\r\\nNow upto where we can extend the end of our window? Untill and unless we find next odd element index i.e q[k]\\r\\n`window maxLimit = q[k]`\\r\\nso the `no of subarrays which can be formed = window max Limit - atleast window end`\\r\\nand increment ur curr index\\r\\nif ur currIndex > q[0] -> pop out the index as we calculated all possible sub arrays for it\\r\\n\\r\\nNow the only base case here is what if the odd number sits at the end of the array so we can still make one subarray from it\\r\\n**so add len(arr) to queue at end and this will be the maxWindowLimit for the last subarray if possible**\\r\\n\\r\\nThis might not be the best solution space optimization wise but many sliding window problems for counting subarrays can be solved with similar pattern approach.\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        q = deque()\\r\\n        n = len(nums)\\r\\n        for i in range(len(nums)):\\r\\n            if nums[i] % 2 != 0:\\r\\n                q.append(i)\\r\\n        q.append(n) # for the subarray can be formed by odd ele at last index\\r\\n        i = 0\\r\\n        subarrays = 0\\r\\n        while len(q) > k:\\r\\n            minWindowLen = q[k-1]\\r\\n            nextWindow = q[k]\\r\\n            subarrays += nextWindow - minWindowLen\\r\\n            if i == q[0]:\\r\\n                q.popleft()\\r\\n            i += 1\\r\\n        return subarrays\\r\\n        \\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        q = deque()\\r\\n        n = len(nums)\\r\\n        for i in range(len(nums)):\\r\\n            if nums[i] % 2 != 0:\\r\\n                q.append(i)\\r\\n        q.append(n) # for the subarray can be formed by odd ele at last index\\r\\n        i = 0\\r\\n        subarrays = 0\\r\\n        while len(q) > k:\\r\\n            minWindowLen = q[k-1]\\r\\n            nextWindow = q[k]\\r\\n            subarrays += nextWindow - minWindowLen\\r\\n            if i == q[0]:\\r\\n                q.popleft()\\r\\n            i += 1\\r\\n        return subarrays\\r\\n        \\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578127,
                "title": "sliding-window-c-try-it",
                "content": "\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\nchange the array in binary array **1 for odd and 0 for even**.\\r\\nand try to find out number of subarray having sum equal to k.\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:O(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n\\r\\n    int solve(vector<int> arr,int k)\\r\\n    {\\r\\n      int n = arr.size();\\r\\n      int sum = 0,i = 0,j = 0;\\r\\n      int ans = 0;\\r\\n\\r\\n      while(j<n)\\r\\n      {\\r\\n         sum+=arr[j];\\r\\n\\r\\n         while(sum>k)\\r\\n         {\\r\\n            sum-=arr[i];\\r\\n            i++;\\r\\n         }\\r\\n\\r\\n         ans+=(j-i+1);\\r\\n         j++;\\r\\n      }\\r\\n\\r\\n      return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& arr, int k) {\\r\\n        \\r\\n        int n = arr.size();\\r\\n        for(int i = 0;i<n;i++)\\r\\n        arr[i] = (arr[i]%2) ? 1 : 0;\\r\\n\\r\\n        return solve(arr,k)-solve(arr,k-1);\\r\\n    }\\r\\n};\\r\\n```\\r\\n\\r\\n\\r\\n\\r\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n\\r\\n    int solve(vector<int> arr,int k)\\r\\n    {\\r\\n      int n = arr.size();\\r\\n      int sum = 0,i = 0,j = 0;\\r\\n      int ans = 0;\\r\\n\\r\\n      while(j<n)\\r\\n      {\\r\\n         sum+=arr[j];\\r\\n\\r\\n         while(sum>k)\\r\\n         {\\r\\n            sum-=arr[i];\\r\\n            i++;\\r\\n         }\\r\\n\\r\\n         ans+=(j-i+1);\\r\\n         j++;\\r\\n      }\\r\\n\\r\\n      return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& arr, int k) {\\r\\n        \\r\\n        int n = arr.size();\\r\\n        for(int i = 0;i<n;i++)\\r\\n        arr[i] = (arr[i]%2) ? 1 : 0;\\r\\n\\r\\n        return solve(arr,k)-solve(arr,k-1);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562667,
                "title": "c-queue-solution-sliding-window-short-code",
                "content": "\\tint numberOfSubarrays(vector<int>& nums, int k) {\\n\\t\\tqueue<int> q;\\n\\t\\tint count = 0 , start = -1;\\n\\n\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\tif(nums[i] % 2 == 1)q.push(i);\\n\\t\\t\\tif(q.size() > k){\\n\\t\\t\\t\\tstart = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif(q.size() == k)count += q.front()-start;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "\\tint numberOfSubarrays(vector<int>& nums, int k) {\\n\\t\\tqueue<int> q;\\n\\t\\tint count = 0 , start = -1;\\n\\n\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\tif(nums[i] % 2 == 1)q.push(i);\\n\\t\\t\\tif(q.size() > k){\\n\\t\\t\\t\\tstart = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif(q.size() == k)count += q.front()-start;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3562160,
                "title": "easy-to-understand-intuition-explained-with-visuals-prefix-contribution-technique",
                "content": "**INTUITION **\\n\\nso intuition is that to calculate number of subarrays we can built from the valid prefix subarray \\n**what do i mean by valid prefix subarray ?**\\nso a valid subarray is having exactly k odd elements ,\\nlets take an example \\n2 2 2 1 2 2 1 2 2 2 1 2 1    k=2\\nfirst valid subarray is\\n2 2 2 1 2 2 1\\nnow taking this as a prefix how many subarray we can built \\n2 2 2 1 2 2 1\\n2 2 2 1 2 2 1 2\\n2 2 2 1 2 2 1 2 2\\n2 2 2 1 2 2 1 2 2 2\\nthese all are valid subarrays we can built we the prefix\\nto calculate these subarrays recall a trick in which we have to find the number of subarrays starting from given index i  which is equal to **(n-i)**  n=>arr length\\nso we can  applying same concept here but instead of n we have to know the valid boundary\\n\\n**what do i mean by valid boundary ?**\\nconsider the above example we have built the  4 number of subarrays using 2 2 2 1 2 2 1 as a prefix now if i take **2 2 2 1 2 2 1** 2 2 2 1  this an subarray will it be valid , according to given condition we can take k(2) odd elements but in this subarray we have taken more than k elements so here we can say that whenever we have found the valid subarray after this we have to find a boundary which will be an index of first odd element after the valid subarray \\nint our eg 2 2 2 1 2 2 1 2 2 2 1 2 1  for prefix subarray  2 2 2 1 2 2 1 boundary will be 10\\nso number of subarrays we can built with this prefix is 10-6 (boundary-end index of valid subarray) which is 4 .\\nso doing this for one valid subarray we will simply shrink out window i++ OR startptr++ and then continue the above process\\n\\nTo find a boundary we can take a pointer which will find the first odd index after endptr\\n\\nYou can refer the image or dry run the solution yourself\\n**sorry for the handwriting**\\n\\n![image](https://assets.leetcode.com/users/images/2ac981c8-237e-4f83-b2dc-570e766e3674_1685037616.3853507.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a348518f-e96f-4d8e-9cc8-e72642fdb93f_1685037537.6457465.jpeg)\\n\\n```\\nclass Solution {\\npublic int numberOfSubarrays(int[] nums, int k) {\\nint ans=0;\\nint i=0,j=0;\\nint boundary=-1;\\nint n=0;\\nif(nums[0]%2!=0)n++;\\nwhile(j<nums.length){\\nif(n==k){\\nboundary=j+1;\\nwhile(boundary<nums.length && nums[boundary]%2==0)boundary++;\\n// System.out.println(ptr +\" : \"+j);\\nans+=(boundary-j);\\nif(nums[i]%2!=0)n--;\\ni++;\\n}else{\\nj++;\\nif(j==nums.length)break;\\nif(nums[j]%2!=0)n++;\\n}\\n}\\nreturn ans;\\n}\\n}\\n```\\n\\n**with using this prefix contribution approach u can solve this also**\\nhttps://leetcode.com/problems/vowels-of-all-substrings/\\n\\nIf i find more problems i will update here\\n\\n**I will like to know from you  in the comments if we can optimise this approach ?**\\n\\ncurrently its run time is 13 ms , it might vary for others\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int numberOfSubarrays(int[] nums, int k) {\\nint ans=0;\\nint i=0,j=0;\\nint boundary=-1;\\nint n=0;\\nif(nums[0]%2!=0)n++;\\nwhile(j<nums.length){\\nif(n==k){\\nboundary=j+1;\\nwhile(boundary<nums.length && nums[boundary]%2==0)boundary++;\\n// System.out.println(ptr +\" : \"+j);\\nans+=(boundary-j);\\nif(nums[i]%2!=0)n--;\\ni++;\\n}else{\\nj++;\\nif(j==nums.length)break;\\nif(nums[j]%2!=0)n++;\\n}\\n}\\nreturn ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219562,
                "title": "rust-implementation",
                "content": "# Approach\\r\\n- We iterate through all the numbers and increment the odd counter whenver we encounter odd number.\\r\\n- Once we encounter `k` odd numbers we incremenet the left pointer until we reach the first `odd` number during this process we subtract the odd number and count the number of even numbers.\\r\\n- Update the total with the number of even numbers. \\r\\n\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(1)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nimpl Solution {\\r\\n    pub fn number_of_subarrays(nums: Vec<i32>, k: i32) -> i32 {\\r\\n        let mut total = 0;\\r\\n        let mut odd = 0;\\r\\n        let mut count = 0;\\r\\n\\r\\n        let mut j = 0;\\r\\n        let is_odd = |x| x % 2 == 1;\\r\\n\\r\\n        for &num in nums.iter() {\\r\\n            if is_odd(num) {\\r\\n                odd += 1;\\r\\n                count = 0;\\r\\n            }\\r\\n\\r\\n            while odd == k {\\r\\n                if is_odd(nums[j]) {\\r\\n                    odd -= 1;\\r\\n                }\\r\\n                count += 1;\\r\\n                j += 1;\\r\\n            }\\r\\n            total += count;\\r\\n        }\\r\\n\\r\\n        total as i32\\r\\n    }\\r\\n}\\r\\n\\r\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\r\\nimpl Solution {\\r\\n    pub fn number_of_subarrays(nums: Vec<i32>, k: i32) -> i32 {\\r\\n        let mut total = 0;\\r\\n        let mut odd = 0;\\r\\n        let mut count = 0;\\r\\n\\r\\n        let mut j = 0;\\r\\n        let is_odd = |x| x % 2 == 1;\\r\\n\\r\\n        for &num in nums.iter() {\\r\\n            if is_odd(num) {\\r\\n                odd += 1;\\r\\n                count = 0;\\r\\n            }\\r\\n\\r\\n            while odd == k {\\r\\n                if is_odd(nums[j]) {\\r\\n                    odd -= 1;\\r\\n                }\\r\\n                count += 1;\\r\\n                j += 1;\\r\\n            }\\r\\n            total += count;\\r\\n        }\\r\\n\\r\\n        total as i32\\r\\n    }\\r\\n}\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189044,
                "title": "c-and-python-90-faster-code-hash-table-and-prefix-sum",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n**C++ Solution:-**\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int count = 0;\\r\\n        int sum = 0;\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            if(nums[i] % 2 == 1) nums[i] = 1;\\r\\n            else nums[i] = 0;\\r\\n        }\\r\\n        map<int, int> mpp;\\r\\n        mpp[0] = 1;\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            sum += nums[i];\\r\\n            mpp[sum]++;\\r\\n            count += mpp[sum-k];\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n```\\r\\n**Python Solution:-**\\r\\n```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        for i in range(len(nums)):\\r\\n            if nums[i] % 2 == 1:\\r\\n                nums[i] = 1\\r\\n            else:\\r\\n                nums[i] = 0\\r\\n        hashmap = {}\\r\\n        hashmap[0] = 1\\r\\n        sums = 0\\r\\n        count = 0\\r\\n        for i in range(len(nums)):\\r\\n            sums += nums[i]\\r\\n            if sums not in hashmap.keys():\\r\\n                hashmap[sums] = 1\\r\\n            else:\\r\\n                hashmap[sums] += 1\\r\\n            if sums - k in hashmap:\\r\\n                count += hashmap[sums-k]\\r\\n        return count\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int count = 0;\\r\\n        int sum = 0;\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            if(nums[i] % 2 == 1) nums[i] = 1;\\r\\n            else nums[i] = 0;\\r\\n        }\\r\\n        map<int, int> mpp;\\r\\n        mpp[0] = 1;\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            sum += nums[i];\\r\\n            mpp[sum]++;\\r\\n            count += mpp[sum-k];\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n```\n```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        for i in range(len(nums)):\\r\\n            if nums[i] % 2 == 1:\\r\\n                nums[i] = 1\\r\\n            else:\\r\\n                nums[i] = 0\\r\\n        hashmap = {}\\r\\n        hashmap[0] = 1\\r\\n        sums = 0\\r\\n        count = 0\\r\\n        for i in range(len(nums)):\\r\\n            sums += nums[i]\\r\\n            if sums not in hashmap.keys():\\r\\n                hashmap[sums] = 1\\r\\n            else:\\r\\n                hashmap[sums] += 1\\r\\n            if sums - k in hashmap:\\r\\n                count += hashmap[sums-k]\\r\\n        return count\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156558,
                "title": "python-sliding-window-with-comments-for-explanation",
                "content": "```python\\nclass Solution:\\n\\tdef numberOfSubarrays(self, arr, k):\\n\\t\\t# the difference gives the exact K elements count\\n\\t\\treturn self.atMostKElements(arr, k) - self.atMostKElements(arr, k-1)\\n\\n\\tdef atMostKElements(self, arr, k):\\n\\t\\ti, j = 0, 0\\n\\t\\tres, curr_window_count = 0, 0\\n\\t\\tfor j in range(len(arr)):\\n\\t\\t\\t# the {condition} which increases the curr_window_count. Different for different problems\\n\\t\\t\\tif arr[j]%2 != 0: curr_window_count += 1\\n\\n\\t\\t\\t# check if the window is valid. If its invalid, make it valid by shortening the left pointer.\\n\\t\\t\\t# Valid is when curr_window_count <= k (at most K elements)\\n\\t\\t\\tif curr_window_count > k:\\n\\t\\t\\t\\twhile curr_window_count > k:\\n\\t\\t\\t\\t\\t# this condition will be specific to the problem\\n\\t\\t\\t\\t\\tif arr[i]%2 != 0: curr_window_count -= 1\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\t# total nos of elements in the valid window is added to the res. \\n\\t\\t\\t# eg: [1, 2, 3], if this is the valid window, then [3], [2,3], [1,2,3] are all valid for solving at most K elements problem.\\n\\t\\t\\tres += j-i+1\\n\\t\\t\\tj += 1\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n\\tdef numberOfSubarrays(self, arr, k):\\n\\t\\t# the difference gives the exact K elements count\\n\\t\\treturn self.atMostKElements(arr, k) - self.atMostKElements(arr, k-1)\\n\\n\\tdef atMostKElements(self, arr, k):\\n\\t\\ti, j = 0, 0\\n\\t\\tres, curr_window_count = 0, 0\\n\\t\\tfor j in range(len(arr)):\\n\\t\\t\\t# the {condition} which increases the curr_window_count. Different for different problems\\n\\t\\t\\tif arr[j]%2 != 0: curr_window_count += 1\\n\\n\\t\\t\\t# check if the window is valid. If its invalid, make it valid by shortening the left pointer.\\n\\t\\t\\t# Valid is when curr_window_count <= k (at most K elements)\\n\\t\\t\\tif curr_window_count > k:\\n\\t\\t\\t\\twhile curr_window_count > k:\\n\\t\\t\\t\\t\\t# this condition will be specific to the problem\\n\\t\\t\\t\\t\\tif arr[i]%2 != 0: curr_window_count -= 1\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\t# total nos of elements in the valid window is added to the res. \\n\\t\\t\\t# eg: [1, 2, 3], if this is the valid window, then [3], [2,3], [1,2,3] are all valid for solving at most K elements problem.\\n\\t\\t\\tres += j-i+1\\n\\t\\t\\tj += 1\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088675,
                "title": "easy-sliding-widow-beats-100",
                "content": "\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        odd_count = 0\\r\\n        res = 0\\r\\n        i = 0\\r\\n        count = 0\\r\\n        for ele in nums:\\r\\n            if ele % 2 == 1:\\r\\n                odd_count += 1\\r\\n                count = 0\\r\\n\\r\\n            while odd_count==k:\\r\\n                if nums[i] % 2 == 1:\\r\\n                    odd_count -= 1\\r\\n                i += 1\\r\\n                count += 1\\r\\n                \\r\\n            res += count\\r\\n        return res\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        odd_count = 0\\r\\n        res = 0\\r\\n        i = 0\\r\\n        count = 0\\r\\n        for ele in nums:\\r\\n            if ele % 2 == 1:\\r\\n                odd_count += 1\\r\\n                count = 0\\r\\n\\r\\n            while odd_count==k:\\r\\n                if nums[i] % 2 == 1:\\r\\n                    odd_count -= 1\\r\\n                i += 1\\r\\n                count += 1\\r\\n                \\r\\n            res += count\\r\\n        return res\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059350,
                "title": "c-sliding-window",
                "content": "\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach : Suffix sum, Sliding Window\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(n)$$ \\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n- Credit : [https://leetcode.com/TusharBhart/]()\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& vec, int k) {\\r\\n        vector<int> duri(vec.size() + 1);\\r\\n        duri[duri.size() - 1] = 1;\\r\\n        int distance = 1;\\r\\n        for(int i=vec.size()-1;i>=0;i--) {\\r\\n            vec[i] % 2 ? distance = 1 : distance++;\\r\\n            duri[i] = distance;\\r\\n        }\\r\\n        int i = 0;\\r\\n        int count = 0;\\r\\n        for(int j=0;j<vec.size();j++) {\\r\\n            if(vec[j] % 2) k--;\\r\\n            while(k == 0) {\\r\\n                count += duri[j + 1];\\r\\n                if(vec[i] % 2) k++;\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window",
                    "Suffix Array"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& vec, int k) {\\r\\n        vector<int> duri(vec.size() + 1);\\r\\n        duri[duri.size() - 1] = 1;\\r\\n        int distance = 1;\\r\\n        for(int i=vec.size()-1;i>=0;i--) {\\r\\n            vec[i] % 2 ? distance = 1 : distance++;\\r\\n            duri[i] = distance;\\r\\n        }\\r\\n        int i = 0;\\r\\n        int count = 0;\\r\\n        for(int j=0;j<vec.size();j++) {\\r\\n            if(vec[j] % 2) k--;\\r\\n            while(k == 0) {\\r\\n                count += duri[j + 1];\\r\\n                if(vec[i] % 2) k++;\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041835,
                "title": "prefix-sum-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int n = a.size();\\n        int res=0;\\n        vector<int> temp(n);\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            temp[i] = a[i]%2;\\n        }\\n        \\n        long long  sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=temp[i];\\n            int t = sum-k;\\n            if(mp.count(t))\\n            {\\n                res+=mp[t];  \\n            }\\n            mp[sum]++;\\n        }\\n       \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int n = a.size();\\n        int res=0;\\n        vector<int> temp(n);\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            temp[i] = a[i]%2;\\n        }\\n        \\n        long long  sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=temp[i];\\n            int t = sum-k;\\n            if(mp.count(t))\\n            {\\n                res+=mp[t];  \\n            }\\n            mp[sum]++;\\n        }\\n       \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879199,
                "title": "c-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint numberOfSubarrays(int* nums, int numsSize, int k){\\n\\n    int count[50001]={0};\\n    int i; \\n    count[0]=1;\\n    int curr=0,ans=0;\\n    for(i=0;i<numsSize; i++) {\\n        curr += nums[i]%2;\\n        if(curr-k >=0) ans += count[curr-k];\\n        count[curr]++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numberOfSubarrays(int* nums, int numsSize, int k){\\n\\n    int count[50001]={0};\\n    int i; \\n    count[0]=1;\\n    int curr=0,ans=0;\\n    for(i=0;i<numsSize; i++) {\\n        curr += nums[i]%2;\\n        if(curr-k >=0) ans += count[curr-k];\\n        count[curr]++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2718006,
                "title": "python3-prefix-sum-with-visual-explanation-o-n-space-o-n-time-complexity",
                "content": "# Introduction\\nThe problem can be easily solved by using prefix sum. But before that lets see one test case for better understanding of what we will be doing soon.\\n\\n**Testcase1:**  `nums = [2,2,2,1,2,2,1,2,2,2]`, `k=2`\\n\\n![image](https://assets.leetcode.com/users/images/346c2863-37ed-42b9-9d7e-559ea2372f9e_1666089692.9253418.png)\\n\\nThe steps are:\\n\\n1.  Calculate `prefixSum` of the array `nums` after first replacing even numbers with zero and odd numbers with 1.\\n2.  Finding the first smallest nice sub-array (sub-array with exactly `k` odd numbers).\\n3.  Count zeroes to the left of this sub-array in the prefix sum and add one.\\n4.  Number of nice sub-arrays is to multiply the counted result with the number of 2\\'s in the sum.\\n\\n**Caution:** This is just a specific solution, not a general solution. It is only used to show the main step of solving the problem.\\n\\n# Algorithm\\nThe algorithm is as simple as devising a general procedure from the above steps. The general case can be repeating the above steps in every next smallest nice sub-arrays found with some modifications.\\n1.  Calculate `prefixSum` of the array `nums` after first replacing even numbers with zero and odd numbers with 1.\\n2.  Instantiate a hashmap or python dictionary with a default key 0 and value 1. We will use it to count the number of even numbers that can be added to the smallest sub-array in both sides the same as 0\\'s and 2\\'s that we counted in the aforementioned example.\\n3.  Instantiate a variable `result` to zero to follow the sum of the total nice sub-arrays.\\n4.  Iterate over `prefixSum` and for every number in the array:\\n\\t* Insert the number in the dictonary as a key and the number by which it exists as a value.\\n\\t* If that number minus `k` is already in the dictionary, that means we have found an even number in the original array `nums` that can be added to the smallest nice sub-array. The analogue to this is finding 0\\'s and counting them along with the the 2\\'s in the above example because `2-0 = k = 2`, in general. We will continuously register the sum of the value of this number (as a key) in the dictionary to a `result`.\\n5. Return this `result`.\\n\\n# Implementation\\nThe implementation, I think, is a piece of cake after the algorithm. I will implement it using Python 3.\\n\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        prefixSum = [1 if n & 1 else 0 for n in nums]\\n        for idx in range(len(nums)):\\n            prefixSum[idx] += prefixSum[idx-1] if idx-1 >= 0 else 0\\n        result = 0\\n        dic = {0: 1}\\n        for num in prefixSum:\\n            if num - k in dic:\\n                result += dic[num-k]\\n            dic[num] = dic.get(num, 0) + 1\\n        return result\\n```\\n\\n**Explanations:**\\n* `num & 1` in the above code is a bitwise operation of checking whether a number is odd or not. Every even number ends in 0 and every odd number ends in 1, when written in binary. So what the expression basically doing is that performing a bitwise & operation on both the number at large and 1. It is faster than the usual `num % 2`. For more information please check out these links: \\n\\t[What does this boolean \"(number & 1) == 0\" mean?](https://stackoverflow.com/a/14905686/16271123)\\n\\t[Is & faster than % when checking for odd numbers?](https://stackoverflow.com/a/1089945/16271123) \\n*  `dic[num] = dic.get(num, 0) + 1` is a pythonic way of inserting a `key, value` pair in a dictionary if the `key` does not exist or adding one to the `value` if it is present.\\n\\n# Analysis\\n* **Space Complexity:** We have used `prefixSum`, `result` and `dic` variables which at most count for **O(n)** space.\\n* **Time Complexity:** We have used one list comprehension with O(n) and two for loops each with O(n) complexity, resulting in overall **O(3n)** = **O(n)** time complexity.\\n\\nThank you.\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        prefixSum = [1 if n & 1 else 0 for n in nums]\\n        for idx in range(len(nums)):\\n            prefixSum[idx] += prefixSum[idx-1] if idx-1 >= 0 else 0\\n        result = 0\\n        dic = {0: 1}\\n        for num in prefixSum:\\n            if num - k in dic:\\n                result += dic[num-k]\\n            dic[num] = dic.get(num, 0) + 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677783,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0) nums[i]=0;\\n            else nums[i]=1;\\n        }\\n        int [] arr=new int[n+1];\\n        arr[0]=1;\\n        int sum=0;\\n        int ans=0;\\n        for(int num:nums){\\n            sum+=num;\\n            if(sum>=k)  ans+=arr[sum-k];\\n            arr[sum]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0) nums[i]=0;\\n            else nums[i]=1;\\n        }\\n        int [] arr=new int[n+1];\\n        arr[0]=1;\\n        int sum=0;\\n        int ans=0;\\n        for(int num:nums){\\n            sum+=num;\\n            if(sum>=k)  ans+=arr[sum-k];\\n            arr[sum]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637002,
                "title": "a-python-solution-runtime-810-ms-faster-than-97-95-of-python3-online-submissions",
                "content": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n    \\n## Runtime: 810 ms, faster than 97.95% of Python3 online submissions for Count Number of Nice Subarrays.\\n## Memory Usage: 20.9 MB, less than 39.29% of Python3 online submissions for Count Number of Nice Subarrays.\\n        positions = [i for i,num in enumerate(nums) if num%2==1]\\n        posLength, numsLength, count = len(positions), len(nums), 0\\n        left, right = [], []\\n        \\n        if posLength<k:\\n            return count # 0\\n        elif posLength>k:\\n            for i in range(posLength-k):\\n                left.append(positions[i+1] - positions[i])\\n                right.append(positions[i+k] - positions[i+k-1])\\n        \\n        left = [positions[0]+1] + left\\n        right = right + [numsLength-positions[-1]] \\n        count = sum([i*j for i,j in zip(left, right)])\\n        \\n        return count\\n``` \\n## **Test cases**\\n```\\n[1,1,2,1,1]\\n3\\n[2,4,6]\\n1\\n[2,2,2,1,2,2,1,2,2,2]\\n2\\n[1,1,1,1,1]\\n1\\n[91473,45388,24720,35841,29648,77363,86290,58032,53752,87188,34428,85343,19801,73201]\\n4\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n    \\n## Runtime: 810 ms, faster than 97.95% of Python3 online submissions for Count Number of Nice Subarrays.\\n## Memory Usage: 20.9 MB, less than 39.29% of Python3 online submissions for Count Number of Nice Subarrays.\\n        positions = [i for i,num in enumerate(nums) if num%2==1]\\n        posLength, numsLength, count = len(positions), len(nums), 0\\n        left, right = [], []\\n        \\n        if posLength<k:\\n            return count # 0\\n        elif posLength>k:\\n            for i in range(posLength-k):\\n                left.append(positions[i+1] - positions[i])\\n                right.append(positions[i+k] - positions[i+k-1])\\n        \\n        left = [positions[0]+1] + left\\n        right = right + [numsLength-positions[-1]] \\n        count = sum([i*j for i,j in zip(left, right)])\\n        \\n        return count\\n```\n```\\n[1,1,2,1,1]\\n3\\n[2,4,6]\\n1\\n[2,2,2,1,2,2,1,2,2,2]\\n2\\n[1,1,1,1,1]\\n1\\n[91473,45388,24720,35841,29648,77363,86290,58032,53752,87188,34428,85343,19801,73201]\\n4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602583,
                "title": "python-simple-solution",
                "content": "\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        start=0\\n        odd_count,curr_sub_count=0,0\\n        ans=0\\n        for end in range(len(nums)):\\n            if nums[end]%2==1:\\n                odd_count+=1\\n                curr_sub_count=0\\n            while odd_count==k:\\n                curr_sub_count+=1\\n                if nums[start]%2==1:\\n                    odd_count-=1\\n                start+=1\\n            ans+=curr_sub_count\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        start=0\\n        odd_count,curr_sub_count=0,0\\n        ans=0\\n        for end in range(len(nums)):\\n            if nums[end]%2==1:\\n                odd_count+=1\\n                curr_sub_count=0\\n            while odd_count==k:\\n                curr_sub_count+=1\\n                if nums[start]%2==1:\\n                    odd_count-=1\\n                start+=1\\n            ans+=curr_sub_count\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2583542,
                "title": "c-99-faster-than-all-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int l = -1, r, pre, n = nums.size(), perms = 0;\\n\\t\\t\\n\\t\\t// double-ended queue performs better than list or hash here\\n        deque<int> odds;\\n        \\n\\t\\t// pre-load to avoid size check later\\n        for (r = 0; r < n; r++) {\\n            if (nums[r] % 2) {\\n                odds.push_back(r);\\n                if (odds.size() == k) {\\n                    perms = pre = odds.front() - l;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// only perform ops when we find odd\\n        while (++r < n) {\\n            if (nums[r] % 2) {\\n                perms += pre * (r - odds.back() - 1);\\n                odds.push_back(r);\\n                l = odds.front();\\n                odds.pop_front();\\n                pre = odds.front() - l;\\n                perms += pre;\\n            }\\n        }\\n        \\n\\t\\t// catch the trailing permutations\\n        if (perms) {\\n            perms += pre * (n - odds.back() - 1);\\n        }\\n        \\n        return perms;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int l = -1, r, pre, n = nums.size(), perms = 0;\\n\\t\\t\\n\\t\\t// double-ended queue performs better than list or hash here\\n        deque<int> odds;\\n        \\n\\t\\t// pre-load to avoid size check later\\n        for (r = 0; r < n; r++) {\\n            if (nums[r] % 2) {\\n                odds.push_back(r);\\n                if (odds.size() == k) {\\n                    perms = pre = odds.front() - l;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2567350,
                "title": "cpp-solution-variation-count-of-subarray-with-k-sum",
                "content": "\\n\\n     int numberOfSubarrays(vector<int>& nums, int k) {\\n        /*Simply Traverse through the array and check\\n           1) if nums[i] is odd or even if its odd then update nums[i] as 1 ans if its even then 0 \\n           Now the question become Count of subarray with given sum.......*/\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]%2!=0)\\n                nums[i]=1;\\n            else\\n                nums[i]=0;\\n        }\\n        // Count of subarray with given sum.\\n        unordered_map<int,int> mp;\\n        int presum=0,count=0;\\n        for(auto x: nums)\\n        {\\n            presum+=x;\\n            if(presum==k) count++;\\n            if(mp.find(presum-k)!=mp.end())\\n                count+=mp[presum-k];\\n            mp[presum]++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n     int numberOfSubarrays(vector<int>& nums, int k) {\\n        /*Simply Traverse through the array and check\\n           1) if nums[i] is odd or even if its odd then update nums[i] as 1 ans if its even then 0 \\n           Now the question become Count of subarray with given sum.......*/\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]%2!=0)\\n                nums[i]=1;\\n            else\\n                nums[i]=0;\\n        }\\n        // Count of subarray with given sum.\\n        unordered_map<int,int> mp;\\n        int presum=0,count=0;\\n        for(auto x: nums)\\n        {\\n            presum+=x;\\n            if(presum==k) count++;\\n            if(mp.find(presum-k)!=mp.end())\\n                count+=mp[presum-k];\\n            mp[presum]++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2515043,
                "title": "c-code-using-precomputation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int n = a.size();\\n        vector<int>left(n,0);\\n        vector<int>right(n,0);\\n        int c = 0;\\n        for(int i=0;i<n;i++) {\\n            if(a[i]%2==0) c++;\\n            else {right[i]=c; c=0;}\\n        }\\n        c = 0;\\n        for(int i=n-1;i>=0;i--) {\\n            if(a[i]%2==0) c++;\\n            else {left[i]=c; c=0;}\\n        }\\n        // for(int i=0;i<n;i++) cout<<left[i]<<\" \";\\n        // cout<<endl;\\n        // for(int i=0;i<n;i++) cout<<right[i]<<\" \";\\n        \\n        int i = 0;\\n        int j = 0;\\n        int x = 0;\\n        int ans = 0;\\n        while(j<n) {\\n            if(j<n && a[j]%2!=0) x++;\\n            if(x>k) {\\n                while(x>k) {\\n                    if(i<n && a[i]%2!=0) x--;\\n                    i++;\\n                }\\n            }\\n            else if(x==k) {\\n                while(i<n && a[i]%2==0) {\\n                    i++;\\n                }\\n                cout<<ans<<\" \";\\n                ans+=(right[i]+1)*(left[j]+1);\\n                if(a[i]%2!=0) x--;\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int n = a.size();\\n        vector<int>left(n,0);\\n        vector<int>right(n,0);\\n        int c = 0;\\n        for(int i=0;i<n;i++) {\\n            if(a[i]%2==0) c++;\\n            else {right[i]=c; c=0;}\\n        }\\n        c = 0;\\n        for(int i=n-1;i>=0;i--) {\\n            if(a[i]%2==0) c++;\\n            else {left[i]=c; c=0;}\\n        }\\n        // for(int i=0;i<n;i++) cout<<left[i]<<\" \";\\n        // cout<<endl;\\n        // for(int i=0;i<n;i++) cout<<right[i]<<\" \";\\n        \\n        int i = 0;\\n        int j = 0;\\n        int x = 0;\\n        int ans = 0;\\n        while(j<n) {\\n            if(j<n && a[j]%2!=0) x++;\\n            if(x>k) {\\n                while(x>k) {\\n                    if(i<n && a[i]%2!=0) x--;\\n                    i++;\\n                }\\n            }\\n            else if(x==k) {\\n                while(i<n && a[i]%2==0) {\\n                    i++;\\n                }\\n                cout<<ans<<\" \";\\n                ans+=(right[i]+1)*(left[j]+1);\\n                if(a[i]%2!=0) x--;\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2488311,
                "title": "java-prefix-sum",
                "content": "```\\npublic int numberOfSubarrays(int[] nums, int k) {\\n        if(nums == null || nums.length == 0) return 0;\\n\\n        Map<Integer, Integer> sumFrequency = new HashMap<>();\\n        sumFrequency.put(0, 1);\\n\\n        for(int i=0; i < nums.length; i++)\\n            nums[i] = (nums[i] & 1) == 1 ? 1 : 0;\\n\\n        int prefixSum = 0, count = 0;\\n        for (int num : nums) {\\n            prefixSum += num;\\n            sumFrequency.put(prefixSum, sumFrequency.getOrDefault(prefixSum, 0) + 1);\\n\\n            if (sumFrequency.containsKey(prefixSum - k))\\n                count += sumFrequency.get(prefixSum - k);\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int numberOfSubarrays(int[] nums, int k) {\\n        if(nums == null || nums.length == 0) return 0;\\n\\n        Map<Integer, Integer> sumFrequency = new HashMap<>();\\n        sumFrequency.put(0, 1);\\n\\n        for(int i=0; i < nums.length; i++)\\n            nums[i] = (nums[i] & 1) == 1 ? 1 : 0;\\n\\n        int prefixSum = 0, count = 0;\\n        for (int num : nums) {\\n            prefixSum += num;\\n            sumFrequency.put(prefixSum, sumFrequency.getOrDefault(prefixSum, 0) + 1);\\n\\n            if (sumFrequency.containsKey(prefixSum - k))\\n                count += sumFrequency.get(prefixSum - k);\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2464243,
                "title": "c-simple-solution-o-n-no-fancy-data-structure",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int l,r,ans=0;\\n        vector<int> helper;\\n        for(int i=0;i<nums.size();i++) if(nums[i]%2!=0) helper.push_back(i);\\n        int start=0;\\n        int end=start+k-1;\\n        while(end<helper.size()) {\\n            l=helper[start]+1;\\n            r=nums.size()-helper[end];\\n            if(start>0) l=helper[start]-helper[start-1];\\n            if(end!=helper.size()-1) r=helper[end+1]-helper[end];\\n            ans+=(l)*(r);\\n            start++;\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int l,r,ans=0;\\n        vector<int> helper;\\n        for(int i=0;i<nums.size();i++) if(nums[i]%2!=0) helper.push_back(i);\\n        int start=0;\\n        int end=start+k-1;\\n        while(end<helper.size()) {\\n            l=helper[start]+1;\\n            r=nums.size()-helper[end];\\n            if(start>0) l=helper[start]-helper[start-1];\\n            if(end!=helper.size()-1) r=helper[end+1]-helper[end];\\n            ans+=(l)*(r);\\n            start++;\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426932,
                "title": "prefix-sum-python-solution",
                "content": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        # method1: prefix sum\\n        prefixCount = {0:1}\\n        res = 0\\n        oddCount = 0\\n        for i in range(len(nums)):\\n            oddCount = oddCount + (1 if nums[i]%2 == 1 else 0)\\n            residual = oddCount - k\\n            res += prefixCount.get(residual,0)\\n            prefixCount[oddCount] = 1 + prefixCount.get(oddCount,0)\\n        return res\\n```\\ngood solution by lee215:\\nhttps://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-O(1)-Space",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        # method1: prefix sum\\n        prefixCount = {0:1}\\n        res = 0\\n        oddCount = 0\\n        for i in range(len(nums)):\\n            oddCount = oddCount + (1 if nums[i]%2 == 1 else 0)\\n            residual = oddCount - k\\n            res += prefixCount.get(residual,0)\\n            prefixCount[oddCount] = 1 + prefixCount.get(oddCount,0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425883,
                "title": "sliding-window-python-explanation-o-n-tc",
                "content": "**Understanding Counting Subarrays:**\\nThe hard part of this question and with a few other sliding window questions is counting \"all\" subarrays.\\nThe easy way to do this would be to count the subarrays as you go.\\n\\nEx. [1, 2, 3, 4, 5, 6]\\nLets say we want to count all the nonempty contigous subarrays in this array.\\nLets set our start and end to 0, 0.\\nEach time we add to our total the size of the sliding window (end - start + 1), and then we increment the end and continue.\\n\\nstart = 0, end = 0, count = 0\\ncount += (0 - 0 + 1)\\nHere we added the subarray [1]\\n\\nstart = 0, end = 1, count = 1\\ncount += (1 - 0 + 1) -> 2\\nHere we added the subarray [2] and [1, 2]\\n\\nstart = 0, end = 2, count = 3\\ncount += (2 - 0 + 1) -> 3\\nHere we added the subarray [3], [3, 2], and [3, 2, 1]\\n...\\n\\nSo you can see that as we go to each element we add the subarray containing just that element, and then all the subarrays it can make with the previous elements, which is why adding the size of the window gets us the subarray count.\\n\\n**Understanding Finding the Number of Subarrays Where the Number of Odd Numbers <= K:**\\n\\n```\\ndef atMostK(nums, k):\\n            start, oddCount, subarrayCount = 0, 0, 0\\n        \\n            for i in range(len(nums)):\\n                # look at end of window and check if it is odd\\n                oddCount += (nums[i] % 2) \\n            \\n                # update the start of the window until we have <= k element again\\n                while start <= i and  oddCount > k: \\n                    oddCount -= (nums[start] % 2)\\n                    start += 1\\n                \\n                # add the number of subarrays which equals the size of the window\\n                subarrayCount += (i - start + 1)\\n            \\n            return subarrayCount\\n```\\nNow that you know how to get the number of subarrays, we can use this to calculate the number of subarrays where the total number of odd numbers is <= k.\\nLike in a standard sliding window we increment the window.\\nIf the window is still <= k then we add the number of subarrays with the same method above (add the window size).\\nIf the window is > k, we update the start of the window and then we add the number of subarrays.\\n\\n**Full Solution: Getting the Number of Subarrays with Exactly K Odd Numbers:**\\n\\n**Number of Subarrays with Exactly K = (Number of Subarrays with <= K) - (Number of Subarrays with <= K - 1)**\\n```\\nclass Solution(object):\\n    def numberOfSubarrays(self, nums, k):\\n        # helper function\\n        def atMostK(nums, k):\\n            start, oddCount, subarrayCount = 0, 0, 0\\n        \\n            for i in range(len(nums)):\\n                # look at end of window and check if it is odd\\n                oddCount += (nums[i] % 2) \\n            \\n                # update the start of the window until we have <= k element again\\n                while start <= i and  oddCount > k: \\n                    oddCount -= (nums[start] % 2)\\n                    start += 1\\n                \\n                # add the number of subarrays which equals the size of the window\\n                subarrayCount += (i - start + 1)\\n            \\n            return subarrayCount\\n            \\n        return atMostK(nums, k) - atMostK(nums, k - 1);\\n```\\n\\n**TC: O(n) as you visit each element once\\nSC: O(1) as you only use a few variables for the window**\\n\\nNote: This approach is better than trying to get exactly K because you already know how to get all subarrays <= k. Getting exactly K requires much more work as you have to backtrack and keep adjsuting your sliding window backwards which complicates things.\\n",
                "solutionTags": [],
                "code": "```\\ndef atMostK(nums, k):\\n            start, oddCount, subarrayCount = 0, 0, 0\\n        \\n            for i in range(len(nums)):\\n                # look at end of window and check if it is odd\\n                oddCount += (nums[i] % 2) \\n            \\n                # update the start of the window until we have <= k element again\\n                while start <= i and  oddCount > k: \\n                    oddCount -= (nums[start] % 2)\\n                    start += 1\\n                \\n                # add the number of subarrays which equals the size of the window\\n                subarrayCount += (i - start + 1)\\n            \\n            return subarrayCount\\n```\n```\\nclass Solution(object):\\n    def numberOfSubarrays(self, nums, k):\\n        # helper function\\n        def atMostK(nums, k):\\n            start, oddCount, subarrayCount = 0, 0, 0\\n        \\n            for i in range(len(nums)):\\n                # look at end of window and check if it is odd\\n                oddCount += (nums[i] % 2) \\n            \\n                # update the start of the window until we have <= k element again\\n                while start <= i and  oddCount > k: \\n                    oddCount -= (nums[start] % 2)\\n                    start += 1\\n                \\n                # add the number of subarrays which equals the size of the window\\n                subarrayCount += (i - start + 1)\\n            \\n            return subarrayCount\\n            \\n        return atMostK(nums, k) - atMostK(nums, k - 1);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416009,
                "title": "c-sliding-window",
                "content": "class Solution {\\n# public:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n       int i=0;\\n        int j=0;\\n        int count=0;\\n        int ans=0;\\n        vector<int>v;\\n        while(j<nums.size()){\\n            if(nums[j]%2!=0){\\n                v.push_back(j);\\n                count++;\\n            }\\n           \\n            if(count>k){\\n                int l=v[0]-i;\\n                int r=j-v[v.size()-2]-1;\\n                ans+=l+r+(l*r)+1;\\n            }\\n                while(count>k){\\n                if(nums[i]%2!=0){\\n                    count--;\\n                    v.erase(v.begin());\\n                }\\n                i++;\\n            }\\n            if(count==k && j==nums.size()-1){\\n                int l=v[0]-i;\\n                int r=j-v[v.size()-1];\\n                ans+=l+r+(l*r)+1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n# public:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n       int i=0;\\n        int j=0;\\n        int count=0;\\n        int ans=0;\\n        vector<int>v;\\n        while(j<nums.size()){\\n            if(nums[j]%2!=0){\\n                v.push_back(j);\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2317299,
                "title": "c-sliding-windwo-tc-o-n-sc-o-1-simple-and-concise",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> nums;\\n\\t\\tint solve(int k){\\n\\t\\t\\tint low = 0, high = 0, cnt = 0, res = 0;\\n\\n\\t\\t\\twhile(high < nums.size()){\\n\\t\\t\\t\\tif(nums[high] & 1){\\n\\t\\t\\t\\t\\tcnt++;\\n\\n\\t\\t\\t\\t\\twhile(cnt > k){\\n\\t\\t\\t\\t\\t\\tif(nums[low] & 1) cnt--;\\n\\t\\t\\t\\t\\t\\tlow++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\thigh++;\\n\\t\\t\\t\\tres += high - low;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tint numberOfSubarrays(vector<int>& nums, int k) {\\n\\t\\t\\tthis -> nums = nums;\\n\\t\\t\\treturn solve(k) - solve(k - 1);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> nums;\\n\\t\\tint solve(int k){\\n\\t\\t\\tint low = 0, high = 0, cnt = 0, res = 0;\\n\\n\\t\\t\\twhile(high < nums.size()){\\n\\t\\t\\t\\tif(nums[high] & 1){\\n\\t\\t\\t\\t\\tcnt++;\\n\\n\\t\\t\\t\\t\\twhile(cnt > k){\\n\\t\\t\\t\\t\\t\\tif(nums[low] & 1) cnt--;\\n\\t\\t\\t\\t\\t\\tlow++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2275363,
                "title": "c-very-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int> pos;int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {if(nums[i]%2==1)\\n            pos.push_back(i);\\n        }\\n        if(pos.size()<k)\\n            return 0;\\n        for(int i=0;i<pos.size();i++)\\n        {\\n            if(i==0)\\n            {\\n                if(i+k-1==pos.size()-1)\\n                { count+=((pos[0]+1)*(nums.size()-pos[i+k-1])); goto end;}\\n                else\\n                    count+=((pos[0]+1)*(pos[i+k]-pos[i+k-1]));\\n            }\\n            else\\n                {\\n                if(i+k-1==pos.size()-1)\\n                { count+=((pos[i]-pos[i-1])*(nums.size()-pos[i+k-1])); goto end;}\\n                else\\n                    count+=((pos[i]-pos[i-1])*(pos[i+k]-pos[i+k-1]));\\n            }       \\n        }\\n        end:return count;       \\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int> pos;int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {if(nums[i]%2==1)\\n            pos.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2263115,
                "title": "java-easy-solution-sliding-window",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(j<nums.length){\\n            if(nums[j]%2 ==1)\\n                count++;\\n            if(count<k){\\n                j++;\\n            }\\n            else{\\n                int c1=1;\\n                while(nums[i]%2 != 1){\\n                    c1++;\\n                    i++;\\n                }\\n                cnt+=c1;\\n               // System.out.println(i+\"     \"+j+\"       \"+cnt+\"     \"+count);\\n                count--;\\n                i++;\\n                j++;\\n                while(j<nums.length &&nums[j]%2 != 1){\\n                    cnt+=c1;\\n                    j++;\\n                }\\n                // System.out.println(i+\"     \"+j+\"       \"+cnt+\"     \"+count);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(j<nums.length){\\n            if(nums[j]%2 ==1)\\n                count++;\\n            if(count<k){\\n                j++;\\n            }\\n            else{\\n                int c1=1;\\n                while(nums[i]%2 != 1){\\n                    c1++;\\n                    i++;\\n                }\\n                cnt+=c1;\\n               // System.out.println(i+\"     \"+j+\"       \"+cnt+\"     \"+count);\\n                count--;\\n                i++;\\n                j++;\\n                while(j<nums.length &&nums[j]%2 != 1){\\n                    cnt+=c1;\\n                    j++;\\n                }\\n                // System.out.println(i+\"     \"+j+\"       \"+cnt+\"     \"+count);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219795,
                "title": "java-sliding-window-and-left-right-difference-between-odd-elemeent-math",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        ArrayList<Integer> oddIndexes = new ArrayList<>();\\n        int ans =0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2!=0)oddIndexes.add(i);\\n        }\\n        for(int i=0;i<oddIndexes.size()-k + 1;i++){\\n            int leftDiff = i!=0 ? (oddIndexes.get(i) - oddIndexes.get(i-1) - 1):oddIndexes.get(i);\\n            int rightDiff = i!=oddIndexes.size()-k?oddIndexes.get(i + k) - oddIndexes.get(i + k - 1) - 1:nums.length-oddIndexes.get(i + k - 1)-1;\\n            ans+= leftDiff + rightDiff + leftDiff*rightDiff + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        ArrayList<Integer> oddIndexes = new ArrayList<>();\\n        int ans =0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2!=0)oddIndexes.add(i);\\n        }\\n        for(int i=0;i<oddIndexes.size()-k + 1;i++){\\n            int leftDiff = i!=0 ? (oddIndexes.get(i) - oddIndexes.get(i-1) - 1):oddIndexes.get(i);\\n            int rightDiff = i!=oddIndexes.size()-k?oddIndexes.get(i + k) - oddIndexes.get(i + k - 1) - 1:nums.length-oddIndexes.get(i + k - 1)-1;\\n            ans+= leftDiff + rightDiff + leftDiff*rightDiff + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217464,
                "title": "python-o-n-time-and-space-solution",
                "content": "```\\n# O(n) time | O(n) space b/c of the hashmap\\n\\n# this is a very popular algorithm for sliding window try your best to really understand it. Comment for any help.\\n# you can find another variation of this problem here\\n# https://www.youtube.com/watch?v=fFVZt-6sgyo\\n\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        pSum = 0\\n        hashMap = defaultdict(int)\\n        hashMap[0] = 1\\n        for n in nums:\\n            pSum += 0 if n % 2 == 0 else 1\\n            diff = pSum - k\\n            ans += hashMap.get(diff, 0)\\n            hashMap[pSum] += 1\\n        return ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# O(n) time | O(n) space b/c of the hashmap\\n\\n# this is a very popular algorithm for sliding window try your best to really understand it. Comment for any help.\\n# you can find another variation of this problem here\\n# https://www.youtube.com/watch?v=fFVZt-6sgyo\\n\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        pSum = 0\\n        hashMap = defaultdict(int)\\n        hashMap[0] = 1\\n        for n in nums:\\n            pSum += 0 if n % 2 == 0 else 1\\n            diff = pSum - k\\n            ans += hashMap.get(diff, 0)\\n            hashMap[pSum] += 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210254,
                "title": "classic-sliding-window-pattern-in-python",
                "content": "```\\n\\nclass Solution(object):\\n    def numberOfSubarrays(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        amt = 0\\n        \\n        \\n        seenOddsInWindow = 0\\n        \\n        l = 0\\n        for r in range(len(nums)):\\n            \\n            seenOddsInWindow += 1 if nums[r] % 2 == 1 else 0\\n            \\n            while seenOddsInWindow > k:\\n                seenOddsInWindow -= 1 if nums[l] % 2 == 1 else 0\\n                l+=1\\n                \\n            if seenOddsInWindow == k:\\n                amt+=1\\n                \\n                \\'\\'\\'\\n                [2,2,2,1,2,2,1,2,2,2] k = 2\\n                ---------------------------\\n                first string sub array with k odd numers\\n                we can add to the total seen nice arrays\\n                each even prefix to the array till we hit an odd number\\n                \\n                [2,2,2,1,2,2,1],2,2,2\\n                2,[2,2,1,2,2,1],2,2,2\\n                2,2,[2,1,2,2,1],2,2,2\\n                2,2,2,[1,2,2,1],2,2,2\\n                \\n                [2,2,2,1,2,2,1,2],2,2\\n                2,[2,2,1,2,2,1,2],2,2\\n                2,2,[2,1,2,2,1,2],2,2\\n                2,2,2,[1,2,2,1,2],2,2\\n\\n                [2,2,2,1,2,2,1,2,2],2\\n                2,[2,2,1,2,2,1,2,2],2\\n                2,2,[2,1,2,2,1,2,2],2\\n                2,2,2,[1,2,2,1,2,2],2\\n                \\n                [2,2,2,1,2,2,1,2,2,2]\\n                2,[2,2,1,2,2,1,2,2,2]\\n                2,2,[2,1,2,2,1,2,2,2]\\n                2,2,2,[1,2,2,1,2,2,2]\\n\\n                ----------------------\\n                \\n                \\'\\'\\'\\n            \\n                tempL = l\\n                while nums[tempL] % 2 == 0:\\n                    amt+=1\\n                    tempL+=1\\n                \\n                \\n        return amt\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def numberOfSubarrays(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        amt = 0\\n        \\n        \\n        seenOddsInWindow = 0\\n        \\n        l = 0\\n        for r in range(len(nums)):\\n            \\n            seenOddsInWindow += 1 if nums[r] % 2 == 1 else 0\\n            \\n            while seenOddsInWindow > k:\\n                seenOddsInWindow -= 1 if nums[l] % 2 == 1 else 0\\n                l+=1\\n                \\n            if seenOddsInWindow == k:\\n                amt+=1\\n                \\n                \\'\\'\\'\\n                [2,2,2,1,2,2,1,2,2,2] k = 2\\n                ---------------------------\\n                first string sub array with k odd numers\\n                we can add to the total seen nice arrays\\n                each even prefix to the array till we hit an odd number\\n                \\n                [2,2,2,1,2,2,1],2,2,2\\n                2,[2,2,1,2,2,1],2,2,2\\n                2,2,[2,1,2,2,1],2,2,2\\n                2,2,2,[1,2,2,1],2,2,2\\n                \\n                [2,2,2,1,2,2,1,2],2,2\\n                2,[2,2,1,2,2,1,2],2,2\\n                2,2,[2,1,2,2,1,2],2,2\\n                2,2,2,[1,2,2,1,2],2,2\\n\\n                [2,2,2,1,2,2,1,2,2],2\\n                2,[2,2,1,2,2,1,2,2],2\\n                2,2,[2,1,2,2,1,2,2],2\\n                2,2,2,[1,2,2,1,2,2],2\\n                \\n                [2,2,2,1,2,2,1,2,2,2]\\n                2,[2,2,1,2,2,1,2,2,2]\\n                2,2,[2,1,2,2,1,2,2,2]\\n                2,2,2,[1,2,2,1,2,2,2]\\n\\n                ----------------------\\n                \\n                \\'\\'\\'\\n            \\n                tempL = l\\n                while nums[tempL] % 2 == 0:\\n                    amt+=1\\n                    tempL+=1\\n                \\n                \\n        return amt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166188,
                "title": "c-o-1-space-at-most-concept",
                "content": "```\\nint solve(vector<int> &A,int k){\\n        int res=0,cnt=0;\\n        for(int i=0,j=0;i<size(A);i++){\\n            cnt+=A[i]%2;\\n            while(cnt>k) cnt-=A[j++]%2;\\n            res+=i-j;\\n        }\\n        return res;\\n    }\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return solve(A,k)-solve(A,k-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint solve(vector<int> &A,int k){\\n        int res=0,cnt=0;\\n        for(int i=0,j=0;i<size(A);i++){\\n            cnt+=A[i]%2;\\n            while(cnt>k) cnt-=A[j++]%2;\\n            res+=i-j;\\n        }\\n        return res;\\n    }\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return solve(A,k)-solve(A,k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2164505,
                "title": "java-easy-solution-presume",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int len = nums.length;\\n        int[] pre = new int[len+1];\\n        int ans = 0;\\n        \\n        for (int i = 0; i < len; i++)\\n            pre[i+1] = pre[i] + (nums[i] % 2 == 0 ? 0 : 1);\\n        \\n            \\n         Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int x : pre){\\n            ans += map.getOrDefault(x,0);\\n            map.put(x+k, map.getOrDefault(x+k,0)+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int len = nums.length;\\n        int[] pre = new int[len+1];\\n        int ans = 0;\\n        \\n        for (int i = 0; i < len; i++)\\n            pre[i+1] = pre[i] + (nums[i] % 2 == 0 ? 0 : 1);\\n        \\n            \\n         Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int x : pre){\\n            ans += map.getOrDefault(x,0);\\n            map.put(x+k, map.getOrDefault(x+k,0)+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134001,
                "title": "easy-to-understand-complexity-o-n-o-1",
                "content": "Formula:\\nExact(k) = AtMost(k) - AtMost(k-1):\\n\\n```\\nclass Solution {\\npublic:    \\n    int c(vector<int> &nums, int k){\\n        int n = nums.size();\\n        int ans = 0, count =0, i = 0, j  =0;\\n        \\n        while(j < n){            \\n            if(nums[j]%2){\\n                count++;\\n            }            \\n            while(count > k){\\n                if(nums[i]%2){\\n                    count--;\\n                }\\n                i++;\\n            }\\n            ans += j - i;\\n            j++;\\n        }\\n        return ans;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return c(nums, k) - c(nums, k-1);\\n    }\\n};\\n```\\n\\n### Please Upvote if you like this",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int c(vector<int> &nums, int k){\\n        int n = nums.size();\\n        int ans = 0, count =0, i = 0, j  =0;\\n        \\n        while(j < n){            \\n            if(nums[j]%2){\\n                count++;\\n            }            \\n            while(count > k){\\n                if(nums[i]%2){\\n                    count--;\\n                }\\n                i++;\\n            }\\n            ans += j - i;\\n            j++;\\n        }\\n        return ans;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return c(nums, k) - c(nums, k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092666,
                "title": "c-sliding-window-with-map",
                "content": "```\\n   int sum=0,ans=0;\\n     unordered_map<int,int> mp; // Map for storing previous sum value \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2 !=0)\\n                sum++;\\n            if(sum==k)\\n                ans++; // incrementing ans for each sub array with k\\n            if(mp.count(sum-k))\\n                ans+=mp[sum-k]; // addding ans to with map value so it will consider all sub array before it.\\n            mp[sum]++; // add all sum value in map.\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   int sum=0,ans=0;\\n     unordered_map<int,int> mp; // Map for storing previous sum value \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2 !=0)\\n                sum++;\\n            if(sum==k)\\n                ans++; // incrementing ans for each sub array with k\\n            if(mp.count(sum-k))\\n                ans+=mp[sum-k]; // addding ans to with map value so it will consider all sub array before it.\\n            mp[sum]++; // add all sum value in map.\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2088766,
                "title": "cpp-o-n-space-and-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int nyc=0;\\n        int i=0,j=0,n=nums.size();\\n        int countodd=0;\\n        int nearestodd[n];\\n            nearestodd[n-1]=n;\\n        for(int p=n-2;p>=0;p--)\\n        {\\n            if(nums[p+1]%2!=0)\\n                nearestodd[p]=p+1;\\n            else\\n                nearestodd[p]=nearestodd[p+1];\\n        }\\n        for(j=0;j<n;j++)\\n        {\\n            countodd+=(nums[j]%2!=0);\\n            while(countodd==k)\\n            {\\n                nyc+=(nearestodd[j]-j);\\n                countodd-=(nums[i]%2!=0);\\n                i++;\\n            }\\n        }\\n        return nyc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int nyc=0;\\n        int i=0,j=0,n=nums.size();\\n        int countodd=0;\\n        int nearestodd[n];\\n            nearestodd[n-1]=n;\\n        for(int p=n-2;p>=0;p--)\\n        {\\n            if(nums[p+1]%2!=0)\\n                nearestodd[p]=p+1;\\n            else\\n                nearestodd[p]=nearestodd[p+1];\\n        }\\n        for(j=0;j<n;j++)\\n        {\\n            countodd+=(nums[j]%2!=0);\\n            while(countodd==k)\\n            {\\n                nyc+=(nearestodd[j]-j);\\n                countodd-=(nums[i]%2!=0);\\n                i++;\\n            }\\n        }\\n        return nyc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052596,
                "title": "c-prefix-counting-detailed-explanation",
                "content": "# Approach\\n* Let\\'s compute the number of odds till ith index in the array using prefix technique.\\n`preSum[i] = preSum[i-1] + nums[i] % 2`\\n* Now if we iterate in the preSum array, for an element preSum[i] the number of subarrays with K odds will be number of occurance of (preSum[i] + k ) \\n* For each starting index i all the indexing where preSum is preSum[i] + k will be a subarray with K odds.\\n* The reverse is also true. That is when moving from left to right in preSum we can look for number of occuarnaces of (preSum[i] - k). Using this we can do it in one go.\\n* To implement it we also of keep count of occurances in the preSum array in a map.\\n\\n![image](https://assets.leetcode.com/users/images/4df6750a-aa70-4be3-9bab-f3c124535067_1652934194.7110145.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int i = 0, n = nums.size(), ans = 0;\\n        \\n        vector<int> preSum(n, 0);\\n        unordered_map<int, int> mp;\\n          \\n        mp[0] = 1;\\n        preSum[0] = nums[0] % 2;\\n        mp[preSum[0]] += 1;\\n        ans += mp[preSum[0] - k];\\n        \\n        for(i=1;i<n;i++)\\n        {\\n            preSum[i] = preSum[i-1] + (nums[i] % 2);\\n            mp[preSum[i]] += 1;\\n            ans += mp[preSum[i] - k]; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int i = 0, n = nums.size(), ans = 0;\\n        \\n        vector<int> preSum(n, 0);\\n        unordered_map<int, int> mp;\\n          \\n        mp[0] = 1;\\n        preSum[0] = nums[0] % 2;\\n        mp[preSum[0]] += 1;\\n        ans += mp[preSum[0] - k];\\n        \\n        for(i=1;i<n;i++)\\n        {\\n            preSum[i] = preSum[i-1] + (nums[i] % 2);\\n            mp[preSum[i]] += 1;\\n            ans += mp[preSum[i] - k]; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049094,
                "title": "c-weird-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int l = 0; //left end of sliding window\\n        int r = 0; //right end of sliding window\\n        \\n        int count = 0; //number of odd numbers in curr window\\n        \\n        int ans = 0; //number of subarrays\\n        \\n        int s = -1; //first odd number in this window\\n        int e = -1; //last odd number(after count = k) in this window\\n        \\n        while(l<nums.size() && r<nums.size()){\\n            \\n            \\n            if (nums[r]&1 == 1) {\\n                \\n                if (count == 0) s = r;\\n                count++;\\n                if (count == k) e = r;\\n            }\\n \\n            if(count > k){\\n                \\n                ans += (s-l+1)*(r-e);\\n                \\n                l = s+1;\\n                \\n                while(count > k){\\n                    \\n                    s++;\\n                    \\n                    if (nums[s]&1 == 1) count--;\\n                }\\n                \\n                if (count == k) e = r;\\n            }\\n            \\n            \\n            if (r == nums.size()-1 && count == k){\\n                \\n                ans += (s-l+1)*(r-e+1);\\n                \\n            }\\n            \\n            r++;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int l = 0; //left end of sliding window\\n        int r = 0; //right end of sliding window\\n        \\n        int count = 0; //number of odd numbers in curr window\\n        \\n        int ans = 0; //number of subarrays\\n        \\n        int s = -1; //first odd number in this window\\n        int e = -1; //last odd number(after count = k) in this window\\n        \\n        while(l<nums.size() && r<nums.size()){\\n            \\n            \\n            if (nums[r]&1 == 1) {\\n                \\n                if (count == 0) s = r;\\n                count++;\\n                if (count == k) e = r;\\n            }\\n \\n            if(count > k){\\n                \\n                ans += (s-l+1)*(r-e);\\n                \\n                l = s+1;\\n                \\n                while(count > k){\\n                    \\n                    s++;\\n                    \\n                    if (nums[s]&1 == 1) count--;\\n                }\\n                \\n                if (count == k) e = r;\\n            }\\n            \\n            \\n            if (r == nums.size()-1 && count == k){\\n                \\n                ans += (s-l+1)*(r-e+1);\\n                \\n            }\\n            \\n            r++;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039413,
                "title": "java-two-pointer",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int left = 0;\\n        int right = 0;\\n        int odd = 0;\\n        int result = 0;\\n        \\n        while(right < nums.length){\\n            if((nums[right] & 1) == 1){\\n                odd ++;\\n                right ++;\\n            }else{\\n                right ++;\\n            }\\n            \\n            if(odd == k){\\n              //\\u5411\\u5411\\u53F3\\u79FB\\u52A8\\u53CC\\u6307\\u9488\\uFF0C\\u76F4\\u81F3\\u9047\\u5230\\u7B2C\\u4E00\\u4E2Aodd\\n                int tempRight  = right;\\n                int tempLeft = left;\\n                while(right < nums.length && (nums[right] & 1) == 0){\\n                    right ++;\\n                }\\n                \\n                while((nums[left] & 1) == 0){\\n                    left ++;\\n                }\\n                \\n                result += (left - tempLeft + 1) * (right - tempRight + 1);\\n                \\n                odd  --;\\n                left ++;\\n            }\\n            \\n          \\n\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int left = 0;\\n        int right = 0;\\n        int odd = 0;\\n        int result = 0;\\n        \\n        while(right < nums.length){\\n            if((nums[right] & 1) == 1){\\n                odd ++;\\n                right ++;\\n            }else{\\n                right ++;\\n            }\\n            \\n            if(odd == k){\\n              //\\u5411\\u5411\\u53F3\\u79FB\\u52A8\\u53CC\\u6307\\u9488\\uFF0C\\u76F4\\u81F3\\u9047\\u5230\\u7B2C\\u4E00\\u4E2Aodd\\n                int tempRight  = right;\\n                int tempLeft = left;\\n                while(right < nums.length && (nums[right] & 1) == 0){\\n                    right ++;\\n                }\\n                \\n                while((nums[left] & 1) == 0){\\n                    left ++;\\n                }\\n                \\n                result += (left - tempLeft + 1) * (right - tempRight + 1);\\n                \\n                odd  --;\\n                left ++;\\n            }\\n            \\n          \\n\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008965,
                "title": "go-prefix-sum-clear-solution",
                "content": "Explanation available here: https://www.youtube.com/watch?v=fFVZt-6sgyo\\n\\n```\\nfunc numberOfSubarrays(nums []int, k int) int {\\n    prefixSums := map[int]int{0: 1}\\n    sum, res := 0, 0\\n    for _, n := range nums {\\n        sum += n%2\\n        res += prefixSums[sum-k]\\n        prefixSums[sum]++\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Prefix Sum"
                ],
                "code": "```\\nfunc numberOfSubarrays(nums []int, k int) int {\\n    prefixSums := map[int]int{0: 1}\\n    sum, res := 0, 0\\n    for _, n := range nums {\\n        sum += n%2\\n        res += prefixSums[sum-k]\\n        prefixSums[sum]++\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1970388,
                "title": "easy-to-understand-c-code",
                "content": "* ***Approach 1 : Using Prefix Sum && Unordered Map***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] % 2)\\n            {\\n                nums[i] = 1;\\n            }\\n            \\n            else\\n            {\\n                nums[i] = 0;\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        \\n        mp[0] = 1;\\n        \\n        int curr_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += nums[i];\\n            \\n            int need = curr_sum - k;\\n            \\n            if(mp.count(need))\\n            {\\n                count += mp[need];\\n            }\\n            \\n            mp[curr_sum]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] % 2)\\n            {\\n                nums[i] = 1;\\n            }\\n            \\n            else\\n            {\\n                nums[i] = 0;\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        \\n        mp[0] = 1;\\n        \\n        int curr_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += nums[i];\\n            \\n            int need = curr_sum - k;\\n            \\n            if(mp.count(need))\\n            {\\n                count += mp[need];\\n            }\\n            \\n            mp[curr_sum]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956689,
                "title": "simple-and-probably-the-most-easiest-solution-out-there-o-n-prefix-hash-map",
                "content": "Just replace the odd numbers with 1 and the even numbers with 0. Then, using prefix sum find the total number of sub arrays with sum equal to K.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int> nums, int k) {\\n       int n = nums.size(); \\n        \\n        for(int i=0; i<n ;i++)\\n        {\\n            if(nums[i]%2==0)\\n                nums[i] = 0;\\n            else\\n                nums[i] = 1;\\n        }\\n        \\n        int sum = 0, count=0, j=0;\\n        unordered_map<int, int> mp;\\n        mp[0]=  1;\\n        for(; j<n; j++)\\n        {\\n            sum += nums[j];\\n            if(mp.find(sum-k) != mp.end())\\n                count += mp[sum-k];\\n            mp[sum]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\nHope it helps :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int> nums, int k) {\\n       int n = nums.size(); \\n        \\n        for(int i=0; i<n ;i++)\\n        {\\n            if(nums[i]%2==0)\\n                nums[i] = 0;\\n            else\\n                nums[i] = 1;\\n        }\\n        \\n        int sum = 0, count=0, j=0;\\n        unordered_map<int, int> mp;\\n        mp[0]=  1;\\n        for(; j<n; j++)\\n        {\\n            sum += nums[j];\\n            if(mp.find(sum-k) != mp.end())\\n                count += mp[sum-k];\\n            mp[sum]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908023,
                "title": "python3-solution-subarray-sum-equals-k-time-o-n-space-o-n",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Let\\'s mark each even number by 0 and each odd number by 1. Then the problem reduces to subarray sum\\n        equals k.\\n        Time complexity: O(N)\\n        Space complexity: O(N)\\n        \"\"\"\\n        lookup = defaultdict(int)\\n        lookup[0] = 1 # The sum of 0 exists 1 time.\\n        res = prefix_sum = 0\\n        \\n        for i in range(len(nums)):\\n            if nums[i] % 2 == 0:\\n                nums[i] = 0\\n            \\n            else:\\n                nums[i] = 1\\n                \\n            prefix_sum+=nums[i]\\n            res+=lookup[prefix_sum - k]\\n            lookup[prefix_sum]+=1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Let\\'s mark each even number by 0 and each odd number by 1. Then the problem reduces to subarray sum\\n        equals k.\\n        Time complexity: O(N)\\n        Space complexity: O(N)\\n        \"\"\"\\n        lookup = defaultdict(int)\\n        lookup[0] = 1 # The sum of 0 exists 1 time.\\n        res = prefix_sum = 0\\n        \\n        for i in range(len(nums)):\\n            if nums[i] % 2 == 0:\\n                nums[i] = 0\\n            \\n            else:\\n                nums[i] = 1\\n                \\n            prefix_sum+=nums[i]\\n            res+=lookup[prefix_sum - k]\\n            lookup[prefix_sum]+=1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852603,
                "title": "javascript-sliding-window",
                "content": "```\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n\\nvar numberOfSubarrays = function (nums, k) {\\n  let result = 0,\\n    windowStart = 0,\\n    windowEnd = 0,\\n    count = 0;\\n  while (windowEnd < nums.length) {\\n    //odd\\n    if (nums[windowEnd] % 2 === 1) {\\n      k -= 1;\\n      count = 0;\\n    }\\n    while (k === 0) {\\n      if (nums[windowStart] % 2 === 1) {\\n        k += 1;\\n      }\\n      // shrink the window\\n      windowStart += 1;\\n      // update count\\n      count += 1;\\n    }\\n    result += count;\\n    windowEnd += 1;\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n\\nvar numberOfSubarrays = function (nums, k) {\\n  let result = 0,\\n    windowStart = 0,\\n    windowEnd = 0,\\n    count = 0;\\n  while (windowEnd < nums.length) {\\n    //odd\\n    if (nums[windowEnd] % 2 === 1) {\\n      k -= 1;\\n      count = 0;\\n    }\\n    while (k === 0) {\\n      if (nums[windowStart] % 2 === 1) {\\n        k += 1;\\n      }\\n      // shrink the window\\n      windowStart += 1;\\n      // update count\\n      count += 1;\\n    }\\n    result += count;\\n    windowEnd += 1;\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840870,
                "title": "java-sliding-window",
                "content": "Provide some feedback on this solution please.\\nI think it is a pretty good one using the Sliding Window technique.\\n62.45% faster and 69.41% less space used.\\n\\n\\n```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int oddLen = 0, startIndex = 0, num = 0, endIndex = 0, res = 0;\\n        boolean hasK = false;\\n        for (int i = 0; i < nums.length; i++) {\\n            hasK = false;\\n            endIndex = i;\\n            if(nums[i] % 2 == 1) oddLen++;\\n            while (oddLen >= k) {\\n                hasK = true;\\n                if(nums[startIndex++] % 2 == 1) oddLen--;\\n                num++;\\n            }\\n            res += num;\\n            while (hasK && ++endIndex < nums.length && nums[endIndex] % 2 == 0) {\\n                \\n                res += num;\\n            }\\n            num = 0;\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int oddLen = 0, startIndex = 0, num = 0, endIndex = 0, res = 0;\\n        boolean hasK = false;\\n        for (int i = 0; i < nums.length; i++) {\\n            hasK = false;\\n            endIndex = i;\\n            if(nums[i] % 2 == 1) oddLen++;\\n            while (oddLen >= k) {\\n                hasK = true;\\n                if(nums[startIndex++] % 2 == 1) oddLen--;\\n                num++;\\n            }\\n            res += num;\\n            while (hasK && ++endIndex < nums.length && nums[endIndex] % 2 == 0) {\\n                \\n                res += num;\\n            }\\n            num = 0;\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830017,
                "title": "count-number-of-nice-subarrays",
                "content": "class Solution \\n{\\n public:\\n    int call(vector<int>&nums,int k)\\n    {\\n        int n=nums.size();\\n        int ans=0;\\n        map<int,int>sum;\\n        sum[0]=1;\\n        int total=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total+=nums[i];\\n            ans+=sum[total-k];\\n            sum[total]++;\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n            nums[i]=nums[i]%2;\\n        return call(nums,k);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n{\\n public:\\n    int call(vector<int>&nums,int k)\\n    {\\n        int n=nums.size();\\n        int ans=0;\\n        map<int,int>sum;\\n        sum[0]=1;\\n        int total=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total+=nums[i];\\n            ans+=sum[total-k];\\n            sum[total]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1829179,
                "title": "python-easy-to-read-and-understand-subarray-sum-equals-k",
                "content": "This question can be modified to subarray sum equaks k by converting all odds to 1 and all evens to 0\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            nums[i] = 0 if nums[i]%2 == 0 else 1\\n        \\n        d = {0:1}\\n        sums, ans = 0, 0\\n        for i in range(n):\\n            sums += nums[i]\\n            if sums-k in d:\\n                ans += d[sums-k]\\n            d[sums] = d.get(sums, 0) + 1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            nums[i] = 0 if nums[i]%2 == 0 else 1\\n        \\n        d = {0:1}",
                "codeTag": "Java"
            },
            {
                "id": 1820102,
                "title": "java-prefix-sum-hashmap-solution-based-on-problem-930-binary-subarrays-with-sum",
                "content": "```\\nclass Solution {\\n    // Gist: we have to find the number of subarrays that have \\'k\\' number of odd elements\\n    // Essentially this can be reduced to problem # 930 Binary subarrays with sum\\n    // nums[i] % 2 will either be 0 or 1\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        \\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;\\n        int right = 0;\\n\\t\\t\\n        while (right < nums.length) {\\n            sum += nums[right++] % 2;\\n            if (sum == k) {\\n                res++;\\n            }\\n\\t\\t\\t\\n            if (map.containsKey(sum - k)) {\\n                res += map.get(sum - k);\\n            }\\n            \\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Gist: we have to find the number of subarrays that have \\'k\\' number of odd elements\\n    // Essentially this can be reduced to problem # 930 Binary subarrays with sum\\n    // nums[i] % 2 will either be 0 or 1\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        \\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;\\n        int right = 0;\\n\\t\\t\\n        while (right < nums.length) {\\n            sum += nums[right++] % 2;\\n            if (sum == k) {\\n                res++;\\n            }\\n\\t\\t\\t\\n            if (map.containsKey(sum - k)) {\\n                res += map.get(sum - k);\\n            }\\n            \\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1758263,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1793283,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1573159,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1870128,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2067001,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2050698,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2039574,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2009498,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1994178,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1823836,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1758263,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1793283,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1573159,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1870128,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2067001,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2050698,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2039574,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2009498,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1994178,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1823836,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Max Number of K-Sum Pairs",
        "question_content": "<p>You are given an integer array <code>nums</code> and an integer <code>k</code>.</p>\n\n<p>In one operation, you can pick two numbers from the array whose sum equals <code>k</code> and remove them from the array.</p>\n\n<p>Return <em>the maximum number of operations you can perform on the array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4], k = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Starting with nums = [1,2,3,4]:\n- Remove numbers 1 and 4, then nums = [2,3]\n- Remove numbers 2 and 3, then nums = []\nThere are no more pairs that sum up to 5, hence a total of 2 operations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,3,4,3], k = 6\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Starting with nums = [3,1,3,4,3]:\n- Remove the first two 3&#39;s, then nums = [1,4,3]\nThere are no more pairs that sum up to 6, hence a total of 1 operation.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2005922,
                "title": "going-from-o-n-2-o-nlogn-o-n-meme",
                "content": "\\n\\n**`BRUTE`**\\n\\nThe brute force way to solve this problem is very easy, have 2 pointers one start from very begining & another start just after the second pointer. Means the 2nd pointer is depends on 1st pointer. And now you say if that\\'s the case it wont gonna visit the same element over & over again.?\\n\\nAnd my answer is Yes it\\'ll, but we;ll gonna play mind games. So, the element which i & j pointer has already visited flag them as visited with any value, let\\'s say i\\'ll gonna mark them with -1. So, by that we can handle this case easily. Now Happy :)\\n\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == -1) continue;\\n            for(int j = i + 1; j < nums.length; j++){\\n                if(nums[j] == -1) continue;\\n                if(nums[i] + nums[j] == k){\\n                    count++;\\n                    nums[i] = -1;\\n                    nums[j] = -1;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N^2)\\n\\n* **Space Complexity :-** BigO(1)\\n\\n**`BETTER`**\\n\\nNow, Interviewer won\\'t be happy with your brute solution, so just do some acting & behave like ya, I can improve it more. Tell him, why dont if we Sort the array & have 2 pointers one start from very begining & another from the end of the array.\\n\\nNow we gonna get the sum, \\n* if sum == k :- Increment our count & move our I & J pointer\\n\\n\\n* if sum > k, Move our J pointer\\n* if sum < k, Move our I pointer\\n\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while(i < j){\\n            int sum = nums[i] + nums[j];\\n            if(sum == k) {\\n                count++;\\n                i++;\\n                j--;\\n            }\\n            else if(sum > k) j--;\\n            else i++;\\n        }\\n        return count;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(NlogN) + O(N) => O(NlogN)\\n\\n* **Space Complexity :-** BigO(1)\\n\\n**`BEST`**\\n\\nBut, by looking at that, interviewer will say. I\\'m still not happy, so give him a ~~flying kiss~~ I mean give him a better solution \\uD83D\\uDE05 \\n\\nNow again, perform a beautiful acting, and say why dont we use MAP. So, tell him by using map, we can optimise it more beautifully. \\nSo, what we\\'ll gonna do is & may be you know this one, it is similar to **Two Sum**, so if u dont know then listen to me.\\n\\nWe gonna fill our map as frequency map. And we gonna get the result by subtracting current value from k & whatever result we get, we gonna check in our map. If that is present increment the count & remove it from the map now. That\\'s how we\\'ll get our answer in just O(1) for searching & as we are using a loop thus, O(N). But it\\'s a good approach.\\n\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int res = k - nums[i];\\n            if(map.containsKey(res)){\\n                count++;\\n                if(map.get(res) == 1) map.remove(res);\\n                else map.put(res, map.get(res) - 1);\\n            }\\n            else{\\n                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n\\n<hr>\\n<hr>\\n\\n```\\nMeme Time\\n```\\n\\n<hr>\\n<hr>\\n\\n<img src = \"https://assets.leetcode.com/users/images/4f835887-f3f5-4b3e-b185-754a5f8265e4_1651629920.9651897.png\" width=\"600\" height=\"auto\" border=\"10\"/>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == -1) continue;\\n            for(int j = i + 1; j < nums.length; j++){\\n                if(nums[j] == -1) continue;\\n                if(nums[i] + nums[j] == k){\\n                    count++;\\n                    nums[i] = -1;\\n                    nums[j] = -1;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while(i < j){\\n            int sum = nums[i] + nums[j];\\n            if(sum == k) {\\n                count++;\\n                i++;\\n                j--;\\n            }\\n            else if(sum > k) j--;\\n            else i++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int res = k - nums[i];\\n            if(map.containsKey(res)){\\n                count++;\\n                if(map.get(res) == 1) map.remove(res);\\n                else map.put(res, map.get(res) - 1);\\n            }\\n            else{\\n                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nMeme Time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022699,
                "title": "python-short-counter-solution-oneliner-explained",
                "content": "The question which is asked: how many pairs can be constructed, such that sum in each pair is equal to `k`. Imagine, that `k = 8` and we have numbers `2, 2, 2, 6, 6, 6, 6, 6, 6`. Then we can construct `3` pairs in this case. In general if we have `c1` times of number `x` and `c2` times of number `k - x`, we can construct `min(c1, c2)` pairs with numbers `x, k - x`. So, all we need to do is to use `Counter(nums)` to calculate frequency of each number and then iterate over each number `val`, try to find number equal to `k  - val` and update `ans` by `min(freq, cnt[k - val])`. Note also, that when we do this, we count each pair exaclty `2` times, so we need to divide answer by `2` in the end.\\n\\n**Question**: what happens, if `k = 8`, and we working wigh case `4, 4, 4, 4, 4, 4, 4`? Then there can be constructed `7//2 = 3` pairs, but when we count we count it `7` times. However in the end we will divide it by `2` and everything will work fine: because there can be only one number like this: `k//2` (if k is odd or if there is no such pairs, everythin will be OK as well)\\n\\n**Complexity**: time and space complexity is `O(n)`: we iterate over our number twice: when we build counter, and then when we iterate over counter.\\n\\n**Oneliner** from Nyx314:\\n```\\nreturn (lambda c: sum(min(c[n], c[k-n]) for n in c))(Counter(nums))//2\\n```\\n\\n```\\nclass Solution:\\n    def maxOperations(self, nums, k):\\n        cnt, ans = Counter(nums), 0\\n        for val in cnt:\\n            ans += min(cnt[val], cnt[k - val])\\n        return ans//2\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nreturn (lambda c: sum(min(c[n], c[k-n]) for n in c))(Counter(nums))//2\\n```\n```\\nclass Solution:\\n    def maxOperations(self, nums, k):\\n        cnt, ans = Counter(nums), 0\\n        for val in cnt:\\n            ans += min(cnt[val], cnt[k - val])\\n        return ans//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961351,
                "title": "c-map-o-n-and-two-pointer-o-nlogn-easy-solution",
                "content": "***O(NlogN) approach***\\nWe will sort the array, and start summing of elements from front and back\\nif  `sum == k` means they can be removed but we will not remove, we will just count \\nif `sum > k` then last element must me small so ` j--`\\nif `sum < k` then first element should be bigger so ` i++`\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& num, int k) {\\n      sort(num.begin(), num.end());\\n      int ans = 0;\\n      int i=0, j=num.size()-1;\\n      while(i < j){\\n        if(num[i] + num[j] == k){     // found elements just increase counter\\n          ans++; i++; j--;\\n        } \\n\\t\\telse if(num[i] + num[j] > k) j--;  // sum is large so decrease the bigger element, i.e. jth element\\n        else i++;    // sum is small so increase the smaller element, i.e. ith element\\n      }\\n      return ans;\\n    }\\n}\\n```\\n\\n***O(N) approach***\\ncount frequency using map in nums array\\nif `k - num == num` then num can be removed in pairs so  `ans += half of it\\'s frequency`\\nelse we` find k - num` is present in array using Map and if present `ans += min of count of num or k-num`\\nand update the values in Map also\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n      unordered_map<int, int> Map;\\n      for (auto &num: nums) Map[num]++;  // count freq of nums\\n      int ans = 0;\\n  \\n      for(auto it=Map.begin(); it!=Map.end(); ++it){\\n        int num = it->first, count = it->second;\\n        if(k - num == num) ans += count/2;   // if num is half of k add half of it\\'s count in ans\\n        else if(Map.count(k - num)){   // find k-num in nums and add min freq of num or k-num to ans\\n          int Min = min(count, Map[k-num]);\\n          ans += Min;\\n          Map[num] -= Min;\\n          Map[k-num] -= Min;\\n        }\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& num, int k) {\\n      sort(num.begin(), num.end());\\n      int ans = 0;\\n      int i=0, j=num.size()-1;\\n      while(i < j){\\n        if(num[i] + num[j] == k){     // found elements just increase counter\\n          ans++; i++; j--;\\n        } \\n\\t\\telse if(num[i] + num[j] > k) j--;  // sum is large so decrease the bigger element, i.e. jth element\\n        else i++;    // sum is small so increase the smaller element, i.e. ith element\\n      }\\n      return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n      unordered_map<int, int> Map;\\n      for (auto &num: nums) Map[num]++;  // count freq of nums\\n      int ans = 0;\\n  \\n      for(auto it=Map.begin(); it!=Map.end(); ++it){\\n        int num = it->first, count = it->second;\\n        if(k - num == num) ans += count/2;   // if num is half of k add half of it\\'s count in ans\\n        else if(Map.count(k - num)){   // find k-num in nums and add min freq of num or k-num to ans\\n          int Min = min(count, Map[k-num]);\\n          ans += Min;\\n          Map[num] -= Min;\\n          Map[k-num] -= Min;\\n        }\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901186,
                "title": "java-hashmap-solution-best-and-easy-in-few-lines",
                "content": "#### ***The code is self-explainatory with desired comments ;-)\\n```java\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            //to check if that k-nums[i] present and had some value left or already paired\\n            if(map.containsKey(k-nums[i])&&map.get(k-nums[i])>0){\\n                count++;\\n                map.put(k-nums[i],map.get(k-nums[i])-1);\\n            }else{\\n                //getOrDefault is easy way it directly checks if value is 0 returns 0 where I added 1\\n                //and if some value is present then it return that value \"similar to map.get(i)\" and I added 1 on it \\n                map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n#### **Do like my post If it helps you.!!  :`)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            //to check if that k-nums[i] present and had some value left or already paired\\n            if(map.containsKey(k-nums[i])&&map.get(k-nums[i])>0){\\n                count++;\\n                map.put(k-nums[i],map.get(k-nums[i])-1);\\n            }else{\\n                //getOrDefault is easy way it directly checks if value is 0 returns 0 where I added 1\\n                //and if some value is present then it return that value \"similar to map.get(i)\" and I added 1 on it \\n                map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023159,
                "title": "c-python-hashmap-one-pass-clean-concise-o-n",
                "content": "**Python**\\n```python\\nclass Solution(object):\\n    def maxOperations(self, nums, k):\\n        ans = 0\\n        seen = defaultdict(int)\\n        for b in nums:\\n            a = k - b # Explain: a + b = k  =>  a = k - b\\n            if seen[a] > 0:\\n                ans += 1\\n                seen[a] -= 1\\n            else:\\n                seen[b] += 1\\n        return ans\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> seen;\\n        int ans = 0;\\n        for (int b : nums) {\\n            int a = k - b; // Explain: a + b = k  =>  a = k - b\\n            if (seen[a] > 0) {\\n                ans += 1;\\n                seen[a] -= 1;\\n            } else {\\n                seen[b] += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nComplexity:\\n- Time & Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxOperations(self, nums, k):\\n        ans = 0\\n        seen = defaultdict(int)\\n        for b in nums:\\n            a = k - b # Explain: a + b = k  =>  a = k - b\\n            if seen[a] > 0:\\n                ans += 1\\n                seen[a] -= 1\\n            else:\\n                seen[b] += 1\\n        return ans\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> seen;\\n        int ans = 0;\\n        for (int b : nums) {\\n            int a = k - b; // Explain: a + b = k  =>  a = k - b\\n            if (seen[a] > 0) {\\n                ans += 1;\\n                seen[a] -= 1;\\n            } else {\\n                seen[b] += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023235,
                "title": "c-4-approaches-a-variation-of-two-sum",
                "content": "Approach 1: a variation of two-sum\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int sum) {\\n        unordered_map<int,int> freq;\\n        for(int e: nums) freq[e]++;\\n        int ans = 0;\\n        for(auto& [k,v]: freq){\\n            if(2*k == sum) ans += v / 2, v -= v/2*2; \\n            else if(v > 0 && freq.count(sum-k) && freq[sum-k] > 0) {                \\n                int pair_cnt = min(v, freq[sum-k]);\\n                ans += pair_cnt;\\n                v -= pair_cnt;\\n                freq[sum-k] -= pair_cnt;                \\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2: Single pass 2-sum  (Highly recommended)\\n```\\nclass Solution {\\npublic: // Time/Space: O(n); O(n)\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        int ans = 0;\\n        for(auto cur: nums){\\n            int complement = k - cur;\\n            if(freq[complement] > 0){ans++; freq[complement]--;}\\n            else freq[cur]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nApproac 3: nested for-loop brute force sarch = outer-for-loop + inner-for-loop\\nIdea: exhaustively check all combination pair\\n\\nI like the the following wording[1]:\\n\"\\nTo implement the intuition, we would use a nested for loop. The outer loop would choose the first element of the pair using a pointer first and iterate from the 0th index to the end of the array. The inner loop would choose the second element of the pair using a pointer second and iterate from the first+1 index to the end of the array.\\n\"\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int count = 0;\\n        for (int first = 0; first < nums.size(); first++) {\\n            // check if element pointed by first is already taken up\\n            if (nums[first] == 0) continue;\\n            for (int second = first + 1; second < nums.size(); second++) {\\n                // check if element pointed by second is already taken up\\n                if (nums[second] == 0) continue;\\n                if (nums[first] + nums[second] == k) {\\n                    nums[first] = nums[second] = 0;\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nApproach 4: Sort + 2-pointer + pruning\\n```\\nclass Solution {\\npublic: // Time/Space: O(nlogn); O(1)\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int count = 0;\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        while (left < right && nums[left] < k) {  // pruning:  nums[left] < k\\n            if (nums[left] + nums[right] < k) {\\n                left++;\\n            } else if (nums[left] + nums[right] > k) {\\n                right--;\\n            } else {\\n                left++;\\n                right--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nReference:\\n[1] https://leetcode.com/problems/max-number-of-k-sum-pairs/solution/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int sum) {\\n        unordered_map<int,int> freq;\\n        for(int e: nums) freq[e]++;\\n        int ans = 0;\\n        for(auto& [k,v]: freq){\\n            if(2*k == sum) ans += v / 2, v -= v/2*2; \\n            else if(v > 0 && freq.count(sum-k) && freq[sum-k] > 0) {                \\n                int pair_cnt = min(v, freq[sum-k]);\\n                ans += pair_cnt;\\n                v -= pair_cnt;\\n                freq[sum-k] -= pair_cnt;                \\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: // Time/Space: O(n); O(n)\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        int ans = 0;\\n        for(auto cur: nums){\\n            int complement = k - cur;\\n            if(freq[complement] > 0){ans++; freq[complement]--;}\\n            else freq[cur]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int count = 0;\\n        for (int first = 0; first < nums.size(); first++) {\\n            // check if element pointed by first is already taken up\\n            if (nums[first] == 0) continue;\\n            for (int second = first + 1; second < nums.size(); second++) {\\n                // check if element pointed by second is already taken up\\n                if (nums[second] == 0) continue;\\n                if (nums[first] + nums[second] == k) {\\n                    nums[first] = nums[second] = 0;\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: // Time/Space: O(nlogn); O(1)\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int count = 0;\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        while (left < right && nums[left] < k) {  // pruning:  nums[left] < k\\n            if (nums[left] + nums[right] < k) {\\n                left++;\\n            } else if (nums[left] + nums[right] > k) {\\n                right--;\\n            } else {\\n                left++;\\n                right--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006112,
                "title": "c-o-n-using-frequency-map",
                "content": "* Keep a Frequency map. At every index, check whether the required number` k - nums[i]` is present in the array or not to make a pair with `nums[i]`.\\n* TC : O(N) | SC : O(N)\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, int> freqMap;\\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if(freqMap[k - nums[i]] > 0){\\n                ans++;\\n                freqMap[k-nums[i]]--;\\n            }else{\\n                freqMap[nums[i]]++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, int> freqMap;\\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if(freqMap[k - nums[i]] > 0){\\n                ans++;\\n                freqMap[k-nums[i]]--;\\n            }else{\\n                freqMap[nums[i]]++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005967,
                "title": "python-two-easy-solutions",
                "content": "1. Sort the nums and use two pointer.\\n\\t* \\t***Time: O(nlogn), Sorting.*** \\n\\t* \\t***Space: O(1)***\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        left = 0\\n        right = len(nums) - 1\\n        ans = 0\\n        while left < right:\\n            cur = nums[left] + nums[right]\\n            if cur == k:\\n                ans += 1\\n                left += 1\\n                right -= 1\\n            elif cur < k:\\n                left += 1\\n            else:\\n                right -= 1\\n        \\n        return ans\\n```\\n\\n2. Use hash table.\\n\\t* \\t***Time: O(n)***\\n\\t* \\t***Sapce: O(n), the worst case may be no any fitted elements and all elements are distinct.***\\n\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        b = {}\\n        ans = 0\\n        for i in nums:\\n\\t\\t\\t# If there is num in table and is not used\\n            if k - i in b and b[k - i] > 0:\\n                ans += 1\\n                b[k - i] -= 1  # used\\n            elif i not in b:\\n                b[i] = 1\\n            else:\\n                b[i] += 1\\n        \\n        return ans\\n```\\n\\nThank you for watching. \\n",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        left = 0\\n        right = len(nums) - 1\\n        ans = 0\\n        while left < right:\\n            cur = nums[left] + nums[right]\\n            if cur == k:\\n                ans += 1\\n                left += 1\\n                right -= 1\\n            elif cur < k:\\n                left += 1\\n            else:\\n                right -= 1\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        b = {}\\n        ans = 0\\n        for i in nums:\\n\\t\\t\\t# If there is num in table and is not used\\n            if k - i in b and b[k - i] > 0:\\n                ans += 1\\n                b[k - i] -= 1  # used\\n            elif i not in b:\\n                b[i] = 1\\n            else:\\n                b[i] += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961458,
                "title": "python-c-intuitive-2-pointer-o-nlogn-and-o-n-solution",
                "content": "O(NlogN) Approach :\\nPYTHON\\n```\\n def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        i, j = 0, len(nums)-1\\n        res = 0\\n        while(i<j):\\n            summ = nums[i]+nums[j]\\n            if(summ == k):\\n                i+=1\\n                j-=1\\n                res+=1\\n            elif(summ < k):\\n                i+=1\\n            else:\\n                j-=1\\n        return res\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j =  nums.size()-1;\\n        int res = 0;\\n        while(i<j){\\n            int summ = nums[i]+nums[j];\\n            if(summ == k){\\n                i+=1;\\n                j-=1;\\n                res+=1;\\n            }\\n            else if(summ < k)\\n                    i+=1;\\n                 else\\n                    j-=1;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n\\n\\nO( N ) approach using dictionary. [Python] \\n```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        d = Counter(nums) #count frequency\\n\\t\\tfor x in nums:                 # At the end we need x + y = k\\n            if( x in d and d[x] > 0 ): # If we have x avaialble to choose from\\n                d[x]-=1                # Then pick it\\n                y = k -x               # Search for y\\n                if( y in d and d[y] > 0):  # If y is available to choose from\\n                    d[y]-=1            # Then pick it\\n                    res+=1             # As we picked both x and y, hence increase count\\n                else:                  # # If we didnt find y, matching x+y=k, then \\n                    d[x]+=1            # Put x back\\n        return res\\n```\\n\\nA more optimised version of above could be written as shown below:\\nInstead of looping the whole array again and increamenting pair count by 1 each time. We can increament bunch of pair counts in a single shot.\\nFor ex: If we have [ 3, 3, 3, 3, 3, 3, 3, 4, 5] and k=6. Then, \"3\" is occuring 7 times hence it can form 3 pairs.\\nTherefore we can add 7//2 ~ 3 pairs directly to the result.\\n\\n```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        d = Counter(nums)           #count frequency\\n        for x in d:                 # Get x\\n            y = k -x                # Get y\\n            if(x == y):             # If sum is 6, and x=y=3 and 3 is occuring 10 times, then \\n                res+= d[x]//2       # we can directly add half (5 pairs) of the frequency\\n            else:                   # If both are different\\n                if(y in d):         # And if y exists in the array\\n                    minn = min(d[x], d[y]) # Take the minimum frequent number completely\\n                    res+=minn              # As we have picked minn number of x and y directly\\n                    d[x]-=minn             # Remove so many from both x and y frquency count\\n                    d[y]-=minn\\n        return res\\n```\\n\\nEdit:\\nAs per the comment of @sorosrex, code can be simplifed to this\\n```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n    cache = defaultdict(int)\\n    num_ops = 0\\n    for i in nums:\\n        if cache[i] > 0:\\n            cache[i] -= 1\\n            num_ops += 1\\n            continue\\n        cache[k-i] += 1\\n    return num_ops\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        i, j = 0, len(nums)-1\\n        res = 0\\n        while(i<j):\\n            summ = nums[i]+nums[j]\\n            if(summ == k):\\n                i+=1\\n                j-=1\\n                res+=1\\n            elif(summ < k):\\n                i+=1\\n            else:\\n                j-=1\\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j =  nums.size()-1;\\n        int res = 0;\\n        while(i<j){\\n            int summ = nums[i]+nums[j];\\n            if(summ == k){\\n                i+=1;\\n                j-=1;\\n                res+=1;\\n            }\\n            else if(summ < k)\\n                    i+=1;\\n                 else\\n                    j-=1;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\n```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        d = Counter(nums) #count frequency\\n\\t\\tfor x in nums:                 # At the end we need x + y = k\\n            if( x in d and d[x] > 0 ): # If we have x avaialble to choose from\\n                d[x]-=1                # Then pick it\\n                y = k -x               # Search for y\\n                if( y in d and d[y] > 0):  # If y is available to choose from\\n                    d[y]-=1            # Then pick it\\n                    res+=1             # As we picked both x and y, hence increase count\\n                else:                  # # If we didnt find y, matching x+y=k, then \\n                    d[x]+=1            # Put x back\\n        return res\\n```\n```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        d = Counter(nums)           #count frequency\\n        for x in d:                 # Get x\\n            y = k -x                # Get y\\n            if(x == y):             # If sum is 6, and x=y=3 and 3 is occuring 10 times, then \\n                res+= d[x]//2       # we can directly add half (5 pairs) of the frequency\\n            else:                   # If both are different\\n                if(y in d):         # And if y exists in the array\\n                    minn = min(d[x], d[y]) # Take the minimum frequent number completely\\n                    res+=minn              # As we have picked minn number of x and y directly\\n                    d[x]-=minn             # Remove so many from both x and y frquency count\\n                    d[y]-=minn\\n        return res\\n```\n```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n    cache = defaultdict(int)\\n    num_ops = 0\\n    for i in nums:\\n        if cache[i] > 0:\\n            cache[i] -= 1\\n            num_ops += 1\\n            continue\\n        cache[k-i] += 1\\n    return num_ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961354,
                "title": "java-hashmap-o-n-and-two-pointer-o-nlogn",
                "content": "Using hashMap\\nTime: O(n)\\nSpace: O(n)\\n```\\npublic int maxOperations(int[] nums, int k) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint result = 0;\\n\\tfor(int i: nums)\\n\\t\\tif(map.containsKey(i) && map.get(i) > 0) {\\n\\t\\t\\tmap.put(i, map.get(i) - 1);\\n\\t\\t\\tresult ++;\\n\\t\\t} else map.put(k-i, map.getOrDefault(k-i, 0) + 1);\\n\\treturn result;\\n}\\n```\\n\\nTwo pointer\\nTime: O(nlogn)\\nSpace: O(1)\\n```\\npublic int maxOperations(int[] nums, int k) {\\n\\tArrays.sort(nums);\\n\\tint result = 0, i =0, j= nums.length -1;\\n\\twhile(i<j)\\n\\t\\tif(nums[i]+nums[j] > k) j--;\\n\\t\\telse if(nums[i]+nums[j] < k) i++;\\n\\t\\telse {i++;j--;result++;}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxOperations(int[] nums, int k) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint result = 0;\\n\\tfor(int i: nums)\\n\\t\\tif(map.containsKey(i) && map.get(i) > 0) {\\n\\t\\t\\tmap.put(i, map.get(i) - 1);\\n\\t\\t\\tresult ++;\\n\\t\\t} else map.put(k-i, map.getOrDefault(k-i, 0) + 1);\\n\\treturn result;\\n}\\n```\n```\\npublic int maxOperations(int[] nums, int k) {\\n\\tArrays.sort(nums);\\n\\tint result = 0, i =0, j= nums.length -1;\\n\\twhile(i<j)\\n\\t\\tif(nums[i]+nums[j] > k) j--;\\n\\t\\telse if(nums[i]+nums[j] < k) i++;\\n\\t\\telse {i++;j--;result++;}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022707,
                "title": "c-hashmap-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxOperations(vector<int>& nums, int k) {\\n\\t\\t\\tunordered_map<int, int> m;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\t\\tif(m[k - nums[i]] > 0){\\n\\t\\t\\t\\t   m[k - nums[i]]--;\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tm[nums[i]]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxOperations(vector<int>& nums, int k) {\\n\\t\\t\\tunordered_map<int, int> m;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\t\\tif(m[k - nums[i]] > 0){\\n\\t\\t\\t\\t   m[k - nums[i]]--;\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 961406,
                "title": "java-python-3-two-hashmap-dictionary-o-n-codes-w-analysis",
                "content": "**Method 1:**\\n```java\\n    public int maxOperations(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int ans = 0;\\n        for (int n : nums) {\\n            map.put(n, 1 + map.getOrDefault(n, 0));\\n        }\\n        for (int key : map.keySet()) {\\n            if (key * 2 == k) {\\n                ans += map.get(key) / 2;\\n            }else if (map.containsKey(k - key)) {\\n                int min = Math.min(map.get(key), map.get(k - key));\\n                ans += min;\\n                map.put(key, map.get(key) - min);\\n                map.put(k - key, map.get(k - key) - min);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        d = Counter(nums)\\n        ans = 0\\n        for key in d.keys():\\n            if key * 2 == k:\\n                ans += d[key] // 2\\n            elif d[k - key] > 0:\\n                mi = min(d[key], d[k - key])\\n                d[key] -= mi     \\n                d[k - key] -= mi\\n                ans += mi\\n        return ans\\n```\\n\\n----\\n\\n**Method 2: One pass- credit to @sanmao0715**\\n\\nSimilar to Two Sum, loop through input array, check if the other part, `k - num`, is available. If yes, count it into solution; Otherwise, count current `num` into HashMap/dictionary.\\n```\\n    public int maxOperations(int[] nums, int k) {\\n        int res = 0;\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int num : nums) {\\n            if (count.getOrDefault(k - num, 0) > 0) {\\n                count.put(k - num, count.get(k - num) - 1);\\n                ++res;\\n            }else {\\n                count.put(num, 1 + count.getOrDefault(num, 0));\\n            }\\n        }\\n        return res;\\n    }\\n```\\n```python\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        d = defaultdict(int)\\n      # for i, num in enumerate(nums):\\n        for num in nums:\\n            if d[k - num] > 0:\\n                # we see the other half before, add to the result\\n                d[k - num] -= 1\\n                res += 1\\n            else:\\n                d[num] += 1\\n        return res\\n```\\n**Analysis:**\\n\\nTime & space: O(n), where n = nums.length.",
                "solutionTags": [],
                "code": "```java\\n    public int maxOperations(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int ans = 0;\\n        for (int n : nums) {\\n            map.put(n, 1 + map.getOrDefault(n, 0));\\n        }\\n        for (int key : map.keySet()) {\\n            if (key * 2 == k) {\\n                ans += map.get(key) / 2;\\n            }else if (map.containsKey(k - key)) {\\n                int min = Math.min(map.get(key), map.get(k - key));\\n                ans += min;\\n                map.put(key, map.get(key) - min);\\n                map.put(k - key, map.get(k - key) - min);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        d = Counter(nums)\\n        ans = 0\\n        for key in d.keys():\\n            if key * 2 == k:\\n                ans += d[key] // 2\\n            elif d[k - key] > 0:\\n                mi = min(d[key], d[k - key])\\n                d[key] -= mi     \\n                d[k - key] -= mi\\n                ans += mi\\n        return ans\\n```\n```\\n    public int maxOperations(int[] nums, int k) {\\n        int res = 0;\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int num : nums) {\\n            if (count.getOrDefault(k - num, 0) > 0) {\\n                count.put(k - num, count.get(k - num) - 1);\\n                ++res;\\n            }else {\\n                count.put(num, 1 + count.getOrDefault(num, 0));\\n            }\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        d = defaultdict(int)\\n      # for i, num in enumerate(nums):\\n        for num in nums:\\n            if d[k - num] > 0:\\n                # we see the other half before, add to the result\\n                d[k - num] -= 1\\n                res += 1\\n            else:\\n                d[num] += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2007455,
                "title": "java-2-approaches-100-two-pointer-sorting-hashmap",
                "content": "1st Approach\\nThe Code Should be Self Explanatory. We Use HashMap to store the Integers as we go and Check if the k-nums[i] is already in the hashmap. If it is we increment the Count and decrease the Integer value by 1 in hashmap Otherwise we add the Integer in the HashMap.\\n```\\n\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm= new HashMap<>();\\n\\t\\t//Initialized The Counter\\n        int count=0;\\n        for(int i=0; i<nums.length; i++){\\n\\t\\t// Checking if the HashMap Contains the k-nums[i] (desired Integer)\\n            if(hm.containsKey(k-nums[i]) && hm.get(k-nums[i])>0){\\n                count +=1;\\n                hm.put((k-nums[i]),(hm.get(k-nums[i])-1));\\n            }\\n\\t\\t\\t// Otherwise we add the Integer to the HashMap\\n            else{\\n                hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n\\t\\t// Return the Count\\n        return count;\\n\\t}\\n}\\t\\n\\n```\\n2nd Approach\\nFirst We Sort the Array then Initialize two pointer i=0 and j= nums.length-1 and we check if the sum of Integer at i and j == k then we increament the Count and move i to the next Integer and j to the previous Integer(i++ and j--)\\nOtherwise we Check if the sum of Integer at i and j is greater than k then we decrease the j pointer by -1(j--) or else we will increment the i by +1(i++) because that means Sum of i and j is less than k, So We need to Increase the i pointer.\\n\\n```\\n\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n       // Sorting the Array\\n       Arrays.sort(nums);\\n\\t   //Initializing the Count\\n        int count=0;\\n        for(int i=0,j=nums.length-1; i<j;){\\n\\t\\t//if Integer at i and j = equal, increament the Count and move the pointer\\n            if(nums[i]+nums[j]==k){\\n                count +=1;\\n                j--;\\n                i++;\\n            }\\n\\t\\t\\t// if the Integers at i and j are greater the k, we need the decrease the sum so we move the j pointer by -1 \\n            else if(nums[i]+nums[j]>k){\\n                j--;\\n            }  \\n\\t\\t\\t// else we increment the i pointer by +1\\n            else {\\n                i++;\\n            }\\n        }\\n\\t\\tReturn the Count\\n\\t\\treturn count;\\n\\t}\\n}\\n\\n```\\nPlease Upvote if you found it helpful\\nComment down below if you have any Doubt\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm= new HashMap<>();\\n\\t\\t//Initialized The Counter\\n        int count=0;\\n        for(int i=0; i<nums.length; i++){\\n\\t\\t// Checking if the HashMap Contains the k-nums[i] (desired Integer)\\n            if(hm.containsKey(k-nums[i]) && hm.get(k-nums[i])>0){\\n                count +=1;\\n                hm.put((k-nums[i]),(hm.get(k-nums[i])-1));\\n            }\\n\\t\\t\\t// Otherwise we add the Integer to the HashMap\\n            else{\\n                hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n\\t\\t// Return the Count\\n        return count;\\n\\t}\\n}\\t\\n\\n```\n```\\n\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n       // Sorting the Array\\n       Arrays.sort(nums);\\n\\t   //Initializing the Count\\n        int count=0;\\n        for(int i=0,j=nums.length-1; i<j;){\\n\\t\\t//if Integer at i and j = equal, increament the Count and move the pointer\\n            if(nums[i]+nums[j]==k){\\n                count +=1;\\n                j--;\\n                i++;\\n            }\\n\\t\\t\\t// if the Integers at i and j are greater the k, we need the decrease the sum so we move the j pointer by -1 \\n            else if(nums[i]+nums[j]>k){\\n                j--;\\n            }  \\n\\t\\t\\t// else we increment the i pointer by +1\\n            else {\\n                i++;\\n            }\\n        }\\n\\t\\tReturn the Count\\n\\t\\treturn count;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005923,
                "title": "c-two-approaches-o-n-time-o-n-log-n-time-easy-to-understand",
                "content": "This problem can be done using a hashmap by storing the frequency of elements we are encountering.\\n1. For every element check if (K - nums[i]) is present in the map. If it is there then we got a pair ,and we decrease the frequency of  (K - nums[i]) by 1  since we used one occurence of this element.\\n2. If we did not find (K - nums[i]) with frequency greater than zero, then we put our current element in the hashmap too.\\n\\n# Time Complexity : O(n)\\n# Space Complexity : O(n)\\n\\n\\n```\\n       int count =0;\\n        unordered_map<int,int> mp;\\n        \\n        for(int i =0;i<nums.size();i++){\\n        \\n            int diff = k - nums[i];  \\n            if(mp[diff]>0){\\n                \\n                count++;               // increase count since we got the pair\\n                mp[diff]--;            // decrease freq of diff as we used it for our pair \\n                \\n            }\\n            else{\\n                mp[nums[i]]++;         // no pair found so put it in hashmap\\n            }\\n            \\n            \\n        }\\n        \\n        return count;\\n```\\n\\nIt can also be done by sorting followed by a two pointer algorithm . This problem is kind of an easy version of standard pair sum problem which is solved by sorting and then applying two pointer algorithm , the change is that in pair sum problem ,we need to maintain a hashmap for duplicate elements because we were asked to find all the possible pairs . But in this problem we actually have to delete a pair so we don\\'t need to maintain a hashmap to count duplicates.\\n\\n# Time Complexity : O(n log n)\\n# Space Complexity : O(1)\\n\\n```\\n        sort(nums.begin(),nums.end());\\n        int i =0;\\n        int j =nums.size()-1;\\n        int count =0;\\n        while(i<j){\\n            if(nums[i]+nums[j]>k){\\n                j--;\\n                continue;\\n            }\\n            if(nums[i]+nums[j]==k){\\n                count++;\\n                i++;\\n                j--;\\n                continue;\\n            }\\n            \\n            if(nums[i]+nums[j]<k){\\n                i++;\\n                continue;\\n            }\\n            \\n        }\\n        \\n        return count;\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n       int count =0;\\n        unordered_map<int,int> mp;\\n        \\n        for(int i =0;i<nums.size();i++){\\n        \\n            int diff = k - nums[i];  \\n            if(mp[diff]>0){\\n                \\n                count++;               // increase count since we got the pair\\n                mp[diff]--;            // decrease freq of diff as we used it for our pair \\n                \\n            }\\n            else{\\n                mp[nums[i]]++;         // no pair found so put it in hashmap\\n            }\\n            \\n            \\n        }\\n        \\n        return count;\\n```\n```\\n        sort(nums.begin(),nums.end());\\n        int i =0;\\n        int j =nums.size()-1;\\n        int count =0;\\n        while(i<j){\\n            if(nums[i]+nums[j]>k){\\n                j--;\\n                continue;\\n            }\\n            if(nums[i]+nums[j]==k){\\n                count++;\\n                i++;\\n                j--;\\n                continue;\\n            }\\n            \\n            if(nums[i]+nums[j]<k){\\n                i++;\\n                continue;\\n            }\\n            \\n        }\\n        \\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3697500,
                "title": "python-3-two-solution-with-counter-and-two-points-beats-99-9",
                "content": "```python3 []\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        res, d = 0, Counter(nums)\\n        for val1, cnt in d.items():\\n            val2 = k - val1\\n            # it\\'s trick to get rid of duplicates pairs, consider only pairs where val1 >= val2\\n            if val2 < val1 or val2 not in d: continue \\n            res += min(cnt, d[val2]) if val1 != val2 else cnt//2\\n        \\n        return res\\n```\\n```python3 []\\nclass Solution:\\n    def maxOperations2(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res, l, r = 0, 0 ,len(nums) - 1\\n\\n        while l < r:\\n            S = nums[l] + nums[r]\\n            if S > k:\\n                r -= 1\\n            elif S < k:\\n                l += 1\\n            else:\\n                res += 1\\n                l += 1\\n                r -= 1\\n        return res\\n\\n```\\n![Screenshot 2023-07-29 at 17.50.49.png](https://assets.leetcode.com/users/images/764c906d-9666-400d-a3a2-1b0d3e249ffc_1690642335.1321275.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        res, d = 0, Counter(nums)\\n        for val1, cnt in d.items():\\n            val2 = k - val1\\n            # it\\'s trick to get rid of duplicates pairs, consider only pairs where val1 >= val2\\n            if val2 < val1 or val2 not in d: continue \\n            res += min(cnt, d[val2]) if val1 != val2 else cnt//2\\n        \\n        return res\\n```\n```python3 []\\nclass Solution:\\n    def maxOperations2(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res, l, r = 0, 0 ,len(nums) - 1\\n\\n        while l < r:\\n            S = nums[l] + nums[r]\\n            if S > k:\\n                r -= 1\\n            elif S < k:\\n                l += 1\\n            else:\\n                res += 1\\n                l += 1\\n                r -= 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022780,
                "title": "c-short-clean-simple-o-n-solution-faster-than-99-8",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> counter;\\n        int res = 0;\\n        for (auto n : nums)\\n            if (n < k)\\n                counter[n]++;\\n            \\n        for (auto [a, cnt] : counter)\\n            if (counter.count(k - a))\\n                res += min(counter[k - a], cnt);\\n    \\n        return res/2;\\n    }\\n};\\n```\\n**Like it? please upvote\\nHave any comments? I\\'d love to hear!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> counter;\\n        int res = 0;\\n        for (auto n : nums)\\n            if (n < k)\\n                counter[n]++;\\n            \\n        for (auto [a, cnt] : counter)\\n            if (counter.count(k - a))\\n                res += min(counter[k - a], cnt);\\n    \\n        return res/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022980,
                "title": "c-linear-time-vs-constant-space-solutions-compared-and-explained-100-time-100-space",
                "content": "I really wonder how problems are ranked sometimes, since problems with the same base idea and an extra twist are sometimes passed as easy \\uD83E\\uDD14 .\\n\\nWell, anyway, in our first approach we will go with one single pass, using just 2 support variables:\\n* `res` will store the number of matches we can find;\\n* `m` will map each value to its *remaining* frequency so far.\\n\\nTo clarify in that sense, we will loop through each number `n` in `nums` and:\\n* if we already encountered its complementary number at least once (`m[k - n] > 0`), we will:\\n\\t* reduce the frequency of said complemenetary number (`m[k - n]--`);\\n\\t* increase `res` by `1`;\\n* otherwise, we will just increase the frequency of `n` in our accumulator.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        // support variables\\n        int res = 0;\\n        unordered_map<int, int> m;\\n        // main loop\\n        for (int n: nums) {\\n            if (m[k - n] > 0) {\\n                m[k - n]--;\\n                res++;\\n            }\\n            else m[n]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNow, that was the super-naive solution, that, among other things, will always create a key-value pair for `k - n` when we try to access it; the memory usage for that one was about 15%.\\n\\nWith some smart optimisation (including storing the value of the complement not to recompute the subtraction again) and using pointers to also save on the hashing function, I was able to get my best time of 100ms (I would say averaging ~30-40ms less than the previous solution, but the random tests vary wildly, so do not take my word for it), with memory usage now in the 60-65% range:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        // support variables\\n        int res = 0, complement;\\n        unordered_map<int, int> m;\\n        // main loop\\n        for (int n: nums) {\\n            complement = k - n;\\n            auto compPos = m.find(complement);\\n            if (compPos != end(m) && compPos->second > 0) {\\n                compPos->second--;\\n                res++;\\n            }\\n            else m[n]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe biggest surprise came from trying to keep constant space.\\n\\nIn this solution, I used 3 support variables:\\n* `res`, as above,\\n* `i` and `j`, pointers respectively initialised to the first and last element.\\n* `tot` to store our current sum of elements pointed by `i` and `j`.\\n\\nIn order for our logic to work, we will have then to sort `nums`, so to be sure that `nums[i] <= nums[j]` since this is going to be our loop invariant.\\n\\nWe will then loop as long as `i < j` and:\\n* compute `tot`, as specified above,\\n* deal with 3 cases:\\n\\t* `tot == k` which means we found a match, so we will:\\n\\t\\t* advance `i` and `j`;\\n\\t\\t* increase `res`;\\n\\t* `tot < k`, so we just advance `i`;\\n\\t* `tot > k`, so we just advance `j`.\\n\\nOnce done, we can return `res` :)\\n\\nThe code, which, to my surprise, was the fastest - I guess hashmaps really come with plenety of overhead:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        // support variables\\n        int res = 0, i = 0, j = nums.size() - 1, tot;\\n        // preparing nums\\n        sort(begin(nums), end(nums));\\n        while (i < j) {\\n            tot = nums[i] + nums[j];\\n            // first case: tot is a match\\n            if (tot == k) i++, j--, res++;\\n            // second case: tot is too small\\n            else if (tot < k) i++;\\n            // third case: tot is too large\\n            else j--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        // support variables\\n        int res = 0;\\n        unordered_map<int, int> m;\\n        // main loop\\n        for (int n: nums) {\\n            if (m[k - n] > 0) {\\n                m[k - n]--;\\n                res++;\\n            }\\n            else m[n]++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        // support variables\\n        int res = 0, complement;\\n        unordered_map<int, int> m;\\n        // main loop\\n        for (int n: nums) {\\n            complement = k - n;\\n            auto compPos = m.find(complement);\\n            if (compPos != end(m) && compPos->second > 0) {\\n                compPos->second--;\\n                res++;\\n            }\\n            else m[n]++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        // support variables\\n        int res = 0, i = 0, j = nums.size() - 1, tot;\\n        // preparing nums\\n        sort(begin(nums), end(nums));\\n        while (i < j) {\\n            tot = nums[i] + nums[j];\\n            // first case: tot is a match\\n            if (tot == k) i++, j--, res++;\\n            // second case: tot is too small\\n            else if (tot < k) i++;\\n            // third case: tot is too large\\n            else j--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774197,
                "title": "java-solution-beats-98-o-nlogn-time-o-1-space",
                "content": "-- Time Complexity $$O(nlogn)$$\\n-- space complexity $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int left=0,right = nums.length-1,count=0;\\n        while(left<right) {\\n            int sum = nums[left] + nums[right];\\n\\n            if(sum == k) {\\n                left++;\\n                right--;\\n                count++;\\n            }else if(sum>k) {\\n                right--;\\n            }else {\\n                left++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n![1271c6fe-345b-4f3d-959e-d13e791111d7_1677726484.8832572.jpeg](https://assets.leetcode.com/users/images/bce5fce4-78d0-4926-93bb-975365036328_1689520076.1503363.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int left=0,right = nums.length-1,count=0;\\n        while(left<right) {\\n            int sum = nums[left] + nums[right];\\n\\n            if(sum == k) {\\n                left++;\\n                right--;\\n                count++;\\n            }else if(sum>k) {\\n                right--;\\n            }else {\\n                left++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907479,
                "title": "simple-java-solution-sorting-two-pointers-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use 2 pointer to find all possible indices i and j for which `nums[i] + nums[j] == k `.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nSorting + Two pointers\\n```\\nAt first sort the array.Then declare two variable as a pointer.If the sum is lower than k,then increase the lower pointer because we can\\'t find any pair before this.If the sum is greater than k,we decrease the high pointer cause now we find lower pair.\\n\\n\\n# Complexity\\n- Time complexity:` O(nlogn)`\\nO(nlogn) for sorting and O(n)for while loop.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i=0 , j = nums.length-1;\\n        int count=0;\\n        while(i<j){\\n            if(nums[i]+nums[j] == k){\\n                count++; i++; j--;\\n            }\\n            else if(nums[i]+nums[j] < k){\\n                i++;\\n            }\\n            else j--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nSorting + Two pointers\\n```\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i=0 , j = nums.length-1;\\n        int count=0;\\n        while(i<j){\\n            if(nums[i]+nums[j] == k){\\n                count++; i++; j--;\\n            }\\n            else if(nums[i]+nums[j] < k){\\n                i++;\\n            }\\n            else j--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006604,
                "title": "java-sorting-2-pointers-clean-code-simple-solution-easy",
                "content": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int low = 0, high = nums.length - 1, minOperations = 0;\\n        \\n        while(low < high){\\n            if(nums[low] + nums[high] == k){\\n                low++;\\n                high--;\\n                minOperations++;\\n            } \\n            else if(nums[low] + nums[high] > k) high--;\\n            else low++;\\n        }\\n        \\n        return minOperations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int low = 0, high = nums.length - 1, minOperations = 0;\\n        \\n        while(low < high){\\n            if(nums[low] + nums[high] == k){\\n                low++;\\n                high--;\\n                minOperations++;\\n            } \\n            else if(nums[low] + nums[high] > k) high--;\\n            else low++;\\n        }\\n        \\n        return minOperations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024043,
                "title": "python-explanation",
                "content": "The idea is that there is only one int `k - n` that can be paired with `n`. That said we can remember which and how many `k - n` do we need when `n` is encountered. If we find `k - n`, we can delete one `n` from dict because we can\\'t use that int more than once.\\n\\nWe can use default dictionary from python lib so not to get ValueError in the absence of some key.\\n \\n```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        pair = defaultdict(int) # integer 0 is the default value of all the keys\\n        res = 0\\n        \\n        for n in nums:\\n            if pair[n]: # if we encountered k - n already\\n                res += 1\\n                pair[n] -= 1\\n            else: # if we did\\'n find a pair yet\\n                pair[k - n] += 1\\n                \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        pair = defaultdict(int) # integer 0 is the default value of all the keys\\n        res = 0\\n        \\n        for n in nums:\\n            if pair[n]: # if we encountered k - n already\\n                res += 1\\n                pair[n] -= 1\\n            else: # if we did\\'n find a pair yet\\n                pair[k - n] += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727977,
                "title": "easy-hashmap-solution-java",
                "content": "# Easy HashMap Solution : \\n# Java Code : \\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int target) {\\n        HashMap<Integer,Integer>  hmap = new HashMap<>();\\n        int count = 0;\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            if(hmap.containsKey(target-nums[i]) == true)\\n            {\\n                count++;\\n                if(hmap.get(target-nums[i]) == 1)\\n                    hmap.remove(target-nums[i]);\\n                else\\n                    hmap.put(target-nums[i],hmap.get(target-nums[i])-1);\\n            }\\n            else\\n            {\\n                hmap.put(nums[i],hmap.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked mu solution.* \\uD83D\\uDD25\\n---",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int target) {\\n        HashMap<Integer,Integer>  hmap = new HashMap<>();\\n        int count = 0;\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            if(hmap.containsKey(target-nums[i]) == true)\\n            {\\n                count++;\\n                if(hmap.get(target-nums[i]) == 1)\\n                    hmap.remove(target-nums[i]);\\n                else\\n                    hmap.put(target-nums[i],hmap.get(target-nums[i])-1);\\n            }\\n            else\\n            {\\n                hmap.put(nums[i],hmap.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964836,
                "title": "c-java-python-short-and-concise-o-n-solution-using-hashmap",
                "content": "We can just add every pair, regardless of the order, and then divide it by 2.\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> hash;\\n        for (int num : nums) {\\n            hash[num]++;\\n        }\\n        int ans = 0;\\n        for (auto [x, y] : hash) {\\n            if (hash.count(k - x)) {\\n                ans += min(y, hash[k - x]);\\n            }\\n        }\\n        return ans / 2;\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        cc = Counter(nums)\\n        ans = 0\\n        for i in cc:\\n            ans += min(cc[i], cc[k - i])\\n        return ans // 2\\n```\\nshorter version:\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        cc = Counter(nums)\\n        return sum([min(cc[i], cc[k - i]) for i in cc]) // 2\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        int ans = 0;\\n        for (var entry : map.entrySet()) {\\n            int x = entry.getKey();\\n            if (map.containsKey(k - x)) {\\n                ans += Math.min(entry.getValue(), map.get(k - x));\\n            }\\n        }\\n        return ans / 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> hash;\\n        for (int num : nums) {\\n            hash[num]++;\\n        }\\n        int ans = 0;\\n        for (auto [x, y] : hash) {\\n            if (hash.count(k - x)) {\\n                ans += min(y, hash[k - x]);\\n            }\\n        }\\n        return ans / 2;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        cc = Counter(nums)\\n        ans = 0\\n        for i in cc:\\n            ans += min(cc[i], cc[k - i])\\n        return ans // 2\\n```\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        cc = Counter(nums)\\n        return sum([min(cc[i], cc[k - i]) for i in cc]) // 2\\n```\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        int ans = 0;\\n        for (var entry : map.entrySet()) {\\n            int x = entry.getKey();\\n            if (map.containsKey(k - x)) {\\n                ans += Math.min(entry.getValue(), map.get(k - x));\\n            }\\n        }\\n        return ans / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961522,
                "title": "c-beginner-friendly-easy-understanding-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(int i: nums) map[i]++;\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            int x=nums[i];\\n            if(map[x]>0 && map[k-x]>0){\\n                cnt++;\\n                map[k-x]--;\\n                map[x]--;\\n                if(map[x]<0) cnt--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(int i: nums) map[i]++;\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            int x=nums[i];\\n            if(map[x]>0 && map[k-x]>0){\\n                cnt++;\\n                map[k-x]--;\\n                map[x]--;\\n                if(map[x]<0) cnt--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079699,
                "title": "2-best-approaches",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n# **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n#### **[https://www.instagram.com/pratay_nandy/]()**\\n# CHECK OUT BOTH THE APPROACHES\\n# Approach\\nThis code implements a solution to find the maximum number of pairs of integers from the nums vector whose sum is equal to k. The solution uses an unordered map `umap`to keep track of the frequencies of numbers encountered in the `nums` vector. The idea is to find pairs of numbers such that their sum equals `k` by checking if the complement of the current number `(k - nums[i]`) has been encountered before.\\n\\nHere\\'s a step-by-step explanation of the solution:\\n\\n- Initialize an unordered map ``umap`` to store the frequencies of numbers encountered and an integer ans to store the count of pairs whose sum equals k.\\n\\n- Iterate through the nums vector using a for loop.\\n\\n- For each element ``nums[i]`` in the nums vector:\\n\\n- Calculate the complement of ``nums[i]`` with respect to k as k - `nums[i]`. This is the value that, when added to `nums[i]`, would make the sum equal to k.\\n- Check if the complement `(k - nums[i])` is already present in the \\nand its frequency is greater than zero:\\n\\n- If it is, decrement the frequency of the complement in `umap` by 1 (to mark that it has been used), and increment the ans variable by 1. This represents finding a pair whose sum equals k.\\n- If the complement is not in `umap` or its frequency is zero, it means we haven\\'t encountered a number that can form a pair with the current ``nums[i]`` to make the sum equal to k. In this case, we increment the frequency of `nums[i]` in `umap`.\\n\\n- Continue this process for all elements in the nums vector.\\n\\n- Finally, return the value of `ans`, which represents the maximum number of pairs whose sum equals k.\\n\\nThis algorithm efficiently counts the pairs whose sum is equal to k by using the `umap` to keep track of the numbers encountered and their frequencies.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**0(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint maxOperations(vector<int>& nums, int k) {\\n\\t\\tunordered_map<int, int> umap;\\n\\t\\tint ans = 0;\\n\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\tif(umap[k - nums[i]] > 0){\\n\\t\\t\\t   umap[k - nums[i]]--;\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tumap[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n# Approach\\nThe provided C++ code defines a `maxOperations` function that takes a vector of integers `arr` and an integer `k` as input. It aims to find the maximum number of pairs of integers from the `arr` vector whose sum equals `k`. This solution uses a two-pointer approach after sorting the input array.\\n\\nHere\\'s the step-by-step explanation of the approach:\\n\\n- First, the input `arr` vector is sorted in ascending order using std::`sort`. Sorting the array allows us to efficiently use a two-pointer approach.\\n\\n- Initialize two pointers, `i` and `j`, to the beginning and end of the sorted arr vector, respectively. These pointers will represent the current elements being considered for forming pairs.\\n\\n- Initialize a variable op to count the number of valid pairs whose sum equals `k`.\\n\\n- Use a while loop that continues as long as `i` is less than `j`. This loop is the core of the two-pointer approach.\\n\\n- Inside the loop:\\n\\n- Check if the sum of `arr[i]` and `arr[j]` is equal to `k`. If it is, it means you\\'ve found a valid pair, so increment `i` and decrement `j` to consider the next pair of elements, and increment the op count by `1`.\\n\\n- If the sum of `arr[i]` and `arr[j]` is less than k, increment i. Since the array is sorted, moving i to the right will increase the sum, potentially getting closer to k.\\n\\n- If the sum of `arr[i]` and `arr[j]` is greater than k, decrement j. Moving j to the left will decrease the sum, potentially getting closer to k.\\n\\n- Continue this process until `i` is less than `j`. When `i` becomes greater than or equal to `j`, you\\'ve checked all possible pairs.\\n\\n- Finally, return the value of op, which represents the maximum number of pairs whose sum equals `k`.\\n\\nThe two-pointer approach in this solution efficiently finds pairs in a sorted array, making it a time-efficient solution\\n# Complexity\\n- Time complexity:**0(NlogN)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n\\tint maxOperations(vector<int>& arr, int k) {\\n        sort(arr.begin(),arr.end());\\n        int i = 0 ; int j = arr.size()-1;\\n        int op =0;\\n        while(i<j)\\n        {\\n            if(arr[i]+arr[j] == k)\\n            {\\n                i++;j--;\\n                op ++;\\n            }\\n            else if(arr[i]+arr[j] < k)\\n            {\\n                i++;\\n            }\\n            else if(arr[i]+arr[j] > k)\\n            {\\n                j--;\\n            }\\n        }\\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint maxOperations(vector<int>& nums, int k) {\\n\\t\\tunordered_map<int, int> umap;\\n\\t\\tint ans = 0;\\n\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\tif(umap[k - nums[i]] > 0){\\n\\t\\t\\t   umap[k - nums[i]]--;\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tumap[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint maxOperations(vector<int>& arr, int k) {\\n        sort(arr.begin(),arr.end());\\n        int i = 0 ; int j = arr.size()-1;\\n        int op =0;\\n        while(i<j)\\n        {\\n            if(arr[i]+arr[j] == k)\\n            {\\n                i++;j--;\\n                op ++;\\n            }\\n            else if(arr[i]+arr[j] < k)\\n            {\\n                i++;\\n            }\\n            else if(arr[i]+arr[j] > k)\\n            {\\n                j--;\\n            }\\n        }\\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000686,
                "title": "java-easy-to-understand-hashmap-and-2-pointer",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\nHashMap\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans=0;\\n        for(int i:nums){\\n            int remaining = k-i;\\n            if(map.containsKey(remaining)){\\n                ans++;\\n                if(map.get(remaining)==1){\\n                    map.remove(remaining);\\n                }\\n                else{\\n                    map.put(remaining, map.get(remaining)-1);\\n                }\\n            }\\n            else{\\n                map.put(i, map.getOrDefault(i, 0)+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: O(nlog(n))\\nO(nlogn) = Sorting and O(n) = while loop\\n\\n- Space complexity: O(1)\\n\\n# Code\\nSorting and Two Pointer\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=0, y=nums.length-1 ; i<y ;){\\n            if(nums[i]+nums[y]==k){\\n                ans++;\\n                i++;\\n                y--;\\n            }\\n            else if(nums[i]+nums[y]<k){\\n                i++;\\n            }\\n            else{\\n                y--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans=0;\\n        for(int i:nums){\\n            int remaining = k-i;\\n            if(map.containsKey(remaining)){\\n                ans++;\\n                if(map.get(remaining)==1){\\n                    map.remove(remaining);\\n                }\\n                else{\\n                    map.put(remaining, map.get(remaining)-1);\\n                }\\n            }\\n            else{\\n                map.put(i, map.getOrDefault(i, 0)+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=0, y=nums.length-1 ; i<y ;){\\n            if(nums[i]+nums[y]==k){\\n                ans++;\\n                i++;\\n                y--;\\n            }\\n            else if(nums[i]+nums[y]<k){\\n                i++;\\n            }\\n            else{\\n                y--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005905,
                "title": "c-easiest-understanding-solution-t-c-o-n-log-n-s-c-o-1",
                "content": "**Simple Two Pointer Approach**\\n**Time Complexity: O(n*log(n))**\\n**Space Complexity: O(1)**\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(), nums.end());\\n        int start = 0, end = nums.size() - 1;\\n        int ans = 0;\\n        while (start < end)\\n        {\\n            if (nums[start] + nums[end] == k)\\n            {\\n                ans++;\\n                start++;\\n                end--;\\n            }\\n            else if (nums[start] + nums[end] < k)\\n                start++;\\n            else\\n                end--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(), nums.end());\\n        int start = 0, end = nums.size() - 1;\\n        int ans = 0;\\n        while (start < end)\\n        {\\n            if (nums[start] + nums[end] == k)\\n            {\\n                ans++;\\n                start++;\\n                end--;\\n            }\\n            else if (nums[start] + nums[end] < k)\\n                start++;\\n            else\\n                end--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023882,
                "title": "java-easy-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int cnt = 0 , i = 0, j = nums.length - 1;\\n        // two pointer\\n\\t\\twhile (i < j) {\\n            int sum = nums[i] + nums[j];\\n            //increment the count if the sum is same as k\\n\\t\\t\\t// then increment i and decrement j\\n\\t\\t\\tif (sum == k) {\\n                cnt++;\\n                i++;\\n                j--;\\n            } else if (sum < k) i++; //increment i if sum is lesser (add the minimum to reach k)\\n            else j--; //otherwise decrement j \\n        }\\n        return cnt;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int cnt = 0 , i = 0, j = nums.length - 1;\\n        // two pointer\\n\\t\\twhile (i < j) {\\n            int sum = nums[i] + nums[j];\\n            //increment the count if the sum is same as k\\n\\t\\t\\t// then increment i and decrement j\\n\\t\\t\\tif (sum == k) {\\n                cnt++;\\n                i++;\\n                j--;\\n            } else if (sum < k) i++; //increment i if sum is lesser (add the minimum to reach k)\\n            else j--; //otherwise decrement j \\n        }\\n        return cnt;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961643,
                "title": "c-two-pointer-o-1-extra-space",
                "content": "The problem statement just asks us to find the unique pairs which sum upto **k**.\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=nums.size()-1;\\n        int res=0;\\n        \\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j]==k)\\n            {\\n                res++;\\n                i++;j--;\\n            }\\n            else if(nums[i]+nums[j]>k)\\n                j--;\\n            else \\n                i++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=nums.size()-1;\\n        int res=0;\\n        \\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j]==k)\\n            {\\n                res++;\\n                i++;j--;\\n            }\\n            else if(nums[i]+nums[j]>k)\\n                j--;\\n            else \\n                i++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007144,
                "title": "day-4-daily-leetcode-challenge-problem-o-nlogn-java-c",
                "content": "* By using **Two pointer algorithm** technique on sorted array, we count the number of pairs that have sum equal to k (thats count is our answer)\\n\\n* **Time Complexity**\\nfor sort the array O(nlogn) time is require and for two pointer algorithm O(n) ,so total O(nlogn)+O(n) =**O(nlogn)** is the overall code time complexity \\n\\n* **Space complexity = O(1)**\\n\\n\\n**JAVA Code**\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n \\n        Arrays.sort(nums);\\n        int i=0 , j=nums.length-1;\\n        int count=0;\\n        \\n        while(i<j){            \\n            int sum=nums[i]+nums[j];\\n            \\n            if(sum==k){\\n                count++;\\n                i++;\\n                j--;\\n            }\\n            else if(sum>k) j--;\\n            else i++;          \\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n\\n**C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) { \\n        sort(nums.begin(), nums.end());\\n        \\n        int s=0, e=nums.size()-1 , count=0;; \\n        \\n        while(s<e){            \\n            int sum=nums[s]+nums[e];\\n            \\n            if(sum==k){\\n                count++;\\n                s++;\\n                e--;\\n            }\\n            else if(sum>k) e--;\\n            else s++;          \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n \\n        Arrays.sort(nums);\\n        int i=0 , j=nums.length-1;\\n        int count=0;\\n        \\n        while(i<j){            \\n            int sum=nums[i]+nums[j];\\n            \\n            if(sum==k){\\n                count++;\\n                i++;\\n                j--;\\n            }\\n            else if(sum>k) j--;\\n            else i++;          \\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) { \\n        sort(nums.begin(), nums.end());\\n        \\n        int s=0, e=nums.size()-1 , count=0;; \\n        \\n        while(s<e){            \\n            int sum=nums[s]+nums[e];\\n            \\n            if(sum==k){\\n                count++;\\n                s++;\\n                e--;\\n            }\\n            else if(sum>k) e--;\\n            else s++;          \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006391,
                "title": "java-sorting-two-pointers-explained-simple-solution",
                "content": "```\\n/*\\nSimple `Two pointers` appoach.\\n\\nAlgorithm:\\n------------------------------------------------------------\\n1. `Sort` the input array nums.\\n2. Have two pointers one of which pointing to the first \\n   (low) and another pointing to the last (high) element \\n   of the array.\\n3. Traverse in a while loop till low is less than high\\n4. Have a counter before the loof initiated with the value\\n   0.\\n5. Within the loop if the sum of the two pointers becomes \\n   equal to `k` then increment the value of the counter by\\n   1.\\n6. If the sum is less than k, shift the low pointer to the\\n   next element, i.e increment the value of the pointer\\n   by one.\\n7. If the sum is greater than k, shift the high pointer to\\n   it\\'s previous value in the nums, i.e decrement the value\\n   of the pointer by one.\\n8. At the end of the loop, return the value of the counter.\\n------------------------------------------------------------\\n*/\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n-1;\\n        int count = 0;\\n        while(low<high){\\n            int temp = nums[low]+nums[high];\\n            if(temp == k){\\n                low++;\\n                high--;\\n                count++;\\n            }else if(temp<k){\\n                low++;\\n            }else\\n                high--;\\n        }\\n        return count;\\n    }\\n}\\n```\\nPlease upvote if you like it. :-)",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n/*\\nSimple `Two pointers` appoach.\\n\\nAlgorithm:\\n------------------------------------------------------------\\n1. `Sort` the input array nums.\\n2. Have two pointers one of which pointing to the first \\n   (low) and another pointing to the last (high) element \\n   of the array.\\n3. Traverse in a while loop till low is less than high\\n4. Have a counter before the loof initiated with the value\\n   0.\\n5. Within the loop if the sum of the two pointers becomes \\n   equal to `k` then increment the value of the counter by\\n   1.\\n6. If the sum is less than k, shift the low pointer to the\\n   next element, i.e increment the value of the pointer\\n   by one.\\n7. If the sum is greater than k, shift the high pointer to\\n   it\\'s previous value in the nums, i.e decrement the value\\n   of the pointer by one.\\n8. At the end of the loop, return the value of the counter.\\n------------------------------------------------------------\\n*/\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n-1;\\n        int count = 0;\\n        while(low<high){\\n            int temp = nums[low]+nums[high];\\n            if(temp == k){\\n                low++;\\n                high--;\\n                count++;\\n            }else if(temp<k){\\n                low++;\\n            }else\\n                high--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005917,
                "title": "k-sum-o-n-runtime-single-pass-o-n-space",
                "content": "```\\npublic int maxOperations(int[] nums, int k) {\\n    int result = 0;\\n    Map<Integer, Integer> freq = new HashMap<>();\\n    for (int num : nums) {\\n      int target = k - num;\\n      if (freq.getOrDefault(target, 0) != 0) {\\n        ++result;\\n        freq.put(target, freq.get(target) - 1);\\n      } else {\\n        freq.put(num, freq.getOrDefault(num, 0) + 1);\\n      }\\n    }\\n    return result;\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxOperations(int[] nums, int k) {\\n    int result = 0;\\n    Map<Integer, Integer> freq = new HashMap<>();\\n    for (int num : nums) {\\n      int target = k - num;\\n      if (freq.getOrDefault(target, 0) != 0) {\\n        ++result;\\n        freq.put(target, freq.get(target) - 1);\\n      } else {\\n        freq.put(num, freq.getOrDefault(num, 0) + 1);\\n      }\\n    }\\n    return result;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023408,
                "title": "c-easiest-one-pass-o-n-solution",
                "content": "I have read most of solutions in the Discuss, but wonder why cannot we simply solve the problem in one-pass, since it simplifies the solution by not having to deal with the \"halve frequency\" when k - n = n. \\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        int res = 0;\\n        for (int n : nums) {\\n            if (map[k - n] > 0) {\\n                res++;\\n                map[k - n]--;\\n            } else {\\n                map[n]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAny input is more than welcome!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        int res = 0;\\n        for (int n : nums) {\\n            if (map[k - n] > 0) {\\n                res++;\\n                map[k - n]--;\\n            } else {\\n                map[n]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022787,
                "title": "c-easy-solution-using-map-o-n-o-n",
                "content": "There are quite a few things that you could do but I am going to follow the **2 Sum** approach of using a map.\\n\\nThere are just 3 sections to this problem:\\n1) Frequency map\\n2) k/2 case\\n3) Reamining cases\\n\\n------\\n\\n**Frequency map :** We will nee to map the frequency of all the elements(similar to 2 SUM).\\n\\n------\\n\\n**K/2 case :** if k in even then there will be a repeat in the elements.\\n> Eg : k = 6 then 3 + 3 = 6.\\n>\\n>> Say the frequency of 3 was 4 (i.e. map[3] = 4)\\n>> The ans for this will be 2 times, as we can add 3+3 twice to get 6.\\n>\\n>> Say the frequency of 3 was 5 (i.e. map[3] = 5)\\n>> The ans for this will still be 2 times, as we can add 3+3 twice to get 6.\\n>\\n> Then we delete the map[3] from the map as it will never be used.\\n\\nk is odd case does\\'nt matter as it will be covered in the **Remaining cases**.\\n\\n------\\n\\n**Reamining cases :**  This is the heart of the code and also the easiest to grasp. We just need to find the pairs {a,b} that sum up to k(i.e. a+b = k).\\n\\nSo all we need to do is find the min of the count of map[a] and map[b].\\n\\n> Eg : \\n> map[a] = 4\\n> map[b] = 3\\n> We can do a+b only 3 times after that we run out of b\\'s.\\n\\nAfter we find the min we will need to set the map[a] or map[b] to 0, so that there is no repeat(a+b = b+a).\\n\\n------\\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:    \\n    int maxOperations(vector<int>& nums, int k)\\n    {\\n        unordered_map<int, int> F;\\n        int ans=0;\\n        \\n        // filling the map with the frequency\\n        for(int i : nums) F[i]++;\\n                \\n        // handling k/2 case\\n        if(k%2==0)\\n        {\\n            ans += F[k/2]/2;\\n            F.erase(k/2);\\n        }\\n\\n        // remaining elements\\n        for(auto i : F)\\n        {\\n            int a = i.first;\\n            int b = k - a;\\n                        \\n            if(F.find(b) == F.end()) continue; // if b is not in the map then skip.\\n            \\n            if(F[a] < F[b]) ans += F[a];\\n            else ans += F[b];\\n            \\n            F[a]=0;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n*If you picked up something new from my answer then UPVOTE. Feel free to ask for any clarifications*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    int maxOperations(vector<int>& nums, int k)\\n    {\\n        unordered_map<int, int> F;\\n        int ans=0;\\n        \\n        // filling the map with the frequency\\n        for(int i : nums) F[i]++;\\n                \\n        // handling k/2 case\\n        if(k%2==0)\\n        {\\n            ans += F[k/2]/2;\\n            F.erase(k/2);\\n        }\\n\\n        // remaining elements\\n        for(auto i : F)\\n        {\\n            int a = i.first;\\n            int b = k - a;\\n                        \\n            if(F.find(b) == F.end()) continue; // if b is not in the map then skip.\\n            \\n            if(F[a] < F[b]) ans += F[a];\\n            else ans += F[b];\\n            \\n            F[a]=0;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614597,
                "title": "using-python-dictionary",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n\\n        d = {}\\n        count = 0\\n\\n        for x in nums:\\n            if d.get(k - x, 0) > 0:\\n                count+=1\\n                d[k-x]-=1\\n            else:\\n                d[x] = d.get(x, 0) + 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n\\n        d = {}\\n        count = 0\\n\\n        for x in nums:\\n            if d.get(k - x, 0) > 0:\\n                count+=1\\n                d[k-x]-=1\\n            else:\\n                d[x] = d.get(x, 0) + 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006285,
                "title": "simple-o-nlogn-two-pointer-approach",
                "content": "Very easy logic.\\n\\nStep 1 : Sort the given array.\\nStep 2 : Declare 1 pointer at the start, and 2nd pointer at the end of the sorted array.\\nStep 3 : Start iteration, if nums[i] + nums[j] == k, increment count, and move both the pointers forward. If sum < k, move the starting pointer, else if sum > k, move the ending pointer.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int i = 0;\\n        int j = nums.size() - 1;\\n        int count = 0;\\n        \\n        while(i < j) {\\n            int sum = nums[i] + nums[j];\\n            \\n            if(sum == k) {\\n                i += 1;\\n                j -= 1;\\n                count += 1;\\n            }\\n            else if(sum < k)\\n                i += 1;\\n            else\\n                j -= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int i = 0;\\n        int j = nums.size() - 1;\\n        int count = 0;\\n        \\n        while(i < j) {\\n            int sum = nums[i] + nums[j];\\n            \\n            if(sum == k) {\\n                i += 1;\\n                j -= 1;\\n                count += 1;\\n            }\\n            else if(sum < k)\\n                i += 1;\\n            else\\n                j -= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024387,
                "title": "simple-javascript-solution-o-n",
                "content": "```\\nvar maxOperations = function(nums, k) {\\nlet freq = new Map(),count=0; \\nfor (let i = 0; i < nums.length; i++) {\\n    if (freq.get(k-nums[i])) {\\n        if(freq.get(k-nums[i])==1) freq.delete(k-nums[i])\\n        else freq.set(k-nums[i],freq.get(k-nums[i])-1)\\n        count++;\\n    }else freq.set(nums[i],freq.get(nums[i])+1||1)\\n} \\nreturn count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxOperations = function(nums, k) {\\nlet freq = new Map(),count=0; \\nfor (let i = 0; i < nums.length; i++) {\\n    if (freq.get(k-nums[i])) {\\n        if(freq.get(k-nums[i])==1) freq.delete(k-nums[i])\\n        else freq.set(k-nums[i],freq.get(k-nums[i])-1)\\n        count++;\\n    }else freq.set(nums[i],freq.get(nums[i])+1||1)\\n} \\nreturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022749,
                "title": "python-2-lines-only-super-simple-clean-solution-o-n-faster-than-88",
                "content": "Thanks to @dpustovarov, I got a much shorter version of my solution:\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        c = Counter(nums)\\n        return sum(min(c[k-n], c[n]) for n in c.keys()) >> 1\\n\\n```\\nMy original solution:\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        c = Counter(nums)\\n        res = 0\\n        for n in c.keys():\\n            res += min(c[k-n], c[n])\\n                \\n        return res//2\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        c = Counter(nums)\\n        return sum(min(c[k-n], c[n]) for n in c.keys()) >> 1\\n\\n```\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        c = Counter(nums)\\n        res = 0\\n        for n in c.keys():\\n            res += min(c[k-n], c[n])\\n                \\n        return res//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961365,
                "title": "c-o-n-time-with-frequency-map",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1.\\n\\nSave the frequence of numbers in a map `m`. \\n\\nFor each pair `[n, cnt]` in `m`:\\n* If `k - n == n`, add `cnt / 2` to answer.\\n* Otherwise, add `c = min(cnt, m[k - n])` to the answer, and deduct `c` from `m[n]` and `m[k - n]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-218/problems/max-number-of-k-sum-pairs/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        for (int n : nums) m[n]++;\\n        int ans = 0;\\n        for (auto [n, cnt] : m) {\\n            if (k - n == n) ans += cnt / 2;\\n            else if (m.count(k - n))  {\\n                int c = min(cnt, m[k - n]);\\n                ans += c;\\n                m[n] -= c;\\n                m[k - n] -= c;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-218/problems/max-number-of-k-sum-pairs/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        for (int n : nums) m[n]++;\\n        int ans = 0;\\n        for (auto [n, cnt] : m) {\\n            if (k - n == n) ans += cnt / 2;\\n            else if (m.count(k - n))  {\\n                int c = min(cnt, m[k - n]);\\n                ans += c;\\n                m[n] -= c;\\n                m[k - n] -= c;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984899,
                "title": "99-cpu-92-ram-suboptimal-but-purr-fectly-playful-sort-binary-search",
                "content": "# \\uD83D\\uDC31 Cat-tastic Intuition \\uD83D\\uDC31\\nWhy chase the optimal mouse when we can have some fun with a playful, yet speedy, kitty solution? Let\\'s use some purr-fect library functions to give us a little boost!\\n\\n# \\uD83D\\uDC3E Feline Approach \\uD83D\\uDC3E\\nSure, sorting is like the classic cat nap \\u2013 everyone does it. But why not add a twist with a game of binary search? It\\'s like the laser pointer game for our sorted array, helping us pounce over numbers that just won\\'t play nice.\\n\\n# \\uD83D\\uDC08 Complexity Whiskers \\uD83D\\uDC08\\n- **Time complexity:** $$O(n)log(n)$$ \\u2013 Technically, it\\'s a tad slower than the optimal $$O(n)$$ (which is like a cat sprinting after a toy). But hey, our library functions are like catnip, making everything more fun and fast!\\n  \\n- **Space complexity:** $$O(1)$$ \\u2013 Meow-tastic! Python lets us sort in place, just like how cats always find the purr-fect spot to curl up.\\n\\n# \\uD83D\\uDC31\\u200D\\uD83D\\uDCBB Code Time! \\uD83D\\uDC31\\u200D\\uD83D\\uDCBB\\n```\\nfrom bisect import bisect_left, bisect_right\\n\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums.sort()  # Time to line up our yarn balls!\\n        operations = 0  # Here\\'s where we\\'ll count our playful pounces.\\n\\n        # Two paws are better than one! Let\\'s use two pointers.\\n        left, right = 0, len(nums) - 1\\n        \\n        while left < right:\\n            total = nums[left] + nums[right]\\n            \\n            if total == k:  # Did we catch the yarn ball?\\n                operations += 1\\n                left += 1\\n                right -= 1\\n            elif total < k:\\n                # Pounce to the leftmost yarn ball that\\'s k - nums[right] or bigger.\\n                left = bisect.bisect_left(nums, k - nums[right], lo=left + 1, hi=right)\\n            else:  # total > k\\n                # Hop to the rightmost yarn ball that\\'s k - nums[left] or smaller.\\n                right = bisect.bisect_right(nums, k - nums[left], lo=left, hi=right) - 1\\n                # Remember, bisect_right is a sneaky kitty:\\n                # If there\\'s a yarn ball with the same value, \\n                # it\\'ll try to jump just past it.\\n        \\n        return operations\\n```\\n\\n# \\uD83D\\uDC3E Paws & Reflect \\uD83D\\uDC3E\\nIf my kitty solution made you purr, please give it an upvote! And remember, it\\'s not always about catching the mouse \\u2013 sometimes, it\\'s about the chase! \\uD83D\\uDC31\\uD83E\\uDDF6\\uD83D\\uDC3E",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\n\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums.sort()  # Time to line up our yarn balls!\\n        operations = 0  # Here\\'s where we\\'ll count our playful pounces.\\n\\n        # Two paws are better than one! Let\\'s use two pointers.\\n        left, right = 0, len(nums) - 1\\n        \\n        while left < right:\\n            total = nums[left] + nums[right]\\n            \\n            if total == k:  # Did we catch the yarn ball?\\n                operations += 1\\n                left += 1\\n                right -= 1\\n            elif total < k:\\n                # Pounce to the leftmost yarn ball that\\'s k - nums[right] or bigger.\\n                left = bisect.bisect_left(nums, k - nums[right], lo=left + 1, hi=right)\\n            else:  # total > k\\n                # Hop to the rightmost yarn ball that\\'s k - nums[left] or smaller.\\n                right = bisect.bisect_right(nums, k - nums[left], lo=left, hi=right) - 1\\n                # Remember, bisect_right is a sneaky kitty:\\n                # If there\\'s a yarn ball with the same value, \\n                # it\\'ll try to jump just past it.\\n        \\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825349,
                "title": "beats-100-c-two-pointers-approach-o-nlogn",
                "content": "# Approach\\nTwo pointers\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        // using two poiners approach;\\n        int i=0;\\n        int j=nums.size()-1;\\n        int count=0;\\n        while(j>i)\\n        {\\n            if(nums[i]+nums[j]==k)\\n            {\\n                i++;\\n                j--;\\n                count++;\\n            }\\n            else if(nums[i]+nums[j]<k)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        // using two poiners approach;\\n        int i=0;\\n        int j=nums.size()-1;\\n        int count=0;\\n        while(j>i)\\n        {\\n            if(nums[i]+nums[j]==k)\\n            {\\n                i++;\\n                j--;\\n                count++;\\n            }\\n            else if(nums[i]+nums[j]<k)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759936,
                "title": "java-solution-two-pointer-o-nlogn",
                "content": "<!-- # Intuition -->\\n \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the array and use two pointers technique. \\nWe count the number of pairs that have sum equal to k \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n  O(nlogn) for sorting and O(n)for while loop\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        int j = nums.length-1;\\n        int cnt=0;\\n        while(i<j){\\n            if(nums[i]+nums[j]==k){\\n                cnt++; i++; j--;\\n            }\\n            else if(nums[i]+nums[j] < k){\\n                i++;\\n            }\\n            else j--;\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n![upvote cat.png](https://assets.leetcode.com/users/images/a252a21f-391e-4bc3-a436-c8b16972afa2_1689261828.300584.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        int j = nums.length-1;\\n        int cnt=0;\\n        while(i<j){\\n            if(nums[i]+nums[j]==k){\\n                cnt++; i++; j--;\\n            }\\n            else if(nums[i]+nums[j] < k){\\n                i++;\\n            }\\n            else j--;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241406,
                "title": "python3-very-easy-solution",
                "content": "# Intuition\\n![download.jpg](https://assets.leetcode.com/users/images/3d035459-2ddb-4ee7-af2f-5bb5b27a5694_1687607442.4351149.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(N log N)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        if not nums:\\n            return\\n        start , end , result= 0 , len(nums)-1 , 0\\n        while(start < end):\\n            sum = nums[start] + nums[end]\\n            if k > sum:\\n                start+=1\\n            elif k < sum:\\n                end-=1\\n            else:\\n                start+=1 ; end-=1 ; result+=1\\n        return result\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        if not nums:\\n            return\\n        start , end , result= 0 , len(nums)-1 , 0\\n        while(start < end):\\n            sum = nums[start] + nums[end]\\n            if k > sum:\\n                start+=1\\n            elif k < sum:\\n                end-=1\\n            else:\\n                start+=1 ; end-=1 ; result+=1\\n        return result\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007335,
                "title": "c-map-and-2-pointer-approach",
                "content": "**1st approach:** 2 pointer approach\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int start = 0, end = nums.size()-1;\\n        \\n        int count = 0;\\n        while(start < end){\\n            int sum = nums[start] + nums[end];\\n            if(sum == k){\\n                count++;\\n                start++;    end--;\\n            }\\n                \\n            else if(sum < k)\\n                start++;\\n            else\\n                end--;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**2nd approach:** Map approach in which we will check for an element x whether k-x exist or not.\\n\\n```\\nclass Solution {\\npublic: // Time/Space: O(n); O(n)\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        int ans = 0;\\n        for(auto cur: nums){\\n            int complement = k - cur;\\n            if(freq[complement] > 0){ans++; freq[complement]--;}\\n            else freq[cur]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int start = 0, end = nums.size()-1;\\n        \\n        int count = 0;\\n        while(start < end){\\n            int sum = nums[start] + nums[end];\\n            if(sum == k){\\n                count++;\\n                start++;    end--;\\n            }\\n                \\n            else if(sum < k)\\n                start++;\\n            else\\n                end--;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: // Time/Space: O(n); O(n)\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        int ans = 0;\\n        for(auto cur: nums){\\n            int complement = k - cur;\\n            if(freq[complement] > 0){ans++; freq[complement]--;}\\n            else freq[cur]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006330,
                "title": "c-2-approaches-sorting-and-hashmap",
                "content": "**Approach 1 (Sorting and Two-Pointer)**\\n\\n```\\n    int maxOperations(vector<int>& nums, int k) {\\n        // sort the array\\n        sort(nums.begin(), nums.end());\\n        \\n        // Take two pointers and initialize ans variable with 0\\n        int i=0, j=nums.size()-1, ans = 0;\\n        \\n        // stopping condition\\n        while(i < j)\\n        {\\n            int sum = nums[i]+nums[j];\\n            \\n            // if we got the sum, simply increase the count\\n            if(sum == k)\\n            {\\n                ans++;\\n                i++;\\n                j--;\\n            }\\n            // if the sum is greater than k, decrease the end pointer\\n            else if(sum > k)\\n                j--;\\n            // if the sum is less than k, increase the start pointer\\n            else\\n                i++;\\n            \\n        }\\n        \\n        // returning the ans\\n        return ans;\\n    }\\n```\\n\\n**Time - O(NlogN)\\nSpace - O(1)**\\n\\n\\n**Approach 2 (HashMap) [Single Pass]**\\n\\n```\\n\\tint maxOperations(vector<int>& nums, int k) {\\n        // create a hashmap (i.e. unordered_map) to store frequency of each elements\\n        unordered_map<int, int> m;        \\n        // initializing ans variable with 0\\n        int ans = 0;\\n        \\n        // we could use for_each loop as well\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            // complement element\\n            int ele = k-nums[i];\\n            // checking if the element is present\\n            if(m[ele] > 0)\\n            {\\n                ans++; // increasing the ans\\n                m[ele]--; // decreasing the freq. as the question suggest to remove the element\\n            }\\n            else\\n            {\\n                m[nums[i]]++; // if not present then store the element with increased freq.\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**Time - O(N)\\nSpace - O(N)**\\n\\n***NB: Kindly upvote the solution if I could help a little and comment your doubts, will be happy to help***",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    int maxOperations(vector<int>& nums, int k) {\\n        // sort the array\\n        sort(nums.begin(), nums.end());\\n        \\n        // Take two pointers and initialize ans variable with 0\\n        int i=0, j=nums.size()-1, ans = 0;\\n        \\n        // stopping condition\\n        while(i < j)\\n        {\\n            int sum = nums[i]+nums[j];\\n            \\n            // if we got the sum, simply increase the count\\n            if(sum == k)\\n            {\\n                ans++;\\n                i++;\\n                j--;\\n            }\\n            // if the sum is greater than k, decrease the end pointer\\n            else if(sum > k)\\n                j--;\\n            // if the sum is less than k, increase the start pointer\\n            else\\n                i++;\\n            \\n        }\\n        \\n        // returning the ans\\n        return ans;\\n    }\\n```\n```\\n\\tint maxOperations(vector<int>& nums, int k) {\\n        // create a hashmap (i.e. unordered_map) to store frequency of each elements\\n        unordered_map<int, int> m;        \\n        // initializing ans variable with 0\\n        int ans = 0;\\n        \\n        // we could use for_each loop as well\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            // complement element\\n            int ele = k-nums[i];\\n            // checking if the element is present\\n            if(m[ele] > 0)\\n            {\\n                ans++; // increasing the ans\\n                m[ele]--; // decreasing the freq. as the question suggest to remove the element\\n            }\\n            else\\n            {\\n                m[nums[i]]++; // if not present then store the element with increased freq.\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006166,
                "title": "c-easy-to-understand-solution-intuitive-two-pointers-maps",
                "content": "**Please Upvote if you like it :)**\\n\\n**Approach: Two Pointer & Sorting**\\n\\n***Time: O(Nlogn)\\nSpace: O(1)***\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int s = 0, e = nums.size() - 1, cnt = 0;\\n        while(s < e){\\n            if(nums[s] + nums[e] == k) {\\n                cnt++;\\n                s++;\\n                e--;\\n            }\\n            else if(nums[s] + nums[e] > k) e--;\\n            else s++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Approach 2: Using Map**\\n\\n***Time: O(N)\\nSpace: O(N)***\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k){\\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n        for(auto i: nums){\\n            int val = k - i; \\n            if(mp.find(val) != mp.end()){\\n                if(mp[val] == 1) mp.erase(val);\\n                else mp[val]--;  \\n                cnt++;\\n            }\\n            else mp[i]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int s = 0, e = nums.size() - 1, cnt = 0;\\n        while(s < e){\\n            if(nums[s] + nums[e] == k) {\\n                cnt++;\\n                s++;\\n                e--;\\n            }\\n            else if(nums[s] + nums[e] > k) e--;\\n            else s++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k){\\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n        for(auto i: nums){\\n            int val = k - i; \\n            if(mp.find(val) != mp.end()){\\n                if(mp[val] == 1) mp.erase(val);\\n                else mp[val]--;  \\n                cnt++;\\n            }\\n            else mp[i]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006150,
                "title": "go-best-running-time-solution-100-faster-time-101ms-100-less-mem-usage",
                "content": "# Using Hashmap\\nThe [TwoSum](https://leetcode.com/problems/two-sum/://) Leetcode problem provides a clear base for understanding and solving this problem.\\n\\nCode:\\n\\n```\\nfunc maxOperations(nums []int, k int) int {\\n    \\n    n, ans := len(nums), 0\\n    \\n    //base case\\n    if n <= 1 {\\n        return ans\\n    }\\n    \\n    //hashmap will store values in the form\\n    //num : count\\n    hashmap := make(map[int]int)\\n    \\n    for i := 0; i < n; i++ {\\n        \\n        //skip the values greater or equal to k\\n        if nums[i] >= k {\\n            continue\\n        }\\n\\t\\t\\n        //check if counterpart of nums[i] is present\\n        counterpart := k - nums[i]\\n        \\n        if val, exists := hashmap[counterpart]; exists {\\n            if val != 0 {\\n                ans++\\n            }\\n            \\n            //taking care of duplicates\\n\\t\\t\\t//example. [1,1,1,2]\\n            if val - 1 == 0 {\\n                delete(hashmap,counterpart)\\n            } else {\\n                hashmap[counterpart]--\\n            }\\n            \\n        } else {\\n            hashmap[nums[i]]++\\n        }\\n        \\n    }\\n    \\n    return ans\\n    \\n    \\n}\\n```\\n**Time Complexity**: **O(n)**\\n**Space Complexity**: **O(n)**\\n\\n**Leetcode Result Analysis** for this solution:\\n**Runtime**: **101 ms**, **faster than 100.00%** of Go online submissions for Max Number of K-Sum Pairs.\\n**Memory Usage**: **8.4 MB**, **less than 100.00%** of Go online submissions for Max Number of K-Sum Pairs.\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxOperations(nums []int, k int) int {\\n    \\n    n, ans := len(nums), 0\\n    \\n    //base case\\n    if n <= 1 {\\n        return ans\\n    }\\n    \\n    //hashmap will store values in the form\\n    //num : count\\n    hashmap := make(map[int]int)\\n    \\n    for i := 0; i < n; i++ {\\n        \\n        //skip the values greater or equal to k\\n        if nums[i] >= k {\\n            continue\\n        }\\n\\t\\t\\n        //check if counterpart of nums[i] is present\\n        counterpart := k - nums[i]\\n        \\n        if val, exists := hashmap[counterpart]; exists {\\n            if val != 0 {\\n                ans++\\n            }\\n            \\n            //taking care of duplicates\\n\\t\\t\\t//example. [1,1,1,2]\\n            if val - 1 == 0 {\\n                delete(hashmap,counterpart)\\n            } else {\\n                hashmap[counterpart]--\\n            }\\n            \\n        } else {\\n            hashmap[nums[i]]++\\n        }\\n        \\n    }\\n    \\n    return ans\\n    \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1882494,
                "title": "python3-solution-using-two-pointer-approach-hashmap",
                "content": "Using Two pointer approach\\n**O(NlogN): time, O(1): space**\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums = sorted(nums)\\n        start,end = 0, len(nums)-1\\n        result = 0\\n        while start<end:\\n            sums = nums[start]+nums[end]\\n            if (sums == k):\\n                result+=1\\n                start+=1\\n                end-=1\\n            elif(sums<k):\\n                start+=1\\n            else:\\n                end-=1\\n        return result\\n```\\n\\n**O(N): time, O(N): space**\\nUsing hashMap\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        freq = {}\\n        for i in nums:\\n            try:\\n                freq[i]+=1\\n            except:\\n                freq[i]=1\\n        result = 0\\n        for i in nums:\\n            isFirstAddendPresent = freq.get(i)\\n            if(isFirstAddendPresent!=None and isFirstAddendPresent > 0):\\n                freq[i]-=1\\n                isSecondAddendPresent = freq.get(k-i)\\n                if(isSecondAddendPresent!=None and isSecondAddendPresent > 0):\\n                    result+=1\\n                    freq[k-i]-=1\\n                else:\\n                    freq[i]+=1\\n        return result\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums = sorted(nums)\\n        start,end = 0, len(nums)-1\\n        result = 0\\n        while start<end:\\n            sums = nums[start]+nums[end]\\n            if (sums == k):\\n                result+=1\\n                start+=1\\n                end-=1\\n            elif(sums<k):\\n                start+=1\\n            else:\\n                end-=1\\n        return result\\n```\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        freq = {}\\n        for i in nums:\\n            try:\\n                freq[i]+=1\\n            except:\\n                freq[i]=1\\n        result = 0\\n        for i in nums:\\n            isFirstAddendPresent = freq.get(i)\\n            if(isFirstAddendPresent!=None and isFirstAddendPresent > 0):\\n                freq[i]-=1\\n                isSecondAddendPresent = freq.get(k-i)\\n                if(isSecondAddendPresent!=None and isSecondAddendPresent > 0):\\n                    result+=1\\n                    freq[k-i]-=1\\n                else:\\n                    freq[i]+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240356,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap(); // HashMap for keeping a track of the occurence of the elements in the array\\n        int count=0; // for the final answer\\n        for(int i=0;i<nums.length;i++){ // loop through each element of the array\\n            int an=k-nums[i]; // given condition in the question\\n            if(map.containsKey(an)){ // if there is a number to satisfy the condition\\n                count++; // update the answer\\n                if(map.get(an)==1) // if there is only 1 ouccerence of the element \\n                    map.remove(an); // remove it from the map\\n                else \\n                    map.put(an,map.get(an)-1); // or decrease its value\\n            }\\n            else\\n                 map.put(nums[i],map.getOrDefault(nums[i],0)+1);}  // if element not present then add it in map\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap(); // HashMap for keeping a track of the occurence of the elements in the array\\n        int count=0; // for the final answer\\n        for(int i=0;i<nums.length;i++){ // loop through each element of the array\\n            int an=k-nums[i]; // given condition in the question\\n            if(map.containsKey(an)){ // if there is a number to satisfy the condition\\n                count++; // update the answer\\n                if(map.get(an)==1) // if there is only 1 ouccerence of the element \\n                    map.remove(an); // remove it from the map\\n                else \\n                    map.put(an,map.get(an)-1); // or decrease its value\\n            }\\n            else\\n                 map.put(nums[i],map.getOrDefault(nums[i],0)+1);}  // if element not present then add it in map\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065144,
                "title": "c-faster-than-97-09-easy-understanding-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxOperations(vector<int>& nums, int k) {\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint start = 0, end = nums.size() - 1;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile ( start < end )\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[start] + nums[end] == k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t\\t--end;\\n\\t\\t\\t\\t\\t++start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse if (nums[start] + nums[end] < k)\\n\\t\\t\\t\\t\\t++start;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t--end;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxOperations(vector<int>& nums, int k) {\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint start = 0, end = nums.size() - 1;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile ( start < end )\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[start] + nums[end] == k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t\\t--end;\\n\\t\\t\\t\\t\\t++start;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3666971,
                "title": "java-code-with-o-nlogn-time-complexity-and-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed two pointer approach to first sort so that one can modify pointers in order to get sum as k.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int i=0;\\n        int j = nums.length-1;\\n        int count=0;\\n\\n        Arrays.sort(nums);\\n        while(i<j){\\n            if(nums[i]+nums[j]==k) {\\n                count++;\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]>k){\\n                    j--;\\n            }\\n            else if(nums[i]+nums[j]<k){\\n                    i++;\\n            }\\n        }\\n        return count;      \\n    }\\n}\\n//1,3,3,3,4\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int i=0;\\n        int j = nums.length-1;\\n        int count=0;\\n\\n        Arrays.sort(nums);\\n        while(i<j){\\n            if(nums[i]+nums[j]==k) {\\n                count++;\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]>k){\\n                    j--;\\n            }\\n            else if(nums[i]+nums[j]<k){\\n                    i++;\\n            }\\n        }\\n        return count;      \\n    }\\n}\\n//1,3,3,3,4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555023,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        counter = defaultdict(int)\\n        co = 0\\n        for x in nums:\\n            comp = k - x\\n            if counter[comp]>0:\\n                counter[comp]-=1\\n                co+=1\\n            else:\\n                counter[x] +=1\\n        return co\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        counter = defaultdict(int)\\n        co = 0\\n        for x in nums:\\n            comp = k - x\\n            if counter[comp]>0:\\n                counter[comp]-=1\\n                co+=1\\n            else:\\n                counter[x] +=1\\n        return co\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545683,
                "title": "golang-sort-vs-dictionary",
                "content": "# Complexity\\n- Time complexity:\\nSolution1 -> O(NlogN)\\nSolution2 -> O(N)\\n\\n- Space complexity:\\nSolution1 -> O(1)\\nSolution2 -> O(N)\\n\\n# Code\\n```\\n\\n/* Solution1 */\\nfunc maxOperations(nums []int, k int) int {\\n    sort.Ints(nums)\\n    left, right := 0, len(nums)-1\\n\\n    count := 0\\n    for left < right {\\n        sum := nums[left] + nums[right]\\n        if sum == k {\\n            count++\\n            left++\\n            right--\\n        } else if sum < k {\\n            left++\\n        } else {\\n            right--\\n        }\\n    }\\n\\n    return count\\n}\\n\\n/* Solution2 */\\nfunc maxOperations(nums []int, k int) int {\\n    dict := make(map[int]int)\\n\\n    count := 0\\n    for _, num := range nums {\\n        target := k - num\\n        if value, ok := dict[target]; ok {\\n            count++\\n            if value > 1 {\\n                dict[target]--\\n            } else {\\n                delete(dict, target)\\n            }\\n        } else {\\n            dict[num]++\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\n/* Solution1 */\\nfunc maxOperations(nums []int, k int) int {\\n    sort.Ints(nums)\\n    left, right := 0, len(nums)-1\\n\\n    count := 0\\n    for left < right {\\n        sum := nums[left] + nums[right]\\n        if sum == k {\\n            count++\\n            left++\\n            right--\\n        } else if sum < k {\\n            left++\\n        } else {\\n            right--\\n        }\\n    }\\n\\n    return count\\n}\\n\\n/* Solution2 */\\nfunc maxOperations(nums []int, k int) int {\\n    dict := make(map[int]int)\\n\\n    count := 0\\n    for _, num := range nums {\\n        target := k - num\\n        if value, ok := dict[target]; ok {\\n            count++\\n            if value > 1 {\\n                dict[target]--\\n            } else {\\n                delete(dict, target)\\n            }\\n        } else {\\n            dict[num]++\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3170873,
                "title": "sort-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0, j = nums.size()-1, ans = 0;\\n        while(i<j){\\n            if(nums[i]+nums[j]==k){\\n                ans++;\\n                i++;\\n                j--;\\n            }else if(nums[i]+nums[j]>k){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0, j = nums.size()-1, ans = 0;\\n        while(i<j){\\n            if(nums[i]+nums[j]==k){\\n                ans++;\\n                i++;\\n                j--;\\n            }else if(nums[i]+nums[j]>k){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007172,
                "title": "c-easy-o-nlogn-solution-2-approaches-2-pointer-hashmap",
                "content": "**Approach-1 : Use 2-pointers approach**\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(), nums.end());\\n        int start=0, end=nums.size()-1, count=0;\\n        \\n\\t\\t//iterate till both the pointers cross each other\\n        while(start<end)\\n        {\\n\\t\\t\\t//if pointers\\' value sum equal to the k increase the count operation and move both the pointers\\n            if(nums[start]+nums[end] == k)\\n            {\\n                count++;\\n                start++;\\n                end--;\\n            }\\n            \\n\\t\\t\\t//if sum is smaller then increment the start pointer\\n            else if(nums[start]+nums[end] < k)\\n                start++;\\n            \\n\\t\\t\\t//if sum is greater then decrement the end pointer\\n            else\\n                end--;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n**Approach-2 : Use hashmap**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        unordered_map<int, int> mp;\\n        int count=0;\\n        \\n        for(auto it:nums)\\n        {\\n\\t\\t\\n            int y=k-it;\\n            if(mp.find(y) != mp.end() && mp[y] > 0) //find k-it in map if it exists we increase the count\\n            {\\n                count++;\\n\\t\\t\\t\\t//decrease the frequency of y and it\\n                mp[y]--; \\n                mp[it]--;\\n            }\\n            mp[it]++; //store the frequency of it\\n            \\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(), nums.end());\\n        int start=0, end=nums.size()-1, count=0;\\n        \\n\\t\\t//iterate till both the pointers cross each other\\n        while(start<end)\\n        {\\n\\t\\t\\t//if pointers\\' value sum equal to the k increase the count operation and move both the pointers\\n            if(nums[start]+nums[end] == k)\\n            {\\n                count++;\\n                start++;\\n                end--;\\n            }\\n            \\n\\t\\t\\t//if sum is smaller then increment the start pointer\\n            else if(nums[start]+nums[end] < k)\\n                start++;\\n            \\n\\t\\t\\t//if sum is greater then decrement the end pointer\\n            else\\n                end--;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        unordered_map<int, int> mp;\\n        int count=0;\\n        \\n        for(auto it:nums)\\n        {\\n\\t\\t\\n            int y=k-it;\\n            if(mp.find(y) != mp.end() && mp[y] > 0) //find k-it in map if it exists we increase the count\\n            {\\n                count++;\\n\\t\\t\\t\\t//decrease the frequency of y and it\\n                mp[y]--; \\n                mp[it]--;\\n            }\\n            mp[it]++; //store the frequency of it\\n            \\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007102,
                "title": "c-2-approaches-easy-short-o-n-log-n-optimal-solution",
                "content": "**Approach 1 : Using 2 Pointer Approach** \\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        // we are going to solve this problem by using 2 pointer Approach\\n        // so firstly sort the given vector \\n        sort(nums.begin(),nums.end());\\n        \\n        // made 2 pointer , one for starting idx and other for ending index\\n        int st = 0;\\n        int en = nums.size()-1;\\n        \\n        // it will count the number of pairs \\n        int cnt = 0;\\n        \\n        while(st<en)\\n        {\\n            // if we got our pair then increase cnt by 1 and move both pointers\\n            // because we can not take any one of them again\\n            if(nums[st]+nums[en] == k)\\n            {\\n                st++;\\n                en--;\\n                cnt++;\\n            }\\n            \\n            // if our pair sum is less than we will increase it by st++\\n            else if(nums[st]+nums[en] < k)\\n            {\\n                st++;\\n            }\\n            \\n            // if our pair sum is big than we will decrease it by en--\\n            else\\n            {\\n                en--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Approach 2 : Using Map**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        // declare the map for storing the frequency\\n        map<int,int> mp;\\n        int cnt =0 ;                                // it will store the count value of pairs\\n        \\n        // iterate over the whole vector\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // search our remind value in map if it is present then fo for increment\\n            int x = k - nums[i];\\n            if(mp.find(x) != mp.end() && mp[x]>0)\\n            {\\n                cnt++;\\n                \\n                // after counting the current pair decrease the both value frequency by one\\n                mp[x]--;\\n                mp[nums[i]]--;\\n            }\\n            \\n            // after each iteration increase the count of current value\\n            mp[nums[i]]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        // we are going to solve this problem by using 2 pointer Approach\\n        // so firstly sort the given vector \\n        sort(nums.begin(),nums.end());\\n        \\n        // made 2 pointer , one for starting idx and other for ending index\\n        int st = 0;\\n        int en = nums.size()-1;\\n        \\n        // it will count the number of pairs \\n        int cnt = 0;\\n        \\n        while(st<en)\\n        {\\n            // if we got our pair then increase cnt by 1 and move both pointers\\n            // because we can not take any one of them again\\n            if(nums[st]+nums[en] == k)\\n            {\\n                st++;\\n                en--;\\n                cnt++;\\n            }\\n            \\n            // if our pair sum is less than we will increase it by st++\\n            else if(nums[st]+nums[en] < k)\\n            {\\n                st++;\\n            }\\n            \\n            // if our pair sum is big than we will decrease it by en--\\n            else\\n            {\\n                en--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        // declare the map for storing the frequency\\n        map<int,int> mp;\\n        int cnt =0 ;                                // it will store the count value of pairs\\n        \\n        // iterate over the whole vector\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // search our remind value in map if it is present then fo for increment\\n            int x = k - nums[i];\\n            if(mp.find(x) != mp.end() && mp[x]>0)\\n            {\\n                cnt++;\\n                \\n                // after counting the current pair decrease the both value frequency by one\\n                mp[x]--;\\n                mp[nums[i]]--;\\n            }\\n            \\n            // after each iteration increase the count of current value\\n            mp[nums[i]]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006800,
                "title": "pair-sum-to-k-hashmap-easy-understanding",
                "content": "Hi,\\n\\nI am sharing my thought process for this problem, since it is sum of pairs there are multiple ways to solve this problem.\\n\\nBut the problem is when we go with linear approach of finding each pair and checking whether it is k then it will be n*n times.\\n\\nGiven the constraints as 10^5 we should try to solve in less then n*n times, so the best option that I could think of is HashMap.\\n\\nSince HashMap can retrive the record in O(1), following are the steps in a hashmap:\\n1. First itrate throught all the elements in the given array,\\n2. Find the difference of that element and k\\n3. If differenece is available in the hashmap then it is evident that it is a valid pair,\\n4. Now increase the count of the result and decrease the difference element by one and add back to the hashmap\\n5. Repeat the process for the entire given array\\n\\nIts time to look into the code.\\n\\nDo upvote if its helpful, happy learning..\\n\\n```\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        int res=0;\\n        for(int i:nums){\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tif (map.containsKey(k - i)) {\\n\\t\\t\\t\\tcount = map.get(k - i);\\n\\t\\t\\t\\tif (count > 0) {\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\tmap.put(k - i, --count);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tmap.put(i, map.getOrDefault(i,0)+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.put(i, map.getOrDefault(i,0)+1);\\n\\t\\t\\t}\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nI am sharing my thought process for this problem, since it is sum of pairs there are multiple ways to solve this problem.\\n\\nBut the problem is when we go with linear approach of finding each pair and checking whether it is k then it will be n*n times.\\n\\nGiven the constraints as 10^5 we should try to solve in less then n*n times, so the best option that I could think of is HashMap.\\n\\nSince HashMap can retrive the record in O(1), following are the steps in a hashmap:\\n1. First itrate throught all the elements in the given array,\\n2. Find the difference of that element and k\\n3. If differenece is available in the hashmap then it is evident that it is a valid pair,\\n4. Now increase the count of the result and decrease the difference element by one and add back to the hashmap\\n5. Repeat the process for the entire given array\\n\\nIts time to look into the code.\\n\\nDo upvote if its helpful, happy learning..\\n\\n```\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        int res=0;\\n        for(int i:nums){\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tif (map.containsKey(k - i)) {\\n\\t\\t\\t\\tcount = map.get(k - i);\\n\\t\\t\\t\\tif (count > 0) {\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\tmap.put(k - i, --count);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tmap.put(i, map.getOrDefault(i,0)+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.put(i, map.getOrDefault(i,0)+1);\\n\\t\\t\\t}\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2006666,
                "title": "video-editorial-simple-and-intuitive-c-o-n-time",
                "content": "https://www.youtube.com/watch?v=KBxbgSIeMts\\n```\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int,int>counter;\\n        for(int el:nums)\\n            counter[el]++;\\n        int ans=0;\\n        for(auto x:counter)\\n        {\\n            //x.first actual element\\n            //x.second count\\n            \\n            if(counter.find(k-x.first)!=counter.end())\\n                ans+=min(x.second,counter[k-x.first]);\\n            \\n        }\\n        \\n        // as (a,b) and (b,a) type of pairs are the same\\n        return ans/2;\\n        \\n        //time complexity with unordered_map\\n        //O(n)-> avg case\\n        //O(n^2)->worst case\\n        \\n        //time complexity with map\\n        //O(nlogn)\\n        \\n        //space complexity\\n        //O(n)\\n    }\\n```\\n\\nPlease upvote if you found this helpful :)",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int,int>counter;\\n        for(int el:nums)\\n            counter[el]++;\\n        int ans=0;\\n        for(auto x:counter)\\n        {\\n            //x.first actual element\\n            //x.second count\\n            \\n            if(counter.find(k-x.first)!=counter.end())\\n                ans+=min(x.second,counter[k-x.first]);\\n            \\n        }\\n        \\n        // as (a,b) and (b,a) type of pairs are the same\\n        return ans/2;\\n        \\n        //time complexity with unordered_map\\n        //O(n)-> avg case\\n        //O(n^2)->worst case\\n        \\n        //time complexity with map\\n        //O(nlogn)\\n        \\n        //space complexity\\n        //O(n)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006517,
                "title": "c-from-brute-force-to-optimized-solution-with-comments",
                "content": "Brute Force : \\nTC: O(n*n) \\nSC: O(n)\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int arr_size=nums.size();\\n        vector<bool> visited_idx(arr_size,false);\\n        int cnt=0;\\n        for(int i=0;i<arr_size-1;i++){        //check if values are visited or not \\n            for(int j=i+1;j<arr_size;j++){\\n                if( visited_idx[i]==false and visited_idx[j]==false and nums[i]+nums[j]==k){\\n                    cnt++;\\n                    visited_idx[j]=true;         //mark as visited means both values are deleted\\n                    visited_idx[i]=true;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nOptimed with sorting (2 Pointer):\\nTC: O(nlogn) \\nSC: O(n)\\n\\ncode:\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int arr_size=nums.size();\\n        vector<bool> visited_idx(arr_size,false);\\n        sort(nums.begin(),nums.end());    //sort nums array\\n        int str=0,end=arr_size-1,cnt=0;\\n        while(str<end){              //2 Pointer approach \\n            if(visited_idx[str]==false && visited_idx[end]==false && nums[str]+nums[end]==k){\\n                cnt++;                                      //check if both values not visited and equal  \\n                visited_idx[str]==true;             //to k then increament cnt\\n                visited_idx[end]==true;\\n                str++;\\n                end--;\\n            }\\n            else if(nums[str]+nums[end]>k)\\n                end--;\\n            else\\n                str++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nTC : O(n)\\nSC : O(n)\\n\\ncode:\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int cnt= 0;\\n        for (int b : nums) {\\n            int a = k - b; // a + b = k  =>  a = k - b\\n            if (mp[a] > 0) {\\n                cnt+= 1;\\n                mp[a] -= 1;       //decrement map value means to delete those value\\n            } else {\\n                mp[b] += 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int arr_size=nums.size();\\n        vector<bool> visited_idx(arr_size,false);\\n        int cnt=0;\\n        for(int i=0;i<arr_size-1;i++){        //check if values are visited or not \\n            for(int j=i+1;j<arr_size;j++){\\n                if( visited_idx[i]==false and visited_idx[j]==false and nums[i]+nums[j]==k){\\n                    cnt++;\\n                    visited_idx[j]=true;         //mark as visited means both values are deleted\\n                    visited_idx[i]=true;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int arr_size=nums.size();\\n        vector<bool> visited_idx(arr_size,false);\\n        sort(nums.begin(),nums.end());    //sort nums array\\n        int str=0,end=arr_size-1,cnt=0;\\n        while(str<end){              //2 Pointer approach \\n            if(visited_idx[str]==false && visited_idx[end]==false && nums[str]+nums[end]==k){\\n                cnt++;                                      //check if both values not visited and equal  \\n                visited_idx[str]==true;             //to k then increament cnt\\n                visited_idx[end]==true;\\n                str++;\\n                end--;\\n            }\\n            else if(nums[str]+nums[end]>k)\\n                end--;\\n            else\\n                str++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int cnt= 0;\\n        for (int b : nums) {\\n            int a = k - b; // a + b = k  =>  a = k - b\\n            if (mp[a] > 0) {\\n                cnt+= 1;\\n                mp[a] -= 1;       //decrement map value means to delete those value\\n            } else {\\n                mp[b] += 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006089,
                "title": "java-o-nlogn-approach",
                "content": "**Two Pointer Apporach using sorting**\\n\\nStart from the begning of a sorted array and have one pointer at 0th index and other at the last \\nNow we gonna get the sum, where\\n\\n**sum = nums[i]+nums[j]**\\n\\n* if sum == k :- Increment our count & move our i & j pointer\\n\\n* if sum > k, Move our j pointer\\n\\n* if sum < k, Move our i pointer\\n\\n\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int counter =0;\\n        int i = 0;\\n        int j = nums.length-1;\\n       while(i<j){\\n            if(nums[i]+nums[j] == k){\\n                counter++;\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]>k){\\n                    j--;\\n            }\\n            else\\n                i++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```\\nif you liked the approach please upvote .\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int counter =0;\\n        int i = 0;\\n        int j = nums.length-1;\\n       while(i<j){\\n            if(nums[i]+nums[j] == k){\\n                counter++;\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]>k){\\n                    j--;\\n            }\\n            else\\n                i++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005959,
                "title": "dry-run-two-pointer-easy-2-solution-o-nlog-n-o-n",
                "content": "**Time complexity: O(n log(n))\\nSpace complexity: O(1)**\\n\\n![image](https://assets.leetcode.com/users/images/33bcef80-a3b8-4520-9867-aaa10a37125a_1651629120.1355383.jpeg)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int s=0,c=0;\\n        int e=n-1;\\n        while(s<e)\\n        {\\n            int sum=nums[s]+nums[e];\\n            if(sum==k)\\n            {\\n                c++;\\n                s++;\\n                e--;\\n            }\\n            else if(sum>k)e--;\\n            else s++;\\n            \\n        }\\n        return c;\\n    }\\n};\\n \\n\\n\\nsolution 2\\n\\n**Time complexity: O(N)\\nSpace complexity: O(N)**\\n\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n       int count =0;\\n        unordered_map<int,int> mp; \\n        \\n        for(int i =0;i<nums.size();i++){\\n        \\n            int diff = k - nums[i];  \\n            if(mp[diff]>0){\\n                \\n                count++;               //found than increase the count . \\n                mp[diff]--;           \\n            }\\n            else{\\n                mp[nums[i]]++;         // no pair found so put it in hashmap\\n            }\\n            \\n            \\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n**Do like my post If it helps you than upvote!! :`)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int s=0,c=0;\\n        int e=n-1;\\n        while(s<e)\\n        {\\n            int sum=nums[s]+nums[e];\\n            if(sum==k)\\n            {\\n                c++;\\n                s++;\\n                e--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2005924,
                "title": "c-two-solutions",
                "content": "Two solutions below:\\n\\n**Solved live on stream.  Everyday 6pm PT.  Link in profile**\\n\\nHashmap\\nO(n) time\\nO(n) space\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> freqMap;\\n        int ans = 0;\\n        for(int x : nums) {\\n            int target = k - x;\\n            if(freqMap.find(target) != freqMap.end()) {\\n                freqMap[target]--;\\n                if(freqMap[target] == 0) freqMap.erase(target);\\n                ans++;\\n            } else {\\n                freqMap[x]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nsorting\\nO(nlogn) time\\nO(1) space\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int L = 0;\\n        int R = n - 1;\\n        int ans = 0;\\n        while(L < R) {\\n            int sum = nums[L] + nums[R];\\n            if(sum == k) {\\n                ans++;\\n                L++;\\n                R--;\\n            } else if (sum < k) {\\n                L++;\\n            } else if (sum > k) {\\n                R--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> freqMap;\\n        int ans = 0;\\n        for(int x : nums) {\\n            int target = k - x;\\n            if(freqMap.find(target) != freqMap.end()) {\\n                freqMap[target]--;\\n                if(freqMap[target] == 0) freqMap.erase(target);\\n                ans++;\\n            } else {\\n                freqMap[x]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int L = 0;\\n        int R = n - 1;\\n        int ans = 0;\\n        while(L < R) {\\n            int sum = nums[L] + nums[R];\\n            if(sum == k) {\\n                ans++;\\n                L++;\\n                R--;\\n            } else if (sum < k) {\\n                L++;\\n            } else if (sum > k) {\\n                R--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005867,
                "title": "python-simple-one-pass",
                "content": "This problem is an extension on the [Two Sum Problem](https://leetcode.com/problems/two-sum/). In Two Sum problem, you are just asked to find the existence of a pair that sums up to the target value. In this problem , we are asked to find all the pairs and return the count.\\n\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        counter = defaultdict(int)\\n        \\n        count = 0\\n        for x in nums:\\n            comp = k - x\\n            if counter[comp]>0:\\n                counter[comp]-=1\\n                count+=1\\n            else:\\n                counter[x] +=1\\n        \\n        return count\\n```\\n\\n**Time = O(N)** - Single iteration of the list\\n**Space = O(N)** - Store the hashmap\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        counter = defaultdict(int)\\n        \\n        count = 0\\n        for x in nums:\\n            comp = k - x\\n            if counter[comp]>0:\\n                counter[comp]-=1\\n                count+=1\\n            else:\\n                counter[x] +=1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732716,
                "title": "python-easy-solution-using-hashmap-o-n",
                "content": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n\\t\\t# calculate frequency of each number\\n        count = Counter(nums)\\n        operations = 0\\n        for num in count.keys():\\n\\t\\t    # we take minimum of each count to form pairs\\n            operations += min(count[num], count[k-num])\\n        # we need to divide these operations by 2\\n\\t\\t# since we have considered each pair twice\\n\\t\\t# as (n, k-n) and (k-n, n)\\n\\t\\treturn operations // 2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n\\t\\t# calculate frequency of each number\\n        count = Counter(nums)\\n        operations = 0\\n        for num in count.keys():\\n\\t\\t    # we take minimum of each count to form pairs\\n            operations += min(count[num], count[k-num])\\n        # we need to divide these operations by 2\\n\\t\\t# since we have considered each pair twice\\n\\t\\t# as (n, k-n) and (k-n, n)\\n\\t\\treturn operations // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096974,
                "title": "c-solution-with-two-pointers",
                "content": "```\\n  int count = 0;\\n        Array.Sort(nums);\\n        int p1 = 0;\\n        int p2 = nums.Length - 1;\\n        while(p1 < p2){\\n            if(nums[p1] + nums[p2]==k) { \\n                count++;\\n                p1++;\\n                p2--;\\n            };\\n            if(nums[p1] + nums[p2] > k) p2--;\\n            if(nums[p1] + nums[p2] < k) p1++;\\n            \\n        }\\n        return count;\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n  int count = 0;\\n        Array.Sort(nums);\\n        int p1 = 0;\\n        int p2 = nums.Length - 1;\\n        while(p1 < p2){\\n            if(nums[p1] + nums[p2]==k) { \\n                count++;\\n                p1++;\\n                p2--;\\n            };\\n            if(nums[p1] + nums[p2] > k) p2--;\\n            if(nums[p1] + nums[p2] < k) p1++;\\n            \\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022764,
                "title": "o-n-and-o-nlog-n-2-pointer-solution-100-better-time-complexity-c",
                "content": "O(nlog(n))\\n```\\nstatic const int _ = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int li=0,ri=nums.size()-1,ans=0,sum;\\n        while(li<ri)\\n        {\\n            sum=nums[li]+nums[ri];\\n            if(sum==k)\\n            {\\n                ans+=1;\\n                li++;\\n                ri--;\\n            }\\n            else if(sum>k)\\n            {\\n                ri--;\\n            }\\n            else\\n            {\\n                li++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nO(n) with using hashmap\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int ans=0;\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int trg=k-nums[i];\\n            if(mp[trg]>0)\\n            {\\n                ans+=1;\\n                mp[trg]-=1;\\n            }\\n            else\\n            {\\n                mp[nums[i]]+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nstatic const int _ = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int li=0,ri=nums.size()-1,ans=0,sum;\\n        while(li<ri)\\n        {\\n            sum=nums[li]+nums[ri];\\n            if(sum==k)\\n            {\\n                ans+=1;\\n                li++;\\n                ri--;\\n            }\\n            else if(sum>k)\\n            {\\n                ri--;\\n            }\\n            else\\n            {\\n                li++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int ans=0;\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int trg=k-nums[i];\\n            if(mp[trg]>0)\\n            {\\n                ans+=1;\\n                mp[trg]-=1;\\n            }\\n            else\\n            {\\n                mp[nums[i]]+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022728,
                "title": "python-using-dict-o-n-easy-to-understand-clean",
                "content": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        freq, ans = collections.defaultdict(int), 0\\n        for n in nums:\\n            if freq[k - n]:\\n                freq[k - n] -= 1\\n                ans += 1\\n            else:\\n                freq[n] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        freq, ans = collections.defaultdict(int), 0\\n        for n in nums:\\n            if freq[k - n]:\\n                freq[k - n] -= 1\\n                ans += 1\\n            else:\\n                freq[n] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967498,
                "title": "javsascript-simple-frequency-map-solution-w-explanation-100-92",
                "content": "***Idea:***\\n\\nWe can iterate through **nums**, and for any number that might have a match (**n < k**), we\\'ll check our **frequency map** for the corresponding pair number (**k - n**). If we find it, we increment our answer (**ans**), and if not, we store it as a possible later match.\\n\\nThen we just **return ans**.\\n\\nThe best result for the code below is **100ms / 48.5MB**.\\n\\n` `\\n***Code:***\\n```\\nvar maxOperations = function(nums, k) {\\n    let m = new Map(), ans = 0\\n    for (let n of nums)\\n        if (n < k)\\n            if (m.get(k - n)) m.set(k - n, m.get(k - n) - 1), ans++\\n            else m.set(n, (m.get(n) || 0) + 1)\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxOperations = function(nums, k) {\\n    let m = new Map(), ans = 0\\n    for (let n of nums)\\n        if (n < k)\\n            if (m.get(k - n)) m.set(k - n, m.get(k - n) - 1), ans++\\n            else m.set(n, (m.get(n) || 0) + 1)\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 965344,
                "title": "c-using-qsort",
                "content": "```\\nint comp_up(void const *a, void const *b) {\\n    return *(int *)a - *(int *)b;\\n}\\n\\nint maxOperations(int* nums, int numsSize, int k){\\n\\t\\n\\tqsort(nums, numsSize, sizeof(int), comp_up);\\n\\tint head = 0, tail = numsSize - 1;\\n\\tint i, sum, answer = 0;\\n\\tprintf(\"sort_complete\\\\n\");\\n\\tfor(i = 0; i < numsSize; i++)\\n\\t{\\n\\t\\tsum = nums[head] + nums[tail];\\n\\t\\tif(head >= tail)\\n\\t\\t{\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(sum > k)\\n\\t\\t{\\n\\t\\t\\ttail -= 1;\\n\\t\\t}\\n\\t\\telse if(sum < k)\\n\\t\\t{\\n\\t\\t\\thead += 1;\\n\\t\\t}\\n\\t\\telse if(sum == k)\\n\\t\\t{\\n\\t\\t\\tanswer++;\\n\\t\\t\\thead += 1;\\n\\t\\t\\ttail -= 1;\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint comp_up(void const *a, void const *b) {\\n    return *(int *)a - *(int *)b;\\n}\\n\\nint maxOperations(int* nums, int numsSize, int k){\\n\\t\\n\\tqsort(nums, numsSize, sizeof(int), comp_up);\\n\\tint head = 0, tail = numsSize - 1;\\n\\tint i, sum, answer = 0;\\n\\tprintf(\"sort_complete\\\\n\");\\n\\tfor(i = 0; i < numsSize; i++)\\n\\t{\\n\\t\\tsum = nums[head] + nums[tail];\\n\\t\\tif(head >= tail)\\n\\t\\t{\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(sum > k)\\n\\t\\t{\\n\\t\\t\\ttail -= 1;\\n\\t\\t}\\n\\t\\telse if(sum < k)\\n\\t\\t{\\n\\t\\t\\thead += 1;\\n\\t\\t}\\n\\t\\telse if(sum == k)\\n\\t\\t{\\n\\t\\t\\tanswer++;\\n\\t\\t\\thead += 1;\\n\\t\\t\\ttail -= 1;\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027482,
                "title": "max-number-of-k-sum-pairs-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int l = 0, r  = nums.size() - 1;\\n        int ans = 0;\\n        while(l < r) {\\n            if (nums[l] + nums[r] == k) {\\n                ans++;\\n                l++;\\n                r--;\\n            }\\n            else if (nums[l] + nums[r] < k) l++;\\n            else r--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int l = 0, r  = nums.size() - 1;\\n        int ans = 0;\\n        while(l < r) {\\n            if (nums[l] + nums[r] == k) {\\n                ans++;\\n                l++;\\n                r--;\\n            }\\n            else if (nums[l] + nums[r] < k) l++;\\n            else r--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851479,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Two Pointer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int l = 0, r  = nums.size() - 1;\\n        int ans = 0;\\n        while(l < r) {\\n            if (nums[l] + nums[r] == k) {\\n                ans++;\\n                l++;\\n                r--;\\n            }\\n            else if (nums[l] + nums[r] < k) l++;\\n            else r--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int l = 0, r  = nums.size() - 1;\\n        int ans = 0;\\n        while(l < r) {\\n            if (nums[l] + nums[r] == k) {\\n                ans++;\\n                l++;\\n                r--;\\n            }\\n            else if (nums[l] + nums[r] < k) l++;\\n            else r--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753044,
                "title": "easy-technique-using-sort-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntwo pointer approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the array of nums.Then we iterate over the array to find the pair of number which provide us the given sum.If the sum is equal to K then increase the count value by one.And then move both the pointer toward each other.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN) due to sort.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) no extra space except the two variables as low and high.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        sort(nums.begin(),nums.end());\\n        for(auto x:nums)\\n        {\\n            mp[x]++;\\n        }\\n        int count=0;\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            if(nums[low]+nums[high]==k)\\n            {\\n                count++;\\n                low++;high--;\\n            }\\n            else if(nums[low]+nums[high]>k)\\n            high-=1;\\n            else\\n            low+=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        sort(nums.begin(),nums.end());\\n        for(auto x:nums)\\n        {\\n            mp[x]++;\\n        }\\n        int count=0;\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            if(nums[low]+nums[high]==k)\\n            {\\n                count++;\\n                low++;high--;\\n            }\\n            else if(nums[low]+nums[high]>k)\\n            high-=1;\\n            else\\n            low+=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696440,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        \\n        int i=0,j=nums.size()-1;\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        while(i<j){\\n           if(nums[i]+nums[j]==k){\\n               count++;\\n               i++;j--;\\n               continue;\\n           }\\n           if(nums[i]+nums[j]>k)j--;\\n           else i++;\\n           \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        \\n        int i=0,j=nums.size()-1;\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        while(i<j){\\n           if(nums[i]+nums[j]==k){\\n               count++;\\n               i++;j--;\\n               continue;\\n           }\\n           if(nums[i]+nums[j]>k)j--;\\n           else i++;\\n           \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614076,
                "title": "simple-easy-soln-0-n-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe gonna fill our map as frequency map. And we gonna get the result by subtracting current value from k & whatever result we get, we gonna check in our map. If that is present increment the count & remove it from the map now. That\\'s how we\\'ll get our answer in just O(1) for searching & as we are using a loop thus, O(N). \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int>mp;\\n        int cnt=0;\\n        int n= nums.size();\\n        for(int i=0; i<n; i++) {\\n            int res= k-nums[i];\\n            if(mp.find(res)!=mp.end()) {\\n                cnt++;\\n                mp[res]--;\\n                if(mp[res]==0) mp.erase(res);\\n            }\\n            else {\\n                mp[nums[i]]++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int>mp;\\n        int cnt=0;\\n        int n= nums.size();\\n        for(int i=0; i<n; i++) {\\n            int res= k-nums[i];\\n            if(mp.find(res)!=mp.end()) {\\n                cnt++;\\n                mp[res]--;\\n                if(mp[res]==0) mp.erase(res);\\n            }\\n            else {\\n                mp[nums[i]]++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564973,
                "title": "two-solutions-map-two-pointers",
                "content": "Here are two approaches, they differ by time and space complexities.\\n\\n# Approach 1: Two pointers\\nFirst of all, we sort the array in-place, it takes $$O(n*log(n))$$ time. Then we place one pointer to the begin and the second to the end. We name it \"left\" and \"right\" respectively and check the sum of corresponding elements.\\n1. Sum equals `k`. This is the target pair, we move both pointers towards each other.\\n2. Sum is smaller than `k`. We move the left pointer to increase the sum.\\n3.  Sum is bigger than `k`. We move the right pointer to decrease the sum.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$ - in-place sorting.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MaxOperations(int[] nums, int k)\\n    {\\n        Array.Sort(nums);\\n        int answer = 0;\\n        int l = 0;\\n        int r = nums.Length - 1;\\n\\n        while (l < r)\\n        {\\n            int sum = nums[l] + nums[r];\\n            \\n            if (sum == k)\\n            {\\n                answer++;\\n                l++;\\n                r--;\\n            }\\n            else if (sum < k)\\n            {\\n                l++;\\n            }\\n            else\\n            {\\n                r--;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\\n\\n# Approach 2: Map\\nLet\\'s declare a map to store value-count pair. We traverse the array, checking for each value if its complementary is on the map. If so, we decrease the count for the complementary value. This imitates removing a pair from the array. If there is no complementary, we add current value to the map with count 1, or increase existing count by 1.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - array is traversed once.\\n\\n- Space complexity: $$O(n)$$ - a dictionary of size up to `n` is declared.\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MaxOperations(int[] nums, int k)\\n    {\\n        var map = new Dictionary<int, int>();\\n        int answer = 0;\\n        foreach (int num in nums)\\n        {\\n            if (map.ContainsKey(k - num) && map[k - num] > 0)\\n            {\\n                map[k - num]--;\\n                answer++;\\n            }\\n            else\\n            {\\n                if (!map.TryAdd(num, 1))\\n                {\\n                    map[num]++;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MaxOperations(int[] nums, int k)\\n    {\\n        Array.Sort(nums);\\n        int answer = 0;\\n        int l = 0;\\n        int r = nums.Length - 1;\\n\\n        while (l < r)\\n        {\\n            int sum = nums[l] + nums[r];\\n            \\n            if (sum == k)\\n            {\\n                answer++;\\n                l++;\\n                r--;\\n            }\\n            else if (sum < k)\\n            {\\n                l++;\\n            }\\n            else\\n            {\\n                r--;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int MaxOperations(int[] nums, int k)\\n    {\\n        var map = new Dictionary<int, int>();\\n        int answer = 0;\\n        foreach (int num in nums)\\n        {\\n            if (map.ContainsKey(k - num) && map[k - num] > 0)\\n            {\\n                map[k - num]--;\\n                answer++;\\n            }\\n            else\\n            {\\n                if (!map.TryAdd(num, 1))\\n                {\\n                    map[num]++;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530555,
                "title": "two-pointer-approach-java-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int i=0;\\n        int j = nums.length-1;\\n        int count=0;\\n        Arrays.sort(nums);\\n        while(i<j){\\n            if(nums[i]+nums[j]==k) {\\n                count++;\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]>k){\\n                if(nums[i]>nums[j]){\\n                    i++;\\n                }\\n                else{\\n                    j--;\\n                }\\n            }\\n            else if(nums[i]+nums[j]<k){\\n                if(nums[i]<nums[j]){\\n                    i++;\\n                }\\n                else{\\n                    j--;\\n                }\\n            }\\n\\n        }\\n        return count;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int i=0;\\n        int j = nums.length-1;\\n        int count=0;\\n        Arrays.sort(nums);\\n        while(i<j){\\n            if(nums[i]+nums[j]==k) {\\n                count++;\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i]+nums[j]>k){\\n                if(nums[i]>nums[j]){\\n                    i++;\\n                }\\n                else{\\n                    j--;\\n                }\\n            }\\n            else if(nums[i]+nums[j]<k){\\n                if(nums[i]<nums[j]){\\n                    i++;\\n                }\\n                else{\\n                    j--;\\n                }\\n            }\\n\\n        }\\n        return count;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526476,
                "title": "python-faster-than-99-9-hashmap-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/e5171bec-2421-4c2e-968e-c054848edeb3_1684140750.3920004.png)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        needSet = defaultdict(int)\\n        res = 0\\n        for n in nums:\\n            if needSet[n]:\\n                res += 1\\n                needSet[n] -= 1\\n\\n            else:\\n                needSet[k - n] += 1\\n\\n        return res\\n```\\n# Please upvote if you find this helpful.",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        needSet = defaultdict(int)\\n        res = 0\\n        for n in nums:\\n            if needSet[n]:\\n                res += 1\\n                needSet[n] -= 1\\n\\n            else:\\n                needSet[k - n] += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501505,
                "title": "java-very-easy-2-different-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n\\n        //Sorting And Two Pointer\\n\\n        // int i=0;\\n        // int j=nums.length-1;\\n        // int ans=0;\\n        // Arrays.sort(nums);\\n        // while(i<j){\\n        //     if(nums[i]+nums[j]==k){\\n        //         ans++;\\n        //         i++;\\n        //         j--;\\n        //     }\\n        //     else if(nums[i]+nums[j]<k){\\n        //         i++;\\n        //     }\\n        //     else{\\n        //         j--;\\n        //     }\\n            \\n            \\n        // }\\n        // return ans;\\n\\n\\n        //HashMap Solution\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(k-nums[i]) && map.get(k-nums[i])>0){\\n                ans++;\\n                map.put(k-nums[i],map.get(k-nums[i])-1);\\n            }\\n            else{\\n                map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n\\n        //Sorting And Two Pointer\\n\\n        // int i=0;\\n        // int j=nums.length-1;\\n        // int ans=0;\\n        // Arrays.sort(nums);\\n        // while(i<j){\\n        //     if(nums[i]+nums[j]==k){\\n        //         ans++;\\n        //         i++;\\n        //         j--;\\n        //     }\\n        //     else if(nums[i]+nums[j]<k){\\n        //         i++;\\n        //     }\\n        //     else{\\n        //         j--;\\n        //     }\\n            \\n            \\n        // }\\n        // return ans;\\n\\n\\n        //HashMap Solution\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(k-nums[i]) && map.get(k-nums[i])>0){\\n                ans++;\\n                map.put(k-nums[i],map.get(k-nums[i])-1);\\n            }\\n            else{\\n                map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267388,
                "title": "simple-python-solution-using-hashmap",
                "content": "# Intuition\\nRemember fundamental 2 sum problem -> where we find target-nums[i] exists in the map or not -> same intituion works here also .\\nso map comes to our mind and we think in a similar manner .\\n\\n# Approach\\nwe will iterate over the array -> and if k-i exists in our map + if its freq(k-i) in map > 0 only then -> we will find a pair and will reduce the freq of k-i in the map because we dont want to use it again  ,else\\nwe keep updating  the map with new values that dont form pairs .\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        c = 0\\n        mp = {}\\n        # problem becomes similar to subarray sum equals k \\n        # , only diff -> this is not continous subarray any pair can be choosen \\n        for i in nums:\\n            if (k-i) in mp and mp[k-i] > 0:\\n                c+=1\\n                mp[k-i] -= 1\\n            else:\\n                if i in mp :\\n                    mp[i]+=1\\n                else:\\n                    mp[i]=1\\n        return c \\n        \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        c = 0\\n        mp = {}\\n        # problem becomes similar to subarray sum equals k \\n        # , only diff -> this is not continous subarray any pair can be choosen \\n        for i in nums:\\n            if (k-i) in mp and mp[k-i] > 0:\\n                c+=1\\n                mp[k-i] -= 1\\n            else:\\n                if i in mp :\\n                    mp[i]+=1\\n                else:\\n                    mp[i]=1\\n        return c \\n        \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259359,
                "title": "easy-two-pointer-approach-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int n = nums.length, count = 0;\\n        int start = 0, end = n - 1;\\n        Arrays.sort(nums);\\n        while(start < end){\\n            if(nums[start] + nums[end] == k){\\n                count++;\\n                start++;\\n                end--;\\n            }\\n            else if(nums[start] + nums[end] < k)\\n                start++;\\n            else\\n                end--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int n = nums.length, count = 0;\\n        int start = 0, end = n - 1;\\n        Arrays.sort(nums);\\n        while(start < end){\\n            if(nums[start] + nums[end] == k){\\n                count++;\\n                start++;\\n                end--;\\n            }\\n            else if(nums[start] + nums[end] < k)\\n                start++;\\n            else\\n                end--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115128,
                "title": "c-beats-99-20-two-pointer-approach-sorting",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the vector\\n- Apply two pointer approach to find count of K-Sum Pair\\n- For each sum equals to K, change both pointers, and increment count. otherwise change only one pointer.\\n- Return count.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n\\n        int low =0, high = nums.size()-1, count =0;\\n\\n        while(low<high){\\n            int sum = nums[low]+nums[high];\\n            if(sum == k){\\n                low++;\\n                high--;\\n                count++;\\n            } \\n            else if(sum > k) high--;\\n            else    low++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n\\n        int low =0, high = nums.size()-1, count =0;\\n\\n        while(low<high){\\n            int sum = nums[low]+nums[high];\\n            if(sum == k){\\n                low++;\\n                high--;\\n                count++;\\n            } \\n            else if(sum > k) high--;\\n            else    low++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111300,
                "title": "python-intuitive-two-pass",
                "content": "# Intuition\\nThis is similar to Two Sum, except there are multiple valid pairs. I use similar ideas of using a hashmap counter, and identifying k-sum pairs by complementary values. \\n\\n--- \\nThe complement value (c) is the value that would complete a k-sum pair given n.\\n\\n(k - n = c, thus c + n = k)\\n\\n\\n# Approach \\n\\nI wanted a way to easily access the values of the array without iteration. So I decided to use a hashmap to track the instances of each num. This operation is O(n) time, and O(n) space.\\n\\n\\n\\nOk the next step is to identify complements and perform the operations. \\n\\nI think it is not needed to visit every n, especially if the n has already been used for a prior operation (and therefore, is a waste to check for complements). But in my case, I scan every n and calculate the complement value. O(n) time\\n\\n\\n\\nIf the complement value exists in the hashmap as a key, then it is possible that there is an available quantity of the complement and n values to use as a pair. If the quantity / counter for both complement and n is not 0, then the operation can be performed. \\n\\nI have nested if-statements, in case the complement and n are the same value, I need to verify that the counter is non-zero.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        counter = dict()\\n        for n in nums: \\n            if n in counter:\\n                counter[n] += 1\\n            else:\\n                counter[n] = 1\\n\\n        max_operations = 0 \\n        for n in nums:\\n            complement = k - n\\n            if complement in counter: \\n                if counter[complement] > 0: \\n                    counter[complement] -= 1\\n                    if counter[n] > 0:\\n                        counter[n] -= 1\\n                        max_operations += 1\\n                    else:\\n                        counter[complement] += 1 #undo because operation could not be completed (aka, the second if statement fails)\\n\\n        return max_operations\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        counter = dict()\\n        for n in nums: \\n            if n in counter:\\n                counter[n] += 1\\n            else:\\n                counter[n] = 1\\n\\n        max_operations = 0 \\n        for n in nums:\\n            complement = k - n\\n            if complement in counter: \\n                if counter[complement] > 0: \\n                    counter[complement] -= 1\\n                    if counter[n] > 0:\\n                        counter[n] -= 1\\n                        max_operations += 1\\n                    else:\\n                        counter[complement] += 1 #undo because operation could not be completed (aka, the second if statement fails)\\n\\n        return max_operations\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799298,
                "title": "python3-solution-two-pointers",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOperations(self, A, K):\\n        A.sort()\\n        ans, l, r = 0, 0, len(A) - 1\\n        while l < r:\\n            val = A[l] + A[r]\\n            if val <= K: l += 1\\n            if val >= K: r -= 1\\n            if val == K: ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, A, K):\\n        A.sort()\\n        ans, l, r = 0, 0, len(A) - 1\\n        while l < r:\\n            val = A[l] + A[r]\\n            if val <= K: l += 1\\n            if val >= K: r -= 1\\n            if val == K: ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751913,
                "title": "easy-cpp-two-pass-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   int maxOperations(vector<int>& nums, int k) \\n{\\n   unordered_map<int,int>mp;\\n   for(int i=0;i<nums.size();i++)\\n   {\\n   \\t mp[nums[i]]++;\\n   }\\n   int count=0;\\n   int idx=0;\\n   while(idx < nums.size())\\n   {\\n  \\t   if(mp.find(nums[idx])==mp.end())   // 1 1 1 1 2 3 4\\n  \\t   {\\n  \\t     \\t idx++;\\n       }\\n       else\\n       {\\n       \\t   mp[nums[idx]]--;\\n       \\n\\t       if(mp[nums[idx]]==0)\\n\\t       mp.erase(nums[idx]);\\n\\t\\t   \\n\\t\\t   if(mp.find(k-nums[idx])!=mp.end())  //mil gya  !=mp.end()\\n\\t\\t   {\\n\\t\\t     \\tcount++;\\n\\t\\t     \\tmp[k-nums[idx]]--;\\n\\t\\t     \\tif(mp[k-nums[idx]]==0)\\n\\t\\t     \\t{\\n\\t\\t     \\t\\tmp.erase(k-nums[idx]);\\n\\t\\t\\t    }\\n\\t\\t   }\\n\\t\\t   else    //nahi mila ie  === mp.end()\\n\\t\\t   {\\n\\t           mp[nums[idx]]++;\\n\\t\\t   }\\t\\n\\t\\t   idx++;\\n\\t   }\\n   }\\n   return count;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int maxOperations(vector<int>& nums, int k) \\n{\\n   unordered_map<int,int>mp;\\n   for(int i=0;i<nums.size();i++)\\n   {\\n   \\t mp[nums[i]]++;\\n   }\\n   int count=0;\\n   int idx=0;\\n   while(idx < nums.size())\\n   {\\n  \\t   if(mp.find(nums[idx])==mp.end())   // 1 1 1 1 2 3 4\\n  \\t   {\\n  \\t     \\t idx++;\\n       }\\n       else\\n       {\\n       \\t   mp[nums[idx]]--;\\n       \\n\\t       if(mp[nums[idx]]==0)\\n\\t       mp.erase(nums[idx]);\\n\\t\\t   \\n\\t\\t   if(mp.find(k-nums[idx])!=mp.end())  //mil gya  !=mp.end()\\n\\t\\t   {\\n\\t\\t     \\tcount++;\\n\\t\\t     \\tmp[k-nums[idx]]--;\\n\\t\\t     \\tif(mp[k-nums[idx]]==0)\\n\\t\\t     \\t{\\n\\t\\t     \\t\\tmp.erase(k-nums[idx]);\\n\\t\\t\\t    }\\n\\t\\t   }\\n\\t\\t   else    //nahi mila ie  === mp.end()\\n\\t\\t   {\\n\\t           mp[nums[idx]]++;\\n\\t\\t   }\\t\\n\\t\\t   idx++;\\n\\t   }\\n   }\\n   return count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751858,
                "title": "cpp-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n{\\n   sort(nums.begin(),nums.end());\\n   \\n   int i=0;\\n   int j=nums.size()-1;\\n   \\n   int count=0;\\n   \\n   while(i < j)\\n   {\\n   \\t  int sum = nums[i] + nums[j];\\n   \\t  if(sum == k)\\n   \\t  {\\n   \\t     count++;\\n\\t\\t i++;\\n\\t\\t j--;\\t\\n      }\\n      else if(sum < k)\\n      {\\n      \\t  i++;\\n\\t  }\\n\\t  else if(sum > k)\\n\\t  {\\n\\t  \\t j--;\\n\\t  }\\n   }\\n   return count;\\n           \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n{\\n   sort(nums.begin(),nums.end());\\n   \\n   int i=0;\\n   int j=nums.size()-1;\\n   \\n   int count=0;\\n   \\n   while(i < j)\\n   {\\n   \\t  int sum = nums[i] + nums[j];\\n   \\t  if(sum == k)\\n   \\t  {\\n   \\t     count++;\\n\\t\\t i++;\\n\\t\\t j--;\\t\\n      }\\n      else if(sum < k)\\n      {\\n      \\t  i++;\\n\\t  }\\n\\t  else if(sum > k)\\n\\t  {\\n\\t  \\t j--;\\n\\t  }\\n   }\\n   return count;\\n           \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361694,
                "title": "python-hashmap",
                "content": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        freq = defaultdict(int)\\n        count = 0\\n        for i, elem in enumerate(nums):\\n            if freq[k-elem]:\\n                count += 1\\n                freq[k-elem] -= 1\\n            else:\\n                freq[elem] += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        freq = defaultdict(int)\\n        count = 0\\n        for i, elem in enumerate(nums):\\n            if freq[k-elem]:\\n                count += 1\\n                freq[k-elem] -= 1\\n            else:\\n                freq[elem] += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263304,
                "title": "java-100-faster-95-space-efficient",
                "content": "```\\nclass Solution {\\n    public int maxOperations(int[] arr, int k) {\\n        Arrays.sort(arr);\\n        int i=0, j=arr.length-1, count= 0;\\n        while(i<j){\\n            if(arr[i]+arr[j]==k){\\n                count++;\\n                i++;\\n                j--;\\n            }\\n            else if(arr[i]+arr[j]>k) j--;\\n            else i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] arr, int k) {\\n        Arrays.sort(arr);\\n        int i=0, j=arr.length-1, count= 0;\\n        while(i<j){\\n            if(arr[i]+arr[j]==k){\\n                count++;\\n                i++;\\n                j--;\\n            }\\n            else if(arr[i]+arr[j]>k) j--;\\n            else i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137782,
                "title": "javascript-o-n-using-map",
                "content": "\\tvar maxOperations = function(nums, k) {\\n\\t\\t let count = 0;\\n\\t\\tlet map = new Map();\\n\\t\\tfor(let i=0;i<nums.length;i++){\\n\\t\\t\\tif(map.get(k-nums[i])){\\n\\t\\t\\t if(map.get(k-nums[i]===1)) map.delete(k-nums[i]);\\n\\t\\t\\t else map.set(k-nums[i],(map.get(k-nums[i])-1))\\n\\t\\t\\t count++;\\n\\t\\t\\t}else{\\n\\t\\t\\tmap.set(nums[i],(map.get(nums[i])+1 || 1))}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar maxOperations = function(nums, k) {\\n\\t\\t let count = 0;\\n\\t\\tlet map = new Map();\\n\\t\\tfor(let i=0;i<nums.length;i++){\\n\\t\\t\\tif(map.get(k-nums[i])){\\n\\t\\t\\t if(map.get(k-nums[i]===1)) map.delete(k-nums[i]);\\n\\t\\t\\t else map.set(k-nums[i],(map.get(k-nums[i])-1))\\n\\t\\t\\t count++;\\n\\t\\t\\t}else{\\n\\t\\t\\tmap.set(nums[i],(map.get(nums[i])+1 || 1))}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2008428,
                "title": "python-solution-all-test-cases-passed",
                "content": "```\\npublic class Solution {\\n    public int MaxOperations(int[] nums, int k) {\\n        \\n        if(nums?.Length == 0){\\n            return 0;\\n        }\\n        \\n        int result = 0;\\n        Array.Sort(nums);\\n        int i = 0;\\n        int j = nums.Length - 1;\\n        \\n        while(i < j){\\n            \\n            if(nums[i] + nums[j] == k){\\n                result++;\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i] + nums[j] < k){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxOperations(int[] nums, int k) {\\n        \\n        if(nums?.Length == 0){\\n            return 0;\\n        }\\n        \\n        int result = 0;\\n        Array.Sort(nums);\\n        int i = 0;\\n        int j = nums.Length - 1;\\n        \\n        while(i < j){\\n            \\n            if(nums[i] + nums[j] == k){\\n                result++;\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i] + nums[j] < k){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008017,
                "title": "python-solution",
                "content": "**Upvote** if you like solution and feel **free to ask** If you have any question.\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        opr = 0\\n        num = {}\\n        for i in nums:\\n            num[i]= num.get(i, 0) + 1\\n        for i in nums:\\n            if num.get(i, 0) != 0 and num.get(k-i, 0) != 0:\\n                if k-i == i :\\n                    if num.get(i) > 1:\\n                        opr += 1\\n                        num[i] -= 2\\n                else:\\n                    opr += 1\\n                    num[i] -= 1\\n                    num[k-i] -= 1\\n        return opr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        opr = 0\\n        num = {}\\n        for i in nums:\\n            num[i]= num.get(i, 0) + 1\\n        for i in nums:\\n            if num.get(i, 0) != 0 and num.get(k-i, 0) != 0:\\n                if k-i == i :\\n                    if num.get(i) > 1:\\n                        opr += 1\\n                        num[i] -= 2\\n                else:\\n                    opr += 1\\n                    num[i] -= 1\\n                    num[k-i] -= 1\\n        return opr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007979,
                "title": "python-detailed-solution-o-n-using-dictionary",
                "content": "**The Algorithm:**\\n\\n* Initialize the number of operations to 0 (i.e., `num_operations = 0`)\\n* Keep track of numbers you\\'ve already seen and how many of these numbers are available\\n\\t* Naturally we use a dictionary (e.g., `{number: how_many_available_of_number}`)\\n* While looping through the numbers (`num`), check to see if you have the `k`\\'s complement of that number (i.e., `k-num`) is available in your dictionary\\n\\t* The complement (i.e., `k-num`) is available if it exists in your dictionary and has a positive number of them available (i.e., `d[k-num] in d and d[k-num]>0`)\\n* As we use complements of `k` in the previous step, subtract them from their availability in the dictionary (i.e., `d[k-num] -= 1`) and increase the number of operations (i.e., `num_operations += 1`)\\n* If the complment of `k` was not available then simply increase the count of the current number in the dictionary (i.e., `d[num] += 1`) or initialize count if it\\'s not already available (i.e., `d[num] = 1`)\\n\\n---\\n**The Code:**\\n\\n```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'O(N) time complexity; where N is the length of nums\\'\\'\\'\\n        \\n        num_operations = 0\\n        d = {}  \\n        \\n        for num in nums:\\n            if ((k-num) in d) and (d[k-num] > 0):\\n                d[k-num] -= 1\\n                num_operations += 1\\n            elif num not in d:\\n                d[num] = 1\\n            else:\\n                d[num] += 1\\n                \\n        return num_operations\\n```\\n---\\n**Alternative using `defaultdict`:**\\n*Cleanup credited to [@domthedeveloper](https://leetcode.com/domthedeveloper/)*\\n\\n```\\n\\tfrom collections import defaultdict\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'O(N) time complexity; where N is the length of nums\\'\\'\\'\\n        \\n        num_operations = 0\\n        d = defaultdict(lambda: 0)\\n        \\n        for num in nums:\\n            if ((k-num) in d) and (d[k-num] > 0):\\n                d[k-num] -= 1\\n                num_operations += 1\\n            else:\\n                d[num] += 1\\n                \\n        return num_operations\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'O(N) time complexity; where N is the length of nums\\'\\'\\'\\n        \\n        num_operations = 0\\n        d = {}  \\n        \\n        for num in nums:\\n            if ((k-num) in d) and (d[k-num] > 0):\\n                d[k-num] -= 1\\n                num_operations += 1\\n            elif num not in d:\\n                d[num] = 1\\n            else:\\n                d[num] += 1\\n                \\n        return num_operations\\n```\n```\\n\\tfrom collections import defaultdict\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'O(N) time complexity; where N is the length of nums\\'\\'\\'\\n        \\n        num_operations = 0\\n        d = defaultdict(lambda: 0)\\n        \\n        for num in nums:\\n            if ((k-num) in d) and (d[k-num] > 0):\\n                d[k-num] -= 1\\n                num_operations += 1\\n            else:\\n                d[num] += 1\\n                \\n        return num_operations\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2007169,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn max_operations(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut count = 0;\\n        let mut map = std::collections::HashMap::with_capacity(nums.len());\\n        nums.iter().for_each(|&x| {\\n            let e = map.entry(x).or_insert(0);\\n            match *e {\\n                0 => {\\n                    map.entry(k - x).and_modify(|x| *x += 1).or_insert(1);\\n                }\\n                _ => {\\n                    *e -= 1;\\n                    count += 1;\\n                }\\n            }\\n        });\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_operations(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut count = 0;\\n        let mut map = std::collections::HashMap::with_capacity(nums.len());\\n        nums.iter().for_each(|&x| {\\n            let e = map.entry(x).or_insert(0);\\n            match *e {\\n                0 => {\\n                    map.entry(k - x).and_modify(|x| *x += 1).or_insert(1);\\n                }\\n                _ => {\\n                    *e -= 1;\\n                    count += 1;\\n                }\\n            }\\n        });\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006964,
                "title": "approach-1-o-n-solution-o-n-space-similar-to-2-sum-clean-code",
                "content": "Approach 1 :\\n\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n\\n        Map<Integer,Integer> freq = new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++) {\\n             freq.put(nums[i],freq.getOrDefault(nums[i],0)+1);   \\n        }\\n        int count=0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i]<=k && freq.get(nums[i])>0 && freq.getOrDefault(k-nums[i],0)>0) {\\n                if((k-nums[i] == nums[i]) && freq.get(nums[i])<=1) {\\n                    continue;\\n                }\\n               freq.put(nums[i],freq.getOrDefault(nums[i],0)-1);\\n               freq.put(k-nums[i],freq.getOrDefault(k-nums[i],0)-1);\\n               count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nApproach 2 : Coming soon :-)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n\\n        Map<Integer,Integer> freq = new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++) {\\n             freq.put(nums[i],freq.getOrDefault(nums[i],0)+1);   \\n        }\\n        int count=0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i]<=k && freq.get(nums[i])>0 && freq.getOrDefault(k-nums[i],0)>0) {\\n                if((k-nums[i] == nums[i]) && freq.get(nums[i])<=1) {\\n                    continue;\\n                }\\n               freq.put(nums[i],freq.getOrDefault(nums[i],0)-1);\\n               freq.put(k-nums[i],freq.getOrDefault(k-nums[i],0)-1);\\n               count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006823,
                "title": "rust-concise-o-n-o-n-one-pass",
                "content": "I think it is nice to be able to avoid maintaining a separate count variable by using the combination of `filter()` and `count()`.\\n\\n```\\nuse std::{collections::HashMap};\\n\\nimpl Solution {\\n    pub fn max_operations(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut map = HashMap::<i32, usize>::new();\\n        nums.into_iter().filter(|n| {\\n            // Look for an unmatched complement to n\\n            match map.get_mut(&(k-n)) {\\n                Some(&mut 0) | None => { *map.entry(*n).or_insert(0) += 1; false },\\n                Some(v) => { *v -= 1; true },\\n            }\\n        }).count() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::{collections::HashMap};\\n\\nimpl Solution {\\n    pub fn max_operations(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut map = HashMap::<i32, usize>::new();\\n        nums.into_iter().filter(|n| {\\n            // Look for an unmatched complement to n\\n            match map.get_mut(&(k-n)) {\\n                Some(&mut 0) | None => { *map.entry(*n).or_insert(0) += 1; false },\\n                Some(v) => { *v -= 1; true },\\n            }\\n        }).count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006678,
                "title": "c-variation-of-two-sum-easy-to-understand",
                "content": "\\n    int maxOperations(vector<int>& nums, int k) {\\n        int result=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            if(nums[i]+nums[j]==k){\\n                result++; \\n                i++;\\n                j--;\\n            }\\n            else if(nums[i] + nums[j] > k) j--;\\n            else i++;\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n    int maxOperations(vector<int>& nums, int k) {\\n        int result=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            if(nums[i]+nums[j]==k){\\n                result++; \\n                i++;\\n                j--;\\n            }\\n            else if(nums[i] + nums[j] > k) j--;\\n            else i++;\\n        }\\n        return result;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2006668,
                "title": "easiest-solution-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n//Please do upvote if you like my solution :)\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(k-nums[i]) != mp.end()){\\n                ans++;\\n                mp[k-nums[i]]--;\\n                if(mp[k-nums[i]] == 0){\\n                    mp.erase(k-nums[i]);\\n                }\\n            }else{\\n                mp[nums[i]]++;\\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Please do upvote if you like my solution :)\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(k-nums[i]) != mp.end()){\\n                ans++;\\n                mp[k-nums[i]]--;\\n                if(mp[k-nums[i]] == 0){\\n                    mp.erase(k-nums[i]);\\n                }\\n            }else{\\n                mp[nums[i]]++;\\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006647,
                "title": "java-solution-using-hashmaps",
                "content": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n      HashMap <Integer, Integer> map = new HashMap<>();\\n      int count = 0;\\n      for(int i = 0; i < nums.length; i ++) {\\n        if(map.containsKey(k - nums[i]) && map.get(k - nums[i]) > 0) {\\n          count ++;\\n          map.put(k - nums[i], map.get(k - nums[i]) - 1);\\n        }\\n        else {\\n           map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);  \\n        }\\n      }\\n           return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxOperations(int[] nums, int k) {\\n      HashMap <Integer, Integer> map = new HashMap<>();\\n      int count = 0;\\n      for(int i = 0; i < nums.length; i ++) {\\n        if(map.containsKey(k - nums[i]) && map.get(k - nums[i]) > 0) {\\n          count ++;\\n          map.put(k - nums[i], map.get(k - nums[i]) - 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2006529,
                "title": "easy-java-solution-faster-than-100-other-java-solutions",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n\\t\\n        Arrays.sort(nums);\\n        int i = 0; \\n        int j = nums.length-1;\\n         int count= 0;\\n        while(i<j){\\n            if(nums[i]+nums[j]==k){\\n                count++;\\n                i++;\\n                j--;\\n            }else if(nums[i]+nums[j]<k){\\n                i++;\\n            }else if(nums[i]+nums[j]>k){\\n                j--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int maxOperations(int[] nums, int k) {\\n\\t\\n        Arrays.sort(nums);\\n        int i = 0; \\n        int j = nums.length-1;\\n         int count= 0;\\n        while(i<j){\\n            if(nums[i]+nums[j]==k){\\n                count++;\\n                i++;\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2006519,
                "title": "java-easiest-approach-using-two-pointers",
                "content": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n     int i = 0, j = nums.length - 1, count = 0;\\n      Arrays.sort(nums);\\n      while(i < j) {\\n        if(nums[i] + nums[j] == k) {\\n          count ++;\\n          i ++;\\n          j --;\\n        }\\n        else if(nums[i] + nums[j] < k) i ++;\\n        else j --;\\n      }\\n      return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int maxOperations(int[] nums, int k) {\\n     int i = 0, j = nums.length - 1, count = 0;\\n      Arrays.sort(nums);\\n      while(i < j) {\\n        if(nums[i] + nums[j] == k) {\\n          count ++;\\n          i ++;\\n          j --;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2006404,
                "title": "c-straightforward-using-dicitionary",
                "content": "```\\nusing System;\\nusing System.Collections.Generic;\\n\\npublic class Solution\\n{\\n    public int MaxOperations(int[] nums, int k)\\n    {\\n        Dictionary<int, int> dictionary = new();\\n        foreach (int num in nums)\\n        {\\n            if (dictionary.ContainsKey(num) is false) dictionary[num] = 0;\\n            dictionary[num]++;\\n        }\\n\\n        int numberOfOperations = 0;\\n        foreach ((int element, int elementCount) in dictionary)\\n        {\\n            int otherElement = k - element;\\n            if (element == otherElement)\\n            {\\n                numberOfOperations += elementCount / 2;\\n            }\\n            else if (dictionary.ContainsKey(otherElement))\\n            {\\n                numberOfOperations += Math.Min(dictionary[otherElement], dictionary[element]);\\n                dictionary[element] = dictionary[otherElement] = 0;\\n            }\\n        }\\n\\n        return numberOfOperations;\\n    }\\n}\\n```\\n\\nEDIT:\\n\\nOne foreach solution\\n```\\npublic int MaxOperations(int[] nums, int k)\\n{\\n    Dictionary<int, int> dictionary = new();\\n\\n    int pairs = 0;\\n    foreach (int num in nums)\\n    {\\n        int otherNum = k - num;\\n        if (dictionary.ContainsKey(otherNum) && dictionary[otherNum] > 0)\\n        {\\n            dictionary[otherNum]--;\\n            pairs++;\\n        }\\n        else if (dictionary.ContainsKey(num) is false)\\n        {\\n            dictionary.Add(num, 1);\\n        }\\n        else\\n        {\\n            dictionary[num]++;\\n        }\\n    }\\n\\n    return pairs;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\n\\npublic class Solution\\n{\\n    public int MaxOperations(int[] nums, int k)\\n    {\\n        Dictionary<int, int> dictionary = new();\\n        foreach (int num in nums)\\n        {\\n            if (dictionary.ContainsKey(num) is false) dictionary[num] = 0;\\n            dictionary[num]++;\\n        }\\n\\n        int numberOfOperations = 0;\\n        foreach ((int element, int elementCount) in dictionary)\\n        {\\n            int otherElement = k - element;\\n            if (element == otherElement)\\n            {\\n                numberOfOperations += elementCount / 2;\\n            }\\n            else if (dictionary.ContainsKey(otherElement))\\n            {\\n                numberOfOperations += Math.Min(dictionary[otherElement], dictionary[element]);\\n                dictionary[element] = dictionary[otherElement] = 0;\\n            }\\n        }\\n\\n        return numberOfOperations;\\n    }\\n}\\n```\n```\\npublic int MaxOperations(int[] nums, int k)\\n{\\n    Dictionary<int, int> dictionary = new();\\n\\n    int pairs = 0;\\n    foreach (int num in nums)\\n    {\\n        int otherNum = k - num;\\n        if (dictionary.ContainsKey(otherNum) && dictionary[otherNum] > 0)\\n        {\\n            dictionary[otherNum]--;\\n            pairs++;\\n        }\\n        else if (dictionary.ContainsKey(num) is false)\\n        {\\n            dictionary.Add(num, 1);\\n        }\\n        else\\n        {\\n            dictionary[num]++;\\n        }\\n    }\\n\\n    return pairs;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006355,
                "title": "4-solutions-hash-table-counter-two-pointers-and-pruning-with-video-explanation",
                "content": "Video explanation [here](https://www.youtube.com/watch?v=kp8hdby56PQ) for people who prefer a video format \\n\\n**Solution 1: using hash table**\\n\\nIdea: count occurrences as we traverse and for each num check if we\\u2019ve seen k - num before if so increase num of operations\\n\\n```python\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n  occ = collections.defaultdict(int)\\n  count = 0\\n  for num in nums:\\n      if occ[k - num] > 0:\\n          occ[k - num] -= 1\\n          count += 1\\n      else:\\n          occ[num] += 1\\n  return count\\n```\\n\\ntime complexity: O(n)\\nspace complexity: O(n)\\n\\n**Solution 2: using counter**\\n\\nIdea: for each x number of operations possible using are min(occ[x], occ[k - x]) so add that to count of operations, but since we will count twice for each one for x and one for k - x so divide count by 2 to account for duplicate count \\n\\n```python\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n  occ = collections.Counter(nums)\\n  count = 0\\n  for x in occ:\\n      count += min(occ[x], occ[k - x])\\n  return count // 2\\n```\\ntime complexity: O(n)\\nspace complexity: O(n)\\n\\n**Solution 3: using Sorting and two pointers**\\n\\nIdea: sort the array and use two pointers at the start and end if sum in those position == k add it, otherwise if its < k increase pointer s to get a bigger value to potentially reach k but if its > k decrease e to get smaller sum to potentially reach k.\\n\\n```python\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n  nums.sort()\\n  s, e = 0, len(nums) - 1\\n  count = 0\\n  while s < e:\\n      if nums[s] + nums[e] == k:\\n          count += 1\\n          s += 1\\n          e -= 1\\n      elif nums[s] + nums[e] > k:\\n          e -= 1\\n      else:\\n          s += 1\\n  return count\\n```\\n\\ntime complexity: O(n log n) \\nspace complexity: O(1)\\n\\n**Solution 4: two pointers with pruning**\\n\\nimproves on solution 3 by pruning cases where nums[s] > k \\n\\nwe can\\u2019t do nums[e] > k because as we move e elements gets smaller so it may become equal to k \\n\\nbut for nums[s] > k as we progress s it gets larger so wont be equal to k \\n\\n```python\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n  nums.sort()\\n  s, e = 0, len(nums) - 1\\n  count = 0\\n  while s < e and nums[s] < k:\\n      if nums[s] + nums[e] == k:\\n          count += 1\\n          s += 1\\n          e -= 1\\n      elif nums[s] + nums[e] > k:\\n          e -= 1\\n      else:\\n          s += 1\\n  return count\\n```\\n\\ntime complexity: O(n log n) \\nspace complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```python\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n  occ = collections.defaultdict(int)\\n  count = 0\\n  for num in nums:\\n      if occ[k - num] > 0:\\n          occ[k - num] -= 1\\n          count += 1\\n      else:\\n          occ[num] += 1\\n  return count\\n```\n```python\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n  occ = collections.Counter(nums)\\n  count = 0\\n  for x in occ:\\n      count += min(occ[x], occ[k - x])\\n  return count // 2\\n```\n```python\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n  nums.sort()\\n  s, e = 0, len(nums) - 1\\n  count = 0\\n  while s < e:\\n      if nums[s] + nums[e] == k:\\n          count += 1\\n          s += 1\\n          e -= 1\\n      elif nums[s] + nums[e] > k:\\n          e -= 1\\n      else:\\n          s += 1\\n  return count\\n```\n```python\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n  nums.sort()\\n  s, e = 0, len(nums) - 1\\n  count = 0\\n  while s < e and nums[s] < k:\\n      if nums[s] + nums[e] == k:\\n          count += 1\\n          s += 1\\n          e -= 1\\n      elif nums[s] + nums[e] > k:\\n          e -= 1\\n      else:\\n          s += 1\\n  return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2006320,
                "title": "hashmap-solution",
                "content": "```\\nvar maxOperations = function(nums, k) {\\n    let map = new Map;\\n    let count = 0;\\n    for(let each of nums) {\\n        if (map.has(each)){\\n            map.set(each, map.get(each) - 1);\\n            map.get(each) == 0 && map.delete(each)\\n            count++;\\n        }else {\\n            map.set(k-each,map.get(k-each) + 1 || 1);\\n        }\\n    }\\n    return count;\\n};\\n```\\n**PLEASE UPVOTE if you liked the solution!**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxOperations = function(nums, k) {\\n    let map = new Map;\\n    let count = 0;\\n    for(let each of nums) {\\n        if (map.has(each)){\\n            map.set(each, map.get(each) - 1);\\n            map.get(each) == 0 && map.delete(each)\\n            count++;\\n        }else {\\n            map.set(k-each,map.get(k-each) + 1 || 1);\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006268,
                "title": "c-solution-using-hashmap",
                "content": "The problem can be solved easily using a hashtable or hashmap which is unordered_map in C++ as given below:\\n\\n\\t\\n\\tint maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int,int> lookup;\\n        int operation = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(lookup.find(nums[i]) == lookup.end()) // not found\\n            {\\n                lookup[k-nums[i]]++;\\n            }\\n            else\\n            {\\n                operation++;\\n                lookup[nums[i]]--;\\n                if(lookup[nums[i]] == 0)\\n                    lookup.erase(nums[i]);\\n            }\\n        }\\n        return operation;\\n    }\\n\\t\\nPlease comment if any clarification needed or for any improvements for this code.",
                "solutionTags": [
                    "C"
                ],
                "code": "The problem can be solved easily using a hashtable or hashmap which is unordered_map in C++ as given below:\\n\\n\\t\\n\\tint maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int,int> lookup;\\n        int operation = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(lookup.find(nums[i]) == lookup.end()) // not found\\n            {\\n                lookup[k-nums[i]]++;\\n            }\\n            else\\n            {\\n                operation++;\\n                lookup[nums[i]]--;\\n                if(lookup[nums[i]] == 0)\\n                    lookup.erase(nums[i]);\\n            }\\n        }\\n        return operation;\\n    }\\n\\t\\nPlease comment if any clarification needed or for any improvements for this code.",
                "codeTag": "Unknown"
            },
            {
                "id": 2006243,
                "title": "java-11-features-100-0ms-simple-concise-5-lines-2-ways",
                "content": "```\\n**class Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        var map=new HashMap<Integer,Integer>();\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(k-nums[i])&&map.get(k-nums[i])>0){\\n                c++;\\n                map.put(k-nums[i],map.get(k-nums[i])-1);\\n            }else map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }return c;\\n    }\\n}**\\n\\n2ND METHOD 2 POINTERS TECHNIC USING BINARY SEARCH.\\n\\npublic int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j]==k)\\n            {\\n                i++;\\n                j--;\\n                count++;\\n            }\\n            else if(nums[i]+nums[j]<k)\\n            {\\n                i++;\\n            }\\n            else if(nums[i]+nums[j]>k)\\n            {\\n                j--;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "PHP"
                ],
                "code": "```\\n**class Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        var map=new HashMap<Integer,Integer>();\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(k-nums[i])&&map.get(k-nums[i])>0){\\n                c++;\\n                map.put(k-nums[i],map.get(k-nums[i])-1);\\n            }else map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }return c;\\n    }\\n}**\\n\\n2ND METHOD 2 POINTERS TECHNIC USING BINARY SEARCH.\\n\\npublic int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i=0;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j]==k)\\n            {\\n                i++;\\n                j--;\\n                count++;\\n            }\\n            else if(nums[i]+nums[j]<k)\\n            {\\n                i++;\\n            }\\n            else if(nums[i]+nums[j]>k)\\n            {\\n                j--;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006100,
                "title": "c-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tunordered_map<int, int> map;\\n\\t\\tint maxOperations(vector<int>& nums, int k) {        \\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(auto& num: nums) {\\n\\n\\t\\t\\t\\tmap[num]++;\\n\\n\\t\\t\\t\\tif(num * 2 == k) {\\n\\t\\t\\t\\t\\tif(map[num] == 2) {\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tmap[num] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(map[k - num] > 0) {\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tmap[num]--;\\n\\t\\t\\t\\t\\t\\tmap[k - num]--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tunordered_map<int, int> map;\\n\\t\\tint maxOperations(vector<int>& nums, int k) {        \\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(auto& num: nums) {\\n\\n\\t\\t\\t\\tmap[num]++;\\n\\n\\t\\t\\t\\tif(num * 2 == k) {\\n\\t\\t\\t\\t\\tif(map[num] == 2) {\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tmap[num] = 0;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2006008,
                "title": "simple-c-solution-with-o-n-complexity",
                "content": "Time Complexity: Average O(n)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[ nums[i] ]++;\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == k - nums[i]){\\n                if(mp[ nums[i] ] > 1){\\n                    mp[ nums[i] ] -= 2;\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                if(mp[ nums[i] ] && mp[ k - nums[i] ]){\\n                    cnt++;\\n                    mp[ nums[i] ]--;\\n                    mp[ k - nums[i] ]--;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[ nums[i] ]++;\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == k - nums[i]){\\n                if(mp[ nums[i] ] > 1){\\n                    mp[ nums[i] ] -= 2;\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                if(mp[ nums[i] ] && mp[ k - nums[i] ]){\\n                    cnt++;\\n                    mp[ nums[i] ]--;\\n                    mp[ k - nums[i] ]--;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005984,
                "title": "max-number-of-k-sum-pairs-c-simple-approach-two-pointers-enjoy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n\\t\\t// ans variable is used to count the number of pairs.\\n\\t\\t// Initially i points to 1st indes & j points to last index.\\n        int ans = 0, i = 0, j = nums.size() - 1;\\n\\t\\t// Sorting the array in ascending order.\\n        sort(nums.begin(), nums.end());\\n\\t\\t// We run loop till i is smaller than j to avoid counting pair twice.\\n        while(i < j)\\n        {\\n\\t\\t\\t// If we found a pair we simply add 1 to our ans then increment i & decrement j.\\n\\t\\t\\t// Since they already made a pair we do not check them again.\\n            if(nums[i] + nums[j] == k)\\n            {\\n                ans++;\\n                i++, j--;\\n            }\\n\\t\\t\\t// The logic behind sorting the vector is - \\n\\t\\t\\t// We begin with the sum of smallest & largest number in our vector.\\n\\t\\t\\t// If sum is equal to k fine we get a pair we move on\\n\\t\\t\\t// But if sum is smaller it means that the largest number combining with the smallest number is not enough so we increment i taking the 2nd most smallest element in vector. \\n\\t\\t\\t// We keep doing this until we find a pair with sum equals to k or sum of pairs becomes larger than k.\\n            else if(nums[i] + nums[j] < k)\\n                i++;\\n\\t\\t\\t// In case if sum becomes larger than k that means largest number is too big so we decrement j & take the 2nd most largest number. \\n            else\\n                j--;\\n        }\\n\\t\\t// After the loop ends ans will contain the number of pairs we encounter whose sum is equal to k.\\n        return ans;\\n    }\\n};\\n```\\n\\nThank You for reading, for any doubt leave a comment.\\n\\n```\\n// Code without comments\\n\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        int ans = 0, i = 0, j = nums.size() - 1;\\n        sort(nums.begin(), nums.end());\\n        while(i < j)\\n        {\\n            if(nums[i] + nums[j] == k)\\n            {\\n                ans++;\\n                i++, j--;\\n            }\\n            else if(nums[i] + nums[j] < k)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n\\t\\t// ans variable is used to count the number of pairs.\\n\\t\\t// Initially i points to 1st indes & j points to last index.\\n        int ans = 0, i = 0, j = nums.size() - 1;\\n\\t\\t// Sorting the array in ascending order.\\n        sort(nums.begin(), nums.end());\\n\\t\\t// We run loop till i is smaller than j to avoid counting pair twice.\\n        while(i < j)\\n        {\\n\\t\\t\\t// If we found a pair we simply add 1 to our ans then increment i & decrement j.\\n\\t\\t\\t// Since they already made a pair we do not check them again.\\n            if(nums[i] + nums[j] == k)\\n            {\\n                ans++;\\n                i++, j--;\\n            }\\n\\t\\t\\t// The logic behind sorting the vector is - \\n\\t\\t\\t// We begin with the sum of smallest & largest number in our vector.\\n\\t\\t\\t// If sum is equal to k fine we get a pair we move on\\n\\t\\t\\t// But if sum is smaller it means that the largest number combining with the smallest number is not enough so we increment i taking the 2nd most smallest element in vector. \\n\\t\\t\\t// We keep doing this until we find a pair with sum equals to k or sum of pairs becomes larger than k.\\n            else if(nums[i] + nums[j] < k)\\n                i++;\\n\\t\\t\\t// In case if sum becomes larger than k that means largest number is too big so we decrement j & take the 2nd most largest number. \\n            else\\n                j--;\\n        }\\n\\t\\t// After the loop ends ans will contain the number of pairs we encounter whose sum is equal to k.\\n        return ans;\\n    }\\n};\\n```\n```\\n// Code without comments\\n\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) \\n    {\\n        int ans = 0, i = 0, j = nums.size() - 1;\\n        sort(nums.begin(), nums.end());\\n        while(i < j)\\n        {\\n            if(nums[i] + nums[j] == k)\\n            {\\n                ans++;\\n                i++, j--;\\n            }\\n            else if(nums[i] + nums[j] < k)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005980,
                "title": "c-two-approaches-hashmap-and-two-pointer-best-optimized-approach",
                "content": "\\n****upvote if you find it helpsfull \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F****\\n.\\n\\n\\n.\\n**Approach -> Use of hash map;**\\n.\\t\\t\\t\\t\\t\\t**Using hashmap we are using O(N) space but time complxity is O(1);**\\n\\t\\t\\n\\t\\t\\n\\t\\tunordered_map<int, int> m;\\n\\t\\tint ans = 0;\\n\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\tif(m[k - nums[i]] > 0){\\n\\t\\t\\t   m[k - nums[i]]--;\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tm[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\n\\n**Approach -> 2 Using two pointer**\\n\\n**in this we are using sort function so time complxity will be O(N(Log(N))) but space complxity will be constant O(1);**\\n\\n\\n\\t\\tsort(nums.begin(), nums.end());\\n        int cnt = 0;\\n        int i=0, j=nums.size()-1;\\n        while(i<j){\\n            if(nums[i]+nums[j]>k) j--;\\n            else if(nums[i]+nums[j]<k)i++;\\n            else i++,j--,cnt++;\\n        }\\n        return cnt;\\n\\t\\t\\n\\t\\t\\n****upvote if you find it helpsfull****",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n****upvote if you find it helpsfull \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F****\\n.\\n\\n\\n.\\n**Approach -> Use of hash map;**\\n.\\t\\t\\t\\t\\t\\t**Using hashmap we are using O(N) space but time complxity is O(1);**\\n\\t\\t\\n\\t\\t\\n\\t\\tunordered_map<int, int> m;\\n\\t\\tint ans = 0;\\n\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\tif(m[k - nums[i]] > 0){\\n\\t\\t\\t   m[k - nums[i]]--;\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tm[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\n\\n**Approach -> 2 Using two pointer**\\n\\n**in this we are using sort function so time complxity will be O(N(Log(N))) but space complxity will be constant O(1);**\\n\\n\\n\\t\\tsort(nums.begin(), nums.end());\\n        int cnt = 0;\\n        int i=0, j=nums.size()-1;\\n        while(i<j){\\n            if(nums[i]+nums[j]>k) j--;\\n            else if(nums[i]+nums[j]<k)i++;\\n            else i++,j--,cnt++;\\n        }\\n        return cnt;\\n\\t\\t\\n\\t\\t\\n****upvote if you find it helpsfull****",
                "codeTag": "Unknown"
            },
            {
                "id": 2005875,
                "title": "java-tc-o-nlgn-two-pointers-14ms-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/82e844e5-ab17-43ab-abb0-ee4218ec8ad6_1651625636.6223786.png)\\n\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        Arrays.parallelSort(nums);\\n        int l = -1;\\n        int r = n;\\n        // binary search to find right boundary\\n        while (l + 1 < r) {\\n            int m = l + ((r - l) >> 1);\\n            if (nums[m] < k) {\\n                l = m;\\n            } else {\\n                r = m;\\n            } \\n        } \\n        r = l;\\n        l = 0;\\n        int total = 0;\\n        while (l < r) {\\n            int sum = nums[l] + nums[r];\\n            if (sum > k) {\\n                r--;\\n            } else if (sum < k) {\\n                l++;\\n            } else {\\n                total++;\\n                l++;\\n                r--;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        Arrays.parallelSort(nums);\\n        int l = -1;\\n        int r = n;\\n        // binary search to find right boundary\\n        while (l + 1 < r) {\\n            int m = l + ((r - l) >> 1);\\n            if (nums[m] < k) {\\n                l = m;\\n            } else {\\n                r = m;\\n            } \\n        } \\n        r = l;\\n        l = 0;\\n        int total = 0;\\n        while (l < r) {\\n            int sum = nums[l] + nums[r];\\n            if (sum > k) {\\n                r--;\\n            } else if (sum < k) {\\n                l++;\\n            } else {\\n                total++;\\n                l++;\\n                r--;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126140,
                "title": "simple-hashing-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int d=k-nums[i];\\n            if(mp.find(d)!=mp.end()&&mp[d]!=0)\\n            {\\n                ans++;\\n                mp[d]--;\\n            }\\n            else\\n                mp[nums[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int d=k-nums[i];\\n            if(mp.find(d)!=mp.end()&&mp[d]!=0)\\n            {\\n                ans++;\\n                mp[d]--;\\n            }\\n            else\\n                mp[nums[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104913,
                "title": "c-simple-code-and-well-explanation-with-picture",
                "content": "# **Two pointer approach [Time: O(nlogn) Space: O(1)]**\\n*  `sum == k` means we find a solution, so we store it to `ans` and shift both pointer ->` left++ and right--`\\n*  `sum < k` so we have to increase the sum and shift the Left pointer to the right by 1 unit -> `left++`\\n*  `sum > k` so we have to decrease the sum. So we will shift the Right pointer to the left by 1 unit ->`right--`\\n*  `left >= right` means we iterated over all elemens. So, we will return `ans` and break the loop.\\n \\n![image](https://assets.leetcode.com/users/images/ae82992b-72ad-41f8-b76e-21431e474459_1615488034.9953485.png) \\n ![image](https://assets.leetcode.com/users/images/3aac8b03-119d-4808-89e8-f35f049dd7fd_1615488033.8425758.png)\\n\\n\\n**C++ program**\\n\\n```\\nint maxOperations(vector<int>& nums, int k) {\\n        int left = 0, right = nums.size()-1, ans=0;\\n        sort(nums.begin(), nums.end());\\n        while(left < right){\\n            int sum = nums[left] + nums[right];\\n            if(sum == k){\\n                ans++;\\n                left++;\\n                right--;\\n            }\\n            else if(sum < k) left++;\\n            else right--;\\n        }\\n        return ans;\\n    }\\n```\\n\\n# **Map approach [Time: O(n) Space: O(n)]**\\n* We have to find two numbers `a and b` such that, `a + b = k`. So, if one number is `a` the the another is `k - a`\\n* For each iteration, if the number is `a` , we will find `k - a` in map `pre`.\\n  * If we find the number `k - a` , then `ans++` and `pre[k - a]--` . As we can use `k - a` for the next iteration / second time.\\n  * If we cant find number `k - a`, then we have to store `a` in map `pre`  to find this value in future iteration/next iteration. `pre[a]++`\\n * After the loop, the program will end and return `ans`.\\n\\n**C++ program**\\n```\\nint maxOperations(vector<int>& nums, int k) {\\n        int n=nums.size(), ans=0;\\n        map<int,int> pre;\\n        for(int a: nums){\\n            int target = k - a;\\n            if(pre[target]){\\n                ans++;\\n                pre[target]--;\\n            }\\n            else pre[a]++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint maxOperations(vector<int>& nums, int k) {\\n        int left = 0, right = nums.size()-1, ans=0;\\n        sort(nums.begin(), nums.end());\\n        while(left < right){\\n            int sum = nums[left] + nums[right];\\n            if(sum == k){\\n                ans++;\\n                left++;\\n                right--;\\n            }\\n            else if(sum < k) left++;\\n            else right--;\\n        }\\n        return ans;\\n    }\\n```\n```\\nint maxOperations(vector<int>& nums, int k) {\\n        int n=nums.size(), ans=0;\\n        map<int,int> pre;\\n        for(int a: nums){\\n            int target = k - a;\\n            if(pre[target]){\\n                ans++;\\n                pre[target]--;\\n            }\\n            else pre[a]++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037955,
                "title": "golang-very-very-simple-approach",
                "content": "```\\nfunc maxOperations(nums []int, k int) int {\\n    m := make(map[int]int)\\n    var res int\\n    for _, v := range nums {\\n        if m[v] > 0 {\\n            res++\\n            m[v]--\\n        } else {\\n            m[k - v]++\\n        }\\n        \\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxOperations(nums []int, k int) int {\\n    m := make(map[int]int)\\n    var res int\\n    for _, v := range nums {\\n        if m[v] > 0 {\\n            res++\\n            m[v]--\\n        } else {\\n            m[k - v]++\\n        }\\n        \\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1024019,
                "title": "simple-java-solution-with-explaination-o-n-time-single-pass",
                "content": "1. We will take map to score frequency of each item in array.\\n2. we will increase frequency only if current item doesnot make pair. \\n3. if k-item is present inside map (checked via positive value). then increment result counter and decrement value present at k-item position in map.\\n4. after loop finishes result is the desired answer.\\nTo save map space once frequency of current item is exhausted it is removed from map.\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int pairs=0;\\n        for(int item:nums) {\\n            int val = map.getOrDefault(k-item,0);\\n            if(val>0) {\\n                pairs++;\\n                if(val==1) {\\n                    map.remove(k-item);\\n                } else {\\n                map.put(k-item,val-1);\\n                    \\n                }\\n            } else {\\n            \\tmap.put(item, map.getOrDefault(item, 0)+1);\\n            }\\n        }   \\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int pairs=0;\\n        for(int item:nums) {\\n            int val = map.getOrDefault(k-item,0);\\n            if(val>0) {\\n                pairs++;\\n                if(val==1) {\\n                    map.remove(k-item);\\n                } else {\\n                map.put(k-item,val-1);\\n                    \\n                }\\n            } else {\\n            \\tmap.put(item, map.getOrDefault(item, 0)+1);\\n            }\\n        }   \\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023610,
                "title": "javascript-o-n-solution",
                "content": "```javascript\\nvar maxOperations = function(nums, k) {\\n    const seen = new Map();\\n    let count = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        const diff = k - nums[i];\\n        \\n        if(!seen.has(diff)) {\\n            seen.set(nums[i], (seen.get(nums[i]) || 0) + 1);\\n            continue;\\n        }\\n        seen.set(diff, seen.get(diff)-1);\\n        if(!seen.get(diff)) seen.delete(diff);\\n        count++;\\n    }\\n    return count;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxOperations = function(nums, k) {\\n    const seen = new Map();\\n    let count = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        const diff = k - nums[i];\\n        \\n        if(!seen.has(diff)) {\\n            seen.set(nums[i], (seen.get(nums[i]) || 0) + 1);\\n            continue;\\n        }\\n        seen.set(diff, seen.get(diff)-1);\\n        if(!seen.get(diff)) seen.delete(diff);\\n        count++;\\n    }\\n    return count;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023268,
                "title": "what-s-the-difference-between-unordered-map-and-map-in-c",
                "content": "My accepted answer\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        map<int, int> m;\\n        for (const auto& n: nums) {\\n          ++m[n];\\n        }\\n        int res = 0;\\n        for (const auto& e: m) {\\n          if (e.first < ((k+1) / 2)) {            \\n            res += min(e.second, m[k - e.first]);\\n          }\\n        }\\n        if ((k & 1) == 0 && m[k / 2] > 0) {\\n          res += (m[k / 2] / 2);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut why I got wrong answer when I was using `unordered_map<int, int> m`. And it is even more strange that, the unordered_map version can give correct answer for following input on my local machine:\\nApple clang version 12.0.0 (clang-1200.0.32.28), compiled with -std=c++17\\n```\\n[73,74,74,71,68,67,45,1,24,2,26,48,82,82,28,60,19,36,26,9,12,83,1,86,18,78,14,66,20,26,4,80,44,35,53,48,74,25,75,47,31,20,59,10,35,24,26,3,48,69,78,43,12,86,37,49,1,90,20,35,58,20,2,20,16,18,88,25,44,63,12,16,64,41,86,87,2,23,14,63,43,60,47,7,23,11,64,53,71,78,82,56,65,25,27,52,89,68,63,14,48]\\n44\\n```\\n\\nAny one can tell the reason?\\n\\nThanks in advance!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        map<int, int> m;\\n        for (const auto& n: nums) {\\n          ++m[n];\\n        }\\n        int res = 0;\\n        for (const auto& e: m) {\\n          if (e.first < ((k+1) / 2)) {            \\n            res += min(e.second, m[k - e.first]);\\n          }\\n        }\\n        if ((k & 1) == 0 && m[k / 2] > 0) {\\n          res += (m[k / 2] / 2);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n[73,74,74,71,68,67,45,1,24,2,26,48,82,82,28,60,19,36,26,9,12,83,1,86,18,78,14,66,20,26,4,80,44,35,53,48,74,25,75,47,31,20,59,10,35,24,26,3,48,69,78,43,12,86,37,49,1,90,20,35,58,20,2,20,16,18,88,25,44,63,12,16,64,41,86,87,2,23,14,63,43,60,47,7,23,11,64,53,71,78,82,56,65,25,27,52,89,68,63,14,48]\\n44\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022983,
                "title": "python-very-easy-to-understand-o-n-solution",
                "content": "```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n\\tcount = {}\\n\\toperations = 0\\n\\n\\tfor num in nums:\\n\\t\\tif (k - num) in count and count[k-num] > 0:\\n\\t\\t\\toperations += 1\\n\\t\\t\\tcount[k-num] -= 1\\n\\t\\telse:\\n\\t\\t\\tcount[num] = count.get(num, 0) + 1\\n\\treturn operations\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n\\tcount = {}\\n\\toperations = 0\\n\\n\\tfor num in nums:\\n\\t\\tif (k - num) in count and count[k-num] > 0:\\n\\t\\t\\toperations += 1\\n\\t\\t\\tcount[k-num] -= 1\\n\\t\\telse:\\n\\t\\t\\tcount[num] = count.get(num, 0) + 1\\n\\treturn operations\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1022944,
                "title": "2-solutions-in-python-3-one-using-hashmap-and-the-other-using-sort-2-pointer",
                "content": "1. Hashmap solution, runtime=O(n), space=O(n)\\n```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n\\tdic = defaultdict(int)\\n\\tcount = 0\\n\\tfor n in nums:\\n\\t\\tif k-n in dic and dic[k-n]>0:\\n\\t\\t\\tdic[k-n]-=1\\n\\t\\t\\tcount+=1\\n\\t\\telse:\\n\\t\\t\\tdic[n]+=1\\n\\treturn count\\n```\\n\\n2. Sorting + two pointers, runtime=O(nlogn), space=O(1)\\n\\n```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n\\tnums.sort()\\n\\ts, e = 0, len(nums)-1\\n\\tcount = 0\\n\\n\\twhile s<e:\\n\\t\\tadd = nums[s]+nums[e]\\n\\t\\tif add==k:\\n\\t\\t\\tcount+=1\\n\\t\\t\\ts+=1\\n\\t\\t\\te-=1\\n\\t\\telif add>k:\\n\\t\\t\\te-=1\\n\\t\\telse:\\n\\t\\t\\ts+=1\\n\\treturn count\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n\\tdic = defaultdict(int)\\n\\tcount = 0\\n\\tfor n in nums:\\n\\t\\tif k-n in dic and dic[k-n]>0:\\n\\t\\t\\tdic[k-n]-=1\\n\\t\\t\\tcount+=1\\n\\t\\telse:\\n\\t\\t\\tdic[n]+=1\\n\\treturn count\\n```\n```\\ndef maxOperations(self, nums: List[int], k: int) -> int:\\n\\tnums.sort()\\n\\ts, e = 0, len(nums)-1\\n\\tcount = 0\\n\\n\\twhile s<e:\\n\\t\\tadd = nums[s]+nums[e]\\n\\t\\tif add==k:\\n\\t\\t\\tcount+=1\\n\\t\\t\\ts+=1\\n\\t\\t\\te-=1\\n\\t\\telif add>k:\\n\\t\\t\\te-=1\\n\\t\\telse:\\n\\t\\t\\ts+=1\\n\\treturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1022934,
                "title": "rust-hashmap-onepass",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn max_operations(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut res = 0;\\n        let mut hashmap = HashMap::new();\\n        for num in nums {\\n            let target = k - num;\\n            match hashmap.get_mut(&target) {\\n                Some(a) => {\\n                    if *a > 1 {\\n                        *a -= 1;\\n                    } else {\\n                        hashmap.remove_entry(&target);\\n                    }\\n                    res += 1;\\n                }\\n                None => {\\n                    *hashmap.entry(num).or_insert(0) += 1;\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn max_operations(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut res = 0;\\n        let mut hashmap = HashMap::new();\\n        for num in nums {\\n            let target = k - num;\\n            match hashmap.get_mut(&target) {\\n                Some(a) => {\\n                    if *a > 1 {\\n                        *a -= 1;\\n                    } else {\\n                        hashmap.remove_entry(&target);\\n                    }\\n                    res += 1;\\n                }\\n                None => {\\n                    *hashmap.entry(num).or_insert(0) += 1;\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022897,
                "title": "python-o-n-using-dictionary-1-pass-accepted",
                "content": "```\\ndef maxOperations(nums, k):\\n\\tn_dict = defaultdict(int)\\n\\tcount = 0\\n\\tfor n in nums:\\n\\t\\tif n == k-n and n in n_dict and n_dict[n] > 0:\\n\\t\\t\\tv = n_dict[n] + 1\\n\\t\\t\\tcount += v//2\\n\\t\\t\\tn_dict[n] = 0 if v%2 == 0 else 1\\n\\t\\telif k-n in n_dict and n_dict[k-n] > 0:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tn_dict[k-n] -= 1\\n\\t\\telse:\\n\\t\\t\\tn_dict[n] += 1    \\n\\n\\treturn count",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef maxOperations(nums, k):\\n\\tn_dict = defaultdict(int)\\n\\tcount = 0\\n\\tfor n in nums:\\n\\t\\tif n == k-n and n in n_dict and n_dict[n] > 0:\\n\\t\\t\\tv = n_dict[n] + 1\\n\\t\\t\\tcount += v//2\\n\\t\\t\\tn_dict[n] = 0 if v%2 == 0 else 1\\n\\t\\telif k-n in n_dict and n_dict[k-n] > 0:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tn_dict[k-n] -= 1\\n\\t\\telse:\\n\\t\\t\\tn_dict[n] += 1    \\n\\n\\treturn count",
                "codeTag": "Python3"
            },
            {
                "id": 1022679,
                "title": "c-one-pass-simple-easy-to-understand-solution",
                "content": "Time complexity - O(n)\\nSpace complexity - O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int count=0;\\n        int n=nums.size();\\n        unordered_map<int,int> um;\\n        for(int i=0;i<n;i++){\\n            if(um[k-nums[i]]>0){\\n                um[k-nums[i]]--;\\n                count++;\\n            }\\n            else\\n                um[nums[i]]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        int count=0;\\n        int n=nums.size();\\n        unordered_map<int,int> um;\\n        for(int i=0;i<n;i++){\\n            if(um[k-nums[i]]>0){\\n                um[k-nums[i]]--;\\n                count++;\\n            }\\n            else\\n                um[nums[i]]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975352,
                "title": "python-3-same-old-two-sum-problem-linear-with-hash-table",
                "content": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        d = defaultdict(int)\\n        for x in nums:\\n            if k-x in d:\\n                ans += 1\\n                d[k-x] -= 1\\n                if d[k-x] == 0: del d[k-x]\\n            else:\\n                d[x] += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        d = defaultdict(int)\\n        for x in nums:\\n            if k-x in d:\\n                ans += 1\\n                d[k-x] -= 1\\n                if d[k-x] == 0: del d[k-x]\\n            else:\\n                d[x] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961662,
                "title": "c-faster-than-70-two-pointer-simple-solution-with-explanation",
                "content": "**Time Complexity = O(N longN)**\\n\\nAlgorithm Followed :-\\n1. Keep two pointers, one at the front and one at the end of the array given\\n2. start a while loop with the condition front<end (as if front>=end it will overflow the floop)\\n3. check if the sum of elements at these pointers equals the given sum, k\\n4. if the sum equals k, then move the front pointer forward, end pointer backward, and increment the result counter by 1\\n5. if the sum is less than k, increase the front pointer forward\\n6. if the sum is greater than k, decrease the end pointer backward\\n7. return the result counter as the final answer\\n\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n          sort(nums.begin(), nums.end());       //sort the elements int the vector to make it usable for two pointer approach\\n          int result = 0;                       //initialize the result integer with 0\\n          int front=0, end=nums.size()-1;       //initialize two pointers pointing at the front and end of the array \\n          while(front<end){\\n            if(nums[front]+nums[end] == k){     //if the element is suitable i.e. sum == k then increase the result\\n                result++;    //increment result\\n                front++;     //increment the front pointer to the next element\\n                end--;       //decrement the end pointer to the next element from backward dirrection\\n            } \\n\\n            else if(nums[front] + nums[end] > k){\\n                end--;       //if the sum is greater than required then reduce the end pointer to the next element from backward\\n            }\\n\\n            else{\\n                front++;     //if the sum is smaller than required then increas the front pointer to the next element from front\\n            }    \\n          }\\n          return result;     //return the result count as the final answer\\n    }\\n};\\n```\\n\\nAuthor: shubham1592\\n[https://github.com/shubham1592/LeetCode/blob/main/1679_Max_Sum_of_K_sum_Pairs.cpp](https://github.com/shubham1592/LeetCode/blob/main/1679_Max_Sum_of_K_sum_Pairs.cpp)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n          sort(nums.begin(), nums.end());       //sort the elements int the vector to make it usable for two pointer approach\\n          int result = 0;                       //initialize the result integer with 0\\n          int front=0, end=nums.size()-1;       //initialize two pointers pointing at the front and end of the array \\n          while(front<end){\\n            if(nums[front]+nums[end] == k){     //if the element is suitable i.e. sum == k then increase the result\\n                result++;    //increment result\\n                front++;     //increment the front pointer to the next element\\n                end--;       //decrement the end pointer to the next element from backward dirrection\\n            } \\n\\n            else if(nums[front] + nums[end] > k){\\n                end--;       //if the sum is greater than required then reduce the end pointer to the next element from backward\\n            }\\n\\n            else{\\n                front++;     //if the sum is smaller than required then increas the front pointer to the next element from front\\n            }    \\n          }\\n          return result;     //return the result count as the final answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961425,
                "title": "c-simple-straightforward-to-the-point",
                "content": "Goal is simple:\\nKeep store index of every element in a map\\nAlso check, for each num, if k-num is available or not.\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        map<int,vector<int>> mp;\\n        int ans=0;\\n        for(int x=0; x<nums.size(); ++x){\\n            if(nums[x]>=k) continue;\\n            if(mp[k-nums[x]].size()){\\n                mp[k-nums[x]].pop_back();\\n                ans++;\\n            }\\n            else mp[numx[x]].push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        map<int,vector<int>> mp;\\n        int ans=0;\\n        for(int x=0; x<nums.size(); ++x){\\n            if(nums[x]>=k) continue;\\n            if(mp[k-nums[x]].size()){\\n                mp[k-nums[x]].pop_back();\\n                ans++;\\n            }\\n            else mp[numx[x]].push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961357,
                "title": "python-clean-counter-solution-o-n-o-n",
                "content": "**Idea**\\n\\nWe can use a hashmap to store the frequency of each number. Then we simply go through each number and update `ans` accordingly. \\n\\nBe careful about the edge case where `num * 2 == k`.\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(N)`\\n- Space complexity: `O(N)`\\n\\n</br>\\n\\n**Python**\\n\\n```Python\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        counter = collections.Counter(nums)\\n        ans = 0\\n        for num in counter:\\n            cnt = min(counter[num], counter[k - num])\\n            if cnt == 0:\\n                continue\\n            counter[num] -= cnt\\n            counter[k - num] -= cnt\\n            ans += (cnt // 2) if num * 2 == k else cnt\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        counter = collections.Counter(nums)\\n        ans = 0\\n        for num in counter:\\n            cnt = min(counter[num], counter[k - num])\\n            if cnt == 0:\\n                continue\\n            counter[num] -= cnt\\n            counter[k - num] -= cnt\\n            ans += (cnt // 2) if num * 2 == k else cnt\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932532,
                "title": "java-simple-two-pointer",
                "content": "# Complexity\\n- Time complexity: **O(N log N)**\\n\\n\\n- Space complexity: **O(1)**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int i = 0;\\n        int j = nums.length-1;\\n        while(i < j)\\n        {\\n            if(nums[i] + nums[j] == k)\\n            {\\n                ans++;\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i] + nums[j] > k)\\n            {\\n                j--;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int i = 0;\\n        int j = nums.length-1;\\n        while(i < j)\\n        {\\n            if(nums[i] + nums[j] == k)\\n            {\\n                ans++;\\n                i++;\\n                j--;\\n            }\\n            else if(nums[i] + nums[j] > k)\\n            {\\n                j--;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927391,
                "title": "c-simplest-easiest-optimal-solution-using-sorting-two-pointer-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n\\n        int ans = 0;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        int s = 0;\\n        int e = nums.size() - 1;\\n\\n        while(s < e) {\\n            if(nums[s] + nums[e] == k) {\\n                ans++;\\n                s++;\\n                e--;\\n            }\\n            else if(nums[s] + nums[e] > k)\\n                e--;\\n            else \\n                s++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n\\n        int ans = 0;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        int s = 0;\\n        int e = nums.size() - 1;\\n\\n        while(s < e) {\\n            if(nums[s] + nums[e] == k) {\\n                ans++;\\n                s++;\\n                e--;\\n            }\\n            else if(nums[s] + nums[e] > k)\\n                e--;\\n            else \\n                s++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922908,
                "title": "c-mio-s-solution",
                "content": "# Approach\\n\\u9019\\u500B\\u65B9\\u6CD5\\u6211\\u5011\\u4F7F\\u7528\\u5B57\\u5178\\u4F86\\u8FFD\\u8E64\\u6578\\u5B57\\u7684\\u51FA\\u73FE\\u6B21\\u6578\\u3002\\u6211\\u5011\\u904D\\u6B77\\u8F38\\u5165\\u7684\\u6578\\u7D44\\uFF0C\\u6AA2\\u67E5\\u6BCF\\u500B\\u6578\\u5B57\\u662F\\u5426\\u5B58\\u5728\\u4E00\\u500B\\u8207\\u4E4B\\u76F8\\u52A0\\u7B49\\u65BC\\u76EE\\u6A19\\u503C `k` \\u7684\\u6578\\u5B57\\uFF0C\\u4E26\\u4E14\\u9019\\u500B\\u6578\\u5B57\\u7684\\u6B21\\u6578\\u5927\\u65BC\\u96F6\\u3002\\u5982\\u679C\\u6EFF\\u8DB3\\u9019\\u500B\\u689D\\u4EF6\\uFF0C\\u589E\\u52A0 `operationCount` \\u7684\\u503C\\uFF0C\\u540C\\u6642\\u5C07\\u76F8\\u61C9\\u7684\\u6B21\\u6578\\u6E1B\\u5C11\\u3002\\u5982\\u679C\\u4E0D\\u7B26\\u5408\\u689D\\u4EF6\\uFF0C\\u5247\\u76EE\\u524D\\u6578\\u5B57\\u7684\\u6B21\\u6578\\u589E\\u52A0\\u3002\\u9019\\u6A23\\u53EF\\u4EE5\\u78BA\\u4FDD\\u5C0D\\u65BC\\u6BCF\\u500B\\u6578\\u5B57\\uFF0C\\u80FD\\u5920\\u627E\\u5230\\u4E00\\u500B\\u8207\\u4E4B\\u5339\\u914D\\u7684\\u6578\\u5B57\\u4F86\\u57F7\\u884C\\u64CD\\u4F5C\\u3002\\n\\nIn this approach, we utilize a dictionary to track the occurrences of numbers. We iterate through the input array and check for each number whether there exists another number that, when added to it, equals the target value k, and this second number\\'s count is greater than zero. If this condition is met, we increment the value of operationCount and decrement the corresponding count. If the condition is not met, we increment the count to the current number. This ensures that for each number, we can find a matching number to perform the operation.\\n\\nIn summary, we employ a dictionary to efficiently manage the counts of numbers, allowing us to identify pairs that fulfill the required conditions and perform the operations accordingly.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxOperations(int[] nums, int k) {\\n        Dictionary<int, int> numCounts = new Dictionary<int, int>();\\n        int operationCount = 0;\\n\\n        foreach (int num in nums)\\n        {\\n            if (numCounts.ContainsKey(k - num) && numCounts[k - num] > 0)\\n            {\\n                operationCount++;\\n                numCounts[k - num]--;\\n            }\\n            else\\n            {\\n                if (!numCounts.ContainsKey(num))\\n                    numCounts[num] = 0;\\n                numCounts[num]++;\\n            }\\n        }\\n\\n        return operationCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxOperations(int[] nums, int k) {\\n        Dictionary<int, int> numCounts = new Dictionary<int, int>();\\n        int operationCount = 0;\\n\\n        foreach (int num in nums)\\n        {\\n            if (numCounts.ContainsKey(k - num) && numCounts[k - num] > 0)\\n            {\\n                operationCount++;\\n                numCounts[k - num]--;\\n            }\\n            else\\n            {\\n                if (!numCounts.ContainsKey(num))\\n                    numCounts[num] = 0;\\n                numCounts[num]++;\\n            }\\n        }\\n\\n        return operationCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911571,
                "title": "easy-solution-using-two-pointers-in-o-1-space",
                "content": "# Intuition\\nWe have to find the number of operations we can perform. In one operation, we can remove the two numbers whose sum is equal to `k`.\\nWe can solve this question using two pointers. We will first sort the array, and point one pointer at the beginning of the array and another at the end of the array.\\nWe will compare the sum with `k` and move the pointers accordingly.\\n\\n# Approach\\nFirst sort the array. Then initialize two pointers `left=0` & `right=nums.size()-1` and one counter variable `ans=0`. The we will loop through the array and perform one of the following steps:\\n\\n1. If the sum of the numbers present at the current pointers is equal to `k`, we will increase the counter and left pointer and decrease the right pointer.\\n2. If the sum is less than `k`, then we have to increase the left pointer. **Reason**: The right pointer will be having its max value. To increase the sum, we have to increase the left pointer as left now it will be having its min value.\\n3. If the sum is greater than `k`, then we have to decrease the right pointer. **Reason**: The left pointer will be having its min value. To decrease the sum, we have to decrease the right pointer as right now it will be having its max value.\\n\\nAt the end, we will just return the counter.\\n \\n# Complexity\\n- Time complexity: O(N log N) for sorting and O(N) for looping. So overall O(N log N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxOperations(vector<int>& nums, int k) {\\n    int n = nums.size(), ans = 0;\\n    sort(nums.begin(), nums.end());\\n    int left = 0, right = n - 1;\\n    while(left < right) {\\n      int x = nums[left], y = nums[right];\\n      if(x + y == k) {\\n        left++, right--, ans++;\\n      } else if(x + y < k) {\\n        left++;\\n      } else {\\n        right--;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maxOperations(vector<int>& nums, int k) {\\n    int n = nums.size(), ans = 0;\\n    sort(nums.begin(), nums.end());\\n    int left = 0, right = n - 1;\\n    while(left < right) {\\n      int x = nums[left], y = nums[right];\\n      if(x + y == k) {\\n        left++, right--, ans++;\\n      } else if(x + y < k) {\\n        left++;\\n      } else {\\n        right--;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800009,
                "title": "max-number-of-k-sum-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/4928fde8-a566-41b4-b69b-7a8b4253804f_1690014842.159875.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        op=0\\n        left=0\\n        right=len(nums)-1\\n        nums.sort()\\n        while left<right:\\n            if nums[left]+nums[right]==k and left<right:\\n                op+=1\\n                left+=1\\n                right-=1\\n            elif nums[left]+nums[right]>k:\\n                right-=1\\n            else:\\n                left+=1\\n        return op\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOperations(self, nums: List[int], k: int) -> int:\\n        op=0\\n        left=0\\n        right=len(nums)-1\\n        nums.sort()\\n        while left<right:\\n            if nums[left]+nums[right]==k and left<right:\\n                op+=1\\n                left+=1\\n                right-=1\\n            elif nums[left]+nums[right]>k:\\n                right-=1\\n            else:\\n                left+=1\\n        return op\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799970,
                "title": "c-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n * 1679. Max Number of K-Sum Pairs\\n *\\n * You are given an integer array nums and an integer k.\\n * \\n * In one operation, you can pick two numbers from the \\n * array whose sum equals k and remove them from the array.\\n * \\n * Return the maximum number of operations you can perform \\n * on the array.\\n *\\n * 1 <= nums.length <= 10^5\\n * 1 <= nums[i] <= 10^9\\n * 1 <= k <= 10^9\\n */\\n\\nint cmp(const void *a, const void *b)\\n{\\n    return *((int *)a) - *((int *)b);\\n}\\n\\nint maxOperations(int* nums, int numsSize, int k){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  k\\n     */\\n\\n    int ans = 0;\\n\\n    /* Sort nums by value in ascending order */\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    /* \\n     * Two pointers point to leftmost and rightmost \\n     * compare the sum of values and move the pointer accordingly\\n     */\\n    for (int i = 0, j = numsSize - 1; i < j; ) {\\n\\n        if (nums[i] + nums[j] > k) {\\n            j--;\\n        }\\n        else if (nums[i] + nums[j] < k) {\\n            i++;\\n        }\\n        else {\\n            ans++;\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    /*\\n     * Return the maximum number of operations you can perform \\n     * on the array.\\n     */\\n\\n    return ans;\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n/*\\n * 1679. Max Number of K-Sum Pairs\\n *\\n * You are given an integer array nums and an integer k.\\n * \\n * In one operation, you can pick two numbers from the \\n * array whose sum equals k and remove them from the array.\\n * \\n * Return the maximum number of operations you can perform \\n * on the array.\\n *\\n * 1 <= nums.length <= 10^5\\n * 1 <= nums[i] <= 10^9\\n * 1 <= k <= 10^9\\n */\\n\\nint cmp(const void *a, const void *b)\\n{\\n    return *((int *)a) - *((int *)b);\\n}\\n\\nint maxOperations(int* nums, int numsSize, int k){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  k\\n     */\\n\\n    int ans = 0;\\n\\n    /* Sort nums by value in ascending order */\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    /* \\n     * Two pointers point to leftmost and rightmost \\n     * compare the sum of values and move the pointer accordingly\\n     */\\n    for (int i = 0, j = numsSize - 1; i < j; ) {\\n\\n        if (nums[i] + nums[j] > k) {\\n            j--;\\n        }\\n        else if (nums[i] + nums[j] < k) {\\n            i++;\\n        }\\n        else {\\n            ans++;\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    /*\\n     * Return the maximum number of operations you can perform \\n     * on the array.\\n     */\\n\\n    return ans;\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766127,
                "title": "js-ts-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction maxOperations(nums: number[], k: number): number {\\n    const mapping = {}\\n    let count = 0\\n    for (let i = 0; i < nums.length; i++) {\\n        const target = k - nums[i]\\n        if (mapping[target]) {\\n            count++\\n            mapping[target] = mapping[target] - 1\\n        }\\n        else {\\n            mapping[nums[i]] = (mapping[nums[i]] ?? 0) + 1\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxOperations(nums: number[], k: number): number {\\n    const mapping = {}\\n    let count = 0\\n    for (let i = 0; i < nums.length; i++) {\\n        const target = k - nums[i]\\n        if (mapping[target]) {\\n            count++\\n            mapping[target] = mapping[target] - 1\\n        }\\n        else {\\n            mapping[nums[i]] = (mapping[nums[i]] ?? 0) + 1\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754735,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\n        int i=0;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(i<nums.length && j>=0 && j>i){\\n            int sum=nums[i]+nums[j];\\n            if(sum==k){\\n                count++;\\n                i++;\\n                j--;\\n            }\\n\\n            else if(sum>k){\\n                j--;\\n            }\\n\\n            else if(sum<k){\\n                i++;\\n            }\\n        }\\n\\n        i++;\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\n        int i=0;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(i<nums.length && j>=0 && j>i){\\n            int sum=nums[i]+nums[j];\\n            if(sum==k){\\n                count++;\\n                i++;\\n                j--;\\n            }\\n\\n            else if(sum>k){\\n                j--;\\n            }\\n\\n            else if(sum<k){\\n                i++;\\n            }\\n        }\\n\\n        i++;\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710195,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar maxOperations = function (nums, k) {\\n    nums.sort((a,b)=>a-b)\\n    let res=0\\n    let left=0\\n    let right =nums.length-1\\n    while(left<right){\\n        let sum =nums[left]+nums[right]\\n        if(sum<k){\\n            left++\\n        }else if(sum>k){\\n            right--\\n        }else{\\n            res++\\n            left++\\n            right--\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxOperations = function (nums, k) {\\n    nums.sort((a,b)=>a-b)\\n    let res=0\\n    let left=0\\n    let right =nums.length-1\\n    while(left<right){\\n        let sum =nums[left]+nums[right]\\n        if(sum<k){\\n            left++\\n        }else if(sum>k){\\n            right--\\n        }else{\\n            res++\\n            left++\\n            right--\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3693286,
                "title": "javascript-easy-to-understand-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxOperations = function(nums, k) {\\n    nums.sort((a, b) => a - b);\\n\\n    let ans = 0;\\n    let start = 0;\\n    let end = nums.length - 1;\\n\\n    while (start < end) {\\n        if (nums[start] + nums[end] === k) {\\n            ans++;\\n            start++;\\n            end--;\\n            continue;\\n        } \\n        nums[start] + nums[end] > k ? end-- : start++;\\n    }\\n    return ans;;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxOperations = function(nums, k) {\\n    nums.sort((a, b) => a - b);\\n\\n    let ans = 0;\\n    let start = 0;\\n    let end = nums.length - 1;\\n\\n    while (start < end) {\\n        if (nums[start] + nums[end] === k) {\\n            ans++;\\n            start++;\\n            end--;\\n            continue;\\n        } \\n        nums[start] + nums[end] > k ? end-- : start++;\\n    }\\n    return ans;;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605920,
                "title": "easy-solution-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First we sort given an array.\\n2. declare two variable lo (low initially 0) and hi (high initially n - 1)\\n3. declare cnt var with value 0\\n4. loop though until lo<hi\\n5. check if nums[lo]+nums[hi]==k then we increment cnt and lo++, hi--\\n6. if sum of nums[lo]+nums[hi] is greater than k then we decrease right ptr\\n7. else increase left ptr\\n8. finally return cnt\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int lo=0,hi=n-1;\\n\\n        int cnt=0;\\n        while(lo<hi) {\\n            int sum=nums[lo]+nums[hi];\\n            if ( sum== k) {\\n                cnt++;\\n                lo++;\\n                hi--;\\n            } \\n            else if (sum>k) {\\n                hi--;\\n            }\\n            else {\\n                lo++;\\n            }\\n        }        \\n\\n        return cnt;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int lo=0,hi=n-1;\\n\\n        int cnt=0;\\n        while(lo<hi) {\\n            int sum=nums[lo]+nums[hi];\\n            if ( sum== k) {\\n                cnt++;\\n                lo++;\\n                hi--;\\n            } \\n            else if (sum>k) {\\n                hi--;\\n            }\\n            else {\\n                lo++;\\n            }\\n        }        \\n\\n        return cnt;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573167,
                "title": "ruby-solution-using-a-hash",
                "content": "# Approach\\nUsing a hash map we\\'ll store a the numbers in the nums array and the frequency that we encounter them. In the loop will be looking for `k - n` where `n` is the current number we\\'re looking in the loop, by performing the substraction we get the number that will be needed for `n` to become `k`, if this number is present we\\'ll decrease the frequency since we \"used it\"; if we didn\\'t find this number we\\'ll add `n` and/or +1 to is frequency to be used later on with different `n`.\\n\\nSince the problem ask us the number of operations we need can make to get `k`, everytime we encounter a number that added to `n` gets us `k` we add +1 to our ops counter.   \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Integer}\\ndef max_operations(nums, k)\\n  nums_map = Hash.new 0 # Makes the default value 0 instead of nil\\n  ops = 0\\n\\n  nums.each do |n|\\n    unless n >= k\\n      if nums_map[k - n] > 0\\n        nums_map[k - n] -= 1\\n        ops += 1\\n      else\\n        nums_map[n] += 1\\n      end\\n    end\\n  end\\n\\n  ops\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Hash Table"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Integer}\\ndef max_operations(nums, k)\\n  nums_map = Hash.new 0 # Makes the default value 0 instead of nil\\n  ops = 0\\n\\n  nums.each do |n|\\n    unless n >= k\\n      if nums_map[k - n] > 0\\n        nums_map[k - n] -= 1\\n        ops += 1\\n      else\\n        nums_map[n] += 1\\n      end\\n    end\\n  end\\n\\n  ops\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3566280,
                "title": "java-simple-and-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = 0; int r = nums.length - 1;\\n        int res = 0;\\n\\n        while(l < r){\\n            if(nums[l] + nums[r] == k){\\n                l += 1; r -= 1;\\n                res += 1;\\n            }\\n            else if(nums[l] + nums[r] < k) l += 1; \\n            else r-= 1;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = 0; int r = nums.length - 1;\\n        int res = 0;\\n\\n        while(l < r){\\n            if(nums[l] + nums[r] == k){\\n                l += 1; r -= 1;\\n                res += 1;\\n            }\\n            else if(nums[l] + nums[r] < k) l += 1; \\n            else r-= 1;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564009,
                "title": "rust-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n\\n    pub fn max_operations(nums: Vec<i32>, k: i32) -> i32 {\\n\\n        //Remove elems > k\\n        let mut cleaned = nums.into_iter().filter(|val| val < &k).collect::<Vec<i32>>();\\n\\n        // Return 0 if list is now empty\\n        if cleaned.len() == 0 {return 0}\\n\\n        // Sort from lowest to highest value\\n        // unstable ignores ordering of equal elems (ok in this case)\\n        cleaned.sort_unstable();\\n        \\n        let mut count: i32 = 0;\\n\\n        // Start with smallest number\\n        let mut left_ptr: usize = 0;\\n        // And largest number\\n        let mut right_ptr: usize = cleaned.len() -1;\\n\\n        //So we have exhausted options when ptrs equal each other\\n        while left_ptr < right_ptr {\\n\\n            let left_val = cleaned[left_ptr];\\n            let right_val = cleaned[right_ptr];\\n            let sum = left_val + right_val;\\n\\n            // if equal add to operation count \\n            // and move both pointers (remove pair from list)\\n            if sum == k {\\n                count += 1;\\n                left_ptr +=1;\\n                right_ptr -= 1;\\n                \\n            }\\n            // if sum is greater than k max next sum smaller\\n            else if sum > k {\\n                right_ptr -= 1;\\n            }\\n            // if sum is less than k max next sum greater\\n            else {\\n                left_ptr +=1;\\n\\n            }\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n\\n    pub fn max_operations(nums: Vec<i32>, k: i32) -> i32 {\\n\\n        //Remove elems > k\\n        let mut cleaned = nums.into_iter().filter(|val| val < &k).collect::<Vec<i32>>();\\n\\n        // Return 0 if list is now empty\\n        if cleaned.len() == 0 {return 0}\\n\\n        // Sort from lowest to highest value\\n        // unstable ignores ordering of equal elems (ok in this case)\\n        cleaned.sort_unstable();\\n        \\n        let mut count: i32 = 0;\\n\\n        // Start with smallest number\\n        let mut left_ptr: usize = 0;\\n        // And largest number\\n        let mut right_ptr: usize = cleaned.len() -1;\\n\\n        //So we have exhausted options when ptrs equal each other\\n        while left_ptr < right_ptr {\\n\\n            let left_val = cleaned[left_ptr];\\n            let right_val = cleaned[right_ptr];\\n            let sum = left_val + right_val;\\n\\n            // if equal add to operation count \\n            // and move both pointers (remove pair from list)\\n            if sum == k {\\n                count += 1;\\n                left_ptr +=1;\\n                right_ptr -= 1;\\n                \\n            }\\n            // if sum is greater than k max next sum smaller\\n            else if sum > k {\\n                right_ptr -= 1;\\n            }\\n            // if sum is less than k max next sum greater\\n            else {\\n                left_ptr +=1;\\n\\n            }\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558417,
                "title": "c-simplest-solution-using-two-pointers",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n\\n        sort(nums.begin(), nums.end());\\n\\n        int ans = 0;\\n\\n        int s = 0;\\n        int e = nums.size() - 1;\\n\\n        while(s < e) {\\n            int temp = nums[s] + nums[e];\\n            if(temp == k) {\\n                ans++;\\n                s++;\\n                e--;\\n            }\\n            else if(temp > k) \\n                e--;\\n            else \\n                s++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n\\n        sort(nums.begin(), nums.end());\\n\\n        int ans = 0;\\n\\n        int s = 0;\\n        int e = nums.size() - 1;\\n\\n        while(s < e) {\\n            int temp = nums[s] + nums[e];\\n            if(temp == k) {\\n                ans++;\\n                s++;\\n                e--;\\n            }\\n            else if(temp > k) \\n                e--;\\n            else \\n                s++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556147,
                "title": "2-pointer-approach-java-beats-90-93",
                "content": "# \\nSorting --> then using 2 pointer approach \\ninitializing i=start and j=end\\n\\n# Complexity\\n- Time complexity:\\n\\nSorting-> n log(n) \\n\\nLogic 2 pointer-> n/2\\n\\nOverall -> nlog(n)+n/2\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\n        int i=0;\\n        int j=nums.length-1;\\n        int res=0;\\n\\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j] < k)\\n            {\\n                i++;\\n            }\\n            else if(nums[i]+nums[j] >k)\\n            {\\n                j--;\\n            }\\n            else {\\n                res++;\\n                i++;\\n                j--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\n        int i=0;\\n        int j=nums.length-1;\\n        int res=0;\\n\\n        while(i<j)\\n        {\\n            if(nums[i]+nums[j] < k)\\n            {\\n                i++;\\n            }\\n            else if(nums[i]+nums[j] >k)\\n            {\\n                j--;\\n            }\\n            else {\\n                res++;\\n                i++;\\n                j--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505393,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int ans = 0;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        for(int num : nums){\\n            int req = k - num;\\n            if(hm.containsKey(req)){\\n                ans++;\\n                hm.put(req, hm.get(req)-1);\\n                if(hm.get(req)==0)\\n                    hm.remove(req);\\n                continue;\\n            }\\n            hm.put(num, hm.getOrDefault(num,0)+1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n/*\\n\\n[1,2,3,4]\\n5\\n[3,1,3,4,3]\\n6\\n\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int ans = 0;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        for(int num : nums){\\n            int req = k - num;\\n            if(hm.containsKey(req)){\\n                ans++;\\n                hm.put(req, hm.get(req)-1);\\n                if(hm.get(req)==0)\\n                    hm.remove(req);\\n                continue;\\n            }\\n            hm.put(num, hm.getOrDefault(num,0)+1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n/*\\n\\n[1,2,3,4]\\n5\\n[3,1,3,4,3]\\n6\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483601,
                "title": "javascript-easy-solution-using-hashmap-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxOperations = function(nums, k) {\\n    let map = new Map(), pairs = 0;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(map.has(nums[i])) {\\n            map.set(nums[i], map.get(nums[i])+1);\\n        }\\n        else {\\n            map.set(nums[i],1);\\n        }\\n    }\\n    for(let i = 0; i < nums.length; i++) {\\n        if(map.get(nums[i])) {\\n            map.set(nums[i], map.get(nums[i])-1);\\n            if(map.get(k-nums[i])) {\\n                pairs++;\\n                map.set(k-nums[i], map.get(k-nums[i])-1);\\n            }\\n            else {\\n                map.set(nums[i], map.get(nums[i])+1);\\n            }\\n        }\\n    }\\n    return pairs;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxOperations = function(nums, k) {\\n    let map = new Map(), pairs = 0;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(map.has(nums[i])) {\\n            map.set(nums[i], map.get(nums[i])+1);\\n        }\\n        else {\\n            map.set(nums[i],1);\\n        }\\n    }\\n    for(let i = 0; i < nums.length; i++) {\\n        if(map.get(nums[i])) {\\n            map.set(nums[i], map.get(nums[i])-1);\\n            if(map.get(k-nums[i])) {\\n                pairs++;\\n                map.set(k-nums[i], map.get(k-nums[i])-1);\\n            }\\n            else {\\n                map.set(nums[i], map.get(nums[i])+1);\\n            }\\n        }\\n    }\\n    return pairs;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3094411,
                "title": "solution-for-max-operation",
                "content": "\\n\\n# Code\\n```\\nfunction maxOperations(nums: number[], k: number): number {\\n    if(nums.length ==1) return 0\\n    nums.sort((a,b) => a-b)\\n    let left = 0, right = nums.length-1\\n    let result = 0\\n    while(left < right) {\\n        const sum = nums[left] + nums[right]\\n        if(sum < k) left++\\n        else if(sum > k) right--\\n        else {\\n            result++\\n            left++\\n            right--\\n        }\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxOperations(nums: number[], k: number): number {\\n    if(nums.length ==1) return 0\\n    nums.sort((a,b) => a-b)\\n    let left = 0, right = nums.length-1\\n    let result = 0\\n    while(left < right) {\\n        const sum = nums[left] + nums[right]\\n        if(sum < k) left++\\n        else if(sum > k) right--\\n        else {\\n            result++\\n            left++\\n            right--\\n        }\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967802,
                "title": "min-heap-and-max-heap-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        priority_queue<int> max_heap;\\n        priority_queue<int, vector<int>, greater<int>> min_heap;\\n        for(auto it:nums)\\n        {\\n            max_heap.push(it);\\n            min_heap.push(it);\\n        }\\n        int cnt = 0;\\n        while(!max_heap.empty() && !min_heap.empty())\\n        {\\n            int sum = max_heap.top() + min_heap.top();\\n            if(sum == k)\\n            {\\n                cnt++;\\n                max_heap.pop();\\n                min_heap.pop();\\n            }\\n            else if(sum > k)\\n            {\\n                max_heap.pop();\\n            }\\n            else\\n            {\\n                min_heap.pop();\\n            }\\n        }\\n        return cnt/2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        priority_queue<int> max_heap;\\n        priority_queue<int, vector<int>, greater<int>> min_heap;\\n        for(auto it:nums)\\n        {\\n            max_heap.push(it);\\n            min_heap.push(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2726724,
                "title": "3-approaches-clean-c-code-with-examples-and-thought-process",
                "content": "Let me get the task straight, all we need to find is that how many unique pairs that sum to K exist in the array. Brute force approach will be very simple, just generate all unique pairs and count pairs with `sum = k`. The time complexity will be `O(N^2)`, which will not get accepted(*Life is all about not getting what you want*).\\n\\nHow Should I optimise this? What if I fix first element of the pair? If I fix one element than all we need to know if array contains element with value `K - first_chosen_value` or not, if exist then `count_of_pairs++`. Now let me tell your two approaches to achieve this, \\n\\n\\n## Approach 1 - Hashmap\\nHashmap will let us know if value `K - first_chosen_value` exist in the array or not in `log(N) time` (*on an average, don\\'t take it seriously it can be injurious to mental health.*). After every found pair make sure you update the map, because we want unique pairs. Let\\'s code this shit!\\n```\\nTime Complexity: T(N) = O(N * log(N))\\nSpace Complexity: S(N) = O(N)\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for(auto num: nums) mp[num]++;             // insert all values in the map\\n        \\n        int res = 0;\\n        for(auto num: nums)                        // iterate over nums again, this time calculate pairs\\n        {\\n            int rem = k - num;\\n            if(rem == num) {                       // if K is equal to the half of current element, then total pairs become (count_of_current_element / 2) \\n                res += mp[num] / 2;\\n                mp[num] = (mp[num] & 1);           // if count is odd then 1 will be left, u can put it zero as well, it doesn\\'t matter\\n            }\\n            else if(mp[num] and mp[rem]) {\\n                int canTake = min(mp[num], mp[rem]);     // otherwise simple seaching and map update for (K - first_element_of_pair)\\n                res += canTake;\\n                mp[num] -= canTake;\\n                mp[rem] -= canTake;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n\\n## Approach 2 - Multiset\\nThis approach costed me 1 Wrong submission and 1 TLE. But it was worth time. Here is English what shit I did in code\\n\\n1. We will create two multisets(*bcoz duplicates will be there*) one is `upper`, one is `lower`.\\n2. `Lower` will have `elements <= K / 2` and `Upper` will have `element > K / 2`.\\n3. We iterate over the array and insert each element of array in multiset accordingly.\\n4. Again we iterate over `lower` multiset and search for `(K - first_element_of_pair)` in `upper` multiset, if we found it then we will erase it from the upper multiset. Remember to use the `lower_bound` to search the element in `upper` multiset and then do `erase`, otherwise it will delete all the occurences. Let\\'s code this shit!\\n\\n```\\nTime Complexity: T(N) = O(N * log(N))\\nSpace Complexity: S(N) = O(N)\\n\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        multiset<int> lower, upper;\\n        int mid = k / 2, cnt_mid = 0;\\n        \\n        for(auto num: nums)         // insert into the respective multsets\\n        {\\n            if((2 * num) == k)\\n                cnt_mid++;\\n            else if(num < mid or ((k & 1) and num <= mid))    // Guess why this shit has been done, U will enter in a different domain of thoughts or run your code on this test case arr = [1, 2, 3, 4], K = 5.\\n                lower.insert(num);\\n            else  \\n                upper.insert(num);\\n        }\\n        \\n        int res = cnt_mid / 2;\\n        for(auto a: lower)                  // if found in upper then erase, remember to found by lower_bound\\n        {\\n            if(upper.find(k - a) != upper.end()) {\\n                res++;\\n                upper.erase(upper.lower_bound(k-a));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n## Approach 3 - Sortings and Two Pointers\\nFor this approach you can read any of the other articles in discuss section, I don\\'t think I need to repeat what is already there with insanely nice explanation.\\n\\n\\n#### Do Upvote or else\\n![image](https://assets.leetcode.com/users/images/977f69fc-f193-449b-b6f1-7247c49c8e0c_1666291546.2541003.gif)\\n",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nTime Complexity: T(N) = O(N * log(N))\\nSpace Complexity: S(N) = O(N)\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for(auto num: nums) mp[num]++;             // insert all values in the map\\n        \\n        int res = 0;\\n        for(auto num: nums)                        // iterate over nums again, this time calculate pairs\\n        {\\n            int rem = k - num;\\n            if(rem == num) {                       // if K is equal to the half of current element, then total pairs become (count_of_current_element / 2) \\n                res += mp[num] / 2;\\n                mp[num] = (mp[num] & 1);           // if count is odd then 1 will be left, u can put it zero as well, it doesn\\'t matter\\n            }\\n            else if(mp[num] and mp[rem]) {\\n                int canTake = min(mp[num], mp[rem]);     // otherwise simple seaching and map update for (K - first_element_of_pair)\\n                res += canTake;\\n                mp[num] -= canTake;\\n                mp[rem] -= canTake;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nTime Complexity: T(N) = O(N * log(N))\\nSpace Complexity: S(N) = O(N)\\n\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        multiset<int> lower, upper;\\n        int mid = k / 2, cnt_mid = 0;\\n        \\n        for(auto num: nums)         // insert into the respective multsets\\n        {\\n            if((2 * num) == k)\\n                cnt_mid++;\\n            else if(num < mid or ((k & 1) and num <= mid))    // Guess why this shit has been done, U will enter in a different domain of thoughts or run your code on this test case arr = [1, 2, 3, 4], K = 5.\\n                lower.insert(num);\\n            else  \\n                upper.insert(num);\\n        }\\n        \\n        int res = cnt_mid / 2;\\n        for(auto a: lower)                  // if found in upper then erase, remember to found by lower_bound\\n        {\\n            if(upper.find(k - a) != upper.end()) {\\n                res++;\\n                upper.erase(upper.lower_bound(k-a));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512990,
                "title": "c-map",
                "content": "class Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n         map<int,int> mapp;\\n        int count = 0;\\n        \\n        for(int i = 0; i <nums.size() ;i++){\\n            \\n            int x=k-nums[i];\\n            if(mapp[x]<1){\\n                mapp[nums[i]]++;\\n            }\\n            else{\\n                count++;\\n                mapp[x]--;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n         map<int,int> mapp;\\n        int count = 0;\\n        \\n        for(int i = 0; i <nums.size() ;i++){\\n            \\n            int x=k-nums[i];\\n            if(mapp[x]<1){\\n                mapp[nums[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2453477,
                "title": "two-pointer-solution",
                "content": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        int start=0;\\n        int end= nums.length-1; \\n        int count=0;\\n        while(start<end)\\n        {\\n            if(nums[start]+nums[end]==k)\\n            {\\n                start++;\\n                end--;\\n                count++;\\n            }\\n            else if(nums[start]+nums[end]<k)\\n            {\\n                start++;\\n            }\\n            else if(nums[start]+nums[end]>k)\\n            {\\n                end--;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        int start=0;\\n        int end= nums.length-1; \\n        int count=0;\\n        while(start<end)\\n        {\\n            if(nums[start]+nums[end]==k)\\n            {\\n                start++;\\n                end--;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2170508,
                "title": "easy-java-solution-runtime-78ms",
                "content": "Step 1: check if k-nums[i] is there in hashmap or not :\\nStep 2: If it exists then just update counter one time and decrement value by one of that key in hashmap.\\nStep 3: If it doesn\\'t exist just add that key and increment the value\\n```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(k-nums[i])&&map.get(k-nums[i])>0){\\n                count++;\\n                map.put(k-nums[i],map.get(k-nums[i])-1);\\n            }else{\\n                map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(k-nums[i])&&map.get(k-nums[i])>0){\\n                count++;\\n                map.put(k-nums[i],map.get(k-nums[i])-1);\\n            }else{\\n                map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165075,
                "title": "easy-solution-c-in-o-n-time-complexity",
                "content": "\\tint maxOperations(vector<int>& nums, int k) {\\n\\t\\t\\tunordered_map<int,int> mp;\\n\\t\\t\\tint count = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            int val = k-nums[i];\\n            if(mp.find(val)!= mp.end() && mp[val] > 0){\\n                count++;\\n                mp[val]--;\\n            }\\n            else\\n            mp[nums[i]]++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint maxOperations(vector<int>& nums, int k) {\\n\\t\\t\\tunordered_map<int,int> mp;\\n\\t\\t\\tint count = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            int val = k-nums[i];\\n            if(mp.find(val)!= mp.end() && mp[val] > 0){\\n                count++;\\n                mp[val]--;\\n            }\\n            else\\n            mp[nums[i]]++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2157978,
                "title": "python-easy-hashtable-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef maxOperations(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\thash = {}\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif k - num in hash:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\thash[k - num] -= 1\\n\\n\\t\\t\\t\\t\\tif hash[k - num] == 0:\\n\\t\\t\\t\\t\\t\\thash.pop(k-num)\\n\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tif num in hash:\\n\\t\\t\\t\\t\\thash[num] += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thash[num] = 1\\n\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "class Solution:\\n\\t\\tdef maxOperations(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\thash = {}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1986623,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1566217,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1930898,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 2000597,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1948690,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1829448,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 2036380,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1966769,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 2042386,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 2028637,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1986623,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1566217,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1930898,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 2000597,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1948690,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1829448,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 2036380,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 1966769,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 2042386,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            },
            {
                "id": 2028637,
                "content": [
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/max-number-of-k-sum-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Hashmap - Two Pass\n\n  \n**Approach 3:** Using Hashmap - Single Pass\n\n  \n**Approach 4:** Two Pointer Approach Using Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "leonardshen",
                        "content": "When I run my code, the \\'Expected\\' is blank. Is there a bug or something?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is a useful follow up to the Two Sum question except that the nums array is 10x bigger so brute force is not an option."
                    },
                    {
                        "username": "cjeong880",
                        "content": "Why is there an empty test case?"
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "why people use Arrays.sort(), doesn\\'t it take O(n^2) which gives time limit exceed??\\nI solved it with O(n) and it runs on 72ms!"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "the traversal would take O(n) but altering hash table might take some time if the n is more significant .I think this is the reason that sorting is taking less time than hash table here  and also the  Arrays.sort() takes O(nlog(n))"
                    },
                    {
                        "username": "AleksandrT",
                        "content": ">why people use Arrays.sort(), doesn't it take O(n^2)\n\nIt's used for two window approach and it should take O(nlogn)"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "On submitting, It passes 51/51 testcases but gives a time limit exceeded error showing blank input testcase. What can be done? Any help is appreciated \n[ScreenShot](https://raw.githubusercontent.com/prithvi2k2/assets/main/image.png)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "my code got result 3, but in my local visual studio got correct answer 11. same code!\\n\\n\\n `\\ncode:\\n\\n\\nint maxOperations(vector<int>& nums, int k) {\\n    unordered_map<int, int> umap;\\n    for (int n : nums) { if (n < k) umap[n]++; }\\n\\n    int result = 0;\\n    for (auto up : umap)\\n    {\\n        if (up.second <= 0 || up.first >= k) continue;\\n        if (k % 2 == 0 && up.first == k / 2)\\n        {\\n            result += (up.second / 2);\\n            umap[up.first] -= ((up.second / 2) / 2);\\n            continue;\\n        }\\n        int r = k - up.first;\\n        int cm = min(up.second, umap[r]);\\n        result += cm;\\n        umap[up.first] -= cm;\\n        umap[r] -= cm;\\n    }\\n    return result;\\n}\\n\\n`"
                    },
                    {
                        "username": "smit_patel6602",
                        "content": "beta bada hoja pehle, baap ko sikha riya hai"
                    },
                    {
                        "username": "Rivo11",
                        "content": "This is an easy question anyway ... smiliar to two sum using 2 pointer technique."
                    },
                    {
                        "username": "solve_adorer",
                        "content": "its an easy question"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Operations to Make Array Continuous",
        "question_content": "<p>You are given an integer array <code>nums</code>. In one operation, you can replace <strong>any</strong> element in <code>nums</code> with <strong>any</strong> integer.</p>\n\n<p><code>nums</code> is considered <strong>continuous</strong> if both of the following conditions are fulfilled:</p>\n\n<ul>\n\t<li>All elements in <code>nums</code> are <strong>unique</strong>.</li>\n\t<li>The difference between the <strong>maximum</strong> element and the <strong>minimum</strong> element in <code>nums</code> equals <code>nums.length - 1</code>.</li>\n</ul>\n\n<p>For example, <code>nums = [4, 2, 5, 3]</code> is <strong>continuous</strong>, but <code>nums = [1, 2, 3, 5, 6]</code> is <strong>not continuous</strong>.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of operations to make </em><code>nums</code><em> </em><strong><em>continuous</em></strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,2,5,3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>&nbsp;nums is already continuous.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,5,6]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>&nbsp;One possible solution is to change the last element to 4.\nThe resulting array is [1,2,3,5,4], which is continuous.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,10,100,1000]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>&nbsp;One possible solution is to:\n- Change the second element to 2.\n- Change the third element to 3.\n- Change the fourth element to 4.\nThe resulting array is [1,2,3,4], which is continuous.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1470853,
                "title": "python-binary-search-clean-concise",
                "content": "**Idea**\\n- Store the original length, `n = len(nums)`.\\n- Firstly, **make** elements in `nums` **unique** and **sort** `nums` array.\\n- Try elements in `nums` as the start of the continuous array, let say `start`.\\n\\t- Elements in the continuous array must in range `[start, end]`, where `end = start + n - 1`.\\n\\t- Binary search to find the index of the right insert position of `end` in `nums`, let say `idx`.\\n\\t- Then we can calculate the number of unique numbers in range `[start, end]` by `uniqueLen = n - idx`.\\n\\t- The cost to make coninuous array is `cost = n - uniqueLen`.\\n\\t- We update the best answer so far, `ans = min(ans, cost)`\\n- Then return the best `ans` we have.\\n\\n```python\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))  # Make `nums` as unique numbers and sort `nums`.\\n\\n        ans = n\\n        for i, start in enumerate(nums):\\n            end = start + n - 1  # We expect elements of continuous array must in range [start..end]\\n            idx = bisect_right(nums, end)  # Find right insert position\\n            uniqueLen = idx - i\\n            ans = min(ans, n - uniqueLen)\\n        return ans\\n```\\n\\n**Complexity**\\n- Time: `O(NlogN)`\\n- Space: `O(N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))  # Make `nums` as unique numbers and sort `nums`.\\n\\n        ans = n\\n        for i, start in enumerate(nums):\\n            end = start + n - 1  # We expect elements of continuous array must in range [start..end]\\n            idx = bisect_right(nums, end)  # Find right insert position\\n            uniqueLen = idx - i\\n            ans = min(ans, n - uniqueLen)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470857,
                "title": "c-sliding-window",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Sliding Window\\n\\nCheck out \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\" which can help you solve all sliding window problems.\\n\\n**Intuition**: Sort and only keep unique elements. The problem is the same as \"get the length of the longest subarray whose difference between min and max elements is `N - 1`\".\\n\\n**Algorithm**:\\n\\nThe brute force way is to pick each `A[i]` as the start of the subarray and count the number of elements that are `<= A[i] + N - 1`, which takes `O(N^2)` time.\\n\\nSince the array is already sorted, we can use sliding window so that we only traverse the entire array once.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int N = A.size(), ans = N, j = 0;\\n        sort(begin(A), end(A));\\n        A.erase(unique(begin(A), end(A)), end(A)); // only keep unique elements\\n        int M = A.size();\\n        for (int i = 0; i < M; ++i) {\\n            while (j < M && A[j] < A[i] + N) ++j; // let `j` point to the first element that is out of range -- `>= A[i] + N`.\\n            ans = min(ans, N - j + i); // The length of this subarray is `j - i`. We need to replace `N - j + i` elements to make it continuous.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nUse Shrinkable Sliding Window Template: \\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int N = A.size(), i = 0, j = 0, ans = 0;\\n        sort(begin(A), end(A));\\n        A.erase(unique(begin(A), end(A)), end(A)); // only keep unique elements\\n        for (int M = A.size(); j < M; ++j) {\\n            while (A[i] + N <= A[j]) ++i; // let `i` point to the first element that is in range -- `A[i] + N > A[j]`\\n            ans = max(ans, j - i + 1);\\n        }\\n        return N - ans;\\n    }\\n};\\n```\\n\\nUse Non-shrinkable Sliding Window Template:\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int N = A.size(), i = 0, j = 0;\\n        sort(begin(A), end(A));\\n        A.erase(unique(begin(A), end(A)), end(A)); // only keep unique elements\\n        for (int M = A.size(); j < M; ++j) {\\n            if (A[i] + N <= A[j]) ++i;\\n        }\\n        return N - j + i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int N = A.size(), ans = N, j = 0;\\n        sort(begin(A), end(A));\\n        A.erase(unique(begin(A), end(A)), end(A)); // only keep unique elements\\n        int M = A.size();\\n        for (int i = 0; i < M; ++i) {\\n            while (j < M && A[j] < A[i] + N) ++j; // let `j` point to the first element that is out of range -- `>= A[i] + N`.\\n            ans = min(ans, N - j + i); // The length of this subarray is `j - i`. We need to replace `N - j + i` elements to make it continuous.\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int N = A.size(), i = 0, j = 0, ans = 0;\\n        sort(begin(A), end(A));\\n        A.erase(unique(begin(A), end(A)), end(A)); // only keep unique elements\\n        for (int M = A.size(); j < M; ++j) {\\n            while (A[i] + N <= A[j]) ++i; // let `i` point to the first element that is in range -- `A[i] + N > A[j]`\\n            ans = max(ans, j - i + 1);\\n        }\\n        return N - ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int N = A.size(), i = 0, j = 0;\\n        sort(begin(A), end(A));\\n        A.erase(unique(begin(A), end(A)), end(A)); // only keep unique elements\\n        for (int M = A.size(); j < M; ++j) {\\n            if (A[i] + N <= A[j]) ++i;\\n        }\\n        return N - j + i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470900,
                "title": "python-explanation-with-pictures-binary-search",
                "content": "For any valid result, we can focus on the minimum number ```a``` in that list, since there are ```n``` unique numbers, all the numbers are: ```a, a + 1, a + 2, ... , a + n - 1```. Traverse the list ```A```, for the current number a, if the result list has ```a``` as the smallest number, we need to find out how many unique numbers in the range ```[a, a + n - 1]``` (inclusively), are in ```A```.\\n\\nTake the sorted list below as an example, if we pick ```1``` as the smallest number, we expect to have the list ```[1, 2, 3, ... 8]``` as the sorted result.\\n![image](https://assets.leetcode.com/users/images/e44204cc-d46e-44ff-baa7-0848e22591af_1631980896.1023772.png)\\n\\nUse binary search to find the right boundary of the range. Apparently all the numbers to the right of the boundary will be discarded.\\n\\n![image](https://assets.leetcode.com/users/images/46268c9a-38f8-4916-a0ad-5fe656ad2197_1631980900.3043478.png)\\nThe next task is find out how many **unique** numbers within this range?\\nWe use prefix number of unique numbers, start from ```index = 0``` and count how many unique number in the list **so far**. Like how we bulid pre sum list of an array.\\n![image](https://assets.leetcode.com/users/images/a7ab9975-6c80-4095-b73a-62062d007e38_1631980903.6625006.png)\\nTherefore, we find ```3``` unique numbers in this range, meaning we need to change the rest ```8 - 3 = 5``` numbers.\\n![image](https://assets.leetcode.com/users/images/26bd83c6-5e67-43e5-a7ae-c7473da9cb86_1631980906.9087243.png)\\n\\nIn the second example, suppose we let ```3``` to be the smallest number is the final result, thus we expect to have ```[3, 4, 5,... 10]``` as the sorted final result.\\n![image](https://assets.leetcode.com/users/images/8833510b-04ef-4e3a-a408-b4d8ac1c6e28_1631980910.7367795.png)\\nUse binary search to find the right boundary. Notice in this case we shall discard all the numbers smaller than ```3``` as well since ```3``` is the smallest number.\\n![image](https://assets.leetcode.com/users/images/b8e02735-a483-42c7-98e9-05167109039d_1631980913.8592906.png)\\n\\n\\n```\\ndef minOperations(self, A: List[int]) -> int:\\n        A.sort()\\n        n = len(A)\\n        ans = n - 1\\n        uniq, cur = [1], 1\\n        \\n        for i in range(1, n):\\n            if A[i] != A[i - 1]: \\n                cur += 1\\n            uniq.append(cur)\\n        \\n        for i in range(n):\\n            a = A[i]\\n            idx = bisect.bisect_right(A, a + n - 1)\\n            cur_uniq = max(0, uniq[idx - 1] - uniq[i]) + 1\\n            ans = min(ans, n - cur_uniq)\\n\\n        return ans\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```a```\n```n```\n```a, a + 1, a + 2, ... , a + n - 1```\n```A```\n```a```\n```[a, a + n - 1]```\n```A```\n```1```\n```[1, 2, 3, ... 8]```\n```index = 0```\n```3```\n```8 - 3 = 5```\n```3```\n```[3, 4, 5,... 10]```\n```3```\n```3```\n```\\ndef minOperations(self, A: List[int]) -> int:\\n        A.sort()\\n        n = len(A)\\n        ans = n - 1\\n        uniq, cur = [1], 1\\n        \\n        for i in range(1, n):\\n            if A[i] != A[i - 1]: \\n                cur += 1\\n            uniq.append(cur)\\n        \\n        for i in range(n):\\n            a = A[i]\\n            idx = bisect.bisect_right(A, a + n - 1)\\n            cur_uniq = max(0, uniq[idx - 1] - uniq[i]) + 1\\n            ans = min(ans, n - cur_uniq)\\n\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1471265,
                "title": "java-sort-sliding-window",
                "content": "The intuition is to find the maximum number of distinct elements fitting in a window of length `maxNumsInWindow`, by iterating over the sorted array. \\n=> The remaining `N - maxNumsInWindow` elements need to be replaced.\\n\\n![image](https://assets.leetcode.com/users/images/f373a1c0-2e29-4261-9ce8-3e349693f1a8_1632031168.8222687.png)\\n\\nFor example, if we have `in = [1, 2, 8, 9, 11]`, the window has length 5. As we iterate, the window contains:\\n- [1]\\n- [1,2]\\n- [8] (we removed 1 and 2, because more distant than 5)\\n- [8,9]\\n- [8,9,11] (=> `maxNumsInWindow = 3` => `N - maxNumsInWindow = 2` elements to replace)\\n\\nThe code:\\n```\\n    public int minOperations(int[] nums) {\\n        Arrays.sort(nums); // Sort the array\\n        \\n        int n = nums.length;\\n        int maxNumsInWindow = 0;\\n        \\n        Deque<Integer> numsInWindow = new ArrayDeque<>();\\n        for (int num : nums) {\\n            // Advance the window\\n            while (numsInWindow.size() > 0 && num - numsInWindow.peekFirst() >= n) {\\n                numsInWindow.poll();\\n            }\\n            \\n            // Add the new number to the window (if it\\'s not a duplicate)\\n            if(numsInWindow.size() == 0 || ! numsInWindow.peekLast().equals(num)) {\\n                numsInWindow.offer(num);            \\n            }\\n            \\n            maxNumsInWindow = Math.max(maxNumsInWindow, numsInWindow.size());\\n        }\\n        \\n        return n - maxNumsInWindow;\\n    }\\n```\\n\\nComplexity\\n- Time: `O(N logN)`\\n- Space: `O(N)`\\n\\nNote that it\\'s also possible to use pointers instead of the queue.\\n\\nQuestions and discussions are welcome!",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n    public int minOperations(int[] nums) {\\n        Arrays.sort(nums); // Sort the array\\n        \\n        int n = nums.length;\\n        int maxNumsInWindow = 0;\\n        \\n        Deque<Integer> numsInWindow = new ArrayDeque<>();\\n        for (int num : nums) {\\n            // Advance the window\\n            while (numsInWindow.size() > 0 && num - numsInWindow.peekFirst() >= n) {\\n                numsInWindow.poll();\\n            }\\n            \\n            // Add the new number to the window (if it\\'s not a duplicate)\\n            if(numsInWindow.size() == 0 || ! numsInWindow.peekLast().equals(num)) {\\n                numsInWindow.offer(num);            \\n            }\\n            \\n            maxNumsInWindow = Math.max(maxNumsInWindow, numsInWindow.size());\\n        }\\n        \\n        return n - maxNumsInWindow;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470894,
                "title": "python-2-solutions-bit-and-binary-search-explained",
                "content": "Reformulate the problems: found the range `[x, x + n - 1]`, such that we have maximum number of values from `nums`.\\nThis problem can be solved with use of binary indexed tree. The idea is to put all numbers in sparse binary indexed tree and then check for each range `[num, num + n - 1]`. Notice that we only need to check ranges which starts with some number from `nums`.\\n\\n#### Complexity\\nIt is `O(n*log M)`, where `n = len(nums)` and `M = 10**9 + 10**5` is the maximum value of number + n`.\\n\\n#### Code\\n```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.sums = defaultdict(int)\\n        self.n = n\\n    \\n    def update(self, i, delta):\\n        while i < self.n + 1:\\n            self.sums[i] += delta\\n            i += i & (-i)\\n    \\n    def query(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.sums[i]\\n            i -= i & (-i)\\n        return res\\n\\n    def sum(self, i, j):\\n        return self.query(j) - self.query(i-1)\\n\\nclass Solution:\\n    def minOperations(self, nums):\\n        n, ans = len(nums), 0\\n        bit = BIT(10**9 + 10**5 + 10)\\n        for num in set(nums):\\n            bit.update(num, 1)\\n\\n        for num in nums:\\n            ans = max(ans, bit.sum(num, num + n - 1))\\n        return n - ans\\n```\\n\\n#### Solution 2\\nIn fact we do not need bit, we can use binary search idea as well. Notice that if we sort all numbers, then all we need to find is number of values in range `[x, x + n - 1]`, which can be done using binary search.\\n\\n#### Complexity\\nIt is `O(n log n)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minOperations(self, nums):\\n        sArray = sorted(set(nums))    \\n        cand = [(i, n + len(nums) - 1) for i, n in enumerate(sArray)]\\n        \\n        ans = float(\"inf\")\\n        for i, high in cand:\\n            idx = bisect.bisect_left(sArray, high)\\n            if idx >= len(sArray) or sArray[idx] != high: idx -= 1\\n            ans = min(ans, len(nums) - idx + i - 1)\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.sums = defaultdict(int)\\n        self.n = n\\n    \\n    def update(self, i, delta):\\n        while i < self.n + 1:\\n            self.sums[i] += delta\\n            i += i & (-i)\\n    \\n    def query(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.sums[i]\\n            i -= i & (-i)\\n        return res\\n\\n    def sum(self, i, j):\\n        return self.query(j) - self.query(i-1)\\n\\nclass Solution:\\n    def minOperations(self, nums):\\n        n, ans = len(nums), 0\\n        bit = BIT(10**9 + 10**5 + 10)\\n        for num in set(nums):\\n            bit.update(num, 1)\\n\\n        for num in nums:\\n            ans = max(ans, bit.sum(num, num + n - 1))\\n        return n - ans\\n```\n```python\\nclass Solution:\\n    def minOperations(self, nums):\\n        sArray = sorted(set(nums))    \\n        cand = [(i, n + len(nums) - 1) for i, n in enumerate(sArray)]\\n        \\n        ans = float(\"inf\")\\n        for i, high in cand:\\n            idx = bisect.bisect_left(sArray, high)\\n            if idx >= len(sArray) or sArray[idx] != high: idx -= 1\\n            ans = min(ans, len(nums) - idx + i - 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471112,
                "title": "c-binary-search-understandable-to-beginners-as-well",
                "content": "**Explanation**: If You are not able to understand handwriting ,look in the code, Your doubts will get cleared.\\n![image](https://assets.leetcode.com/users/images/5bb11431-4ab9-42db-b09f-1b0de18337ca_1641672048.9503567.jpeg)\\n![image](https://assets.leetcode.com/users/images/4ffc83ce-b9e2-4269-b42e-d70caff14750_1641672077.1946993.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        //set for finding unique element \\n        set<int>s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        vector<int>unique;\\n        for(int item:s){\\n            unique.push_back(item);\\n        }\\n        \\n        //sort the array(let unique.size= m  m*log(m))\\n        sort(unique.begin(),unique.end());\\n        \\n        int ans = INT_MAX;\\n        for(int i=0;i<unique.size();i++)\\n        {\\n            int start = unique[i];\\n            int last = start+n-1;\\n            \\n            //search for element just grater than last\\n            vector<int>::iterator upper=upper_bound(unique.begin(),unique.end(),last);\\n            int len = upper- unique.begin();\\n            ans = min(ans,n-(len-i));\\n            \\n        }\\n       return ans;\\n    }\\n};\\n```\\n\\nIf You have any Query feel free to ask.\\nIf you have understood then please upvote.",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        //set for finding unique element \\n        set<int>s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        vector<int>unique;\\n        for(int item:s){\\n            unique.push_back(item);\\n        }\\n        \\n        //sort the array(let unique.size= m  m*log(m))\\n        sort(unique.begin(),unique.end());\\n        \\n        int ans = INT_MAX;\\n        for(int i=0;i<unique.size();i++)\\n        {\\n            int start = unique[i];\\n            int last = start+n-1;\\n            \\n            //search for element just grater than last\\n            vector<int>::iterator upper=upper_bound(unique.begin(),unique.end(),last);\\n            int len = upper- unique.begin();\\n            ans = min(ans,n-(len-i));\\n            \\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470856,
                "title": "python-how-leetcode-and-interviewers-will-try-to-trick-you-with-test-cases",
                "content": "Me: \"I was so sloppy during today\\'s contest. I\\'m going to write a discussion post to make myself feel better.\"\\n\\nMy girlfriend: \"Whatever\"\\n\\n--- \\n\\nIn this problem, we have to form a consecutive set of numbers `[i, j]` with as many elements from the input array `nums` as possible. Let\\'s call the set `[i, j]` with the most numbers from `nums` our \"best set.\"\\n\\nHere\\'s the idea: it isn\\'t hard to imagine that the \"best set\" will include at least one number from `nums`. We don\\'t know exactly how many yet, but it will most certainly include at least one. So, what if we could check the \"best set\" starting at every index of the sorted `nums` array? If we can do it fast enough, we can consider every possible \"best set\" and just return the one that includes the most numbers in `nums`.\\n\\nThe problem is that if we\\'re checking each number in `nums`, we\\'re already at `O(N)` time complexity. That means there\\'s not much more room for work; if we try to look at subarrays, we\\'ll be at `O(N**2)` which is definitely too slow given the constraints. However, think about it this way: if we sort `nums` and we move to start our \"best set\" from the value of index `k` to `k + 1`, we know that our new `j` value from the new interval `[nums[k+1], j]` will have to be greater than the last value of `j\\'` from the previous interval `[nums[k], j\\']`. So, we can use a **two-pointer solution** and keep track of the range we have to sum to. Once we\\'re in that range, we can figure out the elements to change in `O(1)` time; we just have to change every number that is less than `k` (equal to the index of `k`, because the list is sorted) and the numbers greater than `j\\'`. Success!!\\n\\n... wait a minute, I got it wrong?\\n\\n```\\nInput: [4, 5, 8, 8, 9, 9]\\nOutput: 1\\nExpected: 2\\n```\\n\\nCrap. I forgot about duplicates, because Leetcode didn\\'t give any examples in the problem description that contained them! This is a simple, but good example of how your interviewers will sometimes trick you by hiding edge cases. **The interviewer will usually not be comprehensive when they give you test cases. It\\'s your job to be vigilant and come up with the cases yourself!**\\n\\nAnyway, there is a simple solution to this duplicates problem. Just use dynamic programming: create an array `duplicates` where `duplicates[i]` =  the number of duplicate elements on the inclusive interval `[i, j]`. Then, if you want to find the number of duplicates in subarray `nums[i\\':j\\']`, that number is just `duplicates[j\\'] - duplicates[i\\']`. Instead of just adding the numbers greater than the start and end of your consecutive series of numbers, you have to also add the number of duplicates in that range; after all, you can only use each number once.\\n\\nSolution:\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        from bisect import bisect_right\\n        \\n        nums.sort()\\n        # duplicates[i] is the count of duplicate numbers we\\'ve seen\\n        # from indices 0 to i in the nums array\\n        duplicates = [0 for _ in nums]\\n        seen = set()\\n        cur = 0\\n        for i,num in enumerate(nums):\\n            cur += num in seen\\n            seen.add(num)\\n            duplicates[i] = cur\\n        duplicates.append(duplicates[-1])\\n        \\n        ret = float(\\'inf\\')\\n        i = 0\\n        j = bisect_right(nums, nums[i] + len(nums) - 1)\\n        while i < len(nums):\\n            start = nums[i]\\n            end = start + len(nums) - 1\\n            \\n            while j < len(nums) and nums[j] <= end:\\n                j += 1\\n                \\n            # we have to change every number greater than \"end\"...\\n            right = len(nums) - j\\n            # ... plus every number less than \"start\"...\\n            left = i\\n            # ... plus every number in between [start, end] that is a duplicate.\\n            dupes = duplicates[j] - duplicates[i]\\n            \\n            ret = min(ret, left + dupes + right)\\n            i += 1\\n            \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nInput: [4, 5, 8, 8, 9, 9]\\nOutput: 1\\nExpected: 2\\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        from bisect import bisect_right\\n        \\n        nums.sort()\\n        # duplicates[i] is the count of duplicate numbers we\\'ve seen\\n        # from indices 0 to i in the nums array\\n        duplicates = [0 for _ in nums]\\n        seen = set()\\n        cur = 0\\n        for i,num in enumerate(nums):\\n            cur += num in seen\\n            seen.add(num)\\n            duplicates[i] = cur\\n        duplicates.append(duplicates[-1])\\n        \\n        ret = float(\\'inf\\')\\n        i = 0\\n        j = bisect_right(nums, nums[i] + len(nums) - 1)\\n        while i < len(nums):\\n            start = nums[i]\\n            end = start + len(nums) - 1\\n            \\n            while j < len(nums) and nums[j] <= end:\\n                j += 1\\n                \\n            # we have to change every number greater than \"end\"...\\n            right = len(nums) - j\\n            # ... plus every number less than \"start\"...\\n            left = i\\n            # ... plus every number in between [start, end] that is a duplicate.\\n            dupes = duplicates[j] - duplicates[i]\\n            \\n            ret = min(ret, left + dupes + right)\\n            i += 1\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471689,
                "title": "sliding-window",
                "content": "First, we sort and de-dup the numbers. Be sure to remember the original array\\'s size as `n`.\\n\\nThen, we use two pointers `i` and `j` to track numbers within the `[nums[i], nums[i] + n]` window. Numbers are already in their places, so we need to change the remaning  `n - (j - i)` numbers. \\n\\n**C++**\\n```cpp\\nint minOperations(vector<int>& nums) {\\n    int res = INT_MAX, n = nums.size();\\n    sort(begin(nums), end(nums));\\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\\n    for (int i = 0, j = 0; i < nums.size(); ++i)\\n        while (j < nums.size() && nums[j] < nums[i] + n)\\n            res = min(res, n - (++j - i));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minOperations(vector<int>& nums) {\\n    int res = INT_MAX, n = nums.size();\\n    sort(begin(nums), end(nums));\\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\\n    for (int i = 0, j = 0; i < nums.size(); ++i)\\n        while (j < nums.size() && nums[j] < nums[i] + n)\\n            res = min(res, n - (++j - i));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1476157,
                "title": "sort-and-sliding-window-c-o-nlogn-and-o-n",
                "content": "# INTUITION\\nElements in the continuous array will be like:``` i, i+1, i+2, ..., i + arr.size()-1```, for some integer i, because, ```max(arr) - min(arr) = i + arr.size() - 1 - i = arr.size()-1,``` which is provided.\\n\\nThus, we will maintain a sliding window of ```a.size()``` (e.g ```a[i] - a[j] + 1<= a.size()```, the difference of ```a[i]-a[j]+1``` will be our slide, which will never exceed ```a.size()```), and count the number of **unique elements** present in the slide. (e.g ```i-j+1```), Our answer will be the **maximum** of such window, because we can **change the elements of the array** excluding them (As they are already good to go), which results in ```N - max```.\\n\\n# CODE\\n```\\nint minOperations(vector<int>& arr) {\\n    int n = arr.size();\\n    if(n == 1) return 0;  //1 item is always continuous.\\n    sort(arr.begin(), arr.end());\\n\\t\\n\\tvector<int> a;   //Array to store unique elements\\n    for(int i = 0; i < n-1; i++) {\\n        while(arr[i] == arr[i+1]) i++;\\n        a.push_back(arr[i]);\\n    }\\n    if(arr.back() != a.back()) a.push_back(arr.back());\\n    \\n    int mx = 0;\\n    for(int i = 0, j = 0; i < a.size(); i++) {\\n        while(j <= i && (a[i]-a[j]+1) > n) j++;   //While our slide is invalid, keep reducing\\n        mx = max(mx, i-j+1);                          //Compare with the previous highest\\n    }\\n    return n - mx;\\n}\\n```\\n# PERFORMANCE IF YOU ARE INTERESTED\\n![image](https://assets.leetcode.com/users/images/a29f02c5-82b6-4b2a-96fe-46713fcfb72b_1632210296.0959826.png)\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "``` i, i+1, i+2, ..., i + arr.size()-1```\n```max(arr) - min(arr) = i + arr.size() - 1 - i = arr.size()-1,```\n```a.size()```\n```a[i] - a[j] + 1<= a.size()```\n```a[i]-a[j]+1```\n```a.size()```\n```i-j+1```\n```N - max```\n```\\nint minOperations(vector<int>& arr) {\\n    int n = arr.size();\\n    if(n == 1) return 0;  //1 item is always continuous.\\n    sort(arr.begin(), arr.end());\\n\\t\\n\\tvector<int> a;   //Array to store unique elements\\n    for(int i = 0; i < n-1; i++) {\\n        while(arr[i] == arr[i+1]) i++;\\n        a.push_back(arr[i]);\\n    }\\n    if(arr.back() != a.back()) a.push_back(arr.back());\\n    \\n    int mx = 0;\\n    for(int i = 0, j = 0; i < a.size(); i++) {\\n        while(j <= i && (a[i]-a[j]+1) > n) j++;   //While our slide is invalid, keep reducing\\n        mx = max(mx, i-j+1);                          //Compare with the previous highest\\n    }\\n    return n - mx;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1504914,
                "title": "easy-sliding-window-c-solution-180ms",
                "content": "Important points are added as comments.\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int k = nums.size() - 1;  // max size of sliding window is the target gap between min and max elements\\n        sort(nums.begin(), nums.end()); // sorting in O(nlogn) time so that we can remove duplicates and slide over the array\\n        int newLen = unique(nums.begin(), nums.end()) - nums.begin();  // remove adjacent duplicates with STL unique\\n        int l = 0, r = 0, fin = 1; //  initialize left and right pointers and the minimum elements in the window\\n        while (r < newLen) {  // iterate over the new unique array\\n            if (l == r)\\n                r++;  //  if the window is closed, open it ;)\\n            else if (nums[r] - nums[l] > k)\\n                l++;  //  if window becomes bigger than allowed size, shrink it\\n            else {\\n                fin = max(fin, r - l + 1);  //  if window is in allowed size, maximize the number of elements in the window\\n                r++;  // slide the right side \\n            }\\n        }  //  at this point, we have maximized the number of elements at any time inside the window\\n        return k - fin + 1;   //  return the missing elements in that window\\n    }\\n};\\n```\\n\\nIf you have any doubts or suggestions, please feel free to comment.\\nIf you find this solution useful, you know where the upvote is :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int k = nums.size() - 1;  // max size of sliding window is the target gap between min and max elements\\n        sort(nums.begin(), nums.end()); // sorting in O(nlogn) time so that we can remove duplicates and slide over the array\\n        int newLen = unique(nums.begin(), nums.end()) - nums.begin();  // remove adjacent duplicates with STL unique\\n        int l = 0, r = 0, fin = 1; //  initialize left and right pointers and the minimum elements in the window\\n        while (r < newLen) {  // iterate over the new unique array\\n            if (l == r)\\n                r++;  //  if the window is closed, open it ;)\\n            else if (nums[r] - nums[l] > k)\\n                l++;  //  if window becomes bigger than allowed size, shrink it\\n            else {\\n                fin = max(fin, r - l + 1);  //  if window is in allowed size, maximize the number of elements in the window\\n                r++;  // slide the right side \\n            }\\n        }  //  at this point, we have maximized the number of elements at any time inside the window\\n        return k - fin + 1;   //  return the missing elements in that window\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470854,
                "title": "detailed-explanation-sorting-binary-search",
                "content": "\\nClearly, if input array is of length ```n```, then our final continuous array must be of form:\\n\\n[start, start + 1, ... start + n - 1], where ```start``` is some starting element. \\n\\nKey idea: We can ```start``` our final continuous array from one of the given elements of the input array to get the minimum operations. \\n***Why?***\\nWell, this is because by starting at an element ```i``` of input array, we give ourselves the opportunity to find more elements in the range [```arr[i] + 1```, ```arr[i] + n - 1```] that are already present in the input. This will help us reduce the number of operations that we need to perform in order to get rest of the elements in the range [```arr[i]```, ```arr[i] + n - 1```]\\n\\n***How do I code?***\\nWe consider each element of the given array as a potential starting point of the final continuous array that we will form.\\nGiven a potential starting element at ```i```\\nWe can simply reuse all the unique elements of the given array that are between (```arr[i] + 1```, ```arr[i] + n - 1```)\\nTo find these reusable elements, we keep input sorted and then binary search for the elements in this range.\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        // Maintain only the list of unique elements. \\n        List<Integer> unique = new ArrayList<>();\\n        HashSet<Integer> vis = new HashSet<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (!vis.contains(nums[i])) {\\n                vis.add(nums[i]);\\n                unique.add(nums[i]);\\n            }\\n        }\\n\\n        // sort the unique elements, this will help us find reusable elements in O(logn) via binary search.\\n        Collections.sort(unique);\\n        \\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < unique.size(); ++i) {\\n            int start = unique.get(i);\\n            int last = unique.get(i) + nums.length - 1;\\n            int lo = i;\\n            int hi = unique.size() - 1;\\n\\n            // find the elements that we can reuse if the starting point is start\\n            while (lo < hi) {\\n                int mi = (lo + hi + 1) / 2;\\n\\n                if (unique.get(mi) <= last) {\\n                    lo = mi;\\n                } else {\\n                    hi = mi - 1;\\n                }\\n            }\\n\\n            min = Math.min(min, nums.length - (lo - i + 1));\\n        }\\n        return min;\\n    }\\n}\\n```\\n\\nComplexity: O(nlogn)",
                "solutionTags": [],
                "code": "```n```\n```start```\n```start```\n```i```\n```arr[i] + 1```\n```arr[i] + n - 1```\n```arr[i]```\n```arr[i] + n - 1```\n```i```\n```arr[i] + 1```\n```arr[i] + n - 1```\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        // Maintain only the list of unique elements. \\n        List<Integer> unique = new ArrayList<>();\\n        HashSet<Integer> vis = new HashSet<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (!vis.contains(nums[i])) {\\n                vis.add(nums[i]);\\n                unique.add(nums[i]);\\n            }\\n        }\\n\\n        // sort the unique elements, this will help us find reusable elements in O(logn) via binary search.\\n        Collections.sort(unique);\\n        \\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < unique.size(); ++i) {\\n            int start = unique.get(i);\\n            int last = unique.get(i) + nums.length - 1;\\n            int lo = i;\\n            int hi = unique.size() - 1;\\n\\n            // find the elements that we can reuse if the starting point is start\\n            while (lo < hi) {\\n                int mi = (lo + hi + 1) / 2;\\n\\n                if (unique.get(mi) <= last) {\\n                    lo = mi;\\n                } else {\\n                    hi = mi - 1;\\n                }\\n            }\\n\\n            min = Math.min(min, nums.length - (lo - i + 1));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119741,
                "title": "prefix-sum-solution-tc-o-nlog-n-sc-o-n",
                "content": "Since the array must be continuous, if the array starts with an element a, it will be continuous, and the last element will be a + size of the array - 1.\\n\\nWe can try to find an optimal starting position \\'a\\' for which we will need to change as few elements of the array as possible.\\n\\nTo do that, let us create an ordered map where each key of the map denotes an arbitrary starting position \\'a\\'. Now we iterate over all the elements of the array. For any element nums[i], it can be a part of all the arrays with starting positions in the range [max(1, nums[i] - k+1), nums[i]). So we increment the value of map at max(1, nums[i] - k+1) by 1 and decrement the value of map at (nums[i] + 1) by 1.\\n\\nNow do the prefix sum over all the keys of the map. It will give us the total number of elements that do not need modification for each key of the map.\\n\\nIterate over all the keys and find the one which has the highest value and then return the size of array - the highest value.\\n\\nexample: [1, 2, 3, 5, 6]\\nmp[1]=1, mp[2]=-1\\nmp[1]=2, mp[3]=-1\\nmp[1]=3, mp[4]=-1\\nmp[1]=4, mp[6]=-1\\nmp[2]=0, mp[7]=-1\\n\\nNow the values can be given as:\\n\\nkeys =    1   2   3   4   5   6   7\\nvalues = 4   0 -1  -1  -1  -1  -1\\n\\nsum =    4  4   3    2   1    0  -1\\n\\nSo the starting points 1 and 2 requires only one modifcation so the answer is 5-4=1.\\n\\nNote: We need to take care of duplicate elements. Figure out why\\n\\n**C++ code**\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        set<int>s;\\n        for(auto& val:nums){\\n            s.insert(val);\\n        }\\n        map<int, int>mp;\\n        for(auto& val:s){\\n            int l=max(1, val-(int)nums.size()+1);\\n            mp[l]++;\\n            mp[val+1]--;\\n        }\\n        int sum=0;\\n        for(auto& val:mp){\\n            sum+=val.second;\\n            val.second=sum;\\n        }\\n        int ans=INT_MAX;\\n        for(auto val:mp){\\n            ans=min(ans, (int)nums.size()-val.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        set<int>s;\\n        for(auto& val:nums){\\n            s.insert(val);\\n        }\\n        map<int, int>mp;\\n        for(auto& val:s){\\n            int l=max(1, val-(int)nums.size()+1);\\n            mp[l]++;\\n            mp[val+1]--;\\n        }\\n        int sum=0;\\n        for(auto& val:mp){\\n            sum+=val.second;\\n            val.second=sum;\\n        }\\n        int ans=INT_MAX;\\n        for(auto val:mp){\\n            ans=min(ans, (int)nums.size()-val.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471593,
                "title": "python3-sliding-window",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/0dcbb71853720dc380becdd8968bf94bdf419b7d) for the solutions of biweekly 61. \\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        \\n        ans = ii = 0\\n        for i, x in enumerate(nums): \\n            if x - nums[ii] >= n: ii += 1\\n            ans = max(ans, i - ii + 1)\\n        return n - ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        \\n        ans = ii = 0\\n        for i, x in enumerate(nums): \\n            if x - nums[ii] >= n: ii += 1\\n            ans = max(ans, i - ii + 1)\\n        return n - ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746951,
                "title": "c-silding-window",
                "content": "**Intution:-**\\n1.First i will sort the array, and make a new non repeating array in sorted form.\\n2.From each value in \"non-repeating-array\" , I will try to find out maximum possible elements in continous array, if formed from that element.\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int> different;\\n        different.push_back(nums[0]);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]!=nums[i-1]){\\n                different.push_back(nums[i]);\\n            }\\n        }\\n        int i=0;\\n        int m=different.size();\\n        int ans=0;\\n        for(int j=0;j<m;j++){\\n            if(different[j]<=different[i]+n-1){\\n                ans=max(ans,j-i+1);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return n-ans;\\n    }\\n};****\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int> different;\\n        different.push_back(nums[0]);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]!=nums[i-1]){\\n                different.push_back(nums[i]);\\n            }\\n        }\\n        int i=0;\\n        int m=different.size();\\n        int ans=0;\\n        for(int j=0;j<m;j++){\\n            if(different[j]<=different[i]+n-1){\\n                ans=max(ans,j-i+1);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return n-ans;\\n    }\\n};****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376527,
                "title": "c-simple-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        nums.resize(unique(nums.begin(), nums.end()) - nums.begin());\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int cntLess = i;\\n            int cntGreater = nums.end() - upper_bound(nums.begin(), nums.end(), nums[i] + n - 1);\\n            int inRange = nums.size() - (cntLess + cntGreater);\\n            ans = min(ans, n - inRange);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        nums.resize(unique(nums.begin(), nums.end()) - nums.begin());\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int cntLess = i;\\n            int cntGreater = nums.end() - upper_bound(nums.begin(), nums.end(), nums[i] + n - 1);\\n            int inRange = nums.size() - (cntLess + cntGreater);\\n            ans = min(ans, n - inRange);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997732,
                "title": "python-3-binary-search-o-nlogn-simple-solution",
                "content": "```\\nimport bisect\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        nums=list(set(nums))\\n        nums.sort()\\n        minn=float(\\'inf\\')\\n        for i,val in enumerate(nums):\\n            index=bisect_right(nums,val+n-1)\\n            minn=min(minn,n-(index-i))\\n        return minn\\n        \\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        nums=list(set(nums))\\n        nums.sort()\\n        minn=float(\\'inf\\')\\n        for i,val in enumerate(nums):\\n            index=bisect_right(nums,val+n-1)\\n            minn=min(minn,n-(index-i))\\n        return minn\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636219,
                "title": "c-set-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        //length of the initial array\\n        int len=nums.size();\\n        \\n        //remove duplicate elements and sort them\\n        set<int>S;\\n        for(auto &x:nums)\\n            S.insert(x);\\n        \\n        vector<int>temp;\\n        for(auto &x:S)\\n            temp.push_back(x);\\n        \\n        \\n        int maxx=INT_MIN,e=0;\\n        //In the first loop we traverse the entire array(modified) and take that element\\n        //as the minimum element of the required array and count the no of elements \\n        //that are in the range of [element,element+len) \\n        //and so for each element we count the count of elements required in the array \\n        //which is present in modified array and take the maximum of such counts.\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            while(e<temp.size()&&temp[e]<temp[i]+len)\\n            e++;\\n            \\n            maxx=max(maxx,e-i);\\n        }\\n        \\n        //the answer is the (length of the given array)-(maximum no of elements found in nums of any\\n        //such array that is being created in the above process.)\\n        return len-maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        //length of the initial array\\n        int len=nums.size();\\n        \\n        //remove duplicate elements and sort them\\n        set<int>S;\\n        for(auto &x:nums)\\n            S.insert(x);\\n        \\n        vector<int>temp;\\n        for(auto &x:S)\\n            temp.push_back(x);\\n        \\n        \\n        int maxx=INT_MIN,e=0;\\n        //In the first loop we traverse the entire array(modified) and take that element\\n        //as the minimum element of the required array and count the no of elements \\n        //that are in the range of [element,element+len) \\n        //and so for each element we count the count of elements required in the array \\n        //which is present in modified array and take the maximum of such counts.\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            while(e<temp.size()&&temp[e]<temp[i]+len)\\n            e++;\\n            \\n            maxx=max(maxx,e-i);\\n        }\\n        \\n        //the answer is the (length of the given array)-(maximum no of elements found in nums of any\\n        //such array that is being created in the above process.)\\n        return len-maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619435,
                "title": "c-easy-to-understand-well-commented-binary-search-sorting",
                "content": "```\\n// Problem Link : https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/\\nclass Solution {\\npublic:\\n    // Binary Search\\n    // it will give index of target and if target is not present then it will give largest element which is smaller than target\\n    int bsearch(vector<int>& nums, int target){\\n        int l = 0, h = nums.size()-1;\\n        \\n        while(l <= h){\\n            int m = l + (h-l)/2;\\n            \\n            if(target == nums[m])\\n                return m;\\n            else if(target < nums[m])\\n                h = m-1;\\n            else\\n                l = m+1;\\n        }\\n        return h;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        // To remove duplicates\\n        unordered_set<int> st;\\n        int duplicates = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(st.count(nums[i]) == 0){\\n                st.insert(nums[i]);\\n            }else{\\n                nums[i] = -1;\\n                duplicates++;\\n            }\\n        }\\n        int ans = nums.size();\\n        \\n        // sort an array\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = duplicates; i < nums.size(); i++){\\n            int valid = nums[i]+nums.size()-1; // this will be largest valid number if we start from nums[i]\\n            \\n            int indx = bsearch(nums,valid); // index of largest valid number\\n            int valid_numbers = indx-i+1; // numbers which are valid\\n            ans = min(ans,(int)nums.size()-valid_numbers); // substract valid numbers from total numbers to get valid numbers.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n// Problem Link : https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/\\nclass Solution {\\npublic:\\n    // Binary Search\\n    // it will give index of target and if target is not present then it will give largest element which is smaller than target\\n    int bsearch(vector<int>& nums, int target){\\n        int l = 0, h = nums.size()-1;\\n        \\n        while(l <= h){\\n            int m = l + (h-l)/2;\\n            \\n            if(target == nums[m])\\n                return m;\\n            else if(target < nums[m])\\n                h = m-1;\\n            else\\n                l = m+1;\\n        }\\n        return h;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        // To remove duplicates\\n        unordered_set<int> st;\\n        int duplicates = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(st.count(nums[i]) == 0){\\n                st.insert(nums[i]);\\n            }else{\\n                nums[i] = -1;\\n                duplicates++;\\n            }\\n        }\\n        int ans = nums.size();\\n        \\n        // sort an array\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = duplicates; i < nums.size(); i++){\\n            int valid = nums[i]+nums.size()-1; // this will be largest valid number if we start from nums[i]\\n            \\n            int indx = bsearch(nums,valid); // index of largest valid number\\n            int valid_numbers = indx-i+1; // numbers which are valid\\n            ans = min(ans,(int)nums.size()-valid_numbers); // substract valid numbers from total numbers to get valid numbers.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511051,
                "title": "using-ordered-set-c-o-nlogn",
                "content": "The time complexity is high but easy to understand.\\nEvery time we just go to every element and find how many elements we need to change to make the array contiguous which can easily be achived using the ordered_set \\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n  \\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        ordered_set st;\\n        \\n        for (int i = 0;i < n;i++){\\n            st.insert(nums[i]);\\n        }\\n        //This is the minimum number of change we have to made\\n        int mst = n - st.size();\\n        int ans = INT_MAX;\\n        for (auto val : st){\\n\\t\\t//  Finding how many element we have to change which are less then val and which are greater than the (val+n-1) \\n            int val2 = n - st.order_of_key(val+n) + st.order_of_key(val);\\n            int mx = max(mst, val2);\\n            ans = min(ans, mx);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you like",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n  \\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        ordered_set st;\\n        \\n        for (int i = 0;i < n;i++){\\n            st.insert(nums[i]);\\n        }\\n        //This is the minimum number of change we have to made\\n        int mst = n - st.size();\\n        int ans = INT_MAX;\\n        for (auto val : st){\\n\\t\\t//  Finding how many element we have to change which are less then val and which are greater than the (val+n-1) \\n            int val2 = n - st.order_of_key(val+n) + st.order_of_key(val);\\n            int mx = max(mst, val2);\\n            ans = min(ans, mx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1485104,
                "title": "sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        set<int> s;\\n        for(int i: nums)\\n            s.insert(i);\\n        int l1= nums.size();\\n        int ans= l1;\\n        int l2= s.size();\\n        set<int>:: iterator itr1;\\n        itr1= s.begin();\\n        int i= 0, j= 0;\\n        for(auto itr= s.begin(); itr!= s.end(); ++itr, ++i)\\n        {\\n            while(itr1!= s.end()&&*itr1<=*itr+l1-1)\\n            {\\n                ++itr1;\\n                ++j;\\n            }\\n            ans= min(ans, l1-j+i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        set<int> s;\\n        for(int i: nums)\\n            s.insert(i);\\n        int l1= nums.size();\\n        int ans= l1;\\n        int l2= s.size();\\n        set<int>:: iterator itr1;\\n        itr1= s.begin();\\n        int i= 0, j= 0;\\n        for(auto itr= s.begin(); itr!= s.end(); ++itr, ++i)\\n        {\\n            while(itr1!= s.end()&&*itr1<=*itr+l1-1)\\n            {\\n                ++itr1;\\n                ++j;\\n            }\\n            ans= min(ans, l1-j+i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472257,
                "title": "java-set-sorting-binary-search",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        //get unique elemets\\n        Set<Integer> set=new HashSet();\\n        for(int i:nums)\\n        {\\n            set.add(i);\\n        }\\n        int[] res=new int[set.size()];\\n        int in=0;\\n        for(int i:set)\\n        {\\n            res[in++]=i;\\n        }\\n        //sort the unique elements\\n        Arrays.sort(res);\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<res.length;i++)\\n        {\\n            //find the target based on the original array\\n            int e=res[i]+nums.length-1;\\n           //binary search for target\\n            int index=bs(res, i+1, e);\\n            ans=Math.min(ans, nums.length-(index-i+1));\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public int bs(int[] nums, int start, int target)\\n    {\\n        int high=nums.length-1;\\n        while(start<=high)\\n        {\\n            int mid=start+(high-start)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            } else {\\n                high=mid-1;\\n            }\\n        }\\n        return start-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        //get unique elemets\\n        Set<Integer> set=new HashSet();\\n        for(int i:nums)\\n        {\\n            set.add(i);\\n        }\\n        int[] res=new int[set.size()];\\n        int in=0;\\n        for(int i:set)\\n        {\\n            res[in++]=i;\\n        }\\n        //sort the unique elements\\n        Arrays.sort(res);\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<res.length;i++)\\n        {\\n            //find the target based on the original array\\n            int e=res[i]+nums.length-1;\\n           //binary search for target\\n            int index=bs(res, i+1, e);\\n            ans=Math.min(ans, nums.length-(index-i+1));\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public int bs(int[] nums, int start, int target)\\n    {\\n        int high=nums.length-1;\\n        while(start<=high)\\n        {\\n            int mid=start+(high-start)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            } else {\\n                high=mid-1;\\n            }\\n        }\\n        return start-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471041,
                "title": "c-sorting-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int n = A.size();\\n        if(n == 1) return 0;\\n        sort(A.begin(), A.end());\\n        \\n        vector<int> nums = {A[0]};\\n        for(int i=1; i<n; ++i)\\n            if(A[i] != A[i-1]) nums.push_back(A[i]); //remove duplicates\\n\\n        int maxContinuos = 1;\\n        for(int i= 1; i<nums.size(); ++i) {\\n            int val = nums[i] - n +1;\\n\\t\\t\\t//for every nums[i], we are finding how many numbers are there in range [val, nums[i]]\\n            int index = lower_bound(nums.begin(), nums.begin()+i, val) - nums.begin() ;\\n\\n            maxContinuos = max(maxContinuos, i - index+1);\\n        }\\n        return n - maxContinuos;\\n    }\\n};\\n```\\n\\nTime Complexity: O(N LogN) for sorting\\nSpace Complexity: O(N), for using one array\\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int n = A.size();\\n        if(n == 1) return 0;\\n        sort(A.begin(), A.end());\\n        \\n        vector<int> nums = {A[0]};\\n        for(int i=1; i<n; ++i)\\n            if(A[i] != A[i-1]) nums.push_back(A[i]); //remove duplicates\\n\\n        int maxContinuos = 1;\\n        for(int i= 1; i<nums.size(); ++i) {\\n            int val = nums[i] - n +1;\\n\\t\\t\\t//for every nums[i], we are finding how many numbers are there in range [val, nums[i]]\\n            int index = lower_bound(nums.begin(), nums.begin()+i, val) - nums.begin() ;\\n\\n            maxContinuos = max(maxContinuos, i - index+1);\\n        }\\n        return n - maxContinuos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470890,
                "title": "c-sorting-binary-search-easy-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int> mp;     // stores the frequency of each element\\n        vector<int> dp(nums.size(),0); // dp[i] represents no of duplicate elements from 0....i\\n        dp[0]=0;\\n        mp[nums[0]]++;\\n        for(int i=1;i<nums.size();i++){\\n            dp[i]+=dp[i-1] + (mp[nums[i]] > 0 ? 1 : 0); \\n            mp[nums[i]]++;\\n        }\\n        int ans = INT_MAX;\\n        // For each index, consider this is the smallest element and then calculate no of elements we need to change.\\n        for(int i = 0;i<nums.size();i++){\\n            int idx = upper_bound(nums.begin(),nums.end(),nums[i]+nums.size()-1) - nums.begin();\\n            int d = dp[idx-1] - (i==0 ? 0 : dp[i-1]); // Counting duplicate elements from i.....idx\\n            int curr = i + nums.size() - idx + d ;\\n            ans = min(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Hit Upvote if you like :)**",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int> mp;     // stores the frequency of each element\\n        vector<int> dp(nums.size(),0); // dp[i] represents no of duplicate elements from 0....i\\n        dp[0]=0;\\n        mp[nums[0]]++;\\n        for(int i=1;i<nums.size();i++){\\n            dp[i]+=dp[i-1] + (mp[nums[i]] > 0 ? 1 : 0); \\n            mp[nums[i]]++;\\n        }\\n        int ans = INT_MAX;\\n        // For each index, consider this is the smallest element and then calculate no of elements we need to change.\\n        for(int i = 0;i<nums.size();i++){\\n            int idx = upper_bound(nums.begin(),nums.end(),nums[i]+nums.size()-1) - nums.begin();\\n            int d = dp[idx-1] - (i==0 ? 0 : dp[i-1]); // Counting duplicate elements from i.....idx\\n            int curr = i + nums.size() - idx + d ;\\n            ans = min(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470852,
                "title": "c-solution-unique-and-queue",
                "content": "\\n### Idea\\n- make a new array with all unique element and sort.\\n- keep pushing an element into queue, and pop out the front element which is `queue.back() - queue.front() > n -1`, these elements in the queue are guaranteed that we don\\'t need to change.\\n- answer is n - queue.size();\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& _nums) {\\n        if(_nums.size() == 1) return 0;\\n        int n = _nums.size();\\n        map<int, int> cnt;\\n        for(auto x : _nums) ++cnt[x];\\n        vector<int> nums;\\n        for(auto it : cnt) nums.push_back(it.first); // sorted\\n        int ans = 0;\\n        queue<int> q;\\n        for(auto x : nums) {\\n            q.push(x);\\n            while(q.back() - q.front() > n - 1) q.pop();\\n            ans = max(ans, (int)q.size());\\n        }\\n        return n - ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& _nums) {\\n        if(_nums.size() == 1) return 0;\\n        int n = _nums.size();\\n        map<int, int> cnt;\\n        for(auto x : _nums) ++cnt[x];\\n        vector<int> nums;\\n        for(auto it : cnt) nums.push_back(it.first); // sorted\\n        int ans = 0;\\n        queue<int> q;\\n        for(auto x : nums) {\\n            q.push(x);\\n            while(q.back() - q.front() > n - 1) q.pop();\\n            ans = max(ans, (int)q.size());\\n        }\\n        return n - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725833,
                "title": "java-sliding-windows",
                "content": "```java\\npublic int minOperations(int[] nums) {\\n\\tint[] arr = Arrays.stream(nums).sorted().distinct().toArray();\\n\\tint res = nums.length;\\n\\tfor (int i = 0, j = 0; j < arr.length; j++) {\\n\\t\\twhile (arr[j] - arr[i] >= nums.length) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\tres = Integer.min(res, nums.length - (j - i + 1));\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int minOperations(int[] nums) {\\n\\tint[] arr = Arrays.stream(nums).sorted().distinct().toArray();\\n\\tint res = nums.length;\\n\\tfor (int i = 0, j = 0; j < arr.length; j++) {\\n\\t\\twhile (arr[j] - arr[i] >= nums.length) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\tres = Integer.min(res, nums.length - (j - i + 1));\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2702922,
                "title": "simple-solution-explained-python",
                "content": "ending - starting = n - 1\\nwe want something like [a, a+1, ......, a+n-1] (sorted representation)\\nmax operations = n-1, min operations = 0\\neach value in nums can be a valid starting point\\neach value in nums can be a valid ending point\\n\\nif each value can be a valid starting point, find the number of elements outside the window\\nelements outside window will be smaller than starting point & larger than n - 1 + starting\\nyou can use binary search to find the elements outside the window,\\nand smaller elements are to the left of starting point\\nyou should treat repeated elements as infinity because they are always going to change\\n\\nafter you realise that you just need to find the elements out of window\\nyou can just apply the sliding window technique\\n```\\ndef minOperations(self, nums: List[int]) -> int:\\n        #binary search\\n        n = len(nums)\\n        ans = n-1\\n        nums = sorted(set(nums))\\n        extra = n - len(nums) #repeated elements\\n        for i in range(len(nums)):\\n            right = bisect_right(nums, n-1+nums[i]) #index of first element larger than n-1+nums[i]\\n            ans = min(ans, len(nums) - right + i + extra)\\n        return ans\\n\\n        #sliding window\\n        n = len(nums)\\n        ans = n - 1\\n        nums = sorted(set(nums))\\n        extra = n - len(nums)\\n\\n        j = 0\\n        for i in range(len(nums)):\\n            while j<len(nums) and nums[j] <= n - 1 + nums[i]:\\n                j += 1\\n            ans = min(ans, n - (j - i))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\ndef minOperations(self, nums: List[int]) -> int:\\n        #binary search\\n        n = len(nums)\\n        ans = n-1\\n        nums = sorted(set(nums))\\n        extra = n - len(nums) #repeated elements\\n        for i in range(len(nums)):\\n            right = bisect_right(nums, n-1+nums[i]) #index of first element larger than n-1+nums[i]\\n            ans = min(ans, len(nums) - right + i + extra)\\n        return ans\\n\\n        #sliding window\\n        n = len(nums)\\n        ans = n - 1\\n        nums = sorted(set(nums))\\n        extra = n - len(nums)\\n\\n        j = 0\\n        for i in range(len(nums)):\\n            while j<len(nums) and nums[j] <= n - 1 + nums[i]:\\n                j += 1\\n            ans = min(ans, n - (j - i))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2644435,
                "title": "java-binary-search-o-nlogn",
                "content": "Inuition:\\nConsidering each element as the last element of answer array, we will find how many numbers are present between the element and (element - array.length +1), inclusive these two. keep track of maximum number of valid elements. and at last return the difference between total number of element of array and the maximum number of elements that we calculated earlier.\\n\\n```\\npublic int minOperations(int[] nums) {\\n        int totalEle = nums.length;\\n        int[] uniqueSortedArray = getUniqueSortedArray(nums);\\n        int maxCorrEle = Integer.MIN_VALUE;\\n        int sortedEle = uniqueSortedArray.length;\\n        for(int i = 0; i<sortedEle; i++) {\\n            int toFind = uniqueSortedArray[i] - totalEle + 1;\\n            int ind = Arrays.binarySearch(uniqueSortedArray, toFind);\\n            if(ind<0){\\n                ind = (-1 * ind) - 1;\\n            }\\n            maxCorrEle = Math.max(maxCorrEle, i-ind+1);\\n        }\\n        return totalEle-maxCorrEle;\\n        \\n    }\\n\\n    private int[] getUniqueSortedArray(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i : nums) {\\n            set.add(i);\\n        }\\n        int un = set.size();\\n        int[] arr = new int[un];\\n        int i = 0;\\n        for (Integer s : set) {\\n            arr[i++] = s;\\n        }\\n        set.clear();\\n        set = null;\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int[] nums) {\\n        int totalEle = nums.length;\\n        int[] uniqueSortedArray = getUniqueSortedArray(nums);\\n        int maxCorrEle = Integer.MIN_VALUE;\\n        int sortedEle = uniqueSortedArray.length;\\n        for(int i = 0; i<sortedEle; i++) {\\n            int toFind = uniqueSortedArray[i] - totalEle + 1;\\n            int ind = Arrays.binarySearch(uniqueSortedArray, toFind);\\n            if(ind<0){\\n                ind = (-1 * ind) - 1;\\n            }\\n            maxCorrEle = Math.max(maxCorrEle, i-ind+1);\\n        }\\n        return totalEle-maxCorrEle;\\n        \\n    }\\n\\n    private int[] getUniqueSortedArray(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i : nums) {\\n            set.add(i);\\n        }\\n        int un = set.size();\\n        int[] arr = new int[un];\\n        int i = 0;\\n        for (Integer s : set) {\\n            arr[i++] = s;\\n        }\\n        set.clear();\\n        set = null;\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2460173,
                "title": "c-sliding-window-sorting-solution-with-explaination",
                "content": "**The idea is to remove the duplicate elements and sort the array \\nduplicate elements are removed as they are definitely not the part of our continuous array \\nnow iterate through the array and consider every element as the minimum element of continuous subarray\\nmake a sliding window from that element and increase its length to cover all the elements in the range of current+(length-1)\\nstore the maximum size of sliding window (maxi)\\nlength-maxi is the minimum number of elements to be changed\\n **\\n```\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        set<int>set;\\n        for(auto it:nums){\\n            set.insert(it);\\n        }\\n        vector<int>v;\\n        for(auto it:set){\\n            v.push_back(it);\\n        }\\n        sort(v.begin(),v.end());\\n        int right=0;\\n        int maxi=INT_MIN;\\n        int p=v.size();\\n        for(int left=0;left<n;left++){\\n           while(right<p&&v[right]-v[left]<=n-1) {\\n               right++;\\n           }\\n            int cur_count=right-left;\\n            maxi=max(cur_count,maxi);\\n        }\\n        return n-maxi;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        set<int>set;\\n        for(auto it:nums){\\n            set.insert(it);\\n        }\\n        vector<int>v;\\n        for(auto it:set){\\n            v.push_back(it);\\n        }\\n        sort(v.begin(),v.end());\\n        int right=0;\\n        int maxi=INT_MIN;\\n        int p=v.size();\\n        for(int left=0;left<n;left++){\\n           while(right<p&&v[right]-v[left]<=n-1) {\\n               right++;\\n           }\\n            int cur_count=right-left;\\n            maxi=max(cur_count,maxi);\\n        }\\n        return n-maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2374629,
                "title": "java-o-nlog-n-time-o-1-space-sliding-window-with-comments",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);              // Sort in ascending order, so left points to min element and right to max element in window\\n        \\n        int left = 0, right = 0;        \\n        int maxDiff = n - 1;            // max diff between the min and max element\\n        int maxLen = 1;                 // Length of longest sub array without duplicates such that min - max <= maxDiff\\n        int dupCount = 0;               // count of duplicate elements in the window\\n        \\n        for(right = 0; right < n; right ++) {\\n            if(right > 0 && nums[right] == nums[right - 1]) {\\n                dupCount ++;\\n            }\\n            \\n            while(nums[right] - nums[left] > maxDiff) { // if max - min > maxDiff, decrease size of window\\n                if(left < n && nums[left] == nums[left + 1]) {\\n                    dupCount --;\\n                }\\n                left ++;\\n                \\n            }\\n            maxLen = Math.max(maxLen, right - left + 1 - dupCount);\\n        }\\n        \\n        return n - maxLen;  // modifications required\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);              // Sort in ascending order, so left points to min element and right to max element in window\\n        \\n        int left = 0, right = 0;        \\n        int maxDiff = n - 1;            // max diff between the min and max element\\n        int maxLen = 1;                 // Length of longest sub array without duplicates such that min - max <= maxDiff\\n        int dupCount = 0;               // count of duplicate elements in the window\\n        \\n        for(right = 0; right < n; right ++) {\\n            if(right > 0 && nums[right] == nums[right - 1]) {\\n                dupCount ++;\\n            }\\n            \\n            while(nums[right] - nums[left] > maxDiff) { // if max - min > maxDiff, decrease size of window\\n                if(left < n && nums[left] == nums[left + 1]) {\\n                    dupCount --;\\n                }\\n                left ++;\\n                \\n            }\\n            maxLen = Math.max(maxLen, right - left + 1 - dupCount);\\n        }\\n        \\n        return n - maxLen;  // modifications required\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365453,
                "title": "c-sets",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len=nums.size()-1;\\n        int mini=INT_MAX, maxi=INT_MIN;\\n        set<int> count;\\n        for(auto &it:nums) {\\n            count.insert(it);\\n            mini=min(mini, it); \\n            maxi=max(maxi, it);\\n        }\\n        if(count.size()==len+1&&maxi-mini==len) return 0;\\n        int ans=INT_MIN, si=0, ei=0;\\n        auto itr=count.begin();\\n        for(auto it=count.begin(); it!=count.end(); it++) {\\n            int num=0, maxi=*it+len;\\n            while(itr!=count.end()&&(*itr<=maxi)) {\\n                itr++; ei++;\\n            }   \\n            ans=max(ans, ei-si);\\n            if(ans==len+1) return 0;\\n            si++;\\n        }\\n        return len+1-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len=nums.size()-1;\\n        int mini=INT_MAX, maxi=INT_MIN;\\n        set<int> count;\\n        for(auto &it:nums) {\\n            count.insert(it);\\n            mini=min(mini, it); \\n            maxi=max(maxi, it);\\n        }\\n        if(count.size()==len+1&&maxi-mini==len) return 0;\\n        int ans=INT_MIN, si=0, ei=0;\\n        auto itr=count.begin();\\n        for(auto it=count.begin(); it!=count.end(); it++) {\\n            int num=0, maxi=*it+len;\\n            while(itr!=count.end()&&(*itr<=maxi)) {\\n                itr++; ei++;\\n            }   \\n            ans=max(ans, ei-si);\\n            if(ans==len+1) return 0;\\n            si++;\\n        }\\n        return len+1-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349112,
                "title": "heavily-commented-code-simplest-explanation-using-binary-search",
                "content": "`\\n/*Intution : while pondering at the problem, I was thinking of o(n2) solution wherein, I\\'ll deem every element as the minimum element and will see how many elements are there in the array that together with this element will form a \"continuous array\" with minimum changes. \\nSomething like this :*/ `\\n\\n```\\nfor(int idx -> 0 to n) {\\n\\t another loop to check how many elements are there in the array that together with nums[idx] will form a \"continuous array\" with minimum changes\\n}\\n```\\n\\n\\n***But looking at the constraints o(n2) solution won\\'t get passed. So I need to work on my inner loop and if possible bring inner loop\\'s complexity down to o(logn or 1)***\\n\\nOne more thing to consider : elements in the continuous array  should be unique. For that I can remove all the  repeating elements. (By using set containers,  probably!!)\\n\\n`There\\'s another intution : for every  start(minE) element, it\\'s end(maxE) counterpart can be decided using the  given relation, (maxE - minE = size - 1), if the array is sorted, then maxE and minE will be our end and start elements.\\nso we can use binary search  to find an element just greater than our required end element, and the difference between end_idx and start_idx will give us the number of elements present in our array that can be used in the continuous array. The start element that will have max number of usable elements in the given array will be our start element for the \"continuous array\", and will give us a continuous array with minimum replacements. (Greedy Approach)\\n` \\n\\n\\n# code with comments : \\n```\\nclass Solution {\\npublic:\\n    \\n    //tc : o(nlogn); sc : o(n);\\n    //the test cases here are deceptive, none of them cover the case where, nums will have repeating elements.\\n    int minOperations(vector<int>& nums) {\\n        //as nums should have unique values, all non-unique values should be \\n        //removed. Infact non-unique ones will be have to be replaced, costing one operation\\n        //so it\\'s fine to remove all of them.\\n        int n = nums.size(); \\n        \\n        set<int> container; //container To Remove Repeating Elements Plus To Sort the Left Ones\\n        \\n        for(int idx = 0; idx < nums.size(); idx++) container.insert(nums[idx]);\\n        nums.clear();\\n        for(auto u: container) nums.push_back(u);\\n        //nums now contain only unique values and that too in sorted fashion.\\n        \\n        //the sole idea behind a continuous array  is that it should be continuous from the start element till the end element\\n        //we\\'ll take each element as the start element and then we\\'ll check how many elements are missing from the \\n        //array if it was continuous, we\\'ll choose the element for which max number of elements will be present for our \\n        //array to be continuous, in other words we\\'ll choose the element for which minimum no. of chages would be required\\n        \\n        int minOp = INT_MAX;\\n        for(int idx=0; idx<n; idx++) {\\n            int start = nums[idx];\\n            int end = start + n - 1; //from : (end - start = n - 1), difference between max and min should be equal to size - 1;\\n            \\n            //BS to find element just greater than end element, so the difference will give the no. of elements between start & end.\\n            auto itToEnd = upper_bound(nums.begin(), nums.end(), end);\\n            int end_idx = itToEnd - nums.begin();\\n            \\n            int eleBetween = end_idx - idx; //no. of elements between end & start\\n            int nOfMissingElements = n - eleBetween; //no. of elements required to make nums continuous.\\n            \\n            minOp = min(minOp, nOfMissingElements);\\n        }\\n        \\n        \\n        return minOp;\\n    }\\n};\\n\\n\\n//initial mistake, n should be the size of original nums as that size can only tell us how much elements are required exactly.\\n```\\n\\n\\n```\\nComplexity analysis,  \\n\\ttc : o(nlogn + nlogn) ~ o(nlogn) //we are using set plus binary search within a loop.\\n\\tsc : o(n) //maintaining a set of size  at max n\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nfor(int idx -> 0 to n) {\\n\\t another loop to check how many elements are there in the array that together with nums[idx] will form a \"continuous array\" with minimum changes\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    //tc : o(nlogn); sc : o(n);\\n    //the test cases here are deceptive, none of them cover the case where, nums will have repeating elements.\\n    int minOperations(vector<int>& nums) {\\n        //as nums should have unique values, all non-unique values should be \\n        //removed. Infact non-unique ones will be have to be replaced, costing one operation\\n        //so it\\'s fine to remove all of them.\\n        int n = nums.size(); \\n        \\n        set<int> container; //container To Remove Repeating Elements Plus To Sort the Left Ones\\n        \\n        for(int idx = 0; idx < nums.size(); idx++) container.insert(nums[idx]);\\n        nums.clear();\\n        for(auto u: container) nums.push_back(u);\\n        //nums now contain only unique values and that too in sorted fashion.\\n        \\n        //the sole idea behind a continuous array  is that it should be continuous from the start element till the end element\\n        //we\\'ll take each element as the start element and then we\\'ll check how many elements are missing from the \\n        //array if it was continuous, we\\'ll choose the element for which max number of elements will be present for our \\n        //array to be continuous, in other words we\\'ll choose the element for which minimum no. of chages would be required\\n        \\n        int minOp = INT_MAX;\\n        for(int idx=0; idx<n; idx++) {\\n            int start = nums[idx];\\n            int end = start + n - 1; //from : (end - start = n - 1), difference between max and min should be equal to size - 1;\\n            \\n            //BS to find element just greater than end element, so the difference will give the no. of elements between start & end.\\n            auto itToEnd = upper_bound(nums.begin(), nums.end(), end);\\n            int end_idx = itToEnd - nums.begin();\\n            \\n            int eleBetween = end_idx - idx; //no. of elements between end & start\\n            int nOfMissingElements = n - eleBetween; //no. of elements required to make nums continuous.\\n            \\n            minOp = min(minOp, nOfMissingElements);\\n        }\\n        \\n        \\n        return minOp;\\n    }\\n};\\n\\n\\n//initial mistake, n should be the size of original nums as that size can only tell us how much elements are required exactly.\\n```\n```\\nComplexity analysis,  \\n\\ttc : o(nlogn + nlogn) ~ o(nlogn) //we are using set plus binary search within a loop.\\n\\tsc : o(n) //maintaining a set of size  at max n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120270,
                "title": "binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) \\n    {\\n        map<int,int> mp;\\n        int n=a.size(),ans=1e9;\\n        for(int i=0;i<n;i++)\\n            mp[a[i]]++;\\n        a.clear();\\n        for(auto i:mp)\\n            a.push_back(i.first);\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int len=lower_bound(a.begin(),a.end(),a[i]+n)-a.begin()-i;\\n            ans=min(ans,n-len);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) \\n    {\\n        map<int,int> mp;\\n        int n=a.size(),ans=1e9;\\n        for(int i=0;i<n;i++)\\n            mp[a[i]]++;\\n        a.clear();\\n        for(auto i:mp)\\n            a.push_back(i.first);\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int len=lower_bound(a.begin(),a.end(),a[i]+n)-a.begin()-i;\\n            ans=min(ans,n-len);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922796,
                "title": "c-short",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tnums.erase(unique(nums.begin(),nums.end()),nums.end());\\n\\t\\t\\tint m = nums.size();\\n\\t\\t\\t\\n\\t\\t\\tint j=0;\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\twhile(j<m && nums[j] < nums[i]+n){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = min(ans,n-j+i);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tnums.erase(unique(nums.begin(),nums.end()),nums.end());\\n\\t\\t\\tint m = nums.size();\\n\\t\\t\\t\\n\\t\\t\\tint j=0;\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\twhile(j<m && nums[j] < nums[i]+n){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1636191,
                "title": "java-solution-sorting-treeset",
                "content": "\\n \\n\\t  class Solution {\\n         public int minOperations(int[] nums) {\\n\\t\\t//using treeset to store them in sorted fashion and ignoring duplicates\\n        \\n        TreeSet<Integer> s=new TreeSet<>();\\n        int max=Integer.MIN_VALUE;\\n        int range=nums.length-1;\\n        \\n        //sorting the array to make the elements continuous which will be easy to do\\n        //[1,2,3,50,51,56] have this array\\n        //now checking for each no. range i.e\\n        //[1,2,3,4,5,6] like this so,when 50-1 encounters that goes out of range so we remove it\\n        //from set and stores max size of the set list and then try for the next\\n        //continuous range,i.e[2,3,4,5,6,7] like this continues...\\n        //and maximum size of the set is stored\\n        //so minimum operation required will be (array length-max(size of set stored))\\n        Arrays.sort(nums);\\n        \\n        for(int x:nums){\\n            \\n            while(!s.isEmpty() && x-s.first()>range){\\n                s.pollFirst();\\n            }\\n            \\n            s.add(x);\\n            max=Math.max(max,s.size());\\n        }\\n        return nums.length-max;\\n\\t}\\n}\\n\\t\\n",
                "solutionTags": [],
                "code": "class Solution {\\n         public int minOperations(int[] nums) {\\n\\t\\t//using treeset to store them in sorted fashion and ignoring duplicates\\n        \\n        TreeSet<Integer> s=new TreeSet<>();\\n        int max=Integer.MIN_VALUE;\\n        int range=nums.length-1;\\n        \\n        //sorting the array to make the elements continuous which will be easy to do\\n        //[1,2,3,50,51,56] have this array\\n        //now checking for each no. range i.e\\n        //[1,2,3,4,5,6] like this so,when 50-1 encounters that goes out of range so we remove it\\n        //from set and stores max size of the set list and then try for the next\\n        //continuous range,i.e[2,3,4,5,6,7] like this continues...\\n        //and maximum size of the set is stored\\n        //so minimum operation required will be (array length-max(size of set stored))\\n        Arrays.sort(nums);\\n        \\n        for(int x:nums){\\n            \\n            while(!s.isEmpty() && x-s.first()>range){\\n                s.pollFirst();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1586190,
                "title": "pigeonhole-principle",
                "content": "Didn\\'t see anyone mention this, but here\\'s how I thought of the problem. You can kind of think of this according to the pigeonhole principle used to reason about hash tables. Think of it this way, I have a range of numbers (buckets) between the maximum and minimum number candidates of the array, and I want to cram the rest of the array into it such that each number fits into each bucket. Or in other words, I want to fit \\'n\\' items in less than or equal to \\'m\\' buckets.\\n\\nExample:\\n[1,2,4,4,5,9] => i starts at zero with 1 as my candidate minimum, my candidate maximum here would be 7. I need to cram the rest of the array in that range. I need to know if I essentially have collisions. To track this, check what numbers do not need to be moved. The numbers that do not need to be moved are going to be the numbers already within the range (in this case, 2,4,5). Any numbers that are duplicates need to be moved as they occupy the same bucket already. Any numbers outside of the range (either to the left of the candidate minumum or to the right of the candidate maximum) need to also be moved within the range.\\n\\nHere\\'s my code below, I used a treemap to find the closest number to the candidate maximum as well as a prefix array to track duplicates. The closet number to my candidate maximum (which might be the maximum itself) would be the index that\\'s used find numbers outside of the range and to the right of the candidate maximum.\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int [] prefixArr = new int[nums.length];\\n        TreeMap<Integer,Integer> lowTreeMap = new TreeMap<>();\\n        boolean isDupe = false;;\\n        int totalDupes = 0;\\n        int minOps = nums.length-1;\\n        lowTreeMap.put(nums[0], 0);\\n        for(int i=1;i<nums.length;i++){\\n            isDupe = nums[i] == nums[i-1];\\n            totalDupes += (isDupe) ? 1 : 0;\\n            prefixArr[i] = totalDupes;\\n            lowTreeMap.putIfAbsent(nums[i], i);\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]+(nums.length-1) < 0){\\n                break;\\n            }\\n            Map.Entry<Integer,Integer> maxEntry = lowTreeMap.ceilingEntry(nums[i]+(nums.length-1)); // May be null which is a case that should be checked. So the candidate maximum is greater than any other number in the array.\\n\\n            int maxNum = nums[i]+(nums.length-1); // This number may not correspond with an element in the array\\n            int maxKey = (maxEntry != null) ? maxEntry.getKey() : maxNum;\\n            int maxIndex = (maxEntry != null) ? maxEntry.getValue() : nums.length-1;\\n            int numDupes = prefixArr[maxIndex]-prefixArr[i];\\n\\n            int numTaken = (maxEntry != null) ? (maxIndex-i-1) - numDupes : (maxIndex-i) - numDupes;\\n            int numLeft = i;\\n            int numRight = nums.length-1-maxIndex;\\n            int range = (maxEntry != null) ? maxNum - nums[i] - 1 : maxNum - nums[i];\\n            int addKey = (maxKey > maxNum) ? 1 : 0;\\n\\n            if(numLeft + numRight + numDupes + numTaken <= range){ // Check if \\'n\\' items can fit in \\'m\\' buckets.\\n                minOps = Math.min(numLeft+numRight+numDupes+addKey, minOps);\\n            }\\n\\n        }\\n        return minOps;\\n}\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int [] prefixArr = new int[nums.length];\\n        TreeMap<Integer,Integer> lowTreeMap = new TreeMap<>();\\n        boolean isDupe = false;;\\n        int totalDupes = 0;\\n        int minOps = nums.length-1;\\n        lowTreeMap.put(nums[0], 0);\\n        for(int i=1;i<nums.length;i++){\\n            isDupe = nums[i] == nums[i-1];\\n            totalDupes += (isDupe) ? 1 : 0;\\n            prefixArr[i] = totalDupes;\\n            lowTreeMap.putIfAbsent(nums[i], i);\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]+(nums.length-1) < 0){\\n                break;\\n            }\\n            Map.Entry<Integer,Integer> maxEntry = lowTreeMap.ceilingEntry(nums[i]+(nums.length-1)); // May be null which is a case that should be checked. So the candidate maximum is greater than any other number in the array.\\n\\n            int maxNum = nums[i]+(nums.length-1); // This number may not correspond with an element in the array\\n            int maxKey = (maxEntry != null) ? maxEntry.getKey() : maxNum;\\n            int maxIndex = (maxEntry != null) ? maxEntry.getValue() : nums.length-1;\\n            int numDupes = prefixArr[maxIndex]-prefixArr[i];\\n\\n            int numTaken = (maxEntry != null) ? (maxIndex-i-1) - numDupes : (maxIndex-i) - numDupes;\\n            int numLeft = i;\\n            int numRight = nums.length-1-maxIndex;\\n            int range = (maxEntry != null) ? maxNum - nums[i] - 1 : maxNum - nums[i];\\n            int addKey = (maxKey > maxNum) ? 1 : 0;\\n\\n            if(numLeft + numRight + numDupes + numTaken <= range){ // Check if \\'n\\' items can fit in \\'m\\' buckets.\\n                minOps = Math.min(numLeft+numRight+numDupes+addKey, minOps);\\n            }\\n\\n        }\\n        return minOps;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503787,
                "title": "c-simple-solution-using-set",
                "content": "Idea is sort the array and erase duplicates if any,\\nSo set is bettter compare to erase in a vector.\\n\\n```\\nint minOperations(vector<int>& A) {\\n         int N = A.size(), i = 0, j = 0;      \\n        set<int> st(A.begin(), A.end());\\n        vector<int> B (st.begin(), st.end());\\n      \\n        for (int M = B.size(); j < M; ++j) {\\n            if (B[i] + N <= B[j]) \\n                ++i;\\n        }\\n        return N - j + i;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minOperations(vector<int>& A) {\\n         int N = A.size(), i = 0, j = 0;      \\n        set<int> st(A.begin(), A.end());\\n        vector<int> B (st.begin(), st.end());\\n      \\n        for (int M = B.size(); j < M; ++j) {\\n            if (B[i] + N <= B[j]) \\n                ++i;\\n        }\\n        return N - j + i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1483624,
                "title": "sorting-dedup-binary-search-with-java",
                "content": "# LC2009. Minimum Number of Operations to Make Array Continuous\\n## Method. Sorting + Dedup + Binary Search\\n### Main Idea\\n**Observations**\\n1. Since the length of the input array is fixed, once the starting point is determined, the end point is also fixed, which is `end = start + n - 1`.\\n2. To see how many modifications we need to make if we choose `start` as the starting point, just check the number of unique elements in the array that fall within the range `[start, end]`, say `count`, and `n - count` will be the number of operations needed if we choose `start` as the starting point.\\n3. It\\'s obvious that the starting point can only be one of the elements in the array, since modifying a starting point doesn\\'t make any sense.\\n\\nSo the main idea is to use each element in the array as the starting point, and check the number of operations needed using the above observations, finally take the minimum among them.\\n\\n**Algorithm**\\n1. Sort the array, so if a starting point `i` is given, we know that all the elements in its LHS will be out of the range (since they are smaller than the starting point), and we can use binary search to find the largest element smaller than `nums[i] + n - 1` on the RHS. Any numbers greater than `nums[i] + n - 1` will also be excluded and modified.\\n2. We also need to deduplicate the array since even within the range, we need to modify duplicate elements.\\n3. Use binary search as 1. mentioned.\\n4. Take the min among all the results.\\n\\n### Code\\n* Java\\n```java\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length, res = n;\\n        Arrays.sort(nums);\\n\\t\\t// Dedup and store in a new array A\\n        List<Integer> A = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            if (A.isEmpty() || A.get(A.size() - 1) != nums[i]) {\\n                A.add(nums[i]);\\n            }\\n        }\\n        for (int i = 0; i < A.size(); ++i) {\\n            int idx = binarySearch(A, i + 1, A.size() - 1, A.get(i) + n - 1);\\n            if (idx != -1) {\\n                int cnt = n - (idx - i + 1);\\n                res = Math.min(res, cnt);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    // Search for the index of largest element smaller equal to tar\\n    private int binarySearch(List<Integer> A, int start, int end, int tar) {\\n        int l = start, r = end;\\n        while (l < r - 1) {\\n            int m = l + (r - l) / 2;\\n            if (A.get(m) == tar) {\\n                return m;\\n            } else if (A.get(m) < tar) {\\n                l = m;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        \\n        return A.get(r) <= tar ? r : A.get(l) <= tar ? l : -1;\\n    }\\n}\\n```\\n\\n### Complexity Analysis\\nTime: `O(nlogn)`, since we sorted the array, and performed `n` binary search, each takes `O(logn)`\\nSpace: `O(n)`, since we used a new array to store the dedup array `A`.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length, res = n;\\n        Arrays.sort(nums);\\n\\t\\t// Dedup and store in a new array A\\n        List<Integer> A = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            if (A.isEmpty() || A.get(A.size() - 1) != nums[i]) {\\n                A.add(nums[i]);\\n            }\\n        }\\n        for (int i = 0; i < A.size(); ++i) {\\n            int idx = binarySearch(A, i + 1, A.size() - 1, A.get(i) + n - 1);\\n            if (idx != -1) {\\n                int cnt = n - (idx - i + 1);\\n                res = Math.min(res, cnt);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    // Search for the index of largest element smaller equal to tar\\n    private int binarySearch(List<Integer> A, int start, int end, int tar) {\\n        int l = start, r = end;\\n        while (l < r - 1) {\\n            int m = l + (r - l) / 2;\\n            if (A.get(m) == tar) {\\n                return m;\\n            } else if (A.get(m) < tar) {\\n                l = m;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        \\n        return A.get(r) <= tar ? r : A.get(l) <= tar ? l : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472077,
                "title": "simple-java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length, maxNum = 0; \\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, j = 0; i < n; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            while (nums[i] - nums[j] >= n) {\\n                map.put(nums[j], map.get(nums[j]) - 1);\\n                if (map.get(nums[j]) == 0) map.remove(nums[j]); \\n                j++;\\n            }\\n            maxNum = Math.max(maxNum, map.size());\\n        }\\n        return n - maxNum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length, maxNum = 0; \\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, j = 0; i < n; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            while (nums[i] - nums[j] >= n) {\\n                map.put(nums[j], map.get(nums[j]) - 1);\\n                if (map.get(nums[j]) == 0) map.remove(nums[j]); \\n                j++;\\n            }\\n            maxNum = Math.max(maxNum, map.size());\\n        }\\n        return n - maxNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471546,
                "title": "c-upper-bound-faster-than-100-o-nlogn-with-simple-explanation",
                "content": "**Conclusion from the question**\\n1) Final array will be a continious series of unique elements of length nums.size().\\n2) Intuitively, It is not very difficult to see that the resulting series will start from any optimal element which is already present in the array. \\n\\n3) Now we only need to find from **which element I should start my series**  so that I required minimum updation.\\n\\n**Idea**\\nHere I will be computing for every element in the array,  that How many minimum number of elements required to add in the array if I am starting from the current element, and the ans will be the minimum count among all the array elements.\\n\\n**Logic For computing the minimum number of element those are required to add if I am starting my series from current element**\\nFirst I will create another array after removing all the duplicate from the nums array in sorted order. \\nNow suppose my array is  1 2 5 6 7 11 12   and I want to find the count for starting element lets say 1 . \\n\\n```Already_exists_Number_of_elements=upper_bound(arr.begin(), arr.end(), currelement+nums.size()-1)-itr``` \\n(Here itr is the position of the current element , as 1 is the first element of the array so here itr=arr.begin())\\n\\n```Elements_required_to_add = (nums.size()-Already_exists_Number_of_elements)```\\n\\n**ans=min for all i (Elements_required_to_add)**\\n\\n[C++Code] O(nlogn)\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> arr; arr.push_back(nums[0]);\\n        // arr will store all the unique elements from nums in sorted order\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1])\\n            arr.push_back(nums[i]);\\n        }\\n        \\n        int n=nums.size(); int ans=n;\\n        for(auto itr=arr.begin();itr!=arr.end();itr++){\\n        // ele:- represents the number of elements those are already exists in the array \\n        // if i am starting my series from the element (*itr)\\n            int ele=upper_bound(itr, arr.end(), *itr+n-1)-itr;\\n            ans=min(ans, n-ele);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```Already_exists_Number_of_elements=upper_bound(arr.begin(), arr.end(), currelement+nums.size()-1)-itr```\n```Elements_required_to_add = (nums.size()-Already_exists_Number_of_elements)```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> arr; arr.push_back(nums[0]);\\n        // arr will store all the unique elements from nums in sorted order\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1])\\n            arr.push_back(nums[i]);\\n        }\\n        \\n        int n=nums.size(); int ans=n;\\n        for(auto itr=arr.begin();itr!=arr.end();itr++){\\n        // ele:- represents the number of elements those are already exists in the array \\n        // if i am starting my series from the element (*itr)\\n            int ele=upper_bound(itr, arr.end(), *itr+n-1)-itr;\\n            ans=min(ans, n-ele);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470879,
                "title": "python-3-o-nlogn-solution-with-visualization",
                "content": "**Explanation with visualization**\\n\\n**Observation 1:**\\nWe can consider only unique elements (No duplicates)\\n\\n**Observation 2:** \\nFor the difference between maximum and minimum number to be equal to len(nums)-1 we want the elements to be a contiguous sequence. \\n\\n**Solution:**\\nSince the final result has to be a contiguous sequence we can go over all the current contiguous sequences and for each sequence we can see how many numbers will be in the window of size len(nums) (with duplicates) to the left and the right of the contiguous sequence. We consider the side which encloses most numbers. Since we know how many numbers are not going to be replaced we can subtract that from the len(nums) (with duplicates) to get the ans for the current contiguous sequence. We repeat the same process over all the sequences and return the minimum replacements. \\n\\nConsider an Example:\\n\\nLet\\'s say nums = [2,3,5,6,11]\\nThere are 3 contiguous sequences: \\n[2,3], [5,6], [11]\\nWe start from [2,3] and check the number of points to the left and right in a window of size 5. There are no points on the left and there are 2 points on the right of [2,3], which can be seen in the figure below. \\n![image](https://assets.leetcode.com/users/images/e41e1cdd-e98e-4899-b149-c66f34c9714d_1631995803.1712296.jpeg)\\n\\nSimilarly, for [5,6] there are points on the left and not on the right. Above figure applies to this one as well for the left window. The right window is:\\n![image](https://assets.leetcode.com/users/images/1bc28036-c1f3-4c58-8c82-9b2e66e4a88a_1631995975.3122933.jpeg)\\n\\nFor [11], there are no points on the right or left. The left window is as shown below: \\n![image](https://assets.leetcode.com/users/images/8425a8e0-0e95-4a14-8fdd-fdc67a4b9e38_1631996027.6644182.jpeg)\\n\\nHence, the minimum number of points to be removed are in the case of right window of [2,3] and left window of [5,6] which is 1.\\n\\n**Implementation:**\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        i = 0\\n        initial_length = len(nums)\\n        nums = list(set(nums))\\n        nums.sort()\\n        n = len(nums)\\n        continuous_segments = []\\n        while i<n:\\n            j = i+1\\n            while j<n and nums[j]==nums[j-1]+1:\\n                j+=1\\n            continuous_segments.append([j-i,i,j-1])\\n            i = j\\n        res = float(\\'inf\\')\\n        for ans,ans_l,ans_r in continuous_segments:\\n            # Find number of points from nums[ans_r]+1 to nums[ans_r]+(initial_length-ans)\\n            right_points = bisect.bisect_right(nums,nums[ans_r]+(initial_length-ans))-bisect.bisect_left(nums,nums[ans_r]+1)\\n            # Find number of points from nums[ans_l]-(initial_length-ans) to nums[ans_l]-1\\n            left_points = bisect.bisect_left(nums,nums[ans_l]-1)-bisect.bisect_left(nums,nums[ans_l]-(initial_length-ans))\\n            res = min(res, initial_length-(ans+max(right_points,left_points)))\\n        return res\\n```\\n\\n**Update:**\\n\\nSince we are considering a sorted nums sequence we don\\'t have to check both the left and right windows, as the previous contiguous sequence will have the left window of current contiguous sequence as it\\'s right window. In short, it suffices to just check the right window of every contiguous sequence. \\n\\n**Updated code:**\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        i = 0\\n        initial_length = len(nums)\\n        nums = list(set(nums))\\n        nums.sort()\\n        n = len(nums)\\n        continuous_segments = []\\n        while i<n:\\n            j = i+1\\n            while j<n and nums[j]==nums[j-1]+1:\\n                j+=1\\n            continuous_segments.append([j-i,i,j-1])\\n            i = j\\n        res = float(\\'inf\\')\\n        for ans,ans_l,ans_r in continuous_segments:\\n            # Find number of points from nums[ans_r]+1 to nums[ans_r]+(initial_length-ans)\\n            right_points = bisect.bisect_right(nums,nums[ans_r]+(initial_length-ans))-bisect.bisect_left(nums,nums[ans_r]+1)\\n            res = min(res, initial_length-(ans+right_points))\\n        return res\\n```\\nIf you like the solution, please consider upvoting!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        i = 0\\n        initial_length = len(nums)\\n        nums = list(set(nums))\\n        nums.sort()\\n        n = len(nums)\\n        continuous_segments = []\\n        while i<n:\\n            j = i+1\\n            while j<n and nums[j]==nums[j-1]+1:\\n                j+=1\\n            continuous_segments.append([j-i,i,j-1])\\n            i = j\\n        res = float(\\'inf\\')\\n        for ans,ans_l,ans_r in continuous_segments:\\n            # Find number of points from nums[ans_r]+1 to nums[ans_r]+(initial_length-ans)\\n            right_points = bisect.bisect_right(nums,nums[ans_r]+(initial_length-ans))-bisect.bisect_left(nums,nums[ans_r]+1)\\n            # Find number of points from nums[ans_l]-(initial_length-ans) to nums[ans_l]-1\\n            left_points = bisect.bisect_left(nums,nums[ans_l]-1)-bisect.bisect_left(nums,nums[ans_l]-(initial_length-ans))\\n            res = min(res, initial_length-(ans+max(right_points,left_points)))\\n        return res\\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        i = 0\\n        initial_length = len(nums)\\n        nums = list(set(nums))\\n        nums.sort()\\n        n = len(nums)\\n        continuous_segments = []\\n        while i<n:\\n            j = i+1\\n            while j<n and nums[j]==nums[j-1]+1:\\n                j+=1\\n            continuous_segments.append([j-i,i,j-1])\\n            i = j\\n        res = float(\\'inf\\')\\n        for ans,ans_l,ans_r in continuous_segments:\\n            # Find number of points from nums[ans_r]+1 to nums[ans_r]+(initial_length-ans)\\n            right_points = bisect.bisect_right(nums,nums[ans_r]+(initial_length-ans))-bisect.bisect_left(nums,nums[ans_r]+1)\\n            res = min(res, initial_length-(ans+right_points))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938330,
                "title": "c-binary-search-faster-95",
                "content": "**Intuition**\\n- Sort the array\\n- For each element look for elements in range `nums[i] to nums[i] + n`\\n- This means other elements that is not in this range can be left out\\n- We calculate the minimum of those left out elements\\n\\n\\n**Code**\\n```c++\\nint minOperations(vector<int>& nums) {   \\n    int res = INT_MAX, n = nums.size();\\n    sort(begin(nums), end(nums));\\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\\n    for (int i = 0; i < nums.size(); ++i) {\\n        int idx = lower_bound(nums.begin(), nums.end(), nums[i] + n) - nums.begin();\\n        res = min(res, n - (idx - i));\\n    }\\n    return res;\\n}\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nint minOperations(vector<int>& nums) {   \\n    int res = INT_MAX, n = nums.size();\\n    sort(begin(nums), end(nums));\\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\\n    for (int i = 0; i < nums.size(); ++i) {\\n        int idx = lower_bound(nums.begin(), nums.end(), nums[i] + n) - nums.begin();\\n        res = min(res, n - (idx - i));\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919310,
                "title": "simple-binary-search-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort the array and remove all the duplicates since duplicates will definitely needs to change and then apply binary search from every index to the forward part.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we firstly sort the given array and declare a new temporary array to store duplicate free elements in it. This will help us to know only unique elements. Now do the binary search in the temp array to the forward part of the array.\\nHere we need to get diff between largest and smallest element to be equal to the orginal array size minus 1, we store that value in add variable.\\nDuring binary search we consider a index to be the minimum value so that all the later values will be greater than it hence we plus add variable to get the exact range and find out how many element lies in that range and how many left and the left one will be the answer.\\nThe answer will be the minimum among all the left ones.\\n\\n# Complexity\\n- Time complexity:\\n- O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[i-1]){\\n                temp.push_back(nums[i]);\\n            }\\n        }\\n\\n        int add = nums.size()-1;\\n        int mn = INT_MAX;\\n        for(int i=0;i<temp.size();i++){\\n            int lo = i;\\n            int hi = temp.size()-1;\\n            while(hi - lo > 1){\\n                int mid = (lo+hi)/2;\\n                if(temp[mid] <= temp[i]+add){\\n                    lo = mid;\\n                }else{\\n                    hi = mid-1;\\n                }\\n            }\\n            if(temp[hi] <= temp[i]+add){\\n                int diff = hi-i;\\n                mn = min(mn, add-diff);\\n            }else{\\n                int diff = lo-i;\\n                mn = min(mn, add-diff);\\n            }\\n        }\\n\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[i-1]){\\n                temp.push_back(nums[i]);\\n            }\\n        }\\n\\n        int add = nums.size()-1;\\n        int mn = INT_MAX;\\n        for(int i=0;i<temp.size();i++){\\n            int lo = i;\\n            int hi = temp.size()-1;\\n            while(hi - lo > 1){\\n                int mid = (lo+hi)/2;\\n                if(temp[mid] <= temp[i]+add){\\n                    lo = mid;\\n                }else{\\n                    hi = mid-1;\\n                }\\n            }\\n            if(temp[hi] <= temp[i]+add){\\n                int diff = hi-i;\\n                mn = min(mn, add-diff);\\n            }else{\\n                int diff = lo-i;\\n                mn = min(mn, add-diff);\\n            }\\n        }\\n\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627296,
                "title": "o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n       int n=nums.size(), m,i, j,k, ans=n;\\n    set<int>s;\\n    m=n;\\n        for(i = 0 ; i < n ; i++){\\n    \\n      s.insert(nums[i]);\\n          \\n        }\\n        n=s.size();\\n        \\n        int a[n];\\n        i=0;\\n        for(auto it:s){\\n            a[i++]=it;\\n        }\\n\\n        \\n        for(i = 0;i < n; i++){\\n    //    j=upper_bound(a,a+n,a[i])-a;\\n       k=lower_bound(a,a+n,a[i]-m+1)-a;\\n       j=n-i-1;\\n    \\n       ans=min(ans,j+k+m-n);}\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n       int n=nums.size(), m,i, j,k, ans=n;\\n    set<int>s;\\n    m=n;\\n        for(i = 0 ; i < n ; i++){\\n    \\n      s.insert(nums[i]);\\n          \\n        }\\n        n=s.size();\\n        \\n        int a[n];\\n        i=0;\\n        for(auto it:s){\\n            a[i++]=it;\\n        }\\n\\n        \\n        for(i = 0;i < n; i++){\\n    //    j=upper_bound(a,a+n,a[i])-a;\\n       k=lower_bound(a,a+n,a[i]-m+1)-a;\\n       j=n-i-1;\\n    \\n       ans=min(ans,j+k+m-n);}\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387418,
                "title": "just-binary-search-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int len=nums.size();\\n        set<int> s(nums.begin(),nums.end());\\n        int n=s.size();\\n        vector<int> arr;\\n        for(auto x:s){\\n            arr.push_back(x);\\n        }\\n        vector<int> dp(n);\\n        dp[0]=1;\\n        int subans=1;\\n        for(int i=1;i<n;i++){\\n            int idx=lower_bound(arr.begin(),arr.begin()+i,arr[i]-len+1)-arr.begin();\\n            if(idx==i){\\n                dp[i]=1;\\n            }\\n            else dp[i]=i-idx+1;\\n            subans=max(subans,dp[i]);\\n        }\\n        return len-subans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int len=nums.size();\\n        set<int> s(nums.begin(),nums.end());\\n        int n=s.size();\\n        vector<int> arr;\\n        for(auto x:s){\\n            arr.push_back(x);\\n        }\\n        vector<int> dp(n);\\n        dp[0]=1;\\n        int subans=1;\\n        for(int i=1;i<n;i++){\\n            int idx=lower_bound(arr.begin(),arr.begin()+i,arr[i]-len+1)-arr.begin();\\n            if(idx==i){\\n                dp[i]=1;\\n            }\\n            else dp[i]=i-idx+1;\\n            subans=max(subans,dp[i]);\\n        }\\n        return len-subans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440042,
                "title": "java-binary-search-space-o-1",
                "content": "```\\n//Runtime: 77 ms, faster than 57.58% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //Memory Usage: 60.2 MB, less than 93.94% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //Binary Search\\n    //Time: O(N*lgN + N + N*lgN); Space:O(1);\\n    public int minOperations(int[] nums) {\\n        if(nums.length == 1) return 0;\\n\\n        //Time: O(N*lgN)\\n        Arrays.sort(nums);\\n\\n        //Time: O(N)\\n        //unique\\n        int uniqueLen = 1;\\n        for(int i = 1; i < nums.length; i++)\\n            if (nums[i] != nums[i-1]) nums[uniqueLen++] = nums[i];\\n\\n        //Time: O(N*lgN)\\n        int res = nums.length + 1;\\n        for (int i = 0; i < uniqueLen; i++){\\n            if (i >= res) break;\\n            int right = Math.min(uniqueLen - 1, binarySearchInsert(nums, i, uniqueLen, nums[i] + nums.length - 1));\\n            res = Math.min(res, nums.length - ( right - i + 1));\\n        }\\n        return res;\\n    }\\n\\n    //Time: O(lgN)\\n    public int binarySearchInsert(int[] nums, int from, int to, int target){\\n        while (from <= to){\\n            int mid = (from + to) / 2;\\n            if (nums[mid] == target) return mid;\\n            else if (nums[mid] > target) to = mid - 1;\\n            else from = mid + 1;\\n        }\\n        return to; //to\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n//Runtime: 77 ms, faster than 57.58% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //Memory Usage: 60.2 MB, less than 93.94% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //Binary Search\\n    //Time: O(N*lgN + N + N*lgN); Space:O(1);\\n    public int minOperations(int[] nums) {\\n        if(nums.length == 1) return 0;\\n\\n        //Time: O(N*lgN)\\n        Arrays.sort(nums);\\n\\n        //Time: O(N)\\n        //unique\\n        int uniqueLen = 1;\\n        for(int i = 1; i < nums.length; i++)\\n            if (nums[i] != nums[i-1]) nums[uniqueLen++] = nums[i];\\n\\n        //Time: O(N*lgN)\\n        int res = nums.length + 1;\\n        for (int i = 0; i < uniqueLen; i++){\\n            if (i >= res) break;\\n            int right = Math.min(uniqueLen - 1, binarySearchInsert(nums, i, uniqueLen, nums[i] + nums.length - 1));\\n            res = Math.min(res, nums.length - ( right - i + 1));\\n        }\\n        return res;\\n    }\\n\\n    //Time: O(lgN)\\n    public int binarySearchInsert(int[] nums, int from, int to, int target){\\n        while (from <= to){\\n            int mid = (from + to) / 2;\\n            if (nums[mid] == target) return mid;\\n            else if (nums[mid] > target) to = mid - 1;\\n            else from = mid + 1;\\n        }\\n        return to; //to\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386079,
                "title": "c-sorting-sliding-window",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>a;\\n        set<int>s;\\n        for(auto x:nums) s.insert(x);\\n        for(auto x:s) a.push_back(x);\\n        int p=a.size();\\n        int left=0,right=0;\\n        int minn=1e9;\\n        while(right<p){\\n            while(right<p&&a[right]-a[left]<=n-1) right++;\\n            minn=min(minn,n-right+left);\\n            if(right<p){\\n                while(left<=right&&a[right]-a[left]>n-1) left++;\\n            }\\n        }\\n        minn=min(minn,n-right+left);\\n        return minn;\\n    }\\n};\\n",
                "solutionTags": [
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>a;\\n        set<int>s;\\n        for(auto x:nums) s.insert(x);\\n        for(auto x:s) a.push_back(x);\\n        int p=a.size();\\n        int left=0,right=0;\\n        int minn=1e9;\\n        while(right<p){\\n            while(right<p&&a[right]-a[left]<=n-1) right++;\\n            minn=min(minn,n-right+left);\\n            if(right<p){\\n                while(left<=right&&a[right]-a[left]>n-1) left++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2315148,
                "title": "python-o-n-log-n-two-pointers",
                "content": "```python\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        m = len(nums)\\n        \\n        best_ans = float(\\'inf\\')\\n        i = 0\\n        # Keep nums[i:j+1], use operations to replace other elements\\n        j = 0\\n        for i in range(m):\\n            while j < m and nums[j] - nums[i] <= n - 1:\\n                j += 1\\n            j -= 1\\n            ans = n - (j - i + 1)\\n            best_ans = min(best_ans, ans)\\n        return best_ans\\n```            \\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        m = len(nums)\\n        \\n        best_ans = float(\\'inf\\')\\n        i = 0\\n        # Keep nums[i:j+1], use operations to replace other elements\\n        j = 0\\n        for i in range(m):\\n            while j < m and nums[j] - nums[i] <= n - 1:\\n                j += 1\\n            j -= 1\\n            ans = n - (j - i + 1)\\n            best_ans = min(best_ans, ans)\\n        return best_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913577,
                "title": "c-easy-bs-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums) {\\n\\t\\t\\t int n=nums.size();\\n\\t\\t\\t set<int> st;\\n\\t\\t\\t for(auto &it: nums) st.insert(it);\\n\\t\\t\\t vector<int> v(st.begin(),st.end());\\n\\t\\t\\t int ans=INT_MAX;\\n\\t\\t\\t for(int i=0;i<v.size();i++){\\n\\t\\t\\t\\t  int last=v[i]+n-1;\\n\\t\\t\\t\\t  int it1=i;\\n\\t\\t\\t\\t  auto it2=lower_bound(v.begin(),v.end(),last);\\n\\t\\t\\t\\t  int present;\\n\\t\\t\\t\\t  if(it2==v.end() or *(it2)!=(last))\\n\\t\\t\\t\\t   present=(it2-v.begin())-it1;\\n\\t\\t\\t\\t  else\\n\\t\\t\\t\\t\\t present=(it2-v.begin())-it1+1; \\n\\t\\t\\t\\t  // cout<<present<<\" \";\\n\\t\\t\\t\\t  ans=min(ans,n-present);\\n\\t\\t\\t }\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums) {\\n\\t\\t\\t int n=nums.size();\\n\\t\\t\\t set<int> st;\\n\\t\\t\\t for(auto &it: nums) st.insert(it);\\n\\t\\t\\t vector<int> v(st.begin(),st.end());\\n\\t\\t\\t int ans=INT_MAX;\\n\\t\\t\\t for(int i=0;i<v.size();i++){\\n\\t\\t\\t\\t  int last=v[i]+n-1;\\n\\t\\t\\t\\t  int it1=i;\\n\\t\\t\\t\\t  auto it2=lower_bound(v.begin(),v.end(),last);\\n\\t\\t\\t\\t  int present;\\n\\t\\t\\t\\t  if(it2==v.end() or *(it2)!=(last))\\n\\t\\t\\t\\t   present=(it2-v.begin())-it1;\\n\\t\\t\\t\\t  else\\n\\t\\t\\t\\t\\t present=(it2-v.begin())-it1+1; \\n\\t\\t\\t\\t  // cout<<present<<\" \";\\n\\t\\t\\t\\t  ans=min(ans,n-present);\\n\\t\\t\\t }",
                "codeTag": "C++"
            },
            {
                "id": 1890001,
                "title": "c-lower-bound-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int>::iterator it = unique(nums.begin(), nums.end());\\n        int nn = it-nums.begin();\\n        int best = n;\\n        for(int i=0;i<nn;i++) {\\n            int lo = nums[i]-n+1;\\n            int hi = nums[i];\\n            int tot = nums.begin()+i+1-lower_bound(nums.begin(), nums.end(), lo);\\n            best = min(best, n-tot);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int>::iterator it = unique(nums.begin(), nums.end());\\n        int nn = it-nums.begin();\\n        int best = n;\\n        for(int i=0;i<nn;i++) {\\n            int lo = nums[i]-n+1;\\n            int hi = nums[i];\\n            int tot = nums.begin()+i+1-lower_bound(nums.begin(), nums.end(), lo);\\n            best = min(best, n-tot);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822835,
                "title": "simple-solution-o-nlogn-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\\n\\t\\t\\tint k = n-1;\\n\\t\\t\\tint len = 0;\\n\\t\\t\\tfor(auto i = 0; i < nums.size(); i++){\\n\\t\\t\\t\\tint it = upper_bound(nums.begin()+i, nums.end(), nums[i]+k) - nums.begin()-i;\\n\\t\\t\\t\\tlen = max(len, it);\\n\\t\\t\\t}\\n\\t\\t\\treturn n - len;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\\n\\t\\t\\tint k = n-1;\\n\\t\\t\\tint len = 0;\\n\\t\\t\\tfor(auto i = 0; i < nums.size(); i++){\\n\\t\\t\\t\\tint it = upper_bound(nums.begin()+i, nums.end(), nums[i]+k) - nums.begin()-i;\\n\\t\\t\\t\\tlen = max(len, it);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1718455,
                "title": "c-minimum-op-to-make-array-continuous-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end()); // sort the array\\n        vector<int> v; // array to store only unique elements\\n        v.push_back(nums[0]);\\n        for(int i=1; i<n; i++){\\n            if(nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            v.push_back(nums[i]);\\n        }\\n        int res = n;\\n        for(int i=0; i<v.size(); i++){\\n            int end = v[i]+n-1; // considering each v[i] as the minimum element get its maximum by adding it with n-1\\n\\t\\t\\t// now we have to convert all the elements in v to [v[i], end] inclusive. So to do that, we\\'ve to find all those elements that are not already in the range [v[i], end]. \\n            auto ub = upper_bound(v.begin(), v.end(), end); // here upper_bound helps us to find all the elements that are greater than end. \\n            int in_range = (ub-v.begin())-i; // number of elements in range [v[i], end]\\n            res = min(res, n-in_range); // (n - in_range) gives all the elements that needs to be converted.\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end()); // sort the array\\n        vector<int> v; // array to store only unique elements\\n        v.push_back(nums[0]);\\n        for(int i=1; i<n; i++){\\n            if(nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            v.push_back(nums[i]);\\n        }\\n        int res = n;\\n        for(int i=0; i<v.size(); i++){\\n            int end = v[i]+n-1; // considering each v[i] as the minimum element get its maximum by adding it with n-1\\n\\t\\t\\t// now we have to convert all the elements in v to [v[i], end] inclusive. So to do that, we\\'ve to find all those elements that are not already in the range [v[i], end]. \\n            auto ub = upper_bound(v.begin(), v.end(), end); // here upper_bound helps us to find all the elements that are greater than end. \\n            int in_range = (ub-v.begin())-i; // number of elements in range [v[i], end]\\n            res = min(res, n-in_range); // (n - in_range) gives all the elements that needs to be converted.\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691435,
                "title": "inimum-number-of-operations-to-make-array-continuous-c-count-unique-elements",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        sort(begin(A), end(A));\\n        int n = A.size(), ans = n;\\n        \\n        int uniq[n]; // uniq[i] = count of unique elements in range [0, i]\\n        uniq[0] = 1;\\n        \\n        for(int i = 1; i < n; i++){\\n            uniq[i] = A[i] != A[i - 1] ? 1 + uniq[i - 1] : uniq[i - 1];\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            int l = A[i], r = A[i] + n - 1;\\n            int idx = upper_bound(begin(A), end(A), r) - begin(A);\\n            int count = uniq[idx - 1] - (i > 0 ? uniq[i - 1] : 0); // count of unique elements in range [i, idx)\\n            ans = min(ans, n - count); // (n - count) will be count of those elements which will be changed make array continuous\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        sort(begin(A), end(A));\\n        int n = A.size(), ans = n;\\n        \\n        int uniq[n]; // uniq[i] = count of unique elements in range [0, i]\\n        uniq[0] = 1;\\n        \\n        for(int i = 1; i < n; i++){\\n            uniq[i] = A[i] != A[i - 1] ? 1 + uniq[i - 1] : uniq[i - 1];\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            int l = A[i], r = A[i] + n - 1;\\n            int idx = upper_bound(begin(A), end(A), r) - begin(A);\\n            int count = uniq[idx - 1] - (i > 0 ? uniq[i - 1] : 0); // count of unique elements in range [i, idx)\\n            ans = min(ans, n - count); // (n - count) will be count of those elements which will be changed make array continuous\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664166,
                "title": "easy-to-understand-sliding-window",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        end = 0\\n        ans = -1\\n        for i in range(len(nums)):\\n            while end < len(nums):\\n                if nums[i] + n > nums[end]:\\n                    end+=1\\n                else:\\n                    break\\n            ans = max(ans,end - i)\\n        return n - ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        end = 0\\n        ans = -1\\n        for i in range(len(nums)):\\n            while end < len(nums):\\n                if nums[i] + n > nums[end]:\\n                    end+=1\\n                else:\\n                    break\\n            ans = max(ans,end - i)\\n        return n - ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631237,
                "title": "c-using-lower-bound-o-nlogn-solution",
                "content": "On a sorted array lower bound takes LogN time, on an unsorted array it takes O(N) time, hence we sort the array . \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = INT_MAX;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        // new array will be sorted and unique. \\n        vector<int>newarr;\\n        newarr.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!= nums[i-1]) newarr.push_back(nums[i]);\\n        }\\n        // we check lowerbound for each elements. more the elements in the lowerbound to i\\'s\\n        // range, less will be the changes required. \\n        for(int i = 0; i<newarr.size();i++){\\n            auto low = lower_bound(newarr.begin(),newarr.end(),newarr[i]+n);\\n            if(low != newarr.end()){\\n                int index = low - newarr.begin();\\n                int elements = index-i;\\n                int changes = n - elements;\\n                ans = min(changes, ans);\\n            }\\n            else{\\n                int elements = newarr.size()-i;\\n                int changes = n-elements;\\n                ans = min(changes, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = INT_MAX;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        // new array will be sorted and unique. \\n        vector<int>newarr;\\n        newarr.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!= nums[i-1]) newarr.push_back(nums[i]);\\n        }\\n        // we check lowerbound for each elements. more the elements in the lowerbound to i\\'s\\n        // range, less will be the changes required. \\n        for(int i = 0; i<newarr.size();i++){\\n            auto low = lower_bound(newarr.begin(),newarr.end(),newarr[i]+n);\\n            if(low != newarr.end()){\\n                int index = low - newarr.begin();\\n                int elements = index-i;\\n                int changes = n - elements;\\n                ans = min(changes, ans);\\n            }\\n            else{\\n                int elements = newarr.size()-i;\\n                int changes = n-elements;\\n                ans = min(changes, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614171,
                "title": "java-using-treeset-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        int threshold = nums.length-1;\\n        int max = 0;\\n        Arrays.sort(nums);\\n        for(int num:nums) {\\n            while(!set.isEmpty() && num-set.first()>threshold) {\\n                set.remove(set.first());\\n            } \\n            set.add(num);\\n            max = Math.max(max, set.size());   \\n        }\\n        return nums.length-max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        int threshold = nums.length-1;\\n        int max = 0;\\n        Arrays.sort(nums);\\n        for(int num:nums) {\\n            while(!set.isEmpty() && num-set.first()>threshold) {\\n                set.remove(set.first());\\n            } \\n            set.add(num);\\n            max = Math.max(max, set.size());   \\n        }\\n        return nums.length-max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515778,
                "title": "java-solution-with-explanation",
                "content": "## Please upvote if you like the solution\\n\\n```\\nclass Solution {\\n    \\n    public int minOperations(int[] nums) {\\n\\n        /**\\n         * Sort the Array First, so that we can utilise the given property of contiguous which is\\n         *  \"The difference between the maximum element and the minimum element in nums equals nums.length - 1.\"\\n         */\\n        Arrays.sort(nums);\\n\\n        int length = nums.length;\\n        int maxWindowSize = 0;\\n\\n        // Will use this queue to hold the numbers of elements for a window\\n        Deque<Integer> queue = new ArrayDeque<>();\\n\\n        for (int num : nums) {\\n            /**\\n             * If the queue is not empty and the num value is not adhere to the property of contiguous.\\n             * i.e - \"The difference between the maximum element and the minimum element in nums equals nums.length - 1.\"\\n             * Meaning if the array is [1 , 2 , 3 , 4, 5 , 6]\\n             * So smallest element is : 1\\n             * so, a element can be considered as contagious if the length of array is greater than current element - smallest element.\\n             * i.e 4 - 1 = 3 which is less than length 6\\n             *\\n             * In those cases We will remove the values from first from the queue.\\n             */\\n            while (!queue.isEmpty() && num - queue.peekFirst() >= length) {\\n                queue.pollFirst();\\n            }\\n\\n            /**\\n             * If queue is empty or the last element is not same as current element. To avoid duplicate element.\\n             * Note : Here all the elements will be in the range of smallest element and (nums length - 1 + smallest element).\\n             * Other cases is taken care as part of the previous condition\\n             */\\n            if (queue.isEmpty() || queue.peekLast() != num) {\\n                queue.add(num);\\n            }\\n\\n            /**\\n             * Keep tracking of the maximum size of the queue\\n             */\\n            maxWindowSize = Math.max(maxWindowSize, queue.size());\\n        }\\n\\n        /**\\n         * If there are n element and m was the size of the window the no of elements needed is (n - m)\\n         */\\n        return length - maxWindowSize;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int minOperations(int[] nums) {\\n\\n        /**\\n         * Sort the Array First, so that we can utilise the given property of contiguous which is\\n         *  \"The difference between the maximum element and the minimum element in nums equals nums.length - 1.\"\\n         */\\n        Arrays.sort(nums);\\n\\n        int length = nums.length;\\n        int maxWindowSize = 0;\\n\\n        // Will use this queue to hold the numbers of elements for a window\\n        Deque<Integer> queue = new ArrayDeque<>();\\n\\n        for (int num : nums) {\\n            /**\\n             * If the queue is not empty and the num value is not adhere to the property of contiguous.\\n             * i.e - \"The difference between the maximum element and the minimum element in nums equals nums.length - 1.\"\\n             * Meaning if the array is [1 , 2 , 3 , 4, 5 , 6]\\n             * So smallest element is : 1\\n             * so, a element can be considered as contagious if the length of array is greater than current element - smallest element.\\n             * i.e 4 - 1 = 3 which is less than length 6\\n             *\\n             * In those cases We will remove the values from first from the queue.\\n             */\\n            while (!queue.isEmpty() && num - queue.peekFirst() >= length) {\\n                queue.pollFirst();\\n            }\\n\\n            /**\\n             * If queue is empty or the last element is not same as current element. To avoid duplicate element.\\n             * Note : Here all the elements will be in the range of smallest element and (nums length - 1 + smallest element).\\n             * Other cases is taken care as part of the previous condition\\n             */\\n            if (queue.isEmpty() || queue.peekLast() != num) {\\n                queue.add(num);\\n            }\\n\\n            /**\\n             * Keep tracking of the maximum size of the queue\\n             */\\n            maxWindowSize = Math.max(maxWindowSize, queue.size());\\n        }\\n\\n        /**\\n         * If there are n element and m was the size of the window the no of elements needed is (n - m)\\n         */\\n        return length - maxWindowSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507218,
                "title": "share-my-java-solution-using-binary-search",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n         Set<Integer> set = new HashSet<>();\\n         for(int ele: nums){\\n             set.add(ele);\\n         }\\n         List<Integer> list = new ArrayList<>();\\n         for(Integer ele: set){\\n             list.add(ele);\\n         }\\n         Collections.sort(list);\\n         set.clear();\\n         Arrays.sort(nums);\\n         \\n         int min_val = nums.length;\\n         for(int i=0;i<nums.length;i++){\\n             int cur = nums[i];\\n             int index = Collections.binarySearch(list, nums[i]-(nums.length-1));\\n             if(index < 0){\\n                 index = -(index+1);\\n             }\\n             \\n             int cur_index = Collections.binarySearch(list, nums[i]);\\n             int count = nums.length - (cur_index-index+1);\\n             min_val = Math.min(min_val, count);   \\n         }\\n        \\n         return min_val;\\n         \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n         Set<Integer> set = new HashSet<>();\\n         for(int ele: nums){\\n             set.add(ele);\\n         }\\n         List<Integer> list = new ArrayList<>();\\n         for(Integer ele: set){\\n             list.add(ele);\\n         }\\n         Collections.sort(list);\\n         set.clear();\\n         Arrays.sort(nums);\\n         \\n         int min_val = nums.length;\\n         for(int i=0;i<nums.length;i++){\\n             int cur = nums[i];\\n             int index = Collections.binarySearch(list, nums[i]-(nums.length-1));\\n             if(index < 0){\\n                 index = -(index+1);\\n             }\\n             \\n             int cur_index = Collections.binarySearch(list, nums[i]);\\n             int count = nums.length - (cur_index-index+1);\\n             min_val = Math.min(min_val, count);   \\n         }\\n        \\n         return min_val;\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493674,
                "title": "a-few-solutions",
                "content": "Sort the input array `A`.  Find the `best` continuous run\\'s \"fixup cost\" starting at each `i`<sup>th</sup> index by performing a binary search on the continuous run\\'s ending value (ie. `start + N - 1`) to determine the end index `j` non-inclusive.  We know the run `A[i..j)` is continuous so it\\'s length is tracked by `ok`.  It follows the \"fixup cost\" is then the count of elements which are *not* `ok` (ie. `N - ok`).\\n\\nNote: `ng` == *not* good (ie. *not* `ok`, this is the \"fixup cost\")\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun upperBound(A: IntArray, target: Int): Int {\\n        val N = A.size\\n        var i = 0\\n        var j = N\\n        while (i < j) {\\n            val k = (i + j + 1) / 2\\n            if (k < N && A[k] <= target)\\n                i = k\\n            else\\n                j = k - 1\\n        }\\n        return j + 1\\n    }\\n    fun minOperations(A_: IntArray): Int {\\n        var best = (1e9 + 7).toInt()\\n        var N = A_.size\\n        var A = A_.toSet().toIntArray()\\n        A.sort()\\n        for (i in 0 until A.size) {\\n            var beg = A[i]\\n            var end = A[i] + N - 1\\n            var j = upperBound(A, end)\\n            var ok = j - i\\n            var ng = N - ok\\n            best = Math.min(best, ng)\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minOperations = (A, best = Infinity) => {\\n    let N = A.length;\\n    A = [...new Set(A)].sort((a, b) => a - b);\\n    for (let i = 0; i < A.length; ++i) {\\n        let beg = A[i],\\n            end = A[i] + N - 1;\\n        let j = _.sortedLastIndex(A, end);\\n        let ok = j - i,\\n            ng = N - ok;\\n        best = Math.min(best, ng);\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minOperations(self, A: List[int], best = float(\\'inf\\')) -> int:\\n        N = len(A)\\n        A = sorted(set(A))\\n        for i in range(len(A)):\\n            beg = A[i]\\n            end = A[i] + N - 1\\n            j = bisect_right(A, end)\\n            ok = j - i\\n            ng = N - ok\\n            best = min(best, ng)\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = set<int>;\\n    int minOperations(VI& A, int best = 1e9 + 7) {\\n        int N = A.size();\\n        Set S{ A.begin(), A.end() };\\n        for (auto it = S.begin(); it != S.end(); ++it) {\\n            int i = distance(S.begin(), it),\\n                j = distance(S.begin(), S.upper_bound(*it + N - 1));\\n            int ok = j - i,\\n                ng = N - ok;\\n            best = min(best, ng);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun upperBound(A: IntArray, target: Int): Int {\\n        val N = A.size\\n        var i = 0\\n        var j = N\\n        while (i < j) {\\n            val k = (i + j + 1) / 2\\n            if (k < N && A[k] <= target)\\n                i = k\\n            else\\n                j = k - 1\\n        }\\n        return j + 1\\n    }\\n    fun minOperations(A_: IntArray): Int {\\n        var best = (1e9 + 7).toInt()\\n        var N = A_.size\\n        var A = A_.toSet().toIntArray()\\n        A.sort()\\n        for (i in 0 until A.size) {\\n            var beg = A[i]\\n            var end = A[i] + N - 1\\n            var j = upperBound(A, end)\\n            var ok = j - i\\n            var ng = N - ok\\n            best = Math.min(best, ng)\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet minOperations = (A, best = Infinity) => {\\n    let N = A.length;\\n    A = [...new Set(A)].sort((a, b) => a - b);\\n    for (let i = 0; i < A.length; ++i) {\\n        let beg = A[i],\\n            end = A[i] + N - 1;\\n        let j = _.sortedLastIndex(A, end);\\n        let ok = j - i,\\n            ng = N - ok;\\n        best = Math.min(best, ng);\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, A: List[int], best = float(\\'inf\\')) -> int:\\n        N = len(A)\\n        A = sorted(set(A))\\n        for i in range(len(A)):\\n            beg = A[i]\\n            end = A[i] + N - 1\\n            j = bisect_right(A, end)\\n            ok = j - i\\n            ng = N - ok\\n            best = min(best, ng)\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = set<int>;\\n    int minOperations(VI& A, int best = 1e9 + 7) {\\n        int N = A.size();\\n        Set S{ A.begin(), A.end() };\\n        for (auto it = S.begin(); it != S.end(); ++it) {\\n            int i = distance(S.begin(), it),\\n                j = distance(S.begin(), S.upper_bound(*it + N - 1));\\n            int ok = j - i,\\n                ng = N - ok;\\n            best = min(best, ng);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493235,
                "title": "simple-sliding-window-without-using-extra-space-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n    int mini=nums.size();\\n    int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        int j=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            while(j<nums.size() && nums[j]-nums[i]<=n-1)\\n                j++;\\n            mini=min(mini,n-j+i);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n    int mini=nums.size();\\n    int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        int j=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            while(j<nums.size() && nums[j]-nums[i]<=n-1)\\n                j++;\\n            mini=min(mini,n-j+i);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481315,
                "title": "python-deque-linear",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        uniq = list(set(nums))\\n        \\n        q=deque()\\n        n=len(nums)\\n        ans=n-1\\n        uniq.sort()\\n        for x in uniq:\\n            while q and x-q[0]>=n:\\n                q.popleft()\\n            q.append(x)\\n            ans=min(ans, n-len(q))\\n        return ans\\n            \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        uniq = list(set(nums))\\n        \\n        q=deque()\\n        n=len(nums)\\n        ans=n-1\\n        uniq.sort()\\n        for x in uniq:\\n            while q and x-q[0]>=n:\\n                q.popleft()\\n            q.append(x)\\n            ans=min(ans, n-len(q))\\n        return ans\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476962,
                "title": "scala-functional-solution-using-sliding-window-foldleft",
                "content": "This is a pretty concise & readable Scala version for the sliding window solution explained in the more popular discussion threads. \\n\\nA quick exit condition `if (newEnd == m) return math.min(min, swapsNeeded)` can be added inside the fold loop, but doesn\\'t seem to provide any noticeable runtime benefit for the test cases executed at the time of this writing.\\n```\\n  def minOperations(nums: Array[Int]): Int = {\\n    val unique = nums.distinct.sorted\\n    val (n, m) = (nums.length, unique.length)\\n\\n    (0 until m).foldLeft(n, 0) {\\n      case ((min, end), start) =>\\n        val newEnd = (end until m).find(i => unique(i) >= unique(start) + n).getOrElse(m)\\n        val alreadyInWindow = newEnd - start\\n        val swapsNeeded = n - alreadyInWindow\\n        (math.min(min, swapsNeeded), newEnd)\\n    }._1\\n  }\\n```",
                "solutionTags": [
                    "Scala",
                    "Sliding Window"
                ],
                "code": "```\\n  def minOperations(nums: Array[Int]): Int = {\\n    val unique = nums.distinct.sorted\\n    val (n, m) = (nums.length, unique.length)\\n\\n    (0 until m).foldLeft(n, 0) {\\n      case ((min, end), start) =>\\n        val newEnd = (end until m).find(i => unique(i) >= unique(start) + n).getOrElse(m)\\n        val alreadyInWindow = newEnd - start\\n        val swapsNeeded = n - alreadyInWindow\\n        (math.min(min, swapsNeeded), newEnd)\\n    }._1\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1473151,
                "title": "c-solution-deque",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        deque<int>dq;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            dq.push_back(nums[i]);\\n            while(dq.back()-dq.front()>n-1)\\n            {\\n                dq.pop_front();\\n            }\\n            ans=max(ans,(int)dq.size());\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        deque<int>dq;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            dq.push_back(nums[i]);\\n            while(dq.back()-dq.front()>n-1)\\n            {\\n                dq.pop_front();\\n            }\\n            ans=max(ans,(int)dq.size());\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471741,
                "title": "does-java-have-any-method-to-make-an-array-all-element-unique",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int x : nums){\\n            set.add(x);\\n        }\\n        int size = set.size();\\n        int[] t = new int[size];\\n        int idx = 0;\\n        for(int x : set){\\n            t[idx++] = x;\\n        }\\n        Arrays.sort(t);\\n        int i = 0 , j = 0;\\n        int ret = Integer.MAX_VALUE;\\n        while(i < size){\\n            while(j < size && t[j] <= t[i] + nums.length-1){\\n                j++;\\n            }\\n            int cnt = j-i;\\n            ret = Math.min(ret , nums.length - cnt);\\n            i++;\\n        }\\n        return ret;  \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int x : nums){\\n            set.add(x);\\n        }\\n        int size = set.size();\\n        int[] t = new int[size];\\n        int idx = 0;\\n        for(int x : set){\\n            t[idx++] = x;\\n        }\\n        Arrays.sort(t);\\n        int i = 0 , j = 0;\\n        int ret = Integer.MAX_VALUE;\\n        while(i < size){\\n            while(j < size && t[j] <= t[i] + nums.length-1){\\n                j++;\\n            }\\n            int cnt = j-i;\\n            ret = Math.min(ret , nums.length - cnt);\\n            i++;\\n        }\\n        return ret;  \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471639,
                "title": "c-2009-minimum-number-of-operations-to-make-array-continuous",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), ans = 0; \\n        sort(nums.begin(), nums.end()); \\n        nums.erase(unique(nums.begin(), nums.end()), nums.end()); // remove duplicates\\n        \\n        for (int i = 0, ii = 0; i < nums.size(); ++i) {\\n            if (nums[i] - nums[ii] >= n) ++ii; \\n            ans = max(ans, i - ii + 1); \\n        }\\n        return n - ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), ans = 0; \\n        sort(nums.begin(), nums.end()); \\n        nums.erase(unique(nums.begin(), nums.end()), nums.end()); // remove duplicates\\n        \\n        for (int i = 0, ii = 0; i < nums.size(); ++i) {\\n            if (nums[i] - nums[ii] >= n) ++ii; \\n            ans = max(ans, i - ii + 1); \\n        }\\n        return n - ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471065,
                "title": "python-10-lines-concise-sortedlist",
                "content": "Idea :\\nSearch through each span to find the span that covers the most numbers. (O(range(nums[i]) ~= 10 ** 9), too long)\\n-> If a span is a minimum one, the largest number in the span must be present in the original array. (Reduce above to O(len(nums) ~= 10 ** 5, ok)\\n-> Finding the coverage of a span is O(lg(range(num[i]))), which can be done by substracting the index in between the large bisect value and the small bisect value in SortedList.\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        from sortedcontainers import SortedList\\n        l = len(nums)\\n        nums = SortedList(set(nums))\\n        ret = l\\n        for n in nums:\\n            count = nums.bisect_right(n) - nums.bisect_left(n-l+1)\\n            ret = min(ret,l - count)\\n        return ret \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        from sortedcontainers import SortedList\\n        l = len(nums)\\n        nums = SortedList(set(nums))\\n        ret = l\\n        for n in nums:\\n            count = nums.bisect_right(n) - nums.bisect_left(n-l+1)\\n            ret = min(ret,l - count)\\n        return ret \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470995,
                "title": "simple-solution-in-c",
                "content": "Simple solution using order statistics tree.\\nRefered [this](https://codeforces.com/blog/entry/11080) \\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\n\\n\\nusing namespace __gnu_pbds;\\n\\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) \\n    {\\n        Tree<int>s;\\n        \\n        for( auto x : a )\\n            s.insert(x);\\n        \\n        int ans = INT_MAX , n = a.size();\\n        \\n        for( auto x : a )\\n        {\\n            int k1 = s.order_of_key(x+n);\\n            k1 -= s.order_of_key(x);\\n            \\n            ans = min( ans , n-k1 );\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\n\\n\\nusing namespace __gnu_pbds;\\n\\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) \\n    {\\n        Tree<int>s;\\n        \\n        for( auto x : a )\\n            s.insert(x);\\n        \\n        int ans = INT_MAX , n = a.size();\\n        \\n        for( auto x : a )\\n        {\\n            int k1 = s.order_of_key(x+n);\\n            k1 -= s.order_of_key(x);\\n            \\n            ans = min( ans , n-k1 );\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1470985,
                "title": "java-treemap-ceiling-and-floor-with-prefix-sum-solution",
                "content": "In this solution I am trying to find out the max possible range within the current element\\'s ceil value in array  (i.e. +n-1) and similarly for the lower value and the corresponding bounds. So either of them might be having the maximum number of uniq elements in the array. This is being done with prefix sum array of uniq elements until index i;\\nThis we compare with the max as of now and then finally we return n- max.\\n\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        TreeMap<Integer, Integer> lp =  new TreeMap();\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int[] uniq = new int[n];\\n        int uq=0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(!lp.containsKey(nums[i])) uq++;\\n            uniq[i] = uq;\\n            lp.put(nums[i], i);\\n        }\\n        int max = 0;\\n        for(int elem : lp.keySet()) {\\n            Map.Entry<Integer, Integer> low = lp.ceilingEntry(elem - n + 1);\\n            Map.Entry<Integer, Integer> hi = lp.floorEntry(elem + n - 1);\\n            int hiLow = lp.ceilingEntry(hi.getKey() - n + 1).getValue();\\n            int lowHi = lp.floorEntry(low.getKey() + n - 1).getValue();\\n            int cmr = Math.max(uniq[lowHi] - uniq[low.getValue()] + 1, uniq[hi.getValue()] - uniq[hiLow] + 1);\\n            max = Math.max(max, cmr);\\n        }\\n        return n- max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        TreeMap<Integer, Integer> lp =  new TreeMap();\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int[] uniq = new int[n];\\n        int uq=0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(!lp.containsKey(nums[i])) uq++;\\n            uniq[i] = uq;\\n            lp.put(nums[i], i);\\n        }\\n        int max = 0;\\n        for(int elem : lp.keySet()) {\\n            Map.Entry<Integer, Integer> low = lp.ceilingEntry(elem - n + 1);\\n            Map.Entry<Integer, Integer> hi = lp.floorEntry(elem + n - 1);\\n            int hiLow = lp.ceilingEntry(hi.getKey() - n + 1).getValue();\\n            int lowHi = lp.floorEntry(low.getKey() + n - 1).getValue();\\n            int cmr = Math.max(uniq[lowHi] - uniq[low.getValue()] + 1, uniq[hi.getValue()] - uniq[hiLow] + 1);\\n            max = Math.max(max, cmr);\\n        }\\n        return n- max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470979,
                "title": "python-2-solutions-binary-search-without-bisect-and-brute-force",
                "content": "Sorting and binary search\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n\\t\\t\\n        answer = float(\"+inf\")\\n        for i, start in enumerate(nums):\\n            \\n            search = start + n - 1  # number to search\\n            start, end = 0, len(nums)-1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                if nums[mid] <= search:\\n                    idx = mid\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n            \\n            changes = idx - i + 1\\n            answer = min(answer, n - changes)\\n        return answer\\n                \\n```\\n\\nBrute force solution - TLE\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        answer = float(\"+inf\")\\n        for i in range(len(nums)):\\n            minimum = nums[i]\\n            used = set()\\n            total = 0\\n            for j in range(len(nums)):\\n                if minimum <= nums[j] <= minimum + len(nums) - 1:\\n                    if nums[j] in used:\\n                        total += 1\\n                    else:\\n                        used.add(nums[j])\\n                else:\\n                    total += 1\\n            answer = min(answer, total)\\n            \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n\\t\\t\\n        answer = float(\"+inf\")\\n        for i, start in enumerate(nums):\\n            \\n            search = start + n - 1  # number to search\\n            start, end = 0, len(nums)-1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                if nums[mid] <= search:\\n                    idx = mid\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n            \\n            changes = idx - i + 1\\n            answer = min(answer, n - changes)\\n        return answer\\n                \\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        answer = float(\"+inf\")\\n        for i in range(len(nums)):\\n            minimum = nums[i]\\n            used = set()\\n            total = 0\\n            for j in range(len(nums)):\\n                if minimum <= nums[j] <= minimum + len(nums) - 1:\\n                    if nums[j] in used:\\n                        total += 1\\n                    else:\\n                        used.add(nums[j])\\n                else:\\n                    total += 1\\n            answer = min(answer, total)\\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470972,
                "title": "sliding-window-python",
                "content": "Check the # of unique nums within the range==len(n)\\n\\n\\tn=len(nums)\\n        \\n\\tnums=sorted(set(nums))\\n\\n\\tres=n-1\\n\\n\\tl=0\\n\\tfor r in range(1,len(nums)):\\n\\t\\twhile nums[r]-nums[l]>=n:\\n\\t\\t\\tl+=1\\n\\t\\tres=min(res,n-(r-l+1))\\n\\n\\treturn  res\\n\\n\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "Check the # of unique nums within the range==len(n)\\n\\n\\tn=len(nums)\\n        \\n\\tnums=sorted(set(nums))\\n\\n\\tres=n-1\\n\\n\\tl=0\\n\\tfor r in range(1,len(nums)):\\n\\t\\twhile nums[r]-nums[l]>=n:\\n\\t\\t\\tl+=1\\n\\t\\tres=min(res,n-(r-l+1))\\n\\n\\treturn  res\\n\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1470925,
                "title": "6-lines-python-solution",
                "content": "For each unique number x, how many unique nums are covered in range (x, x + len(nums))?\\n```python\\narr = sorted(set(nums))\\nresult = inf\\nfor i, num in enumerate(arr):\\n\\tj = bisect_right(arr, num + len(nums) - 1)\\n\\tresult = min(result, len(nums) - (j - i))\\nreturn result\\n```",
                "solutionTags": [],
                "code": "```python\\narr = sorted(set(nums))\\nresult = inf\\nfor i, num in enumerate(arr):\\n\\tj = bisect_right(arr, num + len(nums) - 1)\\n\\tresult = min(result, len(nums) - (j - i))\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470923,
                "title": "easy-c-solution-with-explanation-and-comments",
                "content": "In this ques I checked all the window of all nums.size()-1 and selected the one which has most no of unique elements in it and we will try to make all element in this range \\nThe ans will be nums.size - size of window as these will be the elements which are outside window and we will make it inside or are duplicate inside this range\\n\\nEg  1 2 3 3 100 100\\nMax no of element in 6 size window is 3 \\nSo ans is 6-3 =3\\nWe will make 1 2 3 4 5 6\\n\\nWe are using deque for measuring no of element in a window\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        vector<int>temp;\\n          sort(nums.begin(),nums.end());\\n         temp.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){                                   // doing this to make all element unique\\n            if(temp[temp.size()-1]==nums[i])\\n                continue;\\n            else\\n              temp.push_back(nums[i]);\\n                \\n        }\\n        deque<int>d;\\n        int ans=0;\\n        for(int i=0;i<temp.size();i++){\\n            d.push_back(temp[i]);\\n            while( d.back()- d.front()> (nums.size()-1)  )     // size of the window is nums.size\\n                d.pop_front();\\n            int c=d.size();\\n            ans=max(ans,c);\\n            \\n        }\\n        \\n        return nums.size()-ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        vector<int>temp;\\n          sort(nums.begin(),nums.end());\\n         temp.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){                                   // doing this to make all element unique\\n            if(temp[temp.size()-1]==nums[i])\\n                continue;\\n            else\\n              temp.push_back(nums[i]);\\n                \\n        }\\n        deque<int>d;\\n        int ans=0;\\n        for(int i=0;i<temp.size();i++){\\n            d.push_back(temp[i]);\\n            while( d.back()- d.front()> (nums.size()-1)  )     // size of the window is nums.size\\n                d.pop_front();\\n            int c=d.size();\\n            ans=max(ans,c);\\n            \\n        }\\n        \\n        return nums.size()-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470876,
                "title": "kotlin-simple-short-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    fun minOperations(nums: IntArray): Int {\\n        val distinctNums = nums.sorted().distinct()\\n        var maxCount = 1\\n        var firstNumIndex = 0\\n        for (i in 1..distinctNums.lastIndex) {\\n            while (distinctNums[i] - distinctNums[firstNumIndex] >= nums.size) {\\n                ++firstNumIndex\\n            }\\n            maxCount = maxOf(maxCount, i - firstNumIndex + 1)\\n        }\\n        return nums.size - maxCount\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minOperations(nums: IntArray): Int {\\n        val distinctNums = nums.sorted().distinct()\\n        var maxCount = 1\\n        var firstNumIndex = 0\\n        for (i in 1..distinctNums.lastIndex) {\\n            while (distinctNums[i] - distinctNums[firstNumIndex] >= nums.size) {\\n                ++firstNumIndex\\n            }\\n            maxCount = maxOf(maxCount, i - firstNumIndex + 1)\\n        }\\n        return nums.size - maxCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470875,
                "title": "simple-10-line-c-solution-sliding-window",
                "content": "A simple observation: we can solve this problem by enumerating answers starting with each number and choosing the smallest one amoung them. If we do it without any optimization, it would take O(n^2)\\xA0time, because finding each answer needs to traverse the whole array once. But we don\\'t actually need to do that since answers are not totally independent. So here comes the solution.\\n\\nWe can sort the array and remove duplicated numbers (duplicated numbers are useless in this problem), and use two variables to \"bound\" the valid range (numbers that do not need to be operated), and adjust the right bound while moving the left one. That\\'s why it\\'s called \"sliding window\". During each iteration, we record the best answer so far.\\n\\nTime complexity: O(nlogn).\\n\\n```\\nclass Solution {\\n   public:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        int ans = n;\\n        for (int l = 0, r = 0; l < nums.size(); l++) {\\n            while (r < nums.size() - 1 && nums[r + 1] - nums[l] <= n - 1) r++;\\n            ans = min(ans, n - (r - l + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        int ans = n;\\n        for (int l = 0, r = 0; l < nums.size(); l++) {\\n            while (r < nums.size() - 1 && nums[r + 1] - nums[l] <= n - 1) r++;\\n            ans = min(ans, n - (r - l + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989982,
                "title": "minimum-operations-easy-cpp-solution-sliding-window-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code aims to find the minimum number of operations needed to make all elements in the input vector nums distinct. An operation involves either increasing or decreasing an element\\'s value by any positive integer.\\n\\nThe code begins by creating a set<int> called st to store unique elements from the input nums. This step ensures that we only consider distinct elements in the subsequent operations.\\n\\nThe unique elements are then copied from the set st into a vector vp. The vp vector is sorted in ascending order, which will be helpful in the next steps.\\n\\nThe code uses a sliding window approach to find the longest subsequence of vp such that the difference between the maximum and minimum elements in the subsequence is less than or equal to size - 1. Here, size represents the size of the input vector nums.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlp and rp are initialized to 0. lp represents the left pointer of the sliding window, and rp represents the right pointer.\\n\\nThe while loop inside the for loop moves the right pointer rp to the right as long as the difference between vp[rp] and vp[lp] is less than or equal to size - 1. This ensures that the window contains a valid subsequence.\\n\\nThe mx variable keeps track of the maximum length of such subsequences encountered during the iteration.\\n\\nFinally, the code returns the difference between size and mx. This represents the minimum number of operations required to make all elements in nums distinct. The reasoning is that if we have a subsequence of length mx where the difference between the maximum and minimum elements is less than or equal to size - 1, then we can make the rest of the elements distinct by performing operations on them.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        set<int> st;\\n        vector<int> vp;\\n        int size= nums.size();\\n        for(int i=0; i< nums.size(); i++){\\n            st.insert(nums[i]);\\n        }\\n        for(int val: st){\\n            vp.push_back(val);\\n        }\\n        int n = vp.size();\\n        int lp =0;\\n        int rp =0;\\n        int mx =0;\\n        for (int lp =0; lp< n; lp++){\\n            while(rp< n and vp[rp]- vp[lp]<= size-1){\\n                rp++;\\n            }\\n            mx = max(mx, rp-lp);\\n        }\\n        return size - mx;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        set<int> st;\\n        vector<int> vp;\\n        int size= nums.size();\\n        for(int i=0; i< nums.size(); i++){\\n            st.insert(nums[i]);\\n        }\\n        for(int val: st){\\n            vp.push_back(val);\\n        }\\n        int n = vp.size();\\n        int lp =0;\\n        int rp =0;\\n        int mx =0;\\n        for (int lp =0; lp< n; lp++){\\n            while(rp< n and vp[rp]- vp[lp]<= size-1){\\n                rp++;\\n            }\\n            mx = max(mx, rp-lp);\\n        }\\n        return size - mx;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877273,
                "title": "java-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse sliding window, to find length of max window, which showed most consecutive nos.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the array, to get good idea of min and max elements\\n- Remove duplicates, as they will always cost one replacement\\n- For each element as start, check if next \\'n\\' elements are within range [arr[start], arr[start] + n]\\n    -   if not increment counter\\n- finally compute answer as maxlength of window, which has most consecutive terms\\n\\n# Complexity\\n- Time complexity: $$O(n * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = nums.length;\\n        \\n        List<Integer> uniqueArr = Arrays.stream(nums).\\n                                    boxed().    // int[] to List<Integer>\\n                                    distinct(). // only take unique values\\n                                    sorted().   // sort values\\n                                    collect(Collectors.toList());\\n        \\n        int end = 0;\\n        int maxSlidingWindowLen = Integer.MIN_VALUE;\\n        for(int start = 0; start < uniqueArr.size(); start++) {\\n            // for element start, check if next set of elements are in range within -> expected End elem -> arr[start] + n ]]\\n            while(end < uniqueArr.size() && uniqueArr.get(end) < uniqueArr.get(start) + nums.length)\\n                end++;\\n            maxSlidingWindowLen = Math.max(maxSlidingWindowLen, end - start);\\n        }\\n        return n - maxSlidingWindowLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = nums.length;\\n        \\n        List<Integer> uniqueArr = Arrays.stream(nums).\\n                                    boxed().    // int[] to List<Integer>\\n                                    distinct(). // only take unique values\\n                                    sorted().   // sort values\\n                                    collect(Collectors.toList());\\n        \\n        int end = 0;\\n        int maxSlidingWindowLen = Integer.MIN_VALUE;\\n        for(int start = 0; start < uniqueArr.size(); start++) {\\n            // for element start, check if next set of elements are in range within -> expected End elem -> arr[start] + n ]]\\n            while(end < uniqueArr.size() && uniqueArr.get(end) < uniqueArr.get(start) + nums.length)\\n                end++;\\n            maxSlidingWindowLen = Math.max(maxSlidingWindowLen, end - start);\\n        }\\n        return n - maxSlidingWindowLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865756,
                "title": "java-o-n2-hashset-o-nlogn-sw-approach",
                "content": "### TC - O(n2) - Using HashSet - TLE\\n```\\n    // O(n2) approach considering every element as minimum \\n    public int minOperations(int[] nums){\\n        int n = nums.length;\\n        int min = Integer.MAX_VALUE;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int num : nums){\\n            set.add(num);\\n        }\\n        for(int num : nums){\\n            set.remove(num);\\n            int op = 0;\\n            for(int i = num + 1; i <= num + n - 1; i++){\\n                if(!set.contains(i)){\\n                    op++;\\n                }\\n            }\\n            min = Math.min(min, op);\\n            set.add(num);\\n        }\\n        return min;\\n    }\\n\\n```\\n\\n\\n\\n### TC - O(nlogn) - Using Sliding Window - Accepted\\n```\\n    public int minOperations(int[] nums){\\n       int n = nums.length;\\n\\n       // duplicates will not contribute in making array continous \\n       int[] arr = Arrays.stream(nums).sorted().distinct().toArray();\\n       \\n       int j = 0;\\n       int max = Integer.MIN_VALUE;\\n       // find maxm sliding window size any element outside it need to be change \\n       for(int i = 0; i < arr.length; i++){\\n           int curr = arr[i];\\n           int Uprange = curr + n - 1;\\n           while(j < arr.length && arr[j] <= Uprange){\\n             j++;\\n           }\\n           max = Math.max(max, j - i);\\n       }\\n       return n - max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    // O(n2) approach considering every element as minimum \\n    public int minOperations(int[] nums){\\n        int n = nums.length;\\n        int min = Integer.MAX_VALUE;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int num : nums){\\n            set.add(num);\\n        }\\n        for(int num : nums){\\n            set.remove(num);\\n            int op = 0;\\n            for(int i = num + 1; i <= num + n - 1; i++){\\n                if(!set.contains(i)){\\n                    op++;\\n                }\\n            }\\n            min = Math.min(min, op);\\n            set.add(num);\\n        }\\n        return min;\\n    }\\n\\n```\n```\\n    public int minOperations(int[] nums){\\n       int n = nums.length;\\n\\n       // duplicates will not contribute in making array continous \\n       int[] arr = Arrays.stream(nums).sorted().distinct().toArray();\\n       \\n       int j = 0;\\n       int max = Integer.MIN_VALUE;\\n       // find maxm sliding window size any element outside it need to be change \\n       for(int i = 0; i < arr.length; i++){\\n           int curr = arr[i];\\n           int Uprange = curr + n - 1;\\n           while(j < arr.length && arr[j] <= Uprange){\\n             j++;\\n           }\\n           max = Math.max(max, j - i);\\n       }\\n       return n - max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846681,
                "title": "another-solution-fast-easy-o-1-space-and-o-nlogn-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minOperations ( vector<int>& a ) {\\n      int n = a.size ( ) , ans = 1e6 , r;\\n      if ( n == 1 ) return 0;\\n      sort ( a.begin ( ) , a.end ( ) );\\n      for ( int i = 1; i < n; i++ ) {\\n         if ( a [ i - 1 ] == a [ i ] ) a [ i - 1 ] = 0;\\n         }\\n      sort ( a.begin ( ) , a.end ( ) );\\n      for ( int i = 0; i < n; i++ ) {\\n         if ( a [ i ] == 0 ) continue;\\n         auto it = upper_bound ( a.begin ( ) , a.end ( ) , a [ i ] + n - 1 );\\n         r = n;\\n         if ( it != a.end ( ) ) r = it - a.begin ( );\\n         ans = min ( ans , n - (--r) + i - 1 );\\n         }\\n      return ans;\\n      }\\n   };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minOperations ( vector<int>& a ) {\\n      int n = a.size ( ) , ans = 1e6 , r;\\n      if ( n == 1 ) return 0;\\n      sort ( a.begin ( ) , a.end ( ) );\\n      for ( int i = 1; i < n; i++ ) {\\n         if ( a [ i - 1 ] == a [ i ] ) a [ i - 1 ] = 0;\\n         }\\n      sort ( a.begin ( ) , a.end ( ) );\\n      for ( int i = 0; i < n; i++ ) {\\n         if ( a [ i ] == 0 ) continue;\\n         auto it = upper_bound ( a.begin ( ) , a.end ( ) , a [ i ] + n - 1 );\\n         r = n;\\n         if ( it != a.end ( ) ) r = it - a.begin ( );\\n         ans = min ( ans , n - (--r) + i - 1 );\\n         }\\n      return ans;\\n      }\\n   };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846497,
                "title": "hashing-and-sorting-easy-and-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minOperations ( vector<int>& a ) {\\n      int n = a.size ( ) , ans = 1e6 , k = 0 , r , m [ n ];\\n      if ( n == 1 ) return 0;\\n      sort ( a.begin ( ) , a.end ( ) );\\n      m [ 0 ] = 0;\\n      for ( int i = 1; i < n; i++ ) {\\n         if ( a [ i ] == a [ i - 1 ] ) ++k;\\n         m [ i ] = k;\\n         }\\n      for ( int i = 0; i < n; i++ ) {\\n         auto it = upper_bound ( a.begin ( ) , a.end ( ) , a [ i ] + n - 1 );\\n         r = n;\\n         if ( it != a.end ( ) ) r = it - a.begin ( );\\n         ans = min ( ans , m [ --r ] - m [ i ] + n - r + i - 1 );\\n         }\\n      return ans;\\n      }\\n   };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minOperations ( vector<int>& a ) {\\n      int n = a.size ( ) , ans = 1e6 , k = 0 , r , m [ n ];\\n      if ( n == 1 ) return 0;\\n      sort ( a.begin ( ) , a.end ( ) );\\n      m [ 0 ] = 0;\\n      for ( int i = 1; i < n; i++ ) {\\n         if ( a [ i ] == a [ i - 1 ] ) ++k;\\n         m [ i ] = k;\\n         }\\n      for ( int i = 0; i < n; i++ ) {\\n         auto it = upper_bound ( a.begin ( ) , a.end ( ) , a [ i ] + n - 1 );\\n         r = n;\\n         if ( it != a.end ( ) ) r = it - a.begin ( );\\n         ans = min ( ans , m [ --r ] - m [ i ] + n - r + i - 1 );\\n         }\\n      return ans;\\n      }\\n   };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841887,
                "title": "commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: list[int]) -> int:\\n        n = len(nums)  # find the total length of nums\\n        nums = sorted(set(nums))  # remove duplicates and sort all unique elements\\n\\n        ans = ii = 0\\n        for i, x in enumerate(\\n            nums\\n        ):  # n will be eventually the number of unique elements in nums\\n            if (\\n                x - nums[ii] >= n\\n            ):  # if the difference between x and the start of the sliding window is larger than n\\n                ii += 1  # move the start of the sliding window to the next element\\n            ans = max(\\n                ans, i - ii + 1\\n            )  # always keep the maximum length of the continuous sequence\\n        return (\\n            n - ans\\n        )  # subtract the length of the longest continuous sequence from the total length of nums\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: list[int]) -> int:\\n        n = len(nums)  # find the total length of nums\\n        nums = sorted(set(nums))  # remove duplicates and sort all unique elements\\n\\n        ans = ii = 0\\n        for i, x in enumerate(\\n            nums\\n        ):  # n will be eventually the number of unique elements in nums\\n            if (\\n                x - nums[ii] >= n\\n            ):  # if the difference between x and the start of the sliding window is larger than n\\n                ii += 1  # move the start of the sliding window to the next element\\n            ans = max(\\n                ans, i - ii + 1\\n            )  # always keep the maximum length of the continuous sequence\\n        return (\\n            n - ans\\n        )  # subtract the length of the longest continuous sequence from the total length of nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828362,
                "title": "easy-and-small-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        set<int> st;\\n        for(int num: nums) st.insert(num);\\n        vector<int> arr(st.begin(), st.end());\\n        int min_ops = INT_MAX;\\n        for(int i=0; i<arr.size(); ++i) {\\n            int idx = upper_bound(arr.begin(), arr.end(), arr[i]+n-1)-arr.begin();\\n            min_ops = min(min_ops, n-(idx-i));\\n        }\\n        return min_ops;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        set<int> st;\\n        for(int num: nums) st.insert(num);\\n        vector<int> arr(st.begin(), st.end());\\n        int min_ops = INT_MAX;\\n        for(int i=0; i<arr.size(); ++i) {\\n            int idx = upper_bound(arr.begin(), arr.end(), arr[i]+n-1)-arr.begin();\\n            min_ops = min(min_ops, n-(idx-i));\\n        }\\n        return min_ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811895,
                "title": "python-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\'\\'\\'\\nneed to sort?\\n0       10      100     101\\n(0, 0)  1  2   2\\n\\nIs the answer len(nums) minus the longest contiguous sequence of numbers in nums?\\nNo -> 1 2 3 4 6 7 8 100\\nWhat about for each contiguous sequence we see how many other elements happen to fall into place.\\n\\n1 2 3 4 6 7 8 100\\nFor sequence 1 2 3 4 we can deduce:\\n1 2 3 4 X 6 7 8\\n^ Three other elements happen to fall into place, so 1 replacement needed\\nCan work for\\nX 2 3 4 X 6 7 8 if len(list) is 9\\nProblem is answer isn\\'t necessarily at longest sequence\\n\\nAnother idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that fits the expected value in the number line.\\nproblem:\\n1 2 3 6 7 8 40 50 60\\nSimilar idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that is less than or equal to the calculated max_value\\n1 2 3 6 7 8 40 50 60\\n\\nFor 1 the calculated max is 8, and we can find that at index 5 (using binary search/bisect_left)\\n[1,2,3,5,6]\\n\\nBut you can do another BS in the space of what is an acceptable diff.\\n\\'\\'\\'\\n\\nimport bisect\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        offset = 1\\n        for i, num in enumerate(nums):\\n            expected_end = num + n\\n            while i + offset < len(nums):\\n                if nums[i + offset] < expected_end:\\n                    offset += 1\\n                else:\\n                    break     \\n            else:\\n                break     \\n        return n - offset\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\'\\'\\'\\nneed to sort?\\n0       10      100     101\\n(0, 0)  1  2   2\\n\\nIs the answer len(nums) minus the longest contiguous sequence of numbers in nums?\\nNo -> 1 2 3 4 6 7 8 100\\nWhat about for each contiguous sequence we see how many other elements happen to fall into place.\\n\\n1 2 3 4 6 7 8 100\\nFor sequence 1 2 3 4 we can deduce:\\n1 2 3 4 X 6 7 8\\n^ Three other elements happen to fall into place, so 1 replacement needed\\nCan work for\\nX 2 3 4 X 6 7 8 if len(list) is 9\\nProblem is answer isn\\'t necessarily at longest sequence\\n\\nAnother idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that fits the expected value in the number line.\\nproblem:\\n1 2 3 6 7 8 40 50 60\\nSimilar idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that is less than or equal to the calculated max_value\\n1 2 3 6 7 8 40 50 60\\n\\nFor 1 the calculated max is 8, and we can find that at index 5 (using binary search/bisect_left)\\n[1,2,3,5,6]\\n\\nBut you can do another BS in the space of what is an acceptable diff.\\n\\'\\'\\'\\n\\nimport bisect\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        offset = 1\\n        for i, num in enumerate(nums):\\n            expected_end = num + n\\n            while i + offset < len(nums):\\n                if nums[i + offset] < expected_end:\\n                    offset += 1\\n                else:\\n                    break     \\n            else:\\n                break     \\n        return n - offset\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811886,
                "title": "python-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\'\\'\\'\\nneed to sort?\\n0       10      100     101\\n(0, 0)  1  2   2\\n\\nIs the answer len(nums) minus the longest contiguous sequence of numbers in nums?\\nNo -> 1 2 3 4 6 7 8 100\\nWhat about for each contiguous sequence we see how many other elements happen to fall into place.\\n\\n1 2 3 4 6 7 8 100\\nFor sequence 1 2 3 4 we can deduce:\\n1 2 3 4 X 6 7 8\\n^ Three other elements happen to fall into place, so 1 replacement needed\\nCan work for\\nX 2 3 4 X 6 7 8 if len(list) is 9\\nProblem is answer isn\\'t necessarily at longest sequence\\n\\nAnother idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that fits the expected value in the number line.\\nproblem:\\n1 2 3 6 7 8 40 50 60\\nSimilar idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that is less than or equal to the calculated max_value\\n1 2 3 6 7 8 40 50 60\\n\\nFor 1 the calculated max is 8, and we can find that at index 5 (using binary search/bisect_left)\\n[1,2,3,5,6]\\n\\nBut you can do another BS in the space of what is an acceptable diff.\\n\\'\\'\\'\\n\\nimport bisect\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        running_maximum = 0\\n        for i, num in enumerate(nums):\\n            if len(nums) - i < running_maximum:\\n                break\\n            running_maximum = max(bisect.bisect_left(nums, num + n) - i, running_maximum)\\n        return n - running_maximum\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\'\\'\\'\\nneed to sort?\\n0       10      100     101\\n(0, 0)  1  2   2\\n\\nIs the answer len(nums) minus the longest contiguous sequence of numbers in nums?\\nNo -> 1 2 3 4 6 7 8 100\\nWhat about for each contiguous sequence we see how many other elements happen to fall into place.\\n\\n1 2 3 4 6 7 8 100\\nFor sequence 1 2 3 4 we can deduce:\\n1 2 3 4 X 6 7 8\\n^ Three other elements happen to fall into place, so 1 replacement needed\\nCan work for\\nX 2 3 4 X 6 7 8 if len(list) is 9\\nProblem is answer isn\\'t necessarily at longest sequence\\n\\nAnother idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that fits the expected value in the number line.\\nproblem:\\n1 2 3 6 7 8 40 50 60\\nSimilar idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that is less than or equal to the calculated max_value\\n1 2 3 6 7 8 40 50 60\\n\\nFor 1 the calculated max is 8, and we can find that at index 5 (using binary search/bisect_left)\\n[1,2,3,5,6]\\n\\nBut you can do another BS in the space of what is an acceptable diff.\\n\\'\\'\\'\\n\\nimport bisect\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        running_maximum = 0\\n        for i, num in enumerate(nums):\\n            if len(nums) - i < running_maximum:\\n                break\\n            running_maximum = max(bisect.bisect_left(nums, num + n) - i, running_maximum)\\n        return n - running_maximum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811880,
                "title": "python-5-line-of-code-simple-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\'\\'\\'\\nneed to sort?\\n0       10      100     101\\n(0, 0)  1  2   2\\n\\nIs the answer len(nums) minus the longest contiguous sequence of numbers in nums?\\nNo -> 1 2 3 4 6 7 8 100\\nWhat about for each contiguous sequence we see how many other elements happen to fall into place.\\n\\n1 2 3 4 6 7 8 100\\nFor sequence 1 2 3 4 we can deduce:\\n1 2 3 4 X 6 7 8\\n^ Three other elements happen to fall into place, so 1 replacement needed\\nCan work for\\nX 2 3 4 X 6 7 8 if len(list) is 9\\nProblem is answer isn\\'t necessarily at longest sequence\\n\\nAnother idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that fits the expected value in the number line.\\nproblem:\\n1 2 3 6 7 8 40 50 60\\nSimilar idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that is less than or equal to the calculated max_value\\n1 2 3 6 7 8 40 50 60\\n\\nFor 1 the calculated max is 8, and we can find that at index 5 (using binary search/bisect_left)\\n[1,2,3,5,6]\\n\\nBut you can do another BS in the space of what is an acceptable diff.\\n\\'\\'\\'\\n\\nimport bisect\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        running_maximum = 0\\n        for i, num in enumerate(nums):\\n            running_maximum = max(bisect.bisect_left(nums, num + n) - i, running_maximum)\\n        return n - running_maximum\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\'\\'\\'\\nneed to sort?\\n0       10      100     101\\n(0, 0)  1  2   2\\n\\nIs the answer len(nums) minus the longest contiguous sequence of numbers in nums?\\nNo -> 1 2 3 4 6 7 8 100\\nWhat about for each contiguous sequence we see how many other elements happen to fall into place.\\n\\n1 2 3 4 6 7 8 100\\nFor sequence 1 2 3 4 we can deduce:\\n1 2 3 4 X 6 7 8\\n^ Three other elements happen to fall into place, so 1 replacement needed\\nCan work for\\nX 2 3 4 X 6 7 8 if len(list) is 9\\nProblem is answer isn\\'t necessarily at longest sequence\\n\\nAnother idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that fits the expected value in the number line.\\nproblem:\\n1 2 3 6 7 8 40 50 60\\nSimilar idea: have sorted unique nums. For each num, see how far ahead you can look and still find a number that is less than or equal to the calculated max_value\\n1 2 3 6 7 8 40 50 60\\n\\nFor 1 the calculated max is 8, and we can find that at index 5 (using binary search/bisect_left)\\n[1,2,3,5,6]\\n\\nBut you can do another BS in the space of what is an acceptable diff.\\n\\'\\'\\'\\n\\nimport bisect\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n        running_maximum = 0\\n        for i, num in enumerate(nums):\\n            running_maximum = max(bisect.bisect_left(nums, num + n) - i, running_maximum)\\n        return n - running_maximum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801625,
                "title": "c-10-lines-solution-easy-to-understand",
                "content": "# Code\\n```\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size(),m=0;\\n        set<int> st(nums.begin(),nums.end());\\n        for(auto it=st.begin();it!=st.end();it++){\\n            nums[m++]=*it;\\n        }\\n\\n        int i=0,j=0,maxi=0;\\n        while(j<m){\\n            if(nums[j]>=nums[i]+n) i++;\\n            maxi=max(maxi,j-i+1);\\n            ++j;\\n        }\\n\\n        return n-maxi;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size(),m=0;\\n        set<int> st(nums.begin(),nums.end());\\n        for(auto it=st.begin();it!=st.end();it++){\\n            nums[m++]=*it;\\n        }\\n\\n        int i=0,j=0,maxi=0;\\n        while(j<m){\\n            if(nums[j]>=nums[i]+n) i++;\\n            maxi=max(maxi,j-i+1);\\n            ++j;\\n        }\\n\\n        return n-maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740085,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n// \\nsince continous subarry required. to fullfill 2 conditions \\n1) min-max==n-1 (n)len of array\\n1) all unique number\\n.. points that required attention\\n\\n\\n          [any number can be starting number ]\\n           [if a[i] is stating the all the number less than a[i] and number greater thena a[i]+n-1   ] -- number outside the range if this number is starting as as array number\\n         suppos [2,3,4,5,6]\\n\\n[then if [3,2,4,5,6] the ans for both the array is same]\\n[sorting will help ] in to find the number which are lower than the currentr number and also easy binary search(lower_bound function. is applied)\\n\\n\\n\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwe will move from 0 to n-1 and consider this element as our first element\\nand now we will find the. number that are in the range of the curr number \\nis  number that <=nums[pos]+n-1\\n// that optimizatiion is binary search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlog)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        // number are unique\\n        // max-min =nums;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n       \\n        int ans=n;\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n         int n2=nums.size();\\n        for(int i=0; i<n; i++){\\n            int left=i;\\n    int right=nums.end()-upper_bound(nums.begin(),nums.end(), nums[i]+(n-1));\\n           \\nans=min(ans,left+right);\\n        }\\n       return ans+(n-n2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        // number are unique\\n        // max-min =nums;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n       \\n        int ans=n;\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n         int n2=nums.size();\\n        for(int i=0; i<n; i++){\\n            int left=i;\\n    int right=nums.end()-upper_bound(nums.begin(),nums.end(), nums[i]+(n-1));\\n           \\nans=min(ans,left+right);\\n        }\\n       return ans+(n-n2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694518,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int i = 0, j = 1;\\n        int ans = n-1;\\n        int repeat = 0;\\n        while(j<n) {\\n            if(nums[j] != nums[j-1]) {\\n                while(nums[j] - nums[i] >= n) {\\n                    if(nums[i] == nums[i+1]) repeat--;\\n                    i++;\\n                }\\n                ans = Math.min(ans, n - (j-i+1-repeat));\\n            }\\n            else repeat++;\\n            \\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int i = 0, j = 1;\\n        int ans = n-1;\\n        int repeat = 0;\\n        while(j<n) {\\n            if(nums[j] != nums[j-1]) {\\n                while(nums[j] - nums[i] >= n) {\\n                    if(nums[i] == nums[i+1]) repeat--;\\n                    i++;\\n                }\\n                ans = Math.min(ans, n - (j-i+1-repeat));\\n            }\\n            else repeat++;\\n            \\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649027,
                "title": "c-binary-search-prefix",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans,index,n;\\n    int minOperations(vector<int>& nums) {\\n        n=nums.size();\\n        ans=n-1;\\n        sort(nums.begin(),nums.end());\\n        vector<int> A(nums.size());\\n        A[0]=0;\\n        for(int i=1;i<=nums.size()-1;i++)\\n        {\\n            A[i]=A[i-1];\\n            if(nums[i]==nums[i-1]) A[i]++;\\n        }\\n        for(int i=0;i<=nums.size()-1;i++)\\n        {\\n            index=upper_bound(nums.begin()+i,nums.end(),nums[i]+n-1)-nums.begin()-1;\\n            ans=min(ans,n-(index-i+1)+A[index]-A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans,index,n;\\n    int minOperations(vector<int>& nums) {\\n        n=nums.size();\\n        ans=n-1;\\n        sort(nums.begin(),nums.end());\\n        vector<int> A(nums.size());\\n        A[0]=0;\\n        for(int i=1;i<=nums.size()-1;i++)\\n        {\\n            A[i]=A[i-1];\\n            if(nums[i]==nums[i-1]) A[i]++;\\n        }\\n        for(int i=0;i<=nums.size()-1;i++)\\n        {\\n            index=upper_bound(nums.begin()+i,nums.end(),nums[i]+n-1)-nums.begin()-1;\\n            ans=min(ans,n-(index-i+1)+A[index]-A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604886,
                "title": "simple-binary-search-and-greedy-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust watched the video of some random youtuber. Here is the link:\\nhttps://www.youtube.com/watch?v=Z2DloBdu6NU\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn trying to solve the problem you have already observed one thing that is the array after the operations will have continous numbers with difference of 1 with the adjacent element after sorting. So to do so in minimum number of operations:\\n\\nIn each loop I am taking the minimum non visited number of the vector to be as the first miniumum number of the resultant array which the question is talking about i.e. the array after the operations.\\nSo the last number will be the minimum number + n - 1 and to find that use upper_bound() and now the index to which upper_bound is pointing upto that index will contain all the numbers which will be available in the resultant array, so for finding minimum number of operations we need to maximize it. At the end just do n-ans.\\n\\nOne more thing we are not taking the array with duplicacy to avoid the duplicate values to get count which we are counting that must be in the resultant array so take care of that.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nLog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define append push_back\\n    int minOperations(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int n=v.size();\\n        int ans=0;\\n\\n        set<int> s(v.begin(),v.end());\\n        int m=s.size();\\n        vector<int> a;\\n        for(auto x:s) a.append(x);\\n        \\n        for(int i=0; i<m; i++){\\n            int it = upper_bound(a.begin()+i, a.end(), a[i]+n-1) - a.begin()-i;\\n            ans = max(ans, it);\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define append push_back\\n    int minOperations(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int n=v.size();\\n        int ans=0;\\n\\n        set<int> s(v.begin(),v.end());\\n        int m=s.size();\\n        vector<int> a;\\n        for(auto x:s) a.append(x);\\n        \\n        for(int i=0; i<m; i++){\\n            int it = upper_bound(a.begin()+i, a.end(), a[i]+n-1) - a.begin()-i;\\n            ans = max(ans, it);\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566363,
                "title": "c-prefix-sum-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& v) {\\n        int k = v.size();\\n        map <int, int> mp;\\n        for(auto &it: v) mp[it]++;\\n        vector <int> nums, pre(mp.size());\\n        for(auto &it: mp) nums.push_back(it.first);\\n        \\n        int n = nums.size(), ans = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        pre[0] = mp[nums[0]];\\n        \\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + mp[nums[i]];\\n\\n        int mn = k;\\n        for(int i = 0; i < n; i++) {\\n            int mx = nums[i] + k - 1;\\n            int j = upper_bound(nums.begin(), nums.end(), mx) - nums.begin();\\n            int need = k - (j - i);\\n            \\n            int freqSum = 0;\\n            if(i == 0) freqSum += pre[j - 1];\\n            else freqSum += pre[j - 1] - pre[i - 1];\\n            freqSum -= j - i;\\n            need = min(need, freqSum);\\n            need += pre[n - 1] - pre[j - 1];\\n            if(i - 1 >= 0) need += pre[i - 1];\\n            \\n            mn = min(mn, need);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& v) {\\n        int k = v.size();\\n        map <int, int> mp;\\n        for(auto &it: v) mp[it]++;\\n        vector <int> nums, pre(mp.size());\\n        for(auto &it: mp) nums.push_back(it.first);\\n        \\n        int n = nums.size(), ans = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        pre[0] = mp[nums[0]];\\n        \\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + mp[nums[i]];\\n\\n        int mn = k;\\n        for(int i = 0; i < n; i++) {\\n            int mx = nums[i] + k - 1;\\n            int j = upper_bound(nums.begin(), nums.end(), mx) - nums.begin();\\n            int need = k - (j - i);\\n            \\n            int freqSum = 0;\\n            if(i == 0) freqSum += pre[j - 1];\\n            else freqSum += pre[j - 1] - pre[i - 1];\\n            freqSum -= j - i;\\n            need = min(need, freqSum);\\n            need += pre[n - 1] - pre[j - 1];\\n            if(i - 1 >= 0) need += pre[i - 1];\\n            \\n            mn = min(mn, need);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528484,
                "title": "c-sort-and-slide-to-find-dense-window-just-ignore-duplicates",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int sz = nums.size(), dense = 0;// most dense (maximal unique number count) interval with range <= sz - 1\\n        for(int i = 0, j = 0, count = 0; i < sz && dense < sz - i; ) {\\n            for(; j < sz && nums[j] - nums[i] <= sz-1; ++j) {\\n                count += (j == i || nums[j] != nums[j-1]); \\n            }\\n            dense = max(dense, count);\\n            if(++i < sz)\\n                count -= (i == j || nums[i] != nums[i-1]);\\n        }\\n        return sz - dense;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int sz = nums.size(), dense = 0;// most dense (maximal unique number count) interval with range <= sz - 1\\n        for(int i = 0, j = 0, count = 0; i < sz && dense < sz - i; ) {\\n            for(; j < sz && nums[j] - nums[i] <= sz-1; ++j) {\\n                count += (j == i || nums[j] != nums[j-1]); \\n            }\\n            dense = max(dense, count);\\n            if(++i < sz)\\n                count -= (i == j || nums[i] != nums[i-1]);\\n        }\\n        return sz - dense;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473693,
                "title": "best-way-to-solve-and-well-explained-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int orgLen = nums.size();\\n\\n        int unqEleLen = unique(nums.begin(), nums.end()) - nums.begin();\\n        int maxNum=0, res=0;\\n        \\n        cout<< orgLen << \" \"<< unqEleLen<<endl;\\n        int endIdx=0;\\n        for(int startIdx=0; startIdx < unqEleLen && endIdx < unqEleLen; startIdx++) {\\n            int startingVal=nums[startIdx];\\n            // Window length  = len\\n            // Window max val = startingVal+len\\n            // So end index should not go beyond window len or window max value\\n            while(endIdx < unqEleLen && nums[endIdx] < startingVal+orgLen) {\\n                cout<<endIdx<<endl;\\n                endIdx++;\\n            }\\n            // count the maximum num comes under window rang = ()endIdx - startIdx)\\n            res = max(res, endIdx-startIdx);\\n        }\\n\\n        return orgLen-res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int orgLen = nums.size();\\n\\n        int unqEleLen = unique(nums.begin(), nums.end()) - nums.begin();\\n        int maxNum=0, res=0;\\n        \\n        cout<< orgLen << \" \"<< unqEleLen<<endl;\\n        int endIdx=0;\\n        for(int startIdx=0; startIdx < unqEleLen && endIdx < unqEleLen; startIdx++) {\\n            int startingVal=nums[startIdx];\\n            // Window length  = len\\n            // Window max val = startingVal+len\\n            // So end index should not go beyond window len or window max value\\n            while(endIdx < unqEleLen && nums[endIdx] < startingVal+orgLen) {\\n                cout<<endIdx<<endl;\\n                endIdx++;\\n            }\\n            // count the maximum num comes under window rang = ()endIdx - startIdx)\\n            res = max(res, endIdx-startIdx);\\n        }\\n\\n        return orgLen-res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467596,
                "title": "c-binary-search-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& arr) {\\n        int ans=-1;\\n        int n=arr.size();\\n        vector<int> nums;\\n        unordered_set<int> st;\\n        for(int i=0;i<arr.size();i++){\\n            if(st.find(arr[i])!=st.end()) continue;\\n            nums.push_back(arr[i]);\\n            st.insert(arr[i]);\\n        }\\n        int m=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int maxi=1;\\n        for(int i=0;i<nums.size();i++){\\n            int x=lower_bound(nums.begin(),nums.end(),nums[i]+n-1)-nums.begin();\\n            maxi=max(maxi,(x-i+((x<m && nums[x]==nums[i]+n-1)?1:0)));\\n        }\\n        return n-maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& arr) {\\n        int ans=-1;\\n        int n=arr.size();\\n        vector<int> nums;\\n        unordered_set<int> st;\\n        for(int i=0;i<arr.size();i++){\\n            if(st.find(arr[i])!=st.end()) continue;\\n            nums.push_back(arr[i]);\\n            st.insert(arr[i]);\\n        }\\n        int m=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int maxi=1;\\n        for(int i=0;i<nums.size();i++){\\n            int x=lower_bound(nums.begin(),nums.end(),nums[i]+n-1)-nums.begin();\\n            maxi=max(maxi,(x-i+((x<m && nums[x]==nums[i]+n-1)?1:0)));\\n        }\\n        return n-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421343,
                "title": "straightforward-c-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int ans = 1;\\n        int l = 1;\\n        int i = 0, j = 1;\\n        int u = 1; // unique count of numbers between i-th and j-th number\\n        while (j < n) {\\n          if (nums[j] - nums[i] < n) {\\n              if (nums[j] != nums[j-1]) ++u;\\n              ++j;\\n              ans = max(u, ans);\\n          } else {\\n            ++i;\\n            if (nums[i] != nums[i-1]) --u;\\n          }\\n\\n        }\\n\\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int ans = 1;\\n        int l = 1;\\n        int i = 0, j = 1;\\n        int u = 1; // unique count of numbers between i-th and j-th number\\n        while (j < n) {\\n          if (nums[j] - nums[i] < n) {\\n              if (nums[j] != nums[j-1]) ++u;\\n              ++j;\\n              ans = max(u, ans);\\n          } else {\\n            ++i;\\n            if (nums[i] != nums[i-1]) --u;\\n          }\\n\\n        }\\n\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365450,
                "title": "c-sliding-window-bin-search-explained",
                "content": "The question actually asks u to create an array s.t. it contains n consequtive numbers (where n = size of array)\\n        If the size of array = n , then the maximum answer in worst case will be n-1 ? because , In worst case , u can fix only 1 number and change other n-1 numbers such that they are conseq. to fixed number \\n        e.g :\\n        in last example [1 , 10 , 100 , 1000]\\n        > we can fix 1 , can convert 10-2 , 100-3 , 1000-4\\n        OR\\n        >we can fix 10 , can convert 1-11 , 100-12 , 1000-13\\n        OR\\n        >we can fix 100 , can covert 1-101 , 10-102 , 1000-103\\n        SIMILARLY...\\n\\nso what we can do is iterate over all ements , an check if they are the starting point (fixed number) , then how many conversions we need to get n conseq. numbers starting from the current number\\n        \\nEX : assume [1 , 5 , 6 , 14]\\nSay we fix <1>\\nwe see there are no consequtives to 1 already present , hence we need 3 conversions i.e. 5-2 , 6-3 , 14-4 \\n        \\nwe fix <5>\\nwe see , we already have 5,6 as consequtives , so we just need 2 conversions i.e. 1-7 , 14-8 , so overall array will be [5,6,7,8]\\n        \\nwe fix <6>\\nNo consequtives after 6 present , so we need 3 convers. 1-7 , 5-8 , 14-9\\n        \\nsame goes for fixing <14> , 3 conversions are needed.\\n        \\n\\t\\t\\n\\t\\t\\nSO FINAL RETURNED VALUE WILL BE 2 AS IT IS THE MINIMUM AMONG ALL THE POSSIBLE CONVERSIONS\\n\\n\\n\\nIF THE ORIGINAL ARRAYS CONTAINS , DUPLICATE ELEMENTS , REMOVE DUPLICATE ELEMENTS BY EITHER SETTING TO INT-MIN.\\nNOTE THE SIZE USED (n) WILL BE SAME AS THAT OF ORIGNIAL ARAY, I HAVE RECREATED THE ARRAY BUT USED THE ORIGINAL SIZE AS n\\n\\n\\nQ) how do we actually find out no. of consequtive sequence  which start with ,say the number, \\'x\\' ?\\nA) remember that we wanted (n-1) conseqs. numbers that start with x i.e. we want [x , x+1 , x+2 , x+3 ...... x+n-1]\\nFirst OF all , SORT THE ARRAY. \\nsay u are at number \\'x\\' , and u need to find how many numbers AFTER \\'x\\' that are consequtive are already present,\\n\\nbinary search (x+n-1) , in the sorted array, u will get a index , count how many elements lie in this range , if the range consist of all the elements of array => all elements form the conseq. sequence that start with \\'x\\' , say out of n , you found \\'q\\' elements that lie in range of (x) to (x+n-1) after Bin_search , => You need to convert (n-q) elements to get all numbers to be the part of consequtive sequence. \\n\\n\\nTO OPTIMIZE , RATHER THAN BIN_SEARCH , YOU CAN USE 2 POINTER (SLIDING - WINDOW) AS I HAVE USED.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n        set<int> s;\\n        for(int x : nums) s.insert(x);\\n        nums.clear();\\n        for(int x:s)nums.push_back(x);\\n        int i = 0;\\n        int j = 0;\\n        int minConversions = INT_MAX;\\n        while(i < nums.size()){\\n            while(j < (nums.size()) && nums[j] <= nums[i]+n-1)\\n                j++;\\n            int numbersAlreadyInConseqs = j-i;\\n            minConversions = min(minConversions ,(n - numbersAlreadyInConseqs));\\n            i++;\\n        }\\n        return minConversions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n        set<int> s;\\n        for(int x : nums) s.insert(x);\\n        nums.clear();\\n        for(int x:s)nums.push_back(x);\\n        int i = 0;\\n        int j = 0;\\n        int minConversions = INT_MAX;\\n        while(i < nums.size()){\\n            while(j < (nums.size()) && nums[j] <= nums[i]+n-1)\\n                j++;\\n            int numbersAlreadyInConseqs = j-i;\\n            minConversions = min(minConversions ,(n - numbersAlreadyInConseqs));\\n            i++;\\n        }\\n        return minConversions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336509,
                "title": "c-easy-solution-for-better-understand-with-explanation",
                "content": "# Intuition\\n# Solution 1. Sliding Window\\n**Check out \"C++ Maximum Sliding Window Cheatsheet Template!\" which can help you solve all sliding window problems.**\\n\\n# Intuition\\n**Sort and only keep unique elements. The problem is the same as \"get the length of the longest subarray whose difference between min and max elements is `N - 1`\".**\\n\\n# Algorithm:\\n\\n**The brute force way is to pick each `A[i]` as the start of the subarray and count the number of elements that are `<= A[i] + N - 1`, which takes `O(N^2`) time.**\\n\\n**Since the array is already sorted, we can use sliding window so that we only traverse the entire array once.\\nUse Non-shrinkable Sliding Window Template:**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# If you Upvote it I will  smile for you \\uD83D\\uDE04\\uD83D\\uDE04\\u2764\\uFE0F\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int N = nums.size(), i = 0, j = 0;\\n        sort(begin(nums), end(nums));\\n        nums.erase(unique(begin(nums), end(nums)), end(nums)); // only keep unique elements\\n        for (int M = nums.size(); j < M; ++j) {\\n           if (nums[i] + N <= nums[j]) ++i;\\n        }\\n        return N - j + i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int N = nums.size(), i = 0, j = 0;\\n        sort(begin(nums), end(nums));\\n        nums.erase(unique(begin(nums), end(nums)), end(nums)); // only keep unique elements\\n        for (int M = nums.size(); j < M; ++j) {\\n           if (nums[i] + N <= nums[j]) ++i;\\n        }\\n        return N - j + i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278904,
                "title": "c-sort-binarysearch-sort-slidingwindow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSliding Window / BinarySearch\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Sort + BinarySearch\\n```\\npublic class Solution {\\n    public int MinOperations(int[] nums) {\\n        Array.Sort(nums);\\n        List<int> list = new List<int>();\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            \\n            list.Add(nums[i]);\\n        }\\n\\n        int max = 0;\\n        \\n        for (int i = 0; i < list.Count; i++)\\n        {\\n            int target = list[i] + nums.Length - 1;\\n            int index = list.BinarySearch(target);\\n            \\n            if (index < 0)\\n                index = (~index) - 1;\\n            \\n            max = Math.Max(max, index - i + 1);\\n        }\\n        \\n        return nums.Length - max;\\n    }\\n}\\n```\\n# Sort + SlidingWindow\\n```\\npublic class Solution {\\n    public int MinOperations(int[] nums) {\\n        Array.Sort(nums);\\n        List<int> list = new List<int>();\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n\\n            list.Add(nums[i]);\\n        }\\n\\n        int max = 0;\\n        for (int i = 0, j = 0; i < list.Count; i++)\\n        {\\n            while (list[i] - list[j] > nums.Length - 1)\\n            {\\n                j ++;\\n            }\\n\\n            max = Math.Max(max, i - j + 1);\\n        }\\n\\n        return nums.Length - max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums) {\\n        Array.Sort(nums);\\n        List<int> list = new List<int>();\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            \\n            list.Add(nums[i]);\\n        }\\n\\n        int max = 0;\\n        \\n        for (int i = 0; i < list.Count; i++)\\n        {\\n            int target = list[i] + nums.Length - 1;\\n            int index = list.BinarySearch(target);\\n            \\n            if (index < 0)\\n                index = (~index) - 1;\\n            \\n            max = Math.Max(max, index - i + 1);\\n        }\\n        \\n        return nums.Length - max;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MinOperations(int[] nums) {\\n        Array.Sort(nums);\\n        List<int> list = new List<int>();\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n\\n            list.Add(nums[i]);\\n        }\\n\\n        int max = 0;\\n        for (int i = 0, j = 0; i < list.Count; i++)\\n        {\\n            while (list[i] - list[j] > nums.Length - 1)\\n            {\\n                j ++;\\n            }\\n\\n            max = Math.Max(max, i - j + 1);\\n        }\\n\\n        return nums.Length - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245729,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        let n = nums.len();\\n        let mut ans = n as i32;\\n        nums.sort_unstable();\\n        nums.dedup();\\n        let m = nums.len();\\n        let mut j = 0;\\n        for i in 0..m {\\n            while j < m && nums[j] < nums[i] + n as i32 {\\n                j += 1;\\n            }\\n            ans = ans.min(n as i32 - j as i32 + i as i32);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        let n = nums.len();\\n        let mut ans = n as i32;\\n        nums.sort_unstable();\\n        nums.dedup();\\n        let m = nums.len();\\n        let mut j = 0;\\n        for i in 0..m {\\n            while j < m && nums[j] < nums[i] + n as i32 {\\n                j += 1;\\n            }\\n            ans = ans.min(n as i32 - j as i32 + i as i32);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3133562,
                "title": "we-don-t-need-all-the-extra-nonsense-clean-concise",
                "content": "```\\nclass Solution:\\n    def minOperations(self, n: List[int], a=0) -> int:\\n        b,n=len(n),sorted(set(n))\\n        return b- max([1+i-bisect.bisect_right(n,k-b)for i,k in enumerate(n)])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: List[int], a=0) -> int:\\n        b,n=len(n),sorted(set(n))\\n        return b- max([1+i-bisect.bisect_right(n,k-b)for i,k in enumerate(n)])",
                "codeTag": "Java"
            },
            {
                "id": 3124326,
                "title": "c-o-n-log-n-short-sorting-sliding-window-solution",
                "content": "# Intuition And Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should choose a starting point of the consecutive array and notice that choosing the number in the array as a starting point is always no worse than choosing a number that does not appear in the array. \\n\\nSince the order of the array does not matter, we can sort the array in non-decreasing order and remove all the duplicates. Then try each of them `nums[l]` as the starting point. What we have to do is find the first index `r` such that `nums[r] > nums[l] + n - 1`. Then the number of elements within the range `[nums[l]..nums[l] + n -1]` is `r-l`(Notice that we don\\'t count the duplicated element).\\n\\nWhen `nums[l]` is increasing, the corresponding index `r` is ever-increasing. Knowing this property, we can just use one right pointer, when moving forward `l`, we can slide the right pointer to the corresponding position. Then the right pointer will move at most `n-1` times when we slide `l` from the start to the end, leading to the time complexity of O(n).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n) for sorting, O(n) for deduplication, and O(n) for sliding window algorithm. So totally it\\'s an `O(n log n)` algorithm\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(quicksort)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        ::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int sz = ::unique(nums.begin(), nums.end()) - nums.begin();\\n        nums.resize(sz);\\n\\n        int ans = INT_MAX;\\n        for (int l = 0, r = 0; l < sz; ++l) {\\n            while (r < sz && nums[r] <= nums[l] + n - 1) {++r;}\\n            ans = min(ans, n - (r-l));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        ::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int sz = ::unique(nums.begin(), nums.end()) - nums.begin();\\n        nums.resize(sz);\\n\\n        int ans = INT_MAX;\\n        for (int l = 0, r = 0; l < sz; ++l) {\\n            while (r < sz && nums[r] <= nums[l] + n - 1) {++r;}\\n            ans = min(ans, n - (r-l));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984436,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        set<int> s;\\n        for(auto it:nums)s.insert(it);\\n        nums.clear();\\n        for(auto it:s)nums.push_back(it);\\n\\n        int opr=INT_MAX;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int cur=nums[i];\\n            int last=cur+n-1;\\n\\n            auto upr= upper_bound(nums.begin()+i,nums.end(),last);\\n            upr--;\\n\\n            int idx=upr-nums.begin();\\n\\n            int curOpr= n - (idx -i +1);\\n\\n            opr=min(opr,curOpr);\\n        }\\n        \\n\\n        return opr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        set<int> s;\\n        for(auto it:nums)s.insert(it);\\n        nums.clear();\\n        for(auto it:s)nums.push_back(it);\\n\\n        int opr=INT_MAX;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int cur=nums[i];\\n            int last=cur+n-1;\\n\\n            auto upr= upper_bound(nums.begin()+i,nums.end(),last);\\n            upr--;\\n\\n            int idx=upr-nums.begin();\\n\\n            int curOpr= n - (idx -i +1);\\n\\n            opr=min(opr,curOpr);\\n        }\\n        \\n\\n        return opr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964427,
                "title": "java-two-solutions-binary-search-and-sliding-window",
                "content": "**Solution 1** - \\nApproach - \\n1. Make a note of riginal array length, let it be n.\\n2. Sort the given array.\\n3. Get rid of all the duplicate elements and save unique elements in a List.\\n4. Loop through every element as if it is the minimum element of the possible candidate continuouss array. Let it be i\\n5. For every i index, find the right most index with which elements are less than or equal to nums[i] + n-1 as stated in problem. These elements can be reused in the candidate continous array and rest we need to change.\\n6. Find the maximum length of this window and save it in maxCount.\\n7. Variable maxCount is the maximum number of elements in given original array nums[] which can be reused and rest have to be changed. \\n8. As we need to find the minimum number of elements that need to be changed from original array. So, the answer is n - maxCount.\\n\\nT.C is O(N*logN) and S.C is of(N)\\nNote - We can reduce the S.C to O(1) by changing to the given array nums[]. Ignoring S.C of O(logN) due to sorting algorithm.\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length, maxCount = 0;\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        list.add(nums[0]);\\n        for(int i = 1; i<n; ++i){\\n            if(nums[i] != list.get(list.size()-1)){\\n                list.add(nums[i]);\\n            }\\n        }\\n        // System.out.println(list.toString());\\n        int limit, count;\\n        for(int i = 0; i<list.size(); ++i){\\n            limit = (n - 1) + list.get(i);\\n            count = validCount(list, i, limit);\\n            maxCount = (int)Math.max(maxCount, count);\\n            // System.out.printf(\"i:%d, limit:%d, count:%d, len:\", i, limit, count);\\n        }\\n        return n - maxCount;\\n    }\\n    \\n    private int validCount(List<Integer> list, int i, int limit){\\n        int end = list.size()-1, len = 1, mid, start = i;\\n        while(start <= end){\\n            mid = start + (end-start)/2;\\n            if(list.get(mid) <= limit){\\n                len = mid - i + 1;\\n                start = mid + 1;\\n            }\\n            else end = mid - 1;\\n        }\\n        // System.out.println(len);\\n        return len;\\n    }\\n}\\n```\\n\\n**Solution 2** - \\n**Optimization** - We tried to find the maximum length of valid elements together in above solution using binary search. But we can do it using sliding window also which increases our code performance.\\nT.C is still O(N*logN) due to sorting.\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int maxLen = 0, n = nums.length;\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        list.add(nums[0]);\\n        for(int i = 1; i<n; ++i){\\n            if(nums[i] != list.get(list.size()-1)){\\n                list.add(nums[i]);\\n            }\\n        } \\n        int i = 0, j = 0, limit;\\n        while(i < n && j < list.size()){\\n            limit = list.get(i) + (n-1);\\n            while(j < list.size() && list.get(j) <= limit){\\n                ++j;\\n            }\\n            // System.out.printf(\"i:%d, j:%d, limit:%d\\\\n\", i, j, limit);\\n            maxLen = (int)Math.max(maxLen, j - i);\\n            ++i;            \\n        }\\n        return n - maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length, maxCount = 0;\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        list.add(nums[0]);\\n        for(int i = 1; i<n; ++i){\\n            if(nums[i] != list.get(list.size()-1)){\\n                list.add(nums[i]);\\n            }\\n        }\\n        // System.out.println(list.toString());\\n        int limit, count;\\n        for(int i = 0; i<list.size(); ++i){\\n            limit = (n - 1) + list.get(i);\\n            count = validCount(list, i, limit);\\n            maxCount = (int)Math.max(maxCount, count);\\n            // System.out.printf(\"i:%d, limit:%d, count:%d, len:\", i, limit, count);\\n        }\\n        return n - maxCount;\\n    }\\n    \\n    private int validCount(List<Integer> list, int i, int limit){\\n        int end = list.size()-1, len = 1, mid, start = i;\\n        while(start <= end){\\n            mid = start + (end-start)/2;\\n            if(list.get(mid) <= limit){\\n                len = mid - i + 1;\\n                start = mid + 1;\\n            }\\n            else end = mid - 1;\\n        }\\n        // System.out.println(len);\\n        return len;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int maxLen = 0, n = nums.length;\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        list.add(nums[0]);\\n        for(int i = 1; i<n; ++i){\\n            if(nums[i] != list.get(list.size()-1)){\\n                list.add(nums[i]);\\n            }\\n        } \\n        int i = 0, j = 0, limit;\\n        while(i < n && j < list.size()){\\n            limit = list.get(i) + (n-1);\\n            while(j < list.size() && list.get(j) <= limit){\\n                ++j;\\n            }\\n            // System.out.printf(\"i:%d, j:%d, limit:%d\\\\n\", i, j, limit);\\n            maxLen = (int)Math.max(maxLen, j - i);\\n            ++i;            \\n        }\\n        return n - maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910188,
                "title": "dp-binary-search-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> dp(n, 0);\\n        \\n        unordered_map<int, int> cntMap;\\n        \\n        vector<int> unique;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (cntMap[nums[i]] == 0) {\\n                unique.push_back(nums[i]);\\n                cntMap[nums[i]]++;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        int u_n = unique.size();\\n        \\n        \\n        for (int i = 0; i < n; i++) {\\n            int f = nums[i];\\n            int l = nums[i] + n - 1;\\n            \\n            int fIdx = (int) (lower_bound(unique.begin(), unique.end(), f) - unique.begin());\\n            int sIdx = (int) (lower_bound(unique.begin(), unique.end(), l) - unique.begin());\\n            \\n            if (sIdx == u_n) {\\n                sIdx--;\\n            } else {\\n                if (unique[sIdx] > l) {\\n                    sIdx--;\\n                }\\n            }\\n            \\n            //cout<<i<<\" \"<<fIdx<<\" \"<<sIdx<<endl;\\n            \\n            ans = min(ans, n - (sIdx - fIdx + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> dp(n, 0);\\n        \\n        unordered_map<int, int> cntMap;\\n        \\n        vector<int> unique;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (cntMap[nums[i]] == 0) {\\n                unique.push_back(nums[i]);\\n                cntMap[nums[i]]++;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        int u_n = unique.size();\\n        \\n        \\n        for (int i = 0; i < n; i++) {\\n            int f = nums[i];\\n            int l = nums[i] + n - 1;\\n            \\n            int fIdx = (int) (lower_bound(unique.begin(), unique.end(), f) - unique.begin());\\n            int sIdx = (int) (lower_bound(unique.begin(), unique.end(), l) - unique.begin());\\n            \\n            if (sIdx == u_n) {\\n                sIdx--;\\n            } else {\\n                if (unique[sIdx] > l) {\\n                    sIdx--;\\n                }\\n            }\\n            \\n            //cout<<i<<\" \"<<fIdx<<\" \"<<sIdx<<endl;\\n            \\n            ans = min(ans, n - (sIdx - fIdx + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2869895,
                "title": "python-brute-force-binary-search-sliding-window",
                "content": "Before the code, let me explain the basic idea behind the below approaches. \\n\\nSee, we want to convert the array into a \"continuous\" array such that, the final array has no duplicate elements and also, the difference between maximum and minimum element is \"length - 1\"\\n\\nNow if you think, it just means, that if \"x\" is the starting element in the final continuous array, then the maximum element should be \"x + n - 1\". Also, we are not asked to return the continous array. Instead, we are asked to find how many elements to replace.\\n\\nSince we want to minimize the replacements, it means, from the original input array, we should be able to reuse the maximum number of elements in our final array. Because, if we maximize the number of elements we reuse, we will minimize the number of elements we replace. That\\'s the main idea of all the approaches below.\\n\\nSince final array should not have any duplicates, this means, once we use an element, we will not be reusing same element again. And so, it means, we can straight off remove the duplicates first. Set will come handy in this case.\\n\\nNow, the minimum in our continuous array can be any element from original array. For example, if we are given [1,2,3,5,6] then what can be the continuous array if we make each element as minimum - \\n\\n\\t\\tIf \"1\" is the minimum -> [1,2,3,4,5]\\n\\t\\tIf \"2\" is the minimum -> [2,3,4,5,6]\\n\\t\\tIf \"3\" is the minimum -> [3,4,5,6,7]\\n\\t\\tIf \"5\" is the minimum -> [5,6,7,8,9]\\n\\t\\tIf \"6\" is the minimum -> [6,7,8,9,10]\\n\\nSo, in which case we have to make the minimum number of replacements? We can use the set that we created above for that because lookup is O(1) operation.\\n\\nIf \"X\" is the minimum element in the final array, we know \"X + N - 1\" will be the maximum. So, we can check how many elements from \"X\" to \"X + N - 1\" are present in the set. If all are present, we basically do not need to make any replacements and the array is already continuous. \\n\\n# **1. BRUTE FORCE APPROACH - TLE**\\n\\nThe Brute Force approach is pretty straight forward. Consider each element as \"minimum\" and check how many elements are present in the set in the range [num, num + n - 1]. That will be our number of elements we can reuse.\\n\\nFind the minimum replacements and return that.\\n\\nBut this approach is not efficient and will fail for large test cases.\\n\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        # Since we want to convert \"nums\" into a continuous array\\n        # It means, it will not have any duplicates\\n        # So first, we will remove the duplicates\\n        \\n        nums = set(nums)\\n        \\n        maxReusedElements = 1\\n        \\n        for num in nums:\\n            reused = 0\\n            # If we consider \"num\" to be the minimum in resulting continous array\\n            # Then we know the maximum element in that array needs to be \"num + n - 1\"\\n            # So now we want to check how many elements we can reuse\\n            for i in range(num, num + n):\\n                if i in nums: reused += 1\\n                    \\n            maxReusedElements = max(maxReusedElements, reused)\\n            \\n        return n - maxReusedElements\\n\\t\\t\\n# **2. BINARY SEARCH APPROACH**\\nHow can we use Binary Search?\\n\\nWe also know that if we \"Maximize\" the number of elements we can reuse, then the replacements will be \"Minimized\". \\n\\nSo, for each element, if we consider it as the minimum element, then all that we want to find is how many elements are there in the range [element, element + n - 1] in the input array. We can reuse all of them, right? And so, if we sort our array, then we can use Binary search to find just that.\\n\\nAnd that\\'s the idea of this approach. \\n\\nTake each element, consider it as minimum, and then find how many elements are already present in the array that are <= element + n - 1. \\n\\nOne thing that\\'s important is that, in the \"start\" and \"end\", the length of array is the length of the new array that we created after removing duplicates. But, the \"n\" is the length of array originally. Because our continuous array needs to be of length \"n\". \\n\\n```\\ndef minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        # Since we want to convert \"nums\" into a continuous array\\n        # It means, it will not have any duplicates\\n        # So first, we will remove the duplicates\\n        \\n        nums = list(set(nums))\\n        \\n        # To use Binary Search, we also Sort this array\\n        nums.sort()\\n        \\n        maxReusedElements = 1\\n        \\n        for i,num in enumerate(nums):\\n            # This time, instead of linear search, we will do Binary Search\\n            # Because since array is sorted, we just want to find the largest element in array that is <= num + n - 1\\n            # And the number of elements in between = number of elements we can reuse \\n            \\n            # Note that here, we are not using \"n\" which is the old length before we removed duplicates\\n            # Here we are using len(nums) that is, the new length of the list after removing duplicates\\n            start = 0\\n            end = len(nums) - 1\\n            \\n            rightmostIndex = i\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # Here we are using \"n\" which is the length of original array\\n                # Since the final continous array needs to be of length \"n\"\\n                if nums[mid] <= num + n - 1:\\n                    rightmostIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n            \\n            maxReusedElements = max(maxReusedElements, rightmostIndex - i + 1)\\n        \\n        # Now that we have the Maximum number of elements we can reuse\\n        # Just return the minimum replacements we need to make\\n        return n - maxReusedElements\\n```\\n\\n# **3. SLIDING WINDOW APPROACH**\\n![image](https://assets.leetcode.com/users/images/97874891-968c-4865-8349-4aa58f74fab7_1669990988.6850874.png)\\n\\n\\nWell, there is no need of Binary Search as well if you think a bit.\\n\\nBecause basically, after sorting, all that we are looking for is what is the longest subarray that starts with element \"X\" and the maximum element in this subarray does not exceed \"X + N - 1\".  Because all the elements in this subarray will be reused if \"X\" is the minimum element in final continuous array. \\n\\nAnd well, here, we can make use of Sliding Window approach because we are dealing with subarray here and we want the Maximum length subarray such that the maximum element in the subarray is <= (minimum element + n - 1)\\n\\n```\\ndef minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        # Since we want to convert \"nums\" into a continuous array\\n        # It means, it will not have any duplicates\\n        # So first, we will remove the duplicates\\n        \\n        nums = list(set(nums))\\n        \\n        # To use Sliding Window, we also Sort this array\\n        nums.sort()\\n        \\n        maxReusedElements = 1\\n        i,j = 0,0\\n        \\n        while j < len(nums):\\n            \\n            # While this window is valid, keep increasing its size from right end\\n            # And also keep track of the maximum window size\\n            # Because that refers to number of elements we can reuse\\n            while j < len(nums) and nums[j] <= nums[i] + n - 1: \\n                maxReusedElements = max(maxReusedElements, j - i + 1)\\n                j += 1\\n            \\n            # Shrink the window from left end\\n            i += 1\\n\\n        return n - maxReusedElements\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\ndef minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        # Since we want to convert \"nums\" into a continuous array\\n        # It means, it will not have any duplicates\\n        # So first, we will remove the duplicates\\n        \\n        nums = list(set(nums))\\n        \\n        # To use Binary Search, we also Sort this array\\n        nums.sort()\\n        \\n        maxReusedElements = 1\\n        \\n        for i,num in enumerate(nums):\\n            # This time, instead of linear search, we will do Binary Search\\n            # Because since array is sorted, we just want to find the largest element in array that is <= num + n - 1\\n            # And the number of elements in between = number of elements we can reuse \\n            \\n            # Note that here, we are not using \"n\" which is the old length before we removed duplicates\\n            # Here we are using len(nums) that is, the new length of the list after removing duplicates\\n            start = 0\\n            end = len(nums) - 1\\n            \\n            rightmostIndex = i\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # Here we are using \"n\" which is the length of original array\\n                # Since the final continous array needs to be of length \"n\"\\n                if nums[mid] <= num + n - 1:\\n                    rightmostIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n            \\n            maxReusedElements = max(maxReusedElements, rightmostIndex - i + 1)\\n        \\n        # Now that we have the Maximum number of elements we can reuse\\n        # Just return the minimum replacements we need to make\\n        return n - maxReusedElements\\n```\n```\\ndef minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        # Since we want to convert \"nums\" into a continuous array\\n        # It means, it will not have any duplicates\\n        # So first, we will remove the duplicates\\n        \\n        nums = list(set(nums))\\n        \\n        # To use Sliding Window, we also Sort this array\\n        nums.sort()\\n        \\n        maxReusedElements = 1\\n        i,j = 0,0\\n        \\n        while j < len(nums):\\n            \\n            # While this window is valid, keep increasing its size from right end\\n            # And also keep track of the maximum window size\\n            # Because that refers to number of elements we can reuse\\n            while j < len(nums) and nums[j] <= nums[i] + n - 1: \\n                maxReusedElements = max(maxReusedElements, j - i + 1)\\n                j += 1\\n            \\n            # Shrink the window from left end\\n            i += 1\\n\\n        return n - maxReusedElements\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2865321,
                "title": "easy-to-understand-4-approaches-c-single-map-line-sweep-sliding-window-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\nint minOperations(vector<int>& nums) {\\n        int n =  nums.size();\\n        // uniqify intervals\\n        map<int,int> lineSweep;\\n        for(auto& val:nums){\\n            auto it = lineSweep.find(val);\\n\\t\\t\\t// if interval is >= 0 means number is already seen\\n            if ((it != lineSweep.end()) && (it->second >= 0))\\n                continue;\\n            lineSweep[val]++;\\n            lineSweep[val+n]--;\\n        }\\n        int sum=0;\\n        // sweep the line\\n        // every possitive sum means there was an overlap\\n        // of maximumm real numbers, so more the number better the result;\\n        int maxOverlap = 0;\\n        for(auto& val:lineSweep){\\n           sum+=val.second;\\n           maxOverlap = max(maxOverlap,sum);\\n        }\\n        return n-maxOverlap;\\n    }\\n\\t\\n   int minOperations3(vector<int>& nums) {\\n       int minOperations(vector<int>& nums) {\\n        // uniqify intervals\\n        set<int>s;\\n        for(auto& val:nums){\\n            s.insert(val);\\n        }\\n        int n =  nums.size();\\n        // create a line sweep\\n        map<int, int>mp;\\n        for(auto& val:s){\\n            mp[val]++; // marking start of interval\\n            mp[val+n]--; // end of interval\\n        }\\n        int sum=0;\\n        int ans=INT_MAX;\\n        // sweep the line\\n        // every possitive sum means there was an overlap\\n        // of maximumm real numbers, so more the number better the result;\\n        int maxOverlap = 0;\\n        for(auto& val:mp){\\n           sum+=val.second;\\n           maxOverlap = max(maxOverlap,sum);\\n        }\\n        return n-maxOverlap;\\n    }\\n    \\n    int minOperations2(vector<int>& nums) {\\n        int n = nums.size();\\n        int result = n;\\n        // sort and uniqify numbers using ordered set\\n        set<int> uniq(nums.begin(),nums.end());\\n        vector<int> arr; arr.reserve(n);\\n        for (auto &it : uniq) {\\n            arr.push_back(it);\\n        }\\n        \\n        int l = 0; int r = 1;\\n        int len = arr.size();\\n        while(r < len) {\\n            // if current window is valid the capture the size\\n            if (arr[r] >= (arr[l]+n)) {\\n                result = min(result,n-(r-l));\\n                // resize until we are sliding left and window\\n                // becomes valid again\\n                while((l !=r) && (arr[l]+n) <= arr[r]) {\\n                    l++;\\n                }\\n            }\\n            r++;\\n        }\\n        // capture result at the end as well\\n        result = min(result,n-((r-l)));\\n        \\n        return result;\\n    }\\n    \\n    \\n    int minOperations1(vector<int>& nums) {\\n        int n = nums.size();\\n        int result = n;\\n        set<int> uniq(nums.begin(),nums.end());\\n        vector<int> arr; arr.reserve(n);\\n        for (auto &it : uniq) {\\n            arr.push_back(it);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            // using binary search and find the size of valid window\\n            auto it = upper_bound(arr.begin()+i,arr.end(),arr[i]+n-1);\\n            int pos = it - arr.begin();\\n            result = min(result,(n-(pos-i)));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint minOperations(vector<int>& nums) {\\n        int n =  nums.size();\\n        // uniqify intervals\\n        map<int,int> lineSweep;\\n        for(auto& val:nums){\\n            auto it = lineSweep.find(val);\\n\\t\\t\\t// if interval is >= 0 means number is already seen\\n            if ((it != lineSweep.end()) && (it->second >= 0))\\n                continue;\\n            lineSweep[val]++;\\n            lineSweep[val+n]--;\\n        }\\n        int sum=0;\\n        // sweep the line\\n        // every possitive sum means there was an overlap\\n        // of maximumm real numbers, so more the number better the result;\\n        int maxOverlap = 0;\\n        for(auto& val:lineSweep){\\n           sum+=val.second;\\n           maxOverlap = max(maxOverlap,sum);\\n        }\\n        return n-maxOverlap;\\n    }\\n\\t\\n   int minOperations3(vector<int>& nums) {\\n       int minOperations(vector<int>& nums) {\\n        // uniqify intervals\\n        set<int>s;\\n        for(auto& val:nums){\\n            s.insert(val);\\n        }\\n        int n =  nums.size();\\n        // create a line sweep\\n        map<int, int>mp;\\n        for(auto& val:s){\\n            mp[val]++; // marking start of interval\\n            mp[val+n]--; // end of interval\\n        }\\n        int sum=0;\\n        int ans=INT_MAX;\\n        // sweep the line\\n        // every possitive sum means there was an overlap\\n        // of maximumm real numbers, so more the number better the result;\\n        int maxOverlap = 0;\\n        for(auto& val:mp){\\n           sum+=val.second;\\n           maxOverlap = max(maxOverlap,sum);\\n        }\\n        return n-maxOverlap;\\n    }\\n    \\n    int minOperations2(vector<int>& nums) {\\n        int n = nums.size();\\n        int result = n;\\n        // sort and uniqify numbers using ordered set\\n        set<int> uniq(nums.begin(),nums.end());\\n        vector<int> arr; arr.reserve(n);\\n        for (auto &it : uniq) {\\n            arr.push_back(it);\\n        }\\n        \\n        int l = 0; int r = 1;\\n        int len = arr.size();\\n        while(r < len) {\\n            // if current window is valid the capture the size\\n            if (arr[r] >= (arr[l]+n)) {\\n                result = min(result,n-(r-l));\\n                // resize until we are sliding left and window\\n                // becomes valid again\\n                while((l !=r) && (arr[l]+n) <= arr[r]) {\\n                    l++;\\n                }\\n            }\\n            r++;\\n        }\\n        // capture result at the end as well\\n        result = min(result,n-((r-l)));\\n        \\n        return result;\\n    }\\n    \\n    \\n    int minOperations1(vector<int>& nums) {\\n        int n = nums.size();\\n        int result = n;\\n        set<int> uniq(nums.begin(),nums.end());\\n        vector<int> arr; arr.reserve(n);\\n        for (auto &it : uniq) {\\n            arr.push_back(it);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            // using binary search and find the size of valid window\\n            auto it = upper_bound(arr.begin()+i,arr.end(),arr[i]+n-1);\\n            int pos = it - arr.begin();\\n            result = min(result,(n-(pos-i)));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861716,
                "title": "python-sliding-window-with-set-1090-ms",
                "content": "Sort the array first then apply a sliding window of range (len(nums) - 1), use a set to kill repeated elements.\\n\\nLemme know if any suggestions for improvement:)\\n\\n     def minOperations(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ran = n - 1\\n        l, r = 0, 0\\n        res = float(\\'inf\\')\\n        visited = set()\\n        while r < n and nums[r] - nums[l] <= ran:\\n            visited.add(nums[r])\\n            r += 1\\n            res = min(res, n - len(visited))\\n            while l < r < n and nums[r] - nums[l] > ran:\\n                if nums[l] in visited:\\n                    visited.remove(nums[l])\\n                l += 1\\n        return res\\n\\t\\t\\nTime: O(N)\\nSpace: O(N)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Sort the array first then apply a sliding window of range (len(nums) - 1), use a set to kill repeated elements.\\n\\nLemme know if any suggestions for improvement:)\\n\\n     def minOperations(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ran = n - 1\\n        l, r = 0, 0\\n        res = float(\\'inf\\')\\n        visited = set()\\n        while r < n and nums[r] - nums[l] <= ran:\\n            visited.add(nums[r])\\n            r += 1\\n            res = min(res, n - len(visited))\\n            while l < r < n and nums[r] - nums[l] > ran:\\n                if nums[l] in visited:\\n                    visited.remove(nums[l])\\n                l += 1\\n        return res\\n\\t\\t\\nTime: O(N)\\nSpace: O(N)",
                "codeTag": "Python3"
            },
            {
                "id": 2823850,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        sort(begin(A), end(A));\\n        queue<int> q;\\n        int N = A.size(), res = N;\\n        for(int i = 0; i < N; i++) {\\n            if(!q.empty() && A[i] == A[q.back()]) continue;\\n            while(!q.empty() && A[i]-A[q.front()] >= N) q.pop();\\n            q.push(i);\\n            res = min(res, N-(int)q.size());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        sort(begin(A), end(A));\\n        queue<int> q;\\n        int N = A.size(), res = N;\\n        for(int i = 0; i < N; i++) {\\n            if(!q.empty() && A[i] == A[q.back()]) continue;\\n            while(!q.empty() && A[i]-A[q.front()] >= N) q.pop();\\n            q.push(i);\\n            res = min(res, N-(int)q.size());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772352,
                "title": "set-sliding-window",
                "content": "Key: calculate the max length (without duplicate) sub array that biggest - smallest < *nums.size()*\\nthe answer is nums.size() - max length\\nUsing a set to tracking the max len, it can easily to exclude repeat nums.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxlen = 0;\\n        set<int> bucket;\\n        \\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < n; i++)\\n        {\\n            bucket.insert(nums[i]);\\n            \\n            while( *bucket.rbegin() - *bucket.begin() >= n)\\n            {\\n                bucket.erase(bucket.begin());\\n            }\\n            \\n            maxlen = max(maxlen, (int)bucket.size());\\n        }\\n\\n        return n - maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxlen = 0;\\n        set<int> bucket;\\n        \\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < n; i++)\\n        {\\n            bucket.insert(nums[i]);\\n            \\n            while( *bucket.rbegin() - *bucket.begin() >= n)\\n            {\\n                bucket.erase(bucket.begin());\\n            }\\n            \\n            maxlen = max(maxlen, (int)bucket.size());\\n        }\\n\\n        return n - maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759754,
                "title": "c",
                "content": "Runtime: 402 ms, faster than 60.00% of C online submissions for Minimum Number of Operations to Make Array Continuous.\\nMemory Usage: 17.5 MB, less than 20.00% of C online submissions for Minimum Number of Operations to Make Array Continuous.\\n```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint minOperations(int* nums, int numsSize){\\n    int n = numsSize;\\n    qsort(nums, n, sizeof(int), cmpfunc);\\n    int* arr = malloc(n * sizeof(int));\\n    arr[0] = nums[0];\\n    int idx = 1;\\n    for(int i = 1; i < n; i++)\\n    {\\n        if(nums[i] != nums[i-1])\\n        {\\n            arr[idx] = nums[i];\\n            idx++;\\n        }    \\n    }\\n    int ans = INT_MAX;\\n    int j = 0;\\n    for(int i = 0; i < idx; i++)\\n    {\\n        while(j < idx && (arr[j] - arr[i] + 1) <= n)\\n        {\\n            ans = fmin(ans , n - (j - i + 1));\\n            j++;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint minOperations(int* nums, int numsSize){\\n    int n = numsSize;\\n    qsort(nums, n, sizeof(int), cmpfunc);\\n    int* arr = malloc(n * sizeof(int));\\n    arr[0] = nums[0];\\n    int idx = 1;\\n    for(int i = 1; i < n; i++)\\n    {\\n        if(nums[i] != nums[i-1])\\n        {\\n            arr[idx] = nums[i];\\n            idx++;\\n        }    \\n    }\\n    int ans = INT_MAX;\\n    int j = 0;\\n    for(int i = 0; i < idx; i++)\\n    {\\n        while(j < idx && (arr[j] - arr[i] + 1) <= n)\\n        {\\n            ans = fmin(ans , n - (j - i + 1));\\n            j++;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2752543,
                "title": "c-o-nlogn-solution-using-binary-search",
                "content": "**C++ Code:**\\n**Please Upvote my Solution**\\n```\\n int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        // Removing Duplicate\\n        unordered_set<int>s;\\n        vector<int>arr;\\n        for(int i=0;i<n;i++){\\n            if(s.find(nums[i])==s.end()){\\n            s.insert(nums[i]);\\n            arr.push_back(nums[i]);\\n            }\\n        }\\n      // calculating minimum element should replace to make array continuous\\n    // In every iteration we are considering arr[i] as min element and checking how many element comes under arr[i]+n-1 and rest element should be replace.    \\n        int ans = n;\\n        for(int i=0;i<arr.size();i++){\\n            int low = i,high = arr.size()-1;\\n            while(low<=high){\\n              int mid = (low+high)/2;\\n                if(arr[mid]<=arr[i]+n-1)\\n                    low = mid+1;\\n                else high = mid-1;\\n            }\\n            ans = min(ans,n-(low-i));\\n        }\\n     return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\n int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        // Removing Duplicate\\n        unordered_set<int>s;\\n        vector<int>arr;\\n        for(int i=0;i<n;i++){\\n            if(s.find(nums[i])==s.end()){\\n            s.insert(nums[i]);\\n            arr.push_back(nums[i]);\\n            }\\n        }\\n      // calculating minimum element should replace to make array continuous\\n    // In every iteration we are considering arr[i] as min element and checking how many element comes under arr[i]+n-1 and rest element should be replace.    \\n        int ans = n;\\n        for(int i=0;i<arr.size();i++){\\n            int low = i,high = arr.size()-1;\\n            while(low<=high){\\n              int mid = (low+high)/2;\\n                if(arr[mid]<=arr[i]+n-1)\\n                    low = mid+1;\\n                else high = mid-1;\\n            }\\n            ans = min(ans,n-(low-i));\\n        }\\n     return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2746853,
                "title": "java-binary-search",
                "content": "For each element `x`, we can search for number of unique elements in `[x, x + n - 1]` and `[x - n + 1, x]`. If we subtract this from n, it will give us the additional number of elements that needs to be added in that range. Taking a minimum of this will give us our solution. \\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        List<Integer> list = getUnique(nums);\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i<list.size(); i++) {\\n            int x = list.get(i);\\n            //find no of elements in [x, x + n - 1] and [x - n + 1, x]\\n            int floorIdx = floor(list, x + n - 1);\\n            ans = Math.min(ans, n - (floorIdx - i + 1));\\n            int ceilIdx = ceil(list, x - n + 1);\\n            ans = Math.min(ans, n - (i - ceilIdx + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int floor(List<Integer> list, int target) {\\n        int ans = -1;\\n        int low = 0, high = list.size() - 1;\\n        while(low <= high) {\\n            int mid = (low + high)/2;\\n            if(target >= list.get(mid)) {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int ceil(List<Integer> list, int target) {\\n        int ans = -1;\\n        int low = 0, high = list.size() - 1;\\n        while(low <= high) {\\n            int mid = (low + high)/2;\\n            if(target <= list.get(mid)) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    List<Integer> getUnique(int nums[]) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int x: nums)\\n            set.add(x);\\n        \\n        return new ArrayList<>(set);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        List<Integer> list = getUnique(nums);\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i<list.size(); i++) {\\n            int x = list.get(i);\\n            //find no of elements in [x, x + n - 1] and [x - n + 1, x]\\n            int floorIdx = floor(list, x + n - 1);\\n            ans = Math.min(ans, n - (floorIdx - i + 1));\\n            int ceilIdx = ceil(list, x - n + 1);\\n            ans = Math.min(ans, n - (i - ceilIdx + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int floor(List<Integer> list, int target) {\\n        int ans = -1;\\n        int low = 0, high = list.size() - 1;\\n        while(low <= high) {\\n            int mid = (low + high)/2;\\n            if(target >= list.get(mid)) {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int ceil(List<Integer> list, int target) {\\n        int ans = -1;\\n        int low = 0, high = list.size() - 1;\\n        while(low <= high) {\\n            int mid = (low + high)/2;\\n            if(target <= list.get(mid)) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    List<Integer> getUnique(int nums[]) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int x: nums)\\n            set.add(x);\\n        \\n        return new ArrayList<>(set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744855,
                "title": "c-binary-search",
                "content": "A little bit of trick when handling duplicate numbers, first map them to a negative number... when checking the numbers only consider the positive ones...\\nThe rest is just sort and binary search to find how many operations is needed for each number...\\nTime: O(nlogn)\\nSpace: O(n) -> only to find duplicates\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) \\n    {\\n        int length = nums.size();\\n        unordered_map<int, int> counts;\\n        for (int& num:nums)\\n        {\\n            if (counts.find(num) != counts.end())\\n            {\\n                num = -1;\\n            }\\n            counts[num]++;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        int minOps = INT_MAX;\\n        for (int& num:nums)\\n        {\\n            if (num < 0)    continue;\\n            int max_bound = num + length - 1;\\n            auto upper = upper_bound(nums.begin(), nums.end(), max_bound);\\n            auto self  = lower_bound(nums.begin(), nums.end(), num);\\n            int outside = length - (upper - self);\\n            minOps = min(outside, minOps);\\n        }\\n        return minOps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) \\n    {\\n        int length = nums.size();\\n        unordered_map<int, int> counts;\\n        for (int& num:nums)\\n        {\\n            if (counts.find(num) != counts.end())\\n            {\\n                num = -1;\\n            }\\n            counts[num]++;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        int minOps = INT_MAX;\\n        for (int& num:nums)\\n        {\\n            if (num < 0)    continue;\\n            int max_bound = num + length - 1;\\n            auto upper = upper_bound(nums.begin(), nums.end(), max_bound);\\n            auto self  = lower_bound(nums.begin(), nums.end(), num);\\n            int outside = length - (upper - self);\\n            minOps = min(outside, minOps);\\n        }\\n        return minOps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717519,
                "title": "c-sliding-window-clean-concise-with-comments",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n      int N = A.size(), ans = -1e9, e= 0;// e==end\\n        sort(begin(A), end(A));\\n        A.erase(unique(begin(A), end(A)), end(A)); // only keep unique elements\\n        int M = A.size();\\n        for (int strt = 0; strt < M; ++strt) {\\n            while (e < M && A[e] < A[strt] + N) ++e; //maximizing use of elements existing in array \\n            ans = max(ans, e - strt); \\n        }\\n        return N-ans; //Initial length - max elemnts that could be used acc to condition\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n      int N = A.size(), ans = -1e9, e= 0;// e==end\\n        sort(begin(A), end(A));\\n        A.erase(unique(begin(A), end(A)), end(A)); // only keep unique elements\\n        int M = A.size();\\n        for (int strt = 0; strt < M; ++strt) {\\n            while (e < M && A[e] < A[strt] + N) ++e; //maximizing use of elements existing in array \\n            ans = max(ans, e - strt); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2712113,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int ans = n;\\n        vector<int> dp(n,1);\\n        for(int i=1;i<n;i++)\\n            dp[i] = dp[i-1] + (nums[i] != nums[i-1]);\\n        for(int i=0;i<n;i++){\\n            auto it = lower_bound(nums.begin(),nums.end(),nums[i] + n - 1);\\n            if(it == nums.end() || (*it > (nums[i] + n - 1)))\\n                it = it - 1;\\n            int val = dp[(it - nums.begin())] - dp[i] + 1;\\n            ans = min(ans,n-val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int ans = n;\\n        vector<int> dp(n,1);\\n        for(int i=1;i<n;i++)\\n            dp[i] = dp[i-1] + (nums[i] != nums[i-1]);\\n        for(int i=0;i<n;i++){\\n            auto it = lower_bound(nums.begin(),nums.end(),nums[i] + n - 1);\\n            if(it == nums.end() || (*it > (nums[i] + n - 1)))\\n                it = it - 1;\\n            int val = dp[(it - nums.begin())] - dp[i] + 1;\\n            ans = min(ans,n-val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709988,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int minOperations(vector<int>& nums)\\n    {\\n        int n = nums.size(), j = 0, ans = n;\\n    \\n          sort(nums.begin(),nums.end());\\n        \\n        nums.erase(unique(nums.begin(),nums.end()), nums.end());\\n        \\n        int m = nums.size();\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            while(j < m && nums[j] < nums[i]+n)\\n            {\\n                j++;\\n            }\\n            \\n            ans = min(ans, n-j+i);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums)\\n    {\\n        int n = nums.size(), j = 0, ans = n;\\n    \\n          sort(nums.begin(),nums.end());\\n        \\n        nums.erase(unique(nums.begin(),nums.end()), nums.end());\\n        \\n        int m = nums.size();\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            while(j < m && nums[j] < nums[i]+n)\\n            {\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2609513,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), i = 0, ans = INT_MIN;\\n        sort(nums.begin(), nums.end());\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        for(int j = 0; j < nums.size(); ++j){\\n            while(i <= j && (nums[j] - nums[i] + 1) > n) i++;\\n            ans = max(ans, j - i + 1);\\n        }\\n        // cout<<ans<<endl;\\n        return n - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), i = 0, ans = INT_MIN;\\n        sort(nums.begin(), nums.end());\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        for(int j = 0; j < nums.size(); ++j){\\n            while(i <= j && (nums[j] - nums[i] + 1) > n) i++;\\n            ans = max(ans, j - i + 1);\\n        }\\n        // cout<<ans<<endl;\\n        return n - ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2566102,
                "title": "python-binary-search-and-sliding-window",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique, sz = list(sorted(set(nums))), len(nums)\\n        res, numUnique = 0, len(unique)\\n        for i in range(numUnique):\\n            idx = bisect.bisect_right(unique, unique[i] + sz - 1)\\n            res = max(res, idx - i)\\n        return sz - res\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique, sz = list(sorted(set(nums))), len(nums)\\n        res, numUnique = 0, len(unique)\\n        for i in range(numUnique):\\n            idx = bisect.bisect_right(unique, unique[i] + sz - 1)\\n            res = max(res, idx - i)\\n        return sz - res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558148,
                "title": "easy-understandable-code-c-nakshatra",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long ;\\n    int minOperations(vector<int>& nums) {\\n        ll n = nums.size(), ans=INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        \\n        set<ll> st;\\n        vector<ll> tmp;\\n        for(ll i=0; i<n; i++)\\n        {\\n            st.insert(nums[i]);\\n            tmp.push_back(i+1-st.size());\\n        }\\n    \\n        for(ll i=0; i<n; i++)\\n        {\\n            ll num = nums[i]+n-1;\\n            ll idx = upper_bound(nums.begin(), nums.end(), num)-nums.begin()-1;\\n            ll val = tmp[idx]-tmp[i]+n-(idx-i+1);\\n            ans = min(ans, val);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    using ll = long long ;\\n    int minOperations(vector<int>& nums) {\\n        ll n = nums.size(), ans=INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        \\n        set<ll> st;\\n        vector<ll> tmp;\\n        for(ll i=0; i<n; i++)\\n        {\\n            st.insert(nums[i]);\\n            tmp.push_back(i+1-st.size());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2549272,
                "title": "simple-java-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int equal[] = new int [nums.length];\\n        for(int i = 0; i < nums.length; ++i){\\n            if(i > 0){\\n                equal[i] = equal[i - 1];\\n            }\\n            if(i > 0 && nums[i] == nums[i - 1]){\\n                equal[i]++;\\n            }\\n        }\\n        int minOperations = nums.length;\\n        for(int i = 0; i < nums.length; ++i){\\n            if(i > 0 && nums[i] == nums[i - 1]){\\n                continue;\\n            }\\n            int low = i, high = nums.length - 1, maxElementIndex = i;\\n            while(low <= high){\\n                int mid = (low + high) >> 1;\\n                if(nums[mid] <= nums[i] + nums.length - 1){\\n                    maxElementIndex = mid;\\n                    low = mid + 1;\\n                }\\n                else{\\n                    high = mid - 1;\\n                }\\n            }\\n            minOperations = Math.min(minOperations, i + nums.length - maxElementIndex - 1 + equal[maxElementIndex] - equal[i]);\\n        }\\n        return minOperations;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int equal[] = new int [nums.length];\\n        for(int i = 0; i < nums.length; ++i){\\n            if(i > 0){\\n                equal[i] = equal[i - 1];\\n            }\\n            if(i > 0 && nums[i] == nums[i - 1]){\\n                equal[i]++;\\n            }\\n        }\\n        int minOperations = nums.length;\\n        for(int i = 0; i < nums.length; ++i){\\n            if(i > 0 && nums[i] == nums[i - 1]){\\n                continue;\\n            }\\n            int low = i, high = nums.length - 1, maxElementIndex = i;\\n            while(low <= high){\\n                int mid = (low + high) >> 1;\\n                if(nums[mid] <= nums[i] + nums.length - 1){\\n                    maxElementIndex = mid;\\n                    low = mid + 1;\\n                }\\n                else{\\n                    high = mid - 1;\\n                }\\n            }\\n            minOperations = Math.min(minOperations, i + nums.length - maxElementIndex - 1 + equal[maxElementIndex] - equal[i]);\\n        }\\n        return minOperations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507666,
                "title": "c-simple-sliding-window-solution",
                "content": "According to the question all the elements should lie in the range of` [x,x+n-1]`, where x is the minimum number of the final array and n is the size of the array.\\nSo we can basically check that how many number we currently have which lies in this  range. We will search for that range which has maximum number of elements in the  array.\\n```\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> uniq;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<n;i++)\\n        {\\n            while(i<n-1 && nums[i] == nums[i+1]) i++;\\n            uniq.push_back(nums[i]);\\n        }\\n        int res=0, sz = uniq.size();\\n        for(int i=0;i<sz;i++)\\n        {\\n            int idx = upper_bound(uniq.begin(),uniq.end(),uniq[i]+n-1)-uniq.begin();\\n            if(idx-i > res)\\n            {\\n                res = idx-i;\\n            }\\n        }\\n        return n-res;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> uniq;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<n;i++)\\n        {\\n            while(i<n-1 && nums[i] == nums[i+1]) i++;\\n            uniq.push_back(nums[i]);\\n        }\\n        int res=0, sz = uniq.size();\\n        for(int i=0;i<sz;i++)\\n        {\\n            int idx = upper_bound(uniq.begin(),uniq.end(),uniq[i]+n-1)-uniq.begin();\\n            if(idx-i > res)\\n            {\\n                res = idx-i;\\n            }\\n        }\\n        return n-res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2506133,
                "title": "optimal-c-solution-beats-99-82-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int n = nums.size(), i, j, res = 0;\\n        sort(nums.begin(), nums.end());\\n\\t\\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        for(i=0, j=0; j < nums.size(); j++) {\\n            while(nums[i] <= nums[j]-n) i++;\\n            res = max(res, j-i+1);\\n        }\\n        return n-res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int n = nums.size(), i, j, res = 0;\\n        sort(nums.begin(), nums.end());\\n\\t\\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        for(i=0, j=0; j < nums.size(); j++) {\\n            while(nums[i] <= nums[j]-n) i++;\\n            res = max(res, j-i+1);\\n        }\\n        return n-res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2438955,
                "title": "java-slide-window-space-o-1-two-solutions-with-comments",
                "content": "```\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    //Runtime: 59 ms, faster than 74.55% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //Memory Usage: 77.6 MB, less than 77.58% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //Slide window\\n    //Time: O(N*lgN + 2N); Space:O(1);\\n    public int minOperations(int[] nums) {\\n        //Time: O(N*lgN)\\n        Arrays.sort(nums);\\n\\n        int maxWinSize = 0;\\n        int numCount = 0, lastValue = nums[0] - 1;\\n        int left = 0, right = 0;\\n\\n        //Time: worst case: O(2N).\\n        // Left & right pointer visited every number once respectively.\\n        while (right < nums.length){\\n            if (nums[right] != lastValue) numCount++;   //skip duplicated numbers\\n            lastValue = nums[right++];\\n            maxWinSize = Math.max(maxWinSize, numCount);\\n\\n            //move left\\n            int tmp = nums[left] - 1;\\n            while (right < nums.length && nums[right] - nums[left] >= nums.length) {\\n                if (nums[left] != tmp) numCount--;  //skip duplicated numbers\\n                tmp = nums[left++];\\n            }\\n        }\\n        return nums.length - maxWinSize;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    //Runtime: 135 ms, faster than 35.76% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //Memory Usage: 121.5 MB, less than 6.06% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //slide window + hashmap\\n    //Time: O(N* lgN + 2N) ; Space: O(N)\\n    //N is the length of array. L is the\\n    public int minOperations_1(int[] nums) {\\n        //Time: O(N*lgN)\\n        Arrays.sort(nums);\\n\\n        int maxWinSize = 0;\\n        int left = 0, right = 0;\\n\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        while (right < nums.length){\\n\\n            seen.put(nums[right], seen.getOrDefault(nums[right++], 0) + 1);\\n            maxWinSize = Math.max(maxWinSize, seen.keySet().size());\\n\\n\\t\\t\\t//move left pointer\\n            while (right < nums.length && nums[right] - nums[left] >= nums.length) {\\n                int c = seen.get(nums[left]) - 1;\\n                if (c <= 0) seen.remove(nums[left]);\\n                else seen.put(nums[left], c);\\n                left++;\\n            }\\n        }\\n        return nums.length - maxWinSize;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    //Runtime: 59 ms, faster than 74.55% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //Memory Usage: 77.6 MB, less than 77.58% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //Slide window\\n    //Time: O(N*lgN + 2N); Space:O(1);\\n    public int minOperations(int[] nums) {\\n        //Time: O(N*lgN)\\n        Arrays.sort(nums);\\n\\n        int maxWinSize = 0;\\n        int numCount = 0, lastValue = nums[0] - 1;\\n        int left = 0, right = 0;\\n\\n        //Time: worst case: O(2N).\\n        // Left & right pointer visited every number once respectively.\\n        while (right < nums.length){\\n            if (nums[right] != lastValue) numCount++;   //skip duplicated numbers\\n            lastValue = nums[right++];\\n            maxWinSize = Math.max(maxWinSize, numCount);\\n\\n            //move left\\n            int tmp = nums[left] - 1;\\n            while (right < nums.length && nums[right] - nums[left] >= nums.length) {\\n                if (nums[left] != tmp) numCount--;  //skip duplicated numbers\\n                tmp = nums[left++];\\n            }\\n        }\\n        return nums.length - maxWinSize;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////\\n    //Runtime: 135 ms, faster than 35.76% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //Memory Usage: 121.5 MB, less than 6.06% of Java online submissions for Minimum Number of Operations to Make Array Continuous.\\n    //slide window + hashmap\\n    //Time: O(N* lgN + 2N) ; Space: O(N)\\n    //N is the length of array. L is the\\n    public int minOperations_1(int[] nums) {\\n        //Time: O(N*lgN)\\n        Arrays.sort(nums);\\n\\n        int maxWinSize = 0;\\n        int left = 0, right = 0;\\n\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        while (right < nums.length){\\n\\n            seen.put(nums[right], seen.getOrDefault(nums[right++], 0) + 1);\\n            maxWinSize = Math.max(maxWinSize, seen.keySet().size());\\n\\n\\t\\t\\t//move left pointer\\n            while (right < nums.length && nums[right] - nums[left] >= nums.length) {\\n                int c = seen.get(nums[left]) - 1;\\n                if (c <= 0) seen.remove(nums[left]);\\n                else seen.put(nums[left], c);\\n                left++;\\n            }\\n        }\\n        return nums.length - maxWinSize;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2416949,
                "title": "python-3-binary-search",
                "content": "\\tclass Solution:\\n\\t\\tdef minOperations(self, nums: List[int]) -> int:\\n\\t\\t\\tA=sorted(set(nums))\\n\\t\\t\\tdef search(v):\\n\\t\\t\\t\\tl,r=0,len(A)-1\\n\\t\\t\\t\\tres=len(A)-1\\n\\t\\t\\t\\twhile l<=r:\\n\\t\\t\\t\\t\\tmid=l+(r-l)//2\\n\\t\\t\\t\\t\\tif A[mid]<=v:\\n\\t\\t\\t\\t\\t\\tres=mid\\n\\t\\t\\t\\t\\t\\tl=mid+1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tr=mid-1\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tcorrect=0\\n\\t\\t\\tfor i,x in enumerate(A):\\n\\t\\t\\t\\ta=search(x+len(nums)-1)\\n\\t\\t\\t\\tcorrect=max(a-i+1,correct)\\n\\t\\t\\treturn len(nums)-correct",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minOperations(self, nums: List[int]) -> int:\\n\\t\\t\\tA=sorted(set(nums))\\n\\t\\t\\tdef search(v):\\n\\t\\t\\t\\tl,r=0,len(A)-1\\n\\t\\t\\t\\tres=len(A)-1\\n\\t\\t\\t\\twhile l<=r:\\n\\t\\t\\t\\t\\tmid=l+(r-l)//2\\n\\t\\t\\t\\t\\tif A[mid]<=v:\\n\\t\\t\\t\\t\\t\\tres=mid\\n\\t\\t\\t\\t\\t\\tl=mid+1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tr=mid-1\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tcorrect=0\\n\\t\\t\\tfor i,x in enumerate(A):\\n\\t\\t\\t\\ta=search(x+len(nums)-1)\\n\\t\\t\\t\\tcorrect=max(a-i+1,correct)\\n\\t\\t\\treturn len(nums)-correct",
                "codeTag": "Java"
            },
            {
                "id": 2397163,
                "title": "0-nlogn-java-binary-search",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n       /*\\n       nums[i] --> first element \\n       \\n       1 2 3 5 6  last element \\n       \\n         nums[j]-nums[i] < n\\n         nums[j] < n+nums[i]\\n         \\n       */\\n        int n=nums.length;\\n        List<Integer>A=new ArrayList<>();\\n        Arrays.sort(nums);\\n        int i=0;\\n        while(i<nums.length){ //store unique ele\\n            int j=i;\\n            while(j<nums.length && nums[j]==nums[i])j++;\\n            A.add(nums[i]);\\n            i=j;\\n        }\\n        \\n        int max=1;\\n        for(i=0;i<A.size()-1;i++){\\n           //consider it as first ele\\n            int l=i+1;\\n            int h=A.size()-1;\\n            \\n            while(l<=h){\\n                int mid=(l+h)>>1;\\n                \\n                if(A.get(mid) < n+A.get(i))\\n                    l=mid+1;\\n                else\\n                    h=mid-1;\\n            }\\n            max=Math.max(max,h-i+1); //this much elements already discovered\\n            \\n        }\\n        return n-max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n       /*\\n       nums[i] --> first element \\n       \\n       1 2 3 5 6  last element \\n       \\n         nums[j]-nums[i] < n\\n         nums[j] < n+nums[i]\\n         \\n       */\\n        int n=nums.length;\\n        List<Integer>A=new ArrayList<>();\\n        Arrays.sort(nums);\\n        int i=0;\\n        while(i<nums.length){ //store unique ele\\n            int j=i;\\n            while(j<nums.length && nums[j]==nums[i])j++;\\n            A.add(nums[i]);\\n            i=j;\\n        }\\n        \\n        int max=1;\\n        for(i=0;i<A.size()-1;i++){\\n           //consider it as first ele\\n            int l=i+1;\\n            int h=A.size()-1;\\n            \\n            while(l<=h){\\n                int mid=(l+h)>>1;\\n                \\n                if(A.get(mid) < n+A.get(i))\\n                    l=mid+1;\\n                else\\n                    h=mid-1;\\n            }\\n            max=Math.max(max,h-i+1); //this much elements already discovered\\n            \\n        }\\n        return n-max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371953,
                "title": "c-easy-to-understand",
                "content": "We can see that the optimal way is to choose one number in nums as highest or lowest. This is my simple code implement this idea using binary search. If you find this helpful, please upvote. Thank you for reading.\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int res = INT_MAX;\\n        nums.erase( unique( nums.begin(), nums.end() ), nums.end() );\\n        for(int i=0; i<nums.size(); i++){\\n            int upper = nums[i]+(n-1);\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            int save = i;\\n            while(low<=high){\\n                int mid = (low+high)/2;\\n                if(nums[mid]<=upper){\\n                    save = mid;\\n                    low = mid+1;\\n                }\\n                else{\\n                    high = mid-1;\\n                }\\n            }\\n            res = min(res, n-(save-i+1));\\n            int lower = nums[i]-(n-1);\\n            low = 0;\\n            high = i-1;\\n            save = i;\\n            while(low<=high){\\n                int mid = (low+high)/2;\\n                if(nums[mid]>=lower){\\n                    high = mid-1;\\n                    save = mid;\\n                }\\n                else{\\n                    low = mid+1;\\n                }\\n            }\\n            res = min(res, n-(i-save+1));\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int res = INT_MAX;\\n        nums.erase( unique( nums.begin(), nums.end() ), nums.end() );\\n        for(int i=0; i<nums.size(); i++){\\n            int upper = nums[i]+(n-1);\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            int save = i;\\n            while(low<=high){\\n                int mid = (low+high)/2;\\n                if(nums[mid]<=upper){\\n                    save = mid;\\n                    low = mid+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2291777,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        set<int> s;\\n        for(auto& a: nums) s.insert(a);\\n        int uni = s.size();\\n\\t\\t// Find the occurances of duplicates, for those duplicates, we have to change them.\\n        int dup = n - uni;\\n        \\n        vector<int> v;\\n        for(auto& a: s) v.push_back(a);\\n        \\n        int ans = n-1;\\n\\t\\t// The vector v contains unique elements in nums. \\n\\t\\t// For each element in v, we can choose that element as the start of the sequence, and count how many elements in v are already in the sequences (we don\\'t need to change those elements). For the rest of the elements in v, we need to modify them.\\n        for(int i=0; i<uni; ++i) {\\n            int s = v[i], e = v[i] + n- 1;\\n            auto it1 = lower_bound(v.begin(), v.end(), s);\\n            auto it2 = upper_bound(v.begin(), v.end(), e);\\n            int coverage = it2 - it1;\\n            ans = min(ans, uni - coverage);\\n        }\\n        return ans + dup;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        set<int> s;\\n        for(auto& a: nums) s.insert(a);\\n        int uni = s.size();\\n\\t\\t// Find the occurances of duplicates, for those duplicates, we have to change them.\\n        int dup = n - uni;\\n        \\n        vector<int> v;\\n        for(auto& a: s) v.push_back(a);\\n        \\n        int ans = n-1;\\n\\t\\t// The vector v contains unique elements in nums. \\n\\t\\t// For each element in v, we can choose that element as the start of the sequence, and count how many elements in v are already in the sequences (we don\\'t need to change those elements). For the rest of the elements in v, we need to modify them.\\n        for(int i=0; i<uni; ++i) {\\n            int s = v[i], e = v[i] + n- 1;\\n            auto it1 = lower_bound(v.begin(), v.end(), s);\\n            auto it2 = upper_bound(v.begin(), v.end(), e);\\n            int coverage = it2 - it1;\\n            ans = min(ans, uni - coverage);\\n        }\\n        return ans + dup;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276400,
                "title": "cpp-easy-to-understand-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        //ws = window start, we = window end\\n        //for every element consider it as start of window\\n        int n=nums.size(), i, res=INT_MAX, ws, we, j=0;\\n        sort(nums.begin(), nums.end());\\n        //Remove the duplicacy\\n        nums.erase(unique(begin(nums), end(nums)), end(nums));\\n        int n2=nums.size();\\n        const int diff = n-1;\\n        for(i=0;i<n2;++i){\\n            //array may contain duplicates so this line will be saviour\\n            if(i>0 and nums[i]==nums[i-1]) continue;\\n            ws = nums[i];\\n            we = nums[i]+diff;\\n            while(j<n2 and nums[j]<=we) j++;\\n            //from i to j-1 we have got elements which do not need to be replaced\\n            res = min(res, n-(j-i));\\n            if(res==0) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        //ws = window start, we = window end\\n        //for every element consider it as start of window\\n        int n=nums.size(), i, res=INT_MAX, ws, we, j=0;\\n        sort(nums.begin(), nums.end());\\n        //Remove the duplicacy\\n        nums.erase(unique(begin(nums), end(nums)), end(nums));\\n        int n2=nums.size();\\n        const int diff = n-1;\\n        for(i=0;i<n2;++i){\\n            //array may contain duplicates so this line will be saviour\\n            if(i>0 and nums[i]==nums[i-1]) continue;\\n            ws = nums[i];\\n            we = nums[i]+diff;\\n            while(j<n2 and nums[j]<=we) j++;\\n            //from i to j-1 we have got elements which do not need to be replaced\\n            res = min(res, n-(j-i));\\n            if(res==0) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263301,
                "title": "java-o-nlogn-using-sliding-window",
                "content": "Idea is to fix a min value and count all the numbers which are greater than num[i]+nums.length and less than nums[i], the obtained count is the number of changes to be made. Find this for all possible values of min.\\n```\\npublic int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int count=Integer.MAX_VALUE,j=1,dup=0;\\n        int[] dupArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            while(j<nums.length&&nums[j]<=nums[i]+nums.length-1) {\\n                if(nums[j]==nums[j-1]) ++dup;\\n                dupArr[j]=dup;\\n                j++;\\n            }\\n            count = Math.min(count, i+(nums.length-j)+dup-dupArr[i]);\\n        }\\n        return count;\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "Idea is to fix a min value and count all the numbers which are greater than num[i]+nums.length and less than nums[i], the obtained count is the number of changes to be made. Find this for all possible values of min.\\n```\\npublic int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int count=Integer.MAX_VALUE,j=1,dup=0;\\n        int[] dupArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            while(j<nums.length&&nums[j]<=nums[i]+nums.length-1) {\\n                if(nums[j]==nums[j-1]) ++dup;\\n                dupArr[j]=dup;\\n                j++;\\n            }\\n            count = Math.min(count, i+(nums.length-j)+dup-dupArr[i]);\\n        }\\n        return count;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2212827,
                "title": "python-o-n-clean-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = list(set(nums))\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        left = 0\\n        for i in range(len(nums)):\\n            while left<i and nums[left]<nums[i] - n+1:\\n                left+=1 \\n            count = i - left +1 \\n            ans = min(ans , n - count)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = list(set(nums))\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        left = 0\\n        for i in range(len(nums)):\\n            while left<i and nums[left]<nums[i] - n+1:\\n                left+=1 \\n            count = i - left +1 \\n            ans = min(ans , n - count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090679,
                "title": "python-short-solution-using-two-pointers",
                "content": "Take the unique elements and sort thems, now with each index `i` find the farthest index `j` such that the value at index `j` doest exceed the value at index `i` + `len(nums)-1`, all the other elements not in this range must be replaced (of course the duplicated original ones must be replaced as well), the number of elements must be replaces equal to `original_length(nums) - length_of_range([i...j])`\\n\\n```python\\ndef minOperations(self, nums: List[int]) -> int:\\n        j = 0 \\n        res = n = len(nums)\\n        nums = sorted(set(nums))\\n        for i,v in enumerate(nums):\\n            while j < len(nums) and nums[j] <= v + n - 1 :\\n                j += 1\\n            res = min(res, n - j + i )\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minOperations(self, nums: List[int]) -> int:\\n        j = 0 \\n        res = n = len(nums)\\n        nums = sorted(set(nums))\\n        for i,v in enumerate(nums):\\n            while j < len(nums) and nums[j] <= v + n - 1 :\\n                j += 1\\n            res = min(res, n - j + i )\\n            \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2057984,
                "title": "c-the-logical-width-and-the-physical-width-of-the-sliding-window",
                "content": "Idea: sliding window\\n* sort the numbers, and dedup them.\\n* run a sliding window that covers the logical width of n contiguous integers\\n* logical width of the sliding window is  `A[j] - A[i]`,\\nwhereas physical width of the sliding window is j - i.\\n\\n\\nthe discrepancy between\\n* the logical size of the problem and\\n* physical width of the sliding window\\n\\nare the # of missing integers.\\nso we\\'ll need that # of operations to insert those missing numbers.\\n\\n```\\n// Idea: sliding window\\n// * sort the numbers, and dedup them.\\n// * run a sliding window that covers the logical width of n contiguous integers.\\n// * logical width of the sliding window is  `A[j] - A[i]`,\\n// whereas physical width of the sliding window is j - i.\\n// the discrepancy between\\n// * the logical size of the problem and\\n// * physical width of the sliding window\\n// are the # of missing integers.\\n// so we\\'ll need that # of operations to insert those missing numbers.\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        const int logicalSize = A.size(); // logical size of the problem\\n        // sort the input array.\\n        sort(A.begin(), A.end());\\n        // remove the duplicates, aka dedup\\n        A.erase(std::unique(A.begin(), A.end()), A.end());\\n        // the physical size after dedup\\n        const int n = A.size();\\n\\n        int res = INT_MAX;\\n        // sliding window\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            // logical width of the sliding window:  `A[j] - A[i]`;\\n            // whereas physical width of ... is j - i\\n            while (j < n && A[j] - A[i] < logicalSize) {\\n                ++j;\\n            }\\n            const int prevJ = j - 1;\\n            const int physicalWidth = prevJ - i + 1;\\n            // the discrepancy between\\n            // * the logical size of the problem and\\n            // * physical width of the sliding window\\n            // are the # of missing integers.\\n            // so we\\'ll need that # of operations to insert those missing numbers.\\n            res = min(res, logicalSize - physicalWidth);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n// Idea: sliding window\\n// * sort the numbers, and dedup them.\\n// * run a sliding window that covers the logical width of n contiguous integers.\\n// * logical width of the sliding window is  `A[j] - A[i]`,\\n// whereas physical width of the sliding window is j - i.\\n// the discrepancy between\\n// * the logical size of the problem and\\n// * physical width of the sliding window\\n// are the # of missing integers.\\n// so we\\'ll need that # of operations to insert those missing numbers.\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        const int logicalSize = A.size(); // logical size of the problem\\n        // sort the input array.\\n        sort(A.begin(), A.end());\\n        // remove the duplicates, aka dedup\\n        A.erase(std::unique(A.begin(), A.end()), A.end());\\n        // the physical size after dedup\\n        const int n = A.size();\\n\\n        int res = INT_MAX;\\n        // sliding window\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            // logical width of the sliding window:  `A[j] - A[i]`;\\n            // whereas physical width of ... is j - i\\n            while (j < n && A[j] - A[i] < logicalSize) {\\n                ++j;\\n            }\\n            const int prevJ = j - 1;\\n            const int physicalWidth = prevJ - i + 1;\\n            // the discrepancy between\\n            // * the logical size of the problem and\\n            // * physical width of the sliding window\\n            // are the # of missing integers.\\n            // so we\\'ll need that # of operations to insert those missing numbers.\\n            res = min(res, logicalSize - physicalWidth);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998975,
                "title": "python3-sliding-window",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        j = 0\\n        result = math.inf\\n        count = 0 # count the number of value could be used in the array, in this case n - count will be the number of swaps needed\\n        hashmap = defaultdict(int) # handle duplicate value, for each duplicate value, we only count it once\\n        \\n        for i in range(n):\\n            \\n            while j < n and nums[j] - nums[i] < n:\\n                if hashmap[nums[j]] == 0:\\n                    count += 1\\n                hashmap[nums[j]] += 1\\n                j += 1\\n            result = min(result, n - count)\\n            \\n            hashmap[nums[i]] -= 1\\n            if hashmap[nums[i]] == 0:\\n                count -= 1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        j = 0\\n        result = math.inf\\n        count = 0 # count the number of value could be used in the array, in this case n - count will be the number of swaps needed\\n        hashmap = defaultdict(int) # handle duplicate value, for each duplicate value, we only count it once\\n        \\n        for i in range(n):\\n            \\n            while j < n and nums[j] - nums[i] < n:\\n                if hashmap[nums[j]] == 0:\\n                    count += 1\\n                hashmap[nums[j]] += 1\\n                j += 1\\n            result = min(result, n - count)\\n            \\n            hashmap[nums[i]] -= 1\\n            if hashmap[nums[i]] == 0:\\n                count -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991457,
                "title": "naive-c-approach-sliding-window",
                "content": "The basic idea is we\\'ll assume each element as starting (the min one) \\nthen run a sliding window to check how many of the rest elements are in it\\'s capacity   `{min one, min one + N - 1}`  where `N` is size of array.\\n\\nExample: 11 12 16 51 52 99\\nconsider 11 as starting min one -> we got 2 more 12, 16\\nconsider 12 as starting min one -> we got 1 more 16\\nconsider 16 as starting min one -> we got nothing\\nconsider 51 as starting min one -> we got 1 more 52\\n...\\n\\n\\n\\n```\\n\\t\\tint n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\t\\t//we\\'re removing the duplicates as those aren\\'t useful here\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        int m = nums.size();\\n        int res = n;\\n        \\n        //Now for each element we\\'re finding out how many of the rest are good to be included\\n        for(int i=0; i<m; i++){\\n\\t\\t\\tint j = i+1;\\n            while(j<m && nums[j]<=nums[i]+n-1) j++;\\n            res = min(res, n-(j-i));\\n        }\\n        return res;\\n```\\n\\nP.S. The 2nd part of the code is just for simple understanding but gives TLE due to t.c. being O(N^2)\\nwe can make it O(N) by the initializing `j` just one:\\n```\\n\\t\\tint j = 0;\\n        for(int i=0; i<m; i++){\\n            while(j<m && nums[j]<=nums[i]+n-1) j++;\\n            res = min(res, n-(j-i));\\n        }\\n        return res;\\n```\\n\\n**Overall correct code:**\\n```\\n\\t\\tint n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        int m = nums.size();\\n        int res = n;\\n        int j = 0;\\n        for(int i=0; i<m; i++){\\n            while(j<m && nums[j]<=nums[i]+n-1) j++;\\n            res = min(res, n-(j-i));\\n        }\\n        return res;\\n```\\n\\nFor easy-visual understanding watch this: https://www.youtube.com/watch?v=Z2DloBdu6NU",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n\\t\\tint n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\t\\t//we\\'re removing the duplicates as those aren\\'t useful here\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        int m = nums.size();\\n        int res = n;\\n        \\n        //Now for each element we\\'re finding out how many of the rest are good to be included\\n        for(int i=0; i<m; i++){\\n\\t\\t\\tint j = i+1;\\n            while(j<m && nums[j]<=nums[i]+n-1) j++;\\n            res = min(res, n-(j-i));\\n        }\\n        return res;\\n```\n```\\n\\t\\tint j = 0;\\n        for(int i=0; i<m; i++){\\n            while(j<m && nums[j]<=nums[i]+n-1) j++;\\n            res = min(res, n-(j-i));\\n        }\\n        return res;\\n```\n```\\n\\t\\tint n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        int m = nums.size();\\n        int res = n;\\n        int j = 0;\\n        for(int i=0; i<m; i++){\\n            while(j<m && nums[j]<=nums[i]+n-1) j++;\\n            res = min(res, n-(j-i));\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937670,
                "title": "java-sliding-window",
                "content": "```\\n\\tpublic int minOperations(int[] nums) {\\n        int N = nums.length;\\n        // Make the input sorted + unique first\\n        Set<Integer> unique = new HashSet();\\n        for(int n: nums) unique.add(n);\\n        int[] sorted = new int[unique.size()];\\n        int id = 0;\\n        for(int n: unique) sorted[id++] = n;\\n        Arrays.sort(sorted);\\n        int M = sorted.length;\\n        \\n        int ans = N;\\n        int j = 0;\\n        for(int i = 0;i < M;i++){\\n            int curr = sorted[i];// Consider curr element as the starting element of sequence\\n            int end = curr+N-1;// Then this would be end element of sequence\\n            // Find total number already present in this range of [curr,end] in sorted array\\n            \\n            while(j < M && sorted[j] <= end) j++;// As array is sorted, so j would be defntly greater for next element(i++) iteration, so we don\\'t reset j\\n            int numberLeft = N-j+i;\\n            ans = Math.min(ans, numberLeft);\\n        }\\n        return ans;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minOperations(int[] nums) {\\n        int N = nums.length;\\n        // Make the input sorted + unique first\\n        Set<Integer> unique = new HashSet();\\n        for(int n: nums) unique.add(n);\\n        int[] sorted = new int[unique.size()];\\n        int id = 0;\\n        for(int n: unique) sorted[id++] = n;\\n        Arrays.sort(sorted);\\n        int M = sorted.length;\\n        \\n        int ans = N;\\n        int j = 0;\\n        for(int i = 0;i < M;i++){\\n            int curr = sorted[i];// Consider curr element as the starting element of sequence\\n            int end = curr+N-1;// Then this would be end element of sequence\\n            // Find total number already present in this range of [curr,end] in sorted array\\n            \\n            while(j < M && sorted[j] <= end) j++;// As array is sorted, so j would be defntly greater for next element(i++) iteration, so we don\\'t reset j\\n            int numberLeft = N-j+i;\\n            ans = Math.min(ans, numberLeft);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922476,
                "title": "binary-search-and-the-intuition-behind-it",
                "content": "Lets start with the intuition first. \\n\\nIt wasn\\'t easy for me to approach this problem. At first I was looking into figuring out the longest continuous series and tried playing around with the idea. But after a while I realised that\\'s not the way to go, since different smaller continuous sequences may add up later to form a bigger sequence. So, the problem really is how do you know these disconnected continuous sequences can be part of a bigger continuous sequence. \\n\\nThink for a moment and try to come up with the intuition. Or you can scroll down and read the core idea.i\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // gives the leftmost number in left orbit\\n    int bs_left(vector<int>& nums, int x) {\\n        int l = 0, r = nums.size() - 1;\\n        while(l <= r) {\\n            int m = (l + r) / 2;\\n            if(x <= nums[m]) {\\n                r = m - 1;\\n            } else\\n                l = m + 1;\\n        }\\n        return l;\\n    }\\n    \\n    // gives the rightmost number in right orbit\\n    int bs_right(vector<int>& nums, int x) {\\n        int l = 0, r = nums.size() - 1;\\n        while(l <= r) {\\n            int m = (l + r) / 2;\\n            if(x < nums[m]) {\\n                r = m - 1;\\n            } else\\n                l = m + 1;\\n        }\\n        return r;\\n    }\\n  \\n    \\n    int satellites_left(vector<int>& nums, vector<int>& duplicates, int k, int l) {\\n        int n = nums.size();\\n        int dl = duplicates[k] - duplicates[l];\\n        int nl = k - l - dl;\\n        return nl;\\n    } \\n    \\n    int satellites_right(vector<int>& nums, vector<int>& duplicates, int k, int r) {\\n        int n = nums.size();\\n        //int r = bs_right(nums, nums[k] + (n - 1) - x);\\n        int dr = duplicates[r] - duplicates[k]; \\n        int nr = r - k - dr;\\n        return nr;\\n    }\\n```\\n**The core idea is to look into the orbit of a number.**\\nWe need to find the range of distinct satellite numbers that can be part of the longest sequence and subtract that from the array length.\\nSo, if the length of the array is n. For each number nums[k] in the array we can look up the potential numbers (satellites) that would fall in the left or right orbit of nums[k] such that the whole sequence is of length n. \\n**The reason I am using the term satellites is to help visuallise the gaps(missing numbers) in the squence** \\nNote the size of the orbit (left and right) is defined by the numbers that can become part of the larger sequence. \\n\\n{nums[0], nums[1], nums[2], .....nums[k],........,nums[n]}\\n\\nCase 1 : Look left orbit with nums[k] being the rightmost number.\\nNumbers in range\\n(nums[k] - (n - 1),  nums[k])\\nCase 2 : Look right orbit with nums[k] begin the leftmost number.\\nNumbers in range\\n(nums[k], nums[k] + n - 1)\\n\\nCase 3 : nums[k] is not in extreme ends of the sequence : fix right orbit with rightmost satellite and look if any remaining numbers in left orbit; \\nCase 4 : nums[k] is not in extreme ends of the sequence : fix left orbit with leftmost satellite and look if any remaining numbers in right orbit; \\n\\n\\n```\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ops = 0;\\n        \\n        // array to track number of duplicates seen so far.\\n        vector<int> duplicates(n);\\n        duplicates[0] = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(nums[i] == nums[i - 1]) {\\n                duplicates[i] = duplicates[i - 1] + 1;\\n            } else\\n                duplicates[i] = duplicates[i - 1];\\n        }\\n        \\n        for(int k = 0; k < n; k++) {\\n            // Case 1 : left orbit; nums[k] is rightmost number in sequence\\n\\t\\t\\t\\n            int l = bs_left(nums, nums[k] - (n - 1));\\n            int nl = satellites_left(nums, duplicates, k, l);\\n            ops = max(ops, nl + 1);\\n\\t\\t\\t\\n            // Case 2 : right orbit; nums[k] is leftmost number in sequence\\n            int r = bs_right(nums, nums[k] + (n - 1));\\n            int nr = satellites_right(nums, duplicates, k, r);\\n            ops = max(ops, nr + 1);\\n            \\n            \\n            // Case 3 : fix right orbit and look if any remaining numbers in left orbit; nums[i] is not in extreme ends of the sequence\\n            int l1 = bs_left(nums, nums[k] - (n - 1) + nums[r] - nums[k]);\\n            int xl = satellites_left(nums, duplicates, k, l1);\\n\\t\\t\\t\\n\\t\\t\\t// Case 4 : fix left orbit and look if any remaining numbers in right orbit; nums[i] is not in extreme ends of the sequence\\n            int r1 = bs_right(nums, nums[k] + (n - 1) - (nums[k] - nums[l]));\\n            int xr = satellites_right(nums, duplicates, k, r1);\\n\\t\\t\\t\\n            ops = max(ops, nl + xr + 1);\\n            ops = max(ops, nr + xl + 1);\\n\\n        }\\n        return n - ops;\\n    }\\n};\\n```\\nI hope that gives you the idea as to how to approach such problems in future. \\nA similar kind of problem for working on your intuition.\\nhttps://leetcode.com/problems/minimum-increment-to-make-array-unique/\\n\\n",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // gives the leftmost number in left orbit\\n    int bs_left(vector<int>& nums, int x) {\\n        int l = 0, r = nums.size() - 1;\\n        while(l <= r) {\\n            int m = (l + r) / 2;\\n            if(x <= nums[m]) {\\n                r = m - 1;\\n            } else\\n                l = m + 1;\\n        }\\n        return l;\\n    }\\n    \\n    // gives the rightmost number in right orbit\\n    int bs_right(vector<int>& nums, int x) {\\n        int l = 0, r = nums.size() - 1;\\n        while(l <= r) {\\n            int m = (l + r) / 2;\\n            if(x < nums[m]) {\\n                r = m - 1;\\n            } else\\n                l = m + 1;\\n        }\\n        return r;\\n    }\\n  \\n    \\n    int satellites_left(vector<int>& nums, vector<int>& duplicates, int k, int l) {\\n        int n = nums.size();\\n        int dl = duplicates[k] - duplicates[l];\\n        int nl = k - l - dl;\\n        return nl;\\n    } \\n    \\n    int satellites_right(vector<int>& nums, vector<int>& duplicates, int k, int r) {\\n        int n = nums.size();\\n        //int r = bs_right(nums, nums[k] + (n - 1) - x);\\n        int dr = duplicates[r] - duplicates[k]; \\n        int nr = r - k - dr;\\n        return nr;\\n    }\\n```\n```\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ops = 0;\\n        \\n        // array to track number of duplicates seen so far.\\n        vector<int> duplicates(n);\\n        duplicates[0] = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(nums[i] == nums[i - 1]) {\\n                duplicates[i] = duplicates[i - 1] + 1;\\n            } else\\n                duplicates[i] = duplicates[i - 1];\\n        }\\n        \\n        for(int k = 0; k < n; k++) {\\n            // Case 1 : left orbit; nums[k] is rightmost number in sequence\\n\\t\\t\\t\\n            int l = bs_left(nums, nums[k] - (n - 1));\\n            int nl = satellites_left(nums, duplicates, k, l);\\n            ops = max(ops, nl + 1);\\n\\t\\t\\t\\n            // Case 2 : right orbit; nums[k] is leftmost number in sequence\\n            int r = bs_right(nums, nums[k] + (n - 1));\\n            int nr = satellites_right(nums, duplicates, k, r);\\n            ops = max(ops, nr + 1);\\n            \\n            \\n            // Case 3 : fix right orbit and look if any remaining numbers in left orbit; nums[i] is not in extreme ends of the sequence\\n            int l1 = bs_left(nums, nums[k] - (n - 1) + nums[r] - nums[k]);\\n            int xl = satellites_left(nums, duplicates, k, l1);\\n\\t\\t\\t\\n\\t\\t\\t// Case 4 : fix left orbit and look if any remaining numbers in right orbit; nums[i] is not in extreme ends of the sequence\\n            int r1 = bs_right(nums, nums[k] + (n - 1) - (nums[k] - nums[l]));\\n            int xr = satellites_right(nums, duplicates, k, r1);\\n\\t\\t\\t\\n            ops = max(ops, nl + xr + 1);\\n            ops = max(ops, nr + xl + 1);\\n\\n        }\\n        return n - ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872256,
                "title": "python-sorting-with-thought-process-when-being-asked-during-interviews",
                "content": "### Sorting + Sliding Window\\nI always start analying the problem by figuring out the invariance, which is facts that won\\'t be changed with different input.\\nSpecific to this problem, we can get invariance as below:\\n* disctinct numbers\\n* continues numbers\\n\\nWhat can we get by looking at this 2 conditions? the resulted `nums` must be a range with fixed length. So if we know the range and the number of elements fall into the range, we  can get the result by `n  - max(size of falling)`. \\nThen how can we get the range? since the length is fixed, the range is determined by the starting number. So we can simiply iterate each number as starting number and calculate the number of elements falling into the range using prefix sum that returns the result in constant time.\\n```\\ndef minOperations(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n    prex = [0] * (nums[-1] + 1)\\n    for num in nums:\\n\\t\\tprex[num] = 1\\n \\n\\tfor i in range(1, len(prex)):\\n\\t\\tprex[i] += prex[i - 1]\\n        \\n\\tres, n = float(\\'inf\\'), len(nums)\\n    for num in nums:\\n\\t\\tres = min(res, n - prex[min(num + n - 1, nums[-1])] + prex[num - 1])\\n\\treturn res\\n```\\n\\nHowever, you will get `Memory Exceeds Limits` error because the maximum number might be very large. \\nInstead of using prefix sum, if we know the index of range placed in the elements, then we also are able to know the number of elements enclosed by the range, in addition to sort `nums`. Binary Search!\\nActually we can do it better since the lenght of range is fixed, we can shift the window from left to right without doing binary search each time. Whenver we move on to the next element, we try to extend the window to cover possible elements to the end of `nums`. The complexity is linear not *n^2*, you can think about why.\\n```python\\ndef minOperations(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n    nums = sorted(set(nums))\\n    min_ops, j = n, 0\\n    for i, num in enumerate(nums):\\n\\t\\twhile j < len(nums) and nums[j] < num + n:\\n\\t\\t\\tj += 1\\n\\t\\tmin_ops = min(min_ops, n - j + i)\\n\\treturn min_ops\\n```\\n\\n*Time Complexity*= **O(NlgN)**\\n*Space Complexity*= **O(1)**",
                "solutionTags": [],
                "code": "```\\ndef minOperations(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n    prex = [0] * (nums[-1] + 1)\\n    for num in nums:\\n\\t\\tprex[num] = 1\\n \\n\\tfor i in range(1, len(prex)):\\n\\t\\tprex[i] += prex[i - 1]\\n        \\n\\tres, n = float(\\'inf\\'), len(nums)\\n    for num in nums:\\n\\t\\tres = min(res, n - prex[min(num + n - 1, nums[-1])] + prex[num - 1])\\n\\treturn res\\n```\n```python\\ndef minOperations(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n    nums = sorted(set(nums))\\n    min_ops, j = n, 0\\n    for i, num in enumerate(nums):\\n\\t\\twhile j < len(nums) and nums[j] < num + n:\\n\\t\\t\\tj += 1\\n\\t\\tmin_ops = min(min_ops, n - j + i)\\n\\treturn min_ops\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1830069,
                "title": "c-sort-lower-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int k=INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        int n=nums.size();\\n        int ind= unique(nums.begin(), nums.end())- nums.begin(); //returns number of unique elements and places unique elements in first \\'ind\\' indices\\n        nums.resize(ind);\\n        for(int i=0; i<nums.size(); i++){\\n            int l= lower_bound(nums.begin(), nums.end(), nums[i]+n)- nums.begin();\\n            k= min(k, n-l+i);\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int k=INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        int n=nums.size();\\n        int ind= unique(nums.begin(), nums.end())- nums.begin(); //returns number of unique elements and places unique elements in first \\'ind\\' indices\\n        nums.resize(ind);\\n        for(int i=0; i<nums.size(); i++){\\n            int l= lower_bound(nums.begin(), nums.end(), nums[i]+n)- nums.begin();\\n            k= min(k, n-l+i);\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809477,
                "title": "how-5-is-a-possible-solution",
                "content": "For array :[41,33,29,33,35,26,47,24,18,28] (sorted to [18,24,26,28,29,33,33,35,41,47])\\n the expected output is 5 whereas I am getting 6. How is 6 a possible answer?",
                "solutionTags": [],
                "code": "For array :[41,33,29,33,35,26,47,24,18,28] (sorted to [18,24,26,28,29,33,33,35,41,47])\\n the expected output is 5 whereas I am getting 6. How is 6 a possible answer?",
                "codeTag": "Unknown"
            },
            {
                "id": 1781791,
                "title": "java-sliding-window-with-duplicates",
                "content": "while we maintain a valid window, we also need to update the count of duplicate numbers in the window\\n```\\npublic int minOperations(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tint n = nums.length;\\n\\tint duplicates = 0;\\n\\tint maxContinuous = 0;\\n\\tfor (int start = 0, end = 0; end < n; end++) {\\n\\t\\tif (end > 0 && nums[end] == nums[end - 1])\\n\\t\\t\\tduplicates++;\\n\\t\\twhile (nums[start] + n <= nums[end]) {\\n\\t\\t\\tstart++;\\n\\t\\t\\tif (nums[start] == nums[start - 1])\\n\\t\\t\\t\\tduplicates--;\\n\\t\\t}\\n\\t\\tmaxContinuous = Math.max(maxContinuous, end - start + 1 - duplicates);\\n\\t}\\n\\treturn n - maxContinuous;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tint n = nums.length;\\n\\tint duplicates = 0;\\n\\tint maxContinuous = 0;\\n\\tfor (int start = 0, end = 0; end < n; end++) {\\n\\t\\tif (end > 0 && nums[end] == nums[end - 1])\\n\\t\\t\\tduplicates++;\\n\\t\\twhile (nums[start] + n <= nums[end]) {\\n\\t\\t\\tstart++;\\n\\t\\t\\tif (nums[start] == nums[start - 1])\\n\\t\\t\\t\\tduplicates--;\\n\\t\\t}\\n\\t\\tmaxContinuous = Math.max(maxContinuous, end - start + 1 - duplicates);\\n\\t}\\n\\treturn n - maxContinuous;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774254,
                "title": "python3-solution",
                "content": "`\\n\\n\\nclass Solution:\\n\\n    def minOperations(self, nums: List[int]) -> int:\\n\\n        n=len(nums)\\n        snum=set(nums)\\n        nums2=sorted(list(snum))\\n        minans=float(\\'inf\\')\\n        for i in range(len(nums2)):\\n            end=nums2[i]+n-1\\n            endidx=bisect_left(nums2,end)\\n            if end in snum:\\n                minans=min(minans,n-(endidx-i+1))\\n            else:\\n                minans=min(minans,n-(endidx-i))\\n        return minans\\n`",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "`\\n\\n\\nclass Solution:\\n\\n    def minOperations(self, nums: List[int]) -> int:\\n\\n        n=len(nums)\\n        snum=set(nums)\\n        nums2=sorted(list(snum))\\n        minans=float(\\'inf\\')\\n        for i in range(len(nums2)):\\n            end=nums2[i]+n-1\\n            endidx=bisect_left(nums2,end)\\n            if end in snum:\\n                minans=min(minans,n-(endidx-i+1))\\n            else:\\n                minans=min(minans,n-(endidx-i))\\n        return minans\\n`",
                "codeTag": "Java"
            },
            {
                "id": 1762043,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Intution : First of all sort the array , then store the unique element in different array . Iterate over the unique array and for every element in unique array check how many element in range of (arr[i], arr[i] + (n - 1)) including . Then update the result accordingly .***\\n\\n* ***Time Complexity : O(NlogN)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nint minOperations(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        vector<int> v;\\n        \\n        v.push_back(arr[0]);\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            if(arr[i] == arr[i - 1]){\\n                \\n                continue;\\n            }\\n            \\n            v.push_back(arr[i]);\\n        }\\n        \\n        int res = n;\\n        \\n        for(int i = 0; i < v.size(); i++){\\n            \\n            int maxi = v[i] + n - 1;\\n            \\n            auto it = upper_bound(v.begin(), v.end(), maxi);\\n            \\n            int in_range = (it - v.begin()) - i; \\n            \\n            res = min(res, n - in_range); \\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nint minOperations(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        vector<int> v;\\n        \\n        v.push_back(arr[0]);\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            if(arr[i] == arr[i - 1]){\\n                \\n                continue;\\n            }\\n            \\n            v.push_back(arr[i]);\\n        }\\n        \\n        int res = n;\\n        \\n        for(int i = 0; i < v.size(); i++){\\n            \\n            int maxi = v[i] + n - 1;\\n            \\n            auto it = upper_bound(v.begin(), v.end(), maxi);\\n            \\n            int in_range = (it - v.begin()) - i; \\n            \\n            res = min(res, n - in_range); \\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735126,
                "title": "very-easy-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        map<int,int> mp;\\n        vector<int> v;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(mp[nums[i]]==0)v.push_back(nums[i]);\\n            mp[nums[i]]++;\\n        }\\n        sort(v.begin(),v.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int back=nums[i];\\n            int front=nums[i]+(n-1);\\n            int t=upper_bound(v.begin(),v.end(),front)-lower_bound(v.begin(),v.end(),back);\\n            ans=min(ans,n-t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        map<int,int> mp;\\n        vector<int> v;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(mp[nums[i]]==0)v.push_back(nums[i]);\\n            mp[nums[i]]++;\\n        }\\n        sort(v.begin(),v.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int back=nums[i];\\n            int front=nums[i]+(n-1);\\n            int t=upper_bound(v.begin(),v.end(),front)-lower_bound(v.begin(),v.end(),back);\\n            ans=min(ans,n-t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734981,
                "title": "python-soln",
                "content": "\\tclass Solution:\\n\\t\\tdef minOperations(self, nums: List[int]) -> int:\\n\\t\\t\\t# use binary search using bisect_right\\n\\t\\t\\t# Time O(nlogn), Space O(n)\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tnums = sorted(set(nums))\\n\\t\\t\\tresult = sys.maxsize\\n\\n\\t\\t\\tfor i, start in enumerate(nums):\\n\\t\\t\\t\\tend = start+n-1\\n\\t\\t\\t\\t# get the next insertion point for end to maintain sorted order\\n\\t\\t\\t\\tidx = bisect_right(nums, end)\\n\\n\\t\\t\\t\\t# (idx-i) will be the nums that do not need to change \\n\\t\\t\\t\\tresult = min(result, n-(idx-i))\\n\\n\\t\\t\\treturn result\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minOperations(self, nums: List[int]) -> int:\\n\\t\\t\\t# use binary search using bisect_right\\n\\t\\t\\t# Time O(nlogn), Space O(n)\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tnums = sorted(set(nums))\\n\\t\\t\\tresult = sys.maxsize\\n\\n\\t\\t\\tfor i, start in enumerate(nums):\\n\\t\\t\\t\\tend = start+n-1\\n\\t\\t\\t\\t# get the next insertion point for end to maintain sorted order\\n\\t\\t\\t\\tidx = bisect_right(nums, end)\\n\\n\\t\\t\\t\\t# (idx-i) will be the nums that do not need to change \\n\\t\\t\\t\\tresult = min(result, n-(idx-i))\\n\\n\\t\\t\\treturn result\\n",
                "codeTag": "Java"
            },
            {
                "id": 1728158,
                "title": "python-3-2-pointers-with-repetitions-tracked",
                "content": "\\n```\\n    def minOperations(self, nums: List[int]) -> int:\\n        nums.sort()\\n        nN = len(nums)\\n        \\n        nRep = 0\\n        r = -1                  # right index\\n        maxL = 1\\n        for l in range(nN):     # left index\\n            if l and nums[l]==nums[l-1]:\\n                nRep -= 1\\n                continue\\n            while r<nN-1 and nums[r+1]-nums[l]<nN:\\n                r += 1\\n                if r and nums[r]==nums[r-1]:\\n                    nRep += 1\\n                maxL = max(maxL, r-l+1-nRep)\\n            if r==nN-1:     break\\n        return nN - maxL\\n```",
                "solutionTags": [],
                "code": "```\\n    def minOperations(self, nums: List[int]) -> int:\\n        nums.sort()\\n        nN = len(nums)\\n        \\n        nRep = 0\\n        r = -1                  # right index\\n        maxL = 1\\n        for l in range(nN):     # left index\\n            if l and nums[l]==nums[l-1]:\\n                nRep -= 1\\n                continue\\n            while r<nN-1 and nums[r+1]-nums[l]<nN:\\n                r += 1\\n                if r and nums[r]==nums[r-1]:\\n                    nRep += 1\\n                maxL = max(maxL, r-l+1-nRep)\\n            if r==nN-1:     break\\n        return nN - maxL\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1722160,
                "title": "java-sort-2-pointers",
                "content": "~~~java\\n\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        \\n        int n = nums.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        Map<Integer, Integer> cnts = new HashMap<>();\\n        int rst = n;\\n        int uniqueCnt = 0;\\n        \\n        for (int i = 0, j = 0; i < n; i++) {\\n            int prevCnt = cnts.getOrDefault(nums[i], 0);\\n            if (prevCnt == 0) {\\n                uniqueCnt++;\\n            }\\n            cnts.put(nums[i], prevCnt + 1);\\n            \\n            while (nums[i] - nums[j] > n - 1) {\\n                prevCnt = cnts.get(nums[j]);\\n                if (prevCnt == 1) {\\n                    uniqueCnt--;\\n                }\\n                cnts.put(nums[j], prevCnt - 1);\\n                j++;\\n            }\\n            \\n            rst = Math.min(rst, n - uniqueCnt);\\n        }\\n        \\n        return rst;\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1697881,
                "title": "javascript-sliding-window",
                "content": "Based on the \"Use Non-shrinkable Sliding Window Template\" of https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/discuss/1470857/C%2B%2B-Sliding-Window\\n\\n```\\n\\nvar minOperations = function(nums) {\\n    if (nums.length == 0) return 0\\n\\t\\n    let n = nums.length \\n    \\n    nums.sort((a,b) => a-b)\\n    \\n    let m = 1 // length of array without dups \\n    \\n    // remove duplicates in place \\n    for (let i = 1; i < n; i ++) {\\n        if (nums[i] != nums[i -1]) {\\n            nums[m] = nums[i]\\n            m ++\\n        } \\n    }\\n     \\n    \\n    let i = 0 // start\\n    let j = 0 // end \\n    \\n    for(j = 0; j < m; j ++) {\\n        //console.log(\"j\",j, \"i\", i)\\n        //console.log(\"nums[i]\", nums[i])\\n        //console.log(\"nums[i] + n\", nums[i] + n)\\n        //console.log(\"nums[j]\", nums[j])                    \\n        \\n        if (nums[i] + n <= nums[j]) { // need to be replaced, outside the window\\n            //console.log(\"i++\", i + 1)\\n            \\n            i ++\\n        } \\n        \\n        //console.log(\"\\\\n\")\\n    }\\n    \\n    return n - m + i // (n-m) = duplicates. i = number of items too small to fit in window\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar minOperations = function(nums) {\\n    if (nums.length == 0) return 0\\n\\t\\n    let n = nums.length \\n    \\n    nums.sort((a,b) => a-b)\\n    \\n    let m = 1 // length of array without dups \\n    \\n    // remove duplicates in place \\n    for (let i = 1; i < n; i ++) {\\n        if (nums[i] != nums[i -1]) {\\n            nums[m] = nums[i]\\n            m ++\\n        } \\n    }\\n     \\n    \\n    let i = 0 // start\\n    let j = 0 // end \\n    \\n    for(j = 0; j < m; j ++) {\\n        //console.log(\"j\",j, \"i\", i)\\n        //console.log(\"nums[i]\", nums[i])\\n        //console.log(\"nums[i] + n\", nums[i] + n)\\n        //console.log(\"nums[j]\", nums[j])                    \\n        \\n        if (nums[i] + n <= nums[j]) { // need to be replaced, outside the window\\n            //console.log(\"i++\", i + 1)\\n            \\n            i ++\\n        } \\n        \\n        //console.log(\"\\\\n\")\\n    }\\n    \\n    return n - m + i // (n-m) = duplicates. i = number of items too small to fit in window\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690374,
                "title": "python-slide-window",
                "content": "```\\nclass Solution(object):\\n    def minOperations(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n\\n        1, 2, 3, 5, 6\\n        \\n         1. sort\\n         2. get max continuous subarray, m\\n         3. n - m\\n        \"\"\"\\n        n = len(nums)\\n        uniq_nums = list(set(nums))\\n        uniq_nums.sort()\\n\\n        start = 0\\n        max_continusous = 0\\n        for end in range(len(uniq_nums)):\\n            while end - max_continusous >= 0 and uniq_nums[end] - uniq_nums[max(0, end - max_continusous)] <= n - 1:\\n                max_continusous += 1\\n        return n - max_continusous\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minOperations(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n\\n        1, 2, 3, 5, 6\\n        \\n         1. sort\\n         2. get max continuous subarray, m\\n         3. n - m\\n        \"\"\"\\n        n = len(nums)\\n        uniq_nums = list(set(nums))\\n        uniq_nums.sort()\\n\\n        start = 0\\n        max_continusous = 0\\n        for end in range(len(uniq_nums)):\\n            while end - max_continusous >= 0 and uniq_nums[end] - uniq_nums[max(0, end - max_continusous)] <= n - 1:\\n                max_continusous += 1\\n        return n - max_continusous\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674467,
                "title": "c-lower-bound-approach",
                "content": "I have seen many solutions, where people have used set to remove the duplicates and then pushed the elements back to the array.\\nThis will cost ```O(nlogn)``` for set insertion ```O(n)``` space complexity if new vector used or time-complexity if popped all elements and then pushed back\\n\\nI have used exact same almost like quick-sort:\\n* \\tif current element is lesser than the pivot, increment the low and then swap the current element with the element on the low index.\\n* \\tafter sorting, if there are duplicates, do ```nums[pivot++] = a[i]``` then make ```i=1+index of last duplicate```.\\n* \\twe will not wipe any element, since ```[0,...,pivot]``` contains all the distinct element from the range ```[0,...,i-1]``` and at any point of time, we will be using only ```[pivot+1,...,n]``` range for assignment.\\n* \\tnew array range will be 0 to pivot-1\\n\\nfor each element in the new array, do the following\\n* if the current element is the starting of the required array, i.e ```nums.length-1 == max-min```, then from the remaining element which should be converted?\\n* that can be done using lower_bound:\\nWe have min, we know the max, so elements which are not there between [min,max], will be converted and that will be the answer\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int> nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int j,pivot = 0;\\n        for(int i = 0; i < n; ){\\n            while(j < n && nums[i] == nums[j])\\n                j++;\\n            nums[pivot++] = nums[i];\\n            i = j;\\n        }\\n        int d;\\n        int mini = INT_MAX;\\n        vector<int>::iterator ptr;\\n        for(int i = 0; i < pivot; i++){\\n            ptr = lower_bound(nums.begin(),nums.begin()+pivot,nums[i]+n);\\n            d = ptr-(nums.begin()+i);\\n            mini = min(mini,(n-d));\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```O(nlogn)```\n```O(n)```\n```nums[pivot++] = a[i]```\n```i=1+index of last duplicate```\n```[0,...,pivot]```\n```[0,...,i-1]```\n```[pivot+1,...,n]```\n```nums.length-1 == max-min```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int> nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int j,pivot = 0;\\n        for(int i = 0; i < n; ){\\n            while(j < n && nums[i] == nums[j])\\n                j++;\\n            nums[pivot++] = nums[i];\\n            i = j;\\n        }\\n        int d;\\n        int mini = INT_MAX;\\n        vector<int>::iterator ptr;\\n        for(int i = 0; i < pivot; i++){\\n            ptr = lower_bound(nums.begin(),nums.begin()+pivot,nums[i]+n);\\n            d = ptr-(nums.begin()+i);\\n            mini = min(mini,(n-d));\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671306,
                "title": "c-sliding-window",
                "content": "MAIN STEPS OF THIS APPROACH\\n1. PUT ALL ELEMENT IN SET SO THAT THEIR IS NO DUPLIACTE ELEMNET\\n2. THAN CLEAR THE VECTOR AND PUSH SET ELEMNT IN VECTOR\\n3. SORT \\n4. NOW WE MAINTAIN THE SLIDING WINDOW\\n\\n\\n\\n\\n\\nclass Solution\\n{\\npublic:\\n  int minOperations(vector<int> &v)\\n  {\\n\\n    int size = v.size();\\n    unordered_set<int> s;\\n    for (auto a : v)\\n    {\\n      s.insert(a);\\n    }\\n    v.clear();\\n    for (auto a : s)\\n    {\\n      v.push_back(a);\\n    }\\n    sort(v.begin(), v.end());\\n    int low = 0;\\n    int high = 0;\\n\\n    int ans = 0;\\n    while (high < v.size())\\n    {\\n\\n      if (v[high] > size - 1 + v[low])\\n      {\\n\\n        low++;\\n      }\\n\\n      ans = max(ans, high - low + 1);\\n      high++;\\n    }\\n\\n    return size - ans;\\n  }\\n};\\n\\n\\n\\n\\nIf you have any doubt feel free to comment",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution\\n{\\npublic:\\n  int minOperations(vector<int> &v)\\n  {\\n\\n    int size = v.size();\\n    unordered_set<int> s;\\n    for (auto a : v)\\n    {\\n      s.insert(a);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1663029,
                "title": "easy-understanding-sliding-window-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), ans = n-1;\\n        if ( n == 0 )\\n            return 0;\\n        unordered_set<int> win;\\n        sort(nums.begin(),nums.end());\\n        int l = 0, r = 0, end_val = nums[l]+n-1;\\n        while ( r < n )\\n        {\\n            if ( nums[r] > end_val ) \\n            {\\n                win.erase(nums[l++]);\\n                end_val = nums[l] + n - 1;\\n            }\\n            else\\n            {\\n                win.insert(nums[r++]);\\n                ans = min(ans,n-(int)win.size());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), ans = n-1;\\n        if ( n == 0 )\\n            return 0;\\n        unordered_set<int> win;\\n        sort(nums.begin(),nums.end());\\n        int l = 0, r = 0, end_val = nums[l]+n-1;\\n        while ( r < n )\\n        {\\n            if ( nums[r] > end_val ) \\n            {\\n                win.erase(nums[l++]);\\n                end_val = nums[l] + n - 1;\\n            }\\n            else\\n            {\\n                win.insert(nums[r++]);\\n                ans = min(ans,n-(int)win.size());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630037,
                "title": "c",
                "content": "\\'\\'\\'\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n        \\n        int numsize = nums.size();\\n        int left = 0, right = 1, maxWindowSize = 1;// sliding window\\n        int countDuplicates = 0;\\n        \\n        while(right<numsize){\\n            while(right<numsize && nums[right] < nums[left]+numsize){\\n                if(nums[right] == nums[right-1]) countDuplicates++;\\n                right++;\\n            }\\n            maxWindowSize = max(maxWindowSize,right-left-countDuplicates);\\n            left++;\\n            if(left != numsize && nums[left] == nums[left-1]) countDuplicates--;\\n        }\\n        return numsize-maxWindowSize;\\n        \\n    }\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n        \\n        int numsize = nums.size();\\n        int left = 0, right = 1, maxWindowSize = 1;// sliding window\\n        int countDuplicates = 0;\\n        \\n        while(right<numsize){\\n            while(right<numsize && nums[right] < nums[left]+numsize){\\n                if(nums[right] == nums[right-1]) countDuplicates++;\\n                right++;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1902878,
                "content": [
                    {
                        "username": "bhaskar_op",
                        "content": "Lol.. I jumped on this question after \\nKeerti Purswani and Luv\\'s mock interview video.. "
                    },
                    {
                        "username": "prashantpathak01",
                        "content": "  Same "
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Same "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Solution 1. Sliding Window\\nCheck out \"C++ Maximum Sliding Window Cheatsheet Template!\" which can help you solve all sliding window problems.\\n\\nIntuition: Sort and only keep unique elements. The problem is the same as \"get the length of the longest subarray whose difference between min and max elements is N - 1\".\\n\\nAlgorithm:\\n\\nThe brute force way is to pick each A[i] as the start of the subarray and count the number of elements that are <= A[i] + N - 1, which takes O(N^2) time.\\n\\nSince the array is already sorted, we can use sliding window so that we only traverse the entire array once.\\nUse Non-shrinkable Sliding Window Template:\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int N = nums.size(), i = 0, j = 0;\\n        sort(begin(nums), end(nums));\\n        nums.erase(unique(begin(nums), end(nums)), end(nums)); // only keep unique elements\\n        for (int M = nums.size(); j < M; ++j) {\\n            if (nums[i] + N <= nums[j]) ++i;\\n        }\\n        return N - j + i;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1737457,
                "content": [
                    {
                        "username": "bhaskar_op",
                        "content": "Lol.. I jumped on this question after \\nKeerti Purswani and Luv\\'s mock interview video.. "
                    },
                    {
                        "username": "prashantpathak01",
                        "content": "  Same "
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Same "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Solution 1. Sliding Window\\nCheck out \"C++ Maximum Sliding Window Cheatsheet Template!\" which can help you solve all sliding window problems.\\n\\nIntuition: Sort and only keep unique elements. The problem is the same as \"get the length of the longest subarray whose difference between min and max elements is N - 1\".\\n\\nAlgorithm:\\n\\nThe brute force way is to pick each A[i] as the start of the subarray and count the number of elements that are <= A[i] + N - 1, which takes O(N^2) time.\\n\\nSince the array is already sorted, we can use sliding window so that we only traverse the entire array once.\\nUse Non-shrinkable Sliding Window Template:\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int N = nums.size(), i = 0, j = 0;\\n        sort(begin(nums), end(nums));\\n        nums.erase(unique(begin(nums), end(nums)), end(nums)); // only keep unique elements\\n        for (int M = nums.size(); j < M; ++j) {\\n            if (nums[i] + N <= nums[j]) ++i;\\n        }\\n        return N - j + i;\\n    }\\n};\\n"
                    }
                ]
            }
        ]
    }
]