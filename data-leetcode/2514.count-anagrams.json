[
    {
        "title": "Count Anagrams",
        "question_content": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\n\tFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"&nbsp;and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".\n\nExample 2:\n\nInput: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string.\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts consists of lowercase English letters and spaces ' '.\n\tThere is single space between consecutive words.",
        "solutions": [
            {
                "id": 2947111,
                "title": "c-solution-math-with-explanation-each-step-in-detail",
                "content": "# Explanation\\n1. The basic idea is to multiply the number of ways to write each word.\\n2. The number of ways to write a word of size n is `n factorial` i.e\\xA0`n!`.\\n3. For example *\"abc\" ->\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\".* total 6 ways = 3!.\\n3. Here we want total ***unique count***, so words like \"aa\" can be written in only `1` way. So we divide our ways by the factorial of all repeating characters\\' frequencies.\\n4. So we create a frequency array of word freq[].\\n4. Now our formula is as follows:` ways = n! / ( freq[i]! * freq[i+1]! *...freq[n-1]! )`.\\n5. So our overall answer is `ways[i] * ways[i+1] *...ways[n]`.\\n6. But the problem here is that our answer can be a large number, so we have to return `modulo 1e9+7`.\\n7. Well, that\\'s not a big problem as we can just use `cnt % mod` for our answer, but here we have to use modulo for every computation as numbers can be very large. In our formula:` a= n!`, `b = (freq[i]! * freq[i+1]!... freq[n-1]!` is  `(a / b)%mod`.\\n8. But ` (a / b) % mod != (a% mod) / (b% mod)`. So here we use `Modular Multiplicative Inverse`,\\xA0i.e `(A / B) % mod =\\xA0A * ( B ^ -1 ) % mod`. Now `( B ^ -1 ) % mod` we can get by\\xA0`Fermat\\'s little theorem`, whose end conclusion is\\xA0`(b ^ -1) % mod = b ^ (mod -2)`\\xA0if mod is `prime`.\\n9. now mod is 1e9+7. We can\\'t get` b ^ (mod -2)` using for loop which is `O(n)`. for this we can use ***Binary Exponentiation***  which allows us to calculate \\u200A`a ^ n` in `O(log(n))`.\\n\\n\\n### Read about   [*Modular Multiplicative Inverse*](https://cp-algorithms.com/algebra/module-inverse.html) and [*Binary Exponentiation*](https://cp-algorithms.com/algebra/binary-exp.html)\\n\\n\\n# *C++ Code*\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nint fact[100002];\\n\\nint modmul(int a,int b){\\n    return((long long)(a%mod)*(b%mod))%mod;\\n}\\n\\nint binExpo(int a,int b){\\n    if(!b)return 1;\\n    int res=binExpo(a,b/2);\\n    if(b&1){\\n        return modmul(a,modmul(res,res));\\n    }else{\\n        return modmul(res,res);\\n    }\\n}\\n\\nint modmulinv(int a){\\n    return binExpo(a,mod-2);\\n}\\n\\nvoid getfact() {\\n    fact[0]=1;\\n    for(int i=1;i<=100001;i++){\\n        fact[i]=modmul(fact[i-1],i);\\n    }\\n}\\n\\nint ways(string str) {\\n   int freq[26] = {0};\\n   for(int i = 0; i<str.size(); i++) {\\n      freq[str[i] - \\'a\\']++;\\n   }\\n   int totalWays = fact[str.size()];\\n   int factR=1; \\n   for(int i = 0; i<26; i++) {\\n         factR=modmul(factR,fact[freq[i]]);\\n   }\\n   return modmul(totalWays,modmulinv(factR));\\n}\\n \\n    int countAnagrams(string s) {\\n        getfact();\\n        istringstream ss(s);\\n        string word; \\n         int ans=1;\\n        while (ss >> word)\\n        {\\n            ans=modmul(ans,ways(word));\\n        }\\n        return ans;\\n    }\\n  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nint fact[100002];\\n\\nint modmul(int a,int b){\\n    return((long long)(a%mod)*(b%mod))%mod;\\n}\\n\\nint binExpo(int a,int b){\\n    if(!b)return 1;\\n    int res=binExpo(a,b/2);\\n    if(b&1){\\n        return modmul(a,modmul(res,res));\\n    }else{\\n        return modmul(res,res);\\n    }\\n}\\n\\nint modmulinv(int a){\\n    return binExpo(a,mod-2);\\n}\\n\\nvoid getfact() {\\n    fact[0]=1;\\n    for(int i=1;i<=100001;i++){\\n        fact[i]=modmul(fact[i-1],i);\\n    }\\n}\\n\\nint ways(string str) {\\n   int freq[26] = {0};\\n   for(int i = 0; i<str.size(); i++) {\\n      freq[str[i] - \\'a\\']++;\\n   }\\n   int totalWays = fact[str.size()];\\n   int factR=1; \\n   for(int i = 0; i<26; i++) {\\n         factR=modmul(factR,fact[freq[i]]);\\n   }\\n   return modmul(totalWays,modmulinv(factR));\\n}\\n \\n    int countAnagrams(string s) {\\n        getfact();\\n        istringstream ss(s);\\n        string word; \\n         int ans=1;\\n        while (ss >> word)\\n        {\\n            ans=modmul(ans,ways(word));\\n        }\\n        return ans;\\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947480,
                "title": "multiply-permutations",
                "content": "We count permutations of each word, and multiply those permutatons.\\n\\nThe number of permutations with repetitions is a factorial of word lenght, divided by factorial of count of each character.\\n\\n**Python 3**\\nPython developers are in luck due to `factorial` and large integer support.\\n\\n```python\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        res = 1\\n        for w in s.split(\" \"):\\n            cnt, prem = Counter(w), factorial(len(w))\\n            for rep in cnt.values():\\n                prem = prem // factorial(rep)\\n            res = res * prem % 1000000007\\n        return res\\n```\\n**C++**\\nNeed to pre-compute factorials and inverse modulos (to simulate divisions).\\n\\n```cpp\\nint fact[100001] = {1, 1}, inv_fact[100001] = {1, 1}, mod = 1000000007;\\nclass Solution {\\npublic: \\nint countAnagrams(string s) {\\n    if (fact[2] == 0) {\\n        vector<int> inv(100001, 1);\\n        for (long long i = 2; i < sizeof(fact) / sizeof(fact[0]); ++i) {\\n            fact[i] = i * fact[i - 1] % mod;\\n            inv[i] = mod - mod / i * inv[mod % i] % mod;\\n            inv_fact[i] = 1LL * inv_fact[i - 1] * inv[i] % mod;            \\n        }\\n    }\\n    int res = 1;\\n    for (int i = 0, j = 0; i <= s.size(); ++i)\\n        if (i == s.size() || s[i] == \\' \\') {\\n            long long cnt[26] = {}, prem = fact[i - j];\\n            for (int k = j; k < i; ++k)\\n                ++cnt[s[k] - \\'a\\'];\\n            for (int rep : cnt)\\n                prem = prem * inv_fact[rep] % mod;\\n            res = res * prem % mod;\\n            j = i + 1;\\n        }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        res = 1\\n        for w in s.split(\" \"):\\n            cnt, prem = Counter(w), factorial(len(w))\\n            for rep in cnt.values():\\n                prem = prem // factorial(rep)\\n            res = res * prem % 1000000007\\n        return res\\n```\n```cpp\\nint fact[100001] = {1, 1}, inv_fact[100001] = {1, 1}, mod = 1000000007;\\nclass Solution {\\npublic: \\nint countAnagrams(string s) {\\n    if (fact[2] == 0) {\\n        vector<int> inv(100001, 1);\\n        for (long long i = 2; i < sizeof(fact) / sizeof(fact[0]); ++i) {\\n            fact[i] = i * fact[i - 1] % mod;\\n            inv[i] = mod - mod / i * inv[mod % i] % mod;\\n            inv_fact[i] = 1LL * inv_fact[i - 1] * inv[i] % mod;            \\n        }\\n    }\\n    int res = 1;\\n    for (int i = 0, j = 0; i <= s.size(); ++i)\\n        if (i == s.size() || s[i] == \\' \\') {\\n            long long cnt[26] = {}, prem = fact[i - j];\\n            for (int k = j; k < i; ++k)\\n                ++cnt[s[k] - \\'a\\'];\\n            for (int rep : cnt)\\n                prem = prem * inv_fact[rep] % mod;\\n            res = res * prem % mod;\\n            j = i + 1;\\n        }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946476,
                "title": "python-simple-math",
                "content": "Just use formula from school to get permutation number of each part.\\nhttps://en.wikipedia.org/wiki/Permutation#k-permutations_of_n\\n\\n```python\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        def get(word):\\n            n = math.factorial(len(word))\\n\\n            for v in Counter(word).values():\\n                n //= math.factorial(v)\\n\\n            return int(n) % (10**9 + 7)\\n\\n        total = 1  \\n        for word in s.split():\\n            total *= get(word)\\n\\n        return total % (10**9 + 7)\\n```\\n\\n\\n**Please vote up if you like my solution** \\uD83D\\uDE4F",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        def get(word):\\n            n = math.factorial(len(word))\\n\\n            for v in Counter(word).values():\\n                n //= math.factorial(v)\\n\\n            return int(n) % (10**9 + 7)\\n\\n        total = 1  \\n        for word in s.split():\\n            total *= get(word)\\n\\n        return total % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946715,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Calculate the number of permutations of each word,\\n    Formula is: N! / (Ma! * Mb! * ... * Mz!)\\n    where N is the amount of letters in the word, and \\n    Ma, Mb, ..., Mz are the occurrences of repeated letters in the word. \\n    Each M equals the amount of times the letter appears in the word.\\n    \\n    Multiply number of permutations of each word.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(Nlog(mod))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    ll fact[100005];\\n\\n    void factorial(ll n) {\\n        fact[0] = 1;\\n        for(ll i=1; i<=n; i++) fact[i] = i * fact[i-1] % mod;\\n    }\\n\\n    ll powmod(ll a, ll b) {\\n        ll ans = 1;\\n        while(b > 0) {\\n            if(b & 1) ans = ans * a % mod;\\n            a = a * a % mod;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n    ll inv(ll x) {\\n        return powmod(x, mod-2);\\n    }\\n    \\n    int countAnagrams(string s) {\\n        ll n = s.size();\\n        factorial(n);\\n        s.push_back(\\' \\');\\n        unordered_map<char, ll> mp;\\n        ll ans = 1, cnt = 0;\\n        for(auto c: s) {\\n            if(c == \\' \\') {\\n                ll up = fact[cnt];\\n                for(auto x: mp) {\\n                    ll down = fact[x.second];\\n                    up = up * inv(down) % mod;\\n                }\\n                ans = ans * up % mod;\\n                mp.clear();\\n                cnt = 0;\\n            }\\n            else {\\n                mp[c]++;\\n                cnt++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    ll fact[100005];\\n\\n    void factorial(ll n) {\\n        fact[0] = 1;\\n        for(ll i=1; i<=n; i++) fact[i] = i * fact[i-1] % mod;\\n    }\\n\\n    ll powmod(ll a, ll b) {\\n        ll ans = 1;\\n        while(b > 0) {\\n            if(b & 1) ans = ans * a % mod;\\n            a = a * a % mod;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n    ll inv(ll x) {\\n        return powmod(x, mod-2);\\n    }\\n    \\n    int countAnagrams(string s) {\\n        ll n = s.size();\\n        factorial(n);\\n        s.push_back(\\' \\');\\n        unordered_map<char, ll> mp;\\n        ll ans = 1, cnt = 0;\\n        for(auto c: s) {\\n            if(c == \\' \\') {\\n                ll up = fact[cnt];\\n                for(auto x: mp) {\\n                    ll down = fact[x.second];\\n                    up = up * inv(down) % mod;\\n                }\\n                ans = ans * up % mod;\\n                mp.clear();\\n                cnt = 0;\\n            }\\n            else {\\n                mp[c]++;\\n                cnt++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946945,
                "title": "easy-to-understand-java-solution-permutations-and-inverse-factorial",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is how to calcuate number of permutations with duplicates.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor string such as \"AAABBCCD\", the length of string is 8, and has 3 \\'A\\'s, 2 \\'B\\'s, 2 \\'C\\'s, and 1 \\'D\\'.\\n\\nPermutations of duplicates only contribute to one of unique permutation, therefore, number of permuations of the entire string needs to be divided by number of permuations of each duplicate.\\n\\nThus, the the number of permutations of string \"AAABBCCD\" is 8!/(3!*2!*2!*1!).\\n\\nThe next question is how to calcuate inverse of factorials when number is large.\\n\\nLet A * A\\' = 1 and MOD = 1000000007, then (A * A\\') = 1 (mod MOD), we need to calculate (A * A\\') = 1 (mod MOD). Then \\n\\n```\\n(A ^ (MOD - 2) * A) % MOD = A ^ (MOD - 1) % MOD = 1 % MOD\\n```\\n\\nWe used [Fermat\\'s little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem), let P be a prime number, then\\n\\n```\\nA ^ P = A (mod P)\\n```\\n\\nThus, if we want to calculate A\\', we just calculate\\n\\n```\\nA ^ (MOD - 2)\\n\\n```\\nBecause MOD = 1000000007 and 1000000007 is a prime number.\\n\\n# Complexity\\nLet maximum length of individual string is m and number of strings be n, then time complexity is O(m) for calculating factorial, O(n * log(MOD)) for calculating inverse factorial ~ O(n).\\nIf there are n individual strings, the time to calculate number of permutations is O(m * constant).\\n\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n).\\n\\nWe need to store information of factorial and inverse factorial array, space complexity of this part is O(m). Because the auxiliary array of `String[] strs`, space complexity of this part is O(m * n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n).\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int countAnagrams(String s) {\\n        String[] strs = s.split(\" \");\\n        long result = 1;\\n        int maxLen = 0;\\n        for (String str : strs) {            \\n            maxLen = Math.max(maxLen, str.length());\\n        }\\n        int[] factorial = getFactorial(maxLen);\\n        int[] invFactorial = getInverseFactorial(maxLen, factorial);\\n        int[] count = new int[26];\\n        int len = 0;\\n        long numOfPermutations = 0;\\n        for (String str : strs) {\\n            Arrays.fill(count, 0);\\n            len = str.length();\\n            for (int i = 0; i < len; i++) {\\n                count[str.charAt(i) - \\'a\\']++;\\n            }\\n            numOfPermutations = factorial[len];\\n            for (int i = 0; i < 26; i++) {\\n                if (count[i] > 0) {\\n                    numOfPermutations = (numOfPermutations * invFactorial[count[i]]) % MOD;\\n                }\\n            }\\n            result = (result * numOfPermutations) % MOD;\\n        }\\n        return (int) result;\\n    }\\n    private int[] getFactorial(int num) {\\n        int[] factorial = new int[num + 1];\\n        factorial[0] = 1;\\n        for (int i = 1; i <= num; i++) {\\n            factorial[i] = (int) ((1L * factorial[i - 1] * i) % MOD);\\n        }\\n        return factorial;\\n    }\\n    private int[] getInverseFactorial(int num, int[] factorial) {\\n        int[] invFactorial = new int[num + 1];\\n        for (int i = 1; i <= num; i++) {\\n            invFactorial[i] = (int) powMod(factorial[i], MOD - 2) % MOD;\\n        }\\n        return invFactorial;\\n    }\\n    private long powMod(long num, int pow) {\\n        long result = 1;\\n        while (pow >= 1) {\\n            if (pow % 2 == 1) {\\n                result = (result * num) % MOD;\\n            }\\n            pow /= 2;\\n            num = (num * num) % MOD;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\n(A ^ (MOD - 2) * A) % MOD = A ^ (MOD - 1) % MOD = 1 % MOD\\n```\n```\\nA ^ P = A (mod P)\\n```\n```\\nA ^ (MOD - 2)\\n\\n```\n```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int countAnagrams(String s) {\\n        String[] strs = s.split(\" \");\\n        long result = 1;\\n        int maxLen = 0;\\n        for (String str : strs) {            \\n            maxLen = Math.max(maxLen, str.length());\\n        }\\n        int[] factorial = getFactorial(maxLen);\\n        int[] invFactorial = getInverseFactorial(maxLen, factorial);\\n        int[] count = new int[26];\\n        int len = 0;\\n        long numOfPermutations = 0;\\n        for (String str : strs) {\\n            Arrays.fill(count, 0);\\n            len = str.length();\\n            for (int i = 0; i < len; i++) {\\n                count[str.charAt(i) - \\'a\\']++;\\n            }\\n            numOfPermutations = factorial[len];\\n            for (int i = 0; i < 26; i++) {\\n                if (count[i] > 0) {\\n                    numOfPermutations = (numOfPermutations * invFactorial[count[i]]) % MOD;\\n                }\\n            }\\n            result = (result * numOfPermutations) % MOD;\\n        }\\n        return (int) result;\\n    }\\n    private int[] getFactorial(int num) {\\n        int[] factorial = new int[num + 1];\\n        factorial[0] = 1;\\n        for (int i = 1; i <= num; i++) {\\n            factorial[i] = (int) ((1L * factorial[i - 1] * i) % MOD);\\n        }\\n        return factorial;\\n    }\\n    private int[] getInverseFactorial(int num, int[] factorial) {\\n        int[] invFactorial = new int[num + 1];\\n        for (int i = 1; i <= num; i++) {\\n            invFactorial[i] = (int) powMod(factorial[i], MOD - 2) % MOD;\\n        }\\n        return invFactorial;\\n    }\\n    private long powMod(long num, int pow) {\\n        long result = 1;\\n        while (pow >= 1) {\\n            if (pow % 2 == 1) {\\n                result = (result * num) % MOD;\\n            }\\n            pow /= 2;\\n            num = (num * num) % MOD;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946876,
                "title": "java-multiply-anagrams-of-every-strings",
                "content": "# Code\\n```java\\nclass Solution {\\n    long mod = (long) 1e9+7;\\n    public int countAnagrams(String s) {\\n        int n = s.length();\\n        long[] fact = new long[n+1];\\n        fact[0] = 1L;\\n        for(int i=1;i<=n;i++){\\n            fact[i] = fact[i-1]*i%mod;\\n        }\\n        String[] str = s.split(\" \");\\n        long ans = 1;\\n        for(String t:str){\\n            int[] ch = new int[26];\\n            for(char c:t.toCharArray()){\\n                ch[c-\\'a\\']++;\\n            }\\n            long cur = 1;\\n            for(int a:ch){\\n                cur = cur *fact[a]%mod;\\n            }\\n            long cur = fact[t.length()] * binpow(cur,mod-2) % mod;\\n            ans = ans * cur % mod;\\n        }\\n        return (int) ans;\\n    }\\n    long binpow(long a, long b) {\\n        if (b == 0)\\n            return 1;\\n        long res = binpow(a, b / 2);\\n        res = res * res % mod;\\n        if (b % 2==1)\\n            return res * a % mod;\\n        else\\n            return  res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    long mod = (long) 1e9+7;\\n    public int countAnagrams(String s) {\\n        int n = s.length();\\n        long[] fact = new long[n+1];\\n        fact[0] = 1L;\\n        for(int i=1;i<=n;i++){\\n            fact[i] = fact[i-1]*i%mod;\\n        }\\n        String[] str = s.split(\" \");\\n        long ans = 1;\\n        for(String t:str){\\n            int[] ch = new int[26];\\n            for(char c:t.toCharArray()){\\n                ch[c-\\'a\\']++;\\n            }\\n            long cur = 1;\\n            for(int a:ch){\\n                cur = cur *fact[a]%mod;\\n            }\\n            long cur = fact[t.length()] * binpow(cur,mod-2) % mod;\\n            ans = ans * cur % mod;\\n        }\\n        return (int) ans;\\n    }\\n    long binpow(long a, long b) {\\n        if (b == 0)\\n            return 1;\\n        long res = binpow(a, b / 2);\\n        res = res * res % mod;\\n        if (b % 2==1)\\n            return res * a % mod;\\n        else\\n            return  res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946588,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll =long long;\\n    ll mod=1e9+7;\\n    ll fact[100005];\\n    ll power(ll a,ll b)\\n    {\\n        ll res=1;\\n        while(b)\\n        {\\n            if(b&1)\\n            {\\n                res=(res*a)%mod;\\n            }\\n            a=(a*a)%mod;\\n            b/=2;\\n        }\\n        return res;\\n    }\\n    ll cal(vector<int>&dp)\\n    {\\n        ll sum=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            sum+=dp[i];\\n        }\\n        ll ans=fact[sum]; // total permutation \\n        for(int i=0;i<26;i++)\\n        {\\n            ans*=(power(fact[dp[i]],mod-2)); // remove duplicate\\n            ans%=mod;\\n        }\\n        /*\\n        formula\\n          n!/(a!* b! * c! )\\n          where a b c are freq of char\\n        */\\n        return ans;\\n    }\\n    int countAnagrams(string s) \\n    {\\n        fact[0]=1;\\n        for(int i=1;i<100005;i++)\\n        {\\n            fact[i]=(i*fact[i-1])%mod;\\n        }\\n        int n=s.size();\\n        vector<int>dp(26,0);\\n        ll ans=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                ll value=cal(dp);\\n                ans*=value;\\n                ans%=mod;\\n                dp=vector<int>(26,0);\\n            }\\n            else\\n            {\\n                dp[s[i]-\\'a\\']++;\\n            }\\n        }\\n        ll value=cal(dp);\\n        ans*=value;\\n        ans%=mod;\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll =long long;\\n    ll mod=1e9+7;\\n    ll fact[100005];\\n    ll power(ll a,ll b)\\n    {\\n        ll res=1;\\n        while(b)\\n        {\\n            if(b&1)\\n            {\\n                res=(res*a)%mod;\\n            }\\n            a=(a*a)%mod;\\n            b/=2;\\n        }\\n        return res;\\n    }\\n    ll cal(vector<int>&dp)\\n    {\\n        ll sum=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            sum+=dp[i];\\n        }\\n        ll ans=fact[sum]; // total permutation \\n        for(int i=0;i<26;i++)\\n        {\\n            ans*=(power(fact[dp[i]],mod-2)); // remove duplicate\\n            ans%=mod;\\n        }\\n        /*\\n        formula\\n          n!/(a!* b! * c! )\\n          where a b c are freq of char\\n        */\\n        return ans;\\n    }\\n    int countAnagrams(string s) \\n    {\\n        fact[0]=1;\\n        for(int i=1;i<100005;i++)\\n        {\\n            fact[i]=(i*fact[i-1])%mod;\\n        }\\n        int n=s.size();\\n        vector<int>dp(26,0);\\n        ll ans=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                ll value=cal(dp);\\n                ans*=value;\\n                ans%=mod;\\n                dp=vector<int>(26,0);\\n            }\\n            else\\n            {\\n                dp[s[i]-\\'a\\']++;\\n            }\\n        }\\n        ll value=cal(dp);\\n        ans*=value;\\n        ans%=mod;\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946557,
                "title": "c-java-python3-multinomial-coefficients",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/3ffc910c12ff8c84890fb15351216a0fa85dc3ac) for solutions of biweekly 94. \\n\\n**Intuition**\\nOn the math level, this is basically a test of multinomial coeffcients. The tricky part lies in the implementation. \\n**C++**\\n```\\nclass Solution {\\npublic: \\n    int countAnagrams(string s) {\\n        const int mod = 1\\'000\\'000\\'007; \\n        int n = s.size(); \\n        vector<long> fact(n+1, 1), ifact(n+1, 1), inv(n+1, 1); \\n        for (int x = 1; x <= n; ++x) {\\n            if (x >= 2) inv[x] = mod - mod/x * inv[mod%x] % mod; \\n            fact[x] = fact[x-1] * x % mod; \\n            ifact[x] = ifact[x-1] * inv[x] % mod; \\n        }\\n        long ans = 1; \\n        istringstream iss(s); \\n        string buff; \\n        while (iss >> buff) {\\n            ans = ans * fact[buff.size()] % mod; \\n            vector<int> freq(26); \\n            for (auto& ch : buff) ++freq[ch-\\'a\\']; \\n            for (auto& x : freq) ans = ans * ifact[x] % mod; \\n        }\\n        return ans; \\n    }\\n}; \\n```\\n**Java**\\n```\\nclass Solution {\\n\\tpublic int countAnagrams(String s) {\\n\\t\\tfinal int mod = 1_000_000_007; \\n\\t\\tint n = s.length(); \\n\\t\\tlong[] fact = new long[n+1], ifact = new long[n+1], inv = new long[n+1]; \\n\\t\\tfact[0] = ifact[0] = inv[0] = inv[1] = 1; \\n\\t\\tfor (int x = 1; x <= n; ++x) {\\n\\t\\t\\tif (x >= 2) inv[x] = mod - mod/x * inv[mod%x] % mod; \\n\\t\\t\\tfact[x] = fact[x-1] * x % mod; \\n\\t\\t\\tifact[x] = ifact[x-1] * inv[x] % mod; \\n\\t\\t}\\n\\t\\tlong ans = 1; \\n\\t\\tfor (var buff : s.split(\" \")) {\\n\\t\\t\\tans = ans * fact[buff.length()] % mod; \\n\\t\\t\\tint[] freq = new int[26]; \\n\\t\\t\\tfor (var ch : buff.toCharArray())  ++freq[ch-\\'a\\']; \\n\\t\\t\\tfor (var x : freq) ans = ans * ifact[x] % mod; \\n\\t\\t}\\n\\t\\treturn (int) ans; \\n\\t}\\n}\\n```\\n**Python3**\\n```\\nclass Solution: \\n    def countAnagrams(self, s: str) -> int:\\n        n = len(s)\\n        mod = 1_000_000_007\\n        inv = [1]*(n+1)\\n        fact = [1]*(n+1)\\n        ifact = [1]*(n+1)\\n        for x in range(1, n+1): \\n            if x >= 2: inv[x] = mod - mod//x * inv[mod % x] % mod \\n            fact[x] = fact[x-1] * x % mod \\n            ifact[x] = ifact[x-1] * inv[x] % mod \\n        ans = 1\\n        for word in s.split(): \\n            ans *= fact[len(word)]\\n            for x in Counter(word).values(): ans *= ifact[x]\\n            ans %= mod \\n        return ans \\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int countAnagrams(string s) {\\n        const int mod = 1\\'000\\'000\\'007; \\n        int n = s.size(); \\n        vector<long> fact(n+1, 1), ifact(n+1, 1), inv(n+1, 1); \\n        for (int x = 1; x <= n; ++x) {\\n            if (x >= 2) inv[x] = mod - mod/x * inv[mod%x] % mod; \\n            fact[x] = fact[x-1] * x % mod; \\n            ifact[x] = ifact[x-1] * inv[x] % mod; \\n        }\\n        long ans = 1; \\n        istringstream iss(s); \\n        string buff; \\n        while (iss >> buff) {\\n            ans = ans * fact[buff.size()] % mod; \\n            vector<int> freq(26); \\n            for (auto& ch : buff) ++freq[ch-\\'a\\']; \\n            for (auto& x : freq) ans = ans * ifact[x] % mod; \\n        }\\n        return ans; \\n    }\\n}; \\n```\n```\\nclass Solution {\\n\\tpublic int countAnagrams(String s) {\\n\\t\\tfinal int mod = 1_000_000_007; \\n\\t\\tint n = s.length(); \\n\\t\\tlong[] fact = new long[n+1], ifact = new long[n+1], inv = new long[n+1]; \\n\\t\\tfact[0] = ifact[0] = inv[0] = inv[1] = 1; \\n\\t\\tfor (int x = 1; x <= n; ++x) {\\n\\t\\t\\tif (x >= 2) inv[x] = mod - mod/x * inv[mod%x] % mod; \\n\\t\\t\\tfact[x] = fact[x-1] * x % mod; \\n\\t\\t\\tifact[x] = ifact[x-1] * inv[x] % mod; \\n\\t\\t}\\n\\t\\tlong ans = 1; \\n\\t\\tfor (var buff : s.split(\" \")) {\\n\\t\\t\\tans = ans * fact[buff.length()] % mod; \\n\\t\\t\\tint[] freq = new int[26]; \\n\\t\\t\\tfor (var ch : buff.toCharArray())  ++freq[ch-\\'a\\']; \\n\\t\\t\\tfor (var x : freq) ans = ans * ifact[x] % mod; \\n\\t\\t}\\n\\t\\treturn (int) ans; \\n\\t}\\n}\\n```\n```\\nclass Solution: \\n    def countAnagrams(self, s: str) -> int:\\n        n = len(s)\\n        mod = 1_000_000_007\\n        inv = [1]*(n+1)\\n        fact = [1]*(n+1)\\n        ifact = [1]*(n+1)\\n        for x in range(1, n+1): \\n            if x >= 2: inv[x] = mod - mod//x * inv[mod % x] % mod \\n            fact[x] = fact[x-1] * x % mod \\n            ifact[x] = ifact[x-1] * inv[x] % mod \\n        ans = 1\\n        for word in s.split(): \\n            ans *= fact[len(word)]\\n            for x in Counter(word).values(): ans *= ifact[x]\\n            ans %= mod \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954462,
                "title": "java-build-in-method-to-calc-mod-inverse",
                "content": "# Intuition\\nAssuming you have already known that a / b != (a % mod) / (b % mod)\\n(Division is not allowed as a modular arithmetic operation.) \\nOne of the approches to handle this problme is using inverse multiplication.)\\n\\nkudos to this post: https://leetcode.cn/problems/count-anagrams/solution/java-cheng-fa-ni-yuan-nei-zhi-han-shu-by-02y7/\\n\\nThere is an Java build-in method:\\n` public BigInteger modInverse(BigInteger m)` to calc mod inverse\\uFF08a BigInteger whose value is this ^ -1 mod m)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlong inv = BigInteger.valueOf(fac[v]).modInverse(BigInteger.valueOf(mod)).longValue();\\n\\n# Complexity\\n- Time complexity:\\nN/A\\n\\n- Space complexity:\\nN/A\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    long mod = (long) (1e9 + 7);\\n    long[] fac;\\n    public int countAnagrams(String s) {\\n\\n        fac = new long[s.length() + 1];\\n        fac[1] = 1;\\n      for (int i = 2; i <= s.length(); i++) {\\n            fac[i] = (fac[i - 1] * i) % mod;\\n        }\\n        String[] ws = s.split(\" \");\\n        long ans = 1;\\n        for (String w : ws) {\\n            ans = (ans * calc(w)) % mod;\\n        }\\n        return (int)ans;\\n    }\\n    private long calc(String w) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        for (char ch : w.toCharArray()) {\\n            m.put(ch, m.getOrDefault(ch, 0) + 1);\\n        }\\n        long all = fac[w.length()];\\n        for (int v : m.values()) {\\n            long inv = BigInteger.valueOf(fac[v]).modInverse(BigInteger.valueOf(mod)).longValue();\\n            all = all * inv % mod;\\n        }\\n        return all;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    long mod = (long) (1e9 + 7);\\n    long[] fac;\\n    public int countAnagrams(String s) {\\n\\n        fac = new long[s.length() + 1];\\n        fac[1] = 1;\\n      for (int i = 2; i <= s.length(); i++) {\\n            fac[i] = (fac[i - 1] * i) % mod;\\n        }\\n        String[] ws = s.split(\" \");\\n        long ans = 1;\\n        for (String w : ws) {\\n            ans = (ans * calc(w)) % mod;\\n        }\\n        return (int)ans;\\n    }\\n    private long calc(String w) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        for (char ch : w.toCharArray()) {\\n            m.put(ch, m.getOrDefault(ch, 0) + 1);\\n        }\\n        long all = fac[w.length()];\\n        for (int v : m.values()) {\\n            long inv = BigInteger.valueOf(fac[v]).modInverse(BigInteger.valueOf(mod)).longValue();\\n            all = all * inv % mod;\\n        }\\n        return all;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748960,
                "title": "python-3-2-lines-w-explanation-t-m-66-100",
                "content": "The problem reduces to finding the multinomial coefficient for each word and then returning the product.\\nMore formally, we find multi(len(word; [n1, n2, ... nk])) = len(word)! // (n1! * n1! * n2!*... *nk!)\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        multi =  lambda x, y : factorial(x)//prod(factorial(i) for i in y)\\n\\n        return  prod(multi(len(w), Counter(w).values())\\n                                         for w in s.split(\\' \\'))%1000000007 \\n\\n```\\n[https://leetcode.com/problems/count-anagrams/submissions/864994400/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        multi =  lambda x, y : factorial(x)//prod(factorial(i) for i in y)\\n\\n        return  prod(multi(len(w), Counter(w).values())\\n                                         for w in s.split(\\' \\'))%1000000007 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561617,
                "title": "c-factorial",
                "content": "calculate no of possible combinarion of each word and than multiplay each calculated ans of each word.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int modin(int x){\\n        int k = 1e9+5, mod = 1e9+7,ans = 1;\\n        while(k){\\n            if(k&1){\\n                ans = (ans*1LL*x)%mod;\\n            }\\n            x = (x*1LL*x)%mod;\\n            k >>= 1;\\n        }\\n        return ans;\\n    }\\n    int countAnagrams(string s) {\\n        int ans = 1, mod = 1e9+7,k;\\n        int n = s.length(),i;\\n        vector<int> dp(n+1,1);\\n        for(i = 2; i <= n; i++){\\n            dp[i] = (i*1LL*dp[i-1])%mod;\\n        }\\n        vector<int> v(26,0);\\n        int x = 0;\\n        for(auto &i: s){\\n            if(i==\\' \\'){\\n                k = dp[x];\\n                for(auto &j: v){\\n                    if(j>1)\\n                        k = (k*1LL*modin(dp[j]))%mod;\\n                }\\n                ans = (ans*1LL*k)%mod;\\n                // cout<<ans<< \" \";\\n                fill(v.begin(),v.end(),0);\\n                x = 0;\\n            }else{\\n                x++;\\n                v[i-\\'a\\']++;\\n            }\\n        }\\n        // cout<<\"#\";\\n                k = dp[x];\\n                for(auto &j: v){\\n                    if(j>1)\\n                        k = (k*1LL*modin(dp[j]))%mod;\\n                }\\n                ans = (ans*1LL*k)%mod;\\n        // cout<<ans;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int modin(int x){\\n        int k = 1e9+5, mod = 1e9+7,ans = 1;\\n        while(k){\\n            if(k&1){\\n                ans = (ans*1LL*x)%mod;\\n            }\\n            x = (x*1LL*x)%mod;\\n            k >>= 1;\\n        }\\n        return ans;\\n    }\\n    int countAnagrams(string s) {\\n        int ans = 1, mod = 1e9+7,k;\\n        int n = s.length(),i;\\n        vector<int> dp(n+1,1);\\n        for(i = 2; i <= n; i++){\\n            dp[i] = (i*1LL*dp[i-1])%mod;\\n        }\\n        vector<int> v(26,0);\\n        int x = 0;\\n        for(auto &i: s){\\n            if(i==\\' \\'){\\n                k = dp[x];\\n                for(auto &j: v){\\n                    if(j>1)\\n                        k = (k*1LL*modin(dp[j]))%mod;\\n                }\\n                ans = (ans*1LL*k)%mod;\\n                // cout<<ans<< \" \";\\n                fill(v.begin(),v.end(),0);\\n                x = 0;\\n            }else{\\n                x++;\\n                v[i-\\'a\\']++;\\n            }\\n        }\\n        // cout<<\"#\";\\n                k = dp[x];\\n                for(auto &j: v){\\n                    if(j>1)\\n                        k = (k*1LL*modin(dp[j]))%mod;\\n                }\\n                ans = (ans*1LL*k)%mod;\\n        // cout<<ans;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3125517,
                "title": "super-short-simple-python-solution-dictionaries-and-math-factorial",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947898,
                "title": "fast-c-soln-maths-explained-o-n-tc",
                "content": "# Intuition\\nFor a given string, the answer can be found separately for each word in the string and multiplying over all words (from fundamental counting principle)\\n\\nFor each word, again use the counting principle. For ex: given a word `abbccd`\\nthe number of anagrams is the number of permutations of this string -\\n$ n= 6 \\\\ \\\\ \\\\textrm{(length of the string)}$\\n$freq(a) = 1 \\\\\\\\ \\n freq(b) = 2 \\\\\\\\\\n freq(c) = 2 \\\\\\\\\\n freq(d) = 1\\n$\\n$ count = \\\\frac{6!}{1! \\\\times 2! \\\\times 2! \\\\times 1!}\\n$\\n\\n# Approach\\n\\n\\n1. split the given string into words. I have done this using [`std::stringstream`](https://cplusplus.com/reference/sstream/stringstream/stringstream/).\\n2. For each word calculate the number of anagrams as follows -\\n\\n    1. find the frequency of each character in the word. Let it be denoted by $count(i)$ where $i$ is a character in the word\\n    2. let $n$ be the length of this word\\n    3. now the answer is \\n    $$ans= \\\\frac{n!}{\\\\prod count(i)!}$$\\n3. multiply the answer across all words.\\n\\nI have precalculated the factorial and its inverse using the following formulae -\\n\\n$ f(i) =f(i-1) \\\\times i$\\n\\nthe inverse is a direct result of [Fermat\\'s Little Theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)\\n\\n$$ x^{-1}  \\\\equiv x^{m-2}\\\\  \\\\textrm{mod}\\\\ m $$\\n\\nFurther-\\n\\n$f(i)^{-1} = (i \\\\times f(i-1))^{-1}$\\n$ \\\\implies f(i)^{-1} =i^{-1} \\\\times f(i-1)^{-1} $\\n$\\\\implies f(i-1)^{-1}=f(i)^{-1} \\\\times i $\\n\\n\\n\\n\\n# Code\\n```\\nconst long long mod=1e9+7;\\nusing ll=long long;\\n\\n// binary exponentiation\\nll binpow(ll a, ll b, ll m)\\n{\\n\\ta %= m;\\n\\tll res = 1;\\n\\twhile (b > 0)\\n\\t{\\n\\t\\tif (b & 1) res = res * a % m;\\n\\t\\ta = a * a % m;\\n\\t\\tb >>= 1;\\n\\t}\\n\\treturn res;\\n}\\n// find modular multiplicative inverse \\n// using fermat\\'s little theorem\\nll inv(ll a, ll m = mod) { return binpow(a, m - 2, m); }\\n\\nconst int N=(int)1e5;\\nll fact[N+1];\\nll inv_fact[N+1];\\nvoid precalc()\\n{\\n    fact[0]=1;\\n    for(int i=1;i<=N;i++)\\n        fact[i]=(fact[i-1]*i)%mod;\\n    inv_fact[N]=inv(fact[N]);\\n    for(int i=N-1;i>=0;i--)\\n        inv_fact[i]=(inv_fact[i+1]*(i+1))%mod;\\n}\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        // call precalc only once across all testcases\\n        precalc();\\n    }\\n    // get the answer for each word\\n    int calc_for_word(const string&s)\\n    {\\n        // frequency array for each character \\n        ll a[26]{};\\n        for(auto &ch:s)\\n        {\\n            a[ch-\\'a\\']++;\\n        }\\n        ll ans=fact[s.size()];\\n        for(int i=0;i<26;i++)\\n        {\\n            ans*=inv_fact[a[i]];\\n            ans%=mod;\\n        }\\n        return ans;   \\n    }\\n    int countAnagrams(string str) {\\n        std::stringstream ss(str);\\n        string temp;\\n        ll ans=1;\\n        while(ss>>temp){\\n            ans*=calc_for_word(temp);\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\n    1. `precalc` - $O(n)$\\n    2. `countAnagrams` - $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Memoization"
                ],
                "code": "```\\nconst long long mod=1e9+7;\\nusing ll=long long;\\n\\n// binary exponentiation\\nll binpow(ll a, ll b, ll m)\\n{\\n\\ta %= m;\\n\\tll res = 1;\\n\\twhile (b > 0)\\n\\t{\\n\\t\\tif (b & 1) res = res * a % m;\\n\\t\\ta = a * a % m;\\n\\t\\tb >>= 1;\\n\\t}\\n\\treturn res;\\n}\\n// find modular multiplicative inverse \\n// using fermat\\'s little theorem\\nll inv(ll a, ll m = mod) { return binpow(a, m - 2, m); }\\n\\nconst int N=(int)1e5;\\nll fact[N+1];\\nll inv_fact[N+1];\\nvoid precalc()\\n{\\n    fact[0]=1;\\n    for(int i=1;i<=N;i++)\\n        fact[i]=(fact[i-1]*i)%mod;\\n    inv_fact[N]=inv(fact[N]);\\n    for(int i=N-1;i>=0;i--)\\n        inv_fact[i]=(inv_fact[i+1]*(i+1))%mod;\\n}\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        // call precalc only once across all testcases\\n        precalc();\\n    }\\n    // get the answer for each word\\n    int calc_for_word(const string&s)\\n    {\\n        // frequency array for each character \\n        ll a[26]{};\\n        for(auto &ch:s)\\n        {\\n            a[ch-\\'a\\']++;\\n        }\\n        ll ans=fact[s.size()];\\n        for(int i=0;i<26;i++)\\n        {\\n            ans*=inv_fact[a[i]];\\n            ans%=mod;\\n        }\\n        return ans;   \\n    }\\n    int countAnagrams(string str) {\\n        std::stringstream ss(str);\\n        string temp;\\n        ll ans=1;\\n        while(ss>>temp){\\n            ans*=calc_for_word(temp);\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947420,
                "title": "python3-math-combinatorics",
                "content": "# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        ans = 1\\n        for word in s.split():\\n            ans = (ans * self.count(word)) % MOD\\n        return ans\\n            \\n    def count(self, word):\\n        n = len(word)\\n        ans = 1\\n        for f in Counter(word).values():\\n            ans *= math.comb(n, f)\\n            n -= f\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        ans = 1\\n        for word in s.split():\\n            ans = (ans * self.count(word)) % MOD\\n        return ans\\n            \\n    def count(self, word):\\n        n = len(word)\\n        ans = 1\\n        for f in Counter(word).values():\\n            ans *= math.comb(n, f)\\n            n -= f\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946651,
                "title": "c-solution-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problems essentially asks us to find the number of distinct permutations for the entire string. \\n\\nThis boils down to finding the number of distinct permuations of each word in the string and multiplying them to get total number of permuations. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every word, we get it\\'s length. We also keep track of the occurrence of every character in that word. \\n\\nAfter this let\\'s find the number of distinct permuations for this word.\\nIt\\'s going to be $$({n!}/{(x! * y! * ... z!)})$$, here n is the length of the word, and x, y, z are characters that have repeated x, y, z times.\\n\\nNow, we just multiply this with our answer and reset all the variables and keep doing this for all the words. \\n\\nFor calculating the factorials we can precompute all factorials till 1e5.\\n\\nSince, there is division taking place under modulo, we need to find the modulo multiplicative inverse of $${(x! * y! * ... z!)}$$ with respect to our modulo (1e9+7).\\n\\nModulo Multiplicative Inverse for a number N, when the modulo is prime is given by : $$(N^{MOD-2})$$ with respect to modulo $${MOD}$$\\n\\nWe can use binary exponentiation to calculate $$(a^b)$$ in $$log(b)$$ time.\\nAlso, keep in mind to use modular multiplication everywhere.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    const int mod=1e9+7;\\n    long long fact[100001];\\n    \\n    int modMul(int a,int b,int mod){\\n        return ((long long)(a%mod)*(b%mod))%mod;\\n    }\\n    \\n    int binpow(int a,int b,int mod){\\n        if(b==0)return 1;\\n        long long res=binpow(a,b/2,mod);\\n        res=modMul(res,res,mod);\\n        if(b & 1){\\n            res=modMul(res,a,mod);\\n        }\\n        return res;\\n    }\\n    \\n    void computeFactorial(){\\n        fact[0]=1;\\n        for(int i=1;i<100001;i++){\\n            fact[i]=modMul(fact[i-1],i,mod);\\n        }\\n    }    \\n    \\n    int modInv(int a,int mod){\\n        return binpow(a,mod-2,mod);\\n    }\\npublic:\\n    //  For a given word of len(n) the number of permutations are: \\n    //      n!/(x1!*x2!*..xk!),\\n    //  where x1,x2,.. are repeating letters.\\n    int countAnagrams(string s) {\\n       computeFactorial();\\n        \\n       map<char,int>characterOccurrence;\\n       string cur=\"\";\\n       int curLen=0;\\n       int rep=0;\\n       int ans=1;\\n       int n=(int)s.size(); \\n        \\n       for(int i=0;i<n;i++){\\n           if(s[i]==\\' \\'){\\n              int currentLenFact=fact[curLen]; \\n              int repFact=1;\\n              for(auto character:characterOccurrence){\\n                 repFact=modMul(repFact,fact[character.second],mod); \\n              } \\n              ans=modMul(ans,modMul(currentLenFact,modInv(repFact,mod),mod),mod);\\n              curLen=0,rep=0;\\n              characterOccurrence.clear();\\n           }\\n           else{\\n               characterOccurrence[s[i]]++;\\n               curLen++;\\n           }\\n       }\\n       int currentLenFact=fact[curLen];\\n       int repFact=1;\\n       for(auto character:characterOccurrence){\\n          repFact=modMul(repFact,fact[character.second],mod); \\n       }\\n       ans=modMul(ans,modMul(currentLenFact,modInv(repFact,mod),mod),mod);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int mod=1e9+7;\\n    long long fact[100001];\\n    \\n    int modMul(int a,int b,int mod){\\n        return ((long long)(a%mod)*(b%mod))%mod;\\n    }\\n    \\n    int binpow(int a,int b,int mod){\\n        if(b==0)return 1;\\n        long long res=binpow(a,b/2,mod);\\n        res=modMul(res,res,mod);\\n        if(b & 1){\\n            res=modMul(res,a,mod);\\n        }\\n        return res;\\n    }\\n    \\n    void computeFactorial(){\\n        fact[0]=1;\\n        for(int i=1;i<100001;i++){\\n            fact[i]=modMul(fact[i-1],i,mod);\\n        }\\n    }    \\n    \\n    int modInv(int a,int mod){\\n        return binpow(a,mod-2,mod);\\n    }\\npublic:\\n    //  For a given word of len(n) the number of permutations are: \\n    //      n!/(x1!*x2!*..xk!),\\n    //  where x1,x2,.. are repeating letters.\\n    int countAnagrams(string s) {\\n       computeFactorial();\\n        \\n       map<char,int>characterOccurrence;\\n       string cur=\"\";\\n       int curLen=0;\\n       int rep=0;\\n       int ans=1;\\n       int n=(int)s.size(); \\n        \\n       for(int i=0;i<n;i++){\\n           if(s[i]==\\' \\'){\\n              int currentLenFact=fact[curLen]; \\n              int repFact=1;\\n              for(auto character:characterOccurrence){\\n                 repFact=modMul(repFact,fact[character.second],mod); \\n              } \\n              ans=modMul(ans,modMul(currentLenFact,modInv(repFact,mod),mod),mod);\\n              curLen=0,rep=0;\\n              characterOccurrence.clear();\\n           }\\n           else{\\n               characterOccurrence[s[i]]++;\\n               curLen++;\\n           }\\n       }\\n       int currentLenFact=fact[curLen];\\n       int repFact=1;\\n       for(auto character:characterOccurrence){\\n          repFact=modMul(repFact,fact[character.second],mod); \\n       }\\n       ans=modMul(ans,modMul(currentLenFact,modInv(repFact,mod),mod),mod);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946514,
                "title": "c-math-modulo-multiplicative-inverse-permutations",
                "content": "* Here, for all words we can find distinct permutations and than for distinct permutations for whole string we have to multiply all distinct permutations that can be made from each words.\\n* For `too` there are three possible permutations `1.too  2. oot 3. oto` .\\n* For finding distinct permutations ,` n! / r1! * r2! ... rn! `, where n is the size of the string and r1 to rn is frequency of the repetitive characters.\\n* ` s = \"too hot\"` i.e for `too = 3! / 2!  = 3`, `hot = 3! = 6`, so answer is  3 * 6 = 18.\\n* For dividing by factorial we can use modulo multiplicative inverse.\\n\\n```\\nclass Solution {\\npublic:\\n    const static int mod = 1e9+7,N = 1e5+10;\\n    long long fact[N];\\n    long long power(long long x,int y,int mod){\\n        long long ans = 1;\\n        x = x%mod;\\n        while(y >0){\\n            if(y&1){\\n                ans = (ans*x)%mod;\\n            }\\n            y>>=1;\\n            x = (x*x)%mod;\\n        }\\n        return ans;\\n    }\\n    long long modInverse(long long n,int mod){\\n        return power(n,mod-2,mod);\\n    }\\n    void init(){\\n        fact[0] = 1;\\n        for(int i=1;i<N;i++){\\n            fact[i] = (fact[i-1]*i)%mod;\\n        }\\n    }\\n    int countAnagrams(string s){\\n        init();\\n        int n = s.size();\\n        vector<string> tmp;\\n        string val = \"\";\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){\\n                if(val!=\"\") tmp.push_back(val);\\n                val = \"\";\\n            }\\n            else{\\n                val.push_back(s[i]);\\n            }\\n        }\\n        if(val!=\"\") tmp.push_back(val);\\n        long long ans = 1;\\n        for(auto &ele:tmp){\\n            cout<<ele<<\" \";\\n            unordered_map<char,int> mp;\\n            for(int i=0;i<ele.size();i++){\\n                mp[ele[i]]++;\\n            }\\n            ans = (ans*fact[(int)ele.size()])%mod;\\n            for(auto &pr:mp){\\n                long long inv = modInverse(fact[pr.second],mod)%mod;\\n                ans = (ans*inv)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const static int mod = 1e9+7,N = 1e5+10;\\n    long long fact[N];\\n    long long power(long long x,int y,int mod){\\n        long long ans = 1;\\n        x = x%mod;\\n        while(y >0){\\n            if(y&1){\\n                ans = (ans*x)%mod;\\n            }\\n            y>>=1;\\n            x = (x*x)%mod;\\n        }\\n        return ans;\\n    }\\n    long long modInverse(long long n,int mod){\\n        return power(n,mod-2,mod);\\n    }\\n    void init(){\\n        fact[0] = 1;\\n        for(int i=1;i<N;i++){\\n            fact[i] = (fact[i-1]*i)%mod;\\n        }\\n    }\\n    int countAnagrams(string s){\\n        init();\\n        int n = s.size();\\n        vector<string> tmp;\\n        string val = \"\";\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){\\n                if(val!=\"\") tmp.push_back(val);\\n                val = \"\";\\n            }\\n            else{\\n                val.push_back(s[i]);\\n            }\\n        }\\n        if(val!=\"\") tmp.push_back(val);\\n        long long ans = 1;\\n        for(auto &ele:tmp){\\n            cout<<ele<<\" \";\\n            unordered_map<char,int> mp;\\n            for(int i=0;i<ele.size();i++){\\n                mp[ele[i]]++;\\n            }\\n            ans = (ans*fact[(int)ele.size()])%mod;\\n            for(auto &pr:mp){\\n                long long inv = modInverse(fact[pr.second],mod)%mod;\\n                ans = (ans*inv)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2946503,
                "title": "c-factorial-and-their-inverse-mathematics-easy-to-understand",
                "content": "Explanation:\\nAns is multiplication of nos of different permutations of all words in the given string\\n\\nExample:\\n\\nsuppose the given string is \"abc bcd ffa\"\\nwe can write abc in 6 ways\\nbcd in 6 ways\\nsimilarly ffa in 3 ways (ffa,faf,aff)\\ntotal no of different strings that can be produced\\nwe have 3 positions\\n\"___ ___ ___\"\\nTotal 6 * 6 * 3 ways (Fundamental Principle of Counting) or can say observation.\\n\\nTo find individual way of writing a word we can do\\nFactorial of length of that word divide by\\n(Multiplication of factorial of count of [\\'a\\',\\'z\\'] in that word).\\n\\nBut here factorials value are large so we can\\'t perform divide instead we can multiply with their inverse.\\n\\nHope You understand the solutoin.\\nFor clarification comment down.\\n\\n**Complexity**\\n\\n**Time complexity:** O(logn+n+(no of words*(length of word + 26)) )\\n**Space complexity:** O(n)\\n\\n**Code**\\n```\\n\\n\\n\\nclass Solution\\n{\\npublic:\\n#define ll long long\\n    const int mod = 1e9 + 7;\\n\\n    vector<ll> fact, invfact;\\n\\n    ll binpow(ll a, ll b, ll p)\\n    {\\n        ll res = 1;\\n        a %= p;\\n        while (b)\\n        {\\n            if (b & 1)\\n                res = (res * a) % p;\\n            a = (a * a) % p;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n\\n    void precompute()\\n    {\\n        ll n = 100000;\\n\\n        fact.resize(n + 1);\\n        invfact.resize(n + 1);\\n\\n        fact[0] = 1;\\n        for (int i = 1; i <= n; ++i)\\n            fact[i] = (fact[i - 1] * i) % mod;\\n\\n        invfact[n] = binpow(fact[n], mod - 2, mod);\\n        for (int i = n - 1; i >= 0; --i)\\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod; // computing all factorial inverses in O(N)\\n    }\\n\\n    int countAnagrams(string s)\\n    {\\n        precompute();\\n        vector<string> S;\\n        stringstream ss(s);\\n        string SS;\\n        while (ss >> SS)\\n            S.push_back(SS); // Getting all words from the main string ( we can do normal for loop also)\\n        int ans = 1;\\n        for (auto x : S)\\n        {\\n            ans = (ans * fact[x.size()]) % mod;\\n            map<char, int> mp;\\n            for (auto y : x)\\n                mp[y]++;\\n            for (auto counts : mp)\\n                ans = (ans * invfact[counts.second]) % mod;\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "String",
                    "Combinatorics"
                ],
                "code": "```\\n\\n\\n\\nclass Solution\\n{\\npublic:\\n#define ll long long\\n    const int mod = 1e9 + 7;\\n\\n    vector<ll> fact, invfact;\\n\\n    ll binpow(ll a, ll b, ll p)\\n    {\\n        ll res = 1;\\n        a %= p;\\n        while (b)\\n        {\\n            if (b & 1)\\n                res = (res * a) % p;\\n            a = (a * a) % p;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n\\n    void precompute()\\n    {\\n        ll n = 100000;\\n\\n        fact.resize(n + 1);\\n        invfact.resize(n + 1);\\n\\n        fact[0] = 1;\\n        for (int i = 1; i <= n; ++i)\\n            fact[i] = (fact[i - 1] * i) % mod;\\n\\n        invfact[n] = binpow(fact[n], mod - 2, mod);\\n        for (int i = n - 1; i >= 0; --i)\\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod; // computing all factorial inverses in O(N)\\n    }\\n\\n    int countAnagrams(string s)\\n    {\\n        precompute();\\n        vector<string> S;\\n        stringstream ss(s);\\n        string SS;\\n        while (ss >> SS)\\n            S.push_back(SS); // Getting all words from the main string ( we can do normal for loop also)\\n        int ans = 1;\\n        for (auto x : S)\\n        {\\n            ans = (ans * fact[x.size()]) % mod;\\n            map<char, int> mp;\\n            for (auto y : x)\\n                mp[y]++;\\n            for (auto counts : mp)\\n                ans = (ans * invfact[counts.second]) % mod;\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621575,
                "title": "easy-solution-with-modular-inverse-stringstream",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\nconst int MOD = 1e9+7;\\nint modInverse(int a, int m) {\\n    int m0 = m;\\n    int y = 0, x = 1;\\n\\n    if (m == 1)\\n        return 0;\\n\\n    while (a > 1) {\\n        int q = a / m;\\n        int t = m;\\n\\n        m = a % m;\\n        a = t;\\n        t = y;\\n\\n        y = x - q * y;\\n        x = t;\\n    }\\n\\n    if (x < 0)\\n        x += m0;\\n\\n    return x;\\n}\\n\\nint countAnagrams(string s) {\\n    stringstream ss(s);\\n    string temp;\\n    long long ans = 1;\\n    vector<int> fac(s.size()+10,1);\\n    for (int i = 2; i <= s.size()+8; i++) {\\n        fac[i] = (i * 1LL * fac[i - 1]) % MOD;\\n    }\\n\\n    while (ss >> temp) {\\n        int tem = fac[temp.size()];\\n        map<char, int> mp;\\n\\n        for (int i = 0; i < temp.size(); i++) {\\n            mp[temp[i]]++;\\n        }\\n\\n        for (auto m : mp) {\\n            int inverse = modInverse(fac[m.second], MOD);\\n            tem = (tem * 1LL * inverse) % MOD;\\n        }\\n\\n\\n        ans = (ans *1LL* tem) % MOD;\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nconst int MOD = 1e9+7;\\nint modInverse(int a, int m) {\\n    int m0 = m;\\n    int y = 0, x = 1;\\n\\n    if (m == 1)\\n        return 0;\\n\\n    while (a > 1) {\\n        int q = a / m;\\n        int t = m;\\n\\n        m = a % m;\\n        a = t;\\n        t = y;\\n\\n        y = x - q * y;\\n        x = t;\\n    }\\n\\n    if (x < 0)\\n        x += m0;\\n\\n    return x;\\n}\\n\\nint countAnagrams(string s) {\\n    stringstream ss(s);\\n    string temp;\\n    long long ans = 1;\\n    vector<int> fac(s.size()+10,1);\\n    for (int i = 2; i <= s.size()+8; i++) {\\n        fac[i] = (i * 1LL * fac[i - 1]) % MOD;\\n    }\\n\\n    while (ss >> temp) {\\n        int tem = fac[temp.size()];\\n        map<char, int> mp;\\n\\n        for (int i = 0; i < temp.size(); i++) {\\n            mp[temp[i]]++;\\n        }\\n\\n        for (auto m : mp) {\\n            int inverse = modInverse(fac[m.second], MOD);\\n            tem = (tem * 1LL * inverse) % MOD;\\n        }\\n\\n\\n        ans = (ans *1LL* tem) % MOD;\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448222,
                "title": "modular-arithmetic-inverse-modulo-explanation-with-comments",
                "content": "```\\nclass Solution\\n{\\n\\tlong long binExpo(long long a, long long b, long long m)\\n\\t{\\n\\t\\tif (b == 0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tlong long ans = binExpo(a, b / 2, m);\\n\\t\\tans = (ans * ans) % m;\\n\\t\\tif (b & 1)\\n\\t\\t{\\n\\t\\t\\tans = (ans * a) % m;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\npublic:\\n\\tint countAnagrams(string s)\\n\\t{\\n\\t\\t// conversion of string of words into vector of words for simplicity\\n\\t\\tstringstream ss(s);\\n\\t\\tvector<string> words;\\n\\t\\tstring str = \"\";\\n\\t\\tint maxi = -1; // storing maximum length of word in s\\n\\n\\t\\twhile (ss >> str)\\n\\t\\t{\\n\\t\\t\\twords.push_back(str);\\n\\t\\t\\tint len = str.size();\\n\\t\\t\\tmaxi = max(maxi, len); // calculating the maximum length of word for precomputation\\n\\t\\t}\\n\\n\\t\\tlong long fact[maxi + 1];\\n\\t\\tfact[0] = 1;\\n\\t\\tlong long mod = 1e9 + 7;\\n\\t\\tfor (int i = 1; i <= maxi; i++)\\n\\t\\t{\\n\\t\\t\\tfact[i] = (fact[i - 1] * i) % mod;\\n\\t\\t}\\n\\t\\tunordered_map<char, int> freq; // used to store freq of each of each character\\n\\t\\tint res = 1;\\t\\t\\t\\t   // final result\\n\\n\\t\\tfor (auto &curr : words)\\n\\t\\t{\\n\\t\\t\\tfor (auto &j : curr)\\n\\t\\t\\t{ // calculating the freq of each char of curr word\\n\\t\\t\\t\\tfreq[j]++;\\n\\t\\t\\t}\\n\\t\\t\\tlong ans = fact[curr.size()];\\n\\t\\t\\tfor (auto j : freq)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = (ans * binExpo(fact[j.second], mod - 2, mod)) % mod; // inverse modulo\\n\\t\\t\\t}\\n\\t\\t\\tres = ((res % mod) * (ans % mod)) % mod;\\n\\t\\t\\tfreq.clear();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Combinatorics",
                    "Counting"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tlong long binExpo(long long a, long long b, long long m)\\n\\t{\\n\\t\\tif (b == 0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tlong long ans = binExpo(a, b / 2, m);\\n\\t\\tans = (ans * ans) % m;\\n\\t\\tif (b & 1)\\n\\t\\t{\\n\\t\\t\\tans = (ans * a) % m;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\npublic:\\n\\tint countAnagrams(string s)\\n\\t{\\n\\t\\t// conversion of string of words into vector of words for simplicity\\n\\t\\tstringstream ss(s);\\n\\t\\tvector<string> words;\\n\\t\\tstring str = \"\";\\n\\t\\tint maxi = -1; // storing maximum length of word in s\\n\\n\\t\\twhile (ss >> str)\\n\\t\\t{\\n\\t\\t\\twords.push_back(str);\\n\\t\\t\\tint len = str.size();\\n\\t\\t\\tmaxi = max(maxi, len); // calculating the maximum length of word for precomputation\\n\\t\\t}\\n\\n\\t\\tlong long fact[maxi + 1];\\n\\t\\tfact[0] = 1;\\n\\t\\tlong long mod = 1e9 + 7;\\n\\t\\tfor (int i = 1; i <= maxi; i++)\\n\\t\\t{\\n\\t\\t\\tfact[i] = (fact[i - 1] * i) % mod;\\n\\t\\t}\\n\\t\\tunordered_map<char, int> freq; // used to store freq of each of each character\\n\\t\\tint res = 1;\\t\\t\\t\\t   // final result\\n\\n\\t\\tfor (auto &curr : words)\\n\\t\\t{\\n\\t\\t\\tfor (auto &j : curr)\\n\\t\\t\\t{ // calculating the freq of each char of curr word\\n\\t\\t\\t\\tfreq[j]++;\\n\\t\\t\\t}\\n\\t\\t\\tlong ans = fact[curr.size()];\\n\\t\\t\\tfor (auto j : freq)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = (ans * binExpo(fact[j.second], mod - 2, mod)) % mod; // inverse modulo\\n\\t\\t\\t}\\n\\t\\t\\tres = ((res % mod) * (ans % mod)) % mod;\\n\\t\\t\\tfreq.clear();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412323,
                "title": "c-time-o-n-space-n-multiply-permutation-short-sweet-code",
                "content": "/*\\nlets a substring is aaabbbcc\\nso ans for this \\n          8!/(3!*3!*2!)\\n*/\\n````\\nclass Solution {\\npublic:\\n    int getinverse(long long int a,int b,int c){\\n        long long int ans = 1;\\n        while(b){\\n            if(b&1){\\n                ans = (ans*a)%c;\\n            }\\n            a = (a*a)%c;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    int countAnagrams(string s) {\\n        int mod = 1e9+7;\\n        int n = s.length(),i;\\n        vector<int> fact(n+10,1);\\n        for(i = 2; i <= n+8; i++){\\n            fact[i] = (fact[i-1]*1LL*i)%mod;//get factorial till s.length\\n        }\\n        long long int ans = 1,tmp;\\n        vector<int> factinv(n+10,0);\\n        for(int i = 0; i <= n+8; i++){\\n            factinv[i] = getinverse(fact[i],mod-2,mod);//factorial inverse of eash number\\n        }\\n        vector<int> dp(26,0);\\n        int k = 0;//k = length of substring\\n        for(auto &i: s){\\n            if(i==\\' \\'){//perform above mentioned approach\\n                tmp = fact[k];//\\n                for(auto &j: dp){\\n                    tmp = (tmp*1LL*factinv[j])%mod;\\n                }\\n                ans = (ans*tmp)%mod;\\n                fill(dp.begin(),dp.end(),0);\\n                k = 0;\\n            }else{\\n                dp[i-\\'a\\']++;\\n                k++;\\n            }\\n        }\\n\\t\\t//for last substring\\n        tmp = fact[k];\\n        for(auto &j: dp){\\n        tmp = (tmp*1LL*factinv[j])%mod;\\n        }\\n        ans = (ans*tmp)%mod;\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int getinverse(long long int a,int b,int c){\\n        long long int ans = 1;\\n        while(b){\\n            if(b&1){\\n                ans = (ans*a)%c;\\n            }\\n            a = (a*a)%c;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    int countAnagrams(string s) {\\n        int mod = 1e9+7;\\n        int n = s.length(),i;\\n        vector<int> fact(n+10,1);\\n        for(i = 2; i <= n+8; i++){\\n            fact[i] = (fact[i-1]*1LL*i)%mod;//get factorial till s.length\\n        }\\n        long long int ans = 1,tmp;\\n        vector<int> factinv(n+10,0);\\n        for(int i = 0; i <= n+8; i++){\\n            factinv[i] = getinverse(fact[i],mod-2,mod);//factorial inverse of eash number\\n        }\\n        vector<int> dp(26,0);\\n        int k = 0;//k = length of substring\\n        for(auto &i: s){\\n            if(i==\\' \\'){//perform above mentioned approach\\n                tmp = fact[k];//\\n                for(auto &j: dp){\\n                    tmp = (tmp*1LL*factinv[j])%mod;\\n                }\\n                ans = (ans*tmp)%mod;\\n                fill(dp.begin(),dp.end(),0);\\n                k = 0;\\n            }else{\\n                dp[i-\\'a\\']++;\\n                k++;\\n            }\\n        }\\n\\t\\t//for last substring\\n        tmp = fact[k];\\n        for(auto &j: dp){\\n        tmp = (tmp*1LL*factinv[j])%mod;\\n        }\\n        ans = (ans*tmp)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025314,
                "title": "easy-python-solution",
                "content": "```\\ndef countAnagrams(self, s: str) -> int:\\n        res=1\\n        for i in s.split():\\n            a=Counter(i)\\n            l=factorial(len(i))\\n            \\n            for k,v in a.items():\\n               l=l//factorial(v)\\n            res=(res*l)\\n        return res%((10**9)+7)\\n```",
                "solutionTags": [],
                "code": "```\\ndef countAnagrams(self, s: str) -> int:\\n        res=1\\n        for i in s.split():\\n            a=Counter(i)\\n            l=factorial(len(i))\\n            \\n            for k,v in a.items():\\n               l=l//factorial(v)\\n            res=(res*l)\\n        return res%((10**9)+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2953119,
                "title": "modulo-multiplicative-inverse-using-binary-exponentiation-easy-c-solution",
                "content": "\\n// modulo multiplicative inverse using binary exponentiation for better understanding\\n//https://youtu.be/Gd9w8m-klho\\n# Code\\n```\\nusing ll=long long;\\nclass Solution {\\npublic:\\nconst int N=1e5+1;\\n        ll mod=1e9+7;\\n    vector<ll> precompute;\\n    ll temp=1;\\n    void fun(){\\n    for(int i=1;i<N;i++){\\n        temp=((temp%mod)*i)%mod;\\n        precompute.push_back(temp);\\n    }\\n    }\\n    ll binaryexp(int a,int b,int m){\\n        ll res=1;\\n        while(b>0){\\n            if(b%2==1){\\n                res=((1ll)*res*a)%m;\\n            }\\n            a=((1ll)*a*a)%mod;\\n            b=b>>1;\\n        }\\n        return res;\\n    }\\n\\n    int countAnagrams(string s) {\\n        int n=s.size();\\n        stringstream s1(s);\\n          precompute.push_back(1);\\n        string word;\\n        fun();\\n        vector<ll> sum;\\n            ll ans=1;\\n        while(s1>>word){\\n            unordered_map<char,ll> m;\\n            for(auto &j:word){\\n                m[j]++;\\n            }\\n            int n1=word.size();\\n          long long temp1=precompute[n1];\\n            ll temp2=1;\\n            for(auto &j1:m){\\n                if(j1.second>1){\\n                    ll k=j1.second;\\n                    temp2=((temp2%mod)*precompute[k])%mod;\\n        \\n                }\\n            }\\n         \\n         ll den=binaryexp(temp2,mod-2,mod); //denominator\\n         \\n         ll proeach=((temp1%mod)*den)%mod;\\n           ans=((ans%mod)*proeach)%mod;\\n             // cout<<temp2<<\" \"<<den<<\" \"<<proeach<<\" \"<<ans<<endl;\\n     \\n        }\\n    \\n    return ans%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing ll=long long;\\nclass Solution {\\npublic:\\nconst int N=1e5+1;\\n        ll mod=1e9+7;\\n    vector<ll> precompute;\\n    ll temp=1;\\n    void fun(){\\n    for(int i=1;i<N;i++){\\n        temp=((temp%mod)*i)%mod;\\n        precompute.push_back(temp);\\n    }\\n    }\\n    ll binaryexp(int a,int b,int m){\\n        ll res=1;\\n        while(b>0){\\n            if(b%2==1){\\n                res=((1ll)*res*a)%m;\\n            }\\n            a=((1ll)*a*a)%mod;\\n            b=b>>1;\\n        }\\n        return res;\\n    }\\n\\n    int countAnagrams(string s) {\\n        int n=s.size();\\n        stringstream s1(s);\\n          precompute.push_back(1);\\n        string word;\\n        fun();\\n        vector<ll> sum;\\n            ll ans=1;\\n        while(s1>>word){\\n            unordered_map<char,ll> m;\\n            for(auto &j:word){\\n                m[j]++;\\n            }\\n            int n1=word.size();\\n          long long temp1=precompute[n1];\\n            ll temp2=1;\\n            for(auto &j1:m){\\n                if(j1.second>1){\\n                    ll k=j1.second;\\n                    temp2=((temp2%mod)*precompute[k])%mod;\\n        \\n                }\\n            }\\n         \\n         ll den=binaryexp(temp2,mod-2,mod); //denominator\\n         \\n         ll proeach=((temp1%mod)*den)%mod;\\n           ans=((ans%mod)*proeach)%mod;\\n             // cout<<temp2<<\" \"<<den<<\" \"<<proeach<<\" \"<<ans<<endl;\\n     \\n        }\\n    \\n    return ans%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2946613,
                "title": "c-division-with-prime-modulo-10-9-7-solution-explained",
                "content": "**Formula for factorial**\\n4! = `1 x 2 x 3 x 4`\\n\\n**Formula for permutations.**\\nFor permutations of \"cccbhbq\", \"c\" is repeated 3 times and \"b\" is repeated 2 times. There are 7 total characters. Therefore, calculation for the permutations is `7! / (3! * 2!)`.\\n\\n**For dividing with prime modulo:**\\n`a / b` == `a * b^(-1)`\\n`b^(-1) mod m` == `b^(modulo - 2)` \\n\\n**Time complexity**\\nO(N log N). Loop through each character in the string thus `O(N)`. For every word, there is a `O(log N)` calculation of denominator to the power of `mod-2`.\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int countAnagrams(string s) {\\n\\t\\t// preprocess factorial calculations\\n\\t\\tvector<long> factorial {1};\\n        for (int i = 1; i <100004; ++i) {\\n            long curr = (factorial[factorial.size()-1] * i);\\n            curr %= mod;\\n            factorial.push_back(curr);\\n        }\\n\\t\\t\\n        vector<int> freq(26); \\n        int prev = 0;\\n        long permutations = 1;\\n        for (int i = 0; i <= s.size(); ++i) {\\n            if (i != s.size() && s[i] != \\' \\') {\\n                freq[s[i]-\\'a\\']++;\\n            } else {\\n\\t\\t\\t\\t// calculate according to permutation formula\\n                long num = factorial[i-prev];\\n                long denom = 1;\\n                for (long val : freq) { // multiply factorial of repeated characters to denominator\\n                    if (val <= 1) continue;\\n                    denom *= factorial[val];\\n                    denom %= mod;\\n                }\\n                permutations *= (num * (fastpow(denom, mod-2) % mod)) % mod;\\n                permutations %= mod;\\n                \\n\\t\\t\\t\\t// reset hash map and previous index\\n                freq.assign(26, 0);\\n                prev = i+1;\\n            }\\n        }\\n        \\n        return permutations;\\n    }\\n    \\n\\t// fast pow function i found online o(logn)\\n    long long fastpow(long long b, long long ex){\\n        if (b==1)return 1;\\n        long long r = 1;\\n        while (ex ){\\n            if (ex&1)r=(r * b)%mod;\\n            ex = ex >> 1;\\n            b = (b * b)%mod;}\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int countAnagrams(string s) {\\n\\t\\t// preprocess factorial calculations\\n\\t\\tvector<long> factorial {1};\\n        for (int i = 1; i <100004; ++i) {\\n            long curr = (factorial[factorial.size()-1] * i);\\n            curr %= mod;\\n            factorial.push_back(curr);\\n        }\\n\\t\\t\\n        vector<int> freq(26); \\n        int prev = 0;\\n        long permutations = 1;\\n        for (int i = 0; i <= s.size(); ++i) {\\n            if (i != s.size() && s[i] != \\' \\') {\\n                freq[s[i]-\\'a\\']++;\\n            } else {\\n\\t\\t\\t\\t// calculate according to permutation formula\\n                long num = factorial[i-prev];\\n                long denom = 1;\\n                for (long val : freq) { // multiply factorial of repeated characters to denominator\\n                    if (val <= 1) continue;\\n                    denom *= factorial[val];\\n                    denom %= mod;\\n                }\\n                permutations *= (num * (fastpow(denom, mod-2) % mod)) % mod;\\n                permutations %= mod;\\n                \\n\\t\\t\\t\\t// reset hash map and previous index\\n                freq.assign(26, 0);\\n                prev = i+1;\\n            }\\n        }\\n        \\n        return permutations;\\n    }\\n    \\n\\t// fast pow function i found online o(logn)\\n    long long fastpow(long long b, long long ex){\\n        if (b==1)return 1;\\n        long long r = 1;\\n        while (ex ){\\n            if (ex&1)r=(r * b)%mod;\\n            ex = ex >> 1;\\n            b = (b * b)%mod;}\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643204,
                "title": "simple-python3-solution-explained-code",
                "content": "# Intuition\\nCode explained in comments.\\n\\n# Code\\n```\\n#from itertools import permutations\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod= 10**9 + 7\\n        #splitting the words of string s in list w\\n        w=s.split(\" \")\\n        a=[]\\n        #then iterating the words in list and appending the permutation of the word to list a\\n        for i in w:\\n            a.append(Solution.perm(i))\\n        #multiplying the elements of list to return the total count of Anagrams\\n        result = 1\\n        for num in a:\\n            result *= num\\n        return result % mod\\n\\n    #function to calculate the permutation of a given string \\n    def perm(inputt):\\n        char_counts = Counter(inputt)\\n        total_permutations = factorial(len(inputt))\\n        denominator = 1\\n        for i in char_counts.values():\\n            denominator *= factorial(i)\\n        return total_permutations // denominator\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#from itertools import permutations\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod= 10**9 + 7\\n        #splitting the words of string s in list w\\n        w=s.split(\" \")\\n        a=[]\\n        #then iterating the words in list and appending the permutation of the word to list a\\n        for i in w:\\n            a.append(Solution.perm(i))\\n        #multiplying the elements of list to return the total count of Anagrams\\n        result = 1\\n        for num in a:\\n            result *= num\\n        return result % mod\\n\\n    #function to calculate the permutation of a given string \\n    def perm(inputt):\\n        char_counts = Counter(inputt)\\n        total_permutations = factorial(len(inputt))\\n        denominator = 1\\n        for i in char_counts.values():\\n            denominator *= factorial(i)\\n        return total_permutations // denominator\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069310,
                "title": "scala-modulo-arithmetic-step-by-step-guide",
                "content": "# Intuition\\nIn order to count anagrams we should count permutations of letters for each word and multiply them. Permutations are computed with factorial. The simplest solution looks like this:\\n\\n```scala\\nval m = 1000000007\\n\\ndef countAnagrams(s: String): Int = {\\n  val wordCounts = s.split(\\' \\').map { word =>\\n    val charCounts = word.groupBy(identity).map(pair => factorial(pair._2.length()))\\n    factorial(word.length()) / charCounts.reduce(_ * _)\\n  }\\n  wordCounts.reduce(_ * _).mod(m).toInt\\n}\\n\\ndef factorial(n: Int): BigInt = BigInt(2.to(n).foldLeft(1)((acc, el) => acc * el % m))\\n```\\nHowever, the solution fails the performance test case. To count it effectively we should switch to modulo arithmetics.\\nNotice, that we require only four operations in our algebra:\\n```scala\\ntrait Arithmetic[T] {\\n  def factorial(n: Int): T\\n  def multiply(a: T, b: T): T\\n  def division(a: T, b: T): T\\n  def toInt(n: T): Int\\n}\\n```\\n\\nThe original solution can be rewritten in terms of this trait:\\n```scala\\ndef doCount[T](s: String, ar: Arithmetic[T]): Int = {\\n  val wordCounts = s.split(\\' \\').toList.map { word =>\\n    val charCounts = word.groupBy(identity).map(pair => ar.factorial(pair._2.length))\\n    ar.division(ar.factorial(word.length()), charCounts.reduce(ar.multiply))\\n  }\\n  ar.toInt(wordCounts.reduce(ar.multiply))\\n}\\n```\\nwith the corresponding arithemtic:\\n```scala\\nfinal class BigIntModuloArithmetic(m: Int) extends Arithmetic[BigInt] {\\n  def factorial(n: Int): BigInt = 2.to(n).foldLeft(BigInt(1))((acc, el) => acc * el)\\n  def multiply(a: BigInt, b: BigInt): BigInt = a * b\\n  def division(a: BigInt, b: BigInt): BigInt = a / b\\n  def toInt(n: BigInt): Int = (n % m).toInt\\n}\\n```\\nWe can verify that this code works the same as the original solution using\\n```scala\\ndef countAnagrams(s: String): Int =\\n  doCount(s, new BigIntModuloArithmetic(1000000007))\\n```\\n\\nLastly, we need to implement modulo arithmetic. `factorial`, `multiply` and `toInt` are trivial, whereas `division` is not.\\n```scala\\nfinal class IntModuloArithmetic(mInt: Int) extends Arithmetic[Int] {\\n  private val m = BigInt(mInt)\\n  def factorial(n: Int): Int = 2.to(n).foldLeft(1)((acc, el) => multiply(acc, el))\\n  def multiply(a: Int, b: Int): Int = (BigInt(a) * BigInt(b)).mod(m).toInt\\n  def division(a: Int, b: Int): Int = (BigInt(b).modInverse(m) * a).mod(m).toInt\\n  def toInt(n: Int): Int = n\\n}\\n```\\nTo verify the implementation we need to change the implementation of `countAnagram` \\n```scala\\ndef countAnagrams(s: String): Int =\\n  doCount(s, new IntModuloArithmetic(1000000007))\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nval m = 1000000007\\n\\ndef countAnagrams(s: String): Int = {\\n  val wordCounts = s.split(\\' \\').map { word =>\\n    val charCounts = word.groupBy(identity).map(pair => factorial(pair._2.length()))\\n    factorial(word.length()) / charCounts.reduce(_ * _)\\n  }\\n  wordCounts.reduce(_ * _).mod(m).toInt\\n}\\n\\ndef factorial(n: Int): BigInt = BigInt(2.to(n).foldLeft(1)((acc, el) => acc * el % m))\\n```\n```scala\\ntrait Arithmetic[T] {\\n  def factorial(n: Int): T\\n  def multiply(a: T, b: T): T\\n  def division(a: T, b: T): T\\n  def toInt(n: T): Int\\n}\\n```\n```scala\\ndef doCount[T](s: String, ar: Arithmetic[T]): Int = {\\n  val wordCounts = s.split(\\' \\').toList.map { word =>\\n    val charCounts = word.groupBy(identity).map(pair => ar.factorial(pair._2.length))\\n    ar.division(ar.factorial(word.length()), charCounts.reduce(ar.multiply))\\n  }\\n  ar.toInt(wordCounts.reduce(ar.multiply))\\n}\\n```\n```scala\\nfinal class BigIntModuloArithmetic(m: Int) extends Arithmetic[BigInt] {\\n  def factorial(n: Int): BigInt = 2.to(n).foldLeft(BigInt(1))((acc, el) => acc * el)\\n  def multiply(a: BigInt, b: BigInt): BigInt = a * b\\n  def division(a: BigInt, b: BigInt): BigInt = a / b\\n  def toInt(n: BigInt): Int = (n % m).toInt\\n}\\n```\n```scala\\ndef countAnagrams(s: String): Int =\\n  doCount(s, new BigIntModuloArithmetic(1000000007))\\n```\n```scala\\nfinal class IntModuloArithmetic(mInt: Int) extends Arithmetic[Int] {\\n  private val m = BigInt(mInt)\\n  def factorial(n: Int): Int = 2.to(n).foldLeft(1)((acc, el) => multiply(acc, el))\\n  def multiply(a: Int, b: Int): Int = (BigInt(a) * BigInt(b)).mod(m).toInt\\n  def division(a: Int, b: Int): Int = (BigInt(b).modInverse(m) * a).mod(m).toInt\\n  def toInt(n: Int): Int = n\\n}\\n```\n```scala\\ndef countAnagrams(s: String): Int =\\n  doCount(s, new IntModuloArithmetic(1000000007))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052720,
                "title": "c-solution-by-counting-the-prime-numbers",
                "content": "# Intuition\\n1. Given a number n, it is not very hard to calculate all the primes less than n and therefore, it is also easy to find out the power of a prime number for n!\\n2. To calculate n!/k!, it is equal to caculate the difference of the power of prime numbers of n! and k!. \\n\\n# Approach\\n1. For any given word, calculate its length n and all the duplicate characters c1, c2,...ck. Save n and c1, c2, ..ck into two different vectors\\n2. For each word length n, and for each prime number p less than n, calculate the power of p in n!. Sum up the power of p for all the word length.\\n3. Similarily, for a given duplicate c, calcualte the power of p in c! and reduce this power from the step 2.\\n4. For all the prime numbers and corresponding power, calculate the answer with module of 1e9 + 7.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAnagrams(string s) {\\n        long long ans = 1;\\n        vector<int> wLens;\\n        int nMaxLen = 0;\\n        vector<int> dupLens;\\n        for (int i = 0, idx = 0; i < s.size(); i = idx + 1)\\n        {\\n            idx = i;\\n            vector<int> cm(26, 0);\\n            for (; idx < s.size() && s[idx] != \\' \\'; idx++)     cm[s[idx] - \\'a\\']++;  \\n            wLens.push_back(idx - i);\\n            nMaxLen = max(nMaxLen, idx - i);\\n            for (int j = 0; j < 26; ++j)\\n                if (cm[j] > 1)  dupLens.push_back(cm[j]);\\n        }\\n\\n        map<int, int> m;\\n        vector<int> primes;\\n        generatePrimes(nMaxLen + 1, primes);\\n        for(int i = 0; i < wLens.size(); ++i)   addPrimeFactors(wLens[i], m, 1, primes);\\n        for(int i = 0; i < dupLens.size(); ++i) addPrimeFactors(dupLens[i], m, -1, primes);\\n        for (auto itr = m.begin(); itr != m.end(); ++itr)\\n        {\\n            for(int i = 0; i < itr->second; ++i)\\n            {\\n                ans = (ans * itr->first) % 1000000007;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    void addPrimeFactors(int n, map<int, int>& m, int w, vector<int>& primes)\\n    {\\n        vector<int> nums(n + 1, 0);\\n        for(int i = 0; i < primes.size() && primes[i] <= n; ++i)\\n        {\\n            int count = 0;\\n            for(long long num = primes[i]; num <= n; num = num * primes[i])   count += (n / num);\\n            m[primes[i]] = m[primes[i]] + w*count;\\n        }\\n    }\\n\\n    void generatePrimes(int n, vector<int>& primes)\\n    {\\n        if (n <= 2)  return;\\n        primes = {2};\\n        vector<int> nums(n, 0);\\n        for(int i = 3; i < n; i = i + 2)\\n        {\\n            if (nums[i] == 1)   continue;\\n            primes.push_back(i);\\n            for(int m = 3*i; m < n; m += 2*i)   nums[m] = 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAnagrams(string s) {\\n        long long ans = 1;\\n        vector<int> wLens;\\n        int nMaxLen = 0;\\n        vector<int> dupLens;\\n        for (int i = 0, idx = 0; i < s.size(); i = idx + 1)\\n        {\\n            idx = i;\\n            vector<int> cm(26, 0);\\n            for (; idx < s.size() && s[idx] != \\' \\'; idx++)     cm[s[idx] - \\'a\\']++;  \\n            wLens.push_back(idx - i);\\n            nMaxLen = max(nMaxLen, idx - i);\\n            for (int j = 0; j < 26; ++j)\\n                if (cm[j] > 1)  dupLens.push_back(cm[j]);\\n        }\\n\\n        map<int, int> m;\\n        vector<int> primes;\\n        generatePrimes(nMaxLen + 1, primes);\\n        for(int i = 0; i < wLens.size(); ++i)   addPrimeFactors(wLens[i], m, 1, primes);\\n        for(int i = 0; i < dupLens.size(); ++i) addPrimeFactors(dupLens[i], m, -1, primes);\\n        for (auto itr = m.begin(); itr != m.end(); ++itr)\\n        {\\n            for(int i = 0; i < itr->second; ++i)\\n            {\\n                ans = (ans * itr->first) % 1000000007;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    void addPrimeFactors(int n, map<int, int>& m, int w, vector<int>& primes)\\n    {\\n        vector<int> nums(n + 1, 0);\\n        for(int i = 0; i < primes.size() && primes[i] <= n; ++i)\\n        {\\n            int count = 0;\\n            for(long long num = primes[i]; num <= n; num = num * primes[i])   count += (n / num);\\n            m[primes[i]] = m[primes[i]] + w*count;\\n        }\\n    }\\n\\n    void generatePrimes(int n, vector<int>& primes)\\n    {\\n        if (n <= 2)  return;\\n        primes = {2};\\n        vector<int> nums(n, 0);\\n        for(int i = 3; i < n; i = i + 2)\\n        {\\n            if (nums[i] == 1)   continue;\\n            primes.push_back(i);\\n            for(int m = 3*i; m < n; m += 2*i)   nums[m] = 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012565,
                "title": "javascript-modular-multiplicative-inverse",
                "content": "Using modular multiplicative inverse formula found on internet https://cp-algorithms.com/algebra/module-inverse.html\\n\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAnagrams = function (s) {\\n  let result = 1n;\\n  const MODULO = 1000000007n;\\n\\n  // precompute factorials\\n  const facts = new Array(1e5 + 10).fill(1n);\\n  for (let i = 1; i < facts.length; ++i) facts[i] = ((facts[i - 1] % MODULO) * (BigInt(i) % MODULO)) % MODULO;\\n\\n  for (const w of s.split(\\' \\')) {\\n    const cnt = w.split(\\'\\').reduce((a, x) => (a.set(x, (a.get(x) || 0) + 1), a), new Map());\\n    let divisor = [...cnt.values()].reduce((a, x) => (a * facts[x]) % MODULO, 1n);\\n    let div_inv_mod = 1n;\\n    let power = MODULO - 2n;\\n    while (0n < power) {\\n      if (power & 1n) div_inv_mod = (div_inv_mod * divisor) % MODULO;\\n      divisor = (divisor * divisor) % MODULO;\\n      power >>= 1n;\\n    }\\n    result = ((result * (facts[w.length] * div_inv_mod)) % MODULO) % MODULO;\\n  }\\n\\n  return Number(result);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAnagrams = function (s) {\\n  let result = 1n;\\n  const MODULO = 1000000007n;\\n\\n  // precompute factorials\\n  const facts = new Array(1e5 + 10).fill(1n);\\n  for (let i = 1; i < facts.length; ++i) facts[i] = ((facts[i - 1] % MODULO) * (BigInt(i) % MODULO)) % MODULO;\\n\\n  for (const w of s.split(\\' \\')) {\\n    const cnt = w.split(\\'\\').reduce((a, x) => (a.set(x, (a.get(x) || 0) + 1), a), new Map());\\n    let divisor = [...cnt.values()].reduce((a, x) => (a * facts[x]) % MODULO, 1n);\\n    let div_inv_mod = 1n;\\n    let power = MODULO - 2n;\\n    while (0n < power) {\\n      if (power & 1n) div_inv_mod = (div_inv_mod * divisor) % MODULO;\\n      divisor = (divisor * divisor) % MODULO;\\n      power >>= 1n;\\n    }\\n    result = ((result * (facts[w.length] * div_inv_mod)) % MODULO) % MODULO;\\n  }\\n\\n  return Number(result);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2999347,
                "title": "python-elegant-short-one-line",
                "content": "```\\nfrom collections import Counter\\nfrom functools import reduce\\nfrom math import perm, prod\\n\\n\\nclass Solution:\\n    MOD = 10 ** 9 + 7\\n\\n    def countAnagrams(self, s: str) -> int:\\n        return reduce(lambda ans, w: ans * perm(len(w)) // prod(map(perm, Counter(w).values())) % self.MOD, s.split(), 1)\\n\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\nfrom collections import Counter\\nfrom functools import reduce\\nfrom math import perm, prod\\n\\n\\nclass Solution:\\n    MOD = 10 ** 9 + 7\\n\\n    def countAnagrams(self, s: str) -> int:\\n        return reduce(lambda ans, w: ans * perm(len(w)) // prod(map(perm, Counter(w).values())) % self.MOD, s.split(), 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972286,
                "title": "swift-version-modular-inverse",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreat explanation please refer\\nhttps://leetcode.com/problems/count-anagrams/solutions/2947111/c-solution-math-with-explanation-each-step-in-detail/?orderBy=most_votes\\n\\nAdd on reference for Fermat\\'s little theorem\\nhttps://en.wikipedia.org/wiki/Fermat%27s_little_theorem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. catch the factorial result for reuse\\n2.  combination formula all $$n!/a!*b!$$ when there are 0...a and 0...b same items\\n2. modularMultiplication for handling multiply overflow product\\n3. binaryExponentiation for quickly get power of number\\n4. moduloInverse for deal with dividing the factorial for same items\\n\\n\\n# Code\\n```\\nclass Solution {\\n    let mod = Int(1e9+7)\\n    func countAnagrams(_ s: String) -> Int {\\n        var anagrams = [String: [Character: Int]]()\\n        for word in s.split(separator: \" \") {\\n            var anagram = [Character: Int]()\\n            word.forEach {\\n                anagram[$0, default: 0] += 1\\n            }\\n            anagrams[String(word)] = anagram\\n        }\\n\\n        var result = 1\\n        for anagram in anagrams {\\n            var permutation = factorial(anagram.key.count)\\n            var devideFactorial = 1\\n            for value in anagram.value.values {\\n                guard value > 1 else {\\n                    continue\\n                }\\n                // (a/b)%m != a%m / b%m -> use modular inverse for division\\n                permutation = modularMultiplication(permutation, moduloInverse(factorial(value)))\\n            }\\n            result = modularMultiplication(result, permutation)\\n        }\\n        return result\\n    }\\n    \\n    var factorials = [Int: Int]()\\n    func factorial(_ n: Int) -> Int {\\n        if let cache = factorials[n] {\\n            return cache\\n        }\\n        guard n > 1 else {\\n            return 1\\n        }\\n        let result = modularMultiplication(n, factorial(n-1))\\n        factorials[n] = result\\n        return result\\n    }\\n    \\n    // n^-1 % m\\n    func moduloInverse(_ n: Int) -> Int {\\n        binaryExponentiation(n, mod-2) % mod\\n    }\\n    \\n    // (a * b) % m\\n    func modularMultiplication(_ a: Int, _ b: Int) -> Int {\\n        (a % mod * b % mod) % mod\\n    }\\n    \\n    // pow(a, b)\\n    func binaryExponentiation(_ a: Int, _ b: Int) -> Int {\\n        if b == 0 {\\n            return 1\\n        }\\n        let result = binaryExponentiation(a, b/2)\\n        if b % 2 == 1 {\\n            return modularMultiplication(a, modularMultiplication(result, result))\\n        } else {\\n            return modularMultiplication(result, result)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    let mod = Int(1e9+7)\\n    func countAnagrams(_ s: String) -> Int {\\n        var anagrams = [String: [Character: Int]]()\\n        for word in s.split(separator: \" \") {\\n            var anagram = [Character: Int]()\\n            word.forEach {\\n                anagram[$0, default: 0] += 1\\n            }\\n            anagrams[String(word)] = anagram\\n        }\\n\\n        var result = 1\\n        for anagram in anagrams {\\n            var permutation = factorial(anagram.key.count)\\n            var devideFactorial = 1\\n            for value in anagram.value.values {\\n                guard value > 1 else {\\n                    continue\\n                }\\n                // (a/b)%m != a%m / b%m -> use modular inverse for division\\n                permutation = modularMultiplication(permutation, moduloInverse(factorial(value)))\\n            }\\n            result = modularMultiplication(result, permutation)\\n        }\\n        return result\\n    }\\n    \\n    var factorials = [Int: Int]()\\n    func factorial(_ n: Int) -> Int {\\n        if let cache = factorials[n] {\\n            return cache\\n        }\\n        guard n > 1 else {\\n            return 1\\n        }\\n        let result = modularMultiplication(n, factorial(n-1))\\n        factorials[n] = result\\n        return result\\n    }\\n    \\n    // n^-1 % m\\n    func moduloInverse(_ n: Int) -> Int {\\n        binaryExponentiation(n, mod-2) % mod\\n    }\\n    \\n    // (a * b) % m\\n    func modularMultiplication(_ a: Int, _ b: Int) -> Int {\\n        (a % mod * b % mod) % mod\\n    }\\n    \\n    // pow(a, b)\\n    func binaryExponentiation(_ a: Int, _ b: Int) -> Int {\\n        if b == 0 {\\n            return 1\\n        }\\n        let result = binaryExponentiation(a, b/2)\\n        if b % 2 == 1 {\\n            return modularMultiplication(a, modularMultiplication(result, result))\\n        } else {\\n            return modularMultiplication(result, result)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966584,
                "title": "count-anagrams-unordered-map-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n     int m = 1000000007;\\n        vector<long long > fact;\\n        void solve(){\\n            fact[0] = fact[1] =1 ;\\n            for(int i=2;i<100001;i++){\\n                fact[i] = (fact[i-1]%m * i%m )%m;\\n            }\\n        }\\n    ll powmod(ll a, ll b){\\n         ll res = 1;\\n         while(b>0){\\n             if(b%2 == 1)res= res*a % m;\\n        a= a*a % m;\\n         b = b/2;\\n         }\\n         return res;\\n    }\\n    ll inverse(ll n){\\n        return powmod(n,m-2);\\n    }\\n    int countAnagrams(string s) {\\n        fact.resize(100001);\\n        solve();\\n       ll ans =1 , cnt=0;\\n       unordered_map<char,int>freq;\\n       s+=\\' \\';\\n       for(int i=0;i<s.size();i++){\\n           if(s[i]==\\' \\'){\\n               ll val = fact[cnt];\\n               for(auto c : freq){\\n                   val  = val * inverse(fact[c.second])%m;\\n               }\\n            ans= ans*val % m;\\n            cnt=0;\\n            freq.clear();\\n           }\\n           else{\\n               cnt++;\\n               freq[s[i]]++;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n     int m = 1000000007;\\n        vector<long long > fact;\\n        void solve(){\\n            fact[0] = fact[1] =1 ;\\n            for(int i=2;i<100001;i++){\\n                fact[i] = (fact[i-1]%m * i%m )%m;\\n            }\\n        }\\n    ll powmod(ll a, ll b){\\n         ll res = 1;\\n         while(b>0){\\n             if(b%2 == 1)res= res*a % m;\\n        a= a*a % m;\\n         b = b/2;\\n         }\\n         return res;\\n    }\\n    ll inverse(ll n){\\n        return powmod(n,m-2);\\n    }\\n    int countAnagrams(string s) {\\n        fact.resize(100001);\\n        solve();\\n       ll ans =1 , cnt=0;\\n       unordered_map<char,int>freq;\\n       s+=\\' \\';\\n       for(int i=0;i<s.size();i++){\\n           if(s[i]==\\' \\'){\\n               ll val = fact[cnt];\\n               for(auto c : freq){\\n                   val  = val * inverse(fact[c.second])%m;\\n               }\\n            ans= ans*val % m;\\n            cnt=0;\\n            freq.clear();\\n           }\\n           else{\\n               cnt++;\\n               freq[s[i]]++;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963564,
                "title": "c-easy-approach-after-learning-binary-exponentiation-and-modular-multiplicative-inverse",
                "content": "# Intuition\\n    Total number of permutations of a word without duplicate letters Formula: N!\\n\\n    Total number of permutations of a word with duplicate letters Formula: N! / ma! * mb! * .... * mz! where N is the total number of letters and ma, mb are the occurrences of repetitive letters in the word\\n\\n# Approach\\n    Next (a / b) % mod will not be equal to (a % mod) / (b % mod) as it is large number we tend to take mod for every multiplication we do and we cannot calculate the final a / b to arrive at total permutations. So we make use of Modular Multiplicative Inverse\\n    \\n    (a / b) % mod != (a % mod) / (b % mod)\\n    By applying Fermat\\'s Little Theorem\\n    By Conclusion we have\\n    (a / b) % mod = a * (b ^ -1) % mod\\n    (b ^ -1) % mod = b ^ (mod - 2) --> O(N)\\n\\n    But now the Time Complexity if O(N * N) which is quadratic\\n    So to reduce we can use Binary Exponentiation which is O(logN)\\n\\n# Complexity\\n- Time complexity:\\n    # O(NlogN)\\n\\n- Space complexity:\\n    # O(N)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    const int mod = 1e9 + 7;\\n    long long fact[100005];\\n\\n    void factorial(int n) {\\n        fact[0] = 1;\\n        for(int i = 1;i <= n;i++) {\\n            fact[i] = (fact[i - 1] * i) % mod;\\n        }\\n    }\\n    \\n    long long getFactorial(long long n) {\\n        return fact[n];\\n    }\\n\\n    long long binExp(long long a, long long b) {\\n        long long res = 1;\\n        while(b) {\\n            if(b & 1) {  // set bit \\n                res = (res * a) % mod;\\n            }\\n            a = (a * a) % mod;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n\\n    long long modMul(long long a, long long b) {\\n        return ((a % mod) * (b % mod)) % mod;\\n    }\\n\\n    long long getPermuation(string &word) {\\n        int mp[26] = {0};\\n        long long pro = 1;\\n        long long n = word.size();\\n\\n        for(auto &ch : word) {\\n            mp[ch - \\'a\\']++;\\n        }\\n        \\n        long long totalFact = getFactorial(n);\\n        long long fact;\\n\\n        for(int i = 0;i < 26;i++) {\\n            if(mp[i] > 0) {\\n                fact = getFactorial(mp[i]);\\n                pro = (pro * fact) % mod;\\n            }\\n        }\\n\\n        long long a = totalFact;\\n        long long b = binExp(pro, mod - 2);\\n\\n        return modMul(a, b);\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        long long total = 1;\\n        int n = s.size();\\n        factorial(n);\\n\\n        stringstream ss(s);\\n        string word;\\n\\n        while(getline(ss, word, \\' \\')) {\\n            total = (total * getPermuation(word)) % mod;\\n        }\\n\\n        return total % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int mod = 1e9 + 7;\\n    long long fact[100005];\\n\\n    void factorial(int n) {\\n        fact[0] = 1;\\n        for(int i = 1;i <= n;i++) {\\n            fact[i] = (fact[i - 1] * i) % mod;\\n        }\\n    }\\n    \\n    long long getFactorial(long long n) {\\n        return fact[n];\\n    }\\n\\n    long long binExp(long long a, long long b) {\\n        long long res = 1;\\n        while(b) {\\n            if(b & 1) {  // set bit \\n                res = (res * a) % mod;\\n            }\\n            a = (a * a) % mod;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n\\n    long long modMul(long long a, long long b) {\\n        return ((a % mod) * (b % mod)) % mod;\\n    }\\n\\n    long long getPermuation(string &word) {\\n        int mp[26] = {0};\\n        long long pro = 1;\\n        long long n = word.size();\\n\\n        for(auto &ch : word) {\\n            mp[ch - \\'a\\']++;\\n        }\\n        \\n        long long totalFact = getFactorial(n);\\n        long long fact;\\n\\n        for(int i = 0;i < 26;i++) {\\n            if(mp[i] > 0) {\\n                fact = getFactorial(mp[i]);\\n                pro = (pro * fact) % mod;\\n            }\\n        }\\n\\n        long long a = totalFact;\\n        long long b = binExp(pro, mod - 2);\\n\\n        return modMul(a, b);\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        long long total = 1;\\n        int n = s.size();\\n        factorial(n);\\n\\n        stringstream ss(s);\\n        string word;\\n\\n        while(getline(ss, word, \\' \\')) {\\n            total = (total * getPermuation(word)) % mod;\\n        }\\n\\n        return total % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949412,
                "title": "easy-c-fermat-s-theorem-o-n-log-10-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFermat\\'s Theorem + factorial\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every word, count no of distinct chars and equal chars freq(using HashMap), now use concept of permutations for every word and keep on multiplying res into \"ans\"\\ne.g for word = \"abbscs\", res = 6!/(2!*2!) => 6! * $$(2!)^i$$*$$(2!)^i$$\\nwhere i = -1 and inv(n) = modular inverse of n w.r.t p can be calculated using Fermat\\'s Theorem:\\ninv(n, p) = pow(n, p-2)%p\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(10^9))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n = size of fact array $$(10^5)$$\\n\\n# Code\\n```\\n#define ll long long\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    \\n    ll bin_pow(ll a, ll n){\\n        ll res = 1;\\n        while(n > 0){\\n            if(n&1)\\n                res = (res*a)%mod;\\n            \\n            a = (a*a)%mod;\\n            n = n>>1;\\n        }\\n        \\n        return res;\\n    }\\n    \\n//     ll fun(ll n, ll r){\\n        \\n//     }\\n    \\n    int countAnagrams(string s) {\\n        int i, j;\\n        int n = s.length();\\n        int sz = 100000;\\n        ll fact[sz+1];\\n        fact[0] = 1;\\n        \\n        for(ll ind=1; ind <= sz; ind++){\\n            fact[ind] = (fact[ind-1]*ind)%mod;\\n        }\\n        \\n        ll ans = 1;\\n        \\n        i = 0;\\n        while(i < n){\\n            unordered_map<char, int> m;\\n            \\n            ll count = 0;\\n            \\n            while(i < n && s[i] != \\' \\'){\\n                count++;\\n                m[s[i]]++;\\n                i++;\\n            }\\n            \\n            ll N = fact[count];\\n            \\n            ll r = 1;\\n            for(auto it:m){\\n                r = (r*fact[it.second])%mod;\\n            }\\n            \\n            ll val = (N*bin_pow(r, mod-2))%mod;\\n            ans = (ans*val)%mod;\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    \\n    ll bin_pow(ll a, ll n){\\n        ll res = 1;\\n        while(n > 0){\\n            if(n&1)\\n                res = (res*a)%mod;\\n            \\n            a = (a*a)%mod;\\n            n = n>>1;\\n        }\\n        \\n        return res;\\n    }\\n    \\n//     ll fun(ll n, ll r){\\n        \\n//     }\\n    \\n    int countAnagrams(string s) {\\n        int i, j;\\n        int n = s.length();\\n        int sz = 100000;\\n        ll fact[sz+1];\\n        fact[0] = 1;\\n        \\n        for(ll ind=1; ind <= sz; ind++){\\n            fact[ind] = (fact[ind-1]*ind)%mod;\\n        }\\n        \\n        ll ans = 1;\\n        \\n        i = 0;\\n        while(i < n){\\n            unordered_map<char, int> m;\\n            \\n            ll count = 0;\\n            \\n            while(i < n && s[i] != \\' \\'){\\n                count++;\\n                m[s[i]]++;\\n                i++;\\n            }\\n            \\n            ll N = fact[count];\\n            \\n            ll r = 1;\\n            for(auto it:m){\\n                r = (r*fact[it.second])%mod;\\n            }\\n            \\n            ll val = (N*bin_pow(r, mod-2))%mod;\\n            ans = (ans*val)%mod;\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947047,
                "title": "c-modular-inverse",
                "content": "Here the problem is quite straightforward, go through the observation points for intuition.\\nObservations:\\n1) Notice our permutation depends on every word of the string i.e. string between two spaces.\\n2) Spaces doesn\\'t contribute to our final answer.\\n3) Permutation of each word is the factorial of the number of charcters in that word divided by factorial of frequency of each character.\\n\\nEample - \\n1) string - \"too hot\"\\nanswer - (3! / (1! * 2!)) * (3! / (1! * 1! * 1!)) = 18\\nExplanation - \\na) \"too\" -  its length is 3 and here frequency of o is 2 and t is 1 so its contribution in final is (3! / (1! * 2!))\\nb) \"hot\" - its length is 3 and here frequency of o is 1, h is 1 and t is 1 so its contribution in final is (3! / (1! * 1! * 1!))\\n\\n2) string - \"aa\"\\nanswer - (2! / 2!) = 1\\nExplanation - \\n\"aa\" - its length is 2 and frequency of letter 2 is 2 so its contribution in final answer is (2! / 2!).\\n\\n3) string - \"topppo hot\"\\nanswer - (6! / (1! * 2! * 3!)) * (3! / (1! * 1! * 1!)) = 360\\nExplanation - \\na) \"topppo\" -  its length is 6 and here frequency of o is 2, p is 3 and t is 1 so its contribution in final is (6! / (1! * 2! * 3!)).\\nb) \"hot\" - its length is 3 and here frequency of o is 1, h is 1 and t is 1 so its contribution in final is (3! / (1! * 1! * 1!))\\n\\nNow you can observe the pattern here.\\nIn this the most challenging part is to calculate mod of dividing the factorial as in the case of mod of dividing, doesn\\'t yield the correct answer. So to come across this, modular inverse is used which is calculated using fermats little theorem. There are many good blogs present in internet for this theorem and modulo inverse, i recommend going through them for better understanding of the solution. I have linked them down below.\\n\\nModulo-Inverse - https://cp-algorithms.com/algebra/module-inverse.html\\nCodeforces blog - https://codeforces.com/blog/entry/78873\\n\\nCode -\\n```\\nclass Solution {\\n    long long mod = 1e9 + 7;\\n    vector<long long> fact = vector<long long>(1e5 + 1);\\n    long long binpow(long long a, long long b) {\\n        long long res = 1; \\n        a = a % mod;\\n        while (b > 0) {\\n            if (b & 1) res = res * a % mod; \\n            a = a * a % mod; \\n            b >>= 1;\\n        } \\n        return res;\\n    }\\n    long long inv(long long a) {\\n        return binpow(a, mod - 2);\\n    }\\npublic:\\n    // Constructor \\n    Solution() {\\n        int maxn = 1e5;\\n        fact[0] = 1;\\n        for(long long i = 1; i <= maxn; ++i) {\\n            fact[i] = fact[i - 1] * i % mod;\\n        }\\n    }\\n    int countAnagrams(string s) {\\n        long long ans = 1;\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i) {\\n            vector<int> freq(26);\\n            int ind = i;\\n            while(ind < n && s[ind] != \\' \\') freq[s[ind++] - \\'a\\']++;\\n            int len = ind - i;\\n            long long perm = 1;\\n            for(int i = 0; i < 26; ++i) {\\n                perm = perm * inv(fact[freq[i]]) % mod;\\n            }\\n            ans = (ans * (fact[len] * perm % mod) % mod);\\n            i = ind;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTC - O(100000) ```for calculating factorial``` +  O(n * 26 * log(mod)) ```for calculating inverse of each frequency```\\nSC - O(100000) ```for storing factorial``` + O(26) ```for storing frequency```\\n\\nNote - TC can be further reduced to ->O(100000 log(mod) + O(n * 26) if we also precompute the inverse array.\\n\\n**Please upvote if it helps**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    long long mod = 1e9 + 7;\\n    vector<long long> fact = vector<long long>(1e5 + 1);\\n    long long binpow(long long a, long long b) {\\n        long long res = 1; \\n        a = a % mod;\\n        while (b > 0) {\\n            if (b & 1) res = res * a % mod; \\n            a = a * a % mod; \\n            b >>= 1;\\n        } \\n        return res;\\n    }\\n    long long inv(long long a) {\\n        return binpow(a, mod - 2);\\n    }\\npublic:\\n    // Constructor \\n    Solution() {\\n        int maxn = 1e5;\\n        fact[0] = 1;\\n        for(long long i = 1; i <= maxn; ++i) {\\n            fact[i] = fact[i - 1] * i % mod;\\n        }\\n    }\\n    int countAnagrams(string s) {\\n        long long ans = 1;\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i) {\\n            vector<int> freq(26);\\n            int ind = i;\\n            while(ind < n && s[ind] != \\' \\') freq[s[ind++] - \\'a\\']++;\\n            int len = ind - i;\\n            long long perm = 1;\\n            for(int i = 0; i < 26; ++i) {\\n                perm = perm * inv(fact[freq[i]]) % mod;\\n            }\\n            ans = (ans * (fact[len] * perm % mod) % mod);\\n            i = ind;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```for calculating factorial```\n```for calculating inverse of each frequency```\n```for storing factorial```\n```for storing frequency```",
                "codeTag": "Java"
            },
            {
                "id": 2946822,
                "title": "rust-module-division-using-fermat-s-little-theorem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) The number of ways of counstructing the solution is the multiplication of the number of ways of constructing each unique word.\\n2) Assume f_1, f_2, ,, f_k are frequencies of distinct characters in a word, where f_1 + f_2 + ... + f_k = n. The number of ways to construct different anagram words is n! / (f_1! * f_2! * .. * f_k!).\\n3) Fermat\\'s Little Theorem states: for any a < p (1000000007, which is a prime), a ^ ( p - 1) == 1 (mod p).\\n4) For any b (1 <= b <= p - 1) & a with b % a == 0, (b / a) % mod p == (b * a ^ (p - 2)) % mod p. We can use this equation to perform the division in helping getting the result from 2.          \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn count_anagrams(s: String) -> i32 {\\n        let mut mp = HashMap::<char, i32>::new();\\n        let n = s.len();\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut ret = 1;\\n        \\n        for i in 0 ..= n {\\n            if i == n || s[i] == \\' \\' {\\n                let data = mp.values().map(|a| *a).collect::<Vec<i32>>();\\n                ret = (ret * Self::calculate(&data) as i64) % 1_000_000_007;\\n                mp.clear();\\n            } else { *mp.entry(s[i]).or_insert(0) += 1; }\\n        } \\n        \\n        ret as _\\n    }\\n    \\n    fn calculate(data: &Vec<i32>) -> i32 {\\n        let n = data.iter().sum::<i32>();\\n        let mut ret = 1;\\n        for k in 2 ..= n {\\n            ret = (ret * k as i64) % 1_000_000_007;\\n        }\\n        \\n        for d in data {\\n            for k in 2 ..= *d {\\n                ret = (ret * Self::divide(k) as i64) % 1_000_000_007;\\n            }\\n        }\\n        \\n        ret as _\\n    }\\n    \\n    fn divide(a: i32) -> i32 {\\n        let (mut base, mut ret) = (a as i64, 1);\\n        let mut m = 1_000_000_005;\\n        while m > 0 {\\n            if m % 2 == 1 { ret = (ret * base) % 1_000_000_007; }\\n            m >>= 1;\\n            base = (base * base) % 1_000_000_007;\\n        }\\n        \\n        ret as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn count_anagrams(s: String) -> i32 {\\n        let mut mp = HashMap::<char, i32>::new();\\n        let n = s.len();\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut ret = 1;\\n        \\n        for i in 0 ..= n {\\n            if i == n || s[i] == \\' \\' {\\n                let data = mp.values().map(|a| *a).collect::<Vec<i32>>();\\n                ret = (ret * Self::calculate(&data) as i64) % 1_000_000_007;\\n                mp.clear();\\n            } else { *mp.entry(s[i]).or_insert(0) += 1; }\\n        } \\n        \\n        ret as _\\n    }\\n    \\n    fn calculate(data: &Vec<i32>) -> i32 {\\n        let n = data.iter().sum::<i32>();\\n        let mut ret = 1;\\n        for k in 2 ..= n {\\n            ret = (ret * k as i64) % 1_000_000_007;\\n        }\\n        \\n        for d in data {\\n            for k in 2 ..= *d {\\n                ret = (ret * Self::divide(k) as i64) % 1_000_000_007;\\n            }\\n        }\\n        \\n        ret as _\\n    }\\n    \\n    fn divide(a: i32) -> i32 {\\n        let (mut base, mut ret) = (a as i64, 1);\\n        let mut m = 1_000_000_005;\\n        while m > 0 {\\n            if m % 2 == 1 { ret = (ret * base) % 1_000_000_007; }\\n            m >>= 1;\\n            base = (base * base) % 1_000_000_007;\\n        }\\n        \\n        ret as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946681,
                "title": "python-linear-time-modular-inverse-3-liner-in-with-explanation-the-best",
                "content": "# Intuition\\nThe number of permutations of word $$w$$ with possible letter repetitions is given by $$C_w = \\\\dfrac{n_w!}{\\\\prod_{c\\\\in w} n_c!}$$, where $$n_c$$ are counts of each letter $$c \\\\in w$$. We need to compute $$\\\\prod_{w\\\\in s} C_w$$ for words $$w\\\\in s$$.\\n\\nThus, the final result is $$\\\\prod_{w\\\\in s} \\\\dfrac{n_w!}{\\\\prod_{c\\\\in w} n_c!} \\\\bmod M$$, where $$M = 10^9+7$$, a prime number.\\n\\n# Approach\\nThe result must be computed in $$\\\\mathbb{Z}_M$$. Also note that computing the full $$n! \\\\in \\\\mathbb{Z}$$ may take too long. We can therefore compute numerator and denominator parts of the result separately in $$\\\\mathbb{Z}_M$$ and then divide them in $$\\\\mathbb{Z}_M$$ by computing the modular inverse of the denominator, which is possible since $$M$$ is prime.\\n\\nThe Best!\\n\\n# Complexity\\n- Time complexity: $$O(\\\\lvert s\\\\rvert)$$\\n- Space complexity: $$O(\\\\lvert s\\\\rvert)$$ due to word splitting, can be reduced to $$O(1)$$ by manually parsing $$s$$\\n\\n# Code\\n```python\\ndef countAnagrams(self, s: str) -> int:\\n    words, M, mul, fact = s.split(), 1000000007, lambda a, b: a*b % M, lambda n: functools.reduce(mul, range(2, n+1), 1)\\n    denom = functools.reduce(mul, (fact(count) for w in words for count in collections.Counter(w).values()), 1)\\n    return mul(functools.reduce(lambda t, w: mul(t, fact(len(w))), words, 1), pow(denom, -1, M))\\n```\\n\\nFor comparison, here is a solution in imperative style:\\n```python\\ndef countAnagrams(self, s: str) -> int:\\n    def fact(n):\\n        product = 1\\n        for num in range(2, n + 1):\\n            product = (product * num) % M\\n        return product\\n\\n    M = 1000000007\\n    numerator, denominator = 1, 1\\n\\n    for word in s.split():\\n        numerator = (numerator * fact(len(word))) % M\\n        for count in collections.Counter(word).values():\\n            denominator = (denominator * fact(count)) % M\\n\\n    return (numerator * pow(denominator, -1, M)) % M\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef countAnagrams(self, s: str) -> int:\\n    words, M, mul, fact = s.split(), 1000000007, lambda a, b: a*b % M, lambda n: functools.reduce(mul, range(2, n+1), 1)\\n    denom = functools.reduce(mul, (fact(count) for w in words for count in collections.Counter(w).values()), 1)\\n    return mul(functools.reduce(lambda t, w: mul(t, fact(len(w))), words, 1), pow(denom, -1, M))\\n```\n```python\\ndef countAnagrams(self, s: str) -> int:\\n    def fact(n):\\n        product = 1\\n        for num in range(2, n + 1):\\n            product = (product * num) % M\\n        return product\\n\\n    M = 1000000007\\n    numerator, denominator = 1, 1\\n\\n    for word in s.split():\\n        numerator = (numerator * fact(len(word))) % M\\n        for count in collections.Counter(word).values():\\n            denominator = (denominator * fact(count)) % M\\n\\n    return (numerator * pow(denominator, -1, M)) % M\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2946574,
                "title": "clean-code-modulo-multiplicative-inverse-using-binary-exponentiation-easy-to-understand-c",
                "content": "# concept\\nhttps://cp-algorithms.com/algebra/module-inverse.html#finding-the-modular-inverse-for-array-of-numbers-modulo-m\\n# Code\\n```\\n#define ll long long\\n#define mod 1000000007\\nconst int N=1e5+1;\\nclass Solution {\\npublic:\\n    ll fact[N];\\n\\n    void pre(){\\n       fact[0]=1;\\n       for(int i=1;i<N;i++){\\n          fact[i]=(1ll*fact[i-1]*i)%mod;\\n       }\\n    }\\n    \\n    ll binexp(int a,int b,int m){\\n       int result=1;\\n       while(b>0){\\n          if(b&1){\\n             result=(1ll*result*a)%m;\\n          }\\n          a=(1ll*a*a)%m;\\n          b>>=1;\\n       }\\n\\n       return result;\\n    }\\n    \\n    int countAnagrams(string s) {\\n        pre();\\n        int i=0;\\n        int n=s.length();\\n        \\n        ll ans=1;\\n        while(i<n){\\n            vector<int> cnt(26,0);\\n            int count=0;\\n            ll curr;\\n            while(i<n && s[i]!=\\' \\'){\\n                count++;\\n                cnt[s[i]-\\'a\\']++;\\n                i++;\\n            }\\n            curr=fact[count];\\n            ll den=1;\\n            for(int i=0;i<26;i++) if(cnt[i]>1) den=(den*fact[cnt[i]])%mod;\\n\\n            curr=(curr*binexp(den,mod-2,mod))%mod;\\n            ans=(ans*curr)%mod;\\n            i++;\\n        }\\n        \\n        return int(ans%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n#define mod 1000000007\\nconst int N=1e5+1;\\nclass Solution {\\npublic:\\n    ll fact[N];\\n\\n    void pre(){\\n       fact[0]=1;\\n       for(int i=1;i<N;i++){\\n          fact[i]=(1ll*fact[i-1]*i)%mod;\\n       }\\n    }\\n    \\n    ll binexp(int a,int b,int m){\\n       int result=1;\\n       while(b>0){\\n          if(b&1){\\n             result=(1ll*result*a)%m;\\n          }\\n          a=(1ll*a*a)%m;\\n          b>>=1;\\n       }\\n\\n       return result;\\n    }\\n    \\n    int countAnagrams(string s) {\\n        pre();\\n        int i=0;\\n        int n=s.length();\\n        \\n        ll ans=1;\\n        while(i<n){\\n            vector<int> cnt(26,0);\\n            int count=0;\\n            ll curr;\\n            while(i<n && s[i]!=\\' \\'){\\n                count++;\\n                cnt[s[i]-\\'a\\']++;\\n                i++;\\n            }\\n            curr=fact[count];\\n            ll den=1;\\n            for(int i=0;i<26;i++) if(cnt[i]>1) den=(den*fact[cnt[i]])%mod;\\n\\n            curr=(curr*binexp(den,mod-2,mod))%mod;\\n            ans=(ans*curr)%mod;\\n            i++;\\n        }\\n        \\n        return int(ans%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946551,
                "title": "java-modulo-multiplicative-inverse-neat-and-clean-solution",
                "content": "# Intuition\\nFor each string (space seprated) find the count of unique permutation and multiply with the result.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHow to get unique permutation - \\neg - string = \"ababcb\"\\nunique permuation - 6! / (2! * 3! * 1!).\\n\\nAs max length of string is 1e5. So we can precomute the factorial from 1 to 1e5.\\n\\nNote :- when dealing with modulus in division. Use modulo multiplicative inverse technique.\\ni.e.  **a / b mod n = (a * pow(b, n -  2)) mod n**  \\n    \\n\\n# Complexity\\n- Time complexity: O(1e5 + n * log (1e9))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1e5)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int countAnagrams(String str) {\\n        \\n        Map<Integer,Long> map = new HashMap<>();\\n        int mod = 1000000000 + 7;\\n        \\n        long pro = 1;\\n        long ans = 1;\\n        \\n        for(int i = 1 ; i <= 100000 ; i++) {\\n            \\n            pro = (pro * i) % mod;\\n            \\n            map.put(i, pro);\\n        }\\n        \\n        for(String s : str.split(\" \")) {\\n            \\n            long num = map.get(s.length());\\n            long den = 1;\\n\\n            int[] freq = new int[26];\\n            \\n            for(char ch : s.toCharArray()) freq[ch - \\'a\\']++;\\n            \\n            for(int ele : freq) {\\n                \\n                if(ele != 0)\\n                \\n                den = (den * map.get(ele)) % mod;\\n            }   \\n            \\n            long curr = (num * pow(den, mod - 2)) % mod;\\n            ans = (ans * curr) % mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n    long pow(long a,long n) {\\n        \\n        int mod = 1000000000 + 7;\\n        \\n        long res = 1;\\n        \\n        while(n > 0) {\\n            \\n            if(n % 2 == 1) {\\n                \\n                res = (res * a) % mod;\\n                n--;\\n            }\\n            else {\\n                \\n                a = (a * a) % mod;\\n                n = n / 2;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAnagrams(String str) {\\n        \\n        Map<Integer,Long> map = new HashMap<>();\\n        int mod = 1000000000 + 7;\\n        \\n        long pro = 1;\\n        long ans = 1;\\n        \\n        for(int i = 1 ; i <= 100000 ; i++) {\\n            \\n            pro = (pro * i) % mod;\\n            \\n            map.put(i, pro);\\n        }\\n        \\n        for(String s : str.split(\" \")) {\\n            \\n            long num = map.get(s.length());\\n            long den = 1;\\n\\n            int[] freq = new int[26];\\n            \\n            for(char ch : s.toCharArray()) freq[ch - \\'a\\']++;\\n            \\n            for(int ele : freq) {\\n                \\n                if(ele != 0)\\n                \\n                den = (den * map.get(ele)) % mod;\\n            }   \\n            \\n            long curr = (num * pow(den, mod - 2)) % mod;\\n            ans = (ans * curr) % mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n    long pow(long a,long n) {\\n        \\n        int mod = 1000000000 + 7;\\n        \\n        long res = 1;\\n        \\n        while(n > 0) {\\n            \\n            if(n % 2 == 1) {\\n                \\n                res = (res * a) % mod;\\n                n--;\\n            }\\n            else {\\n                \\n                a = (a * a) % mod;\\n                n = n / 2;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033701,
                "title": "c-one-pass-o-n-strict-forward-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    private Dictionary<char, (long f, int c)> reps = new();\\n    private int modulo = ((int)Math.Pow(10, 9) + 7);\\n\\n    public int CountAnagrams(string s) {\\n        \\n        s = s + \\' \\'; \\n        var sz = s.Length;\\n        var j = -1;\\n        long factorial = 1;\\n        long result = 1;\\n        long denominator = 1;\\n\\n        for(int i = 0; i < sz; i++)\\n        {            \\n            if(s[i] is \\' \\')\\n            {\\n                j = i;\\n                result = (result * factorial) % modulo;\\n                foreach(var k in reps.Keys)\\n                {\\n                    if(reps[k].c > 1) denominator = (denominator * reps[k].f) % modulo;\\n                }\\n                factorial = 1;\\n                reps = new Dictionary<char, (long f, int c)>();\\n            }\\n            else\\n            {\\n                factorial = (factorial * (i - j)) % modulo;\\n                if(!reps.TryAdd(s[i], (1, 1)))\\n                {\\n                    var next = (reps[s[i]].f, reps[s[i]].c + 1);\\n                    next = ((reps[s[i]].f * next.Item2) % modulo, next.Item2);\\n                    reps[s[i]] = next;\\n                }\\n            }\\n        }\\n\\n        //compute fermat modular inverse of denominator \\n        long exp = Expentiation(denominator, modulo - 2, modulo);\\n\\n        result = (result * exp) % modulo;\\n\\n        return (int)(result % modulo);\\n    }\\n\\n    //Some math thing I don\\'t what the hell is\\n    public long Expentiation(long @base, int exp, int m)\\n    {\\n        long result = 1;\\n        while (exp > 0)\\n        {\\n           if ((exp & 1) > 0) result = (result * @base) % m;\\n            exp >>= 1;\\n            @base = (@base * @base) % m;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n//457992974\\n\\n// \"too hot\"\\n// \"oooooo\"\\n// \"the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmqokzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq\"\\n// \"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"\\n// \"okzojaporykbmqokzojaporykbmq\"\\n// \"smuiquglfwdepzuyqtgujaisius\"\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private Dictionary<char, (long f, int c)> reps = new();\\n    private int modulo = ((int)Math.Pow(10, 9) + 7);\\n\\n    public int CountAnagrams(string s) {\\n        \\n        s = s + \\' \\'; \\n        var sz = s.Length;\\n        var j = -1;\\n        long factorial = 1;\\n        long result = 1;\\n        long denominator = 1;\\n\\n        for(int i = 0; i < sz; i++)\\n        {            \\n            if(s[i] is \\' \\')\\n            {\\n                j = i;\\n                result = (result * factorial) % modulo;\\n                foreach(var k in reps.Keys)\\n                {\\n                    if(reps[k].c > 1) denominator = (denominator * reps[k].f) % modulo;\\n                }\\n                factorial = 1;\\n                reps = new Dictionary<char, (long f, int c)>();\\n            }\\n            else\\n            {\\n                factorial = (factorial * (i - j)) % modulo;\\n                if(!reps.TryAdd(s[i], (1, 1)))\\n                {\\n                    var next = (reps[s[i]].f, reps[s[i]].c + 1);\\n                    next = ((reps[s[i]].f * next.Item2) % modulo, next.Item2);\\n                    reps[s[i]] = next;\\n                }\\n            }\\n        }\\n\\n        //compute fermat modular inverse of denominator \\n        long exp = Expentiation(denominator, modulo - 2, modulo);\\n\\n        result = (result * exp) % modulo;\\n\\n        return (int)(result % modulo);\\n    }\\n\\n    //Some math thing I don\\'t what the hell is\\n    public long Expentiation(long @base, int exp, int m)\\n    {\\n        long result = 1;\\n        while (exp > 0)\\n        {\\n           if ((exp & 1) > 0) result = (result * @base) % m;\\n            exp >>= 1;\\n            @base = (@base * @base) % m;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n//457992974\\n\\n// \"too hot\"\\n// \"oooooo\"\\n// \"the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmqokzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq the cheese is too cheesy okzojaporykbmq\"\\n// \"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"\\n// \"okzojaporykbmqokzojaporykbmq\"\\n// \"smuiquglfwdepzuyqtgujaisius\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008958,
                "title": "python-one-liner",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe calculate permutations for every word `w` in string `s` and multiply them. \\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s, m=10**9+7, f=factorial, c=Counter, p=prod):\\n        return p(f(len(w))//p(f(i) for i in c(w).values()) for w in s.split()) % m\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s, m=10**9+7, f=factorial, c=Counter, p=prod):\\n        return p(f(len(w))//p(f(i) for i in c(w).values()) for w in s.split()) % m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930172,
                "title": "c-solution-beats-81-runtime",
                "content": "# Intuition\\n- Fermat\\'s little theorem needs to be used otherwise there will be overflow even in long\\n\\n# Approach\\nBinary exponentiation is the best we can do. Although the time complexity will not change -i.e., O(nlogMod)= O(n) and O(n*Mod)= O(n). But, it is an optimisation in this solution.\\n\\n# Complexity\\n- Time complexity: O(n) -> Where n is length of string\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    long long mod=pow(10,9)+7;\\n    long factorial(int a){\\n        if(a<2)\\n            return 1;\\n        long long ans=1;\\n        for(long long i=2;i<=a;i++)\\n            ans=(ans*i)%mod;\\n        return ans;\\n    }\\n    long binaryExponent(long a, long pow){\\n        long long ans=1;\\n        while(pow>0){\\n            if(pow&1){\\n                pow--;\\n                ans=(ans*a)%mod;\\n            }\\n            else{\\n                pow/=2;\\n                a=(a*a)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n    long inverseMod(long a){\\n        return binaryExponent(a,mod-2);\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        istringstream ss(s);\\n        string word; long ans=1;\\n        while(ss>>word){\\n            vector<int>count(26,0);long denominator=1,wordPermutations;\\n            long numerator=factorial(word.size());\\n            for(auto&i:word)\\n                count[i-\\'a\\']++;\\n            for(int i=0;i<26;i++)\\n                denominator=(denominator*factorial(count[i]))%mod;\\n            wordPermutations=(numerator * inverseMod(denominator))%mod;\\n            ans= (ans*wordPermutations)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long long mod=pow(10,9)+7;\\n    long factorial(int a){\\n        if(a<2)\\n            return 1;\\n        long long ans=1;\\n        for(long long i=2;i<=a;i++)\\n            ans=(ans*i)%mod;\\n        return ans;\\n    }\\n    long binaryExponent(long a, long pow){\\n        long long ans=1;\\n        while(pow>0){\\n            if(pow&1){\\n                pow--;\\n                ans=(ans*a)%mod;\\n            }\\n            else{\\n                pow/=2;\\n                a=(a*a)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n    long inverseMod(long a){\\n        return binaryExponent(a,mod-2);\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        istringstream ss(s);\\n        string word; long ans=1;\\n        while(ss>>word){\\n            vector<int>count(26,0);long denominator=1,wordPermutations;\\n            long numerator=factorial(word.size());\\n            for(auto&i:word)\\n                count[i-\\'a\\']++;\\n            for(int i=0;i<26;i++)\\n                denominator=(denominator*factorial(count[i]))%mod;\\n            wordPermutations=(numerator * inverseMod(denominator))%mod;\\n            ans= (ans*wordPermutations)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915683,
                "title": "python-one-line-solution-beats-58",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a purely mathematical question that requires knowledge of Factorials and permutations with repetition.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        return math.prod([math.factorial(len(t))//math.prod([math.factorial(num) for num in collections.Counter(t).values()]) for t in s.split()]) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        return math.prod([math.factorial(len(t))//math.prod([math.factorial(num) for num in collections.Counter(t).values()]) for t in s.split()]) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857555,
                "title": "python3-permutations-with-repetition",
                "content": "Hint: use \\'permutations with repetitions\\' formula\\nhttps://brilliant.org/wiki/permutations-with-repetition/\\n```\\nimport math\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        def perm_num(word):\\n            c = Counter(word)\\n            n = len(word)\\n\\n            f = math.factorial(n)\\n            for k in c:\\n                f = f // math.factorial(c[k])\\n            return f % 1000000007\\n\\n        a = 1\\n        words = s.split()\\n        for word in words:\\n            a = a * perm_num(word) % 1000000007\\n        \\n        return a\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        def perm_num(word):\\n            c = Counter(word)\\n            n = len(word)\\n\\n            f = math.factorial(n)\\n            for k in c:\\n                f = f // math.factorial(c[k])\\n            return f % 1000000007\\n\\n        a = 1\\n        words = s.split()\\n        for word in words:\\n            a = a * perm_num(word) % 1000000007\\n        \\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818842,
                "title": "my-python-solution-with-detailed-explanation-even-beginners-will-get-it",
                "content": "Okay, first let\\'s have a look at code and then I will provide explanation for it.\\nPlease upvote if you liked my solution!\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        permutations = 1\\n        words = [word for word in s.split(\\' \\')]\\n        for el in words:\\n            permutations *= factorial(len(el))\\n            occurrences = {}\\n            for symbol in el:\\n                if symbol not in occurrences:\\n                    occurrences[symbol] = factorial(el.count(symbol)) \\n            for value in occurrences.values():\\n                permutations *= pow(value,-1,10**9+7)\\n        return int(permutations % (10**9+7))\\n``` \\n# Intuition (with some lyrical digression)\\nWell, when I read the task I already knew that we have to find out count of permutations for all the words in string, and then simply multiply them all. But problems began when I realized there may be repetitive letters in words. Thanks to my \"Probability Theory\" and \"Combinatorics\" university courses, I quickly restored formula for permutations with repetitions based on some simple example. Let\\'s have a look at it \\n# The only formula you need (with example)\\nLet input be s = \"abbccc\". It has only one word in it. How many permutations will be there? You see letter \\'c\\' appears 3 times, which means that **no matter if we change order of letters inside \"ccc\" part, word remains the same**.\\nLet all of c\\'s be marked as 1,2,3. Permutations for \"ccc\" (1,2,3):\\n123, 132, 213, 231, 312, 321. \\n**If we think of all c\\'s like distinct letters**, there will be **$$P(n) = n!$$** permutations for them, where n is count of occurrences of \\'c\\' in our word.\\nSame thing for letter \\'b\\'. Count of permutations for \"bb\", if they\\'re marked as 1,2 = $$P(2) = 2! = 2$$. Here they are: 12, 21.\\nBut, like I said before, **no matter if we change order of letters inside \"ccc\" part (or \"bb\" part), word remains the same**. So we **don\\'t have to put them in the final answer**\\n\\n---\\n**General formula for one word**:\\nCount of permutations for one word = $$P(word) = \\\\frac{P(n)}{P(n_1) * P(n_2) * ... * P(n_k)}$$, where\\n$$n$$ - length of word\\n$$n_1, n_2, ..., n_k$$ - count of occurrences of each letter in word\\n\\n---\\n\\n\\nSo, for our example:\\nlength of word = 6\\n\\'a\\' appears 1 time\\n\\'b\\' appears 2 times\\n\\'c\\' appears 3 times\\ncount of permutations in \"abbccc\" = \\n$$P(\"abbccc\") = \\\\frac{P(6)}{P(1) * P(2) * P(3)} = \\\\frac{6!}{1! * 2! * 3!} = \\\\frac{720}{1 * 2 * 6} = \\\\frac{720}{12} = 60$$\\n\\n---\\n\\n# Explanation of code\\n```\\ndef countAnagrams(self, s: str) -> int:\\n        permutations = 1\\n        words = [word for word in s.split(\\' \\')]\\n        for el in words:\\n            permutations *= factorial(len(el))\\n            occurrences = {}\\n            for symbol in el:\\n                if symbol not in occurrences:\\n                    occurrences[symbol] = factorial(el.count(symbol)) \\n            for value in occurrences.values():\\n                permutations *= pow(value,-1,10**9+7)\\n        return int(permutations % (10**9+7))\\n```\\nIn this function:\\n*permutation*s - variable we will return, count of all the anagrams\\n*words* - list consists of words in input string \\n*occurrences* - hash table for storing count of occurrences of each letter in one word\\nSo\\n1) we go through each word in string\\n2) count factorial of word length and update *permutations*\\n```\\nfor el in words:\\n    permutations *= factorial(len(el))\\n```\\n3) count occurrenes of each symbol in word, count factorial of each of these values and store them in hash table *occurrences* \\n```\\nfor el in words:\\n    permutations *= factorial(len(el))\\n    occurrences = {}\\n    for symbol in el:\\n        if symbol not in occurrences:\\n            occurrences[symbol] = factorial(el.count(symbol)) \\n```\\n4) update *permutations* by dividing it by every value stored in *occurrences* using pow() function. Don\\'t forget to also divide it by 10^9+7\\n5) return result as `int(permutations % (10**9+7))`\\n```\\nfor el in words:\\n    permutations *= factorial(len(el))\\n    occurrences = {}\\n    for symbol in el:\\n        if symbol not in occurrences:\\n            occurrences[symbol] = factorial(el.count(symbol)) \\n    for value in occurrences.values():\\n        permutations *= pow(value,-1,10**9+7)\\nreturn int(permutations % (10**9+7))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        permutations = 1\\n        words = [word for word in s.split(\\' \\')]\\n        for el in words:\\n            permutations *= factorial(len(el))\\n            occurrences = {}\\n            for symbol in el:\\n                if symbol not in occurrences:\\n                    occurrences[symbol] = factorial(el.count(symbol)) \\n            for value in occurrences.values():\\n                permutations *= pow(value,-1,10**9+7)\\n        return int(permutations % (10**9+7))\\n```\n```\\ndef countAnagrams(self, s: str) -> int:\\n        permutations = 1\\n        words = [word for word in s.split(\\' \\')]\\n        for el in words:\\n            permutations *= factorial(len(el))\\n            occurrences = {}\\n            for symbol in el:\\n                if symbol not in occurrences:\\n                    occurrences[symbol] = factorial(el.count(symbol)) \\n            for value in occurrences.values():\\n                permutations *= pow(value,-1,10**9+7)\\n        return int(permutations % (10**9+7))\\n```\n```\\nfor el in words:\\n    permutations *= factorial(len(el))\\n```\n```\\nfor el in words:\\n    permutations *= factorial(len(el))\\n    occurrences = {}\\n    for symbol in el:\\n        if symbol not in occurrences:\\n            occurrences[symbol] = factorial(el.count(symbol)) \\n```\n```\\nfor el in words:\\n    permutations *= factorial(len(el))\\n    occurrences = {}\\n    for symbol in el:\\n        if symbol not in occurrences:\\n            occurrences[symbol] = factorial(el.count(symbol)) \\n    for value in occurrences.values():\\n        permutations *= pow(value,-1,10**9+7)\\nreturn int(permutations % (10**9+7))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798176,
                "title": "c-modular-multiplicative-inverse-factorial-pre-compute",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   const int N=1e5+1,mod=1e9+7;\\n     vector<int>fact;\\n    long long modInv(int x,int y)\\n    {\\n        long long ans=1;\\n        x=x%mod;\\n\\n        while(y)\\n        {\\n            if(y&1)\\n            {\\n                ans=(ans*1LL*x)%mod;\\n\\n            }\\n            y=y>>1;\\n\\n            x=(x*1LL*x)%mod;\\n\\n        }\\n        return ans;\\n\\n    }\\n \\n\\n    void init()\\n    {\\n       \\n            fact.resize(N,0);\\n\\n        fact[0]=1;\\n\\n        for(int i=1;i<N;i++)\\n        {\\n            fact[i]=(i*1LL*fact[i-1])%mod;\\n\\n        }\\n    }\\n    int countAnagrams(string s) {\\n        //thought approach beautifully kudos\\n        init();\\n\\n        stringstream ss(s);\\n\\n        string word;\\n        map<string,int>mp;\\n        while(ss>> word)\\n        {\\n            mp[word]++;\\n        }\\n\\n        long long finalAns=1;\\n        for(auto it:mp)\\n        {\\n            string str=it.first;\\n            map<char,int>mp1;\\n            for(auto c:str)\\n            {\\n                mp1[c]++;\\n\\n            }\\n            long long res=1;\\n\\n            for(auto i:mp1)\\n            {\\n\\n                res=(res*1LL*modInv(fact[i.second],mod-2))%mod;\\n            }\\n\\n            res=res*1LL*fact[str.length()];\\n            res=res%mod;\\n            finalAns=(finalAns*res)%mod;\\n\\n              }\\n\\n            return finalAns;\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   const int N=1e5+1,mod=1e9+7;\\n     vector<int>fact;\\n    long long modInv(int x,int y)\\n    {\\n        long long ans=1;\\n        x=x%mod;\\n\\n        while(y)\\n        {\\n            if(y&1)\\n            {\\n                ans=(ans*1LL*x)%mod;\\n\\n            }\\n            y=y>>1;\\n\\n            x=(x*1LL*x)%mod;\\n\\n        }\\n        return ans;\\n\\n    }\\n \\n\\n    void init()\\n    {\\n       \\n            fact.resize(N,0);\\n\\n        fact[0]=1;\\n\\n        for(int i=1;i<N;i++)\\n        {\\n            fact[i]=(i*1LL*fact[i-1])%mod;\\n\\n        }\\n    }\\n    int countAnagrams(string s) {\\n        //thought approach beautifully kudos\\n        init();\\n\\n        stringstream ss(s);\\n\\n        string word;\\n        map<string,int>mp;\\n        while(ss>> word)\\n        {\\n            mp[word]++;\\n        }\\n\\n        long long finalAns=1;\\n        for(auto it:mp)\\n        {\\n            string str=it.first;\\n            map<char,int>mp1;\\n            for(auto c:str)\\n            {\\n                mp1[c]++;\\n\\n            }\\n            long long res=1;\\n\\n            for(auto i:mp1)\\n            {\\n\\n                res=(res*1LL*modInv(fact[i.second],mod-2))%mod;\\n            }\\n\\n            res=res*1LL*fact[str.length()];\\n            res=res%mod;\\n            finalAns=(finalAns*res)%mod;\\n\\n              }\\n\\n            return finalAns;\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711497,
                "title": "rust-solution-super-fast-25ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n![\\u56FE\\u7247.png](https://assets.leetcode.com/users/images/6a3131e3-97c8-4407-b43b-c83920ae2d4a_1688367447.719401.png)\\n\\n\\n\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nconst MOD: i64 = 1000_000_007;\\nfn powmod(a: i64, mut b: i64) -> i64 {\\n    let mut res = 1;\\n    let mut c = a;\\n    while b != 0 {\\n        if b & 1 == 1 {\\n            res = res * c % MOD;\\n        }\\n        c = c * c % MOD;\\n        b >>= 1;\\n    }\\n    res\\n}\\nimpl Solution {\\n    pub fn count_anagrams(s: String) -> i32 {\\n        let mut a = 1i64;\\n        let mut b = 1i64;\\n        for word in s.split(\\' \\') {\\n            let mut t = HashMap::new();\\n            for (i, ch) in word.chars().enumerate() {\\n                a *= (i + 1) as i64;\\n                a %= MOD;\\n                *t.entry(ch).or_insert(0) += 1;\\n                b *= t.get(&ch).unwrap();\\n                b %= MOD;\\n            }\\n        }\\n        (a * powmod(b, MOD - 2) % MOD) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nconst MOD: i64 = 1000_000_007;\\nfn powmod(a: i64, mut b: i64) -> i64 {\\n    let mut res = 1;\\n    let mut c = a;\\n    while b != 0 {\\n        if b & 1 == 1 {\\n            res = res * c % MOD;\\n        }\\n        c = c * c % MOD;\\n        b >>= 1;\\n    }\\n    res\\n}\\nimpl Solution {\\n    pub fn count_anagrams(s: String) -> i32 {\\n        let mut a = 1i64;\\n        let mut b = 1i64;\\n        for word in s.split(\\' \\') {\\n            let mut t = HashMap::new();\\n            for (i, ch) in word.chars().enumerate() {\\n                a *= (i + 1) as i64;\\n                a %= MOD;\\n                *t.entry(ch).or_insert(0) += 1;\\n                b *= t.get(&ch).unwrap();\\n                b %= MOD;\\n            }\\n        }\\n        (a * powmod(b, MOD - 2) % MOD) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3690630,
                "title": "python3-dictionary-combinatorics",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> For a single word, we can find the total number of anagrams with a combinatorial approach. If a word of length n doesn\\'t have repeated letters, it is n!. If there are repeated letters, we have to divide it by (number of times each letter is repeated)!.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Define a function which gets the total number of anagrams for a single word. Final result is simply the product of number for each word.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 10**9 + 7\\n        def numberAnagram(word):\\n            d = Counter(word)\\n            res = factorial(len(word))\\n            div = 1\\n            for i in d.values():\\n                div *= factorial(i)\\n            res = res // div\\n            return int(res)\\n        out = 1\\n        for i in s.split():\\n            out *= numberAnagram(i) \\n            # out %= mod\\n\\n        return int(out) % mod\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 10**9 + 7\\n        def numberAnagram(word):\\n            d = Counter(word)\\n            res = factorial(len(word))\\n            div = 1\\n            for i in d.values():\\n                div *= factorial(i)\\n            res = res // div\\n            return int(res)\\n        out = 1\\n        for i in s.split():\\n            out *= numberAnagram(i) \\n            # out %= mod\\n\\n        return int(out) % mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686963,
                "title": "mathy-ruby-solution-with-explanation-100-100",
                "content": "# Intuition\\nFind the number of ways to arrange the letters in each word and multiply these all together to get the total number of anagrams.\\n\\n# Approach\\n0. Set a mod class variable.  (We use this in the main function and helper function to reduce memory usage.)\\n\\n1. Split the string into words.\\n2. Find the number of anagrams for each word with a helper function and multiply by total.\\n3. Return the total after using modulo.\\n\\nMain helper function:\\n1. Split the word into letters and count how frequent each is.\\n2. Make an array just of the frequencies of different letters.  (It doesn\\'t matter which letter each frequency corresponds to.)  Sort this array so we know the most common frequency.\\n\\nIf there were no repeats, we\\'d use a simple factorial to find the number of unique ways to arrange these letters.  With repeats, we have to divide by different factorials for the frequency of each letter.  (For example, there are 6! ways to arrange \\'abcdef\\'.  For \\'aaabbc\\', we do 6! but divide by the 3! ways to arrange the \\'a\\'s (because they for the same word) and the 2! ways to arrange the \\'b\\'s.)\\n\\nBecause factorials are computation intensive, we choose the largest frequency and avoid multiplying and dividing by those numbers.  (For example, if we have 26 letters and one appears 10 times, we can just multiply the numbers 11-26 instead of multiplying 1-26 and dividing by 1-10.)\\n3. Pop off the highest frequency and multiply all the numbers after that up to the length of word for total.\\n4. Now divide by the factorial of each frequency to deal with other repeat letters.\\n5. Return the mod of the total.\\n\\nSecond helper function:\\nFactorials just multiply all the numbers up to n together:\\n1. Start total at 1.\\n2. Multiply by each number up to n.  (No need to multiply by 1.)\\n3. Return the number.  (Note that we can\\'t do modulo here because we\\'re going to be dividing by these numbers in the main helper function, not just multiplying.)\\n\\n# Complexity\\n- Time complexity:\\nNot sure, but I think $$O(m * n)$$, where *m* in the number of words and *n* is the length of each word.  (In other words, the length of the original string.)  We\\'re sorting frequencies, but that will be limited to the number of distinct letters, which can\\'t exceed 26.  Multiplyi ng to make very large numbers might make this a little worse, though.\\n\\n- Space complexity:\\n$$O(n)$$, where *n* is the length of the string.\\n\\n# Code\\n```\\n@mod = 1000000007\\n\\ndef count_anagrams(s)\\n    words = s.split(\\' \\')\\n    total = 1\\n    words.each { |word| total *= num_agrams(word) }\\n    total % @mod\\nend\\n\\ndef num_agrams(word)\\n    letters = word.split(\\'\\')\\n    count = letters.tally\\n    freqs = count.values.sort\\n    total = 1\\n    ((freqs.pop+1)..word.length).each { |i| total *= i }\\n    freqs.each { |i| total /= factorial(i) }\\n    total % @mod\\nend\\n\\ndef factorial(n)\\n    total = 1\\n    (2..n).each { |i| total = total * i }\\n    total\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n@mod = 1000000007\\n\\ndef count_anagrams(s)\\n    words = s.split(\\' \\')\\n    total = 1\\n    words.each { |word| total *= num_agrams(word) }\\n    total % @mod\\nend\\n\\ndef num_agrams(word)\\n    letters = word.split(\\'\\')\\n    count = letters.tally\\n    freqs = count.values.sort\\n    total = 1\\n    ((freqs.pop+1)..word.length).each { |i| total *= i }\\n    freqs.each { |i| total /= factorial(i) }\\n    total % @mod\\nend\\n\\ndef factorial(n)\\n    total = 1\\n    (2..n).each { |i| total = total * i }\\n    total\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3682663,
                "title": "java-c-python-math-image-explanation-90-faster-with-explanation",
                "content": "\\n**Logic Behind Code**\\n\\n\\tLet suppose we have N number of entities in which m are of A type and n are of B type ,\\n\\tthen total number of their permutations possible would simply be (m+n)!/(m)!*(n)! , N= m+n.\\n\\nConclusion of above statement is that total permutation of N things in which p1 are of type 1, p2 of type 2 ... pn of type n would be\\n(p1+p2+p3+....pn)! /  [ (p1)! * (p2)! *  .... *(pn)!  ]\\nor\\n(N)! /[ (p1)! * (p2)! *  .... *(pn)!  ]..\\n\\nNow , do the same for each string then to find the total number of permutations u have to multiply the individual string.\\n\\n![image](https://assets.leetcode.com/users/images/f901c8df-c09e-415a-8a5e-e636024b0830_1687724307.3203788.jpeg)\\n\\n\\n**Explanation**\\n\\nInitialize a hashmap to store the frequency of each character encountered.\\nIterate through each character in the string.\\nIf the character is a space or the last character:\\nCalculate the product of factorials of frequencies of characters in the current segment.\\nUpdate the answer by multiplying it with the factorial of the total characters in the segment and dividing it by the factorial of the frequencies.\\nReset the frequency map and total characters for the next segment.\\nIf the character is not a space, update the frequency map and increment the count of total characters.\\nReturn the answer modulo 1e9 + 7 to ensure the result is within the required range.\\n\\n\\n\\n**C++ CODE**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countAnagrams(string s) {\\n        const int mod = 1e9 + 7;\\n        long long ans = 1;\\n        int n = s.length();\\n        int totalChars = 0;\\n        unordered_map<char, int> freqMap;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\' \\' || i == n - 1) {\\n                if (i == n - 1) {\\n                    freqMap[s[i]]++;\\n                    totalChars++;\\n                }\\n\\n                long long t = 1;\\n                for (auto x : freqMap) {\\n                    t = (t * factorial(x.second, mod)) % mod;\\n                }\\n                ans = (ans * factorial(totalChars, mod)) % mod;\\n                ans = (ans * modularInverse(t, mod)) % mod;\\n\\n                totalChars = 0;\\n                freqMap.clear();\\n            } else {\\n                freqMap[s[i]]++;\\n                totalChars++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    int factorial(int n, int mod) {\\n        long long fact = 1;\\n        for (int i = 2; i <= n; i++) {\\n            fact = (fact * i) % mod;\\n        }\\n        return fact;\\n    }\\n\\n    int modularInverse(long long int a, int mod) {\\n        int b = mod - 2;\\n        int result = 1;\\n\\n        while (b > 0) {\\n            if (b & 1) {\\n                result = (result * a) % mod;\\n            }\\n            a = (a * a) % mod;\\n            b >>= 1;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\\n\\n\\n**Python Code**\\n\\n\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 10**9 + 7\\n        ans = 1\\n        n = len(s)\\n        totalChars = 0\\n        freqMap = {}\\n\\n        for i in range(n):\\n            if s[i] == \\' \\' or i == n - 1:\\n                if i == n - 1:\\n                    freqMap[s[i]] = freqMap.get(s[i], 0) + 1\\n                    totalChars += 1\\n\\n                t = 1\\n                for freq in freqMap.values():\\n                    t = (t * self.factorial(freq, mod)) % mod\\n\\n                ans = (ans * self.factorial(totalChars, mod)) % mod\\n                ans = (ans * self.modularInverse(t, mod)) % mod\\n\\n                totalChars = 0\\n                freqMap = {}\\n            else:\\n                freqMap[s[i]] = freqMap.get(s[i], 0) + 1\\n                totalChars += 1\\n\\n        return ans\\n\\n    def factorial(self, n: int, mod: int) -> int:\\n        fact = 1\\n        for i in range(2, n+1):\\n            fact = (fact * i) % mod\\n        return fact\\n\\n    def modularInverse(self, a: int, mod: int) -> int:\\n        b = mod - 2\\n        result = 1\\n\\n        while b > 0:\\n            if b & 1:\\n                result = (result * a) % mod\\n            a = (a * a) % mod\\n            b >>= 1\\n\\n        return result\\n\\n```\\n\\n\\n\\n**Java Code**\\n\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int countAnagrams(String s) {\\n        final int mod = (int) 1e9 + 7;\\n        long ans = 1;\\n        int n = s.length();\\n        int totalChars = 0;\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\' \\' || i == n - 1) {\\n                if (i == n - 1) {\\n                    freqMap.put(s.charAt(i), freqMap.getOrDefault(s.charAt(i), 0) + 1);\\n                    totalChars++;\\n                }\\n\\n                long t = 1;\\n                for (int freq : freqMap.values()) {\\n                    t = (t * factorial(freq, mod)) % mod;\\n                }\\n\\n                ans = (ans * factorial(totalChars, mod)) % mod;\\n                ans = (ans * modularInverse(t, mod)) % mod;\\n\\n                totalChars = 0;\\n                freqMap.clear();\\n            } else {\\n                freqMap.put(s.charAt(i), freqMap.getOrDefault(s.charAt(i), 0) + 1);\\n                totalChars++;\\n            }\\n        }\\n\\n        return (int) ans;\\n    }\\n\\n    private int factorial(int n, int mod) {\\n        long fact = 1;\\n        for (int i = 2; i <= n; i++) {\\n            fact = (fact * i) % mod;\\n        }\\n        return (int) fact;\\n    }\\n\\n    private int modularInverse(long a, int mod) {\\n        int b = mod - 2;\\n        int result = 1;\\n\\n        while (b > 0) {\\n            if ((b & 1) == 1) {\\n                result = (int) ((result * a) % mod);\\n            }\\n            a = (a * a) % mod;\\n            b >>= 1;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\\n\\nHope u liked it !!",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAnagrams(string s) {\\n        const int mod = 1e9 + 7;\\n        long long ans = 1;\\n        int n = s.length();\\n        int totalChars = 0;\\n        unordered_map<char, int> freqMap;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\' \\' || i == n - 1) {\\n                if (i == n - 1) {\\n                    freqMap[s[i]]++;\\n                    totalChars++;\\n                }\\n\\n                long long t = 1;\\n                for (auto x : freqMap) {\\n                    t = (t * factorial(x.second, mod)) % mod;\\n                }\\n                ans = (ans * factorial(totalChars, mod)) % mod;\\n                ans = (ans * modularInverse(t, mod)) % mod;\\n\\n                totalChars = 0;\\n                freqMap.clear();\\n            } else {\\n                freqMap[s[i]]++;\\n                totalChars++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    int factorial(int n, int mod) {\\n        long long fact = 1;\\n        for (int i = 2; i <= n; i++) {\\n            fact = (fact * i) % mod;\\n        }\\n        return fact;\\n    }\\n\\n    int modularInverse(long long int a, int mod) {\\n        int b = mod - 2;\\n        int result = 1;\\n\\n        while (b > 0) {\\n            if (b & 1) {\\n                result = (result * a) % mod;\\n            }\\n            a = (a * a) % mod;\\n            b >>= 1;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 10**9 + 7\\n        ans = 1\\n        n = len(s)\\n        totalChars = 0\\n        freqMap = {}\\n\\n        for i in range(n):\\n            if s[i] == \\' \\' or i == n - 1:\\n                if i == n - 1:\\n                    freqMap[s[i]] = freqMap.get(s[i], 0) + 1\\n                    totalChars += 1\\n\\n                t = 1\\n                for freq in freqMap.values():\\n                    t = (t * self.factorial(freq, mod)) % mod\\n\\n                ans = (ans * self.factorial(totalChars, mod)) % mod\\n                ans = (ans * self.modularInverse(t, mod)) % mod\\n\\n                totalChars = 0\\n                freqMap = {}\\n            else:\\n                freqMap[s[i]] = freqMap.get(s[i], 0) + 1\\n                totalChars += 1\\n\\n        return ans\\n\\n    def factorial(self, n: int, mod: int) -> int:\\n        fact = 1\\n        for i in range(2, n+1):\\n            fact = (fact * i) % mod\\n        return fact\\n\\n    def modularInverse(self, a: int, mod: int) -> int:\\n        b = mod - 2\\n        result = 1\\n\\n        while b > 0:\\n            if b & 1:\\n                result = (result * a) % mod\\n            a = (a * a) % mod\\n            b >>= 1\\n\\n        return result\\n\\n```\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int countAnagrams(String s) {\\n        final int mod = (int) 1e9 + 7;\\n        long ans = 1;\\n        int n = s.length();\\n        int totalChars = 0;\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\' \\' || i == n - 1) {\\n                if (i == n - 1) {\\n                    freqMap.put(s.charAt(i), freqMap.getOrDefault(s.charAt(i), 0) + 1);\\n                    totalChars++;\\n                }\\n\\n                long t = 1;\\n                for (int freq : freqMap.values()) {\\n                    t = (t * factorial(freq, mod)) % mod;\\n                }\\n\\n                ans = (ans * factorial(totalChars, mod)) % mod;\\n                ans = (ans * modularInverse(t, mod)) % mod;\\n\\n                totalChars = 0;\\n                freqMap.clear();\\n            } else {\\n                freqMap.put(s.charAt(i), freqMap.getOrDefault(s.charAt(i), 0) + 1);\\n                totalChars++;\\n            }\\n        }\\n\\n        return (int) ans;\\n    }\\n\\n    private int factorial(int n, int mod) {\\n        long fact = 1;\\n        for (int i = 2; i <= n; i++) {\\n            fact = (fact * i) % mod;\\n        }\\n        return (int) fact;\\n    }\\n\\n    private int modularInverse(long a, int mod) {\\n        int b = mod - 2;\\n        int result = 1;\\n\\n        while (b > 0) {\\n            if ((b & 1) == 1) {\\n                result = (int) ((result * a) % mod);\\n            }\\n            a = (a * a) % mod;\\n            b >>= 1;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670085,
                "title": "the-competitive-programming-solution",
                "content": "# Intuition\\nIdea is same as you\\'ve probably thought of yourself. This is the CP implementation of the idea:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long power(long long x,long long y, int p=1000000007)\\n{\\n    long long res = 1; \\n \\n    x = x % p;\\n \\n    while (y > 0)\\n    {\\n     \\n        if (y & 1)\\n            res = (res * x) % p;\\n \\n        y = y >> 1;\\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\n \\nlong long modInverse(int n, int p=1000000007)\\n{\\n    return power(n, p - 2, p);\\n}\\n \\n\\nunsigned long long nCr(int n, int r, int p=1000000007)\\n{\\n    if (n < r)\\n        return 0;\\n    if (r == 0)\\n        return 1;\\n\\n    long long fac[n + 1];\\n    fac[0] = 1;\\n    for (int i = 1; i <= n; i++)\\n        fac[i] = (fac[i - 1] * i) % p;\\n \\n    return (fac[n] * modInverse(fac[r], p) % p* modInverse(fac[n - r], p) % p)% p;\\n}\\n    int countAnagrams(string s) {\\n        int count=0;\\n        unordered_map<char,int> m;\\n        long long sum = 1;\\n        for(int i = 0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                for(int j = 0; j<26; j++){\\n                    if(m[\\'a\\'+j])sum=(sum*nCr(count,m[\\'a\\'+j]))%(1000000007);\\n                    count-=m[\\'a\\'+j];\\n                    m[\\'a\\'+j]=0;\\n                }\\n            }\\n            else{\\n                count++;\\n                m[s[i]]++;\\n            }\\n        }\\n        for(int j = 0; j<26; j++){\\n            if(m[\\'a\\'+j])sum=(sum*nCr(count,m[\\'a\\'+j]))%1000000007;\\n            count-=m[\\'a\\'+j];\\n            m[\\'a\\'+j]=0;\\n        }\\n        return (int)(sum%(1000000007));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long power(long long x,long long y, int p=1000000007)\\n{\\n    long long res = 1; \\n \\n    x = x % p;\\n \\n    while (y > 0)\\n    {\\n     \\n        if (y & 1)\\n            res = (res * x) % p;\\n \\n        y = y >> 1;\\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\n \\nlong long modInverse(int n, int p=1000000007)\\n{\\n    return power(n, p - 2, p);\\n}\\n \\n\\nunsigned long long nCr(int n, int r, int p=1000000007)\\n{\\n    if (n < r)\\n        return 0;\\n    if (r == 0)\\n        return 1;\\n\\n    long long fac[n + 1];\\n    fac[0] = 1;\\n    for (int i = 1; i <= n; i++)\\n        fac[i] = (fac[i - 1] * i) % p;\\n \\n    return (fac[n] * modInverse(fac[r], p) % p* modInverse(fac[n - r], p) % p)% p;\\n}\\n    int countAnagrams(string s) {\\n        int count=0;\\n        unordered_map<char,int> m;\\n        long long sum = 1;\\n        for(int i = 0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                for(int j = 0; j<26; j++){\\n                    if(m[\\'a\\'+j])sum=(sum*nCr(count,m[\\'a\\'+j]))%(1000000007);\\n                    count-=m[\\'a\\'+j];\\n                    m[\\'a\\'+j]=0;\\n                }\\n            }\\n            else{\\n                count++;\\n                m[s[i]]++;\\n            }\\n        }\\n        for(int j = 0; j<26; j++){\\n            if(m[\\'a\\'+j])sum=(sum*nCr(count,m[\\'a\\'+j]))%1000000007;\\n            count-=m[\\'a\\'+j];\\n            m[\\'a\\'+j]=0;\\n        }\\n        return (int)(sum%(1000000007));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642329,
                "title": "fully-explained-solution",
                "content": "It is explained in the comments top the code\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        \\'\\'\\'\\n        You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space \\' \\'.\\n        A string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\\n        For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\n        Return the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.\\n        \\'\\'\\'\\n        # number of permutation of a group of  words w1, w2, w3, ..., wn\\n        # = permutation(w1) * permutation(w2) * permutation(w3)*..*permutation(wn)\\n        # permutaion of one word = n!/(c1!*c2!*cm!)  ; c1, c2, cm are the number of repeated characters\\n        # We use the property of (a/b) % mod = a%mod * ()(b^-1)%mod) % mod\\n        result, mod = 1, int(1e9 + 7)\\n        for word in s.split():\\n            result *= factorial(len(word)) % mod\\n            for i in Counter(word).values():\\n                result *= pow(factorial(i), -1, mod)\\n\\n        return result % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        \\'\\'\\'\\n        You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space \\' \\'.\\n        A string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\\n        For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\n        Return the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.\\n        \\'\\'\\'\\n        # number of permutation of a group of  words w1, w2, w3, ..., wn\\n        # = permutation(w1) * permutation(w2) * permutation(w3)*..*permutation(wn)\\n        # permutaion of one word = n!/(c1!*c2!*cm!)  ; c1, c2, cm are the number of repeated characters\\n        # We use the property of (a/b) % mod = a%mod * ()(b^-1)%mod) % mod\\n        result, mod = 1, int(1e9 + 7)\\n        for word in s.split():\\n            result *= factorial(len(word)) % mod\\n            for i in Counter(word).values():\\n                result *= pow(factorial(i), -1, mod)\\n\\n        return result % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563842,
                "title": "c-factorial-modulo-multiplicative-inverse-permutations",
                "content": "# Approach\\nModulo Multiplicative Inverse\\nFactorial using DP\\nPermutations formula\\n\\n# Complexity\\n- Time complexity:\\nO(N log N). Loop through each character in the string thus O(N). For every word, there is a O(log N) calculation of denominator to the power of mod-2.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/*\\n\\nFormula for factorial\\n4! = 1 x 2 x 3 x 4\\n\\nFormula for permutations.\\nFor permutations of \"cccbhbq\", \"c\" is repeated 3 times and \"b\" is repeated 2 times. There are 7 total characters. Therefore, calculation for the permutations is 7! / (3! * 2!).\\n\\nFor dividing with prime modulo:\\na / b == a * b^(-1)\\nb^(-1) mod m == b^(modulo - 2)\\n\\nTime complexity\\nO(N log N). Loop through each character in the string thus O(N). For every word, there is a O(log N) calculation of denominator to the power of mod-2.\\n\\n\\n\\n*/\\n\\n\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    ll fact[100005];\\n\\n    void factorial(ll n) {\\n        fact[0] = 1;\\n        for(ll i=1; i<=n; i++) fact[i] = i * fact[i-1] % mod;\\n    }\\n\\n    ll powmod(ll a, ll b) {\\n        ll ans = 1;\\n        while(b > 0) {\\n            if(b & 1) ans = ans * a % mod;\\n            a = a * a % mod;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n    ll inv(ll x) {\\n        return powmod(x, mod-2);\\n    }\\n    \\n    int countAnagrams(string s) {\\n        ll n = s.size();\\n        factorial(n);\\n        s.push_back(\\' \\');\\n        unordered_map<char, ll> mp;\\n        ll ans = 1, cnt = 0;\\n        for(auto c: s) {\\n            if(c == \\' \\') {\\n                ll up = fact[cnt];\\n                for(auto x: mp) {\\n                    ll down = fact[x.second];\\n                    up = up * inv(down) % mod;\\n                }\\n                ans = ans * up % mod;\\n                mp.clear();\\n                cnt = 0;\\n            }\\n            else {\\n                mp[c]++;\\n                cnt++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n\\nFormula for factorial\\n4! = 1 x 2 x 3 x 4\\n\\nFormula for permutations.\\nFor permutations of \"cccbhbq\", \"c\" is repeated 3 times and \"b\" is repeated 2 times. There are 7 total characters. Therefore, calculation for the permutations is 7! / (3! * 2!).\\n\\nFor dividing with prime modulo:\\na / b == a * b^(-1)\\nb^(-1) mod m == b^(modulo - 2)\\n\\nTime complexity\\nO(N log N). Loop through each character in the string thus O(N). For every word, there is a O(log N) calculation of denominator to the power of mod-2.\\n\\n\\n\\n*/\\n\\n\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    ll fact[100005];\\n\\n    void factorial(ll n) {\\n        fact[0] = 1;\\n        for(ll i=1; i<=n; i++) fact[i] = i * fact[i-1] % mod;\\n    }\\n\\n    ll powmod(ll a, ll b) {\\n        ll ans = 1;\\n        while(b > 0) {\\n            if(b & 1) ans = ans * a % mod;\\n            a = a * a % mod;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n    ll inv(ll x) {\\n        return powmod(x, mod-2);\\n    }\\n    \\n    int countAnagrams(string s) {\\n        ll n = s.size();\\n        factorial(n);\\n        s.push_back(\\' \\');\\n        unordered_map<char, ll> mp;\\n        ll ans = 1, cnt = 0;\\n        for(auto c: s) {\\n            if(c == \\' \\') {\\n                ll up = fact[cnt];\\n                for(auto x: mp) {\\n                    ll down = fact[x.second];\\n                    up = up * inv(down) % mod;\\n                }\\n                ans = ans * up % mod;\\n                mp.clear();\\n                cnt = 0;\\n            }\\n            else {\\n                mp[c]++;\\n                cnt++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517880,
                "title": "19ms-beat-100-true-time-o-n-space-o-1-most-simple-and-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHow many anagrams are there for a word with unique characters? The answer is the permutation number $$n!$$.\\n\\nHow about with duplicated characters? Just divide by the permutation number of the duplicated count $$d!$$.\\n\\nHow about a sentence with many words? We just multiply the result for each word together.\\n\\nHow do we handle large numbers? We take modular on each multiplication.\\n\\nHow do we handle divisions with modular? We use modular inverse algorithm. Specifically, we do NOT take modular inverse each time we divide a number. Instead we keep the denominator and numerator separately and only apply the modular inverse at the end.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N + Log M)$$\\nwhere N is the input size and M is the large mod $$1000\\'000\\'007$$ used in this problem. For any N that\\'s not trivially small, this is just $$\\\\Theta(N)$$\\n\\nMany other \"O(N)\" solutions are actually $$\\\\Theta(N * Log M)$$ (which is worse than $$\\\\Theta(N * Log N)$$) if they calculate the modular inverse inside the loop.\\n\\nAlternatively, some authors use a auxilary array to store all modular inverse numbers so that they got true Time complexity of O(N) but sacrifices the space complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$\\n\\n# Code\\n```\\nconstexpr int kMod = 1000\\'000\\'007;\\n\\nint Multiply(int a, int b) {\\n  if (b == 1) {\\n    return a;  // Optimization specifical to this problem.\\n  }\\n  return static_cast<int64_t>(a) * b % kMod;\\n}\\n\\nint Inverse(int a) {\\n  if (a == 1) {\\n    return 1;\\n  }\\n  int r = 1;\\n  for (int x = kMod - 2; x > 0; x >>= 1) {\\n    if (x % 2 == 1) {\\n      r = Multiply(r, a);\\n    }\\n    a = Multiply(a, a);\\n  }\\n  return r;\\n}\\n\\nclass Solution {\\npublic:\\n  int countAnagrams(string s) {\\n    int p = 1;\\n    int q = 1;  // Our answer is p/q (mod kMod)\\n    int counts[26] = {};\\n    int len = 0;\\n    for (char c : s) {\\n      if (c == \\' \\') {\\n        len = 0;\\n        std::fill(std::begin(counts), std::end(counts), 0);\\n        continue;\\n      }\\n      p = Multiply(p, ++len);\\n      q = Multiply(q, ++counts[c - \\'a\\']);\\n    }\\n    // cout << p << \"/\" << q << endl;\\n    return Multiply(p, Inverse(q));\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Combinatorics"
                ],
                "code": "```\\nconstexpr int kMod = 1000\\'000\\'007;\\n\\nint Multiply(int a, int b) {\\n  if (b == 1) {\\n    return a;  // Optimization specifical to this problem.\\n  }\\n  return static_cast<int64_t>(a) * b % kMod;\\n}\\n\\nint Inverse(int a) {\\n  if (a == 1) {\\n    return 1;\\n  }\\n  int r = 1;\\n  for (int x = kMod - 2; x > 0; x >>= 1) {\\n    if (x % 2 == 1) {\\n      r = Multiply(r, a);\\n    }\\n    a = Multiply(a, a);\\n  }\\n  return r;\\n}\\n\\nclass Solution {\\npublic:\\n  int countAnagrams(string s) {\\n    int p = 1;\\n    int q = 1;  // Our answer is p/q (mod kMod)\\n    int counts[26] = {};\\n    int len = 0;\\n    for (char c : s) {\\n      if (c == \\' \\') {\\n        len = 0;\\n        std::fill(std::begin(counts), std::end(counts), 0);\\n        continue;\\n      }\\n      p = Multiply(p, ++len);\\n      q = Multiply(q, ++counts[c - \\'a\\']);\\n    }\\n    // cout << p << \"/\" << q << endl;\\n    return Multiply(p, Inverse(q));\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3453685,
                "title": "running-with-inverse-modulo-inverse-factorial-modulo",
                "content": "let inv[i] be multiplicative inverse of i under modulo of a prime.(1e9 + 7 is a prime)\\n\\ninv[0] for prime is not defined. inv[1] = 1;\\ninv[i] = prime - (prime//i * inv[prime%i])%prime;\\n\\ninvFact[i] = (inv[1]* inv[2] * ... * inv[i])%prime\\n\\n```\\nclass Solution {\\n    static vector<int> fact;\\n    static vector<int> invFact;\\n    int mod = 1e9 + 7;\\n    int engine(string t){\\n        long long int ans = 1;\\n        vector<int> table(26, 0);\\n        for(char x: t) table[x - \\'a\\']++;\\n        int c = 1;\\n        ans = (ans*fact[t.size()])%mod;\\n        for(int i = 0; i < 26; i++){\\n            if(table[i] != 0){\\n                ans = (ans*invFact[table[i]])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        if(fact[2] == 0){\\n            vector<long long> inv(100001, 0);\\n            fact[0] = 1;\\n            fact[1] = 1;\\n            invFact[1] = 1;\\n            inv[1] = 1;\\n            for(int i = 2; i <= 1e5; i++){\\n                fact[i] = ((long long)fact[i - 1]*i)%mod;\\n                inv[i] = mod - ((long long)(mod/i)*inv[mod%i])%mod;\\n                invFact[i] = (invFact[i - 1]*inv[i])%mod;\\n            }\\n        }\\n        string t = \"\";\\n        long long int ans = 1;\\n        for(char x: s){\\n            if(x == \\' \\'){\\n                ans = (ans * engine(t))%mod;\\n                t = \"\";\\n            }\\n            else t += x;     \\n        }\\n        ans = (ans * engine(t))%mod;\\n        return ans;\\n    }\\n};\\nvector<int> Solution::fact(100001, 0);\\nvector<int> Solution::invFact(100001, 0);\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static vector<int> fact;\\n    static vector<int> invFact;\\n    int mod = 1e9 + 7;\\n    int engine(string t){\\n        long long int ans = 1;\\n        vector<int> table(26, 0);\\n        for(char x: t) table[x - \\'a\\']++;\\n        int c = 1;\\n        ans = (ans*fact[t.size()])%mod;\\n        for(int i = 0; i < 26; i++){\\n            if(table[i] != 0){\\n                ans = (ans*invFact[table[i]])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        if(fact[2] == 0){\\n            vector<long long> inv(100001, 0);\\n            fact[0] = 1;\\n            fact[1] = 1;\\n            invFact[1] = 1;\\n            inv[1] = 1;\\n            for(int i = 2; i <= 1e5; i++){\\n                fact[i] = ((long long)fact[i - 1]*i)%mod;\\n                inv[i] = mod - ((long long)(mod/i)*inv[mod%i])%mod;\\n                invFact[i] = (invFact[i - 1]*inv[i])%mod;\\n            }\\n        }\\n        string t = \"\";\\n        long long int ans = 1;\\n        for(char x: s){\\n            if(x == \\' \\'){\\n                ans = (ans * engine(t))%mod;\\n                t = \"\";\\n            }\\n            else t += x;     \\n        }\\n        ans = (ans * engine(t))%mod;\\n        return ans;\\n    }\\n};\\nvector<int> Solution::fact(100001, 0);\\nvector<int> Solution::invFact(100001, 0);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440216,
                "title": "python-o-n-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. For each word, Calculate the number of anagrams of that word\\n    - $$ \\\\frac{w!}{\\\\prod{f!}} $$\\n    - $w$ : Length of word\\n    - $f$ : Frequency of each chracter\\n2. Total ways = product of possible anagrams for each word\\n\\n# Complexity\\n- Time complexity:\\nO(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef mod_inv(a, m): return pow(a, m-2, m)\\n\\ndef mod_div(a, b, m): return (mod_inv(b, m) * a) % m\\n    \\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        ans = 1\\n        mod = 10**9+7\\n        \\n        fact = [1]\\n        for i in range(1, 10**5+1):\\n            fact.append((fact[-1]*i)%mod)\\n        \\n        for word in s.split(\" \"):\\n            \\n            freq = defaultdict(int)\\n            for c in word:\\n                freq[c] += 1\\n            \\n            den = 1\\n            for c, f in freq.items():\\n                if f: den = (den*fact[f])%mod\\n                    \\n            ans = (ans * mod_div(fact[len(word)], den, mod)) % mod\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef mod_inv(a, m): return pow(a, m-2, m)\\n\\ndef mod_div(a, b, m): return (mod_inv(b, m) * a) % m\\n    \\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        ans = 1\\n        mod = 10**9+7\\n        \\n        fact = [1]\\n        for i in range(1, 10**5+1):\\n            fact.append((fact[-1]*i)%mod)\\n        \\n        for word in s.split(\" \"):\\n            \\n            freq = defaultdict(int)\\n            for c in word:\\n                freq[c] += 1\\n            \\n            den = 1\\n            for c, f in freq.items():\\n                if f: den = (den*fact[f])%mod\\n                    \\n            ans = (ans * mod_div(fact[len(word)], den, mod)) % mod\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431610,
                "title": "easy-solution-no-pre-computation-required",
                "content": "```\\n#define ll long long\\nll m=1e9+7;\\n\\nll  mmi(ll A, ll M)\\n{\\n    ll m0 = M;\\n    ll y = 0, x = 1;\\n \\n    if (M == 1)\\n        return 0;\\n \\n    while (A > 1) {\\n        ll q = A / M;\\n        ll t = M;\\n \\n       M = A % M, A = t;\\n        t = y;\\n \\n        y = x - q * y;\\n        x = t;\\n    }\\n \\n    if (x < 0)\\n        x += m0;\\n \\n    return x;\\n}\\nclass Solution {\\n    \\n\\npublic:\\n    int countAnagrams(string str) {\\n       \\n        ll ans=1,ct=0;\\n        stringstream s(str);\\n        while(s.good()){\\n            string val;\\n            getline(s,val,\\' \\');\\n          \\n            ll size=val.size();\\n              \\n             unordered_map<char,ll>h;\\n           for(int i=0;i<val.size();i++){\\n               h[val[i]]+=1;\\n           }\\n            \\n            ll diff;\\n            ct=0;\\n            for(auto it=h.begin();it!=h.end();it++){\\n                 ll same=it->second;\\n                 \\n                ll ct2=0;\\n                 while(same-- ){ct++; ct2++;ans=(((ans*1LL*ct)%m)*(mmi(ct2,m)%m))%m;}\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    \\n\\npublic:\\n    int countAnagrams(string str) {\\n       \\n        ll ans=1,ct=0;\\n        stringstream s(str);\\n        while(s.good()){\\n            string val;\\n            getline(s,val,\\' \\');\\n          \\n            ll size=val.size();\\n              \\n             unordered_map<char,ll>h;\\n           for(int i=0;i<val.size();i++){\\n               h[val[i]]+=1;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3426747,
                "title": "fermat-inverse-modulaire",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   Calcul combinatoire \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncaLcul du num\\xE9rateur puis du d\\xE9nominateur.\\nAfin respecter les op\\xE9rations modulaires ,le r\\xE9sultat final est obtenu, en mutipliant le num\\xE9rateur par l\\'inverse modulaire du d\\xE9nominateur obtenu \\xE0 l\\'aide du petit th\\xE9or\\xE8me de Fermat   .\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing System.Numerics;\\npublic class Solution {\\n   long[] facts;\\n\\n  void f(int n){\\n\\n        facts[0] = facts[1] = 1;\\n                \\n        for (int i = 2; i <= n; i++)\\n                    facts[i] = (i  * facts[i - 1]) % 1000000007 ;\\n       }\\n\\n    public long Expentiation(long @base, int exp, int m)\\n    {\\n        long result = 1;\\n        while (exp > 0)\\n        {\\n           if ((exp & 1) > 0) result = (result * @base) % m;\\n            exp >>= 1;\\n            @base = (@base * @base) % m;\\n        }\\n\\n        return result;\\n    }\\n    public int CountAnagrams(string s)\\n    {\\n        facts =new long[s.Length+1];\\n      \\n        string[] words = s.Split(\\' \\');\\n\\n        //store factorials\\n        f(string.Join(string.Empty, words).Length);\\n                       \\n        long result = 1;\\n\\n        long numerateur =1 ;\\n        long denominateur =1;\\n         \\n        //compute numinator\\n        foreach (var word in words)\\n              numerateur = (numerateur * facts[word.Count()]) % 1000000007;\\n\\n          //compute denominator\\n        foreach (var word in words)\\n        {\\n           IEnumerable<IGrouping<char, char>> letterGroups = word.GroupBy(x => x).Where(g => g.Count() > 1);\\n\\n           foreach (var letterGroup in letterGroups)\\n               denominateur = (denominateur * facts[letterGroup.Count()]) % 1000000007;\\n        }\\n            \\n\\n        //compute fermat modular inverse of denominator \\n        long exp = Expentiation(denominateur, 1000000005, 1000000007);\\n\\n        //result\\n        result = (numerateur * exp) % 1000000007;\\n\\n        return (int)result ;\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Numerics;\\npublic class Solution {\\n   long[] facts;\\n\\n  void f(int n){\\n\\n        facts[0] = facts[1] = 1;\\n                \\n        for (int i = 2; i <= n; i++)\\n                    facts[i] = (i  * facts[i - 1]) % 1000000007 ;\\n       }\\n\\n    public long Expentiation(long @base, int exp, int m)\\n    {\\n        long result = 1;\\n        while (exp > 0)\\n        {\\n           if ((exp & 1) > 0) result = (result * @base) % m;\\n            exp >>= 1;\\n            @base = (@base * @base) % m;\\n        }\\n\\n        return result;\\n    }\\n    public int CountAnagrams(string s)\\n    {\\n        facts =new long[s.Length+1];\\n      \\n        string[] words = s.Split(\\' \\');\\n\\n        //store factorials\\n        f(string.Join(string.Empty, words).Length);\\n                       \\n        long result = 1;\\n\\n        long numerateur =1 ;\\n        long denominateur =1;\\n         \\n        //compute numinator\\n        foreach (var word in words)\\n              numerateur = (numerateur * facts[word.Count()]) % 1000000007;\\n\\n          //compute denominator\\n        foreach (var word in words)\\n        {\\n           IEnumerable<IGrouping<char, char>> letterGroups = word.GroupBy(x => x).Where(g => g.Count() > 1);\\n\\n           foreach (var letterGroup in letterGroups)\\n               denominateur = (denominateur * facts[letterGroup.Count()]) % 1000000007;\\n        }\\n            \\n\\n        //compute fermat modular inverse of denominator \\n        long exp = Expentiation(denominateur, 1000000005, 1000000007);\\n\\n        //result\\n        result = (numerateur * exp) % 1000000007;\\n\\n        return (int)result ;\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408455,
                "title": "python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        ans=1\\n        for i in s.split():\\n            d=1\\n            for j in Counter(i).values():\\n                d*=math.factorial(j)\\n            ans*=math.factorial(len(i))//d\\n        return ans%(10**9+7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        ans=1\\n        for i in s.split():\\n            d=1\\n            for j in Counter(i).values():\\n                d*=math.factorial(j)\\n            ans*=math.factorial(len(i))//d\\n        return ans%(10**9+7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328218,
                "title": "python-using-combinations-with-repetition",
                "content": "# Approach\\n1. Count possible combinations of letters (aka anagrams) for each word [take into account that letters can be repeated, so technically **combinations** **with repetition**] in the array. \\n2. To find the total number of distinct anagrams - multiply combinations from the previous step.\\n\\n\\n###### **Combinations with repetition**\\n$$P = \\\\frac{n!}{n_1! \\\\cdot n_2! ... n_k!} $$\\n\\nwhere 1,k - unique letters in a string, n_k - number of occurrences of a character k in a string\\n\\n# Complexity\\nTime complexity: $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countAnagrams(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if len(set(s)) == 1:\\n            return 1\\n\\n        res = 1\\n        s = s.split(\\' \\')\\n        combinations_word = []\\n\\n        for word in s:\\n            factorials = 1\\n            for letter in set(word):\\n                cnt_letter = word.count(letter)\\n                factor = factorial(cnt_letter)\\n                factorials *= factor\\n\\n            cur_comb = factorial(len(word)) / factorials\\n            combinations_word.append(int(cur_comb))\\n        \\n        for num in combinations_word:\\n            res *= num\\n        return res%((10**9)+7)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution(object):\\n    def countAnagrams(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if len(set(s)) == 1:\\n            return 1\\n\\n        res = 1\\n        s = s.split(\\' \\')\\n        combinations_word = []\\n\\n        for word in s:\\n            factorials = 1\\n            for letter in set(word):\\n                cnt_letter = word.count(letter)\\n                factor = factorial(cnt_letter)\\n                factorials *= factor\\n\\n            cur_comb = factorial(len(word)) / factorials\\n            combinations_word.append(int(cur_comb))\\n        \\n        for num in combinations_word:\\n            res *= num\\n        return res%((10**9)+7)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281437,
                "title": "python-simple-math-factorial-solution",
                "content": "```\\ndef countAnagrams(self, s: str) -> int:\\n        re = 1\\n        mod = 10**9 + 7\\n        for ele in s.split():\\n            tot = factorial(len(ele))\\n            for v in Counter(ele).values():\\n                tot//=factorial(v)\\n            re = (re*tot)%mod\\n        return re\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\ndef countAnagrams(self, s: str) -> int:\\n        re = 1\\n        mod = 10**9 + 7\\n        for ele in s.split():\\n            tot = factorial(len(ele))\\n            for v in Counter(ele).values():\\n                tot//=factorial(v)\\n            re = (re*tot)%mod\\n        return re\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3268577,
                "title": "c-o-n-solution-detailed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution is to use the fermets little theorem, modular multiplicative inverse and binary exponentiation. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solve this problem was to first precompute the factorials from $$0$$ to $$10$$,  % M.\\nthen to compute the $$numerator$$ and $$denominator$$ seperately. \\nas we know, to find the number of ways we can arrange the string can be found as follows:\\n\\nfor example:\\n```\\ns = \"too hot\"\\ns1 = \"too\"\\ns2 = \"hot\"\\n```\\n\\n`total ways = number of ways of s1 * number of ways of s2`\\n\\nand the basic formula to find the permutation of any string is : \\n\\n`(size of string)! / (product of factorials of no. of common char)`\\n\\nfor example:\\n```\\ns1 = \"cchpsbb\";\\nthen number of permutations = 7! / (2! * 2!)\\n```\\n\\nNow, I pushed extra \\' \\' behind the given string, why will come to know later.\\n\\nI iterated over the string and computed the numberator and denominator. I pushed the \\' \\' just to compute for the last word occured in the string. \\n\\nand finaly we have to find `(num / den) % M` but we cannot directly divide them. we will have to use modular multiplicative inverse and fermets little theorem.\\n\\naccording to fermets little theorem\\n\\n**A^m-1 = 1 (mod) M**\\nunder following conditions,\\n1. M is prime\\n2. A and M are coprime i.e. their gcd is 1\\n\\nso by multiplying both sides by `A^-1`\\nwe get,\\n**A^m-2 = A^-1 (mod) M**\\n**A^m-2 % M = A^-1** \\nand we can transform `(num / den) % M` to `(num * (den) ^ -1) % M`\\nNow , we can easily find. `(den) ^ -1` as `(den^M-1) % M` using **binary exponentiation**. \\nand then just by multiplying `(num * (den^-1)) % M` you will get the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    const int N = 1e5+7;\\n    int binExp(int a, int b){\\n        int ans = 1;\\n        while(b){\\n            if(b&1){\\n                ans = (ans * 1LL * a) % M;\\n            }\\n            b >>= 1;\\n            a = (a * 1LL * a) % M;\\n        }\\n        return ans;\\n    }\\n    int countAnagrams(string s) {\\n        vector<int> facts(N);\\n        facts[0] = facts[1] = 1;\\n        //precomputing facts %M\\n        for(int i = 2; i < N; i++){\\n            facts[i] = (facts[i - 1] * 1LL * i) % M;\\n        }\\n        int num = 1;\\n        int den = 1;\\n        unordered_map<char, int> hsh;\\n        //for last computation\\n        s.push_back(\\' \\');\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] != \\' \\'){\\n                hsh[s[i]]++;\\n            }else{\\n                int sz = 0;\\n                for(auto&it: hsh){\\n                    sz += it.second;\\n                    if(it.second > 1){\\n                        den = (den * 1LL * facts[it.second]) % M;\\n                    }\\n                }\\n                num = (num * 1LL * facts[sz]) % M;\\n                hsh.clear();\\n            }\\n        }\\n        return (num * 1LL * binExp(den, M - 2)) % M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\ns = \"too hot\"\\ns1 = \"too\"\\ns2 = \"hot\"\\n```\n```\\ns1 = \"cchpsbb\";\\nthen number of permutations = 7! / (2! * 2!)\\n```\n```\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    const int N = 1e5+7;\\n    int binExp(int a, int b){\\n        int ans = 1;\\n        while(b){\\n            if(b&1){\\n                ans = (ans * 1LL * a) % M;\\n            }\\n            b >>= 1;\\n            a = (a * 1LL * a) % M;\\n        }\\n        return ans;\\n    }\\n    int countAnagrams(string s) {\\n        vector<int> facts(N);\\n        facts[0] = facts[1] = 1;\\n        //precomputing facts %M\\n        for(int i = 2; i < N; i++){\\n            facts[i] = (facts[i - 1] * 1LL * i) % M;\\n        }\\n        int num = 1;\\n        int den = 1;\\n        unordered_map<char, int> hsh;\\n        //for last computation\\n        s.push_back(\\' \\');\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] != \\' \\'){\\n                hsh[s[i]]++;\\n            }else{\\n                int sz = 0;\\n                for(auto&it: hsh){\\n                    sz += it.second;\\n                    if(it.second > 1){\\n                        den = (den * 1LL * facts[it.second]) % M;\\n                    }\\n                }\\n                num = (num * 1LL * facts[sz]) % M;\\n                hsh.clear();\\n            }\\n        }\\n        return (num * 1LL * binExp(den, M - 2)) % M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176470,
                "title": "my-c-sol-a-little-messy-but-if-it-can-help",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\n#define k 1000000007\\nclass Solution {\\npublic:\\n// NOTE SEE THIS QUESTION FOR USING MOD OPERATOR OF LARGER SIZE\\n    // // helper fn sorry no use of this fn \\n    // ll find_no(int len) {\\n    //     ll temp = 1;\\n    //     for(int i=1;i<=len;i++) {\\n    //         temp = (temp*i);\\n    //     }\\n    //     return temp%k;\\n    // }\\n\\n    // for euler theorem (toitent)\\n    ll power(ll x) {\\n        ll ans = 1;\\n        ll y = k-2;\\n        while(y) {\\n            if(y&1) ans = (ans*x)%k;\\n            y/=2;\\n            x=(x*x)%k;\\n\\n            // // ye y-- ya x-- krke nhi chlega...isse tle maarega\\n            // y--;\\n            // x--;\\n        }\\n        return ans;\\n    }\\n\\n    // main fn\\n    int countAnagrams(string s) {\\n        int n = size(s);\\n        unordered_map<char,int>mp;\\n        ll ans=1;\\n        int space= -1; // ye pichle space ka value store krega\\n\\n        // make a ll array jisme saare 1 to n tk ke saare factorials ho\\n        // so for storing factorials upto n\\n        vector<ll>fact(n+1,0);\\n        fact[0] = 1;\\n        fact[1] = 1;\\n        for(int i=2;i<=n;i++) {\\n            fact[i] = (fact[i-1]*i)%k; // associativity of * greater than % operator\\n        }\\n        \\n        for(int i=0;i<=n;i++) {\\n            if(s[i]==32 || i==n) {\\n                int len = i-space-1; // length of current word\\n                space = i; // update the space\\n               // ll temp = find_no(len);\\n              // no need of find_no fn we can directly take it from the vector fact as it is precalculated \\n               ll temp = fact[len];\\n               // cout << temp<< endl;\\n                for(auto it : mp) {\\n                    // ll div = find_no(it.second);\\n                   //   temp = (temp/div)%k; // this is not how it is divided...use euler\\'s theorem\\n                     // for a/b = a*(1/b) so use euler for 1/b\\n\\n                     ll div = fact[it.second];\\n                   temp = temp*(power(div))%k; // yhan %k imp hai\\n                }\\n                ans = (ans*temp)%k;\\n\\n                mp.clear();\\n                cout << temp<<\" \";\\n            }\\n            else {\\n                if(mp.find(s[i])==mp.end()) mp.insert({s[i],1});\\n                else mp[s[i]]++;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n#define k 1000000007\\nclass Solution {\\npublic:\\n// NOTE SEE THIS QUESTION FOR USING MOD OPERATOR OF LARGER SIZE\\n    // // helper fn sorry no use of this fn \\n    // ll find_no(int len) {\\n    //     ll temp = 1;\\n    //     for(int i=1;i<=len;i++) {\\n    //         temp = (temp*i);\\n    //     }\\n    //     return temp%k;\\n    // }\\n\\n    // for euler theorem (toitent)\\n    ll power(ll x) {\\n        ll ans = 1;\\n        ll y = k-2;\\n        while(y) {\\n            if(y&1) ans = (ans*x)%k;\\n            y/=2;\\n            x=(x*x)%k;\\n\\n            // // ye y-- ya x-- krke nhi chlega...isse tle maarega\\n            // y--;\\n            // x--;\\n        }\\n        return ans;\\n    }\\n\\n    // main fn\\n    int countAnagrams(string s) {\\n        int n = size(s);\\n        unordered_map<char,int>mp;\\n        ll ans=1;\\n        int space= -1; // ye pichle space ka value store krega\\n\\n        // make a ll array jisme saare 1 to n tk ke saare factorials ho\\n        // so for storing factorials upto n\\n        vector<ll>fact(n+1,0);\\n        fact[0] = 1;\\n        fact[1] = 1;\\n        for(int i=2;i<=n;i++) {\\n            fact[i] = (fact[i-1]*i)%k; // associativity of * greater than % operator\\n        }\\n        \\n        for(int i=0;i<=n;i++) {\\n            if(s[i]==32 || i==n) {\\n                int len = i-space-1; // length of current word\\n                space = i; // update the space\\n               // ll temp = find_no(len);\\n              // no need of find_no fn we can directly take it from the vector fact as it is precalculated \\n               ll temp = fact[len];\\n               // cout << temp<< endl;\\n                for(auto it : mp) {\\n                    // ll div = find_no(it.second);\\n                   //   temp = (temp/div)%k; // this is not how it is divided...use euler\\'s theorem\\n                     // for a/b = a*(1/b) so use euler for 1/b\\n\\n                     ll div = fact[it.second];\\n                   temp = temp*(power(div))%k; // yhan %k imp hai\\n                }\\n                ans = (ans*temp)%k;\\n\\n                mp.clear();\\n                cout << temp<<\" \";\\n            }\\n            else {\\n                if(mp.find(s[i])==mp.end()) mp.insert({s[i],1});\\n                else mp[s[i]]++;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3158482,
                "title": "c-math",
                "content": "```\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    vector<vector<ll>> fetch(string &s){\\n        ll n = s.size();\\n        vector<vector<ll>> arr;\\n        ll i=0;\\n        while(i<n){\\n            vector<ll> v(26, 0);\\n            while(i<n){\\n                if(s[i] == \\' \\') break;\\n                else v[s[i]-\\'a\\']++;\\n                ++i;\\n            }\\n            arr.push_back(v);\\n            ++i;\\n        }\\n        return arr;\\n    }\\n    \\n    vector<ll> get_fect(string &s){\\n        int n = s.size();\\n        vector<ll> fact(n+10, 0);\\n        fact[1] = 1;\\n        \\n        for(int i=2; i<n+10; ++i){ \\n            fact[i] = (fact[i-1]%mod*i%mod)%mod;\\n        }\\n        \\n        return fact;\\n    }\\n    \\n    ll binaryExpo(ll x, ll n){\\n        if(n==0) return 1ll;\\n        if(n==1) return x;\\n        ll cur = binaryExpo(x, n/2ll);\\n        cur = (cur%mod * cur%mod)%mod;\\n        if(n&1) cur = (cur%mod * x%mod) %mod;\\n        return cur;\\n    }\\n    \\n    ll factINV(ll x, vector<ll>& fact){\\n        return binaryExpo(fact[x], mod-2)%mod;\\n    }\\n    \\n    \\n    int countAnagrams(string s) {\\n        vector<vector<ll>> arr = fetch(s);\\n        vector<ll> fact = get_fect(s);\\n        \\n        \\n        ll res = 1;\\n        for(auto &v : arr){\\n            ll cnt = 0;\\n            for(auto &e : v){\\n                cnt += e;\\n            }\\n            \\n            cnt = fact[cnt];\\n            \\n            for(auto &e : v){\\n                if(e>1){\\n                    ll d = factINV(e, fact);\\n                    cnt = (cnt%mod * d%mod) % mod;\\n                }\\n            }\\n            \\n            res = (res%mod * cnt%mod) % mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    vector<vector<ll>> fetch(string &s){\\n        ll n = s.size();\\n        vector<vector<ll>> arr;\\n        ll i=0;\\n        while(i<n){\\n            vector<ll> v(26, 0);\\n            while(i<n){\\n                if(s[i] == \\' \\') break;\\n                else v[s[i]-\\'a\\']++;\\n                ++i;\\n            }\\n            arr.push_back(v);\\n            ++i;\\n        }\\n        return arr;\\n    }\\n    \\n    vector<ll> get_fect(string &s){\\n        int n = s.size();\\n        vector<ll> fact(n+10, 0);\\n        fact[1] = 1;\\n        \\n        for(int i=2; i<n+10; ++i){ \\n            fact[i] = (fact[i-1]%mod*i%mod)%mod;\\n        }\\n        \\n        return fact;\\n    }\\n    \\n    ll binaryExpo(ll x, ll n){\\n        if(n==0) return 1ll;\\n        if(n==1) return x;\\n        ll cur = binaryExpo(x, n/2ll);\\n        cur = (cur%mod * cur%mod)%mod;\\n        if(n&1) cur = (cur%mod * x%mod) %mod;\\n        return cur;\\n    }\\n    \\n    ll factINV(ll x, vector<ll>& fact){\\n        return binaryExpo(fact[x], mod-2)%mod;\\n    }\\n    \\n    \\n    int countAnagrams(string s) {\\n        vector<vector<ll>> arr = fetch(s);\\n        vector<ll> fact = get_fect(s);\\n        \\n        \\n        ll res = 1;\\n        for(auto &v : arr){\\n            ll cnt = 0;\\n            for(auto &e : v){\\n                cnt += e;\\n            }\\n            \\n            cnt = fact[cnt];\\n            \\n            for(auto &e : v){\\n                if(e>1){\\n                    ll d = factINV(e, fact);\\n                    cnt = (cnt%mod * d%mod) % mod;\\n                }\\n            }\\n            \\n            res = (res%mod * cnt%mod) % mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152592,
                "title": "golang-map-combinatorics",
                "content": "# Code\\n```\\nconst MOD int64 = 1e9 + 7\\n\\nfunc factorial(n int) int {\\n    var f int64 = 1\\n    for i := 1; i <= n; i++ {\\n        f = (f * int64(i)) % MOD\\n    }\\n    return int(f)\\n}\\nfunc fastExp(x, n int) int {\\n    if n == 0 {return 1}\\n    var y int64 = int64(fastExp(x, n / 2))\\n    if n % 2 == 1 {\\n        return int((((y * y) % MOD) * int64(x)) % MOD)\\n    }\\n    return int((y * y) % MOD)\\n}\\nfunc countAnagrams(s string) int {\\n    Map := make(map[byte]int)\\n    s += \" \"\\n    var N, D, count int = 1, 1, 0\\n    for i := 0; i < len(s); i++ {\\n        if s[i] != \\' \\' {\\n            count++\\n            Map[s[i]]++\\n        } else {\\n            N = (N * factorial(count)) % int(MOD)\\n            for _, val := range Map {\\n                D = (D * factorial(val)) % int(MOD)\\n            }\\n            Map = make(map[byte]int)\\n            count = 0\\n        }\\n    } \\n    return (N * fastExp(D, int(MOD) - 2)) % int(MOD)\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Math",
                    "String",
                    "Combinatorics"
                ],
                "code": "```\\nconst MOD int64 = 1e9 + 7\\n\\nfunc factorial(n int) int {\\n    var f int64 = 1\\n    for i := 1; i <= n; i++ {\\n        f = (f * int64(i)) % MOD\\n    }\\n    return int(f)\\n}\\nfunc fastExp(x, n int) int {\\n    if n == 0 {return 1}\\n    var y int64 = int64(fastExp(x, n / 2))\\n    if n % 2 == 1 {\\n        return int((((y * y) % MOD) * int64(x)) % MOD)\\n    }\\n    return int((y * y) % MOD)\\n}\\nfunc countAnagrams(s string) int {\\n    Map := make(map[byte]int)\\n    s += \" \"\\n    var N, D, count int = 1, 1, 0\\n    for i := 0; i < len(s); i++ {\\n        if s[i] != \\' \\' {\\n            count++\\n            Map[s[i]]++\\n        } else {\\n            N = (N * factorial(count)) % int(MOD)\\n            for _, val := range Map {\\n                D = (D * factorial(val)) % int(MOD)\\n            }\\n            Map = make(map[byte]int)\\n            count = 0\\n        }\\n    } \\n    return (N * fastExp(D, int(MOD) - 2)) % int(MOD)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152507,
                "title": "c-hash-table-combinatorics",
                "content": "# Code\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    int factorial(int n) {\\n        int f = 1;\\n        for(int i = 1; i <= n; i++) {\\n            f = (f * 1L * i) % MOD;\\n        }\\n        return f;\\n    }\\n    int fastExp(int x, int n) {\\n        if(n == 0) return 1;\\n        long y = fastExp(x, n / 2);\\n        if(n % 2) return (((y * y) % MOD) * x) % MOD;\\n        return (y * y) % MOD;\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        unordered_map<char, int> Map;\\n        s += \" \";\\n        int N = 1, D = 1, count = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] != \\' \\') {\\n                count++;\\n                Map[s[i]]++;\\n            } else {\\n                N = (N * 1L * factorial(count)) % MOD;\\n                for(auto &[_, val]: Map) {\\n                    D = (D * 1L * factorial(val)) % MOD;\\n                }\\n                Map.clear();\\n                count = 0;\\n            }\\n        } \\n        return (N * 1L * fastExp(D, MOD - 2)) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    int factorial(int n) {\\n        int f = 1;\\n        for(int i = 1; i <= n; i++) {\\n            f = (f * 1L * i) % MOD;\\n        }\\n        return f;\\n    }\\n    int fastExp(int x, int n) {\\n        if(n == 0) return 1;\\n        long y = fastExp(x, n / 2);\\n        if(n % 2) return (((y * y) % MOD) * x) % MOD;\\n        return (y * y) % MOD;\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        unordered_map<char, int> Map;\\n        s += \" \";\\n        int N = 1, D = 1, count = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] != \\' \\') {\\n                count++;\\n                Map[s[i]]++;\\n            } else {\\n                N = (N * 1L * factorial(count)) % MOD;\\n                for(auto &[_, val]: Map) {\\n                    D = (D * 1L * factorial(val)) % MOD;\\n                }\\n                Map.clear();\\n                count = 0;\\n            }\\n        } \\n        return (N * 1L * fastExp(D, MOD - 2)) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148082,
                "title": "java-solve",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int countAnagrams(String s) {\\n        long res=1;\\n        String stringList [] = s.split(\" \");\\n        for(int i=0 ; i<stringList.length; i++){\\n            long x = countChar(stringList[i]);\\n            long y = p(stringList[i].length());\\n            res *= (y*pow(x,MOD-2))%MOD;\\n            res %=MOD;\\n        }\\n        return (int)res;\\n    }\\n    public  long p(long x){\\n        long temp = 1;\\n        for(int i=1 ; i<=x; i++) {\\n            temp *= i;\\n            temp %= (MOD);\\n        }\\n        return temp;\\n    }\\n    public long countChar(String s){\\n        long sum = 1;\\n        int arr[] = new int[26];\\n        for(int i=0 ; i<s.length(); i++){\\n            arr[s.charAt(i) - \\'a\\']++;\\n        }\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i] != 0) {\\n               sum *= p(arr[i]);\\n               sum %= MOD;\\n            }\\n        }\\n        return sum;\\n    }\\n   public  long  pow(long a,long n) {\\n        long res = 1;\\n        while(n>0) {\\n            if(n%2 == 1) {\\n                res = (res * a) % MOD;\\n                n--;\\n            }\\n            else {\\n                a = (a * a) % MOD;\\n                n = n / 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int countAnagrams(String s) {\\n        long res=1;\\n        String stringList [] = s.split(\" \");\\n        for(int i=0 ; i<stringList.length; i++){\\n            long x = countChar(stringList[i]);\\n            long y = p(stringList[i].length());\\n            res *= (y*pow(x,MOD-2))%MOD;\\n            res %=MOD;\\n        }\\n        return (int)res;\\n    }\\n    public  long p(long x){\\n        long temp = 1;\\n        for(int i=1 ; i<=x; i++) {\\n            temp *= i;\\n            temp %= (MOD);\\n        }\\n        return temp;\\n    }\\n    public long countChar(String s){\\n        long sum = 1;\\n        int arr[] = new int[26];\\n        for(int i=0 ; i<s.length(); i++){\\n            arr[s.charAt(i) - \\'a\\']++;\\n        }\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i] != 0) {\\n               sum *= p(arr[i]);\\n               sum %= MOD;\\n            }\\n        }\\n        return sum;\\n    }\\n   public  long  pow(long a,long n) {\\n        long res = 1;\\n        while(n>0) {\\n            if(n%2 == 1) {\\n                res = (res * a) % MOD;\\n                n--;\\n            }\\n            else {\\n                a = (a * a) % MOD;\\n                n = n / 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096530,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nint fact[100002];\\n\\nint modmul(int a,int b){\\n    return((long long)(a%mod)*(b%mod))%mod;\\n}\\n\\nint binExpo(int a,int b){\\n    if(!b)return 1;\\n    int res=binExpo(a,b/2);\\n    if(b&1){\\n        return modmul(a,modmul(res,res));\\n    }else{\\n        return modmul(res,res);\\n    }\\n}\\n\\nint modmulinv(int a){\\n    return binExpo(a,mod-2);\\n}\\n\\nvoid getfact() {\\n    fact[0]=1;\\n    for(int i=1;i<=100001;i++){\\n        fact[i]=modmul(fact[i-1],i);\\n    }\\n}\\n\\nint ways(string str) {\\n   int freq[26] = {0};\\n   for(int i = 0; i<str.size(); i++) {\\n      freq[str[i] - \\'a\\']++;\\n   }\\n   int totalWays = fact[str.size()];\\n   int factR=1; \\n   for(int i = 0; i<26; i++) {\\n         factR=modmul(factR,fact[freq[i]]);\\n   }\\n   return modmul(totalWays,modmulinv(factR));\\n}\\n \\n    int countAnagrams(string s) {\\n        getfact();\\n        istringstream ss(s);\\n        string word; \\n         int ans=1;\\n        while (ss >> word)\\n        {\\n            ans=modmul(ans,ways(word));\\n        }\\n        return ans;\\n    }\\n  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nint fact[100002];\\n\\nint modmul(int a,int b){\\n    return((long long)(a%mod)*(b%mod))%mod;\\n}\\n\\nint binExpo(int a,int b){\\n    if(!b)return 1;\\n    int res=binExpo(a,b/2);\\n    if(b&1){\\n        return modmul(a,modmul(res,res));\\n    }else{\\n        return modmul(res,res);\\n    }\\n}\\n\\nint modmulinv(int a){\\n    return binExpo(a,mod-2);\\n}\\n\\nvoid getfact() {\\n    fact[0]=1;\\n    for(int i=1;i<=100001;i++){\\n        fact[i]=modmul(fact[i-1],i);\\n    }\\n}\\n\\nint ways(string str) {\\n   int freq[26] = {0};\\n   for(int i = 0; i<str.size(); i++) {\\n      freq[str[i] - \\'a\\']++;\\n   }\\n   int totalWays = fact[str.size()];\\n   int factR=1; \\n   for(int i = 0; i<26; i++) {\\n         factR=modmul(factR,fact[freq[i]]);\\n   }\\n   return modmul(totalWays,modmulinv(factR));\\n}\\n \\n    int countAnagrams(string s) {\\n        getfact();\\n        istringstream ss(s);\\n        string word; \\n         int ans=1;\\n        while (ss >> word)\\n        {\\n            ans=modmul(ans,ways(word));\\n        }\\n        return ans;\\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052685,
                "title": "c-math",
                "content": "# Approach\\n$$O(n)$$ solve inverse modular.\\n```\\nvoid Inv(){\\n\\tinv[0] = inv[1] = 1;\\n\\tfor(LL i = 2;i < maxn; i++){\\n\\t\\tinv[i] = (Mod - Mod / i) * inv[Mod % i] % Mod;\\n\\t}\\n}\\n``` \\nMathmetical explanation:\\nLet $t = \\\\lfloor MOD / i \\\\rfloor$\\nLet $k = MOD \\\\% i$\\nThen $t * i + k = MOD$\\nThen $t * i + k \\\\equiv 0 \\\\pmod{MOD}$\\nDivide $i * k$ on both side of above equation\\n$t * k^{-1} + i^{-1} \\\\equiv 0 \\\\pmod{MOD}$\\nThen $i^{-1} \\\\equiv -t * k^{-1} \\\\pmod{MOD}$\\nMake the right hand side to be positive, then \\n`inv[i] = (Mod - Mod / i) * inv[Mod % i] % Mod;`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int MOD = (int)(1E9 + 7);\\n    int fact[100001] = {1, 1}, inv_fact[100001] = {1, 1};\\n\\n    vector<string> split(string& ori) {\\n        stringstream ss(ori);\\n        string token;\\n        vector<string> result;\\n        while (getline(ss, token, \\' \\')) {\\n            result.push_back(token);\\n        }\\n        return result;\\n    }\\n\\n    vector<int> cntString(string& ori) {\\n        vector<int> cnt(26);\\n        for (char c : ori) {\\n            ++cnt[c - \\'a\\'];\\n        }\\n        return cnt;\\n    }\\n\\n    int countAnagrams(string s) {\\n        if (fact[2] == 0) {\\n            vector<int> inv(100001, 1);\\n            for (long long i = 2; i < sizeof(fact) / sizeof(fact[0]); ++i) {\\n                fact[i] = i * fact[i - 1] % MOD;\\n                inv[i] = MOD - MOD / i * inv[MOD % i] % MOD;\\n                inv_fact[i] = 1LL * inv_fact[i - 1] * inv[i] % MOD;            \\n            }\\n        }\\n        vector<string> ss = split(s);\\n        int result = 1;\\n        for (string& ele : ss) {\\n            vector<int> cnt = cntString(ele);\\n            int temp = fact[ele.length()];\\n            for (int each : cnt) {\\n                if (each > 1) {\\n                    temp = temp * 1ll * inv_fact[each] % MOD;\\n                }\\n            }\\n            result = result * 1ll * temp % MOD;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvoid Inv(){\\n\\tinv[0] = inv[1] = 1;\\n\\tfor(LL i = 2;i < maxn; i++){\\n\\t\\tinv[i] = (Mod - Mod / i) * inv[Mod % i] % Mod;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    const int MOD = (int)(1E9 + 7);\\n    int fact[100001] = {1, 1}, inv_fact[100001] = {1, 1};\\n\\n    vector<string> split(string& ori) {\\n        stringstream ss(ori);\\n        string token;\\n        vector<string> result;\\n        while (getline(ss, token, \\' \\')) {\\n            result.push_back(token);\\n        }\\n        return result;\\n    }\\n\\n    vector<int> cntString(string& ori) {\\n        vector<int> cnt(26);\\n        for (char c : ori) {\\n            ++cnt[c - \\'a\\'];\\n        }\\n        return cnt;\\n    }\\n\\n    int countAnagrams(string s) {\\n        if (fact[2] == 0) {\\n            vector<int> inv(100001, 1);\\n            for (long long i = 2; i < sizeof(fact) / sizeof(fact[0]); ++i) {\\n                fact[i] = i * fact[i - 1] % MOD;\\n                inv[i] = MOD - MOD / i * inv[MOD % i] % MOD;\\n                inv_fact[i] = 1LL * inv_fact[i - 1] * inv[i] % MOD;            \\n            }\\n        }\\n        vector<string> ss = split(s);\\n        int result = 1;\\n        for (string& ele : ss) {\\n            vector<int> cnt = cntString(ele);\\n            int temp = fact[ele.length()];\\n            for (int each : cnt) {\\n                if (each > 1) {\\n                    temp = temp * 1ll * inv_fact[each] % MOD;\\n                }\\n            }\\n            result = result * 1ll * temp % MOD;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042872,
                "title": "go-modular-arithmetic",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(1)$$ \\n# Code\\n```\\nconst MOD int64 = 1_000_000_007\\n\\nfunc euclid(x, y int64) (int64, int64) {\\n\\tif y == 1 {\\n\\t\\treturn 0, 1\\n\\t}\\n\\tu, v := euclid(y, x%y)\\n\\treturn v, u - (x/y)*v\\n}\\n\\nfunc rec(x int64) int64 {\\n\\t_, u := euclid(MOD, x)\\n\\treturn (u + MOD) % MOD\\n}\\n\\nfunc countAnagrams(s string) int {\\n\\tres, count, counts := int64(1), 0, [26]int{}\\n\\tfor _, c := range s {\\n\\t\\tif c == \\' \\' {\\n\\t\\t\\tcount, counts = 0, [26]int{}\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tx := int(c - \\'a\\')\\n\\t\\tcounts[x]++\\n\\t\\tcount++\\n\\t\\tres = (res * int64(count)) % MOD\\n\\t\\tres = (res * rec(int64(counts[x]))) % MOD\\n\\t}\\n\\treturn int(res)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nconst MOD int64 = 1_000_000_007\\n\\nfunc euclid(x, y int64) (int64, int64) {\\n\\tif y == 1 {\\n\\t\\treturn 0, 1\\n\\t}\\n\\tu, v := euclid(y, x%y)\\n\\treturn v, u - (x/y)*v\\n}\\n\\nfunc rec(x int64) int64 {\\n\\t_, u := euclid(MOD, x)\\n\\treturn (u + MOD) % MOD\\n}\\n\\nfunc countAnagrams(s string) int {\\n\\tres, count, counts := int64(1), 0, [26]int{}\\n\\tfor _, c := range s {\\n\\t\\tif c == \\' \\' {\\n\\t\\t\\tcount, counts = 0, [26]int{}\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tx := int(c - \\'a\\')\\n\\t\\tcounts[x]++\\n\\t\\tcount++\\n\\t\\tres = (res * int64(count)) % MOD\\n\\t\\tres = (res * rec(int64(counts[x]))) % MOD\\n\\t}\\n\\treturn int(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042844,
                "title": "python-modular-arithmetic-solution",
                "content": "# Approach\\nFirst we need to remember some modular-math formulas:\\n1) (a / b) % p = ((a % p) * (b^(-1) % p)) mod p, where b^(-1) stands for modular inverse\\n2) (a * b) % p = (a % p) *(b % p) % p\\n-----------------------\\n#### Solution\\n1) So, first step is to pre-calculate all modular factorials\\n2) Go through all words, count stat for each character\\n3) If some characters appears more than ones, than we will use formula: $$len(word)!/stat1!*stat2!...$$ (of course modular factorials)\\n4) To get correct modular division we need to find modular inverse of denumenator. To do that we need to implement [Extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)\\n5) And finally recalculate answer and return it!\\n\\n# Complexity\\n- Time complexity: $$O(N)$$ - precomputing factorials + $$O(Nlog(MOD))$$ for word stat calculations\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nclass Solution:\\n\\n    x, y = 0, 1\\n\\n    def countAnagrams(self, s: str) -> int:\\n\\n        def gcd_extended(a, b):\\n            if (a == 0):\\n                self.x, self.y = 0, 1\\n                return b\\n            gcd = gcd_extended(b % a, a)\\n            x1, y1 = self.x, self.y\\n            self.x = y1 - (b // a) * x1\\n            self.y = x1\\n            return gcd\\n \\n        def mod_inverse(A, M):\\n            g = gcd_extended(A, M)\\n            res = (self.x % M + M) % M\\n            return res\\n\\n        MOD = 10**9 + 7\\n        dp = [0, 1] + [0]*100000\\n        for i in range(2, 100002):\\n            dp[i] = (dp[i - 1]*(i % MOD)) % MOD\\n        ans = 1\\n        for word in s.split():\\n            stat = defaultdict(int)\\n            for char in word:\\n                stat[char] += 1\\n            carry = 1\\n            for val in stat.values():\\n                if val > 1:\\n                    carry =((carry % MOD)*dp[val]) % MOD\\n            if carry > 1:\\n                to_add = (dp[len(word)]*mod_inverse(carry, MOD)) % MOD\\n            else:\\n                to_add = dp[len(word)]\\n            ans = (ans % MOD)*(to_add) % MOD\\n        return ans % MOD\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n\\n    x, y = 0, 1\\n\\n    def countAnagrams(self, s: str) -> int:\\n\\n        def gcd_extended(a, b):\\n            if (a == 0):\\n                self.x, self.y = 0, 1\\n                return b\\n            gcd = gcd_extended(b % a, a)\\n            x1, y1 = self.x, self.y\\n            self.x = y1 - (b // a) * x1\\n            self.y = x1\\n            return gcd\\n \\n        def mod_inverse(A, M):\\n            g = gcd_extended(A, M)\\n            res = (self.x % M + M) % M\\n            return res\\n\\n        MOD = 10**9 + 7\\n        dp = [0, 1] + [0]*100000\\n        for i in range(2, 100002):\\n            dp[i] = (dp[i - 1]*(i % MOD)) % MOD\\n        ans = 1\\n        for word in s.split():\\n            stat = defaultdict(int)\\n            for char in word:\\n                stat[char] += 1\\n            carry = 1\\n            for val in stat.values():\\n                if val > 1:\\n                    carry =((carry % MOD)*dp[val]) % MOD\\n            if carry > 1:\\n                to_add = (dp[len(word)]*mod_inverse(carry, MOD)) % MOD\\n            else:\\n                to_add = dp[len(word)]\\n            ans = (ans % MOD)*(to_add) % MOD\\n        return ans % MOD\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029154,
                "title": "python3-counting-solution",
                "content": "# Intuition & Approach\\nA nice counting problem, I thought of how I would generate the permutations themselves and then about how to count those.\\n\\nWe can tokenize the string into separate words first thing, then apply this basic counting principle across all the tokens: https://en.wikipedia.org/wiki/Rule_of_product\\n\\nThen the question boils down to figuring out how many unique permutations a word has considering repeated letters.\\n\\nWithout repeats this is $N!$, then we divide by the # repeats factorial because there\\'s that many ways to arrange the repeated letters in the positions they fill.\\n\\nFinally, don\\'t forget to mod this.\\n\\n# Complexity\\n- Time & space complexity: $O(n)$\\n\\n# Code\\n```py\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        def get_perms(word):\\n            perms = factorial(len(word))\\n            for cnt in Counter(word).values():\\n                perms //= factorial(cnt)\\n\\n            return perms\\n\\n        return reduce(lambda a, b: a * get_perms(b) % MOD, s.split(), 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        def get_perms(word):\\n            perms = factorial(len(word))\\n            for cnt in Counter(word).values():\\n                perms //= factorial(cnt)\\n\\n            return perms\\n\\n        return reduce(lambda a, b: a * get_perms(b) % MOD, s.split(), 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014315,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int power(long long base, long long p) {\\n        long long res = 1;\\n        while (p > 0) {\\n            if (p & 1) {\\n                res = (res * base) % mod;\\n            }\\n            base = (base * base) % mod;\\n            p /= 2;\\n        }\\n        return res;\\n    }\\n    int countAnagrams(string s) {\\n        int n = s.size();\\n        long long sol = 1;\\n        vector<long long> fac(n + 1);\\n        fac[0] = 1;\\n        for (int i = 1; i < n + 1; i++) {\\n            fac[i] = (fac[i - 1] * i) % mod;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int j = i;\\n            vector<int> freq(26);\\n            while (j < n && s[j] != \\' \\') {\\n                ++freq[s[j] - \\'a\\'];\\n                ++j;\\n            }\\n            long long res = 1;\\n            for (int j = 0; j < 26; j++) {\\n                res = (res * fac[freq[j]]) % mod;\\n            }\\n            long long len = j - i;\\n            long long inv = power(res, mod - 2);\\n            sol = (sol * ((fac[len] * inv) % mod)) % mod;\\n            i = j;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int power(long long base, long long p) {\\n        long long res = 1;\\n        while (p > 0) {\\n            if (p & 1) {\\n                res = (res * base) % mod;\\n            }\\n            base = (base * base) % mod;\\n            p /= 2;\\n        }\\n        return res;\\n    }\\n    int countAnagrams(string s) {\\n        int n = s.size();\\n        long long sol = 1;\\n        vector<long long> fac(n + 1);\\n        fac[0] = 1;\\n        for (int i = 1; i < n + 1; i++) {\\n            fac[i] = (fac[i - 1] * i) % mod;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int j = i;\\n            vector<int> freq(26);\\n            while (j < n && s[j] != \\' \\') {\\n                ++freq[s[j] - \\'a\\'];\\n                ++j;\\n            }\\n            long long res = 1;\\n            for (int j = 0; j < 26; j++) {\\n                res = (res * fac[freq[j]]) % mod;\\n            }\\n            long long len = j - i;\\n            long long inv = power(res, mod - 2);\\n            sol = (sol * ((fac[len] * inv) % mod)) % mod;\\n            i = j;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006018,
                "title": "mathematical-solution-permutations-getting-around-big-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe know that given $n$ elements, with possible duplicate elements, the number of permutations is given by:\\n$$ num\\\\_perms = \\\\frac{n!}{n_1! n_2! ...n_k! }$$\\nwhere $n_1, ...n_k$ are the counts of all the duplicates.\\n\\nFor example, in the word \\'mathematics\\', the permutation count is:\\n$$\\\\frac{11!}{2!2!2!} = 4989600$$\\nSince total length is 11, and \\'m\\', \\'a\\' and \\'t\\' are repeated 2 times each. \\n\\nNow, the number of total permutations across an entire *sentence* is simply the product of the number of permutations per word.\\n\\n$$num\\\\_perms = \\\\prod_{w\\\\in W} p(w)$$\\n\\nwhere $W$ is the set of all words (the entire sentence), $w$ is the current word, and $p(.)$ denotes the number of permutations of.\\n\\n\\nThe mathematical idea is simple enough, but one thing gets in the way: integer overflow. Factorials can easily get huge, and overflow the int32 limit $[-2147483648, 2147483647]$. For example, just $13!$ alone is already exceeding the int32 limit.\\n\\nFor this, some helpful formulae are:\\n$$(a \\\\times b) \\\\mod p = ((a\\\\mod p)\\\\times(b \\\\mod p)) \\\\mod p$$\\n$$(a / b) \\\\mod p = ((a\\\\mod p)\\\\times(b^{-1} \\\\mod p)) \\\\mod p$$\\n\\n$b^{-1}$ denotes the modular multiplicative inverse of $b$ with respect to $p$. This means that:\\n$$ (b \\\\times b^{-1}) \\\\mod p = 1$$\\n\\n## Computing the modular multiplicative inverse\\nWe can model it is a diophantine equation of the following form:\\n$$bx + py = 1$$\\nwhere we are trying to solve for $x$. This should make more sense if we take $\\\\mod p$ of both sides:\\n$$bx \\\\mod p + py \\\\mod p = 1 \\\\mod p $$\\n$$bx \\\\mod p = 1$$\\n\\nRecall we can use the **extended Euclidean algorithm** to compute the solution of a diophantine equation. This solution only exists if $b$ and $p$ are coprime ($gcd(b,p) = 1$). Now since $p = 1e9 + 7$ is a prime number and we always try to keep $b<p$, they are guaranteed to be corprime and so a solution should exist (Bezout\\'s lemma).\\n\\nAs a quick reminder, extended Euclidean algorithm can be done recursively with recursion pattern:\\n$$x_1 = y_0 - \\\\frac{p}{b} x_0$$\\n$$y_1 = x_0 $$\\nuntil termination condition is reached ($b = 0$).\\n\\n## Computing the answer\\nWe use C++\\'s built-in `stringstream` to automatically delimit by whitespace and extract each word in a sentence. \\n\\nThen, we take each word and use the mathematical formula presented before, but in a \\'rolling modulo\\' manner.\\n\\n1. We start with the numerator, and compute the factorial of it, with rolling modulo as we go.\\n2. Then we go through all the duplicated letters in the word, and compute the denominator by multiplying the factorials of each duplicate letter\\'s frequency.\\n3. Then, get modular multiplicative inverse of the denominator\\n4. Multiply the numerator with the modular multiplicative inverse of the denominator, and modulo the result (rolling modulo).\\n5. Multiply onto a \\'total result\\' number, and rolling modulo that too.\\n\\nTo make factorialling more efficient, we cache the results, and everytime a larger factorial is required, we compute it by taking the highest factorial so far and multiplying larger numbers until we reach the required value - this saves having to recompute factorials when results exist.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define BASE 1000000007\\n\\n    pair<int,pair<int,int>> extendedEuclidean(const int& a, const int& b) {\\n        /* terminal case */\\n        if (a == 0) {\\n            return std::make_pair(b, make_pair(0, 1));\\n        }\\n\\n        auto res = extendedEuclidean(b % a, a);\\n\\n        int x = res.second.first;\\n        int y = res.second.second;\\n\\n        return make_pair(res.first /* gcd */\\n                        ,make_pair(y - (b / a) * x /* x, one tier up */\\n                                  ,x /* y, one tier up */\\n                                  )\\n                             );\\n    }\\n    \\n    int modularMultInverse(int A, int M) {\\n\\n        /* such a multiplicative inverse can only exist \\n         * if A and M are coprime */\\n        if (gcd(A, M) != 1) return -1;\\n\\n        auto retval = extendedEuclidean(A, M);\\n\\n        /* bring in range of 1 to M-1 (no negatives) */\\n        auto ret = retval.second.first;\\n        ret = (ret % M + M) % M;\\n\\n        return ret; /* x */\\n    }\\n    \\n    int countAnagrams(string s) {\\n        // there is a mathematical solution to this:\\n        // number of permutations in a single string is (length()!) / foreach_repeat!* each other \\n        // e.g. \\'too\\' is 3!/2!.\\n        \\n        // use dp so we dont have to recompute factorials. max possible word length is 1e5\\n        unordered_map<int,long long> umFacts;\\n        \\n        umFacts[1] = 1;\\n        umFacts[2] = 2;\\n        umFacts[3] = 6;\\n        \\n        int cachedMax = 3;\\n        \\n        stringstream ss(s);\\n        string word;\\n        \\n        long long res = 1;\\n        \\n        while (ss>>word){\\n            unordered_map<int,int> freqmap;\\n            for (const auto& ch:word) freqmap[ch]++;\\n            \\n            long long numAnagrams;\\n            \\n            if (!umFacts.count(word.length())) {\\n                for (int i=cachedMax+1;i<=word.length();++i){\\n                    umFacts[i] = umFacts[i - 1] * i;\\n                    umFacts[i] %= BASE; // hack\\n                }\\n                \\n                cachedMax = word.length();\\n            } \\n            \\n            numAnagrams = umFacts[word.length()]; // numerator\\n            \\n            \\n            long long denom = 1;\\n            \\n            // now divide repetitions.\\n            for (auto& f:freqmap) {\\n                if (f.second > 1) {\\n                    denom *= umFacts[f.second];\\n                    denom %= BASE;\\n                }\\n            }\\n            \\n            // find modular multiplicative inverse of denom\\n            long long mmI = modularMultInverse(denom, BASE);\\n            \\n            mmI %= BASE;\\n            \\n            numAnagrams *= mmI;\\n            numAnagrams %= BASE;\\n            \\n            res *= numAnagrams;\\n            res %= BASE; // rolling modulo\\n        }\\n        \\n        return (int) res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define BASE 1000000007\\n\\n    pair<int,pair<int,int>> extendedEuclidean(const int& a, const int& b) {\\n        /* terminal case */\\n        if (a == 0) {\\n            return std::make_pair(b, make_pair(0, 1));\\n        }\\n\\n        auto res = extendedEuclidean(b % a, a);\\n\\n        int x = res.second.first;\\n        int y = res.second.second;\\n\\n        return make_pair(res.first /* gcd */\\n                        ,make_pair(y - (b / a) * x /* x, one tier up */\\n                                  ,x /* y, one tier up */\\n                                  )\\n                             );\\n    }\\n    \\n    int modularMultInverse(int A, int M) {\\n\\n        /* such a multiplicative inverse can only exist \\n         * if A and M are coprime */\\n        if (gcd(A, M) != 1) return -1;\\n\\n        auto retval = extendedEuclidean(A, M);\\n\\n        /* bring in range of 1 to M-1 (no negatives) */\\n        auto ret = retval.second.first;\\n        ret = (ret % M + M) % M;\\n\\n        return ret; /* x */\\n    }\\n    \\n    int countAnagrams(string s) {\\n        // there is a mathematical solution to this:\\n        // number of permutations in a single string is (length()!) / foreach_repeat!* each other \\n        // e.g. \\'too\\' is 3!/2!.\\n        \\n        // use dp so we dont have to recompute factorials. max possible word length is 1e5\\n        unordered_map<int,long long> umFacts;\\n        \\n        umFacts[1] = 1;\\n        umFacts[2] = 2;\\n        umFacts[3] = 6;\\n        \\n        int cachedMax = 3;\\n        \\n        stringstream ss(s);\\n        string word;\\n        \\n        long long res = 1;\\n        \\n        while (ss>>word){\\n            unordered_map<int,int> freqmap;\\n            for (const auto& ch:word) freqmap[ch]++;\\n            \\n            long long numAnagrams;\\n            \\n            if (!umFacts.count(word.length())) {\\n                for (int i=cachedMax+1;i<=word.length();++i){\\n                    umFacts[i] = umFacts[i - 1] * i;\\n                    umFacts[i] %= BASE; // hack\\n                }\\n                \\n                cachedMax = word.length();\\n            } \\n            \\n            numAnagrams = umFacts[word.length()]; // numerator\\n            \\n            \\n            long long denom = 1;\\n            \\n            // now divide repetitions.\\n            for (auto& f:freqmap) {\\n                if (f.second > 1) {\\n                    denom *= umFacts[f.second];\\n                    denom %= BASE;\\n                }\\n            }\\n            \\n            // find modular multiplicative inverse of denom\\n            long long mmI = modularMultInverse(denom, BASE);\\n            \\n            mmI %= BASE;\\n            \\n            numAnagrams *= mmI;\\n            numAnagrams %= BASE;\\n            \\n            res *= numAnagrams;\\n            res %= BASE; // rolling modulo\\n        }\\n        \\n        return (int) res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003183,
                "title": "counting-with-python-pow-function",
                "content": "# Approach\\nI just wanted to show the python builtin function ```pow(a, b, mod)``` that compute ```a ^ b % mod``` with logarithmic time complexity as we want. The solution idea is like other solutions posted by others using fermat\\'s theorem(inverse module).\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = int(1e9 + 7)\\n        fact = [1, 1]\\n        inv_fact = [1, 1]\\n        for i in range(2, len(s) + 1):\\n            fact.append((fact[-1] * i) % mod)\\n            inv_fact.append((inv_fact[-1] * pow(i, mod - 2, mod)) % mod)\\n\\n        def count_anagrams(word):\\n            ans = fact[len(word)]\\n            cnt = Counter(word)\\n            for v in cnt.values():\\n                ans = (ans * inv_fact[v]) % mod\\n            return ans\\n\\n        res = 1\\n        for word in s.split():\\n            res = (res * count_anagrams(word)) % mod\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```pow(a, b, mod)```\n```a ^ b % mod```\n```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = int(1e9 + 7)\\n        fact = [1, 1]\\n        inv_fact = [1, 1]\\n        for i in range(2, len(s) + 1):\\n            fact.append((fact[-1] * i) % mod)\\n            inv_fact.append((inv_fact[-1] * pow(i, mod - 2, mod)) % mod)\\n\\n        def count_anagrams(word):\\n            ans = fact[len(word)]\\n            cnt = Counter(word)\\n            for v in cnt.values():\\n                ans = (ans * inv_fact[v]) % mod\\n            return ans\\n\\n        res = 1\\n        for word in s.split():\\n            res = (res * count_anagrams(word)) % mod\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003138,
                "title": "java-math",
                "content": "# 2.Math\\n```\\n   private int modulo = 1_000_000_007;\\n\\n    //2.Math\\n    //https://cp-algorithms.com/algebra/module-inverse.html#finding-the-modular-inverse-using-extended-euclidean-algorithm\\n    //(a / b) % mod != (a % mod) / ( b % mod)\\n    //(A / B) % mod = A * ( B ^ -1 ) % mod\\n    //Runtime: 80ms 68%; Memory: 70.5MB 5%\\n    //Time: O(N); Space: O(N)\\n    public int countAnagrams(String s) {\\n        long[] factorial = new long[s.length() + 1];\\n        long[] inv = new long[s.length() + 1];\\n        long[] ifac = new long[s.length() + 1];\\n        factorial[1] =  inv[1] = ifac[1] = 1;\\n        for (int i = 2; i <= s.length(); i++) {\\n            factorial[i] = (factorial[i - 1] * i) % modulo;\\n\\n            inv[i] = modulo - modulo / i * inv[modulo % i] % modulo;\\n            ifac[i] = ifac[i - 1] * inv[i] % modulo;\\n        }\\n\\n        long res = 1;\\n        int total = 0;\\n        int[] counter = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != \\' \\'){\\n                counter[s.charAt(i) - \\'a\\']++;\\n                total++;\\n            }\\n\\n            if (i == s.length() - 1 || s.charAt(i) == \\' \\') {\\n\\n                long currRes = factorial[total];\\n                // ( a! / b! ) % modulo\\n                for (int j = 0; j < counter.length; j++) {\\n                    if (counter[j] > 1)\\n                        currRes = currRes * ifac[counter[j]] % modulo;\\n                }\\n\\n                res = res * currRes % modulo;\\n                counter = new int[26];\\n                total = 0;\\n            }\\n        }\\n        return (int)res;\\n    }\\n\\n```\\n1.Math BigInteger.modInverse\\n```\\n    //1.Math BigInteger.modInverse\\n    // a / b != (a % mod) / (b % mod)\\n    //Runtime: 40ms 90%; Memory: 60.3MB 9%\\n    //Time: O(N); Space: O(N)\\n    public int countAnagrams_1(String s) {\\n\\n        long[] factorial = new long[s.length() + 1];\\n        factorial[1] = 1;\\n        for (int i = 2; i <= s.length(); i++)\\n            factorial[i] = (factorial[i - 1] * i) % modulo;\\n\\n        long res = 1;\\n        int total = 0;\\n        int[] counter = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != \\' \\'){\\n                counter[s.charAt(i) - \\'a\\']++;\\n                total++;\\n            }\\n\\n            if (i == s.length() - 1 || s.charAt(i) == \\' \\'){\\n                res = res * helper(factorial, counter, total) % modulo;\\n                counter = new int[26];\\n                total = 0;\\n            }\\n        }\\n        return (int)res;\\n    }\\n\\n    //a! / b!\\n    // BigInteger.modInverse\\n    private long helper(long[] factorial, int[] counter, int total){\\n        long res = factorial[total];\\n        for (int i = 0; i < counter.length; i++) {\\n            if (counter[i] > 1)\\n                res = res * BigInteger.valueOf(factorial[counter[i]]).modInverse(BigInteger.valueOf(modulo)).longValue()  % modulo;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n   private int modulo = 1_000_000_007;\\n\\n    //2.Math\\n    //https://cp-algorithms.com/algebra/module-inverse.html#finding-the-modular-inverse-using-extended-euclidean-algorithm\\n    //(a / b) % mod != (a % mod) / ( b % mod)\\n    //(A / B) % mod = A * ( B ^ -1 ) % mod\\n    //Runtime: 80ms 68%; Memory: 70.5MB 5%\\n    //Time: O(N); Space: O(N)\\n    public int countAnagrams(String s) {\\n        long[] factorial = new long[s.length() + 1];\\n        long[] inv = new long[s.length() + 1];\\n        long[] ifac = new long[s.length() + 1];\\n        factorial[1] =  inv[1] = ifac[1] = 1;\\n        for (int i = 2; i <= s.length(); i++) {\\n            factorial[i] = (factorial[i - 1] * i) % modulo;\\n\\n            inv[i] = modulo - modulo / i * inv[modulo % i] % modulo;\\n            ifac[i] = ifac[i - 1] * inv[i] % modulo;\\n        }\\n\\n        long res = 1;\\n        int total = 0;\\n        int[] counter = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != \\' \\'){\\n                counter[s.charAt(i) - \\'a\\']++;\\n                total++;\\n            }\\n\\n            if (i == s.length() - 1 || s.charAt(i) == \\' \\') {\\n\\n                long currRes = factorial[total];\\n                // ( a! / b! ) % modulo\\n                for (int j = 0; j < counter.length; j++) {\\n                    if (counter[j] > 1)\\n                        currRes = currRes * ifac[counter[j]] % modulo;\\n                }\\n\\n                res = res * currRes % modulo;\\n                counter = new int[26];\\n                total = 0;\\n            }\\n        }\\n        return (int)res;\\n    }\\n\\n```\n```\\n    //1.Math BigInteger.modInverse\\n    // a / b != (a % mod) / (b % mod)\\n    //Runtime: 40ms 90%; Memory: 60.3MB 9%\\n    //Time: O(N); Space: O(N)\\n    public int countAnagrams_1(String s) {\\n\\n        long[] factorial = new long[s.length() + 1];\\n        factorial[1] = 1;\\n        for (int i = 2; i <= s.length(); i++)\\n            factorial[i] = (factorial[i - 1] * i) % modulo;\\n\\n        long res = 1;\\n        int total = 0;\\n        int[] counter = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != \\' \\'){\\n                counter[s.charAt(i) - \\'a\\']++;\\n                total++;\\n            }\\n\\n            if (i == s.length() - 1 || s.charAt(i) == \\' \\'){\\n                res = res * helper(factorial, counter, total) % modulo;\\n                counter = new int[26];\\n                total = 0;\\n            }\\n        }\\n        return (int)res;\\n    }\\n\\n    //a! / b!\\n    // BigInteger.modInverse\\n    private long helper(long[] factorial, int[] counter, int total){\\n        long res = factorial[total];\\n        for (int i = 0; i < counter.length; i++) {\\n            if (counter[i] > 1)\\n                res = res * BigInteger.valueOf(factorial[counter[i]]).modInverse(BigInteger.valueOf(modulo)).longValue()  % modulo;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2999289,
                "title": "time-complexity-o-length-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFermat\\'s little theorem , Modular multiplicative inverse , Binary Exponentiation\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nc=1000000007\\n\\n(C a get b)%c=(a!/b!/(a-b)!)%c=a!%c * Mod_inverse(b!)%c * Mod_inverse((a-b)!)%c\\n\\nMod_inverse(num)=pow(num,c-2)%c (Fermat\\'s little theorem)\\nuse Binary Exponentiation to get pow(num,c-2)%c in O(1)\\n\\ncost O( length(s) ) to get (0!~length(s)!)%c and Mod_inverse(0!~length(s)!)%c\\n\\ncost O(1) to get (C a get b)%c\\n\\ncost O( length(s) ) to iterate s and compute answer\\n# Complexity\\n- Time complexity:O( length(s) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O( length(s) )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long qpow(long long a,long long b)//a^b\\n    {\\n        long long sum=1;\\n        while(b!=0)\\n        {\\n            if(b%2==1)\\n                sum=sum*a%1000000007;\\n            b/=2;\\n            a=a*a%1000000007;\\n        }\\n        return sum;\\n    }\\n    int countAnagrams(string s) {\\n        s+=\" \";\\n        int n=s.size();\\n        int a,last,space,b;\\n        long long lev[n+1],nlev[n+1],ans=1;\\n        int alpha[26],si=sizeof(alpha);\\n        lev[0]=nlev[0]=1;\\n        for(a=1;a<=n;a++)\\n        {\\n            lev[a]=lev[a-1]*a%1000000007;\\n            nlev[a]=nlev[a-1]*qpow(a,1000000005)%1000000007;\\n        }\\n        memset(alpha,0,si);\\n        last=-1;\\n        for(a=0;a<n;a++)\\n        {\\n            if(s[a]==\\' \\')\\n            {\\n                space=a-last-1;\\n                for(b=0;b<26 && space>1;b++)//c space get alpha[b]\\n                {\\n                    ans=ans*lev[space]%1000000007*nlev[space-alpha[b]]%1000000007*nlev[alpha[b]]%1000000007;\\n                    space-=alpha[b];\\n                }\\n                memset(alpha,0,si);\\n                last=a;\\n            }\\n            else\\n                alpha[s[a]-97]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Combinatorics",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long qpow(long long a,long long b)//a^b\\n    {\\n        long long sum=1;\\n        while(b!=0)\\n        {\\n            if(b%2==1)\\n                sum=sum*a%1000000007;\\n            b/=2;\\n            a=a*a%1000000007;\\n        }\\n        return sum;\\n    }\\n    int countAnagrams(string s) {\\n        s+=\" \";\\n        int n=s.size();\\n        int a,last,space,b;\\n        long long lev[n+1],nlev[n+1],ans=1;\\n        int alpha[26],si=sizeof(alpha);\\n        lev[0]=nlev[0]=1;\\n        for(a=1;a<=n;a++)\\n        {\\n            lev[a]=lev[a-1]*a%1000000007;\\n            nlev[a]=nlev[a-1]*qpow(a,1000000005)%1000000007;\\n        }\\n        memset(alpha,0,si);\\n        last=-1;\\n        for(a=0;a<n;a++)\\n        {\\n            if(s[a]==\\' \\')\\n            {\\n                space=a-last-1;\\n                for(b=0;b<26 && space>1;b++)//c space get alpha[b]\\n                {\\n                    ans=ans*lev[space]%1000000007*nlev[space-alpha[b]]%1000000007*nlev[alpha[b]]%1000000007;\\n                    space-=alpha[b];\\n                }\\n                memset(alpha,0,si);\\n                last=a;\\n            }\\n            else\\n                alpha[s[a]-97]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997077,
                "title": "python3-permutation-with-repetitions-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key idea is the count of permutation of a string with n0 a, n1 b, ..., n25 z is $$(\\u2211ni)!/\\u220Fni!$$\\n\\n# Code\\n```\\nfrom collections import Counter\\nfrom math import factorial\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        ans, MOD = 1, 10 ** 9 + 7\\n        for w in s.split(\\' \\'):\\n            cur = factorial(len(w))\\n            for v in Counter(w).values(): cur //= factorial(v)\\n            ans = (ans * cur) % MOD\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nfrom math import factorial\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        ans, MOD = 1, 10 ** 9 + 7\\n        for w in s.split(\\' \\'):\\n            cur = factorial(len(w))\\n            for v in Counter(w).values(): cur //= factorial(v)\\n            ans = (ans * cur) % MOD\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995114,
                "title": "java-solution-biginteger",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn case you may not be familiar with theorems of primes. Let\\'s try to solve it without complicated theorems. The problem turns to how to get the result from an ordered string by the result of substring of (0, len-1). e.g. get the result from `aaabbcc` by `aaabbc`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a length 26 array to represent the string.\\nTo get the result from result `b` of substring of (0, len-1) will be`b*len/j`, while `j` is repeating count of the incoming charater. \\ne.g.\\n`aaabb` > `aaabbb` = `10*6/3` = `20`\\n`aaabb` > `aaabbc` = `10*6/1` = `60`\\nTo calculate the division directly, you can use `BigInteger`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time will be costed for `BigInteger` operations.\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAnagrams(String s) {\\n        String[] words = s.split(\" \");\\n        long rst = 1L;\\n        for (String word : words) {\\n            int[] arr = new int[26];\\n            for (char c : word.toCharArray()) arr[c - \\'a\\']++;\\n            rst = rst * calc(0, arr, 0, 1) % MOD;\\n        }\\n        return (int) rst;\\n    }\\n\\n    int MOD = 1_000_000_007;\\n    java.math.BigInteger MOD_BI = new java.math.BigInteger(String.valueOf(MOD));\\n\\n    long calc(int i, int[] arr, int len, long cur) {\\n        if (i >= arr.length) return cur;\\n        java.math.BigInteger b = new java.math.BigInteger(String.valueOf(cur));\\n        for (int j = 0; j < arr[i]; j++, len++) \\n            b = b.multiply(new java.math.BigInteger(String.valueOf(len + 1))).divide(new java.math.BigInteger(String.valueOf(j + 1)));\\n        return calc(i + 1, arr, len, b.mod(MOD_BI).longValue());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int countAnagrams(String s) {\\n        String[] words = s.split(\" \");\\n        long rst = 1L;\\n        for (String word : words) {\\n            int[] arr = new int[26];\\n            for (char c : word.toCharArray()) arr[c - \\'a\\']++;\\n            rst = rst * calc(0, arr, 0, 1) % MOD;\\n        }\\n        return (int) rst;\\n    }\\n\\n    int MOD = 1_000_000_007;\\n    java.math.BigInteger MOD_BI = new java.math.BigInteger(String.valueOf(MOD));\\n\\n    long calc(int i, int[] arr, int len, long cur) {\\n        if (i >= arr.length) return cur;\\n        java.math.BigInteger b = new java.math.BigInteger(String.valueOf(cur));\\n        for (int j = 0; j < arr[i]; j++, len++) \\n            b = b.multiply(new java.math.BigInteger(String.valueOf(len + 1))).divide(new java.math.BigInteger(String.valueOf(j + 1)));\\n        return calc(i + 1, arr, len, b.mod(MOD_BI).longValue());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990882,
                "title": "c-fast-inverse-modulo-explanation-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n(a / b) % mod != (a% mod) / (b% mod). \\nSo here we use Modular Multiplicative Inverse, i.e (A / B) % mod = A * ( B ^ -1 ) % mod\\n A * ( B ^ -1 ) % mod = (A * (B ^ (mod-2) ) ) % mod  only if mod is prime.\\n if mod is not prime and ( B and mod ) is coprime then there is little change in the above expression.\\n \\n Remember we can compute pow( B , mod-2 ) using binary exponentiation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    long long ans = 1;\\n    long long inv(long long i) {\\n        if (i == 1) return 1; \\n        return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;\\n    }\\npublic:\\n    int fact(int num){\\n        long long mul = 1;\\n        for(int i = 2; i <= num; i++){\\n            mul = (mul%mod * i%mod)%mod;\\n        }\\n        return mul%mod;\\n    }\\n    int countAnagrams(string s) {\\n        stringstream ss(s);\\n        string word;\\n        vector<string> v;\\n        while(ss >> word){\\n            v.push_back(word);\\n        }\\n        long long ans = 1;\\n        for(int i = 0; i < v.size(); i++){\\n            vector<int> hsh(26,0);\\n            long long mul = fact(v[i].size());\\n            for(char ch: v[i]){\\n                hsh[ch-\\'a\\']++;\\n            }\\n            for(int i = 0; i < 26; i++){\\n                if(hsh[i] > 1){\\n                    mul = mul*inv(fact(hsh[i]));\\n                    mul%=mod;\\n                }\\n            }\\n            // cout << mul << \"*\";\\n            ans %= mod;\\n            ans *= mul;\\n            ans %= mod; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    long long ans = 1;\\n    long long inv(long long i) {\\n        if (i == 1) return 1; \\n        return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;\\n    }\\npublic:\\n    int fact(int num){\\n        long long mul = 1;\\n        for(int i = 2; i <= num; i++){\\n            mul = (mul%mod * i%mod)%mod;\\n        }\\n        return mul%mod;\\n    }\\n    int countAnagrams(string s) {\\n        stringstream ss(s);\\n        string word;\\n        vector<string> v;\\n        while(ss >> word){\\n            v.push_back(word);\\n        }\\n        long long ans = 1;\\n        for(int i = 0; i < v.size(); i++){\\n            vector<int> hsh(26,0);\\n            long long mul = fact(v[i].size());\\n            for(char ch: v[i]){\\n                hsh[ch-\\'a\\']++;\\n            }\\n            for(int i = 0; i < 26; i++){\\n                if(hsh[i] > 1){\\n                    mul = mul*inv(fact(hsh[i]));\\n                    mul%=mod;\\n                }\\n            }\\n            // cout << mul << \"*\";\\n            ans %= mod;\\n            ans *= mul;\\n            ans %= mod; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2984791,
                "title": "simple-c-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    long inverse(long num) { // a * inverse(b) % mod == a / b % mod\\n        if (num == 1) {\\n            return 1;\\n        }\\n        return mod - mod / num * inverse(mod % num) % mod;\\n    }\\n    long fac(int N) { //factory of N\\n        long res = 1;\\n        for (int i = 1; i <= N; i++) {\\n            res = res * i % mod;\\n        }\\n        return res;\\n    }\\n    int count(string s) { // count for one substring\\n        int N = s.size();\\n        long res = fac(N);\\n        vector<int> freq(26);\\n        for (auto c : s) {\\n            freq[c - \\'a\\']++;\\n        }\\n        for (auto num : freq) {\\n            res *= inverse(fac(num));\\n            res %= mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        string s0;\\n        stringstream ss(s);\\n        long res = 1;\\n        while(ss >> s0) {\\n            res = res * count(s0) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    long inverse(long num) { // a * inverse(b) % mod == a / b % mod\\n        if (num == 1) {\\n            return 1;\\n        }\\n        return mod - mod / num * inverse(mod % num) % mod;\\n    }\\n    long fac(int N) { //factory of N\\n        long res = 1;\\n        for (int i = 1; i <= N; i++) {\\n            res = res * i % mod;\\n        }\\n        return res;\\n    }\\n    int count(string s) { // count for one substring\\n        int N = s.size();\\n        long res = fac(N);\\n        vector<int> freq(26);\\n        for (auto c : s) {\\n            freq[c - \\'a\\']++;\\n        }\\n        for (auto num : freq) {\\n            res *= inverse(fac(num));\\n            res %= mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        string s0;\\n        stringstream ss(s);\\n        long res = 1;\\n        while(ss >> s0) {\\n            res = res * count(s0) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981597,
                "title": "java-solution-using-binary-exponentiation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can simply find the number of permutations for each string and multiply them together.\\n\\n# Complexity\\n- Time complexity:O(10^5 + n * log (10^9))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(10^5)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\n    long mod=1000000007L;\\n     public long pow(long n,long base)\\n     {\\n         long ans=1;\\n         while(n>0)\\n         {\\n             if(n%2==1)\\n             {\\n                 ans=(ans*base)%mod;\\n             }\\n              n>>=1;\\n             base=(base*base)%mod;\\n            \\n\\n         }\\n         return ans;\\n\\n     }\\n     public long inv(long n)\\n     {\\n         return pow(mod-2,n);\\n     }\\n     long [] fact;\\n    public long ways(String word)\\n    {\\n        int [] a=new int[26];\\n        for(int i=0;i<word.length();i++)\\n        {\\n            a[word.charAt(i)-\\'a\\']++;\\n        }\\n        int n=word.length();\\n        long ans=fact[n];\\n        for(int i=0;i<26;i++)\\n       {\\n           if(a[i]>0)\\n           {\\n               int s=a[i];\\n               long fac=fact[s];\\n               long jj=inv(fac)%mod;\\n               ans=(1L*ans*jj)%mod;\\n           }\\n       }\\n       return ans;\\n    }\\n    public int countAnagrams(String s) {\\n        fact=new long [s.length()+1];\\n        fact[0]=1L;\\n        int n=s.length();\\n        System.out.println(n);\\n        for(int i=1;i<=n;i++)\\n        {\\n            fact[i]=(1L*i*fact[i-1])%mod;\\n            // System.out.println(fact[i]);\\n        }\\n        String [] words=s.split(\" \");\\n        long res=1;\\n        for(String l:words)\\n        {\\n            System.out.println(l);\\n            res=(res*ways(l))%mod;\\n            // System.out.println(res);\\n        }\\n        res%=mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long mod=1000000007L;\\n     public long pow(long n,long base)\\n     {\\n         long ans=1;\\n         while(n>0)\\n         {\\n             if(n%2==1)\\n             {\\n                 ans=(ans*base)%mod;\\n             }\\n              n>>=1;\\n             base=(base*base)%mod;\\n            \\n\\n         }\\n         return ans;\\n\\n     }\\n     public long inv(long n)\\n     {\\n         return pow(mod-2,n);\\n     }\\n     long [] fact;\\n    public long ways(String word)\\n    {\\n        int [] a=new int[26];\\n        for(int i=0;i<word.length();i++)\\n        {\\n            a[word.charAt(i)-\\'a\\']++;\\n        }\\n        int n=word.length();\\n        long ans=fact[n];\\n        for(int i=0;i<26;i++)\\n       {\\n           if(a[i]>0)\\n           {\\n               int s=a[i];\\n               long fac=fact[s];\\n               long jj=inv(fac)%mod;\\n               ans=(1L*ans*jj)%mod;\\n           }\\n       }\\n       return ans;\\n    }\\n    public int countAnagrams(String s) {\\n        fact=new long [s.length()+1];\\n        fact[0]=1L;\\n        int n=s.length();\\n        System.out.println(n);\\n        for(int i=1;i<=n;i++)\\n        {\\n            fact[i]=(1L*i*fact[i-1])%mod;\\n            // System.out.println(fact[i]);\\n        }\\n        String [] words=s.split(\" \");\\n        long res=1;\\n        for(String l:words)\\n        {\\n            System.out.println(l);\\n            res=(res*ways(l))%mod;\\n            // System.out.println(res);\\n        }\\n        res%=mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974324,
                "title": "python3-multiply-combinatorics-not-factorials-much-faster",
                "content": "[Link to solution](https://leetcode.com/submissions/detail/868443897/)\\n\\n```python\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        \"\"\"\\n        Given \"aaabb\", we have five spots to place \\'a\\' uniquely. There are 5C3\\n        number of ways to do so. Once all \\'a\\'s are settled, we can fill \\'b\\'s\\n        in the remaining two empty spots. There is 2C2 number of ways to do so.\\n        Thus, overall, the number of unique permutation of \"aaabb\" is 5C3 * 2C2\\n        = 10.\\n\\n        Given \"aaaabbbcc\", the number of unique permutation is 9C4 * 5C3 * 2C2.\\n\\n        Thus, the rule is that for each repeated letter, we find the count of\\n        the currently available spots. Say there are r count of repeated letter\\n        and n count of available spots, we multiply nCr. Then we go for the\\n        next repeated letter and continue with the multiplication.\\n\\n        Once the count of unique perm is found for each word, the final result\\n        is just to multiply all the counts.\\n\\n        We can use modular multiplication to avoid large numbers. So the only\\n        benefit Python has is the built-in `math.comb`.\\n        \"\"\"\\n        res = 1\\n        MOD = 10**9 + 7\\n        for word in s.split(\\' \\'):\\n            uniq_perm = 1\\n            n = len(word)\\n            for c in Counter(word).values():\\n                uniq_perm = (uniq_perm * (math.comb(n, c) % MOD)) % MOD\\n                n -= c\\n            res = (res * (uniq_perm % MOD)) % MOD\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```python\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        \"\"\"\\n        Given \"aaabb\", we have five spots to place \\'a\\' uniquely. There are 5C3\\n        number of ways to do so. Once all \\'a\\'s are settled, we can fill \\'b\\'s\\n        in the remaining two empty spots. There is 2C2 number of ways to do so.\\n        Thus, overall, the number of unique permutation of \"aaabb\" is 5C3 * 2C2\\n        = 10.\\n\\n        Given \"aaaabbbcc\", the number of unique permutation is 9C4 * 5C3 * 2C2.\\n\\n        Thus, the rule is that for each repeated letter, we find the count of\\n        the currently available spots. Say there are r count of repeated letter\\n        and n count of available spots, we multiply nCr. Then we go for the\\n        next repeated letter and continue with the multiplication.\\n\\n        Once the count of unique perm is found for each word, the final result\\n        is just to multiply all the counts.\\n\\n        We can use modular multiplication to avoid large numbers. So the only\\n        benefit Python has is the built-in `math.comb`.\\n        \"\"\"\\n        res = 1\\n        MOD = 10**9 + 7\\n        for word in s.split(\\' \\'):\\n            uniq_perm = 1\\n            n = len(word)\\n            for c in Counter(word).values():\\n                uniq_perm = (uniq_perm * (math.comb(n, c) % MOD)) % MOD\\n                n -= c\\n            res = (res * (uniq_perm % MOD)) % MOD\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964530,
                "title": "2514-count-anagrams-c-solution",
                "content": "Solution using Precomputation of factorial values and moduloInverse :-)\\n```cpp\\nclass Solution {\\npublic:\\n    long long int moduloInverse(long long int A, long long int M)\\n    {\\n        int m0 = M;\\n        int y = 0, x = 1;\\n        if (M == 1) return 0;\\n    \\n        while (A > 1) {\\n            int q = A / M;\\n            int t = M;\\n            M = A % M, A = t;\\n            t = y;\\n            y = x - q * y;\\n            x = t;\\n        }\\n        if (x < 0) x += m0;\\n\\n        return x;\\n    }\\n    int countAnagrams(string s) {\\n        long long int MOD = 1e9 + 7;\\n        vector<long long int> fact(100005);\\n        fact[0] = 1;\\n        for(int i = 1; i <= 100000; i++) {\\n            fact[i] = ((fact[i-1] % MOD) * (i % MOD)) % MOD;\\n        }\\n        int ind = 0;\\n        long long int result = 1;\\n        int n = s.size();\\n        while(ind < n) {\\n            vector<int> freq(26, 0);\\n            while(ind < n && s[ind] != \\' \\') {\\n                freq[s[ind] - \\'a\\']++;\\n                ind++;\\n            }\\n            int SIZE = 0;\\n            long long int den = 1;\\n            for(int i = 0; i < 26; i++) {\\n                SIZE += freq[i];\\n                den = ((den % MOD) * (fact[freq[i]] % MOD)) % MOD; \\n            }\\n            \\n            result = ((result % MOD) * ((fact[SIZE] % MOD) * (moduloInverse(den, MOD) % MOD) % MOD)) % MOD;\\n            ind++;\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long int moduloInverse(long long int A, long long int M)\\n    {\\n        int m0 = M;\\n        int y = 0, x = 1;\\n        if (M == 1) return 0;\\n    \\n        while (A > 1) {\\n            int q = A / M;\\n            int t = M;\\n            M = A % M, A = t;\\n            t = y;\\n            y = x - q * y;\\n            x = t;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2961168,
                "title": "c-permutation-and-combination",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7 ; \\n    #define ll long long int \\n    ll fact[100007];\\n    long long f=1;\\n   \\n    void solve(){\\n    for(int i = 1 ; i <= 100005;i++){\\n        f=(f*i)%mod;\\n        fact[i]=f;   \\n    }\\n    }\\n    \\n    ll binaryexp(int a,int b,int m){\\n        ll res=1;\\n        while(b>0){\\n            if(b%2==1){\\n                res=((1ll)*res*a)%m;\\n            }\\n            a=((1ll)*a*a)%mod;\\n            b=b>>1;\\n        }\\n        return res;\\n    }\\n\\n    \\n    int countAnagrams(string s) {\\n        ll ans = 1 ; \\n        solve();\\n        istringstream ss(s); \\n        string word;\\n        while(ss >> word){\\n            map<char,int>mp;\\n            for(auto i : word)\\n                mp[i]++;\\n            \\n            int sz = word.size();\\n            ll numerator = fact[sz];\\n            ll denominator = 1; \\n            for(auto j : mp){\\n                denominator = (denominator*fact[j.second])%mod;\\n                \\n            }\\n            denominator = binaryexp(denominator,mod-2,mod);\\n            ll res = (numerator*denominator)%mod ; \\n            ans = (ans * res)%mod;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mod = 1e9 + 7 ; \\n    #define ll long long int \\n    ll fact[100007];\\n    long long f=1;\\n   \\n    void solve(){\\n    for(int i = 1 ; i <= 100005;i++){\\n        f=(f*i)%mod;\\n        fact[i]=f;   \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2959856,
                "title": "python-one-line",
                "content": "# Intuition\\nCombinatorics 101\\n\\n# Approach\\nCombinatorics 101\\n\\n# Complexity\\n- Time complexity:\\nO(A Christmas Mystery)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        return reduce(lambda result, w: (result * reduce(lambda x,y: x//factorial(y), Counter(w).values(), factorial(len(w)))) % (10**9 + 7), s.split(), 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        return reduce(lambda result, w: (result * reduce(lambda x,y: x//factorial(y), Counter(w).values(), factorial(len(w)))) % (10**9 + 7), s.split(), 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959725,
                "title": "javascript-solution-need-math-knowledge-and-bigint-class",
                "content": "# Intuition\\nThe final result is from multipling each word result.\\nFor a word (splitted by space), we count the frequence of characters and calculate result for that word.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAnagrams = function (s) {\\n  const BIGINT_MODULO = BigInt(Math.pow(10, 9) + 7);\\n  function countWord(word) {\\n    let map = new Map();\\n    for (let c of word) {\\n      let cnt = map.get(c) || 0;\\n      cnt++;\\n      map.set(c, cnt);\\n    }\\n\\n    if (map.size === 1) return 1n;\\n    else {\\n      let finalResult = 1n;\\n      let cnts = Array.from(map.values())\\n        .sort((a, b) => a - b)\\n        .map((val) => BigInt(val));\\n      let sum = BigInt(word.length);\\n      let choice = sum;\\n\\n      for (let i = 0; i < cnts.length - 1; i++) {\\n        let cnt = cnts[i];\\n        let combinations = 1n;\\n        let devisor = 1n;\\n        while (cnt > 0n) {\\n          combinations *= choice--;\\n          devisor *= cnt;\\n          cnt--;\\n        }\\n        finalResult *= combinations / devisor;\\n      }\\n\\n      return finalResult;\\n    }\\n  }\\n\\n  let ans = 1n;\\n  for (let word of s.split(\" \")) {\\n    ans *= countWord(word);\\n    ans %= BIGINT_MODULO;\\n  }\\n\\n  return Number(ans);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAnagrams = function (s) {\\n  const BIGINT_MODULO = BigInt(Math.pow(10, 9) + 7);\\n  function countWord(word) {\\n    let map = new Map();\\n    for (let c of word) {\\n      let cnt = map.get(c) || 0;\\n      cnt++;\\n      map.set(c, cnt);\\n    }\\n\\n    if (map.size === 1) return 1n;\\n    else {\\n      let finalResult = 1n;\\n      let cnts = Array.from(map.values())\\n        .sort((a, b) => a - b)\\n        .map((val) => BigInt(val));\\n      let sum = BigInt(word.length);\\n      let choice = sum;\\n\\n      for (let i = 0; i < cnts.length - 1; i++) {\\n        let cnt = cnts[i];\\n        let combinations = 1n;\\n        let devisor = 1n;\\n        while (cnt > 0n) {\\n          combinations *= choice--;\\n          devisor *= cnt;\\n          cnt--;\\n        }\\n        finalResult *= combinations / devisor;\\n      }\\n\\n      return finalResult;\\n    }\\n  }\\n\\n  let ans = 1n;\\n  for (let word of s.split(\" \")) {\\n    ans *= countWord(word);\\n    ans %= BIGINT_MODULO;\\n  }\\n\\n  return Number(ans);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2958209,
                "title": "c-commented",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mod=1e9+7;\\n\\t\\tint fact[100002];\\n    \\n\\t\\tint modmul(int a,int b){    //  function to multiply two very large numbers \\n\\t\\t\\treturn((long long)(a%mod)*(b%mod))%mod;\\n\\t\\t}\\n\\n\\t\\tint binExpo(int a,int b){    // function to calculate modular multiplicative inverse ( b ^ -1 ) % mod\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\twhile( b > 0 ){\\n\\t\\t\\t\\tif( b & 1 ) ans = modmul( ans, a ); \\n\\t\\t\\t\\ta = modmul( a, a);\\n\\t\\t\\t\\tb = b / 2;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tint modmulinv(int a){              // ( a/b ) % mod  ! = ( a % mod ) / ( b % mod )\\n\\t\\t\\treturn binExpo(a,mod-2);       // ( a/b ) % mod  =  a * ( b ^ -1 ) % mod  \\n\\t\\t}              // if mod is prime then   ( b ^ -1 ) % mod = ( b ^ mod-2 )      and    a * ( b ^ -1 ) % mod  =  a * ( b ^ mod-2 )\\n\\n\\t\\tvoid getfact() {    // function to track all the factorial of nums from 0 to 100000\\n\\t\\t\\tfact[0]=1;\\n\\t\\t\\tfor(int i=1;i<=100001;i++){\\n\\t\\t\\t\\tfact[i]=modmul(fact[i-1],i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint ways( string s ){    // function that returns no of permutations possible for a word \\n\\t\\t\\tmap< char, int > map;\\n\\t\\t\\tfor( char ch : s ){\\n\\t\\t\\t\\tmap[ch]++;\\n\\t\\t\\t}\\n\\t\\t\\tint p = fact[s.size()];\\n\\t\\t\\tint q = 1;\\n\\t\\t\\tfor( auto k : map ){\\n\\t\\t\\t\\tq = modmul( q, fact[k.second] );\\n\\t\\t\\t}\\n\\t\\t\\treturn modmul(p, modmulinv(q));\\n\\t\\t}\\n \\n\\t\\tint countAnagrams(string s) {\\n\\t\\t\\tgetfact();\\n\\t\\t\\tstringstream ss(s);\\n\\t\\t\\tstring word; \\n\\t\\t\\tint ans=1;\\n\\t\\t\\twhile (ss >> word){\\n\\t\\t\\t\\tans=modmul(ans,ways(word));\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t} \\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint mod=1e9+7;\\n\\t\\tint fact[100002];\\n    \\n\\t\\tint modmul(int a,int b){    //  function to multiply two very large numbers \\n\\t\\t\\treturn((long long)(a%mod)*(b%mod))%mod;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2955656,
                "title": "easily-understandable-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    const int MOD = pow(10, 9)+7;\\n    long fact[100001] = {}; // factorial lookup table\\n    void calc(){ // calculate factorials\\n        fact[1] = 1;\\n        for(int i = 2; i <= 100000; i++) fact[i] = fact[i-1]*i%MOD;\\n    }\\n    int binpow(int b){ // binary exponentiation\\n        long long n = MOD-2; // fermat\\'s little theorem\\n        long long ans = 1;\\n        long long place = b; \\n        while(n){ // decompose n into binary representation\\n            if(n&1) ans = (ans * place)%MOD;\\n            place = (place*place)%MOD;\\n            n >>= 1;\\n        }\\n        return ans;\\n    }\\n    int ways(string& s){\\n        int freq[26] = {}; // duplicate letters \\n        for(auto i : s) freq[i-\\'a\\']++;\\n        long perm = fact[s.length()]; // initial permutation\\n        long dupe = 1; \\n        for(auto i : freq) if(i) dupe = (dupe*fact[i])%MOD; // to divide permutations by duplicates factorial\\n        return (perm * binpow(dupe))%MOD; // fermat\\'s little theorem -- turn a/b mod m into a * b^(m-2)\\n    }\\n    int countAnagrams(string s) {\\n        calc();\\n        istringstream ss(s);\\n        long ans = 1;\\n        string temp = \"\";\\n        while(ss >> temp){\\n            ans *= ways(temp);\\n            ans %= MOD;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    const int MOD = pow(10, 9)+7;\\n    long fact[100001] = {}",
                "codeTag": "Java"
            },
            {
                "id": 2954873,
                "title": "very-simple-python-solution-explained-runtime-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can split the text, find number of anagrams of each word using permutations and combinations and then multiply all those numbers to get the final answer because the number of anagrams of a word is the number of different permutations of that word (basically number of different ways a word can be formed using the same set of letters with the same frequency of each letter.)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nNOTE: By using permutations and combinations, we know that the number of permutations of a word = (factorial of number of letters) divided by (product of factorial of number of times each letter occurs)\\n\\n- Initialize a variable \\'ans\\' with the value 1.\\n- Calculate the number of words in the sentence by using split function and store it in variable \\'n\\'.\\n- Use a \\'for loop\\' to iterate through each word.\\n- Use \\'Counter\\' to calculate the number of occurences of each letter in a particular word.\\n- Initialize a variable \\'cur\\' for each word and give it the value of the numerator, i.e. factorial of length of that word.\\n- Iterate through the number of occurences of each letter in that word and divide \\'cur\\' by the factorial of that number\\n- Multiply \\'cur\\' with \\'ans\\' and take the modulus.\\n- The loop does this for all words and eventually gives the required answer.\\n\\n# Details\\n- Runtime: 2042 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Memory: 15.6 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        ans = 1\\n        n = len(s.split())\\n        for i in s.split():\\n            d = Counter(i)\\n            cur = math.factorial(len(i))\\n            for key in d:\\n                cur //= math.factorial(d[key])\\n            ans *= cur\\n            ans %= (10**9) + 7\\n        return ans\\n```\\n\\nFor solutions to other LeetCode problems that I have solved, you can check my github repository :\\nhttps://github.com/harshitpoddar09/LeetCode-Solutions\\n\\nPlease upvote if you found this useful so that others can get help as well!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        ans = 1\\n        n = len(s.split())\\n        for i in s.split():\\n            d = Counter(i)\\n            cur = math.factorial(len(i))\\n            for key in d:\\n                cur //= math.factorial(d[key])\\n            ans *= cur\\n            ans %= (10**9) + 7\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954632,
                "title": "simple-permutation-with-repetition-of-objects-concept",
                "content": "Lets say string s when separated by spaces is made of w1, w2, w3..., wn words. Then we need to find the no of distinct permuations for each word wi. Then the total no of permutation for entire s becomes product of all distinct permutations.\\n\\nLets Pi indicates no of unique permutations of ith word. \\n\\nThen total ans = P1 * P2 * P3 * . . . . . * Pn\\n\\nObviously all the operations are performed under modulation\\n\\n\\n```\\n#define ll long long\\nconst int mod=1e9+7;\\nclass Solution {\\npublic:\\n    ll inv(ll a,ll p){\\n        if(p==0)\\n            return 1;\\n        ll ans=inv(a,p>>1);\\n        ans=(ans*ans)%mod;\\n        if(p&1)\\n            ans=(ans*a)%mod;\\n        return ans;\\n    }\\n    \\n    int countAnagrams(string s) {\\n        ll ans=1;\\n        \\n        vector<ll> fact(1+s.length(),1);\\n        for(int i=1;i<=s.length();i++)\\n            fact[i]=(fact[i-1]*i)%mod;\\n        \\n        for(int i=0;i<s.length();){\\n            string w;\\n            ll curr=1;\\n            vector<int> cnt(26,0);\\n            while(i<s.length() and s[i]!=\\' \\'){\\n                cnt[s[i]-\\'a\\']++;\\n                i++;\\n                w+=s[i];\\n            }\\n            \\n            curr=fact[w.length()];\\n            for(int j=0;j<26;j++){\\n                if(cnt[j]>1)\\n                    curr=(curr*inv(fact[cnt[j]],mod-2))%mod;\\n            }\\n            i++;\\n\\n            ans=(ans*curr)%mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Probability and Statistics"
                ],
                "code": "```\\n#define ll long long\\nconst int mod=1e9+7;\\nclass Solution {\\npublic:\\n    ll inv(ll a,ll p){\\n        if(p==0)\\n            return 1;\\n        ll ans=inv(a,p>>1);\\n        ans=(ans*ans)%mod;\\n        if(p&1)\\n            ans=(ans*a)%mod;\\n        return ans;\\n    }\\n    \\n    int countAnagrams(string s) {\\n        ll ans=1;\\n        \\n        vector<ll> fact(1+s.length(),1);\\n        for(int i=1;i<=s.length();i++)\\n            fact[i]=(fact[i-1]*i)%mod;\\n        \\n        for(int i=0;i<s.length();){\\n            string w;\\n            ll curr=1;\\n            vector<int> cnt(26,0);\\n            while(i<s.length() and s[i]!=\\' \\'){\\n                cnt[s[i]-\\'a\\']++;\\n                i++;\\n                w+=s[i];\\n            }\\n            \\n            curr=fact[w.length()];\\n            for(int j=0;j<26;j++){\\n                if(cnt[j]>1)\\n                    curr=(curr*inv(fact[cnt[j]],mod-2))%mod;\\n            }\\n            i++;\\n\\n            ans=(ans*curr)%mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954510,
                "title": "python3-easy-math-permutation-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nCalculate distinct permutation for all words and multiply them together\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        res = 1\\n        div = s.split()\\n        for element in div:\\n            track = [0]*26\\n            for char in element:\\n                track[ord(char) - 97] += 1\\n            temp_res = math.factorial(len(element))\\n            for element in track:\\n                if element >= 2: temp_res = temp_res // math.factorial(element)\\n            temp_res = temp_res % (10**9 + 7)\\n            res *= temp_res\\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        res = 1\\n        div = s.split()\\n        for element in div:\\n            track = [0]*26\\n            for char in element:\\n                track[ord(char) - 97] += 1\\n            temp_res = math.factorial(len(element))\\n            for element in track:\\n                if element >= 2: temp_res = temp_res // math.factorial(element)\\n            temp_res = temp_res % (10**9 + 7)\\n            res *= temp_res\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954118,
                "title": "very-simple-c-solution-100",
                "content": "\\nFirst we will calculate number of posible way write(or number  permutation) of  a word in string, and we will multiply them all to get the answer.\\n\\nTo calculte number of permutations of a word.\\n\\nwe have n!/(n1!*n2!....)\\n\\neg: \"TOO\" :  --> n=3(length of the word)\\n               n1=1(frequency of T)\\n               n2=2(frequency of O)\\n\\na=n!, b=(n1!*n2!...)\\n\\nFermet theorm:\\n\\n(a/b)%mod= ((a%mod)*((1/b)%mod)%mod)%mod\\n         = ((a%mod)*(b^(mod-2))%mod)%mod\\n\\n\\n\\n\\nCalulate for all the words(substring).\\nAnd multiply all the them to get the answer.\\n\\n\\nTHATS IT HO GUYS CHILL MARO . DO like ....\\nLOVE U ALL \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int mod=1e9+7;\\n\\n    int power(long long x, long long y, long long m){\\n        \\n        //some smart way to do poweering :)\\n        long long ans=1;\\n\\n        x=(x)%m;\\n\\n        while(y>0){\\n            if((y&1)>0){\\n                ans=(ans*x)%m;\\n            }\\n\\n            y=y/2;\\n            x= (x*x)%m;\\n        }\\n\\n        return (int) ans;\\n\\n\\n    }\\n\\n    int countAnagrams(string s) {\\n        \\n        // CALCULATE FACTORIAL TILL 10^5\\n        long long fac[100001];\\n\\n        fac[0]=1;\\n\\n        for(long long i=1; i<=100000; i++){\\n            \\n            fac[i]=(fac[i-1]*i)%mod;\\n        }\\n\\n        \\n        \\n         // TO calculate the frequency of character in a word\\n        vector<int> nums(26,0);\\n        \\n        \\n        long long ans=1;\\n        \\n        long long b;\\n        long long c;\\n        \\n        int a=0;\\n        \\n        int i=0;\\n        \\n        while(i<s.size()){\\n            \\n            \\n            if(s[i]!=\\' \\'){\\n              nums[s[i]-\\'a\\']++;   \\n            }\\n            \\n            if(s[i]==\\' \\' || i==s.size()-1){\\n                \\n                b=i-a;\\n                \\n                if(i==s.size()-1){\\n                    b++;\\n                }\\n             \\n                c=1;\\n                \\n                for(int j=0; j<26; j++){\\n                    \\n                    if(nums[j]!=0){\\n                        c=(c*fac[nums[j]])%mod;\\n                        nums[j]=0;\\n                        \\n                    }\\n                    \\n                }\\n                \\n\\n                //numerator      \\n                b=fac[b];\\n\\n                //denomenator\\n                c=(power(c,mod-2,mod))%mod;\\n\\n               \\n                //answer for the word\\n                b= (b*c)%mod;\\n\\n                //adding(basically multiplying) to final answer\\n                ans= (ans*b)%mod;\\n                \\n                a=i+1;\\n            }\\n            \\n            \\n            i++;\\n            \\n        }\\n        \\n        \\n        return (int)ans;\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mod=1e9+7;\\n\\n    int power(long long x, long long y, long long m){\\n        \\n        //some smart way to do poweering :)\\n        long long ans=1;\\n\\n        x=(x)%m;\\n\\n        while(y>0){\\n            if((y&1)>0){\\n                ans=(ans*x)%m;\\n            }\\n\\n            y=y/2;\\n            x= (x*x)%m;\\n        }\\n\\n        return (int) ans;\\n\\n\\n    }\\n\\n    int countAnagrams(string s) {\\n        \\n        // CALCULATE FACTORIAL TILL 10^5\\n        long long fac[100001];\\n\\n        fac[0]=1;\\n\\n        for(long long i=1; i<=100000; i++){\\n            \\n            fac[i]=(fac[i-1]*i)%mod;\\n        }\\n\\n        \\n        \\n         // TO calculate the frequency of character in a word\\n        vector<int> nums(26,0);\\n        \\n        \\n        long long ans=1;\\n        \\n        long long b;\\n        long long c;\\n        \\n        int a=0;\\n        \\n        int i=0;\\n        \\n        while(i<s.size()){\\n            \\n            \\n            if(s[i]!=\\' \\'){\\n              nums[s[i]-\\'a\\']++;   \\n            }\\n            \\n            if(s[i]==\\' \\' || i==s.size()-1){\\n                \\n                b=i-a;\\n                \\n                if(i==s.size()-1){\\n                    b++;\\n                }\\n             \\n                c=1;\\n                \\n                for(int j=0; j<26; j++){\\n                    \\n                    if(nums[j]!=0){\\n                        c=(c*fac[nums[j]])%mod;\\n                        nums[j]=0;\\n                        \\n                    }\\n                    \\n                }\\n                \\n\\n                //numerator      \\n                b=fac[b];\\n\\n                //denomenator\\n                c=(power(c,mod-2,mod))%mod;\\n\\n               \\n                //answer for the word\\n                b= (b*c)%mod;\\n\\n                //adding(basically multiplying) to final answer\\n                ans= (ans*b)%mod;\\n                \\n                a=i+1;\\n            }\\n            \\n            \\n            i++;\\n            \\n        }\\n        \\n        \\n        return (int)ans;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954005,
                "title": "cpp-solution-using-iterative-binary-exponentiation-and-modular-multiplicative-inverse",
                "content": "\\n\\n# Code\\n```\\ntypedef long long ll ; \\nclass Solution {\\npublic:\\n    const ll mod=1e9+7;\\n    long long fact[100001];\\n    vector<string> ss; \\n    ll modMul(ll a,ll b,ll mod){\\n        return ((a%mod)*(b%mod))%mod;\\n    }\\n    \\n    ll binpow(ll a,ll b,ll mod){\\n        if(b==0)return 1;\\n        ll ans=1;\\n        while(b){\\n            if(b&1){\\n                ans=(ans*a)%mod;\\n            }\\n            a=(a*a)%mod;\\n            b=b>>1;\\n        }\\n        return ans;\\n    }\\n    \\n    void factorial(){\\n        fact[0]=1;\\n        for(int i=1;i<100001;i++){\\n            fact[i]=modMul(fact[i-1],i,mod);\\n        }\\n    }   \\n    ll modInv(ll a,ll mod){\\n        return binpow(a,mod-2,mod);\\n    }\\n    ll solve(string word){\\n        map<char,int>m;\\n        for(auto it:word){\\n            m[it]++;\\n        }\\n        ll num=fact[word.size()]%mod;\\n        ll den=1;\\n        for(auto xx:m){\\n            if(xx.second>1){\\n                den=modMul(den,fact[xx.second],mod);\\n            }\\n        }\\n        ll inv=modInv(den,mod);\\n        ll ans=modMul(num,inv,mod);\\n        return ans;\\n    }\\n    int countAnagrams(string s) {\\n        factorial();\\n        \\n        string cur = \"\";\\n        for(int i =0 ;i<s.size();++i)\\n        {\\n            if(s[i]==\\' \\')   {\\n                ss.push_back(cur);\\n                cur = \"\";\\n            }\\n            else {\\n                cur.push_back(s[i]);\\n            }\\n        }\\n        ss.push_back(cur);\\n        ll ans=1;\\n        for(auto it:ss){\\n            ans=modMul(ans,solve(it),mod);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll ; \\nclass Solution {\\npublic:\\n    const ll mod=1e9+7;\\n    long long fact[100001];\\n    vector<string> ss; \\n    ll modMul(ll a,ll b,ll mod){\\n        return ((a%mod)*(b%mod))%mod;\\n    }\\n    \\n    ll binpow(ll a,ll b,ll mod){\\n        if(b==0)return 1;\\n        ll ans=1;\\n        while(b){\\n            if(b&1){\\n                ans=(ans*a)%mod;\\n            }\\n            a=(a*a)%mod;\\n            b=b>>1;\\n        }\\n        return ans;\\n    }\\n    \\n    void factorial(){\\n        fact[0]=1;\\n        for(int i=1;i<100001;i++){\\n            fact[i]=modMul(fact[i-1],i,mod);\\n        }\\n    }   \\n    ll modInv(ll a,ll mod){\\n        return binpow(a,mod-2,mod);\\n    }\\n    ll solve(string word){\\n        map<char,int>m;\\n        for(auto it:word){\\n            m[it]++;\\n        }\\n        ll num=fact[word.size()]%mod;\\n        ll den=1;\\n        for(auto xx:m){\\n            if(xx.second>1){\\n                den=modMul(den,fact[xx.second],mod);\\n            }\\n        }\\n        ll inv=modInv(den,mod);\\n        ll ans=modMul(num,inv,mod);\\n        return ans;\\n    }\\n    int countAnagrams(string s) {\\n        factorial();\\n        \\n        string cur = \"\";\\n        for(int i =0 ;i<s.size();++i)\\n        {\\n            if(s[i]==\\' \\')   {\\n                ss.push_back(cur);\\n                cur = \"\";\\n            }\\n            else {\\n                cur.push_back(s[i]);\\n            }\\n        }\\n        ss.push_back(cur);\\n        ll ans=1;\\n        for(auto it:ss){\\n            ans=modMul(ans,solve(it),mod);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952430,
                "title": "beats-90-simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question we have to find the different anagram that can be formed by changing the order of character in the given string.So to find the number of possible arrangement that can be formed we will use the following formula.\\n\\nNumber of arrangement=(Length of string)!/((Number of similar character of type 1)!*(number of similar character of type 2)!)\\n\\nFor example if given string is abacc then possible number of arrangement equals to (5!)/((2!)*(2!))\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will count the number of arrangements for each space separated string and we will make one answer variable in which we will store the multiplication of all arrangement.\\n\\nSo with the help of hashmap we need to maintain the freuency of the characters.If the frequency of the character is greater than 1 that means it is duplicate number so we will include this number in denominator.\\nThe value of numerator is the length of string.\\n\\nSo to avoid the overflow we need to calculate the \\n(upper/lower)%MOD.\\n\\n(Upper/Lower)%MOD=upper%MOD*((lower)^-1)%MOD.\\n\\nFor bettern understanding of the modulo division you can follow this link :- [https://www.codewithengineer.in/2022/12/modular-arithmetic-in-competitive.html]()\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nlong long fact(int n,int mod)\\n{\\n\\tif (n <= 1)\\n\\t\\treturn 1;\\n\\treturn ((n) * (fact(n - 1,mod)))%mod;\\n}\\n\\n//binary exponentiation\\nlong long fastModExp(long long num,long long mod,long long pow)\\n{\\n    long long res=1;\\n    while(pow>0)\\n    {\\n        if(pow&1)res=((res%mod)*(num%mod))%mod;\\n        num=((num%mod)*(num%mod))%mod;\\n        pow=pow/2;\\n    }\\n    return res;\\n\\n}\\n    int countAnagrams(string s) {\\n        //hare krishana\\n        //declaring map for storing the frequecy of the characters.\\n        map<char,int> m;\\n        long long ans=1;\\n        int mod=1e9+7;\\n        //temp string for storing the word separated by spaces\\n        string temp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            //if s[i]==\\' \\' the end of the character reached\\n            //if i == s.length()-1 that means it is our last character.\\n            if(s[i]==\\' \\' or i==s.length()-1)\\n            {\\n                //separately we have to deals with the last character of the last word\\n                if(i==s.length()-1)\\n                {\\n                    m[s[i]]++;\\n                    temp.push_back(s[i]);\\n                }\\n                //upper here means the numerator part\\n                long long upper=fact(temp.size(),mod);\\n                //lower means the denominator part\\n                long long lower=1;\\n                //iterating over the map\\n                //as there are only 26 character so it does not increase our time complexity\\n                for(auto x:m)\\n                {\\n                    if(x.second>1)\\n                    {\\n                        lower=((lower%mod)*fact(x.second,mod)%mod)%mod;\\n                    }\\n                }   \\n                //now calculaing the (upper/lower)%mod\\n                //(upper/lower)=(upper*(lower^(-1)))%mod\\n                //lower^(-1)=lower^(mod-2)%mod (using the fermat little theorem)\\n                long long str=((upper%mod)*fastModExp(lower,mod,mod-2)%mod)%mod;\\n                //updating our final answer!!\\n                ans=((ans%mod)*(str))%mod;\\n                temp.clear();\\n                m.clear();\\n            }\\n            else\\n            {\\n                m[s[i]]++;\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nlong long fact(int n,int mod)\\n{\\n\\tif (n <= 1)\\n\\t\\treturn 1;\\n\\treturn ((n) * (fact(n - 1,mod)))%mod;\\n}\\n\\n//binary exponentiation\\nlong long fastModExp(long long num,long long mod,long long pow)\\n{\\n    long long res=1;\\n    while(pow>0)\\n    {\\n        if(pow&1)res=((res%mod)*(num%mod))%mod;\\n        num=((num%mod)*(num%mod))%mod;\\n        pow=pow/2;\\n    }\\n    return res;\\n\\n}\\n    int countAnagrams(string s) {\\n        //hare krishana\\n        //declaring map for storing the frequecy of the characters.\\n        map<char,int> m;\\n        long long ans=1;\\n        int mod=1e9+7;\\n        //temp string for storing the word separated by spaces\\n        string temp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            //if s[i]==\\' \\' the end of the character reached\\n            //if i == s.length()-1 that means it is our last character.\\n            if(s[i]==\\' \\' or i==s.length()-1)\\n            {\\n                //separately we have to deals with the last character of the last word\\n                if(i==s.length()-1)\\n                {\\n                    m[s[i]]++;\\n                    temp.push_back(s[i]);\\n                }\\n                //upper here means the numerator part\\n                long long upper=fact(temp.size(),mod);\\n                //lower means the denominator part\\n                long long lower=1;\\n                //iterating over the map\\n                //as there are only 26 character so it does not increase our time complexity\\n                for(auto x:m)\\n                {\\n                    if(x.second>1)\\n                    {\\n                        lower=((lower%mod)*fact(x.second,mod)%mod)%mod;\\n                    }\\n                }   \\n                //now calculaing the (upper/lower)%mod\\n                //(upper/lower)=(upper*(lower^(-1)))%mod\\n                //lower^(-1)=lower^(mod-2)%mod (using the fermat little theorem)\\n                long long str=((upper%mod)*fastModExp(lower,mod,mod-2)%mod)%mod;\\n                //updating our final answer!!\\n                ans=((ans%mod)*(str))%mod;\\n                temp.clear();\\n                m.clear();\\n            }\\n            else\\n            {\\n                m[s[i]]++;\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952411,
                "title": "basic-mathematics-of-permutation-python-3",
                "content": "# Code\\n```\\nimport math\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        temp=s.split(\\' \\')\\n        mod=10**9+7\\n        ans=1\\n        for i in temp:\\n            has={}\\n            for j in i:\\n                if j in has:\\n                    has[j]+=1\\n                else:\\n                    has[j]=1\\n            val=1\\n            for k in has:\\n                val*=math.factorial(has[k])\\n            ans*=(math.factorial(len(i))//val)\\n        return ans%mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        temp=s.split(\\' \\')\\n        mod=10**9+7\\n        ans=1\\n        for i in temp:\\n            has={}\\n            for j in i:\\n                if j in has:\\n                    has[j]+=1\\n                else:\\n                    has[j]=1\\n            val=1\\n            for k in has:\\n                val*=math.factorial(has[k])\\n            ans*=(math.factorial(len(i))//val)\\n        return ans%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952051,
                "title": "c-easy-solution-modulo-inverse-with-comments",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e9 + 7;\\ntemplate<typename T>\\n \\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\n\\n// using little fermat theorem for \\n// calculating modulo inverse\\n\\nll power(ll x, ll y){\\n    if(!y) return 1;\\n    if(y & 1) return x * power(x, y-1) % mod;\\n    ll temp = power(x, y / 2);\\n    return temp * temp % mod;\\n}\\n\\nll modinverse(ll x){\\n    return power(x, mod-2);\\n}\\n\\nclass Solution {\\npublic:\\n    vs solve(const string& s, int& maxlen){\\n        string temp;\\n        vs output;\\n        forn(i, s.size()){\\n            if(s[i] == \\' \\'){\\n                output.pb(temp);\\n                int x = temp.size();\\n                maxlen = max(maxlen, x);\\n                temp = \"\";\\n            }\\n            else temp += s[i];\\n        }\\n        output.pb(temp);\\n         int x = temp.size();\\n        maxlen = max(maxlen, x);\\n        printvec(output);\\n        return output;\\n    }\\n    int countAnagrams(string s) {\\n        //idea of solution is to calculate number of\\n        //permutations of individual string and then take\\n        //product of them\\n        \\n        \\n        //For Eg if you aaaabcc as a string \\n        //then total permutations will be\\n        //  n! / (freq[a]! * freq[b]! * freq[c]!)\\n        // = 7! / (4! * 1! * 2!) = 105\\n        \\n        //so my answer will be n! * inverse(freq[a]!) * inverse(freq[b]!) * inverse(freq[c]!) .....\\n        \\n        //but as we are taking modulus we have to \\n        //use modulo inverse as we can\\'t take mod\\n        //in the denominator\\n        int n = s.size();\\n        int maxlen = 0;\\n        \\n        //this function just get us all the words\\n        // in a vector string though we can avoid it\\n        //by  simultaneously calculating the word and \\n        //its contribution but it is done to make it\\n        //easy to understand\\n        vs arr = solve(s, maxlen);\\n        vl fact(maxlen+1);\\n        fact[0] = 1;\\n        \\n        //calculating factorial of numbers\\n        //maxlen refers to the maximum length\\n        //of a word in the string s\\n        forn2(i, 1, maxlen+1){\\n           fact[i] = fact[i-1] * i % mod;\\n        }\\n        ll output = 1;\\n        forn(i, arr.size()){\\n            //for storing frequency of each character  in the word\\n            vi freq(26);\\n            for(auto it: arr[i]){\\n                freq[it - \\'a\\']++;\\n            }\\n            int temp = arr[i].size();\\n            //cnt refers to the number of permutations of the current word\\n            ll cnt = fact[temp];\\n            forn(i, 26){\\n                cnt = cnt * modinverse(fact[freq[i]]) % mod;\\n            }\\n            //multiplying the current answer to prev answer\\n            output = output * cnt % mod;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e9 + 7;\\ntemplate<typename T>\\n \\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\n\\n// using little fermat theorem for \\n// calculating modulo inverse\\n\\nll power(ll x, ll y){\\n    if(!y) return 1;\\n    if(y & 1) return x * power(x, y-1) % mod;\\n    ll temp = power(x, y / 2);\\n    return temp * temp % mod;\\n}\\n\\nll modinverse(ll x){\\n    return power(x, mod-2);\\n}\\n\\nclass Solution {\\npublic:\\n    vs solve(const string& s, int& maxlen){\\n        string temp;\\n        vs output;\\n        forn(i, s.size()){\\n            if(s[i] == \\' \\'){\\n                output.pb(temp);\\n                int x = temp.size();\\n                maxlen = max(maxlen, x);\\n                temp = \"\";\\n            }\\n            else temp += s[i];\\n        }\\n        output.pb(temp);\\n         int x = temp.size();\\n        maxlen = max(maxlen, x);\\n        printvec(output);\\n        return output;\\n    }\\n    int countAnagrams(string s) {\\n        //idea of solution is to calculate number of\\n        //permutations of individual string and then take\\n        //product of them\\n        \\n        \\n        //For Eg if you aaaabcc as a string \\n        //then total permutations will be\\n        //  n! / (freq[a]! * freq[b]! * freq[c]!)\\n        // = 7! / (4! * 1! * 2!) = 105\\n        \\n        //so my answer will be n! * inverse(freq[a]!) * inverse(freq[b]!) * inverse(freq[c]!) .....\\n        \\n        //but as we are taking modulus we have to \\n        //use modulo inverse as we can\\'t take mod\\n        //in the denominator\\n        int n = s.size();\\n        int maxlen = 0;\\n        \\n        //this function just get us all the words\\n        // in a vector string though we can avoid it\\n        //by  simultaneously calculating the word and \\n        //its contribution but it is done to make it\\n        //easy to understand\\n        vs arr = solve(s, maxlen);\\n        vl fact(maxlen+1);\\n        fact[0] = 1;\\n        \\n        //calculating factorial of numbers\\n        //maxlen refers to the maximum length\\n        //of a word in the string s\\n        forn2(i, 1, maxlen+1){\\n           fact[i] = fact[i-1] * i % mod;\\n        }\\n        ll output = 1;\\n        forn(i, arr.size()){\\n            //for storing frequency of each character  in the word\\n            vi freq(26);\\n            for(auto it: arr[i]){\\n                freq[it - \\'a\\']++;\\n            }\\n            int temp = arr[i].size();\\n            //cnt refers to the number of permutations of the current word\\n            ll cnt = fact[temp];\\n            forn(i, 26){\\n                cnt = cnt * modinverse(fact[freq[i]]) % mod;\\n            }\\n            //multiplying the current answer to prev answer\\n            output = output * cnt % mod;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2951413,
                "title": "brief-maths-intro-to-the-underlying-concept-details-with-example-access",
                "content": "# Intuition\\nPermutation of characters in each word of the string divided by the repetition of character in each word of the string.\\n\\n# Approach\\nNote: Need to know a bit about following mathematical topics to understand the solution\\n1. Euler Totient Function: counts the number of integers between 1 and n\\u200Ainclusive, which are coprime to n.\\nLike for example How many integers are there which are less than equal to 6 and is coprime to 6 -> only 1 and 5, but for 5 there are 1, 2, 3 and 4. So for 6 it is 2 and for 5 it is 4 i.e. phi(6) = 2 and phi(5) = 4. Totient function is given by phi(x). For a prime number phi(p) = p-1.\\n\\n2. Fermat\\'s Little theorem: Fermat\\'s little theorem states that if p is a prime number, then for any integer a, the number (pow(a,p) - a) is an integer multiple of p. This theorem is basically used here to find the multiplicative inverse.\\n\\n3. Multiplicative inverse of relative prime integer: If a and m are coprime integer then we can always find an x such that (a*x)%m = 1. Something like 2 * (1/2) = 1 but here we are considering Real numbers (R) and not integers. So for integers we define multiplicative inverse in terms of coprime Integer.\\n\\n4. Binary Exponentiation:  A fast method to find a^p. Typically O(logn). If you want to find 2^5. Then break 5 in binary format which is 101 and then use this method like this\\n 2^4 * 2^0 * 2^1 i.e use bit position of the binary format to find 2^5.\\n\\nSolution:-\\n1. For each word find the unique permutation by getting the factorial of the size of the word and diving it by the factorial of all charachters that is repeated in the word. \\nEx:- ACCESS -> word size: 6, repeated word C and S. SO total unique permutation of given word will be:- (6!)/(2! * 2!).\\n2. Catch is that word size can go till 10^5 and storing factorial of 10^5 is impossible within any datatype hence modulus is asked in the problem. \\nSo for the above example we need to take modulus (mod) of (6!)/(2! * 2!) % m.\\nBut modulus function does not hold good for divison (it holds good for multiplication) and thus we need to find the multiplicative inverse of the denominator (den) i.e. 2! * 2!. den = 4 and m = 1000000007. \\nBoth are coprime and with the help of Fermat\\'s little theorem we can find multiplicative inverse of 4.\\nSince m is prime so phi(m) = m-1.\\nso, (6! / 4) % m  = (6! * 4 ^ -1) % m\\n/* Multiplicative inverse of 4 */\\nand, (4 ^ -1) % m = (4^(phi(m) - 1)) % m\\n(4^(phi(m) - 1)) % m =  (4^(m-2)) % m\\nThat is why in the function \"**binExponentiation(ull a)**\" I have taken b = m - 2.\\n3. Now use Binary Exponentiation method to find 4^(m-2).\\n4. Then multiply the above result with 6! and take mod of the result and that is the final answer of the ACCESS word.\\n\\nReading Link: [Modular Inverse using Binary Exponentiation](https://cp-algorithms.com/algebra/module-inverse.html#finding-the-modular-inverse-using-extended-euclidean-algorithm)\\n[Euler\\'s totient function](https://cp-algorithms.com/algebra/phi-function.html)\\n[Binary Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)\\n\\n# Complexity\\n- Time complexity:\\nO(n). Since the whole string is traversed once. For each word of the string, some mathematical operations are done which will take constant time.\\n\\n- Space complexity:\\nO(n) in worst case scenario for storing the words of string in case each word is a single char. Plus some space for storing the pre-calculated factorial of number till 100000.\\n\\n# Code\\n```\\ntypedef unsigned long long int ull;\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\null fact[100001];\\n\\n    void factorial() {\\n        fact[0] = 1;\\n        for(int i = 1; i < 100001; i++) {\\n            fact[i] = (1ull * fact[i-1] * i) % mod;\\n        }\\n    }\\n\\n    ull binExponentiation(ull a) {\\n        ull b = mod - 2;\\n        ull res = 1, x = a;\\n\\n        while(b > 0) {\\n            if(b&1)\\n                res = (1ull * res * x) % mod;\\n            x = (1ull * x * x) % mod;\\n            b = b >> 1;\\n        }\\n        return res;\\n    }\\n\\n    ull countFun(vector<string> &buf) {\\n        vector<int> freq(26, 0);\\n        string cur;\\n        ull den, num, temp, res = 1;\\n\\n        for(int i = 0; i < buf.size(); i++) {\\n            cur = buf[i];\\n\\n            num = fact[cur.size()];\\n            for(int j = 0; j < cur.size(); j++) {\\n                int idx = cur[j] - \\'a\\';\\n                freq[idx]++;\\n            }\\n\\n            den = 1;\\n            for(int j = 0; j < 26; j++) {\\n                if(freq[j] > 1) {\\n                    int t = freq[j];\\n                    den = (1ull * den * fact[t]) % mod;\\n                }\\n            }\\n\\n            temp = (num * binExponentiation(den)) % mod;\\n            res = (res * temp) % mod;\\n\\n            for(int j = 0; j < 26; j++)\\n                freq[j] = 0;\\n        }\\n        return res;\\n    }\\n\\n    int countAnagrams(string s) {\\n        vector<string> buf;\\n        string str;\\n        \\n        factorial();\\n        stringstream ss(s);\\n        while(ss >> str) {\\n            buf.push_back(str);\\n        }        \\n        return countFun(buf);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef unsigned long long int ull;\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\null fact[100001];\\n\\n    void factorial() {\\n        fact[0] = 1;\\n        for(int i = 1; i < 100001; i++) {\\n            fact[i] = (1ull * fact[i-1] * i) % mod;\\n        }\\n    }\\n\\n    ull binExponentiation(ull a) {\\n        ull b = mod - 2;\\n        ull res = 1, x = a;\\n\\n        while(b > 0) {\\n            if(b&1)\\n                res = (1ull * res * x) % mod;\\n            x = (1ull * x * x) % mod;\\n            b = b >> 1;\\n        }\\n        return res;\\n    }\\n\\n    ull countFun(vector<string> &buf) {\\n        vector<int> freq(26, 0);\\n        string cur;\\n        ull den, num, temp, res = 1;\\n\\n        for(int i = 0; i < buf.size(); i++) {\\n            cur = buf[i];\\n\\n            num = fact[cur.size()];\\n            for(int j = 0; j < cur.size(); j++) {\\n                int idx = cur[j] - \\'a\\';\\n                freq[idx]++;\\n            }\\n\\n            den = 1;\\n            for(int j = 0; j < 26; j++) {\\n                if(freq[j] > 1) {\\n                    int t = freq[j];\\n                    den = (1ull * den * fact[t]) % mod;\\n                }\\n            }\\n\\n            temp = (num * binExponentiation(den)) % mod;\\n            res = (res * temp) % mod;\\n\\n            for(int j = 0; j < 26; j++)\\n                freq[j] = 0;\\n        }\\n        return res;\\n    }\\n\\n    int countAnagrams(string s) {\\n        vector<string> buf;\\n        string str;\\n        \\n        factorial();\\n        stringstream ss(s);\\n        while(ss >> str) {\\n            buf.push_back(str);\\n        }        \\n        return countFun(buf);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950513,
                "title": "pre-calculate-factorial-of-inverses-by-iteration",
                "content": "# Intuition\\nTwo tips in this question:\\n* calculate number of permutations with deplicate members.\\n* calculate inverse number by a modular\\n\\n\\n# Approach\\n## permutation\\nNumber of permutations by `n` unique members is `n!`.\\nFor duplicate members, mark their dup-cnt as `a`, `b`, ... then the result will be `n! / a! / b! /...`.\\n\\n## Inverse\\nWe could use **Fermat\\'s little theorem** to calculate any numbers inverse easily, say `n^(p-2) % p`.\\n\\nBut need to calculate a batch of inverse and calculate their factorial,\\nSo there is another faster way.\\nSay modular `p`, calculate `i`\\'s inverse, mark the inverse as `inv[i]`,\\nlet `p = k * i + r, where r = p % i`, then \\n\\n`k * i + r === 0 (mod p)`\\n`inv[i] * inv[r] * (k * i + r) === 0 (mod p)`\\n`inv[r] * k + inv[i] === 0 (mod p)`\\n`inv[i] === -inv[r] * k (mod p)`, notice `p * k === 0 (mod p)`, add it to last function:\\n`inv[i] === -inv[r] * k + p * k(mod p)`\\n`inv[i] === (p - inv[r]) * k (mod p)`\\n\\nNotice `r = p % i`, `r` is less than `i`, `inv[r]` has calculated before we calculate `inv[i]`.\\n\\n\\n# Code\\n```\\nconst int mod = 1e9 + 7;\\nconst int maxn = 1e5 + 1;\\nint inv[maxn], finv[maxn], f[maxn];\\nbool flag = false;\\nclass Solution {\\n    void init() {\\n        if (flag) return;\\n        f[1] = 1;\\n        inv[1] = 1;\\n        finv[1] = 1;\\n        for (int i = 2; i < maxn; ++i) {\\n            f[i] = 1ll * f[i - 1] * i % mod;\\n            inv[i] = 1ll * (mod - mod / i) * inv[mod%i] % mod;\\n            finv[i] = 1ll * finv[i - 1] * inv[i] % mod;\\n        }\\n        flag = true;\\n    }\\n\\npublic:\\n    int countAnagrams(string s) {\\n        init();\\n        long ret = 1;\\n        int l = 0;\\n        map<char, int> m;\\n        for (size_t i = 0, n = s.size(); i < n; ++i) {\\n            if (s[i] != \\' \\') {\\n                ++l;\\n                ++m[s[i]];\\n            }\\n            if (s[i] == \\' \\' || i == n - 1) {\\n                if (l > 0) {\\n                    long t = f[l] % mod;\\n                    for (auto p : m) {\\n                        if (p.second > 1) {\\n                            t = t * finv[p.second] % mod;\\n                        }\\n                    }\\n                    ret = ret * t % mod;\\n                }\\n                l = 0;\\n                m.clear();\\n            }\\n        }\\n        return ret;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nconst int mod = 1e9 + 7;\\nconst int maxn = 1e5 + 1;\\nint inv[maxn], finv[maxn], f[maxn];\\nbool flag = false;\\nclass Solution {\\n    void init() {\\n        if (flag) return;\\n        f[1] = 1;\\n        inv[1] = 1;\\n        finv[1] = 1;\\n        for (int i = 2; i < maxn; ++i) {\\n            f[i] = 1ll * f[i - 1] * i % mod;\\n            inv[i] = 1ll * (mod - mod / i) * inv[mod%i] % mod;\\n            finv[i] = 1ll * finv[i - 1] * inv[i] % mod;\\n        }\\n        flag = true;\\n    }\\n\\npublic:\\n    int countAnagrams(string s) {\\n        init();\\n        long ret = 1;\\n        int l = 0;\\n        map<char, int> m;\\n        for (size_t i = 0, n = s.size(); i < n; ++i) {\\n            if (s[i] != \\' \\') {\\n                ++l;\\n                ++m[s[i]];\\n            }\\n            if (s[i] == \\' \\' || i == n - 1) {\\n                if (l > 0) {\\n                    long t = f[l] % mod;\\n                    for (auto p : m) {\\n                        if (p.second > 1) {\\n                            t = t * finv[p.second] % mod;\\n                        }\\n                    }\\n                    ret = ret * t % mod;\\n                }\\n                l = 0;\\n                m.clear();\\n            }\\n        }\\n        return ret;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950383,
                "title": "python-inverse-modulus-explained",
                "content": "# Intuition\\nPermutations and Combinations (Math)\\n\\n# Approach\\nFor some string ,let there be a,b,c chars with count c1,c2,c2 and length of string as l.\\nThen total combinations will be l!/(c1! * c2! *c3!).\\nFinal answer is multiplication for all strings.\\nUse concept of inverse modulus while dividing by factorial and taking mod.The function modi(x,pri1) returns that value for each factorial in divisor.\\nIf we know M is prime, then we can use Fermat\\u2019s little theorem to find the inverse. \\na^(M-1) \\u2245 1 (mod M)\\nThis means that we get 1 when we do a^(M-1)%M\\nIf we multiply both sides with a^(-1), we get \\na^(-1) \\u2245 a^(M-2) (mod M)\\nHere M is mod=10**9+7 and a is value of number in our divisor like c1,c2,c3 in above example.\\n\\n# Complexity\\n- Time complexity:\\nO(n)+O(k*  log mod) where n is length of whole initial string, k is number of times we call inverse modulus function (~n/2 times in worse case) and mod=10**9+7.\\n\\n- Space complexity:\\nO(n) for storing factorials.\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        nums=[]  #stores count of all chars in a string as a Counter\\n        mod=10**9+7\\n        ans=1\\n        ll=[] #stores length of a string\\n        fact=[1]*100005\\n        for i in range(1,100005):\\n            fact[i]=(fact[i-1]*i)%mod\\n        @cache\\n        def fast_exp(x,n,mod):\\n            ans=1\\n            while n>0:\\n                if n%2==1:\\n                    ans=(ans*x)%mod\\n                    n-=1\\n                x=(x*x)%mod\\n                n //= 2\\n            return ans\\n        @cache\\n        def modi(x,pri1):\\n            return fast_exp(x,pri1-2,pri1)\\n        def ncr(idx,pri1):\\n            cnt=nums[idx]\\n            val=(fact[ll[idx]])%pri1\\n            for c in cnt:\\n                val*=((modi(fact[cnt[c]],pri1))%pri1)%pri1\\n            return val\\n        for word in s.split(\" \"):\\n            m=len(word)\\n            cnt=Counter(word)\\n            nums.append(cnt)\\n            del cnt\\n            ll.append(m)\\n        n=len(nums)\\n        for i in range(n):\\n            ans=(ans*ncr(i,mod))%mod\\n        return ans\\n        \\n        \\n            \\n                \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        nums=[]  #stores count of all chars in a string as a Counter\\n        mod=10**9+7\\n        ans=1\\n        ll=[] #stores length of a string\\n        fact=[1]*100005\\n        for i in range(1,100005):\\n            fact[i]=(fact[i-1]*i)%mod\\n        @cache\\n        def fast_exp(x,n,mod):\\n            ans=1\\n            while n>0:\\n                if n%2==1:\\n                    ans=(ans*x)%mod\\n                    n-=1\\n                x=(x*x)%mod\\n                n //= 2\\n            return ans\\n        @cache\\n        def modi(x,pri1):\\n            return fast_exp(x,pri1-2,pri1)\\n        def ncr(idx,pri1):\\n            cnt=nums[idx]\\n            val=(fact[ll[idx]])%pri1\\n            for c in cnt:\\n                val*=((modi(fact[cnt[c]],pri1))%pri1)%pri1\\n            return val\\n        for word in s.split(\" \"):\\n            m=len(word)\\n            cnt=Counter(word)\\n            nums.append(cnt)\\n            del cnt\\n            ll.append(m)\\n        n=len(nums)\\n        for i in range(n):\\n            ans=(ans*ncr(i,mod))%mod\\n        return ans\\n        \\n        \\n            \\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950049,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAnagrams = function(s) {\\n    let res = BigInt(1);\\n    let arr = s.split(\\' \\');\\n    for(let i=0; i<arr.length; i++){\\n        let w = arr[i];\\n        // count letter of the word\\n        let map = new Map();\\n        // mark if letter repeat\\n        let flag = true;\\n        for(let j=0; j<w.length; j++){\\n            if(map.has(w[j])){\\n                // update the mark\\n                flag = false;\\n                map.set(w[j], map.get(w[j]) + 1);\\n            }else{\\n                map.set(w[j], 1);\\n            }\\n        }\\n        let sum = BigInt(1);\\n        if(flag){\\n            // letter not repeat\\n            sum = calc(w.length);\\n        }else{\\n            // letter repeat\\n            // use bigint to void exceed\\n            let s = BigInt(1);\\n            let keys = Array.from(map.keys());\\n            // if there is only 1 letter, not necessary to calc\\n            if(keys.length > 1){\\n                sum = calc(w.length);\\n                for(let j=0; j<keys.length; j++){\\n                    let l = map.get(keys[j]);\\n                    if(l >= 2){\\n                        s = s * calc(l);\\n                    }\\n                }\\n                // removing duplicate combinations\\n                sum = sum / s;\\n            }\\n        }\\n        res = res * sum;\\n    }\\n    res = res % BigInt(1000000007);\\n    return res;    \\n};\\n\\nfunction calc(len){\\n    let res = BigInt(1);;\\n    while(len > 1){\\n        res = res * BigInt(len);\\n        len --;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAnagrams = function(s) {\\n    let res = BigInt(1);\\n    let arr = s.split(\\' \\');\\n    for(let i=0; i<arr.length; i++){\\n        let w = arr[i];\\n        // count letter of the word\\n        let map = new Map();\\n        // mark if letter repeat\\n        let flag = true;\\n        for(let j=0; j<w.length; j++){\\n            if(map.has(w[j])){\\n                // update the mark\\n                flag = false;\\n                map.set(w[j], map.get(w[j]) + 1);\\n            }else{\\n                map.set(w[j], 1);\\n            }\\n        }\\n        let sum = BigInt(1);\\n        if(flag){\\n            // letter not repeat\\n            sum = calc(w.length);\\n        }else{\\n            // letter repeat\\n            // use bigint to void exceed\\n            let s = BigInt(1);\\n            let keys = Array.from(map.keys());\\n            // if there is only 1 letter, not necessary to calc\\n            if(keys.length > 1){\\n                sum = calc(w.length);\\n                for(let j=0; j<keys.length; j++){\\n                    let l = map.get(keys[j]);\\n                    if(l >= 2){\\n                        s = s * calc(l);\\n                    }\\n                }\\n                // removing duplicate combinations\\n                sum = sum / s;\\n            }\\n        }\\n        res = res * sum;\\n    }\\n    res = res % BigInt(1000000007);\\n    return res;    \\n};\\n\\nfunction calc(len){\\n    let res = BigInt(1);;\\n    while(len > 1){\\n        res = res * BigInt(len);\\n        len --;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2949986,
                "title": "classic-permutation-problem-o-nlogm-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long fc[100001];\\n    long long m = 1000000007;\\n    int cnt[26] = {0};\\n    int countAnagrams(string s) { \\n         // Number of ways to arrange n letters in distinct ways is n!\\n        //  remove duplicate permutations as letter might occur again in the word , we divide n! with combined (occurences of every letter)!\\n       //   eg: \"too\" => permutations are  3! / (occurs(t)! * occurs(o)!) => 3!/(2!)*(1!) => 3\\n         fc[0] = 1;\\n         for(int i=1; i<=100000; i++) fc[i] = (fc[i-1] * i) % m;\\n         long long ans = 1, len = 0;\\n         for(int i=0; i<=s.size(); i++) {\\n               if(i==s.size() || s[i]==\\' \\') {\\n                   long long inv = 1;\\n                   for(int k=0; k<26; k++) {\\n                        if(cnt[k]) {\\n                            inv =  (inv * pw(fc[cnt[k]],m-2,m)) % m;\\n                            cnt[k] = 0;\\n                        }\\n                   }\\n                   ans = (ans * fc[len]) % m;\\n                   ans = (ans * inv) % m;\\n                   len = 0;\\n               }else {\\n                   cnt[s[i] - \\'a\\']++;\\n                   len++;\\n               }\\n         }\\n        return ans;\\n    }\\n    long long pw(long long x,long long y,long long m) {\\n         x %=m;\\n         long long res = 1;\\n         while(y>0) {\\n             if(y&1) res = (res * x) % m;\\n             x = (x * x) % m;   \\n             y>>=1;\\n         }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long fc[100001];\\n    long long m = 1000000007;\\n    int cnt[26] = {0};\\n    int countAnagrams(string s) { \\n         // Number of ways to arrange n letters in distinct ways is n!\\n        //  remove duplicate permutations as letter might occur again in the word , we divide n! with combined (occurences of every letter)!\\n       //   eg: \"too\" => permutations are  3! / (occurs(t)! * occurs(o)!) => 3!/(2!)*(1!) => 3\\n         fc[0] = 1;\\n         for(int i=1; i<=100000; i++) fc[i] = (fc[i-1] * i) % m;\\n         long long ans = 1, len = 0;\\n         for(int i=0; i<=s.size(); i++) {\\n               if(i==s.size() || s[i]==\\' \\') {\\n                   long long inv = 1;\\n                   for(int k=0; k<26; k++) {\\n                        if(cnt[k]) {\\n                            inv =  (inv * pw(fc[cnt[k]],m-2,m)) % m;\\n                            cnt[k] = 0;\\n                        }\\n                   }\\n                   ans = (ans * fc[len]) % m;\\n                   ans = (ans * inv) % m;\\n                   len = 0;\\n               }else {\\n                   cnt[s[i] - \\'a\\']++;\\n                   len++;\\n               }\\n         }\\n        return ans;\\n    }\\n    long long pw(long long x,long long y,long long m) {\\n         x %=m;\\n         long long res = 1;\\n         while(y>0) {\\n             if(y&1) res = (res * x) % m;\\n             x = (x * x) % m;   \\n             y>>=1;\\n         }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949945,
                "title": "c-clean-code-faster-than-94-combinatorics-fermat-s-little-theorem-binary-exponentiation",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n\\n    static const ll MOD = 1\\'000\\'000\\'007;\\n\\n    static ll factorial(int n) {\\n        ll fact = 1;\\n        for (ll i = 2; i <= n; i++)\\n            fact = (fact * i) % MOD;\\n        return fact;\\n    }\\n    \\n    static ll binPowMod(ll a, ll b) {\\n        if (b == 0) {\\n            return 1; \\n        }\\n        const auto res = binPowMod(a, b / 2);\\n        const auto ans = (res * res) % MOD;\\n        return b % 2 ? (a * ans) % MOD : ans;\\n    }\\n\\n    ll inverse(ll v) {\\n        return binPowMod(v, MOD - 2);\\n    }\\n\\n    int countDistinctPermutations(string_view str) {\\n        const ll n = size(str);\\n        vector<ll> freq(26);\\n        for (const auto ch: str) {\\n            ++freq[ch - \\'a\\'];\\n        }\\n        const auto duplicated = accumulate(cbegin(freq), cend(freq), 1ll, [](ll ans, ll v) {\\n            return (ans * factorial(v)) % MOD;\\n        });\\n        return (factorial(n) * inverse(duplicated)) % MOD;\\n    }\\n    \\n    int countAnagrams(string s) {\\n        vector<string> strs;\\n        string curr;\\n        for (const auto ch: s) {\\n            if (ch != \\' \\') {\\n                curr += ch;\\n            }\\n            else {\\n                strs.push_back(curr);\\n                curr.clear();\\n            }\\n        }\\n        strs.push_back(curr);\\n        return accumulate(cbegin(strs), cend(strs), 1ll, [&](ll res, string_view sv) {\\n            return (res * countDistinctPermutations(sv)) % MOD;\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n\\n    static const ll MOD = 1\\'000\\'000\\'007;\\n\\n    static ll factorial(int n) {\\n        ll fact = 1;\\n        for (ll i = 2; i <= n; i++)\\n            fact = (fact * i) % MOD;\\n        return fact;\\n    }\\n    \\n    static ll binPowMod(ll a, ll b) {\\n        if (b == 0) {\\n            return 1; \\n        }\\n        const auto res = binPowMod(a, b / 2);\\n        const auto ans = (res * res) % MOD;\\n        return b % 2 ? (a * ans) % MOD : ans;\\n    }\\n\\n    ll inverse(ll v) {\\n        return binPowMod(v, MOD - 2);\\n    }\\n\\n    int countDistinctPermutations(string_view str) {\\n        const ll n = size(str);\\n        vector<ll> freq(26);\\n        for (const auto ch: str) {\\n            ++freq[ch - \\'a\\'];\\n        }\\n        const auto duplicated = accumulate(cbegin(freq), cend(freq), 1ll, [](ll ans, ll v) {\\n            return (ans * factorial(v)) % MOD;\\n        });\\n        return (factorial(n) * inverse(duplicated)) % MOD;\\n    }\\n    \\n    int countAnagrams(string s) {\\n        vector<string> strs;\\n        string curr;\\n        for (const auto ch: s) {\\n            if (ch != \\' \\') {\\n                curr += ch;\\n            }\\n            else {\\n                strs.push_back(curr);\\n                curr.clear();\\n            }\\n        }\\n        strs.push_back(curr);\\n        return accumulate(cbegin(strs), cend(strs), 1ll, [&](ll res, string_view sv) {\\n            return (res * countDistinctPermutations(sv)) % MOD;\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949293,
                "title": "python3-modular-inverse-with-pow-detailed-intuition-and-simple-code",
                "content": "# Intuition\\n* We compute the product of the number of possibilities for each word.\\n* For a word with `n` distinct letters, we have `n!` possibilities (i.e. all the permutations).\\n* For a word of length `n` with `2` letters with `p` and `n-p` occurences, we have `C^n_p = n! / (p! * (n-p)!)` possibilities (remember your math classes ;) ).\\n* For a word of length `n` with letters occuring `p_1, ..., p_k` times, we generalize and get `n! / (p_1! * ... * p_k!)` possibilities. \\n \\n# Approach\\nWe use the relation \\n`(a / b) % m = ( (a % m) * (b^{-1} % m) ) % m`.\\n\\nIn python, `b^{-1} % m` can be simply obtained using `pow`.\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        result, mod = 1, int(1e9 + 7)\\n\\n        for word in s.split():\\n            result *= factorial(len(word)) % mod\\n            for i in Counter(word).values():\\n                result *= pow(factorial(i), -1, mod)\\n\\n        return result % mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        result, mod = 1, int(1e9 + 7)\\n\\n        for word in s.split():\\n            result *= factorial(len(word)) % mod\\n            for i in Counter(word).values():\\n                result *= pow(factorial(i), -1, mod)\\n\\n        return result % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948532,
                "title": "kotlin-simple-solution",
                "content": "```\\nclass Solution {\\n    val mod: Long = (1e9+7).toLong()\\n\\n    fun power(x: Long, y: Long): Long {\\n        var x: Long = x\\n        var y: Long = y\\n        var ans: Long = 1\\n        x %= mod\\n        while (y > 0) {\\n            if (y and 1 == 1L) \\n                ans = (ans * x) % mod\\n            x = (x * x) % mod\\n            y = y shr 1\\n        }\\n        return ans\\n    }\\n    \\n    fun factorial(x: Long): Long{\\n        var fac: Long = 1L\\n        for(i in 1 until x+1)\\n            fac = (fac * i) % mod\\n        return fac\\n    }\\n\\n    fun countAnagrams(s: String): Int {\\n        var ans = 1L\\n        s.split(\\' \\').forEach {\\n            val counts = LongArray(26){0}\\n            for(c in it) {\\n                counts[c-\\'a\\']++\\n            }\\n            var fac: Long = factorial(it.length.toLong())\\n            for(cnt in counts) {\\n                if(cnt != 0L) {\\n                    fac = (fac * power(factorial(cnt),mod-2))%mod\\n                }\\n            }\\n            ans = (ans * fac) % mod\\n        }\\n        return ((ans + mod) % mod).toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    val mod: Long = (1e9+7).toLong()\\n\\n    fun power(x: Long, y: Long): Long {\\n        var x: Long = x\\n        var y: Long = y\\n        var ans: Long = 1\\n        x %= mod\\n        while (y > 0) {\\n            if (y and 1 == 1L) \\n                ans = (ans * x) % mod\\n            x = (x * x) % mod\\n            y = y shr 1\\n        }\\n        return ans\\n    }\\n    \\n    fun factorial(x: Long): Long{\\n        var fac: Long = 1L\\n        for(i in 1 until x+1)\\n            fac = (fac * i) % mod\\n        return fac\\n    }\\n\\n    fun countAnagrams(s: String): Int {\\n        var ans = 1L\\n        s.split(\\' \\').forEach {\\n            val counts = LongArray(26){0}\\n            for(c in it) {\\n                counts[c-\\'a\\']++\\n            }\\n            var fac: Long = factorial(it.length.toLong())\\n            for(cnt in counts) {\\n                if(cnt != 0L) {\\n                    fac = (fac * power(factorial(cnt),mod-2))%mod\\n                }\\n            }\\n            ans = (ans * fac) % mod\\n        }\\n        return ((ans + mod) % mod).toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948497,
                "title": "ksi-solution",
                "content": "Fatneek\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        import math\\n        def fact_with_reps(word):\\n            \\n            top = math.factorial(len(word))\\n            bottom = 1\\n            for i in set(list(word)):\\n                bottom *= math.factorial(word.count(i))\\n            return top//bottom\\n        \\n        res = 1\\n        for i in s.split():\\n            res *= fact_with_reps(i)\\n            \\n        return res % ((10**9) + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        import math\\n        def fact_with_reps(word):\\n            \\n            top = math.factorial(len(word))\\n            bottom = 1\\n            for i in set(list(word)):\\n                bottom *= math.factorial(word.count(i))\\n            return top//bottom\\n        \\n        res = 1\\n        for i in s.split():\\n            res *= fact_with_reps(i)\\n            \\n        return res % ((10**9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948456,
                "title": "python-solution-why-is-this-problem-marked-hard",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSplit the string into individual words and find the permutations of individual words\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTotal number of anagrams of ```s = \\'word1 word2 word3 ...\\'``` is equal to ```numPermutations(word1) * numPermutations(word2) * numPermutations(word3)...``` and number of permutations of ```word = \\'a1a2a3a4\\'``` can be counted by $$numPermutations = n! / (c1! * c2! *  c3! * c4!)$$ where ```ci``` is the number of occurences of ```ai``` in ```word```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for ```Counter()```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        res, MOD, s = 1, 1000000007, s.split(\\' \\')\\n        for word in s:\\n            freq = Counter(word)\\n            numPermutations = factorial(freq.total())\\n            for _, numOccurences in freq.items():\\n                numPermutations //= factorial(numOccurences)\\n            res = (res * numPermutations) % MOD\\n        return res % MOD\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```s = \\'word1 word2 word3 ...\\'```\n```numPermutations(word1) * numPermutations(word2) * numPermutations(word3)...```\n```word = \\'a1a2a3a4\\'```\n```ci```\n```ai```\n```word```\n```Counter()```\n```python []\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        res, MOD, s = 1, 1000000007, s.split(\\' \\')\\n        for word in s:\\n            freq = Counter(word)\\n            numPermutations = factorial(freq.total())\\n            for _, numOccurences in freq.items():\\n                numPermutations //= factorial(numOccurences)\\n            res = (res * numPermutations) % MOD\\n        return res % MOD\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947956,
                "title": "python-easy-to-read-and-understand-multiply-unique-permutations",
                "content": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        items = s.split(\\' \\')\\n        res = 1\\n        for item in items:\\n            den = 1\\n            n = len(item)\\n            count = collections.Counter(item)\\n            #print(count.items())\\n            for key in count:\\n                if count[key] > 1:\\n                    den *= math.factorial(count[key])\\n            res *= math.factorial(n)//den\\n        return int(res)%(10**9 + 7)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        items = s.split(\\' \\')\\n        res = 1\\n        for item in items:\\n            den = 1\\n            n = len(item)\\n            count = collections.Counter(item)\\n            #print(count.items())\\n            for key in count:\\n                if count[key] > 1:\\n                    den *= math.factorial(count[key])\\n            res *= math.factorial(n)//den\\n        return int(res)%(10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 2947776,
                "title": "python3-multiply-possible-permutation-of-each-word",
                "content": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_00_00_00_007\\n        ans = 1\\n        s = s.split(\" \")\\n        for i in s:\\n            hmap = Counter(i)\\n            cnt = math.factorial(len(i))\\n            for k,v in hmap.items():\\n                d = math.factorial(v)\\n                cnt = (cnt // d)\\n            ans = ans * cnt\\n        return ans % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_00_00_00_007\\n        ans = 1\\n        s = s.split(\" \")\\n        for i in s:\\n            hmap = Counter(i)\\n            cnt = math.factorial(len(i))\\n            for k,v in hmap.items():\\n                d = math.factorial(v)\\n                cnt = (cnt // d)\\n            ans = ans * cnt\\n        return ans % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947770,
                "title": "python-combinatorics-modulo-inverse",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor each word in string we can arrange in fact(n)/factorial(x1)*factorail(x2)*....\\nwhere x1+x2+...=n\\n\\n# Approach\\nwe would decleare a result as ans=1\\nthen for each word in string we would calculate no of ways to arrange . we can do it by using fact[n]/(fact[x1]*fact[x2]....)\\nwe can do it by using inverse modulo as result calt be very large.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n-o(size(string)*log(size(string sepreated by space)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n- o(N)\\n- here N=10^5\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nf=[0]*(10**5+1)\\nf[0]=1\\nm=10**9+7\\nfor i in range(1,10**5+1):\\n    f[i]=f[i-1]*i%m\\n\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        ans=1\\n        l=[]\\n        for i in list(s.split(\" \")):\\n \\n            d=dict()\\n            for j in i:\\n                if(j in d):\\n                    d[j]+=1\\n                else:\\n                    d[j]=1\\n            \\n\\n            l.append([d,len(list(i))])\\n\\n        ans1=1\\n        for i in l:\\n            g=i[0]\\n            h=i[1]\\n            ans1*=f[h]%m\\n            for j in g:\\n                if(g[j]!=1):\\n                    \\n                    ans1*=pow(f[g[j]],m-2,m)%m\\n                \\n        return ans1%m\\n            \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nf=[0]*(10**5+1)\\nf[0]=1\\nm=10**9+7\\nfor i in range(1,10**5+1):\\n    f[i]=f[i-1]*i%m\\n\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        ans=1\\n        l=[]\\n        for i in list(s.split(\" \")):\\n \\n            d=dict()\\n            for j in i:\\n                if(j in d):\\n                    d[j]+=1\\n                else:\\n                    d[j]=1\\n            \\n\\n            l.append([d,len(list(i))])\\n\\n        ans1=1\\n        for i in l:\\n            g=i[0]\\n            h=i[1]\\n            ans1*=f[h]%m\\n            for j in g:\\n                if(g[j]!=1):\\n                    \\n                    ans1*=pow(f[g[j]],m-2,m)%m\\n                \\n        return ans1%m\\n            \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947674,
                "title": "c-share-my-experience-of-understanding-this-problem-hope-this-can-help-others-same-as-me",
                "content": "To be honest, I didn\\'t resolve this problem because of the number overflow. After reading others\\' nice posts, I spent hours learning and understanding the background knowledge which are mostly in the cope of **Discrete Mathematics**.\\n\\nSo here is basically what you may need\\n1. Multinomial Coefficients\\n2. Modulo Multiplicative Inverse\\n3. Fermate\\'s little theorem\\n4. Your brilliant skill achieve them in codes.\\n\\n### **Multinomial Coefficients**\\nI believe most of people can get to this step to compute something like\\n`n! / (a!*b!*...(n-a-b)!)`\\nWe would be easy to get stuck in computing any of `n!` due to results too large.\\n\\n### **Modulo Multiplicative Inverse**\\nWhile it\\'s equivalent to have `(a mod m) * (b mod m) = (a * b) mod m`. This is not applicable to division. So we need *Modulo Multiplicative Inverse* to help us.\\n\\na *Multiplicative Inverse*, `b\\'` of `b` mod `m` makes an relationship\\n```\\nb*b\\' mod m === 1 mod m\\n```\\nwe have the following deduction (assume `a` is divisible by `b`)\\n```\\na mod m === (a * 1) mod m === (a * b * b\\') mod m;\\n(a / b) mod m === (b * b\\' * a / b) mod m;\\n(a / b) mod m === (a * b\\') mod m;\\n```\\n### **Fermate\\'s little theorm**\\nSince we have converted `(a / b) mod m` to `(a * b\\') mod m`, which is further `(a mod m) * (b\\' mod m)`. \\nFollowing *Fermate\\'s little theorem*, if `p` is a prime number, for any integer `a`, we will have\\n```\\n(a^p - a) mod p = 0\\n```\\nThe provable special case is: if `a` and `p` are coprime, there is\\n```\\n(a^(p-1) - 1) mod p = 0 => a^(p-1) === 1 mod p\\n```\\nBecause if `a` and `p` are coprime, `(a^p + a) = X*(a * p) => a ^ (p-1) = X*p => (a^(p-1) - 1) mod p = 0`.\\n\\nRecall that `(b*b\\') === 1 mod m`\\n\\nIn our case, `m` is prime, `b` is always less than `m`, so `b` and `m` are coprime. Then `b\\'` can possibly be `b^(m-2)` such that `b*b\\' = b^(m-1) === 1 mod m`.\\n\\nSince b^(m-2) is not an effcient operation, apply **Binary Exponentiation** for optimization.\\n\\nAs for now, the original problem has been deduced to \\n```\\n[n! / (a!*b!*...)] mod m === (n! mod m) * [(a!)\\' mod m] * [(b!)\\' mod m] * ...\\n\\n=> n! * (a!)^(m-2) * (b!)^(m-2) * ... mod m\\n```\\n\\n### **Reference**\\nBig thanks to ye15@\\'s [post](https://leetcode.com/problems/count-anagrams/discuss/2946557/C%2B%2BorJavaorPython3-multinomial-coefficients)\\nand devanshu171@\\'s [post](https://leetcode.com/problems/count-anagrams/discuss/2947111/C%2B%2B-Solution-Math-with-Explanation-Each-step-in-detail). \\nDon\\'t forget to give them a upvote.\\n\\n### **Solution**\\n1. Precompute `n!` and `(n!) ^ (m-2)`, take `O(NlogN)`.\\n2. For each work apply *Multinomial Coefficients* accordingly. \\n\\n```c++\\nclass Solution {\\npublic:\\n    int countAnagrams(string s) {\\n        // A33/A22 * A33 = 3 * 6 = 18\\n    \\t// modulo multiplicative inverse\\n    \\tint n = s.size();\\n    \\tint mod = 1e9 + 7;\\n    \\t// factorials and inverse factorials\\n    \\tvector<long> fact(n + 1, 1), invfact(n + 1, 1);\\n    \\tfor(int i = 1; i <= n; ++i) {\\n    \\t\\tfact[i] = i * fact[i-1] % mod;\\n    \\t\\tif(i >= 2)\\n\\t    \\t\\tinvfact[i] = binpow(fact[i], mod-2, mod);\\n    \\t}\\n    \\tlong ans = 1;\\n    \\tstring word;\\n    \\tstringstream ss(s);\\n    \\twhile(ss >> word) {\\n    \\t\\tvector<int> freq(26, 0);\\n    \\t\\tfor(char c : word)\\n    \\t\\t\\tfreq[c - \\'a\\']++;\\n    \\t\\t// n!\\n    \\t\\tlong res = fact[word.size()];\\n    \\t\\t// n! / a! / b!/ ...\\n    \\t\\tfor(int cnt : freq)\\n    \\t\\t\\tif(cnt > 1)\\n    \\t\\t\\t\\tres = res * invfact[cnt] % mod;\\n    \\t\\tans = ans * res % mod;\\n    \\t}\\n        return ans;\\n    }  \\nprivate:\\n\\tlong binpow(long a, long n, long m) {\\n\\t\\tlong res = 1;\\n\\t\\twhile(n > 0) {\\n\\t\\t\\tif(n % 2)\\n\\t\\t\\t\\tres = res * a % m;\\n\\t\\t\\ta = a * a % m;\\n\\t\\t\\tn /= 2;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nb*b\\' mod m === 1 mod m\\n```\n```\\na mod m === (a * 1) mod m === (a * b * b\\') mod m;\\n(a / b) mod m === (b * b\\' * a / b) mod m;\\n(a / b) mod m === (a * b\\') mod m;\\n```\n```\\n(a^p - a) mod p = 0\\n```\n```\\n(a^(p-1) - 1) mod p = 0 => a^(p-1) === 1 mod p\\n```\n```\\n[n! / (a!*b!*...)] mod m === (n! mod m) * [(a!)\\' mod m] * [(b!)\\' mod m] * ...\\n\\n=> n! * (a!)^(m-2) * (b!)^(m-2) * ... mod m\\n```\n```c++\\nclass Solution {\\npublic:\\n    int countAnagrams(string s) {\\n        // A33/A22 * A33 = 3 * 6 = 18\\n    \\t// modulo multiplicative inverse\\n    \\tint n = s.size();\\n    \\tint mod = 1e9 + 7;\\n    \\t// factorials and inverse factorials\\n    \\tvector<long> fact(n + 1, 1), invfact(n + 1, 1);\\n    \\tfor(int i = 1; i <= n; ++i) {\\n    \\t\\tfact[i] = i * fact[i-1] % mod;\\n    \\t\\tif(i >= 2)\\n\\t    \\t\\tinvfact[i] = binpow(fact[i], mod-2, mod);\\n    \\t}\\n    \\tlong ans = 1;\\n    \\tstring word;\\n    \\tstringstream ss(s);\\n    \\twhile(ss >> word) {\\n    \\t\\tvector<int> freq(26, 0);\\n    \\t\\tfor(char c : word)\\n    \\t\\t\\tfreq[c - \\'a\\']++;\\n    \\t\\t// n!\\n    \\t\\tlong res = fact[word.size()];\\n    \\t\\t// n! / a! / b!/ ...\\n    \\t\\tfor(int cnt : freq)\\n    \\t\\t\\tif(cnt > 1)\\n    \\t\\t\\t\\tres = res * invfact[cnt] % mod;\\n    \\t\\tans = ans * res % mod;\\n    \\t}\\n        return ans;\\n    }  \\nprivate:\\n\\tlong binpow(long a, long n, long m) {\\n\\t\\tlong res = 1;\\n\\t\\twhile(n > 0) {\\n\\t\\t\\tif(n % 2)\\n\\t\\t\\t\\tres = res * a % m;\\n\\t\\t\\ta = a * a % m;\\n\\t\\t\\tn /= 2;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947611,
                "title": "python-bruteforce-no-modulo-inverse",
                "content": "\\n# Code\\n```\\nfrom collections import Counter\\nfrom math import factorial\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        MOD = 10**9 + 7\\n        def f(w):\\n            n = len(w)\\n            counter = Counter(w)\\n            divisor = 1\\n            for a in counter.values():\\n                divisor = divisor * factorial(a)\\n            res = (factorial(n)//divisor)%MOD    \\n            return res\\n        res = 1\\n        for w in s.split():\\n            res = (res*f(w))%MOD\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nfrom math import factorial\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        MOD = 10**9 + 7\\n        def f(w):\\n            n = len(w)\\n            counter = Counter(w)\\n            divisor = 1\\n            for a in counter.values():\\n                divisor = divisor * factorial(a)\\n            res = (factorial(n)//divisor)%MOD    \\n            return res\\n        res = 1\\n        for w in s.split():\\n            res = (res*f(w))%MOD\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947468,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dfs(self, t):\\n        dict1, total = collections.Counter(t), 1\\n\\n        for i in dict1:\\n            total *= math.factorial(dict1[i])\\n\\n        return math.factorial(len(t))//total\\n\\n    def countAnagrams(self, s):\\n        ans, res, result = s.split(), [], 1\\n\\n        for i in ans:\\n            res.append(self.dfs(i))\\n\\n        for i in res:\\n            result *= i\\n\\n        return result%(10**9+7)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, t):\\n        dict1, total = collections.Counter(t), 1\\n\\n        for i in dict1:\\n            total *= math.factorial(dict1[i])\\n\\n        return math.factorial(len(t))//total\\n\\n    def countAnagrams(self, s):\\n        ans, res, result = s.split(), [], 1\\n\\n        for i in ans:\\n            res.append(self.dfs(i))\\n\\n        for i in res:\\n            result *= i\\n\\n        return result%(10**9+7)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947295,
                "title": "number-of-permutations-with-repetitions",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        def extended_gcd(a, b):\\n            s, old_s = 0, 1\\n            r, old_r = b, a\\n            while r:\\n                q = old_r // r\\n                old_r, r = r, old_r - q * r\\n                old_s, s = s, old_s - q * s\\n            return old_r, old_s, (old_r - old_s * a) // b if b else 0\\n        def modinv(a, m):\\n            g, x, _ = extended_gcd(a % m, m)\\n            return x % m if g == 1 else None\\n        M = 10 ** 9 + 7\\n        k = max([len(w) for w in s.split()])\\n        facts = [0] * (k + 1)\\n        facts[0] = 1\\n        for i in range(1, k + 1):\\n            facts[i] = (i * facts[i - 1]) % M\\n        res = 1\\n        for w in s.split():\\n            n = len(w)\\n            ctr = Counter(w)\\n            res = (res * facts[n]) % M\\n            for c in ctr:\\n                res = (res * modinv(facts[ctr[c]], M)) % M\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        def extended_gcd(a, b):\\n            s, old_s = 0, 1\\n            r, old_r = b, a\\n            while r:\\n                q = old_r // r\\n                old_r, r = r, old_r - q * r\\n                old_s, s = s, old_s - q * s\\n            return old_r, old_s, (old_r - old_s * a) // b if b else 0\\n        def modinv(a, m):\\n            g, x, _ = extended_gcd(a % m, m)\\n            return x % m if g == 1 else None\\n        M = 10 ** 9 + 7\\n        k = max([len(w) for w in s.split()])\\n        facts = [0] * (k + 1)\\n        facts[0] = 1\\n        for i in range(1, k + 1):\\n            facts[i] = (i * facts[i - 1]) % M\\n        res = 1\\n        for w in s.split():\\n            n = len(w)\\n            ctr = Counter(w)\\n            res = (res * facts[n]) % M\\n            for c in ctr:\\n                res = (res * modinv(facts[ctr[c]], M)) % M\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947276,
                "title": "modular-inversion",
                "content": "```\\nclass Solution {\\npublic:\\n    const static int mod=1e9+7, n=1e5+10;\\n    long long fact[n];\\n    \\n    long long power(long long x, long long y, int mod) {\\n        long long ans=1;\\n        x%=mod;\\n        while(y>0) {\\n            if(y&1) {\\n                ans=(ans*x)%mod;\\n            }\\n            y>>=1;\\n            x=(x*x)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    long long inv(long long m, int mod) {\\n        return power(m, mod-2, mod);\\n    }\\n    \\n    void init() {\\n        fact[0]=1;\\n        for(int i=1;i<n;i++) {\\n            fact[i]=(i*fact[i-1])%mod;\\n        }\\n    }\\n    \\n    int countAnagrams(string s) {\\n        init();\\n        string w;\\n        stringstream is(s);\\n        long long ans=1;\\n        while (is>>w) {\\n          string p=w;\\n          long long check=1;\\n          vector<long long> v(26, 0);\\n          for(auto x: p) {\\n              v[x-\\'a\\']++;\\n          }\\n          ans=(ans*fact[p.length()])%mod;\\n          for(int i=0;i<26;i++) {\\n              if(v[i]) {\\n                  ans=(ans*inv(fact[v[i]], mod))%mod;\\n              }\\n          }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const static int mod=1e9+7, n=1e5+10;\\n    long long fact[n];\\n    \\n    long long power(long long x, long long y, int mod) {\\n        long long ans=1;\\n        x%=mod;\\n        while(y>0) {\\n            if(y&1) {\\n                ans=(ans*x)%mod;\\n            }\\n            y>>=1;\\n            x=(x*x)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    long long inv(long long m, int mod) {\\n        return power(m, mod-2, mod);\\n    }\\n    \\n    void init() {\\n        fact[0]=1;\\n        for(int i=1;i<n;i++) {\\n            fact[i]=(i*fact[i-1])%mod;\\n        }\\n    }\\n    \\n    int countAnagrams(string s) {\\n        init();\\n        string w;\\n        stringstream is(s);\\n        long long ans=1;\\n        while (is>>w) {\\n          string p=w;\\n          long long check=1;\\n          vector<long long> v(26, 0);\\n          for(auto x: p) {\\n              v[x-\\'a\\']++;\\n          }\\n          ans=(ans*fact[p.length()])%mod;\\n          for(int i=0;i<26;i++) {\\n              if(v[i]) {\\n                  ans=(ans*inv(fact[v[i]], mod))%mod;\\n              }\\n          }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947127,
                "title": "c-solution",
                "content": "Intuition:C++,Accepted\\n\\nprecompute permution\\nget word one by one and get permutation of all words.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\no(100005)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->o(100005)\\n\\n# Code\\n```\\nclass Solution {\\npublic:vector<long long int>dp;\\nint mod=1e9+7;\\nlong long power(long long  a,long long b)\\n    {\\n     long long  res=1;\\n        while(b)\\n        {\\n            if(b&1)\\n            {\\n                res=(res*a)%mod;\\n            }\\n            a=(a*a)%mod;\\n            b/=2;\\n        }\\n        return res;\\n    }\\n    int countAnagrams(string s) {\\n        dp.resize(100005,1);\\n        for(int i=1;i<100005;i++){\\n            dp[i]=(dp[i-1]*(1LL)*i)%mod;\\n        }\\n        stringstream ss(s);\\n        long long ans=1;\\n        string word;int place=1;\\n        while(ss>>word){\\n            string w=word;\\n            map<int,int>mp;int len=w.size();\\n            for(char ch:w){\\n             \\n                mp[ch-\\'a\\']++;\\n            }\\n           long long int parmu=dp[len]%mod;\\n            cout<<parmu<<endl;\\n            for(auto it :mp){\\n              parmu=parmu*(1LL)*power(dp[it.second],mod-2); \\n              parmu%=mod;\\n           }\\n            cout<<parmu<<endl;\\n            ans=(((ans*(1LL)*parmu)))/place%1000000007;\\n          \\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:vector<long long int>dp;\\nint mod=1e9+7;\\nlong long power(long long  a,long long b)\\n    {\\n     long long  res=1;\\n        while(b)\\n        {\\n            if(b&1)\\n            {\\n                res=(res*a)%mod;\\n            }\\n            a=(a*a)%mod;\\n            b/=2;\\n        }\\n        return res;\\n    }\\n    int countAnagrams(string s) {\\n        dp.resize(100005,1);\\n        for(int i=1;i<100005;i++){\\n            dp[i]=(dp[i-1]*(1LL)*i)%mod;\\n        }\\n        stringstream ss(s);\\n        long long ans=1;\\n        string word;int place=1;\\n        while(ss>>word){\\n            string w=word;\\n            map<int,int>mp;int len=w.size();\\n            for(char ch:w){\\n             \\n                mp[ch-\\'a\\']++;\\n            }\\n           long long int parmu=dp[len]%mod;\\n            cout<<parmu<<endl;\\n            for(auto it :mp){\\n              parmu=parmu*(1LL)*power(dp[it.second],mod-2); \\n              parmu%=mod;\\n           }\\n            cout<<parmu<<endl;\\n            ans=(((ans*(1LL)*parmu)))/place%1000000007;\\n          \\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2947101,
                "title": "c-easy-solution",
                "content": "To find permutation of a word we apply the formula\\n```\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t(a + b + c + ...)! / a!b!c!...\\n```\\nwhere a, b, c ... are the count of each letter.\\n\\nSo we keep applying for the formula for each word.\\n\\n```\\nstruct Mint {\\n    int val = 0;\\n    const int Mod = 1e9 + 7;\\n\\n    constexpr Mint() : val() {}\\n\\n    Mint(const long long &_val) {\\n        val = _val % Mod;\\n    }\\n\\n    Mint operator+(Mint x) {\\n        return val + x.val;\\n    }\\n    Mint operator*(Mint x) {\\n        return 1LL * val * x.val;\\n    }\\n\\n    Mint operator-(Mint x) {\\n        return val - x.val + Mod;\\n    }\\n\\n    void operator+=(Mint x) {\\n        val = (Mint(val) + x).val;\\n    }\\n\\n    void operator-=(Mint x) {\\n        val = (Mint(val) - x).val;\\n    }\\n\\n    void operator*=(Mint x) {\\n        val = (Mint(val) * x).val;\\n    }\\n};\\n\\nclass Solution {\\n    int Mod;\\n    vector<Mint> factorial, inv_factorial;\\n\\n    Mint power_mint(Mint a, int b) {\\n        Mint res = 1;\\n        while (b > 0) {\\n            if (b & 1) res *= a;\\n            a *= a;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n\\n    void ensure_fact(int n) {\\n        if (factorial.empty()) {\\n            factorial.push_back(1);\\n            inv_factorial.push_back(1);\\n        }\\n        while (n >= factorial.size()) {\\n            factorial.push_back(factorial.back() * factorial.size());\\n            inv_factorial.push_back(power_mint(factorial.back(), Mod - 2));\\n        }\\n    }\\n\\n    Mint fact(int n) {\\n        ensure_fact(n);\\n        return factorial[n];\\n    }\\n\\n    Mint ifact(int n) {\\n        ensure_fact(n);\\n        return inv_factorial[n];\\n    }\\n\\npublic:\\n    int countAnagrams(string s) {\\n        Mod = 1e9 + 7;\\n        Mint ans = 1;\\n        stringstream str(s);\\n        string word;\\n        while (str >> word) {\\n            vector<int> cnt(26);\\n            for (char c : word) cnt[c - \\'a\\']++;\\n            Mint cur = fact(word.size());\\n            for (int i = 0; i < 26; i++) {\\n                cur *= ifact(cnt[i]);\\n            }\\n            ans *= cur;\\n        }\\n        return ans.val;\\n    }\\n};\\n```\\n\\nIf you have any doubts feel free to ask :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t(a + b + c + ...)! / a!b!c!...\\n```\n```\\nstruct Mint {\\n    int val = 0;\\n    const int Mod = 1e9 + 7;\\n\\n    constexpr Mint() : val() {}\\n\\n    Mint(const long long &_val) {\\n        val = _val % Mod;\\n    }\\n\\n    Mint operator+(Mint x) {\\n        return val + x.val;\\n    }\\n    Mint operator*(Mint x) {\\n        return 1LL * val * x.val;\\n    }\\n\\n    Mint operator-(Mint x) {\\n        return val - x.val + Mod;\\n    }\\n\\n    void operator+=(Mint x) {\\n        val = (Mint(val) + x).val;\\n    }\\n\\n    void operator-=(Mint x) {\\n        val = (Mint(val) - x).val;\\n    }\\n\\n    void operator*=(Mint x) {\\n        val = (Mint(val) * x).val;\\n    }\\n};\\n\\nclass Solution {\\n    int Mod;\\n    vector<Mint> factorial, inv_factorial;\\n\\n    Mint power_mint(Mint a, int b) {\\n        Mint res = 1;\\n        while (b > 0) {\\n            if (b & 1) res *= a;\\n            a *= a;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n\\n    void ensure_fact(int n) {\\n        if (factorial.empty()) {\\n            factorial.push_back(1);\\n            inv_factorial.push_back(1);\\n        }\\n        while (n >= factorial.size()) {\\n            factorial.push_back(factorial.back() * factorial.size());\\n            inv_factorial.push_back(power_mint(factorial.back(), Mod - 2));\\n        }\\n    }\\n\\n    Mint fact(int n) {\\n        ensure_fact(n);\\n        return factorial[n];\\n    }\\n\\n    Mint ifact(int n) {\\n        ensure_fact(n);\\n        return inv_factorial[n];\\n    }\\n\\npublic:\\n    int countAnagrams(string s) {\\n        Mod = 1e9 + 7;\\n        Mint ans = 1;\\n        stringstream str(s);\\n        string word;\\n        while (str >> word) {\\n            vector<int> cnt(26);\\n            for (char c : word) cnt[c - \\'a\\']++;\\n            Mint cur = fact(word.size());\\n            for (int i = 0; i < 26; i++) {\\n                cur *= ifact(cnt[i]);\\n            }\\n            ans *= cur;\\n        }\\n        return ans.val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947043,
                "title": "c-permutations-and-modular-inverse",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n(a/b)%m = (a%m*(b^-1)%m)%m\\n\\n# Code\\n```\\nconstexpr int m = 1e9+7, r = 1e5;\\n\\nclass Solution {\\npublic:\\n    long long fact[r+1], inv_fact[r+1], inv_mod[r+1];\\n    \\n    void comp_inv_mod(){\\n        inv_mod[1] = 1;\\n        for(int i = 2; i<=r; i++){\\n            inv_mod[i] = m - (m/i) * (inv_mod[m%i]%m) % m;\\n        }\\n    }\\n    void comp_fact(){\\n        fact[0] = 1;\\n        inv_fact[0] = 1;\\n        for(int i = 1; i<=r; i++){\\n            fact[i] = (i*fact[i-1])%m;\\n            inv_fact[i] = (inv_mod[i] * inv_fact[i-1])%m;\\n        }\\n    }\\n    long long solve(string &s){\\n        int res = fact[s.size()];\\n        int mp[26] = {0};\\n\\n        for(auto &c: s){\\n            mp[c-\\'a\\']++;\\n        }\\n\\n        for(int i = 0; i<26; i++){\\n            if(mp[i]<=1) continue;\\n            res = (res*inv_fact[mp[i]])%m;//formula mentioned above\\n        }\\n\\n        return res%m;\\n    }\\n    int countAnagrams(string s) {\\n        comp_inv_mod();\\n        comp_fact();\\n        string temp;\\n        s.push_back(\\' \\');\\n        int res = 1;\\n\\n        for(auto &c: s){\\n            if(c==\\' \\'){\\n                res = (res * solve(temp))%m;\\n                temp = \"\";\\n            }\\n            else temp.push_back(c);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nconstexpr int m = 1e9+7, r = 1e5;\\n\\nclass Solution {\\npublic:\\n    long long fact[r+1], inv_fact[r+1], inv_mod[r+1];\\n    \\n    void comp_inv_mod(){\\n        inv_mod[1] = 1;\\n        for(int i = 2; i<=r; i++){\\n            inv_mod[i] = m - (m/i) * (inv_mod[m%i]%m) % m;\\n        }\\n    }\\n    void comp_fact(){\\n        fact[0] = 1;\\n        inv_fact[0] = 1;\\n        for(int i = 1; i<=r; i++){\\n            fact[i] = (i*fact[i-1])%m;\\n            inv_fact[i] = (inv_mod[i] * inv_fact[i-1])%m;\\n        }\\n    }\\n    long long solve(string &s){\\n        int res = fact[s.size()];\\n        int mp[26] = {0};\\n\\n        for(auto &c: s){\\n            mp[c-\\'a\\']++;\\n        }\\n\\n        for(int i = 0; i<26; i++){\\n            if(mp[i]<=1) continue;\\n            res = (res*inv_fact[mp[i]])%m;//formula mentioned above\\n        }\\n\\n        return res%m;\\n    }\\n    int countAnagrams(string s) {\\n        comp_inv_mod();\\n        comp_fact();\\n        string temp;\\n        s.push_back(\\' \\');\\n        int res = 1;\\n\\n        for(auto &c: s){\\n            if(c==\\' \\'){\\n                res = (res * solve(temp))%m;\\n                temp = \"\";\\n            }\\n            else temp.push_back(c);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947034,
                "title": "count-use-reverse-number",
                "content": "# Intuition\\nFor each word, if the length is n and each letter occurs a1, a2, a3...times separately, it has n! / (a1!) / (a2!) / (a3!)....anagrams.\\n\\nFor each word, count the number of its anagrams and the product of all of them is the final answer.\\n\\n# Approach\\nFor each word, we can calculate the number of anagrams using simple loop and an unordered_map (hashmap or simple array of length 26) to count how many times each letter occurs.\\n\\nBasically, starting from num = 1 and len = 0, with a hash map named **map**, if we have a letter c, then we need to do:\\n* increase len by 1, namely, len += 1\\n* multiply num by len, namely, num *= len\\n* increase the frequency of c by 1, namely, map[c] += 1\\n* divide num by map[c], namely, num /= map[c]\\n\\nFor the division part, we need to use the reverse number, given M = 1000000007, for each x (x = map[c] now), we want to find the reverse of x, rev(x) such that\\nrev(x) * x == 1 (mod M)\\nSince M is a prime number, according to **Fermat\\'s Theorem** we have\\nx ^ (M - 1) == 1 (mod M), So rev(x) == x ^ (M - 2) (mod M).\\nAnd to calculate the x ^ (M - 2) % M, we can use the divide and conquer way (https://en.wikipedia.org/wiki/Exponentiation_by_squaring) to do it in O(logM) time.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nSuppose the length of the string is **n** and M = 1000000007, the time complexity is to calculate the reverse number O(n) times which is O(n * log(M))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    const int M = 1000000007;\\n\\n    int mul(long long x, long long y) {\\n        return x * y % M;\\n    }\\n\\n    int pow(int x, int y) {\\n        int r = 1;\\n        for (; y; y >>= 1) {\\n            if (y & 1) {\\n                r = mul(r, x);\\n            }\\n            x = mul(x, x);\\n        }\\n        return r;\\n    }\\n\\n    int rev(int x) {\\n        return pow(x, M - 2);\\n    }\\n\\npublic:\\n    int countAnagrams(string s) {\\n      istringstream in(s);\\n      int r = 1;\\n      while (in >> s) {\\n          unordered_map<char, int> map;\\n          int len = 0;\\n          for (char c : s) {\\n              r = mul(r, ++len);\\n              r = mul(r, rev(++map[c]));\\n          }\\n      }\\n      return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    const int M = 1000000007;\\n\\n    int mul(long long x, long long y) {\\n        return x * y % M;\\n    }\\n\\n    int pow(int x, int y) {\\n        int r = 1;\\n        for (; y; y >>= 1) {\\n            if (y & 1) {\\n                r = mul(r, x);\\n            }\\n            x = mul(x, x);\\n        }\\n        return r;\\n    }\\n\\n    int rev(int x) {\\n        return pow(x, M - 2);\\n    }\\n\\npublic:\\n    int countAnagrams(string s) {\\n      istringstream in(s);\\n      int r = 1;\\n      while (in >> s) {\\n          unordered_map<char, int> map;\\n          int len = 0;\\n          for (char c : s) {\\n              r = mul(r, ++len);\\n              r = mul(r, rev(++map[c]));\\n          }\\n      }\\n      return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947009,
                "title": "modulo-arithmetic-java-simple-solution-clean-code",
                "content": "# Code\\n```java\\nclass Solution extends Modulo{\\n    public int countAnagrams(String s) {\\n        String tokens[] = s.split(\" \");\\n        long ans = 1;\\n        for(var t:tokens){\\n            Map<Character,Integer> mp = new HashMap<>();\\n            for(int i = 0;i < t.length();i++){\\n                mp.put(t.charAt(i),mp.getOrDefault(t.charAt(i),0) + 1);\\n            }\\n            long d = 1;\\n            for(var ent:mp.entrySet()){\\n                d = mulMod(d,fact[ent.getValue()]); \\n            }\\n            ans = mulMod(ans,divMod(fact[t.length()],d));\\n        }\\n        return (int)ans;\\n    }\\n}\\n\\nclass Modulo {\\n    public static final int MOD = (int) 1e9 + 7;\\n\\n    public static long inv[];\\n\\n    public static long fact[];\\n\\n    public static long invFact[];\\n\\n    static {\\n        int N = (int) 1e5;\\n        inv = new long[N + 1];\\n        fact = new long[N + 1];\\n        invFact = new long[N + 1];\\n\\n        fact[0] = 1;\\n        for (int i = 1; i <= N; ++i) {\\n            fact[i] = mulMod(fact[i - 1], i);\\n        }\\n\\n        invFact[0] = 1;\\n        for (int i = 1; i <= N; ++i) {\\n            invFact[i] = mulMod(invFact[i - 1], invMod(i));\\n        }\\n    }\\n\\n    private static void preComputeInverse(int N){\\n        inv[0] = 0;inv[1] = 1;\\n        for (int i = 2; i <= N; ++i){\\n            inv[i] = (MOD - (MOD / i)) * inv[MOD % i] % MOD;\\n        }\\n    }\\n\\n    public static long powMod(long base, long exp) {\\n        long ans = 1;\\n        for (; exp != 0;) {\\n            if ((exp & 1) == 1) {\\n                ans *= base;\\n                ans %= MOD;\\n            }\\n            base *= base;\\n            base %= MOD;\\n            exp = exp >> 1;\\n        }\\n        return ans;\\n    }\\n\\n    public static long mulMod(long a, long b) {\\n        long ans = 0;\\n        for (; b != 0;) {\\n            if ((b & 1) == 1) {\\n                ans += a;\\n                ans %= MOD;\\n            }\\n            a += a;\\n            a %= MOD;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n    public static long invMod(long num) {\\n        return powMod(num, MOD - 2); // only works if MOD is prime\\n    }\\n\\n    public static long divMod(long a, long b) {\\n        return mulMod(a, invMod(b));\\n    }\\n\\n    public static long factMod(int n) {\\n        return fact[n];\\n    }\\n\\n    public static long nCrMod(int n, int r) {\\n        if (n < r)\\n            return 0;\\n        if (r == 0)\\n            return 1;\\n\\n        return mulMod(fact[n], mulMod(invFact[n - r], invFact[r]));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Number Theory"
                ],
                "code": "```java\\nclass Solution extends Modulo{\\n    public int countAnagrams(String s) {\\n        String tokens[] = s.split(\" \");\\n        long ans = 1;\\n        for(var t:tokens){\\n            Map<Character,Integer> mp = new HashMap<>();\\n            for(int i = 0;i < t.length();i++){\\n                mp.put(t.charAt(i),mp.getOrDefault(t.charAt(i),0) + 1);\\n            }\\n            long d = 1;\\n            for(var ent:mp.entrySet()){\\n                d = mulMod(d,fact[ent.getValue()]); \\n            }\\n            ans = mulMod(ans,divMod(fact[t.length()],d));\\n        }\\n        return (int)ans;\\n    }\\n}\\n\\nclass Modulo {\\n    public static final int MOD = (int) 1e9 + 7;\\n\\n    public static long inv[];\\n\\n    public static long fact[];\\n\\n    public static long invFact[];\\n\\n    static {\\n        int N = (int) 1e5;\\n        inv = new long[N + 1];\\n        fact = new long[N + 1];\\n        invFact = new long[N + 1];\\n\\n        fact[0] = 1;\\n        for (int i = 1; i <= N; ++i) {\\n            fact[i] = mulMod(fact[i - 1], i);\\n        }\\n\\n        invFact[0] = 1;\\n        for (int i = 1; i <= N; ++i) {\\n            invFact[i] = mulMod(invFact[i - 1], invMod(i));\\n        }\\n    }\\n\\n    private static void preComputeInverse(int N){\\n        inv[0] = 0;inv[1] = 1;\\n        for (int i = 2; i <= N; ++i){\\n            inv[i] = (MOD - (MOD / i)) * inv[MOD % i] % MOD;\\n        }\\n    }\\n\\n    public static long powMod(long base, long exp) {\\n        long ans = 1;\\n        for (; exp != 0;) {\\n            if ((exp & 1) == 1) {\\n                ans *= base;\\n                ans %= MOD;\\n            }\\n            base *= base;\\n            base %= MOD;\\n            exp = exp >> 1;\\n        }\\n        return ans;\\n    }\\n\\n    public static long mulMod(long a, long b) {\\n        long ans = 0;\\n        for (; b != 0;) {\\n            if ((b & 1) == 1) {\\n                ans += a;\\n                ans %= MOD;\\n            }\\n            a += a;\\n            a %= MOD;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n    public static long invMod(long num) {\\n        return powMod(num, MOD - 2); // only works if MOD is prime\\n    }\\n\\n    public static long divMod(long a, long b) {\\n        return mulMod(a, invMod(b));\\n    }\\n\\n    public static long factMod(int n) {\\n        return fact[n];\\n    }\\n\\n    public static long nCrMod(int n, int r) {\\n        if (n < r)\\n            return 0;\\n        if (r == 0)\\n            return 1;\\n\\n        return mulMod(fact[n], mulMod(invFact[n - r], invFact[r]));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946984,
                "title": "python-maths-factorial-formula-for-counting-distinct-anagrams-explained",
                "content": "# Intuition\\nIt is a classic Indian 11th class Permutation and Combination\\'s question.\\n\\n# Approach\\nNumber of Unique Anagrams can be found using the formulae of permutations i.e.$$ n!/(a!b!c!..)$$ where n is the length of the word and a, b and c are the number of occurance of characters.\\nMultiply all those to find the number of distinct anagrams \\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the number of characters\\n\\n- Space complexity: $$O(n)$$, where n is the number of characters\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        def noOfUniqueAnagrams(word: str) -> int:\\n            nFact = factorial(len(word))\\n            letterMap = {i: 0 for i in word}\\n            for i in word:\\n                letterMap[i] += 1\\n            for i in letterMap:\\n                nFact //= factorial(letterMap[i])\\n            return nFact % 1000000007\\n        \\n        s = s.split()        \\n        res = 1\\n        for i in s:\\n            res *= noOfUniqueAnagrams(i)\\n        return res % 1000000007\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        def noOfUniqueAnagrams(word: str) -> int:\\n            nFact = factorial(len(word))\\n            letterMap = {i: 0 for i in word}\\n            for i in word:\\n                letterMap[i] += 1\\n            for i in letterMap:\\n                nFact //= factorial(letterMap[i])\\n            return nFact % 1000000007\\n        \\n        s = s.split()        \\n        res = 1\\n        for i in s:\\n            res *= noOfUniqueAnagrams(i)\\n        return res % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946980,
                "title": "mathematical-explanation-for-who-needs-a-proof",
                "content": "**Algorithm:**\\n1. Cutting the string into a collection of words;\\n\\n2. For each word, considering the number of possible permutations (aka permutation with repetition, proof can be found https://brilliant.org/wiki/permutations-with-repetition/ Unfortunately, I cannot give you links to wikipedia which has been banned in my country for years T_T).\\n\\n```\\nfractional of \"sum(count(A) + count(B) + ... + count(Z))\" \\n_________________________________________________________________________________________\\nfractional of \"count(A)\" *  fractional of \"count(B)\" * ... * fractional of \"count(Z)\"\\n```\\n\\n3. Multiplication the number of permutation for each word;\\n\\n**Multiplication & Division with Modulo**\\n1. The mutiplication part should be easy, (AxB)%C=((A%C)x(B%C))%C\\n2. The division part will use \"Euler\\'s Totient Function\" c.f. https://brilliant.org/wiki/eulers-totient-function/ or \"Fermat\\'s little theorem\" c.f. https://brilliant.org/wiki/fermats-little-theorem/ which would be taught by coursed as \"Number Theory\", \"Abstract Math\" or \"Math Basis for Information Security\" etc.\\nIn our case, P=1e9+7 is a prime and the power of a in [2,P-1] can form a field with modulo, i.e. {a^1, a^2, ..., a^(P-1)} %P = [1, P-1]. According to the  properties of a \"filed\",  **a^(P-1) % P =1**, for a in [1, P-1].\\nIn other words, we know a * a^(1e9+5) % (1e9+7) = 1\\n3. rapid calculation of power  a^(1e9+5): As you know, a^(b+c+...+d)=a^b x a^c x ... x a^d. The main idea is similar. Let us decompose (1e9+5) into the sum of a collection of power of 2 (aka binary presentation). Then we calculate a^1, a^2, .. a^67108864 one by one.  \\n\\n```\\nconst long M=1e9+7;\\nint cnt [26];\\nclass Solution {\\n    long frac (int a) {\\n        long ans=1;\\n        for(int i=2; i<=a; ++i) {\\n            ans=(ans*i)%M;\\n        }\\n        return ans;\\n    }\\n    long calc (long a) {\\n        long m=M-2, ans=1, mul=a;\\n        for(; m; m>>=1) {\\n            if(1&m) {\\n                ans=(ans*mul)%M;\\n            }\\n            mul=(mul*mul)%M;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        s+=\\' \\';\\n        long ans=1;\\n        int n=s.size();\\n        const char * c=s.c_str();\\n        for(int i=0; i<26; cnt[i++]=0) {}\\n        for(int i=0, j, k; i<n; ++i) {\\n            if(c[i]==\\' \\') {\\n                for(k=0, j=0; j<26; ++j) {\\n                    if(cnt[j]) {\\n                        k+=cnt[j];\\n                        ans=(ans*calc(frac(cnt[j])))%M;\\n                        cnt[j]=0;\\n                    }\\n                }\\n                ans=(ans*frac(k))%M;\\n            } else {\\n                ++cnt[c[i]-\\'a\\'];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nfractional of \"sum(count(A) + count(B) + ... + count(Z))\" \\n_________________________________________________________________________________________\\nfractional of \"count(A)\" *  fractional of \"count(B)\" * ... * fractional of \"count(Z)\"\\n```\n```\\nconst long M=1e9+7;\\nint cnt [26];\\nclass Solution {\\n    long frac (int a) {\\n        long ans=1;\\n        for(int i=2; i<=a; ++i) {\\n            ans=(ans*i)%M;\\n        }\\n        return ans;\\n    }\\n    long calc (long a) {\\n        long m=M-2, ans=1, mul=a;\\n        for(; m; m>>=1) {\\n            if(1&m) {\\n                ans=(ans*mul)%M;\\n            }\\n            mul=(mul*mul)%M;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countAnagrams(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        s+=\\' \\';\\n        long ans=1;\\n        int n=s.size();\\n        const char * c=s.c_str();\\n        for(int i=0; i<26; cnt[i++]=0) {}\\n        for(int i=0, j, k; i<n; ++i) {\\n            if(c[i]==\\' \\') {\\n                for(k=0, j=0; j<26; ++j) {\\n                    if(cnt[j]) {\\n                        k+=cnt[j];\\n                        ans=(ans*calc(frac(cnt[j])))%M;\\n                        cnt[j]=0;\\n                    }\\n                }\\n                ans=(ans*frac(k))%M;\\n            } else {\\n                ++cnt[c[i]-\\'a\\'];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946971,
                "title": "c-solution",
                "content": "Here we need to multiply the anagrams for each word with others\\nTotal anagrams for a string will be: (noOfChars!) / (freq[a]! * freq[b]! * ... * freq[z]!)\\n\\nLike for eg: str = \"aabbcc\"\\nthen total anagrams = 6! / (2!*2!*2!) = 120\\n\\nUsing this similar logic.\\nBut calculating factorial takes time, so we will pre calculate it and also calculate the inverse beforehand.\\n\\nC++ code:\\n```\\nclass Solution {\\npublic:\\n    long long gcdExtended(long long a, long long b, long long* x, long long* y) {\\n        // Base Case\\n        if (a == 0) {\\n            *x = 0, * y = 1;\\n            return b;\\n        }\\n\\n        // To store results of recursive call\\n        long long x1, y1;\\n        long long gcd = gcdExtended(b % a, a, &x1, &y1);\\n\\n        // Update x and y using results of recursive\\n        // call\\n        *x = y1 - (b / a) * x1;\\n        *y = x1;\\n        return gcd;\\n    }\\n\\n    // Function to find modulo inverse of a\\n    long long modInverse(long long a, long long m) {\\n        long long x, y;\\n        long long g = gcdExtended(a, m, &x, &y);\\n        if (g != 1) {\\n            return -1;\\n        } else {\\n            // m is added to handle negative x\\n            int res = (x % m + m) % m;\\n            return res;\\n        }\\n    }\\n    \\n    const int MOD = 1e9 + 7;\\n    int maxi = 1e5 + 10;\\n    vector<long long> fact;\\n    vector<long long> inv;\\n\\n    void pre() {\\n        fact.resize(maxi);\\n        inv.resize(maxi);\\n        \\n        fact[0] = 1;\\n        fact[1] = 1;\\n        fact[2] = 2;\\n        for(int i = 3; i < maxi; i++) {\\n            fact[i] = (i * fact[i-1]) % MOD;\\n        }\\n        \\n        for(int i = 0; i < maxi; i++) {\\n            inv[i] = modInverse(fact[i], MOD);\\n        }\\n    }\\n    \\n    vector<string> extract(string& str) {\\n        pre();\\n        int n = str.size();\\n        int i = 0;\\n        vector<string> res;\\n        string temp = \"\";\\n        while(i < n) {\\n            while(i < n && str[i] == \\' \\') i++;\\n            while(i < n && str[i] != \\' \\') {\\n                temp.push_back(str[i]);\\n                i++;\\n            }\\n            if(temp.size()) res.push_back(temp);\\n            temp = \"\";\\n        }\\n        return res;\\n    }\\n    \\n    int countAnagrams(string &s) {\\n        vector<string> words = extract(s);\\n        vector<long long> temp;\\n        for(auto &word: words) {\\n            int len = word.size();\\n            vector<int> freq(26);\\n            for(char ch: word) freq[ch - \\'a\\']++;\\n            \\n            int res = fact[len];\\n            for(auto it: freq) {\\n                res = (res * inv[it] + MOD) % MOD;\\n            }\\n            temp.push_back(res);\\n        }\\n    \\n        long long res = 1;\\n        \\n        for(auto it: temp) {\\n            res *= it;\\n            res %= MOD;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gcdExtended(long long a, long long b, long long* x, long long* y) {\\n        // Base Case\\n        if (a == 0) {\\n            *x = 0, * y = 1;\\n            return b;\\n        }\\n\\n        // To store results of recursive call\\n        long long x1, y1;\\n        long long gcd = gcdExtended(b % a, a, &x1, &y1);\\n\\n        // Update x and y using results of recursive\\n        // call\\n        *x = y1 - (b / a) * x1;\\n        *y = x1;\\n        return gcd;\\n    }\\n\\n    // Function to find modulo inverse of a\\n    long long modInverse(long long a, long long m) {\\n        long long x, y;\\n        long long g = gcdExtended(a, m, &x, &y);\\n        if (g != 1) {\\n            return -1;\\n        } else {\\n            // m is added to handle negative x\\n            int res = (x % m + m) % m;\\n            return res;\\n        }\\n    }\\n    \\n    const int MOD = 1e9 + 7;\\n    int maxi = 1e5 + 10;\\n    vector<long long> fact;\\n    vector<long long> inv;\\n\\n    void pre() {\\n        fact.resize(maxi);\\n        inv.resize(maxi);\\n        \\n        fact[0] = 1;\\n        fact[1] = 1;\\n        fact[2] = 2;\\n        for(int i = 3; i < maxi; i++) {\\n            fact[i] = (i * fact[i-1]) % MOD;\\n        }\\n        \\n        for(int i = 0; i < maxi; i++) {\\n            inv[i] = modInverse(fact[i], MOD);\\n        }\\n    }\\n    \\n    vector<string> extract(string& str) {\\n        pre();\\n        int n = str.size();\\n        int i = 0;\\n        vector<string> res;\\n        string temp = \"\";\\n        while(i < n) {\\n            while(i < n && str[i] == \\' \\') i++;\\n            while(i < n && str[i] != \\' \\') {\\n                temp.push_back(str[i]);\\n                i++;\\n            }\\n            if(temp.size()) res.push_back(temp);\\n            temp = \"\";\\n        }\\n        return res;\\n    }\\n    \\n    int countAnagrams(string &s) {\\n        vector<string> words = extract(s);\\n        vector<long long> temp;\\n        for(auto &word: words) {\\n            int len = word.size();\\n            vector<int> freq(26);\\n            for(char ch: word) freq[ch - \\'a\\']++;\\n            \\n            int res = fact[len];\\n            for(auto it: freq) {\\n                res = (res * inv[it] + MOD) % MOD;\\n            }\\n            temp.push_back(res);\\n        }\\n    \\n        long long res = 1;\\n        \\n        for(auto it: temp) {\\n            res *= it;\\n            res %= MOD;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946922,
                "title": "python-3-multiply-permutations",
                "content": "If you implement your own factorial function, then it may give TLE.\\nBetter to use built-in method `math.factorial()`\\n\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        s = s.split()\\n        mod = 10 ** 9 + 7\\n        \\n        def helper(s):\\n            hm = Counter(s)\\n            \\n            temp = 1\\n            for i in hm:\\n                if hm[i] > 1:\\n                    temp *= factorial(hm[i])\\n            \\n            return factorial(len(s)) // temp\\n        \\n        res = 1\\n        for i in s:\\n            res = (res * helper(i)) % mod\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        s = s.split()\\n        mod = 10 ** 9 + 7\\n        \\n        def helper(s):\\n            hm = Counter(s)\\n            \\n            temp = 1\\n            for i in hm:\\n                if hm[i] > 1:\\n                    temp *= factorial(hm[i])\\n            \\n            return factorial(len(s)) // temp\\n        \\n        res = 1\\n        for i in s:\\n            res = (res * helper(i)) % mod\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946913,
                "title": "python-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake all the words in the strings and find the number of permutations of thaes words. The product of all the permutations of the words gives the required answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find each word use the two pointer approach. Here in the solution \\'i\\' and \\'j\\' are left and right pointers. \\n\\n\\'i\\' points to start of the word.\\n\\'j\\' increases iteratevely until it reaches a space or end of given string.\\n\\nNow we have to find the number of permutations for each word. A helper function \\'perm\\' is used for this purpose.\\nPermutations=(n!)/product of all word count factorials\\nA hashmap/dictionary is used to find the counter of characters. \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def perm(self,word:str)->int:\\n        n=len(word)\\n        d=dict()\\n        ret=math.factorial(n)\\n        for i in range(n):\\n            if ord(word[i]) not in d:\\n                d.update({ord(word[i]):0})\\n            d[ord(word[i])]+=1\\n        for v in d.values():\\n            ret=ret//math.factorial(v)\\n        return ret\\n    def countAnagrams(self, s: str) -> int:\\n        i=0\\n        j=0\\n        n=len(s)\\n        ret=1\\n        while i<n and j<n:\\n            if s[j]==\\' \\':\\n                word=s[i:j]\\n                ret*=self.perm(word)\\n                i=j+1\\n                j=i\\n            elif j==n-1:\\n                word=s[i:]\\n                ret*=self.perm(word)\\n                j+=1\\n            else:j+=1\\n        return ret%(10**9+7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def perm(self,word:str)->int:\\n        n=len(word)\\n        d=dict()\\n        ret=math.factorial(n)\\n        for i in range(n):\\n            if ord(word[i]) not in d:\\n                d.update({ord(word[i]):0})\\n            d[ord(word[i])]+=1\\n        for v in d.values():\\n            ret=ret//math.factorial(v)\\n        return ret\\n    def countAnagrams(self, s: str) -> int:\\n        i=0\\n        j=0\\n        n=len(s)\\n        ret=1\\n        while i<n and j<n:\\n            if s[j]==\\' \\':\\n                word=s[i:j]\\n                ret*=self.perm(word)\\n                i=j+1\\n                j=i\\n            elif j==n-1:\\n                word=s[i:]\\n                ret*=self.perm(word)\\n                j+=1\\n            else:j+=1\\n        return ret%(10**9+7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946889,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n private:\\n  static constexpr int mod = 1e9 + 7;\\n  \\n public:\\n  int countAnagrams(const string &s) {\\n    constexpr int letters = 26;\\n    constexpr char a = \\'a\\';\\n    constexpr char space = \\' \\';\\n    int ret = 1;\\n    int word[letters]{};\\n    for (size_t i = 0; i < s.size() + 1; ++i) {\\n      if (i == s.size() || s[i] == space) {\\n        // a word is found\\n        int item = 1;\\n        const int length = accumulate(word, word + letters, 0);\\n        // calculate `length!`\\n        for (int factor = 2; factor < length + 1; ++factor) {\\n          item = static_cast<int>((static_cast<long long>(item) * factor) % mod);\\n        }\\n        for (const int letter_length : word) {\\n          if (letter_length < 2) {\\n            continue;\\n          }\\n          // calcualte (`item` / `letter_length!`)\\n          for (int factor = 2; factor < letter_length + 1; ++factor) {\\n            item = static_cast<int>((static_cast<long long>(item) * inv(factor)) % mod);\\n          }\\n        }\\n        ret = static_cast<int>((static_cast<long long>(ret) * item) % mod);\\n        memset(word, 0, sizeof(word));\\n        continue;\\n      }\\n      ++word[s[i] - a];\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int inv(const int a) {\\n    int ret = 1;\\n    int base = a;\\n    for (int power = mod - 2; power > 0; power >>= 1) {\\n      if ((power & 0b1) == 0b1) {\\n        ret = static_cast<int>((static_cast<long long>(ret) * base) % mod);\\n      }\\n      base = static_cast<int>((static_cast<long long>(base) * base) % mod);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n private:\\n  static constexpr int mod = 1e9 + 7;\\n  \\n public:\\n  int countAnagrams(const string &s) {\\n    constexpr int letters = 26;\\n    constexpr char a = \\'a\\';\\n    constexpr char space = \\' \\';\\n    int ret = 1;\\n    int word[letters]{};\\n    for (size_t i = 0; i < s.size() + 1; ++i) {\\n      if (i == s.size() || s[i] == space) {\\n        // a word is found\\n        int item = 1;\\n        const int length = accumulate(word, word + letters, 0);\\n        // calculate `length!`\\n        for (int factor = 2; factor < length + 1; ++factor) {\\n          item = static_cast<int>((static_cast<long long>(item) * factor) % mod);\\n        }\\n        for (const int letter_length : word) {\\n          if (letter_length < 2) {\\n            continue;\\n          }\\n          // calcualte (`item` / `letter_length!`)\\n          for (int factor = 2; factor < letter_length + 1; ++factor) {\\n            item = static_cast<int>((static_cast<long long>(item) * inv(factor)) % mod);\\n          }\\n        }\\n        ret = static_cast<int>((static_cast<long long>(ret) * item) % mod);\\n        memset(word, 0, sizeof(word));\\n        continue;\\n      }\\n      ++word[s[i] - a];\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int inv(const int a) {\\n    int ret = 1;\\n    int base = a;\\n    for (int power = mod - 2; power > 0; power >>= 1) {\\n      if ((power & 0b1) == 0b1) {\\n        ret = static_cast<int>((static_cast<long long>(ret) * base) % mod);\\n      }\\n      base = static_cast<int>((static_cast<long long>(base) * base) % mod);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946859,
                "title": "simple-c-optimal-solution-o-n-explianed-120ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLS LIKE THE SOLUTION\\nTry to give a comment\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7; \\n    int countAnagrams(string s) {\\n        int n = s.size(); \\n        vector<long> vec(n+1, 1);\\n        vector<long> ivec(n+1, 1), node(n+1, 1); \\n        for (int i = 1; i <= n; ++i) {\\n            if (i >= 2) node[i] = mod - mod/i * node[mod%i] % mod; \\n            vec[i] = vec[i-1] * i % mod; \\n            ivec[i] = ivec[i-1] * node[i] % mod; \\n        }\\n        long result = 1; \\n        istringstream m(s); \\n        string name; \\n        while (m >> name) {\\n            result = result * vec[name.size()] % mod; \\n            unordered_map<char, int> freq; \\n            for (auto& ch : name) ++freq[ch]; \\n            for (auto& [_, v] : freq) result = result * ivec[v] % mod; \\n        }\\n        return result; \\n    }\\n};\\nPLS LIKE THE SOLUTION\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7; \\n    int countAnagrams(string s) {\\n        int n = s.size(); \\n        vector<long> vec(n+1, 1);\\n        vector<long> ivec(n+1, 1), node(n+1, 1); \\n        for (int i = 1; i <= n; ++i) {\\n            if (i >= 2) node[i] = mod - mod/i * node[mod%i] % mod; \\n            vec[i] = vec[i-1] * i % mod; \\n            ivec[i] = ivec[i-1] * node[i] % mod; \\n        }\\n        long result = 1; \\n        istringstream m(s); \\n        string name; \\n        while (m >> name) {\\n            result = result * vec[name.size()] % mod; \\n            unordered_map<char, int> freq; \\n            for (auto& ch : name) ++freq[ch]; \\n            for (auto& [_, v] : freq) result = result * ivec[v] % mod; \\n        }\\n        return result; \\n    }\\n};\\nPLS LIKE THE SOLUTION\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946796,
                "title": "brute-force-accepted-formula",
                "content": "From basic math one can observe that answer is the product of the number of unique anagrams for each word in a sentence. So, we find number of anagrams of each word in sentence and multiple it.\\n**Formula of finding number of anagrams of word:**\\n```\\nFactorial(length of word)/(multiple Factorial(count of each character in word))\\n```\\n**Example:**\\n```\\ns=\"too hot\"\\nunique number of anagrams of \"too\" = Factorial(3)/(Factorial(1)*Factorial(2)) = 3\\nunique number of anagrams of \"hot\" = Factorial(3)/(Factorial(1)*Factorial(1)*Factorial(1)) = 6\\nanswer = 6*3 =18\\n```\\n\\n**Code:**\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        s=list(s.split())\\n        ans=1\\n        for word in s:\\n            length=len(word)\\n            c=Counter(word)\\n            temp=1\\n            for i in c:\\n                temp*=factorial(c[i])\\n            ans*=(factorial(length)//temp)\\n        return ans%(10**9+7)\\n```\\n\\nYou can understand more about formula from [here](https://www.youtube.com/watch?v=ZL_vjZtnLSA)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nFactorial(length of word)/(multiple Factorial(count of each character in word))\\n```\n```\\ns=\"too hot\"\\nunique number of anagrams of \"too\" = Factorial(3)/(Factorial(1)*Factorial(2)) = 3\\nunique number of anagrams of \"hot\" = Factorial(3)/(Factorial(1)*Factorial(1)*Factorial(1)) = 6\\nanswer = 6*3 =18\\n```\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        s=list(s.split())\\n        ans=1\\n        for word in s:\\n            length=len(word)\\n            c=Counter(word)\\n            temp=1\\n            for i in c:\\n                temp*=factorial(c[i])\\n            ans*=(factorial(length)//temp)\\n        return ans%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946777,
                "title": "c-simple-solution-by-modular-multiplicative-inverse",
                "content": "# Concept\\nFor every word, the anagram of it is `(length!)/((# of a!)*(# of b!)*...*(# of z!)) `. To compute `x/n!` and address overflow issue, use `Modular multiplicative inverse` to compute `x/n! in mod(1e9 + 7)` by `x * inv(1) * inv(2) * ... * inv(n)` in mod(1e9 + 7).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long inv(long long a, long long mod) {\\n        if (a == 1) return 1;\\n        return (mod - mod / a) * inv(mod % a, mod) % mod;\\n    }\\n    int countAnagrams(string s) {\\n        stringstream ss(s);\\n        string temp;\\n        long long ans = 1;\\n        long long mod = 1e9 + 7;\\n        \\n        vector<int> counts(26, 0);\\n        while (getline(ss, temp, \\' \\')) {\\n            for (int i = 0; i < 26; ++i) counts[i] = 0;\\n            int total = temp.size();\\n            for (int i = 0; i < total; ++i) counts[temp[i] - \\'a\\']++;\\n            long long current = 1;\\n            for (int i = 1; i <= total; ++i) {\\n                current *= i;\\n                current %= mod;\\n            }\\n            for (int i = 0; i < 26; ++i) {\\n                for (int j = 2; j <= counts[i]; ++j) {\\n                    current *= inv(j, mod);\\n                    current %= mod;\\n                }\\n            }\\n            ans *= current;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long inv(long long a, long long mod) {\\n        if (a == 1) return 1;\\n        return (mod - mod / a) * inv(mod % a, mod) % mod;\\n    }\\n    int countAnagrams(string s) {\\n        stringstream ss(s);\\n        string temp;\\n        long long ans = 1;\\n        long long mod = 1e9 + 7;\\n        \\n        vector<int> counts(26, 0);\\n        while (getline(ss, temp, \\' \\')) {\\n            for (int i = 0; i < 26; ++i) counts[i] = 0;\\n            int total = temp.size();\\n            for (int i = 0; i < total; ++i) counts[temp[i] - \\'a\\']++;\\n            long long current = 1;\\n            for (int i = 1; i <= total; ++i) {\\n                current *= i;\\n                current %= mod;\\n            }\\n            for (int i = 0; i < 26; ++i) {\\n                for (int j = 2; j <= counts[i]; ++j) {\\n                    current *= inv(j, mod);\\n                    current %= mod;\\n                }\\n            }\\n            ans *= current;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946751,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n   ll power(ll x,ll y, ll p)\\n    {\\n        ll res = 1; \\n        x = x % p;\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res * x) % p;\\n            y = y >> 1; \\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n\\n    ll modInverse(ll n, ll p)\\n    {\\n        return power(n, p - 2, p);\\n    }\\n    int countAnagrams(string s) \\n    {\\n        int mod = 1e9+7;\\n        int n = s.length();\\n       vector<int>v(n+1,0);\\n        \\n        v[0]=1;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            v[i]=(1LL*i*v[i-1])%mod;\\n        }\\n        \\n        string p=\"\";\\n        map<char,int>mp;\\n        int ans =1;\\n        for(int i=0;s[i];i++)\\n        {\\n            if(s[i]==\\' \\'||i==s.length()-1)\\n            {\\n                if(i==s.length()-1)\\n                {\\n                    p+=s[i];\\n                    mp[s[i]]++;\\n                }\\n                int l = p.length();\\n                l = v[l];\\n                \\n                int r =1;\\n                \\n                for(auto x:mp)\\n                {\\n                    r= (1LL*r*v[(x.second)])%mod;\\n                }\\n    \\n                ans=(1LL*ans*(1LL*l*modInverse(r,mod)%mod))%mod;\\n                ans%=mod;\\n                p=\"\";\\n                mp.clear();  \\n            }\\n            else\\n            {\\n               p+=s[i];\\n               mp[s[i]]++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n   ll power(ll x,ll y, ll p)\\n    {\\n        ll res = 1; \\n        x = x % p;\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res * x) % p;\\n            y = y >> 1; \\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n\\n    ll modInverse(ll n, ll p)\\n    {\\n        return power(n, p - 2, p);\\n    }\\n    int countAnagrams(string s) \\n    {\\n        int mod = 1e9+7;\\n        int n = s.length();\\n       vector<int>v(n+1,0);\\n        \\n        v[0]=1;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            v[i]=(1LL*i*v[i-1])%mod;\\n        }\\n        \\n        string p=\"\";\\n        map<char,int>mp;\\n        int ans =1;\\n        for(int i=0;s[i];i++)\\n        {\\n            if(s[i]==\\' \\'||i==s.length()-1)\\n            {\\n                if(i==s.length()-1)\\n                {\\n                    p+=s[i];\\n                    mp[s[i]]++;\\n                }\\n                int l = p.length();\\n                l = v[l];\\n                \\n                int r =1;\\n                \\n                for(auto x:mp)\\n                {\\n                    r= (1LL*r*v[(x.second)])%mod;\\n                }\\n    \\n                ans=(1LL*ans*(1LL*l*modInverse(r,mod)%mod))%mod;\\n                ans%=mod;\\n                p=\"\";\\n                mp.clear();  \\n            }\\n            else\\n            {\\n               p+=s[i];\\n               mp[s[i]]++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946734,
                "title": "c-math-solution-using-combinatorics",
                "content": "```\\nbool flag=false;\\nlong f[100001]={};\\nclass Solution \\n{\\n    public:\\n    long d=1000000007;\\n    long powmod(long a,long b)\\n    {\\n        long result=1,base=a;\\n        while(b)\\n        {\\n            if(b&1) result=(result*base)%d;\\n            base=(base*base)%d;\\n            b>>=1;\\n        }\\n        return result;\\n    }\\n    long inv(long n) { return powmod(n,d-2); }\\n    int countAnagrams(string s) \\n    {\\n        if(!flag)\\n        {\\n            f[1]=1;\\n            for(int i=2;i<100001;i++) f[i]=(f[i-1]*i)%d;\\n            flag=true;\\n        }\\n        s+=\" \";\\n        long result=1,n=s.length();\\n        string current;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                long t=current.length(),c=f[t],a[26]={};\\n                for(int j=0;j<current.length();j++) a[current[j]-\\'a\\']++;\\n                for(int j=0;j<26;j++)\\n                    if(a[j]>1) c=(c*inv(f[a[j]]))%d;\\n\\n                result=(result*c)%d;\\n                current=\"\";\\n            }\\n            else current+=s[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool flag=false;\\nlong f[100001]={};\\nclass Solution \\n{\\n    public:\\n    long d=1000000007;\\n    long powmod(long a,long b)\\n    {\\n        long result=1,base=a;\\n        while(b)\\n        {\\n            if(b&1) result=(result*base)%d;\\n            base=(base*base)%d;\\n            b>>=1;\\n        }\\n        return result;\\n    }\\n    long inv(long n) { return powmod(n,d-2); }\\n    int countAnagrams(string s) \\n    {\\n        if(!flag)\\n        {\\n            f[1]=1;\\n            for(int i=2;i<100001;i++) f[i]=(f[i-1]*i)%d;\\n            flag=true;\\n        }\\n        s+=\" \";\\n        long result=1,n=s.length();\\n        string current;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                long t=current.length(),c=f[t],a[26]={};\\n                for(int j=0;j<current.length();j++) a[current[j]-\\'a\\']++;\\n                for(int j=0;j<26;j++)\\n                    if(a[j]>1) c=(c*inv(f[a[j]]))%d;\\n\\n                result=(result*c)%d;\\n                current=\"\";\\n            }\\n            else current+=s[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946678,
                "title": "modulo-multiplicative-inverse-simple-implementation",
                "content": "\\n#intutition:\\n\\nModular multiplicative inverse when M is prime:\\nIf we know M is prime, then we can also use Fermat\\u2019s little theorem to find the inverse, i.e., a^(-1) \\n\\na^(M-1) \\u2245 1 (mod M)\\n\\nIf we multiply both sides with a^-1, we get \\n\\na^(-1) \\u2245 a^(M-2) (mod M)\\n\\n\\nwe can simply find a^(M-2) in O(log n) time\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n   long long int  modInverse(int A, int M)\\n    {\\n        return power(A, M - 2, M);\\n    }\\n\\n    // To compute x^y under modulo m\\n    long long int power(long long int x, unsigned long long  int y, unsigned long long int M)\\n    {\\n        if (y == 0)\\n            return 1;\\n\\n        long long int p = power(x, y / 2, M) % M;\\n        return (y % 2 == 0) ? (p%M * p%M)%M : (x * p%M * p%M) % M;\\n    }\\n    \\n    int countAnagrams(string str) {\\n        istringstream iss(str);\\n        \\n        long long ans=1;\\n        do{\\n            string s;\\n            iss>>s;\\n            \\n            int n= s.size();\\n            long long fact=1;\\n\\n            // eg: \"hhooot hhoot\"\\n            // apply normal permutation for each word and multiply them\\n            // for hhooot, permutation count = 6! / (2! * 3!) = {(6! % mod) * (inv(2) * inv(1))%mod   * ( inv(3)*inv(2)*inv(1))%mod }\\n            // for hhoot, permutation count = 5! / ( 2! * 2!) = {(5! % mod) * (inv(2) * inv(1))%mod   * ( inv(2)*inv(1))%mod }\\n            // multiply both to get the \"ans\" \\n\\n            // where inv(x) = modulo multiplicative inverse of x wrt to mod=1e9+7 \\n            for(int i=1; i<=n; i++)\\n                fact= ( fact%mod * i%mod)%mod;\\n            \\n            vector<int> v(26, 0);\\n            for(int i=0; i<n; i++)\\n                v[s[i] -\\'a\\']++;\\n            \\n            for(int i=0; i<26; i++){\\n                if( v[i]==0)\\n                    continue;\\n                for(int k=1; k<=v[i]; k++){\\n                    long long int mul_inv = modInverse(k , mod);\\n                    fact = ( fact%mod * mul_inv%mod)%mod;   \\n                }  \\n            }\\n            \\n            ans = (( ans%mod) * (fact%mod))%mod;\\n        }while(iss);\\n        \\n        return (ans%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n   long long int  modInverse(int A, int M)\\n    {\\n        return power(A, M - 2, M);\\n    }\\n\\n    // To compute x^y under modulo m\\n    long long int power(long long int x, unsigned long long  int y, unsigned long long int M)\\n    {\\n        if (y == 0)\\n            return 1;\\n\\n        long long int p = power(x, y / 2, M) % M;\\n        return (y % 2 == 0) ? (p%M * p%M)%M : (x * p%M * p%M) % M;\\n    }\\n    \\n    int countAnagrams(string str) {\\n        istringstream iss(str);\\n        \\n        long long ans=1;\\n        do{\\n            string s;\\n            iss>>s;\\n            \\n            int n= s.size();\\n            long long fact=1;\\n\\n            // eg: \"hhooot hhoot\"\\n            // apply normal permutation for each word and multiply them\\n            // for hhooot, permutation count = 6! / (2! * 3!) = {(6! % mod) * (inv(2) * inv(1))%mod   * ( inv(3)*inv(2)*inv(1))%mod }\\n            // for hhoot, permutation count = 5! / ( 2! * 2!) = {(5! % mod) * (inv(2) * inv(1))%mod   * ( inv(2)*inv(1))%mod }\\n            // multiply both to get the \"ans\" \\n\\n            // where inv(x) = modulo multiplicative inverse of x wrt to mod=1e9+7 \\n            for(int i=1; i<=n; i++)\\n                fact= ( fact%mod * i%mod)%mod;\\n            \\n            vector<int> v(26, 0);\\n            for(int i=0; i<n; i++)\\n                v[s[i] -\\'a\\']++;\\n            \\n            for(int i=0; i<26; i++){\\n                if( v[i]==0)\\n                    continue;\\n                for(int k=1; k<=v[i]; k++){\\n                    long long int mul_inv = modInverse(k , mod);\\n                    fact = ( fact%mod * mul_inv%mod)%mod;   \\n                }  \\n            }\\n            \\n            ans = (( ans%mod) * (fact%mod))%mod;\\n        }while(iss);\\n        \\n        return (ans%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946646,
                "title": "15-liner-c-permutations",
                "content": "# Intuition\\nThink of this as find unique permutations of every word and then multiplying all together\\n\\n# Approach\\naab will have 3!/(1! * 2! * 1!) ways ... aab, aba, baa\\nabc will haev 3!/(1! * 1! * 1!) ways ...\\nIgnore the template to calculate factorial and nCk but logic is very simple\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n\\ntemplate <long long mod>\\nstruct modular {\\n    long long value;\\n    modular(long long x = 0) {\\n        value = x % mod;\\n        if (value < 0) value += mod;\\n    }\\n    modular& operator+=(const modular& other) {\\n        if ((value += other.value) >= mod) value -= mod;\\n        return *this;\\n    }\\n    modular& operator-=(const modular& other) {\\n        if ((value -= other.value) < 0) value += mod;\\n        return *this;\\n    }\\n    modular& operator*=(const modular& other) {\\n        value = value * other.value % mod;\\n        return *this;\\n    }\\n    modular& operator/=(const modular& other) {\\n        long long a = 0, b = 1, c = other.value, m = mod;\\n        while (c != 0) {\\n            long long t = m / c;\\n            m -= t * c;\\n            swap(c, m);\\n            a -= t * b;\\n            swap(a, b);\\n        }\\n        a %= mod;\\n        if (a < 0) a += mod;\\n        value = value * a % mod;\\n        return *this;\\n    }\\n    friend modular operator+(const modular& lhs, const modular& rhs) { return modular(lhs) += rhs; }\\n    friend modular operator-(const modular& lhs, const modular& rhs) { return modular(lhs) -= rhs; }\\n    friend modular operator*(const modular& lhs, const modular& rhs) { return modular(lhs) *= rhs; }\\n    friend modular operator/(const modular& lhs, const modular& rhs) { return modular(lhs) /= rhs; }\\n    modular& operator++() { return *this += 1; }\\n    modular& operator--() { return *this -= 1; }\\n    modular operator++(int) {\\n        modular res(*this);\\n        *this += 1;\\n        return res;\\n    }\\n    modular operator--(int) {\\n        modular res(*this);\\n        *this -= 1;\\n        return res;\\n    }\\n    modular operator-() const { return modular(-value); }\\n    bool operator==(const modular& rhs) const { return value == rhs.value; }\\n    bool operator!=(const modular& rhs) const { return value != rhs.value; }\\n    bool operator<(const modular& rhs) const { return value < rhs.value; }\\n};\\ntemplate <long long mod>\\nstring to_string(const modular<mod>& x) {\\n    return to_string(x.value);\\n}\\ntemplate <long long mod>\\nostream& operator<<(ostream& stream, const modular<mod>& x) {\\n    return stream << x.value;\\n}\\ntemplate <long long mod>\\nistream& operator>>(istream& stream, modular<mod>& x) {\\n    stream >> x.value;\\n    x.value %= mod;\\n    if (x.value < 0) x.value += mod;\\n    return stream;\\n}\\n \\nconstexpr long long mod = 1e9 + 7;\\nusing mint = modular<mod>;\\n \\nmint power(mint a, long long n) {\\n    mint res = 1;\\n    while (n > 0) {\\n        if (n & 1) {\\n            res *= a;\\n        }\\n        a *= a;\\n        n >>= 1;\\n    }\\n    return res;\\n}\\n \\nvector<mint> fact(1, 1);\\nvector<mint> finv(1, 1);\\n \\nmint C(int n, int k) {\\n    if (n < k || k < 0) {\\n        return mint(0);\\n    }\\n    while ((int) fact.size() < n + 1) {\\n        fact.emplace_back(fact.back() * (int) fact.size());\\n        finv.emplace_back(mint(1) / fact.back());\\n    }\\n    return fact[n] * finv[k] * finv[n - k];\\n}\\n\\nlong long int mod_pow(long long int a, long long int b)  {\\n    long long int res = 1; \\n    while (b > 0) {\\n        if (b & 1)\\n            res = (res * a) % mod; \\n        a = (a * a) % mod; \\n        b = b >> 1;\\n    } \\n    return res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int countAnagrams(string s) {\\n        C(100005, 0);\\n        mint ans = 1;\\n        stringstream ss(s);\\n        string t = \"\";\\n        while(ss >> t) {\\n            long long freq[26] = {0};\\n            for(auto &i : t) {\\n                freq[i - \\'a\\'] += 1;\\n            }\\n            long long m = t.size();\\n            mint res = fact[m];\\n            for(int i = 0; i < 26; i++) {\\n                res /= fact[freq[i]];\\n            }\\n            ans = ans * res;\\n        }\\n        string str = to_string(ans);\\n        long long res = stoll(str);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntemplate <long long mod>\\nstruct modular {\\n    long long value;\\n    modular(long long x = 0) {\\n        value = x % mod;\\n        if (value < 0) value += mod;\\n    }\\n    modular& operator+=(const modular& other) {\\n        if ((value += other.value) >= mod) value -= mod;\\n        return *this;\\n    }\\n    modular& operator-=(const modular& other) {\\n        if ((value -= other.value) < 0) value += mod;\\n        return *this;\\n    }\\n    modular& operator*=(const modular& other) {\\n        value = value * other.value % mod;\\n        return *this;\\n    }\\n    modular& operator/=(const modular& other) {\\n        long long a = 0, b = 1, c = other.value, m = mod;\\n        while (c != 0) {\\n            long long t = m / c;\\n            m -= t * c;\\n            swap(c, m);\\n            a -= t * b;\\n            swap(a, b);\\n        }\\n        a %= mod;\\n        if (a < 0) a += mod;\\n        value = value * a % mod;\\n        return *this;\\n    }\\n    friend modular operator+(const modular& lhs, const modular& rhs) { return modular(lhs) += rhs; }\\n    friend modular operator-(const modular& lhs, const modular& rhs) { return modular(lhs) -= rhs; }\\n    friend modular operator*(const modular& lhs, const modular& rhs) { return modular(lhs) *= rhs; }\\n    friend modular operator/(const modular& lhs, const modular& rhs) { return modular(lhs) /= rhs; }\\n    modular& operator++() { return *this += 1; }\\n    modular& operator--() { return *this -= 1; }\\n    modular operator++(int) {\\n        modular res(*this);\\n        *this += 1;\\n        return res;\\n    }\\n    modular operator--(int) {\\n        modular res(*this);\\n        *this -= 1;\\n        return res;\\n    }\\n    modular operator-() const { return modular(-value); }\\n    bool operator==(const modular& rhs) const { return value == rhs.value; }\\n    bool operator!=(const modular& rhs) const { return value != rhs.value; }\\n    bool operator<(const modular& rhs) const { return value < rhs.value; }\\n};\\ntemplate <long long mod>\\nstring to_string(const modular<mod>& x) {\\n    return to_string(x.value);\\n}\\ntemplate <long long mod>\\nostream& operator<<(ostream& stream, const modular<mod>& x) {\\n    return stream << x.value;\\n}\\ntemplate <long long mod>\\nistream& operator>>(istream& stream, modular<mod>& x) {\\n    stream >> x.value;\\n    x.value %= mod;\\n    if (x.value < 0) x.value += mod;\\n    return stream;\\n}\\n \\nconstexpr long long mod = 1e9 + 7;\\nusing mint = modular<mod>;\\n \\nmint power(mint a, long long n) {\\n    mint res = 1;\\n    while (n > 0) {\\n        if (n & 1) {\\n            res *= a;\\n        }\\n        a *= a;\\n        n >>= 1;\\n    }\\n    return res;\\n}\\n \\nvector<mint> fact(1, 1);\\nvector<mint> finv(1, 1);\\n \\nmint C(int n, int k) {\\n    if (n < k || k < 0) {\\n        return mint(0);\\n    }\\n    while ((int) fact.size() < n + 1) {\\n        fact.emplace_back(fact.back() * (int) fact.size());\\n        finv.emplace_back(mint(1) / fact.back());\\n    }\\n    return fact[n] * finv[k] * finv[n - k];\\n}\\n\\nlong long int mod_pow(long long int a, long long int b)  {\\n    long long int res = 1; \\n    while (b > 0) {\\n        if (b & 1)\\n            res = (res * a) % mod; \\n        a = (a * a) % mod; \\n        b = b >> 1;\\n    } \\n    return res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int countAnagrams(string s) {\\n        C(100005, 0);\\n        mint ans = 1;\\n        stringstream ss(s);\\n        string t = \"\";\\n        while(ss >> t) {\\n            long long freq[26] = {0};\\n            for(auto &i : t) {\\n                freq[i - \\'a\\'] += 1;\\n            }\\n            long long m = t.size();\\n            mint res = fact[m];\\n            for(int i = 0; i < 26; i++) {\\n                res /= fact[freq[i]];\\n            }\\n            ans = ans * res;\\n        }\\n        string str = to_string(ans);\\n        long long res = stoll(str);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946620,
                "title": "math-python",
                "content": "```\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        MOD = 10**9 + 7\\n        sentence = s.split(\" \")\\n        l = []\\n        for i in range(len(sentence)):\\n            hashmap = {}\\n            for letter in sentence[i]:\\n                if letter in hashmap.keys():\\n                    hashmap[letter] += 1\\n                else:\\n                    hashmap[letter] = 1\\n            \\n            prod = 1\\n            total_comb = math.factorial(len(sentence[i]))\\n            for value,freq in list(hashmap.items()):\\n                if freq >1:\\n                    prod *= math.factorial(freq)\\n            \\n            l.append(total_comb//prod)\\n        \\n        ans = 1\\n        for x in l:\\n            ans *= x\\n        return ans%MOD\\n        \\n        \\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        MOD = 10**9 + 7\\n        sentence = s.split(\" \")\\n        l = []\\n        for i in range(len(sentence)):\\n            hashmap = {}\\n            for letter in sentence[i]:\\n                if letter in hashmap.keys():\\n                    hashmap[letter] += 1\\n                else:\\n                    hashmap[letter] = 1\\n            \\n            prod = 1\\n            total_comb = math.factorial(len(sentence[i]))\\n            for value,freq in list(hashmap.items()):\\n                if freq >1:\\n                    prod *= math.factorial(freq)\\n            \\n            l.append(total_comb//prod)\\n        \\n        ans = 1\\n        for x in l:\\n            ans *= x\\n        return ans%MOD\\n        \\n        \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946617,
                "title": "c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<long long>fact;\\n    void factorial()\\n    {\\n        long long ans = 1;\\n        fact[1] = 1;\\n        fact[0] = 1;\\n        for (int i = 2; i <= 1e5; i++)fact[i] = (fact[i - 1] % mod * i % mod) % mod;\\n    }\\n    long long fastexpo(long long a,int b,int mod){\\n        long long ans = 1;\\n        while(b > 0){\\n            if(b & 1)ans = (ans % mod * a % mod) % mod;\\n            a = (a % mod * a % mod) % mod;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    int countAnagrams(string s) {\\n        int n = s.size();\\n        stringstream str(s);\\n        string word;\\n        fact.resize(1e5 + 3,0);\\n        factorial();\\n        long long ans = 1;\\n        while(str >> word){\\n            vector<int>arr(26,0);\\n            int n = word.size();\\n            for(auto it : word){\\n                arr[it - \\'a\\']++;\\n            }\\n            long long count = 1;\\n            for(int i = 0;i < 26;i++){\\n                // cout<<fact[arr[i]]<<\" \";\\n                count = (count % mod * fact[arr[i]] % mod) % mod;\\n            }\\n            count = (fastexpo(count,mod - 2,mod) % mod * fact[n] % mod) % mod;\\n            ans = (ans % mod * count % mod) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<long long>fact;\\n    void factorial()\\n    {\\n        long long ans = 1;\\n        fact[1] = 1;\\n        fact[0] = 1;\\n        for (int i = 2; i <= 1e5; i++)fact[i] = (fact[i - 1] % mod * i % mod) % mod;\\n    }\\n    long long fastexpo(long long a,int b,int mod){\\n        long long ans = 1;\\n        while(b > 0){\\n            if(b & 1)ans = (ans % mod * a % mod) % mod;\\n            a = (a % mod * a % mod) % mod;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    int countAnagrams(string s) {\\n        int n = s.size();\\n        stringstream str(s);\\n        string word;\\n        fact.resize(1e5 + 3,0);\\n        factorial();\\n        long long ans = 1;\\n        while(str >> word){\\n            vector<int>arr(26,0);\\n            int n = word.size();\\n            for(auto it : word){\\n                arr[it - \\'a\\']++;\\n            }\\n            long long count = 1;\\n            for(int i = 0;i < 26;i++){\\n                // cout<<fact[arr[i]]<<\" \";\\n                count = (count % mod * fact[arr[i]] % mod) % mod;\\n            }\\n            count = (fastexpo(count,mod - 2,mod) % mod * fact[n] % mod) % mod;\\n            ans = (ans % mod * count % mod) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2946605,
                "title": "prime-factorization-character-frequency-binary-exponentiation",
                "content": "# Code\\n```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    void prime_fact(int a, int b, map<int, int> &pf){\\n        while(a % 2 == 0){\\n            pf[2] += b;\\n            a /= 2;\\n        }\\n        for(long long i = 3; i <= (int)sqrt(a); i += 2){\\n            while(a % i == 0){\\n                pf[i] += b;\\n                a /= i;\\n            }\\n        }\\n        if(a > 2){\\n            pf[a] += b;\\n        }\\n    }\\n    int binpow(int a, int b) {\\n        a %= MOD;\\n        int res = 1;\\n        while (b > 0) {\\n            if (b & 1)\\n                res = (long long)res * a % MOD;\\n            a = (long long)a * a % MOD;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    int countAnagrams(string s) {\\n        int ans = 1;\\n        map<int, int> uc, dc;\\n        map<char, int> mp;\\n        s += \\' \\';\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == \\' \\'){\\n                int a = 0;\\n                for(auto it : mp){\\n                    a += (it.second);\\n                    for(int k = 2; k <= it.second; ++k){\\n                        dc[k]++;\\n                    }\\n                }\\n                for(int j = 2; j <= a; ++j){\\n                    uc[j]++;\\n                }\\n                mp.clear();\\n            }\\n            else{\\n                mp[s[i]]++;\\n            }\\n        }\\n        map<int, int> pf;\\n        for(auto it : uc){\\n            prime_fact(it.first, it.second, pf);\\n        }\\n        for(auto it : dc){\\n            prime_fact(it.first, -it.second, pf);\\n        }\\n        for(auto it : pf){\\n            ans = ((long long)ans * (binpow(it.first, it.second))) % MOD;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    void prime_fact(int a, int b, map<int, int> &pf){\\n        while(a % 2 == 0){\\n            pf[2] += b;\\n            a /= 2;\\n        }\\n        for(long long i = 3; i <= (int)sqrt(a); i += 2){\\n            while(a % i == 0){\\n                pf[i] += b;\\n                a /= i;\\n            }\\n        }\\n        if(a > 2){\\n            pf[a] += b;\\n        }\\n    }\\n    int binpow(int a, int b) {\\n        a %= MOD;\\n        int res = 1;\\n        while (b > 0) {\\n            if (b & 1)\\n                res = (long long)res * a % MOD;\\n            a = (long long)a * a % MOD;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    int countAnagrams(string s) {\\n        int ans = 1;\\n        map<int, int> uc, dc;\\n        map<char, int> mp;\\n        s += \\' \\';\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == \\' \\'){\\n                int a = 0;\\n                for(auto it : mp){\\n                    a += (it.second);\\n                    for(int k = 2; k <= it.second; ++k){\\n                        dc[k]++;\\n                    }\\n                }\\n                for(int j = 2; j <= a; ++j){\\n                    uc[j]++;\\n                }\\n                mp.clear();\\n            }\\n            else{\\n                mp[s[i]]++;\\n            }\\n        }\\n        map<int, int> pf;\\n        for(auto it : uc){\\n            prime_fact(it.first, it.second, pf);\\n        }\\n        for(auto it : dc){\\n            prime_fact(it.first, -it.second, pf);\\n        }\\n        for(auto it : pf){\\n            ans = ((long long)ans * (binpow(it.first, it.second))) % MOD;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946600,
                "title": "faster-and-less-memory-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each word, the number of anagrams is given by $n!/(n_1!n_2!\\\\ldots n_k!)$, where $n$ is the length of the word and $n_1, \\\\ldots, n_k$ are the counts of each type of letter. Then, the answer is the product of the number of anagrams of each word.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt helps to optimize the factorial computation by caching it. Division modulo p can be done by multiplying with the inverse, which can be computed in constant time (the constant is $\\\\log_2 p$). Division takes more time than multiplication, so it is better to perform as few divisions as possible.\\nEdit: by organizing the computation properly, it is possible to perform exactly one division.\\n\\n# Complexity\\n- Time complexity: $O(n)$, where $n$ is the length of the string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        p=10**9+7\\n        \\n        @cache\\n        def fact(n):\\n            ans=1\\n            for i in range(1, n+1):\\n                ans=ans*i%p\\n            return ans\\n        \\n        def binary(b):\\n            ans=[]\\n            while b:\\n                ans.append(b&1)\\n                b>>=1\\n            return ans\\n        \\n        lst=binary(p-2)\\n        llst=len(lst)\\n        \\n        @cache\\n        def inv(a):\\n            ans=1\\n            pw=a\\n            tmp=lst\\n            for i in range(llst):\\n                if lst[i]:\\n                    ans=ans*pw%p\\n                pw=pw*pw%p\\n            return ans\\n        \\n        def an(w):\\n            dct=defaultdict(int)\\n            for c in w:\\n                dct[c]+=1\\n            tmp=1\\n            for vl in dct.values():\\n                tmp=tmp*fact(vl)%p\\n            return tmp\\n        \\n        ans1=1; ans2=1\\n        for w in s.split():\\n            ans1=ans1*fact(len(w))%p; ans2=ans2*an(w)%p\\n        \\n        return ans1*inv(ans2)%p       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        p=10**9+7\\n        \\n        @cache\\n        def fact(n):\\n            ans=1\\n            for i in range(1, n+1):\\n                ans=ans*i%p\\n            return ans\\n        \\n        def binary(b):\\n            ans=[]\\n            while b:\\n                ans.append(b&1)\\n                b>>=1\\n            return ans\\n        \\n        lst=binary(p-2)\\n        llst=len(lst)\\n        \\n        @cache\\n        def inv(a):\\n            ans=1\\n            pw=a\\n            tmp=lst\\n            for i in range(llst):\\n                if lst[i]:\\n                    ans=ans*pw%p\\n                pw=pw*pw%p\\n            return ans\\n        \\n        def an(w):\\n            dct=defaultdict(int)\\n            for c in w:\\n                dct[c]+=1\\n            tmp=1\\n            for vl in dct.values():\\n                tmp=tmp*fact(vl)%p\\n            return tmp\\n        \\n        ans1=1; ans2=1\\n        for w in s.split():\\n            ans1=ans1*fact(len(w))%p; ans2=ans2*an(w)%p\\n        \\n        return ans1*inv(ans2)%p       \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1849307,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1727519,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1957746,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1727142,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1727572,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 2068152,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1930983,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1926790,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1830934,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1748068,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1849307,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1727519,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1957746,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1727142,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1727572,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 2068152,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1930983,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1926790,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1830934,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            },
            {
                "id": 1748068,
                "content": [
                    {
                        "username": "LesterEvSe",
                        "content": "This is a really hard problem for C++ programmers"
                    },
                    {
                        "username": "Finesse",
                        "content": "There are many \"medium\" problems harder than this. I spent more time figuring out how to handle big ints in Go than solving the actual problem. It is more about math (combinatorics) than programming."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is medium,or maybe easy,for python users.But hard for Java and C++ due to overflow issue.You can pass all test cases in python but optimised solution is still hard"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s not hard as long as you are familiar with modulo operations. No need to even deal with big ints."
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Yeah this question is pretty easy even compared to this contest medium and easy problems."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Yeah you are right xD, non-Python folks spend more time figuring out how to pre-compute modulo inverses than actually solving this problem"
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Now imagine if you are coding this in Python LOL, this question would be easy-medium at best "
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "What\\'s wrong with the test case  `\"b okzojaporykbmq tybq zrztwlolvcyumcsq jjuowpp\"`?\\nwhy is 210324488 Expected not `5.7456411691533104e+26`?"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@Ahmad](/ahmad-saeed) Hey! how did you solve that problem can you share ? cause I am also getting the same issue and unable to solve that from hours."
                    },
                    {
                        "username": "aryonbe",
                        "content": "This is to find modulo inverse. But I did not use modulo inverse at all. My solution passed. I think testcases are not so strict. Leetcode need to add more testcases. Anyway merry Christmas to all Leetcoders!"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please anyone can explain me what is mean by valid anagram. I didn\\'t understand the question. How there will be valid or not valid anagram. Your effort will be appreciated"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Yes. \n\nAccording to question two strings s1 and s2 are valid anagrams if and only if first word in s1 is an anagram of first word of s2, second word of s1 is an anagram of second word of s2 , third word of s1 is an anagram of third word of s2 and so on. \n\nNOTE : Words in strings are separated by '  '.\n\nExample 1 : \n s1 = \"abc dfe\"\n s2 = \"abc def\" \n1st word in s1 = abc\n1st word in s2 = abc\n2nd word in s1 = dfe\n2nd word in s2 = def\nsince 1st word in s1 is an anagram of first word of s2 and also second word of s1 is an anagram of second word of s2. Hence s2 & s1 are valid anagrams\n\nExample 2: \n s1 = \"abc dfe\"\n s2 = \"def cab\" \n1st word in s1 = abc\n1st word in s2 = def\n2nd word in s1 = dfe\n2nd word in s2 = cab\nsince 1st word in s1 is not an anagram of first word of s2 and also second word of s1 is not an anagram of second word of s2. Hence s1 and s2 are not valid anagrams.\n\nHope it helps.\nMerry Christmas & Happy New Year !!\n Thanks : )"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@strive_hard](/strive_hard) Can u please explain this sentence\\n For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\\nit will be very helpful"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@the_coder_8297](/the_coder_8297) suppose we have two strings s1 and s2 then s1 and s2 will  be valid anagrams if and only if the below two conditions are satisfied:\\n1. Both s1 & s2 are made up of same characters\\n2. Frequency of every character is same in both s1 & s2\\nExamle1 : s1 = neo, s2 = one\\ns1--- n = 1, o = 1, e = 1\\ns2 ---- n = 1, o = 1, e = 1\\ns1 and s2 are valid anagrams because both contains n, e, o and frequency of n, e, o in both s1 & s2 is same.\\nExample 2 :\\ns1 = Must, s2 = Dust\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- D  = 1, u = 1, s = 1, t = 1\\nHere s1 and s2 are not valid anagrams since M is present in s1 but not in s2\\nExample 3 : \\ns1 = Must, s2 = Mustt\\ns1 -- M = 1, u = 1, s = 1, t = 1\\ns2 -- M  = 1, u = 1, s = 1, t = 2\\nHere s1 and s2 are not valid anagrams since frequency of t is not same in both s1 and s2.\\nHope this clarifies your doubt. For any other queries feel free to comment. Thanks : )\\nIf it helps, please upvote.\\n"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I can sense a formula here\n\nFor \"too hot\",\n\"TOO\" -> T=1,O=2 So it can be arranged as 3!/2! ways. This means 3 ways.\n\"HOT\" ->H=1,O=1,T=1, so it can be arranged in 3! ways. This means 6 ways.\n\nThey both have to be arranged together. So total ways = 3*6=18 ways.\n\nI had tried this on custom testcases. Kindly code my approach to find whether my approach is correct ot not.\n\nAlso, tell me approach to code my solution. Better in Java. Python and C are also acceptable.\n  "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "Hi. Well, you\\'re right with the formula here - it\\'s permutations with repetitions.\\nYou can check my solution in Python if you want, I made pretty clear explanation:\\nhttps://leetcode.com/problems/count-anagrams/solutions/3818842/my-python-solution-with-detailed-explanation-even-beginners-will-get-it/"
                    },
                    {
                        "username": "Priyanka0505",
                        "content": "There was no output in expected and that wasted my time .... ! Don\\'t worry .. just submit and see! Your solution might be correct."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why do we need mod in solution I did not understand it"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "You are welcome)"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) thanks finally I understand it)"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) To solve it you need to use one combinatorial formula - permutation with repetitions"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) Anyway this was hard problem for me I could not understand the intuition here"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "[@user5369RY](/user5369RY) Hmm, then the explanation could be this. Why make separate test cases for certain languages, if you can put a constraint in the form of mod and not change the testcases"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@LesterEvSe](/LesterEvSe) sorry maybe I was not precise in my question but my question for python. Or because python based on c then it is applicable on python too? and my question about using M = 1000000007 some solutions used mode  1000000007"
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "Some languages do not have a built-in work with big numbers, for example C++, where the maximum number is 2^64-1 (unsigned long long), that\\'s why you need mod to be able to solve this problem"
                    },
                    {
                        "username": "yunli",
                        "content": "Can anyone tell me why is this solution wrong?\\n ```\\nfrom collections import Counter\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n        mod = 1_000_000_000_7\\n        N = max(len(w) for w in s.split())\\n        fact = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fact[i] = fact[i-1] * i \\n        result = 1\\n        for w in s.split():\\n            result = result * fact[len(w)] \\n            for cnt in Counter(w).values():\\n                result = result // fact[cnt]\\n            result %= mod\\n        return result % mod\\n```"
                    },
                    {
                        "username": "mikhail-abramov",
                        "content": "C# programmers should use BigInteger. I tried with int, uint, ulong, double and so on. 3 lifetime hours wasted"
                    }
                ]
            }
        ]
    }
]