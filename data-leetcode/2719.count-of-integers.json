[
    {
        "title": "Minimize String Length",
        "question_content": "Given a 0-indexed string s, repeatedly perform the following operation any number of times:\n\n\tChoose an index i in the string, and let c be the character in position i. Delete the closest occurrence of c to the left of i (if any) and the closest occurrence of c to the right of i (if any).\n\nYour task is to minimize the length of s by performing the above operation any number of times.\nReturn an integer denoting the length of the minimized string.\n&nbsp;\nExample 1:\n\nInput: s = \"aaabc\"\nOutput: 3\nExplanation: In this example, s is \"aaabc\". We can start by selecting the character 'a' at index 1. We then remove the closest 'a' to the left of index 1, which is at index 0, and the closest 'a' to the right of index 1, which is at index 2. After this operation, the string becomes \"abc\". Any further operation we perform on the string will leave it unchanged. Therefore, the length of the minimized string is 3.\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: 3\nExplanation: For this we can start with character 'b' at index 1. There is no occurrence of 'b' to the left of index 1, but there is one to the right at index 2, so we delete the 'b' at index 2. The string becomes \"cbd\" and further operations will leave it unchanged. Hence, the minimized length is 3.&nbsp;\n\nExample 3:\n\nInput: s = \"dddaaa\"\nOutput: 2\nExplanation: For this, we can start with the character 'd' at index 1. The closest occurrence of a 'd' to its left is at index 0, and the closest occurrence of a 'd' to its right is at index 2. We delete both index 0 and 2, so the string becomes \"daaa\". In the new string, we can select the character 'a' at index 2. The closest occurrence of an 'a' to its left is at index 1, and the closest occurrence of an 'a' to its right is at index 3. We delete both of them, and the string becomes \"da\". We cannot minimize this further, so the minimized length is 2.\n\n&nbsp;\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 100\n\ts contains only lowercase English letters",
        "solutions": [
            {
                "id": 3616312,
                "title": "one-line-code-for-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set((s)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set((s)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595131,
                "title": "find-unique-character-very-simple-and-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution </b>\\nIt can be observed that the we can remove all the duplicate of a character except the last one. So basically we just need to find number of unique character we have in the string as the answer.\\n\\n# Code\\n```\\nint minimizedStringLength(string s) {\\n    unordered_set<char> st;\\n    for(auto c: s) st.insert(c);\\n    return st.size();\\n}\\n```\\n\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minimizedStringLength(string s) {\\n    unordered_set<char> st;\\n    for(auto c: s) st.insert(c);\\n    return st.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595387,
                "title": "one-line-solution-c-java-python",
                "content": "# Intuition\\nJust count the number of distinct characters.\\n\\n# Approach\\nJust count the number of distinct characters.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        return unordered_set<char>(s.begin(), s.end()).size();\\n    }\\n};\\n```\\n\\nJava\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n}\\n```\\n\\nPython\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        return unordered_set<char>(s.begin(), s.end()).size();\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594946,
                "title": "hashset",
                "content": "We can remove all occurances of `c` except the last one.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len({*s})\\n```\\n\\n**C++**\\n```cpp\\nint minimizedStringLength(string s) {\\n    return unordered_set(begin(s), end(s)).size();\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len({*s})\\n```\n```cpp\\nint minimizedStringLength(string s) {\\n    return unordered_set(begin(s), end(s)).size();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594961,
                "title": "java-easy-solution-6-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimizedStringLength(String s) {\\n    var map = new boolean[26];\\n    var ans = 0;\\n    \\n    for (var c : s.toCharArray())\\n      map[c - \\'a\\'] = true;\\n\\n    for (var c : map) if (c) ans++;\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minimizedStringLength(String s) {\\n    var map = new boolean[26];\\n    var ans = 0;\\n    \\n    for (var c : s.toCharArray())\\n      map[c - \\'a\\'] = true;\\n\\n    for (var c : map) if (c) ans++;\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594910,
                "title": "use-new-set-2-lines",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = function(s) {\\n    const u = new Set(s)\\n    return u.size\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = function(s) {\\n    const u = new Set(s)\\n    return u.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596066,
                "title": "python-3-1-line-w-explanation-t-m-98-46",
                "content": "The problem can be reduced to this:\\n\\nIf a character occurs more than once in`s`, then we may remove at least one of those characters with each move. If exactly one of a character is present, then it may not be removed. Hence, the answer is the count of distinct\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(s))\\n```\\n[https://leetcode.com/problems/minimize-string-length/submissions/963522297/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1) in which *N* ~ count of distinct characters.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595507,
                "title": "java-c-python-hashset",
                "content": "# **Explanation**\\nFor all same character, at least one will be left.\\nSo we only need to know,\\nahow many different characters in the input `s`\\nWe can use a hash set to find this.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(26)`\\n<br>\\n\\n**Java**\\nUse `distinct`\\n```java\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimizedStringLength(string s) {\\n        return unordered_set(s.begin(), s.end()).size();\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n```\n```cpp\\n    int minimizedStringLength(string s) {\\n        return unordered_set(s.begin(), s.end()).size();\\n    }\\n```\n```py\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3625803,
                "title": "easy-solution-in-java-0ms-100-beats",
                "content": "# Approach\\nThe approach to solving the problem is as follows:\\n\\n1. A method named `minimizedStringLength` is defined, which takes a string parameter `s`.\\n2. Inside the method, an integer array `arr` of size 26 is created to store the count of each letter in the alphabet.\\n3. The method iterates through each character `c` in the string `s` using a for-each loop.\\n4. For each character, the count at the corresponding index in the `arr` array is incremented by 1. This step counts the occurrences of each letter in the string.\\n5. After counting the occurrences of each letter, a variable `count` is initialized to 0.\\n6. The method iterates through each element `n` in the `arr` array.\\n7. For each element, if it is not zero (indicating that the letter is present in the string), the `count` variable is incremented by 1.\\n8. Finally, the value of `count` is returned, which represents the number of distinct letters present in the string `s`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595845,
                "title": "count-disticnt-no-of-chars-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> v(26,0);\\n        int ans = 0;\\n        for(auto &i: s){\\n            if(!v[i-\\'a\\']){\\n                ans++;\\n                v[i-\\'a\\'] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> v(26,0);\\n        int ans = 0;\\n        for(auto &i: s){\\n            if(!v[i-\\'a\\']){\\n                ans++;\\n                v[i-\\'a\\'] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595137,
                "title": "c-very-easy-solution-using-map-stl",
                "content": "# Intuition\\nAt first glance, we can clearly see that we have to count all unique characters in given string.\\n\\n# Approach\\nThe code uses a map data structure, count, to keep track of the frequency of each character in the string. It iterates over the characters in the string using a for loop and updates the count for each character. After counting all the characters, the size of the map is returned, which represents the number of distinct characters in the string.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input string. As the code iterates over each character in the string once\\n\\n- Space complexity:\\nO(n), as the map will store n key-value pairs, where n is the length of the input string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        \\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        \\n        return count.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        \\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        \\n        return count.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959846,
                "title": "very-easy-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a hashset of type characters \\n- Iterate all the characters of the string and add those characters in the hashset\\n- Hashset do not allow duplicate elememts \\n- return the size of the hashset\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set=new HashSet();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set=new HashSet();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924430,
                "title": "4-lines-solution-java-hashset",
                "content": "# Intuition\\nThe problem is all about removing all duplicates.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo, use hashSet and return the size of the set.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(char c : s.toCharArray()){\\n            set.add(c);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(char c : s.toCharArray()){\\n            set.add(c);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786530,
                "title": "java-faster-then-100-1-liner",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Codes :\\n### **1st method : 100% faster**\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean map[] = new boolean[26];\\n        int ans = 0;\\n        for(char c : s.toCharArray()) \\n            map[c - \\'a\\'] = true;\\n        for(boolean b : map)\\n            if(b == true) ans ++;\\n        return ans;\\n    }\\n}\\n```\\n### **2nd method : 1 liner**\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int)s.chars().distinct().count();\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean map[] = new boolean[26];\\n        int ans = 0;\\n        for(char c : s.toCharArray()) \\n            map[c - \\'a\\'] = true;\\n        for(boolean b : map)\\n            if(b == true) ans ++;\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int)s.chars().distinct().count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606038,
                "title": "c-java-count-number-of-unique-characters",
                "content": "Given the problem that asks us to select an index `i` within a string and then delete the nearest instances of that character to the left and right of `i`, we can infer that we should remove all duplicate occurrences of each character, leaving only one occurrence of each. Therefore, the problem can be simplified to determining the count of unique characters within the string.\\n\\nWe can solve this problem using a hashset, but this method might be too time-consuming. As an optimization, we can use a boolean array instead. The first time we encounter a character, we increment a count. This count, maintained throughout the iteration of the string, serves as the final solution.\\n\\nC++:\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598133,
                "title": "python-elegant-short-1-line-hash-set-size",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597498,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++) {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++) {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597086,
                "title": "c-solution-stack-beginner-friendly-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        stack<char> stk;\\n        map<char, int> mp;\\n        for (int i=0;i<s.length(); i++) {\\n            if ((!stk.empty() && s[i] == stk.top()) or (!stk.empty() && mp.find(s[i]) != mp.end())) {\\n                // \\n            } else {\\n                stk.push(s[i]);\\n                mp.insert({s[i], i});\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        stack<char> stk;\\n        map<char, int> mp;\\n        for (int i=0;i<s.length(); i++) {\\n            if ((!stk.empty() && s[i] == stk.top()) or (!stk.empty() && mp.find(s[i]) != mp.end())) {\\n                // \\n            } else {\\n                stk.push(s[i]);\\n                mp.insert({s[i], i});\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595303,
                "title": "o-n-easy-to-understand-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Check if the result contains the character or not. If the result contains\\n    the character then do not add it, else add that charcter to the resultant\\n    string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        String result = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            if(!result.contains(String.valueOf(s.charAt(i)))) {\\n                result += String.valueOf(s.charAt(i));\\n            }\\n        }\\n        return result.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        String result = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            if(!result.contains(String.valueOf(s.charAt(i)))) {\\n                result += String.valueOf(s.charAt(i));\\n            }\\n        }\\n        return result.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595248,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int len = s.length();\\n        int charIndex = 0;\\n        while(charIndex < 26) {\\n            int i=0;\\n            while(i < s.length() && s.charAt(i) != (char) (\\'a\\' + charIndex))\\n                i++;\\n            int end = i+1;\\n            int count = 0;\\n            while(end < s.length()) {\\n                if(s.charAt(end) == (char)(\\'a\\' + charIndex))\\n                    count++;\\n                if(count == 2) {\\n                    len -= 2;\\n                    count = 0;\\n                }\\n                end++;\\n            }\\n            if(count > 0)\\n                len -= 1;\\n            charIndex++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int len = s.length();\\n        int charIndex = 0;\\n        while(charIndex < 26) {\\n            int i=0;\\n            while(i < s.length() && s.charAt(i) != (char) (\\'a\\' + charIndex))\\n                i++;\\n            int end = i+1;\\n            int count = 0;\\n            while(end < s.length()) {\\n                if(s.charAt(end) == (char)(\\'a\\' + charIndex))\\n                    count++;\\n                if(count == 2) {\\n                    len -= 2;\\n                    count = 0;\\n                }\\n                end++;\\n            }\\n            if(count > 0)\\n                len -= 1;\\n            charIndex++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595149,
                "title": "just-2-lines-c-easiest-problem",
                "content": "CODE\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<int>set(s.begin(),s.end());\\n        return set.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<int>set(s.begin(),s.end());\\n        return set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925129,
                "title": "easy-understanding-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] chars = s.toCharArray();\\n        int[] counts = new int[26];\\n        int result =0;\\n        for(char c: chars){\\n            counts[c-\\'a\\']++;\\n        }\\n        for(int i:counts){\\n            if(i>0){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] chars = s.toCharArray();\\n        int[] counts = new int[26];\\n        int result =0;\\n        for(char c: chars){\\n            counts[c-\\'a\\']++;\\n        }\\n        for(int i:counts){\\n            if(i>0){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908437,
                "title": "super-easy-python3-solution-beats-75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = []\\n        for i in s:\\n            res.append(i)\\n        news=set(res)\\n        return len(news)\\n```\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(res))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = []\\n        for i in s:\\n            res.append(i)\\n        news=set(res)\\n        return len(news)\\n```\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838984,
                "title": "can-you-optimize-it-c-solution-beats-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string ans =\"\";\\n        sort(s.begin(),s.end());\\n        for(int i = 1 ; i<s.length();i++ ){\\n            if(s[i]!=s[i-1]){\\n                ans+=s[i];\\n            }\\n        }\\n        return ans.length()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string ans =\"\";\\n        sort(s.begin(),s.end());\\n        for(int i = 1 ; i<s.length();i++ ){\\n            if(s[i]!=s[i-1]){\\n                ans+=s[i];\\n            }\\n        }\\n        return ans.length()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704884,
                "title": "c-easy-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/2fe5698a-d0e5-4549-8638-57aecfff5a34_1688226708.6732652.png)\\n\\n# Intuition\\nJust return the number of different chars.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        return new HashSet<char>(s).Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        return new HashSet<char>(s).Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619491,
                "title": "python3-one-liner-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf at every character, we are allowed to remove its left and right occurrences then basically we can remove all its duplicate occurrences.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can just return the length of the set of given string as, the set object in python removes all duplicate occurrences of all the elements present in the iterative object passed to it. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the length of s\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612504,
                "title": "simple-c-code",
                "content": "# Code\\n\\n## Code 1 : Using Unordered Set\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set <char> us;\\n        for(auto &it:s)\\n            us.insert(it);\\n        return us.size();\\n    }\\n};\\n```\\n\\n## Code 2: Using Unordered Map\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map <char,bool> ump;\\n        for(auto &it:s)\\n            ump[it]=1;\\n        return ump.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set <char> us;\\n        for(auto &it:s)\\n            us.insert(it);\\n        return us.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map <char,bool> ump;\\n        for(auto &it:s)\\n            ump[it]=1;\\n        return ump.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597035,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596812,
                "title": "one-liner-solution-as-simple-as-it-can-get",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set st(s.begin(),s.end());\\n        return st.size();       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set st(s.begin(),s.end());\\n        return st.size();       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596319,
                "title": "minimize-string-length",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>hs = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            hs.add(c);\\n        }\\n        return hs.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>hs = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            hs.add(c);\\n        }\\n        return hs.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595430,
                "title": "c-python-java-easy-solution-w-intuition-code",
                "content": "# Intuition\\nIn this problem, you can prove that only one occurance of any character will remain by the end of all operation.\\nConsider the string s=\"abcdabacd\"\\n```html\\nindex  - 0 1 2 3 4 5 6 7 8 9\\nstring - a b c d a b a c d a\\n```\\nWe\\'ll consider the index to be unchanged after removal for simplicity of explanation.\\n\\nAt i=0, the \"a\" present at i=4 will be removed.\\nAt i=6, the \"a\" present at i=0 and i=9 will be removed.\\n\\nSimilarly, at each occurance of \"a\", at least 1 other \"a\" will be removed(if any exist). This way only one occurance of every character will remain. \\n\\n# Approach\\nSince we know that we just have to count the number of distinct character, the approach is as simple as using a hashset to get the number of distinct characters.\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> cset;\\n        for(char c: s)\\n            cset.insert(c);\\n        return cset.size();\\n    }\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```\\n```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for(int i=0; i<s.length(); i++)\\n            hs.add(s.charAt(i));\\n        return hs.size();\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> hs(26, false);\\n        for(char c: s)\\n            hs[c-\\'a\\'] = true;\\n        int res{0};\\n        for(bool c: hs)\\n            res += c;\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n\\n- Time complexity: $$O(n)$$\\nSince we\\'re traversing the entire string once.\\n\\n- Space complexity: $$O(n)$$ \\nBecause we are storing all the characters of `s` in the Hash Set. In this specific case, the constraint \"*`s` contains only lowercase English letters*\" makes it $$O(26)$$.\\n\\n>### Note\\n>- Upvote if you liked my solution\\n>- Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```html\\nindex  - 0 1 2 3 4 5 6 7 8 9\\nstring - a b c d a b a c d a\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> cset;\\n        for(char c: s)\\n            cset.insert(c);\\n        return cset.size();\\n    }\\n};\\n```\n```python []\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```\n```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for(int i=0; i<s.length(); i++)\\n            hs.add(s.charAt(i));\\n        return hs.size();\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> hs(26, false);\\n        for(char c: s)\\n            hs[c-\\'a\\'] = true;\\n        int res{0};\\n        for(bool c: hs)\\n            res += c;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595420,
                "title": "return-len-set-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595322,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        unordered_map<char, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            char ch = s[i];\\n            mp[ch].push_back(i);\\n        }\\n        \\n        return mp.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        unordered_map<char, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            char ch = s[i];\\n            mp[ch].push_back(i);\\n        }\\n        \\n        return mp.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595317,
                "title": "python3-solution-one-linear",
                "content": "# Intuition\\nWe can delete any letters as much if its duplicate exist. So we need to count the number of all different characters in the string.\\n\\n# Approach\\nBy using Counter in python we can achieve the above. the len of the counter is the number of different characters in the string.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(26)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(Counter(s))\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(Counter(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595313,
                "title": "c-o-n-simple-solution",
                "content": "# Intuition\\nJust return the number of different chars.\\n\\n# Approach\\nAt first count number of each char:\\n```\\nprivate Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n```\\nThen return the number of different chars:\\n```\\nvar dic = CreateMinimizedStringLengt(s);\\nreturn dic.Count;\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is the length of s\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        var dic = CreateMinimizedStringLengt(s);\\n        return dic.Count;\\n    }\\n    private Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n    {\\n        var rs = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (!rs.ContainsKey(s[i]))\\n            {\\n                rs.Add(s[i], 1);\\n            }\\n            else\\n            {\\n                rs[s[i]]++;\\n            }\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nprivate Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n```\n```\\nvar dic = CreateMinimizedStringLengt(s);\\nreturn dic.Count;\\n```\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        var dic = CreateMinimizedStringLengt(s);\\n        return dic.Count;\\n    }\\n    private Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n    {\\n        var rs = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (!rs.ContainsKey(s[i]))\\n            {\\n                rs.Add(s[i], 1);\\n            }\\n            else\\n            {\\n                rs[s[i]]++;\\n            }\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595246,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto it:s) st.insert(it);\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto it:s) st.insert(it);\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595098,
                "title": "easy-java-6-line-hashset",
                "content": "```\\nclass Solution {\\n   public static int minimizedStringLength(String s) {\\n      char str[]=s.toCharArray();\\n      HashSet<Character> hs=new HashSet<>();\\n      for(int i=0;i<s.length();i++){\\n        hs.add(s.charAt(i));\\n      }\\n      return hs.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public static int minimizedStringLength(String s) {\\n      char str[]=s.toCharArray();\\n      HashSet<Character> hs=new HashSet<>();\\n      for(int i=0;i<s.length();i++){\\n        hs.add(s.charAt(i));\\n      }\\n      return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595088,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n    We need to count unique char in the string\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m) \\n    m = number of unique char, max value is 26\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = (s) => {\\n    const uniqueChars = new Set([...s]);\\n    return uniqueChars.size;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = (s) => {\\n    const uniqueChars = new Set([...s]);\\n    return uniqueChars.size;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595082,
                "title": "python3-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a hashmap to store each character in the string. If the character is already inside the hashmap, skip it or just increment its count by 1.\\nWe then can return the length of the hashmap which will only include distinct characters.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), we visit each character inside s only once. n is the length of s.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) Worst case, every character is distinct and we have to store all of them inside the hashmap.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Use a hashmap. If character already inside map, don\\'t add. Then return length of hashmap\\n        duplicate = {}\\n\\n        if len(s) == 1:\\n            return 1\\n        for c in s:\\n            if c not in duplicate:\\n                duplicate[c] = 1\\n            duplicate[c] += 1\\n        \\n        return len(duplicate)\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Use a hashmap. If character already inside map, don\\'t add. Then return length of hashmap\\n        duplicate = {}\\n\\n        if len(s) == 1:\\n            return 1\\n        for c in s:\\n            if c not in duplicate:\\n                duplicate[c] = 1\\n            duplicate[c] += 1\\n        \\n        return len(duplicate)\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595065,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a map to count the occurrence of each character in the string. By iterating over the map and incrementing a counter variable, it effectively counts the number of unique characters in the string. The final count represents the minimum length of the string after removing duplicate characters.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a map<int,int> called m to store the count of each character in the input string s.\\n\\nThe for loop iterates through each character it in the string s and increments its count in the map m.\\n\\nAfter counting all the characters, the variable ans is initialized to 0.\\n\\nThe second for loop iterates through each key-value pair it in the map m.\\n\\nIn each iteration, the variable ans is incremented by 1, effectively counting the number of unique characters in the string.\\n\\nFinally, the value of ans is returned as the minimum length of the string after removing duplicates.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the input string s. This is because the code iterates over each character in the string to count their occurrences and then iterates over the map to count the number of unique characters. Both iterations have a linear time complexity with respect to the length of the string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the length of the input string s. This is because the map m stores the count of each character, which can be at most the length of the string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n     \\n    map<int,int> m; // Create a map to store character counts\\n    for(auto it:s) m[it]++; // Count the occurrence of each character in the input string\\n    int ans=0; // Initialize a variable to store the count of unique characters\\n    for(auto it:m) {\\n        ans++; // Increment the count for each unique character in the map\\n    }\\n    return ans; // Return the count of unique characters\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n     \\n    map<int,int> m; // Create a map to store character counts\\n    for(auto it:s) m[it]++; // Count the occurrence of each character in the input string\\n    int ans=0; // Initialize a variable to store the count of unique characters\\n    for(auto it:m) {\\n        ans++; // Increment the count for each unique character in the map\\n    }\\n    return ans; // Return the count of unique characters\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595056,
                "title": "groupby",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) \\n    {\\n        return s.Select(x=>x).GroupBy(x=>x).Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) \\n    {\\n        return s.Select(x=>x).GroupBy(x=>x).Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595039,
                "title": "c-easy-solution-hashmap",
                "content": "The given code is a C++ solution for the problem of finding the length of the minimized string after performing a specific operation on a given string.\\n\\nA loop is used to iterate over each character in the string s. For each character, it is inserted into the mp unordered map with a value of true. This effectively removes any duplicate characters from the map since keys in an unordered map are unique.\\n```\\n#include<unordered_map>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n         int n = s.size();\\n        unordered_map<char, bool> mp;\\n\\n        for (int i = 0; i < n; i++) {\\n            mp[s[i]] = true;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<unordered_map>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n         int n = s.size();\\n        unordered_map<char, bool> mp;\\n\\n        for (int i = 0; i < n; i++) {\\n            mp[s[i]] = true;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3595036,
                "title": "stack-and-dict-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s):\\n        cnt = defaultdict(int)\\n        for i in s:\\n            cnt[i] += 1\\n        cnt = dict(sorted(cnt.items(), key=lambda x:x[1], reverse=True))\\n        st = []\\n        for i in s:\\n            #only append if cnt is 1. else decrease cnt \\n            if cnt[i] == 1: st.append(i)\\n            else: cnt[i] -= 1\\n        return len(st)\\n\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s):\\n        cnt = defaultdict(int)\\n        for i in s:\\n            cnt[i] += 1\\n        cnt = dict(sorted(cnt.items(), key=lambda x:x[1], reverse=True))\\n        st = []\\n        for i in s:\\n            #only append if cnt is 1. else decrease cnt \\n            if cnt[i] == 1: st.append(i)\\n            else: cnt[i] -= 1\\n        return len(st)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595029,
                "title": "python3-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595022,
                "title": "3-line-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> st;\\n        for(auto ch:s)\\n            st.insert(ch);\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> st;\\n        for(auto ch:s)\\n            st.insert(ch);\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594991,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(string s) \\n    {\\n        set<char> st;\\n        for(auto ch: s) st.insert(ch);\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(string s) \\n    {\\n        set<char> st;\\n        for(auto ch: s) st.insert(ch);\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594974,
                "title": "short-simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<String> set = new HashSet();\\n        for(int i=0; i<s.length(); i++) set.add(s.charAt(i)+\"\");\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<String> set = new HashSet();\\n        for(int i=0; i<s.length(); i++) set.add(s.charAt(i)+\"\");\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091256,
                "title": "simple-with-unit-tests",
                "content": "## Follow Vaclav Kosar for more software and machine learning at https://vaclavkosar.com/\\n\\n\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \"\"\"\\n        Given a string `s`.\\n        Operation: select position `i` with character `c`, delete closest occurent of `c` to the left if any and right if any.\\n        Repeat Operation any number of times to minimize length of string `s`.\\n        Return length of the minimized string.\\n\\n        The operation above, allows us to deduplicate characters in the string.\\n        While removing the middle duplicates lead to faster results, because we can remove the characters in pairs.\\n\\n        >>> Solution().minimizedStringLength(\"aikadua\")\\n        5\\n\\n        # Explanation: I would select the middle \"a\" to remove. len(\"ikadu\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"aaabc\")\\n        3\\n\\n        # len(\"abc\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"cbbd\")\\n        3\\n\\n\\n        >>> Solution().minimizedStringLength(\"dddaaa\")\\n        2\\n\\n        # len(\"abc\")\\n\\n\\n        Another opportunity is ability to find the duplicate characters quickly.\\n        Perhaps one option would be to index them with for example dictionary.\\n\\n        Let me index the string into dictionary by character.\\n        Then deduplicate within that index.\\n        Then return remaining length.\\n\\n        Now to save time, I can just use set to get the right answer already and get the same result.\\n\\n        \"\"\"\\n\\n        # char_index = defaultdict(list)\\n        # for i, c in enumerate(s):\\n        #    char_index[c].append(i)\\n        # for c in char_index:\\n        #   indexes = char_index[c]\\n        #   indexes.pop(0); indexes.pop(-1)\\n        #\\n        # ...\\n\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \"\"\"\\n        Given a string `s`.\\n        Operation: select position `i` with character `c`, delete closest occurent of `c` to the left if any and right if any.\\n        Repeat Operation any number of times to minimize length of string `s`.\\n        Return length of the minimized string.\\n\\n        The operation above, allows us to deduplicate characters in the string.\\n        While removing the middle duplicates lead to faster results, because we can remove the characters in pairs.\\n\\n        >>> Solution().minimizedStringLength(\"aikadua\")\\n        5\\n\\n        # Explanation: I would select the middle \"a\" to remove. len(\"ikadu\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"aaabc\")\\n        3\\n\\n        # len(\"abc\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"cbbd\")\\n        3\\n\\n\\n        >>> Solution().minimizedStringLength(\"dddaaa\")\\n        2\\n\\n        # len(\"abc\")\\n\\n\\n        Another opportunity is ability to find the duplicate characters quickly.\\n        Perhaps one option would be to index them with for example dictionary.\\n\\n        Let me index the string into dictionary by character.\\n        Then deduplicate within that index.\\n        Then return remaining length.\\n\\n        Now to save time, I can just use set to get the right answer already and get the same result.\\n\\n        \"\"\"\\n\\n        # char_index = defaultdict(list)\\n        # for i, c in enumerate(s):\\n        #    char_index[c].append(i)\\n        # for c in char_index:\\n        #   indexes = char_index[c]\\n        #   indexes.pop(0); indexes.pop(-1)\\n        #\\n        # ...\\n\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085382,
                "title": "minimize-string-length-js-as-short-as-possible",
                "content": "```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s).size\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s).size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082545,
                "title": "python-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        dic = {}\\n        for i in s:\\n            if i in dic:\\n                dic[i] += 1\\n            else:\\n                dic[i] = 1\\n        count = 0\\n        for i in dic:\\n            count += 1\\n        return count \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        dic = {}\\n        for i in s:\\n            if i in dic:\\n                dic[i] += 1\\n            else:\\n                dic[i] = 1\\n        count = 0\\n        for i in dic:\\n            count += 1\\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081844,
                "title": "best-solution-using-hash-map-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map <char, int> mp;\\n        for(auto i : s) {\\n            mp[i]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map <char, int> mp;\\n        for(auto i : s) {\\n            mp[i]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079835,
                "title": "simple-hashtable-as-boolean-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] lowers = new boolean[\\'z\\' - \\'a\\' + 1];\\n        int size = 0;\\n\\n        for(int i = 0; i < s.length(); i ++) {\\n            char ch = s.charAt(i);\\n\\n            if(!lowers[ch - \\'a\\']) {\\n                size ++;\\n                lowers[ch - \\'a\\'] = true;\\n            }\\n        }\\n\\n\\n        return size;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] lowers = new boolean[\\'z\\' - \\'a\\' + 1];\\n        int size = 0;\\n\\n        for(int i = 0; i < s.length(); i ++) {\\n            char ch = s.charAt(i);\\n\\n            if(!lowers[ch - \\'a\\']) {\\n                size ++;\\n                lowers[ch - \\'a\\'] = true;\\n            }\\n        }\\n\\n\\n        return size;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077975,
                "title": "python-one-line-solution-easy-solution",
                "content": "# Intuition\\nuse set: it store only non repeted values and then return the length\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076864,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[27];\\n        for (char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        for (int i : arr) {\\n            if (i > 0) {\\n                arr[26]++;\\n            }\\n        }\\n        return --arr[26];        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[27];\\n        for (char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        for (int i : arr) {\\n            if (i > 0) {\\n                arr[26]++;\\n            }\\n        }\\n        return --arr[26];        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073422,
                "title": "c-straightforward-approach-with-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            for (int j = i + 1; j < s.Length;)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                    s = s.Remove(j, 1);\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n\\n        return s.Length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            for (int j = i + 1; j < s.Length;)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                    s = s.Remove(j, 1);\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n\\n        return s.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072370,
                "title": "return-size-of-hashmap",
                "content": "# Intuition\\nthere will be only 1 key for repeated chars, so return len of keys.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashMap<Character,Integer> mapple = new HashMap<>();\\n        for (int i = 0; i <s.length(); i++) {\\n            mapple.put(s.charAt(i),1);\\n        }\\n        return mapple.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashMap<Character,Integer> mapple = new HashMap<>();\\n        for (int i = 0; i <s.length(); i++) {\\n            mapple.put(s.charAt(i),1);\\n        }\\n        return mapple.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069635,
                "title": "simple-c-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nusign map STL\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069478,
                "title": "2716-minimize-string-length-easy-simple-solutions",
                "content": "# Code\\n```Python []\\n\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        # Using built-in function: `return len(set(s))`\\n        res = \"\"\\n        for i in s:\\n            if i not in res:\\n                res += i\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python []\\n\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        # Using built-in function: `return len(set(s))`\\n        res = \"\"\\n        for i in s:\\n            if i not in res:\\n                res += i\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068678,
                "title": "4-line-code",
                "content": "# Intuition\\nuse a HashSet to prevent the entry of duplicates and return the size of the HashSet\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> len=new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n            len.add(s.charAt(i));\\n        return len.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> len=new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n            len.add(s.charAt(i));\\n        return len.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068238,
                "title": "simple-and-easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean visit[] = new boolean[26];\\n        int ans =0;\\n        for(char c:s.toCharArray()){\\n            if(!visit[c-\\'a\\']){\\n                ans++;\\n                visit[c-\\'a\\'] =true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean visit[] = new boolean[26];\\n        int ans =0;\\n        for(char c:s.toCharArray()){\\n            if(!visit[c-\\'a\\']){\\n                ans++;\\n                visit[c-\\'a\\'] =true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066711,
                "title": "using-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(s) {\\n    var obj={};\\n    for(var i=0;i<s.length;i++)\\n    {\\n        if(obj[s[i]]==undefined)\\n        {\\n           obj[s[i]]=1;\\n        }\\n        else\\n        {\\n            obj[s[i]]++;\\n        }\\n    }\\n    var ky=Object.keys(obj);\\n    return ky.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(s) {\\n    var obj={};\\n    for(var i=0;i<s.length;i++)\\n    {\\n        if(obj[s[i]]==undefined)\\n        {\\n           obj[s[i]]=1;\\n        }\\n        else\\n        {\\n            obj[s[i]]++;\\n        }\\n    }\\n    var ky=Object.keys(obj);\\n    return ky.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062189,
                "title": "one-line-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051607,
                "title": "beats-100-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n        int count = 0;\\n       //To store repeated character at one place\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n       //To count same char only once \\n          for(int i=0;i<26;i++){\\n              if(arr[i] > 0)\\n              count++;\\n          }\\n          return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n        int count = 0;\\n       //To store repeated character at one place\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n       //To count same char only once \\n          for(int i=0;i<26;i++){\\n              if(arr[i] > 0)\\n              count++;\\n          }\\n          return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049269,
                "title": "one-line-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimplest way is to make a set out of string \\'s\\' in order to find all unique elements from the string and return its length\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049001,
                "title": "very-easy-to-understand-beats-100-java",
                "content": "\\n# Here\\'s how the code works:\\n\\n1. It initializes a variable ```count``` to 0, which will be used to count the unique letters.\\n2. It creates a ```boolean array flag``` with 26 elements, representing the 26 lowercase letters of the English alphabet. Each element is initially set to ```false```.\\n3. It then iterates over the characters in the input string s.\\nFor each character c in the string, it calculates its position in the array flag by subtracting \\'a\\' from it. This effectively maps ```\\'a\\'``` to ```index 0```, ```\\'b\\'``` to ```index 1```, and so on.\\n4. It sets the corresponding element in the flag array to true to indicate that the letter has been encountered.\\n5. After processing all characters in the input ```string```, it iterates over the ```flag array``` to count how many letters have been marked as ```true```.\\n6. The count of unique letters is stored in the ```count``` variable, which is then returned as the result.\\nIn the end, this code returns the count of unique lowercase letters in the input ```string s```. A simple and efficient way to achieve this task.\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count=0;\\n        boolean[] flag=new boolean[26];\\n        for(int i=0;i<s.length();i++){\\n            flag[s.charAt(i)-\\'a\\'] = true;\\n        }\\n        for(int i=0;i<flag.length;i++){\\n            if(flag[i]) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```count```\n```boolean array flag```\n```false```\n```\\'a\\'```\n```index 0```\n```\\'b\\'```\n```index 1```\n```string```\n```flag array```\n```true```\n```count```\n```string s```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count=0;\\n        boolean[] flag=new boolean[26];\\n        for(int i=0;i<s.length();i++){\\n            flag[s.charAt(i)-\\'a\\'] = true;\\n        }\\n        for(int i=0;i<flag.length;i++){\\n            if(flag[i]) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048360,
                "title": "java-solution-beats-86-85",
                "content": "\\n# Approach\\n1) Every character must occur minimum times.\\n2) The least no of times that a character occurs has to be 1.\\n3) Let\\'s make a string str of characters from \\'a\\' to \\'z\\'.\\n4) Check if each separate character in str is present in s.\\n5) The count of the string will start to minimise because only individual characters will be counted i.e only once.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s)\\n    {\\n        String str=\"abcdefghijklmnopqrstuvwxyz\";\\n        int min_len=0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(s.indexOf(str.charAt(i))!=-1)\\n               min_len++;\\n        }\\n       return min_len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s)\\n    {\\n        String str=\"abcdefghijklmnopqrstuvwxyz\";\\n        int min_len=0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(s.indexOf(str.charAt(i))!=-1)\\n               min_len++;\\n        }\\n       return min_len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044087,
                "title": "easy-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Hashset\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<String> h1 = new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            h1.add(s.substring(i,i+1));\\n        }\\n        System.out.println(\"h1 is \"+h1);\\n        return h1.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<String> h1 = new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            h1.add(s.substring(i,i+1));\\n        }\\n        System.out.println(\"h1 is \"+h1);\\n        return h1.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043328,
                "title": "100-runtime-beats-99-40-memory-beats-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int arr[]=new int[26];\\n        int count=0;\\n        for(char c : s.toCharArray()){\\n            arr[c-\\'a\\']++;\\n        }\\n        for(int n:arr){\\n            if(n!=0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int arr[]=new int[26];\\n        int count=0;\\n        for(char c : s.toCharArray()){\\n            arr[c-\\'a\\']++;\\n        }\\n        for(int n:arr){\\n            if(n!=0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042765,
                "title": "python-1-line-solution-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040820,
                "title": "c-o-1-memory-complexity",
                "content": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        sort(s.begin(),s.end());\\n        int cnt=1;\\n        \\n        for(int i=1;i<s.size();i++){\\n            \\n            if(s[i]!=s[i-1]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        sort(s.begin(),s.end());\\n        int cnt=1;\\n        \\n        for(int i=1;i<s.size();i++){\\n            \\n            if(s[i]!=s[i-1]){\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4040329,
                "title": "python-beat-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n      res = 0\\n      st = set(s)\\n      for i in st:\\n        res += 1\\n      return res\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n      res = 0\\n      st = set(s)\\n      for i in st:\\n        res += 1\\n      return res\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036551,
                "title": "c-easy-and-readable-solution-faster-than-62",
                "content": "![image.png](https://assets.leetcode.com/users/images/02707d73-80c2-425c-814c-d8783e5284d5_1694538701.2099478.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        Dictionary<char, int> dc = new ();\\n        for (int i = 0; i < s.Length; i++)\\n            if (!dc.ContainsKey(s[i]))\\n                dc.Add(s[i], 1);\\n            else\\n                dc[s[i]]++;\\n        return dc.Count;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        Dictionary<char, int> dc = new ();\\n        for (int i = 0; i < s.Length; i++)\\n            if (!dc.ContainsKey(s[i]))\\n                dc.Add(s[i], 1);\\n            else\\n                dc[s[i]]++;\\n        return dc.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031544,
                "title": "easiest-solution-o-n-beat-90",
                "content": "\\n# Complexity\\n- Time complexity:\\n ```\\nO(N)\\n```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(N)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        if(s.length()==1)\\n        return 1;\\n         string str;\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(str.length()>0)\\n            { if(s[i]==str[str.length()-1])\\n            {\\n                continue;\\n            }\\n            else\\n            { str+=s[i];\\n\\n            }\\n\\n            }\\n            else\\n            {\\n                str+=s[i];\\n            }\\n        }\\n        return str.length();\\n    }\\n};\\n```\\n\\nhope you found it useful....btw i didnt get leetcode submit algorithm \\uD83D\\uDE05...when i submit first time this code beats 98% takes only 8ms hahaha",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nO(N)\\n```\n```\\nO(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        if(s.length()==1)\\n        return 1;\\n         string str;\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(str.length()>0)\\n            { if(s[i]==str[str.length()-1])\\n            {\\n                continue;\\n            }\\n            else\\n            { str+=s[i];\\n\\n            }\\n\\n            }\\n            else\\n            {\\n                str+=s[i];\\n            }\\n        }\\n        return str.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025324,
                "title": "one-line-code-with-no-extra-space-and-linear-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(1)** ---> Set can be Constructed of Size(26) Worst Case Possible. So it is Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022345,
                "title": "easy-to-understand-python-solution-1-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016358,
                "title": "elixir-mapset-rust-hashset-solutions",
                "content": "### Elixir\\n\\n```\\ndefmodule Solution do\\n  @spec minimized_string_length(s :: String.t()) :: integer\\n  def minimized_string_length(s) do\\n    s |> String.graphemes() |> MapSet.new() |> MapSet.size()\\n  end\\nend\\n\\n```\\n\\n### Rust\\n\\n```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let st: HashSet<u8> = HashSet::from_iter(s.bytes().into_iter());\\n        st.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec minimized_string_length(s :: String.t()) :: integer\\n  def minimized_string_length(s) do\\n    s |> String.graphemes() |> MapSet.new() |> MapSet.size()\\n  end\\nend\\n\\n```\n```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let st: HashSet<u8> = HashSet::from_iter(s.bytes().into_iter());\\n        st.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4015125,
                "title": "accepted-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014349,
                "title": "javascript-1-liner",
                "content": "# Code\\n```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s.split(\\'\\')).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s.split(\\'\\')).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013784,
                "title": "beats-100-in-time-space",
                "content": "# Approach - Use int array and store as 1 for the character is present\\n\\nThen calculate the total by iterating over the loop\\nThis beats the Set and HashMap solution flat out doubled the time\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] alpha = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            alpha[s.charAt(i)-\\'a\\'] = 1;\\n        }\\n        int total = 0;\\n        for(int num:alpha){\\n            total+=num;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] alpha = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            alpha[s.charAt(i)-\\'a\\'] = 1;\\n        }\\n        int total = 0;\\n        for(int num:alpha){\\n            total+=num;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013281,
                "title": "simple-c-program-answer",
                "content": "# Intuition\\nSOLUTION IN C PROGRAM .\\n\\n# Approach\\nBY SORTING THE CHARACTER INSIDE THE STRING AND COUNTING THE INDIVIUAL CHARACTER \\n\\n# Code\\n```\\nint minimizedStringLength(char * s){\\n\\n   int length = strlen(s); \\n   int count = 0;\\n   \\n   char temp;\\n   for(int i=0;i<length;i++){\\n       for(int j=i+1;j<length;j++){\\n           if(s[i] > s[j]){\\n               temp = s[i];\\n               s[i] = s[j];\\n               s[j] = temp;\\n           } \\n       }\\n   }\\n\\n   for(int i=1; i<length; i++){\\n       if(s[i] != s[count]){\\n           count++;\\n           s[count] = s[i];\\n       }\\n   }\\n\\n   return count + 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizedStringLength(char * s){\\n\\n   int length = strlen(s); \\n   int count = 0;\\n   \\n   char temp;\\n   for(int i=0;i<length;i++){\\n       for(int j=i+1;j<length;j++){\\n           if(s[i] > s[j]){\\n               temp = s[i];\\n               s[i] = s[j];\\n               s[j] = temp;\\n           } \\n       }\\n   }\\n\\n   for(int i=1; i<length; i++){\\n       if(s[i] != s[count]){\\n           count++;\\n           s[count] = s[i];\\n       }\\n   }\\n\\n   return count + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010143,
                "title": "java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean alphabets[] = new boolean[26];\\n        int ans = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(!alphabets[c - \\'a\\']){\\n                ans++;\\n                alphabets[c - \\'a\\'] = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean alphabets[] = new boolean[26];\\n        int ans = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(!alphabets[c - \\'a\\']){\\n                ans++;\\n                alphabets[c - \\'a\\'] = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009932,
                "title": "2lines-code-easy-code-java-string",
                "content": "\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (ch[i] != ch[i + 1]) {\\n                count++;\\n            }\\n        }\\n        // Increment count for the last unique character\\n        count++;\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (ch[i] != ch[i + 1]) {\\n                count++;\\n            }\\n        }\\n        // Increment count for the last unique character\\n        count++;\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005654,
                "title": "o-n-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnce you have analysed, the goal is to find the unique elements in the string\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Using a set, try to insert all the elements in the set\\n2. Return the size of the set\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set <char> ans;\\n        for(auto x : s) {\\n            ans.insert(x);\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set <char> ans;\\n        for(auto x : s) {\\n            ans.insert(x);\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002535,
                "title": "two-types-of-code-array-and-string-method-both",
                "content": "\\n```\\nfunction minimizedStringLength(s: string): number {\\n    //  let strArr = [...s];\\n    // let count = 0;\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     for (let j = i + 1; j < strArr.length; j++) {\\n    //         if (strArr[i] === strArr[j]) {\\n    //             strArr[j] = \".\";\\n    //         }\\n    //     }\\n    // }\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     if (strArr[i] != \".\") {\\n    //         count++;\\n    //     }\\n    // }\\n\\n    // return count;\\n\\n     let str = \"\";\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (!str.includes(s[i])) {\\n            str += s[i];\\n        }\\n    }\\n\\n    return str.length;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction minimizedStringLength(s: string): number {\\n    //  let strArr = [...s];\\n    // let count = 0;\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     for (let j = i + 1; j < strArr.length; j++) {\\n    //         if (strArr[i] === strArr[j]) {\\n    //             strArr[j] = \".\";\\n    //         }\\n    //     }\\n    // }\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     if (strArr[i] != \".\") {\\n    //         count++;\\n    //     }\\n    // }\\n\\n    // return count;\\n\\n     let str = \"\";\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (!str.includes(s[i])) {\\n            str += s[i];\\n        }\\n    }\\n\\n    return str.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001122,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string>\\nclass Solution {\\n    public:\\n    int minimizedStringLength(string s) {\\n        int n=s.size();\\n        for (int i=0;i<n;){\\n            char ch=s[i];\\n            int j=i+1;\\n            while(j<n){\\n                if (s[j]==ch){\\n                    s.erase(j,1);\\n                    n--;\\n                }\\n                else j++;\\n            }\\n            i++;\\n        }\\n        return s.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\nclass Solution {\\n    public:\\n    int minimizedStringLength(string s) {\\n        int n=s.size();\\n        for (int i=0;i<n;){\\n            char ch=s[i];\\n            int j=i+1;\\n            while(j<n){\\n                if (s[j]==ch){\\n                    s.erase(j,1);\\n                    n--;\\n                }\\n                else j++;\\n            }\\n            i++;\\n        }\\n        return s.size();\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3992806,
                "title": "trick-solution-easy-solution-using-set-4-line-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought was breaking the solution but it seemed too much work so I tried reading the question again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter reading it again I suspected a trick solution might work.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> res = new HashSet<>();\\n        for(char c : s.toCharArray())\\n            res.add(c);\\n        return res.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> res = new HashSet<>();\\n        for(char c : s.toCharArray())\\n            res.add(c);\\n        return res.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992235,
                "title": "minimize-string-length",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    We just have to return the number of unique character in String\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(k) where k is the number of unique element. \\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Map<Character,Integer> map = new HashMap<>(); \\n        \\n        int ans = 0;\\n        for(char ch : s.toCharArray())\\n        {\\n            if(map.containsKey(ch)) continue;\\n            else{\\n                map.put(ch,1);\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Map<Character,Integer> map = new HashMap<>(); \\n        \\n        int ans = 0;\\n        for(char ch : s.toCharArray())\\n        {\\n            if(map.containsKey(ch)) continue;\\n            else{\\n                map.put(ch,1);\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988060,
                "title": "c-2-line-easy-solution",
                "content": "# C++ | 2 Line | easy solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        sort(s.begin(),s.end());\\n        s.erase(unique(s.begin(),s.end()),s.end());\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        sort(s.begin(),s.end());\\n        s.erase(unique(s.begin(),s.end()),s.end());\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985282,
                "title": "typescript-solution",
                "content": "```\\nfunction minimizedStringLength(s: string): number {\\n    const chars: string[] = [...new Set(s.split(\\'\\'))];\\n    return chars.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction minimizedStringLength(s: string): number {\\n    const chars: string[] = [...new Set(s.split(\\'\\'))];\\n    return chars.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983548,
                "title": "solution-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFist I was thinking that I will leave string \"absba\"\\nBut after carfully reading the task I understod that I neeed only distince letters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981569,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>h=new HashSet();\\n        for(int i=0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n        return h.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>h=new HashSet();\\n        for(int i=0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n        return h.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980359,
                "title": "best-explained-and-easiest-solution",
                "content": "# Intuition\\nBasicaly the question is to return the size of substring in a given string which has no duplicate characters,so if you think about it the easiest way to solve this problem is to use set data structure,because set doesnt contain duplicates.\\n\\n# Approach\\n-Traverse through the string and insert every character to set.\\n-In the end return the size of a set.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    set<char>st;\\n    for(char c:s){\\n      st.insert(c);\\n    }    \\n    return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    set<char>st;\\n    for(char c:s){\\n      st.insert(c);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3979931,
                "title": "python-one-line-solution",
                "content": "The only challenge here was to not misinterpret the description and sample cases\\n\\nthe final string will contain no duplicates\\n# Solution\\n```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978878,
                "title": "simple-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(String.valueOf(s.charAt(i)));\\n        }\\n        return set.size();\\n\\n\\n        // StringBuilder sb = new StringBuilder(s);\\n        // for(int i=0; i<sb.length()-1; i++){\\n        //     for(int j=0; j<sb.length()-1; j++){\\n        //         if(sb.charAt(j)==sb.charAt(j+1)){\\n        //             sb.deleteCharAt(j);\\n        //         }\\n        //     }\\n        // }\\n        // String str = sb.toString();\\n        // return str.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(String.valueOf(s.charAt(i)));\\n        }\\n        return set.size();\\n\\n\\n        // StringBuilder sb = new StringBuilder(s);\\n        // for(int i=0; i<sb.length()-1; i++){\\n        //     for(int j=0; j<sb.length()-1; j++){\\n        //         if(sb.charAt(j)==sb.charAt(j+1)){\\n        //             sb.deleteCharAt(j);\\n        //         }\\n        //     }\\n        // }\\n        // String str = sb.toString();\\n        // return str.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978609,
                "title": "go-beats-100",
                "content": "# Intuition\\nf the input string contains only lowercase English letters, you can use an array of size 26 to count the frequency of each letter in the string\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc minimizedStringLength(s string) int {\\n    freq := [26]int{}\\n\\n    for _, c := range s {\\n        freq[c-\\'a\\']++\\n    }\\n\\n    count := 0\\n    for _, f := range freq {\\n        if f > 0 {\\n            count++\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimizedStringLength(s string) int {\\n    freq := [26]int{}\\n\\n    for _, c := range s {\\n        freq[c-\\'a\\']++\\n    }\\n\\n    count := 0\\n    for _, f := range freq {\\n        if f > 0 {\\n            count++\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973020,
                "title": "easy-java-solution-by-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> h = new HashSet<>();\\n        for(int i =0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n\\n    return h.size();}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> h = new HashSet<>();\\n        for(int i =0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n\\n    return h.size();}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972899,
                "title": "solution-with-constant-time-and-memory",
                "content": "\\n# Approach\\nWe need the number of the unique characters. If a character appears\\nmore than 1 time, it can be reduced to 1 apparition. Instead of \\nusing set or map (which occupies a lot memory), use a 26 sized-array(\\nwe are working with small letters) like a map of <int, int> or like a set.\\n![image.png](https://assets.leetcode.com/users/images/e8fc8a39-f97c-4101-9999-1b3d6a3a387c_1693244183.0110075.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //s contains only lowercase English letters\\n        int arr[26] = {0};\\n        for (auto c : s)\\n        {\\n            arr[c - \\'a\\']++;\\n        }\\n        int nr = 0;\\n        for (int c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            if (arr [c - \\'a\\'] >= 1)\\n            {\\n                nr ++;\\n            }\\n        }\\n        return nr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //s contains only lowercase English letters\\n        int arr[26] = {0};\\n        for (auto c : s)\\n        {\\n            arr[c - \\'a\\']++;\\n        }\\n        int nr = 0;\\n        for (int c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            if (arr [c - \\'a\\'] >= 1)\\n            {\\n                nr ++;\\n            }\\n        }\\n        return nr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972775,
                "title": "hash-map-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> mp;\\n\\n        for (int i=0;i<s.size();i++) {\\n            mp[s[i]]++;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> mp;\\n\\n        for (int i=0;i<s.size();i++) {\\n            mp[s[i]]++;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955894,
                "title": "ruby-one-line-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {String} s\\n# @return {Integer}\\ndef minimized_string_length(s)\\n    return s.split(\"\").tally.size\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @return {Integer}\\ndef minimized_string_length(s)\\n    return s.split(\"\").tally.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3951560,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char,int>m;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            if(m[s[i]]==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char,int>m;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            if(m[s[i]]==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951308,
                "title": "c-bits-manipulation-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int mask = 0;\\n        for(char &ele:s){\\n            mask |= (1<<(ele-\\'a\\'));\\n        }\\n        int res = 0;\\n        while(mask){\\n            res += (mask&1);\\n            mask = mask>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int mask = 0;\\n        for(char &ele:s){\\n            mask |= (1<<(ele-\\'a\\'));\\n        }\\n        int res = 0;\\n        while(mask){\\n            res += (mask&1);\\n            mask = mask>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949226,
                "title": "minimize-string-length-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i =0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i =0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946369,
                "title": "js-hashmap-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(arr) {\\n    let map = new Map();\\n\\n\\n    for(let i=0; i<arr.length; i++){\\n        if(!map.has(arr[i])) map.set(arr[i], 1)\\n    }\\n\\n    return map.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(arr) {\\n    let map = new Map();\\n\\n\\n    for(let i=0; i<arr.length; i++){\\n        if(!map.has(arr[i])) map.set(arr[i], 1)\\n    }\\n\\n    return map.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943656,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(NLogN)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int j = 0;\\n        int resultCount = 1;\\n        char[] tmp = s.toCharArray();\\n\\n        Arrays.sort(tmp);\\n\\n        for (int i = 1; i < tmp.length; i++) {\\n            if (tmp[i] != tmp[j]) {\\n                resultCount++;\\n                j = i;\\n            }\\n        }\\n\\n        return resultCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int j = 0;\\n        int resultCount = 1;\\n        char[] tmp = s.toCharArray();\\n\\n        Arrays.sort(tmp);\\n\\n        for (int i = 1; i < tmp.length; i++) {\\n            if (tmp[i] != tmp[j]) {\\n                resultCount++;\\n                j = i;\\n            }\\n        }\\n\\n        return resultCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942288,
                "title": "easy-code-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string temp=\"\";\\n        sort(s.begin(),s.end());\\n        temp.push_back(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(temp.back()!=s[i])\\n            {\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string temp=\"\";\\n        sort(s.begin(),s.end());\\n        temp.push_back(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(temp.back()!=s[i])\\n            {\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941177,
                "title": "simple-solution-4-lines-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> sb = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            sb.add(c);\\n        }\\n        return sb.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> sb = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            sb.add(c);\\n        }\\n        return sb.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939092,
                "title": "clean-golang-solution",
                "content": "# Code\\n```\\nfunc minimizedStringLength(s string) int {\\n    set := make(map[rune]struct{},0)\\n    for _,v := range s {\\n        set[v] = struct{}{}\\n    }\\n    return len(set)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimizedStringLength(s string) int {\\n    set := make(map[rune]struct{},0)\\n    for _,v := range s {\\n        set[v] = struct{}{}\\n    }\\n    return len(set)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937649,
                "title": "2716-minimize-string-length-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(N);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //taking the int variables i,j \\n        int i=0,j=0;\\n        //taking the one string variable\\n        string st=\"\";\\n        //using the sort method to sort the string \\n        sort(s.begin(), s.end());\\n        while(i<s.length()){\\n            st+=s[i];\\n            if(s[i]==s[i+1]){\\n                st.pop_back();\\n            }\\n            else{\\n                j++;\\n                st+=s[i];\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //taking the int variables i,j \\n        int i=0,j=0;\\n        //taking the one string variable\\n        string st=\"\";\\n        //using the sort method to sort the string \\n        sort(s.begin(), s.end());\\n        while(i<s.length()){\\n            st+=s[i];\\n            if(s[i]==s[i+1]){\\n                st.pop_back();\\n            }\\n            else{\\n                j++;\\n                st+=s[i];\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3932732,
                "title": "easy-solution-2-lines-using-set",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n       return st.size();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n       return st.size();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931847,
                "title": "one-word-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n        \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n        \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928205,
                "title": "easy-to-understand-c-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926241,
                "title": "simple-java-solution-single-loop",
                "content": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder r = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (r.indexOf(String.valueOf(c)) == -1) {\\n                r.append(c);\\n            }\\n        }\\n        return r.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder r = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (r.indexOf(String.valueOf(c)) == -1) {\\n                r.append(c);\\n            }\\n        }\\n        return r.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925031,
                "title": "easy-python-solution-for-minimize-the-string-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = \\'\\'\\n        for i in s:\\n            if i not in res:\\n                res += i\\n            else:\\n                pass\\n        return len(res)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = \\'\\'\\n        for i in s:\\n            if i not in res:\\n                res += i\\n            else:\\n                pass\\n        return len(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923048,
                "title": "short-and-easy-solution-using-set-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nintuition is simple to take unique elements from strings\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso i think about set as it stors only unique elements\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTC is O(N)\\n\\n- Space complexity:\\n- O(N) as we took set  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto c:s)\\n        {\\n            st.insert(c);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto c:s)\\n        {\\n            st.insert(c);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921937,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) \\n        {\\n            if (sb.indexOf(String.valueOf(c)) == -1) \\n            {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.length();\\n         }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) \\n        {\\n            if (sb.indexOf(String.valueOf(c)) == -1) \\n            {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.length();\\n         }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921726,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(const string& s)\\n    {\\n        int freq[26] = {0};\\n        for (char c : s)\\n        {\\n            freq[c - \\'a\\']++;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (freq[i] > 0)\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(const string& s)\\n    {\\n        int freq[26] = {0};\\n        for (char c : s)\\n        {\\n            freq[c - \\'a\\']++;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (freq[i] > 0)\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921046,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        int[] arr = new int[26];\\n        for(char c:s.toCharArray()){\\n            if(arr[c - \\'a\\'] == 0){\\n                count++;\\n                arr[c - \\'a\\'] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        int[] arr = new int[26];\\n        for(char c:s.toCharArray()){\\n            if(arr[c - \\'a\\'] == 0){\\n                count++;\\n                arr[c - \\'a\\'] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919817,
                "title": "just-count-the-unique-characters-o-n-beats-100",
                "content": "# intuition\\nfor any character having more than one occurence, it can be deleted from left or right of chosen pivot character.\\nonly the pivot character can\\'t be deleted.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] distincts = new boolean[26];\\n        for(char ch: s.toCharArray()) {\\n            distincts[ch-97] = true;\\n        }\\n        int sum = 0;\\n        for(boolean b: distincts) {\\n            sum += b?1:0;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] distincts = new boolean[26];\\n        for(char ch: s.toCharArray()) {\\n            distincts[ch-97] = true;\\n        }\\n        int sum = 0;\\n        for(boolean b: distincts) {\\n            sum += b?1:0;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917891,
                "title": "dart-solution-in-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minimizedStringLength(String s) {\\n      return s.split(\\'\\').toSet().length;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minimizedStringLength(String s) {\\n      return s.split(\\'\\').toSet().length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917314,
                "title": "go-simple-solution",
                "content": "# Code\\n```go\\nfunc minimizedStringLength(s string) (l int) {\\n    // recommended slices more than map which is slower\\n    v := make([]bool, 26)\\n    for _, b := range s {\\n        if v[b-\\'a\\'] {\\n            continue\\n        }\\n        v[b-\\'a\\'] = true \\n        l++\\n    }\\n    return\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minimizedStringLength(s string) (l int) {\\n    // recommended slices more than map which is slower\\n    v := make([]bool, 26)\\n    for _, b := range s {\\n        if v[b-\\'a\\'] {\\n            continue\\n        }\\n        v[b-\\'a\\'] = true \\n        l++\\n    }\\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916820,
                "title": "easy-understanding",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(m) where m isthe unique charecters in the string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int count = 0;\\n        char ch = s[0];\\n        int n = s.size();\\n        unordered_map<int, int> umap;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(umap.find(s[i]) != umap.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n                umap[s[i]]++;\\n            }\\n        }\\n        return umap.size();\\n        // for(int i=1;i<n;i++)\\n        // {\\n        //     if(s[i] == ch)\\n        //     {\\n        //         continue;\\n        //     }\\n        //     else\\n        //     {\\n        //         count++;\\n        //         ch = s[i];\\n        //     }\\n        // }\\n        // return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int count = 0;\\n        char ch = s[0];\\n        int n = s.size();\\n        unordered_map<int, int> umap;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(umap.find(s[i]) != umap.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n                umap[s[i]]++;\\n            }\\n        }\\n        return umap.size();\\n        // for(int i=1;i<n;i++)\\n        // {\\n        //     if(s[i] == ch)\\n        //     {\\n        //         continue;\\n        //     }\\n        //     else\\n        //     {\\n        //         count++;\\n        //         ch = s[i];\\n        //     }\\n        // }\\n        // return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916506,
                "title": "96-with-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<int> arr(26,0);\\n        int ans=0;\\n        for(auto i:s){\\n            arr[i-\\'a\\']++;\\n            if(arr[i-\\'a\\']==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<int> arr(26,0);\\n        int ans=0;\\n        for(auto i:s){\\n            arr[i-\\'a\\']++;\\n            if(arr[i-\\'a\\']==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916035,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] table = new boolean[26];\\n        int count = 0;\\n\\n        for(char c : s.toCharArray())\\n           table[c -\\'a\\'] = true;\\n        \\n        for(int i = 0; i < 26; i++)\\n           if(table[i]) count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] table = new boolean[26];\\n        int count = 0;\\n\\n        for(char c : s.toCharArray())\\n           table[c -\\'a\\'] = true;\\n        \\n        for(int i = 0; i < 26; i++)\\n           if(table[i]) count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914310,
                "title": "easy-solution-using-set-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910404,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just removing the duplicate here.\\nSo just remove the duplicate string elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        List<Character> list=new ArrayList<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(!list.contains(s.charAt(i)))\\n            {\\n                list.add(s.charAt(i));\\n            }\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        List<Character> list=new ArrayList<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(!list.contains(s.charAt(i)))\\n            {\\n                list.add(s.charAt(i));\\n            }\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907841,
                "title": "using-map-in-c-very-easy-solution",
                "content": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        //Time and space com = O(n);\\n        unordered_map<char,int> mp;\\n        for(char ch : s)\\n        {\\n            mp[ch]++;\\n        }\\n        \\n        return mp.size();\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        //Time and space com = O(n);\\n        unordered_map<char,int> mp;\\n        for(char ch : s)\\n        {\\n            mp[ch]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3902678,
                "title": "o-n-simple-solution-using-mapping-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust use pigeonhole sort principle\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minimizedStringLength(char * s){\\n    int arr[26] = {0};\\n    for(int i = 0;i < strlen(s);i++){\\n        arr[s[i] - \\'a\\']++;\\n    }\\n    int p = 0;\\n    for(int i = 0;i < 26;i++){\\n        if(arr[i] > 0){\\n            p++;\\n        }\\n    }\\n    return(p);\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizedStringLength(char * s){\\n    int arr[26] = {0};\\n    for(int i = 0;i < strlen(s);i++){\\n        arr[s[i] - \\'a\\']++;\\n    }\\n    int p = 0;\\n    for(int i = 0;i < 26;i++){\\n        if(arr[i] > 0){\\n            p++;\\n        }\\n    }\\n    return(p);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3901474,
                "title": "simple-approach-is-using-set",
                "content": "\\n# Approach\\nSince any characher from left or right has to be deleted\\nTherefore any dublicate will be removed in the end.\\nso, the question boils down to count of unique elements.\\n\\n\\n\\n# Code\\n```\\n    int minimizedStringLength(string s) {\\n        set<char>se;\\n        for(char ch:s)se.insert(ch);\\n        return se.size();\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int minimizedStringLength(string s) {\\n        set<char>se;\\n        for(char ch:s)se.insert(ch);\\n        return se.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3898481,
                "title": "one-line-solution-with-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function (s) {\\n\\n    // remove same character from string s using Set() and convert into string from array using join() and find length of string using .length property and return it\\n    return [...new Set([...s])].join(\\'\\').length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function (s) {\\n\\n    // remove same character from string s using Set() and convert into string from array using join() and find length of string using .length property and return it\\n    return [...new Set([...s])].join(\\'\\').length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895120,
                "title": "very-easy-to-understand-just-go-and-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ntraverse every character of set and add it to hashset; lastly return set size;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> A = new HashSet<>();\\n        for(int i =0;i<s.length(); i++){\\n            if(!A.contains(s.charAt(i))){\\n                A.add(s.charAt(i));\\n            }\\n        }\\n        return A.size();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> A = new HashSet<>();\\n        for(int i =0;i<s.length(); i++){\\n            if(!A.contains(s.charAt(i))){\\n                A.add(s.charAt(i));\\n            }\\n        }\\n        return A.size();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894988,
                "title": "python3-and-python-100-simple-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = [i for i in set(s)]\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = [i for i in set(s)]\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894144,
                "title": "beginner-friendly-hashset-sol",
                "content": "# Intuition\\nThe answer string consist of only distinct characters\\n\\n# Approach\\nHashSet\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n\\n        for(char c : s.toCharArray()) {\\n            if(!set.add(c)) continue;\\n            else set.add(c);\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```\\n\\nPLEASE UPVOTE(if you\\'re not gay)",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n\\n        for(char c : s.toCharArray()) {\\n            if(!set.add(c)) continue;\\n            else set.add(c);\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893003,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    int i = 1;\\n    while (i < s.length()) {\\n        cout << s << endl;\\n        \\n        int left = i - 1;\\n        while (left >= 0 && s[left] != s[i]) {\\n            left--;\\n        }\\n        if (left >= 0) {\\n            s.erase(left, 1);\\n            i--;\\n        }\\n\\n        int right = i + 1;\\n        while (right < s.length() && s[right] != s[i]) {\\n            right++;\\n        }\\n        if (right < s.length()) {\\n            s.erase(right, 1);\\n        }\\n\\n        i++;\\n    }\\n    return s.length();\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    int i = 1;\\n    while (i < s.length()) {\\n        cout << s << endl;\\n        \\n        int left = i - 1;\\n        while (left >= 0 && s[left] != s[i]) {\\n            left--;\\n        }\\n        if (left >= 0) {\\n            s.erase(left, 1);\\n            i--;\\n        }\\n\\n        int right = i + 1;\\n        while (right < s.length() && s[right] != s[i]) {\\n            right++;\\n        }\\n        if (right < s.length()) {\\n            s.erase(right, 1);\\n        }\\n\\n        i++;\\n    }\\n    return s.length();\\n}\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3881800,
                "title": "3-lines-solution-incl-return-statement",
                "content": "# Intuition\\nRead between the lines. No need to search for similar chars inside of a string. All you are asked for is a count of unique chars.\\n\\n# Approach\\n- sort it\\n- remove duplicates\\n\\nerase(unique) idiom works just fine\\n\\n# Complexity\\n- Time complexity:\\n$$O(NlogN)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        std::sort(s.begin(), s.end());\\n        s.erase(std::unique(s.begin(), s.end()), s.end() );\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        std::sort(s.begin(), s.end());\\n        s.erase(std::unique(s.begin(), s.end()), s.end() );\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879996,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> mp;\\n\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> mp;\\n\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873211,
                "title": "in-1-line",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        s = set(s)\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        s = set(s)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872551,
                "title": "two-line-code-using-counter-function-runtime-45ms-beat-98-in-runtime",
                "content": "# Intuition\\n-> count the number of distinct character in string and return that count\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n->count the occurances of characters in string using counter function and return the number of distinct keys using len and keys function\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        c=Counter(s)\\n        return len(c.keys())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        c=Counter(s)\\n        return len(c.keys())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864868,
                "title": "python-one-liner-faster-than",
                "content": "# Intuition\\nThis problem is nothing more than a roundabout way of counting the number of unique characters in a string.  There are a number of ways to do this.\\n\\n# Approach\\nMy approach focuses on a \"real-world\" solution to this, which means convenient for the author.  For that reason, this solution is a one-liner.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**: We iterate through a string of length `n` once, performing constant time operations each iteration.  This solution beat 98.55% submissions.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**: We store potentially `n` characters in a set.  While one might be tempted to say this is O(1) space as the constraints specify the input characters are lowercase English letters, the proper abstraction applies to any range of character inputs.  This solution beat 70.97% of submissions.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        #this is literally just returning the number of unique characters\\n        return len({i for i in s})\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        #this is literally just returning the number of unique characters\\n        return len({i for i in s})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862849,
                "title": "easy-to-understand-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let mut unique: HashSet<char> = HashSet::new();\\n    \\n        for char in s.chars() {\\n            unique.insert(char);\\n        }\\n\\n        unique.len() as i32 //.try_into().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let mut unique: HashSet<char> = HashSet::new();\\n    \\n        for char in s.chars() {\\n            unique.insert(char);\\n        }\\n\\n        unique.len() as i32 //.try_into().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3859841,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # for i, c in enumerate(s):\\n        #     p = s[i::].find(c)\\n        #     s[p].replace(s[p], \" \")\\n        #     q = s[:i].find(c)\\n        #     s[q].replace(s[q], \" \")\\n        # return len(s)\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # for i, c in enumerate(s):\\n        #     p = s[i::].find(c)\\n        #     s[p].replace(s[p], \" \")\\n        #     q = s[:i].find(c)\\n        #     s[q].replace(s[q], \" \")\\n        # return len(s)\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858325,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857964,
                "title": "simple-solution-for-beginner-using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        l1=[]\\n        l2=[]\\n        for i in s:\\n            if i not in l1:\\n                l1.append(i)\\n            else:\\n                l2.append(i)\\n        return len(l1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        l1=[]\\n        l2=[]\\n        for i in s:\\n            if i not in l1:\\n                l1.append(i)\\n            else:\\n                l2.append(i)\\n        return len(l1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855703,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(strlen(s))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) as it does not depend on strlen but it \\'26\\'+\\'1\\' extra space used. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minimizedStringLength(char * s){\\n    int ans[\\'z\\'-64]={0};\\n    int count=0;\\n   for(int i=0;i<strlen(s);i++)\\n   {\\n       if(ans[s[i]-65]==0)\\n       {\\n           count++;\\n           ans[s[i]-65]++;\\n       }\\n       else\\n       continue;\\n   }\\n   return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizedStringLength(char * s){\\n    int ans[\\'z\\'-64]={0};\\n    int count=0;\\n   for(int i=0;i<strlen(s);i++)\\n   {\\n       if(ans[s[i]-65]==0)\\n       {\\n           count++;\\n           ans[s[i]-65]++;\\n       }\\n       else\\n       continue;\\n   }\\n   return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853728,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>ss;\\n        for(auto i:s){\\n            ss.insert(i);\\n        }\\n\\n        return ss.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>ss;\\n        for(auto i:s){\\n            ss.insert(i);\\n        }\\n\\n        return ss.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853714,
                "title": "java-easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849099,
                "title": "using-hashmap-one-line-solution",
                "content": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Using Hashmap\\n        # hash_ = {}\\n        # for i in s:\\n        #     if i not in hash_:\\n        #         hash_[i] = 1\\n        #     hash_[i] += 1\\n        # return len(hash_)\\n        \\n        # One line.\\n        return len(set(s))\\n```\\n\\nThanks for reading :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Using Hashmap\\n        # hash_ = {}\\n        # for i in s:\\n        #     if i not in hash_:\\n        #         hash_[i] = 1\\n        #     hash_[i] += 1\\n        # return len(hash_)\\n        \\n        # One line.\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846026,
                "title": "beginner-friendly-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character>set=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character>set=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845826,
                "title": "java-3ms-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // HashSet + StringBuilder strategy: 8ms Beats 79.21%\\n    // boolean[123] + StringBuilder strategy: 4ms Beats 99.80%\\n    // boolean[123] + int numChars strategy: 3ms Beats 100.00%\\n\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] skipForever = new boolean[123];\\n        int numChars = 0;  // what we\\'ll return\\n\\n        for (char c : s.toCharArray()) {\\n            if (!skipForever[c]) {\\n                ++numChars;\\n                skipForever[c] = true;\\n            }\\n        }\\n\\n        return numChars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // HashSet + StringBuilder strategy: 8ms Beats 79.21%\\n    // boolean[123] + StringBuilder strategy: 4ms Beats 99.80%\\n    // boolean[123] + int numChars strategy: 3ms Beats 100.00%\\n\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] skipForever = new boolean[123];\\n        int numChars = 0;  // what we\\'ll return\\n\\n        for (char c : s.toCharArray()) {\\n            if (!skipForever[c]) {\\n                ++numChars;\\n                skipForever[c] = true;\\n            }\\n        }\\n\\n        return numChars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845701,
                "title": "c-efficient-concise",
                "content": "# Intuition\\nThe problem description is a bit confusing, but it boils down to a count of unique characters.\\n# Approach\\nUse a set to count unique characters.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)\\n\\n- Space complexity:\\n$$O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string& s) {\\n        unordered_set<char> t(s.begin(), s.end());\\n        return t.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string& s) {\\n        unordered_set<char> t(s.begin(), s.end());\\n        return t.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844318,
                "title": "c-easy-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> ump;\\n        for(auto i : s) ump[i]++;\\n        \\n        int extra = 0;\\n        for(auto i : ump) {\\n            if(i.second > 1) extra += i.second - 1;\\n        }\\n        return s.size() - extra;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> ump;\\n        for(auto i : s) ump[i]++;\\n        \\n        int extra = 0;\\n        for(auto i : ump) {\\n            if(i.second > 1) extra += i.second - 1;\\n        }\\n        return s.size() - extra;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1916536,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916041,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916139,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916884,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2069258,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2054998,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1980052,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1975797,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1931513,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1921418,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916536,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916041,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916139,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916884,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2069258,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2054998,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1980052,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1975797,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1931513,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1921418,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Semi-Ordered Permutation",
        "question_content": "<p>You are given a <strong>0-indexed</strong> permutation of <code>n</code> integers <code>nums</code>.</p>\n\n<p>A permutation is called <strong>semi-ordered</strong> if the first number equals <code>1</code> and the last number equals <code>n</code>. You can perform the below operation as many times as you want until you make <code>nums</code> a <strong>semi-ordered</strong> permutation:</p>\n\n<ul>\n\t<li>Pick two adjacent elements in <code>nums</code>, then swap them.</li>\n</ul>\n\n<p>Return <em>the minimum number of operations to make </em><code>nums</code><em> a <strong>semi-ordered permutation</strong></em>.</p>\n\n<p>A <strong>permutation</strong> is a sequence of integers from <code>1</code> to <code>n</code> of length <code>n</code> containing each number exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,4,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can make the permutation semi-ordered using these sequence of operations: \n1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than two operations that make nums a semi-ordered permutation. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,1,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can make the permutation semi-ordered using these sequence of operations:\n1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3].\n2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than three operations that make nums a semi-ordered permutation.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,4,2,5]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The permutation is already a semi-ordered permutation.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length == n &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i]&nbsp;&lt;= 50</code></li>\n\t<li><code>nums is a permutation.</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3595297,
                "title": "java-c-python-index-of-1-and-n",
                "content": "# **Explanation**\\nIf index of `1` is `i`,\\n`1` needs `i` swaps to be the first.\\n\\nIf index of `n` is `j`,\\n`n` needs `n - 1 - j` swaps to be the first.\\n\\nIf `i < j`,\\n`res` is `i + (n - 1 - j)`.\\n\\nIf `i > j`,\\n`res` is `i + (n - 1 - j) - 1`,\\nsave one swap when swap `1` and `n`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int semiOrderedPermutation(int[] A) {\\n        int n = A.length, i = 0, j = 0;\\n        for (int k = 0; k < n; k++) {\\n            if (A[k] == 1) i = k;\\n            if (A[k] == A.length) j = k;\\n        }\\n        return i + n - 1 - j - (i > j ? 1 : 0);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size(), i = find(A.begin(), A.end(), 1) - A.begin(), j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def semiOrderedPermutation(self, A: List[int]) -> int:\\n        n = len(A)\\n        i, j = A.index(1), A.index(n)\\n        return i + n - 1 - j - (i > j)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int semiOrderedPermutation(int[] A) {\\n        int n = A.length, i = 0, j = 0;\\n        for (int k = 0; k < n; k++) {\\n            if (A[k] == 1) i = k;\\n            if (A[k] == A.length) j = k;\\n        }\\n        return i + n - 1 - j - (i > j ? 1 : 0);\\n    }\\n```\n```cpp\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size(), i = find(A.begin(), A.end(), 1) - A.begin(), j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n```\n```py\\n    def semiOrderedPermutation(self, A: List[int]) -> int:\\n        n = len(A)\\n        i, j = A.index(1), A.index(n)\\n        return i + n - 1 - j - (i > j)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3595215,
                "title": "explained-iteration-very-simple-and-easy-to-understand",
                "content": "## Approach\\n1. Find the ith index of min val 1 => we need to do i operation to move 1 to first position\\n2. Find the ith index of the max val n => we need to do (n - i - 1) operation to take it to last position\\n3. Take the sum of above two as the answer. Only corner case is when the ith index of 1 is larger than ith index of n - in this case we need to reduce the ans by 1 as the 1 & n cna be swapped at the same time so that we count it as 1 operation in place of 2.\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int imin = 0, imax = nums.size(), n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] == 1) imin = i;\\n            if(nums[i] == n) imax = i;\\n        }\\n        if(imin < imax) return (imin + n - imax - 1);\\n        return (imin + n - imax - 1) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int imin = 0, imax = nums.size(), n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] == 1) imin = i;\\n            if(nums[i] == n) imax = i;\\n        }\\n        if(imin < imax) return (imin + n - imax - 1);\\n        return (imin + n - imax - 1) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594901,
                "title": "find-positions",
                "content": "**C++**\\n```cpp\\nint semiOrderedPermutation(vector<int>& n) {\\n    int first = find(begin(n), end(n), 1) - begin(n);\\n    int last = find(begin(n), end(n), n.size()) - begin(n);\\n    return first + (n.size() - last - 1) - (first > last);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint semiOrderedPermutation(vector<int>& n) {\\n    int first = find(begin(n), end(n), 1) - begin(n);\\n    int last = find(begin(n), end(n), n.size()) - begin(n);\\n    return first + (n.size() - last - 1) - (first > last);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594970,
                "title": "long-but-easy-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function (nums) {\\n    const n = nums.length\\n    if (nums[0] === 1 && nums[n - 1] === n) return 0\\n    \\n    let cn = 0\\n    \\n    let i = nums.indexOf(1)\\n    while (nums[0] !== 1 && i >= 0) {\\n        const curr = nums[i - 1]\\n        \\n        nums[i - 1] = nums[i]\\n        nums[i] = curr\\n        \\n        i -= 1\\n        cn += 1\\n    }\\n    \\n    if (nums[0] === 1 && nums[n - 1] === n) return cn\\n    i = nums.indexOf(n)\\n    while (nums[n - 1] !== n && i < n) {\\n        const curr = nums[i]\\n        \\n        nums[i] = nums[i + 1]\\n        nums[i + 1] = curr\\n        \\n        i += 1\\n        cn += 1\\n    }\\n    \\n    return cn\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function (nums) {\\n    const n = nums.length\\n    if (nums[0] === 1 && nums[n - 1] === n) return 0\\n    \\n    let cn = 0\\n    \\n    let i = nums.indexOf(1)\\n    while (nums[0] !== 1 && i >= 0) {\\n        const curr = nums[i - 1]\\n        \\n        nums[i - 1] = nums[i]\\n        nums[i] = curr\\n        \\n        i -= 1\\n        cn += 1\\n    }\\n    \\n    if (nums[0] === 1 && nums[n - 1] === n) return cn\\n    i = nums.indexOf(n)\\n    while (nums[n - 1] !== n && i < n) {\\n        const curr = nums[i]\\n        \\n        nums[i] = nums[i + 1]\\n        nums[i + 1] = curr\\n        \\n        i += 1\\n        cn += 1\\n    }\\n    \\n    return cn\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597749,
                "title": "python-3-2-lines-w-brief-explanation-t-m-96-97",
                "content": "We first determine the indices `mn`and`mx`of two numbers being migrated to the ends of the list. Second, we count the number of steps required to move each, which are`mn`and`n-mx-1`. We check whether`mn > mx`, in which casethe two migrations share a step and we then correct by decrementing the sum by one. We return this sum.\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        mn, mx = nums.index(1) , nums.index(n:= len(nums))     \\n        return mn - mx + n - 1 - (mn > mx)\\n```\\n[https://leetcode.com/problems/semi-ordered-permutation/submissions/991660777/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        mn, mx = nums.index(1) , nums.index(n:= len(nums))     \\n        return mn - mx + n - 1 - (mn > mx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595007,
                "title": "java-easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int semiOrderedPermutation(int[] nums) {\\n    int n = nums.length, a = 0, b = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (nums[i] == 1) a = i;\\n      if (nums[i] == n) b = i;\\n    }\\n    return a + (n-1-b) - (a > b ? 1 : 0);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n  public int semiOrderedPermutation(int[] nums) {\\n    int n = nums.length, a = 0, b = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (nums[i] == 1) a = i;\\n      if (nums[i] == n) b = i;\\n    }\\n    return a + (n-1-b) - (a > b ? 1 : 0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595866,
                "title": "get-index-of-1-n-c",
                "content": "get index 1 and n\\na = index of 1;\\nb = index of n\\nif(index of 1 < index of n)\\n    than return a+n-1-b;\\nelse return a+n-1-b-n//there is we substracte previous ans by 1 because here one case is possible that we swap(1,n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int a,b,i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(nums[i]==1)a = i;\\n            else if(nums[i]==n)b = i;\\n        }\\n        if(a<b){\\n            return a+n-1-b;\\n        }else{\\n            return a+n-1-b-1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int a,b,i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(nums[i]==1)a = i;\\n            else if(nums[i]==n)b = i;\\n        }\\n        if(a<b){\\n            return a+n-1-b;\\n        }else{\\n            return a+n-1-b-1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594930,
                "title": "find-c",
                "content": "# Intuition\\n**Find Position of ```1``` and ```n```**\\n**```Result = ind_one + (n - ind_n + 1)```** (Calculating Swaps)\\n**But if ind_one is on left of ind_n, it means you one swap operation will be common for both i.e ```swap(1, n)``` so will do ```Result - 1```**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int ind_One = find(nums.begin(), nums.end(), 1) - nums.begin(), ind_N = find(nums.begin(), nums.end(), n) - nums.begin();\\n        int Result = ind_One + n - (ind_N + 1);\\n        if(ind_One > ind_N)    // One on left of N\\n            return Result - 1;\\n        return Result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```1```\n```n```\n```Result = ind_one + (n - ind_n + 1)```\n```swap(1, n)```\n```Result - 1```\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int ind_One = find(nums.begin(), nums.end(), 1) - nums.begin(), ind_N = find(nums.begin(), nums.end(), n) - nums.begin();\\n        int Result = ind_One + n - (ind_N + 1);\\n        if(ind_One > ind_N)    // One on left of N\\n            return Result - 1;\\n        return Result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597044,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)\\n        j=nums.index(n)\\n        ans=i+n-1-j-(i>j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)\\n        j=nums.index(n)\\n        ans=i+n-1-j-(i>j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595606,
                "title": "c-easy-o-n-solution-w-intuition-code-finding-index",
                "content": "# Intuition\\nMy intuition for this problem was to know the number of swaps to change the position of a number. Our task is to move the smallest number to the start and the largest number to the end of the array.\\nTo move a number from index `i=5` to `j=0`, we need `i-j` swaps. So to move the minimum number from any index to the `0th index` we need as many number of swaps as the index of the min. number.\\nNow we need `n-1-i` swaps to move the largest number(positioned at $$i^{th}$$ index) to the `n-1 index` but there\\'s a catch if we do this after moving the min number.\\n\\nWe need to consider the fact that the largest number can come before the smallest number and that moving the smallest number has moved the largest number towards it\\'s desired location. So if the largest number\\'s index comes before the minimum number\\'s index, we use `n-1-i - 1` to indicate that it has to do one less swap itself. \\n\\n# Approach\\nThe approach is simple, we just find:\\n- index of minimum number `minIdx`\\n- index of maximum number `maxIdx`\\n\\nAnd use what we derived above:\\n- Swaps for moving minimum number, `smin`: `minIdx`\\n- Swaps for moving maximum number, `smax`: \\n1. `n-1-maxIdx` if `minIdx<maxIdx`\\n2. `n-1-maxIdx - 1` if `minIdx>maxIdx`\\n\\nSo,  Total number of swaps (our answer): `smin + smax`\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int minIdx{0};\\n        int maxIdx{0};\\n        for(int i=0; i<nums.size(); i++) {\\n            if (nums[i] < nums[minIdx])\\n                minIdx = i;\\n            if (nums[i] > nums[maxIdx])\\n                maxIdx = i;\\n        }\\n        int res{0};\\n        res += minIdx;\\n        res += nums.size()-1-maxIdx-(maxIdx<minIdx);\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nBecause we\\'re traversing the array once to find the indices of the minimum and the maximum number.\\n- Space complexity: $$O(1)$$\\n\\n\\n> ### Note\\n> - Upvote if you liked my solution\\n> - Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int minIdx{0};\\n        int maxIdx{0};\\n        for(int i=0; i<nums.size(); i++) {\\n            if (nums[i] < nums[minIdx])\\n                minIdx = i;\\n            if (nums[i] > nums[maxIdx])\\n                maxIdx = i;\\n        }\\n        int res{0};\\n        res += minIdx;\\n        res += nums.size()-1-maxIdx-(maxIdx<minIdx);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595196,
                "title": "python-3-easy-solution-compare-min-and-max-index",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\\n            return 0\\n        \\n        op = 0\\n        min_idx = nums.index(min(nums))\\n        max_idx = nums.index(max(nums))\\n        if min_idx < max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx)\\n        if min_idx > max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\\n        \\n        return op\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\\n            return 0\\n        \\n        op = 0\\n        min_idx = nums.index(min(nums))\\n        max_idx = nums.index(max(nums))\\n        if min_idx < max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx)\\n        if min_idx > max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\\n        \\n        return op\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872501,
                "title": "java-beginner-friendly-solution-100-beats-fully-explained",
                "content": "# Approach\\n\\nTo convert the given permutation `nums` into a semi-ordered permutation, we need to perform swaps to move the number `1` to the first position and the number `n` to the last position. We can achieve this by finding the indices of `1` and `n` in the array and then calculating the number of operations required to move `1` to the first position and `n` to the last position.\\n\\n**Logic:**\\n1. Initialize two variables `count` and `idx` to keep track of the number of operations and the index of `1` in the array, respectively.\\n2. Loop through the array to find the index of the number `1`. Set `idx` to this index.\\n3. Calculate the number of operations required to move `1` to the first position. Set `count` to `idx`.\\n4. While the number at the first position is not `1`, swap the elements at indices `idx` and `idx-1` to move `1` towards the first position. Decrement `idx` by 1 after each swap.\\n5. Loop through the array again to find the index of the number `n`. Set `idx` to this index.\\n6. Calculate the number of operations required to move `n` to the last position. Return `count + n - idx - 1`, which represents the total number of operations needed to make `nums` a semi-ordered permutation.\\n\\n**Pseudocode:**\\n```plaintext\\nFunction semiOrderedPermutation(nums):\\n    n = length of nums\\n    count = 0\\n    idx = 0\\n    \\n    # Find the index of 1 in nums\\n    for i = 0 to n-1:\\n        if nums[i] == 1:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move 1 to the first position\\n    count = idx\\n    \\n    # Move 1 to the first position using swaps\\n    while nums[0] != 1:\\n        swap nums[idx] and nums[idx-1]\\n        idx = idx - 1\\n    \\n    # Find the index of n in nums\\n    for i = 0 to n-1:\\n        if nums[i] == n:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move n to the last position\\n    return count + n - idx - 1\\n```\\n\\n**Final Remarks:**\\nThe provided solution follows the above approach and logic to solve the problem. It efficiently moves the number `1` to the first position and the number `n` to the last position, minimizing the number of swaps needed. The solution is clear and concise, making it easy for beginners to understand and implement.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        int idx = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        count = idx;\\n\\n        while (nums[0] != 1) {\\n            nums[idx] = nums[idx - 1];\\n            nums[idx - 1] = 1;\\n            idx--;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == n) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        return count + n - idx - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Simulation"
                ],
                "code": "```plaintext\\nFunction semiOrderedPermutation(nums):\\n    n = length of nums\\n    count = 0\\n    idx = 0\\n    \\n    # Find the index of 1 in nums\\n    for i = 0 to n-1:\\n        if nums[i] == 1:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move 1 to the first position\\n    count = idx\\n    \\n    # Move 1 to the first position using swaps\\n    while nums[0] != 1:\\n        swap nums[idx] and nums[idx-1]\\n        idx = idx - 1\\n    \\n    # Find the index of n in nums\\n    for i = 0 to n-1:\\n        if nums[i] == n:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move n to the last position\\n    return count + n - idx - 1\\n```\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        int idx = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        count = idx;\\n\\n        while (nums[0] != 1) {\\n            nums[idx] = nums[idx - 1];\\n            nums[idx - 1] = 1;\\n            idx--;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == n) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        return count + n - idx - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606110,
                "title": "c-java-determining-the-positions-of-1-and-n",
                "content": "\\nDetermine the locations of `1` and `N`, labelled as `one_index` and `n_index` respectively. The number of swaps needed to reposition `1` at the start is equivalent to `one_index`, and similarly, to move `N` to the final position, `N - 1 - n_index` swaps are required. \\n\\nHowever, should `1` be located to the right of `N`, then as `1` is moved towards the 0th position, it would swap places with `N`, thereby bringing `N` a step closer to its desired final position. This would therefore require one less swap, i.e., `N - 1 - n_index - 1` to relocate `N` to the end. Consequently, if `1` is to the right of `N`, we need to subtract 1 from the total swap count.\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int one_index = 0, n_index = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) one_index = i;\\n            else if (nums[i] == n) n_index = i;\\n        }\\n        return one_index + n - 1 - n_index - (one_index < n_index ? 0 : 1);\\n    }\\n};\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = 0, nIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) oneIndex = i;\\n            else if (nums[i] == n) nIndex = i;\\n        }\\n        return oneIndex + n - 1 - nIndex - (oneIndex < nIndex ? 0 : 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int one_index = 0, n_index = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) one_index = i;\\n            else if (nums[i] == n) n_index = i;\\n        }\\n        return one_index + n - 1 - n_index - (one_index < n_index ? 0 : 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = 0, nIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) oneIndex = i;\\n            else if (nums[i] == n) nIndex = i;\\n        }\\n        return oneIndex + n - 1 - nIndex - (oneIndex < nIndex ? 0 : 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600932,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the position of 1 and the n in the nums which will take o(n)\\ni have used find but simple iteration can also be done to find the pos of both the elements \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the pos of both the element using simple iteration or find \\n2. Their are only two case which we have to see now \\n             i.pos_1 < pos_2\\n             ii. pos_1 > pos_2\\n3. For case i we simple add the no of swaps need for both the element to reach their respective position \\n4. for case ii we do the same as for case i but subtract 1 from it as when we were swaping elements for 1 as the pos_2 < pos_1 then the n element must have shifted by one toward its destination so -1 to the ans\\n# Complexity\\n- Time complexity:\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int pos_1 = find(nums.begin(),nums.end(),1) - nums.begin();\\n        int pos_2 = find(nums.begin(),nums.end(),n) - nums.begin();\\n        return (pos_1<pos_2) ?(pos_1 +  n-1-pos_2):(pos_1 + (n-1 - pos_2) - (1));\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int pos_1 = find(nums.begin(),nums.end(),1) - nums.begin();\\n        int pos_2 = find(nums.begin(),nums.end(),n) - nums.begin();\\n        return (pos_1<pos_2) ?(pos_1 +  n-1-pos_2):(pos_1 + (n-1 - pos_2) - (1));\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599250,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int mini=0;\\n        int maxi=0;\\n        int n=nums.size();\\n        for(int i=0 ; i < n ; i++){\\n            if(nums[i]==1){\\n                mini=i;\\n            }\\n            else if(nums[i]==n){\\n                maxi=i;\\n            }\\n        }\\n        if(mini>maxi){\\n            maxi=(n-1)-(maxi+1);\\n        }\\n        else{\\n            maxi=(n-1)-maxi;\\n        }\\n        return mini+maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int mini=0;\\n        int maxi=0;\\n        int n=nums.size();\\n        for(int i=0 ; i < n ; i++){\\n            if(nums[i]==1){\\n                mini=i;\\n            }\\n            else if(nums[i]==n){\\n                maxi=i;\\n            }\\n        }\\n        if(mini>maxi){\\n            maxi=(n-1)-(maxi+1);\\n        }\\n        else{\\n            maxi=(n-1)-maxi;\\n        }\\n        return mini+maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595395,
                "title": "simple-java-o-n-solution",
                "content": "# Approach\\n- Get the index of 1 and N\\n- Number of swaps would be sum of difference between index of 1 and 0 and difference between index of N and last index.\\n- If position of N is before 1, then we require 1 less swap\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int indexOne = -1;\\n        int indexN = -1;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 1)\\n                indexOne = i;\\n            if(nums[i] == nums.length)\\n                indexN = i;\\n        }\\n        \\n        int count = 0;\\n        if(indexOne > indexN)\\n            count--;\\n        \\n        count += indexOne + (nums.length - 1 - indexN);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int indexOne = -1;\\n        int indexN = -1;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 1)\\n                indexOne = i;\\n            if(nums[i] == nums.length)\\n                indexN = i;\\n        }\\n        \\n        int count = 0;\\n        if(indexOne > indexN)\\n            count--;\\n        \\n        count += indexOne + (nums.length - 1 - indexN);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595158,
                "title": "o-n-very-easy-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Just find the idex of 1 and the index of maximum number. \\n    If the index of 1 > index of max number, it will take one swap less \\n    if(idx1>idx){\\n        idx1=idx1-1;\\n        }\\n    The answer will be (nums.length-1-idx) + idx1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        int idx=0,idx1=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n                idx=i;\\n            }\\n            if(nums[i]==1){\\n                idx1=i;\\n            }\\n        }\\n        if(idx1>idx){\\n            idx1=idx1-1;\\n        }\\n        return (nums.length-1-idx) + idx1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        int idx=0,idx1=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n                idx=i;\\n            }\\n            if(nums[i]==1){\\n                idx1=i;\\n            }\\n        }\\n        if(idx1>idx){\\n            idx1=idx1-1;\\n        }\\n        return (nums.length-1-idx) + idx1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594957,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int opr = 0, j = 0;\\n//         finding 1\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == 1)    j = i;\\n//         operating 1 to start index\\n        while(j > 0){\\n            nums[j] = nums[j-1];\\n            nums[j-1] = 1;\\n            opr++;\\n            j--;\\n        }\\n//         finding n\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == nums.length)    j = i;\\n//         operating n to last index\\n        while(j < nums.length-1){\\n            nums[j] = nums[j+1];\\n            nums[j+1] = nums.length;\\n            opr++;\\n            j++;\\n        }   \\n        return opr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int opr = 0, j = 0;\\n//         finding 1\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == 1)    j = i;\\n//         operating 1 to start index\\n        while(j > 0){\\n            nums[j] = nums[j-1];\\n            nums[j-1] = 1;\\n            opr++;\\n            j--;\\n        }\\n//         finding n\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == nums.length)    j = i;\\n//         operating n to last index\\n        while(j < nums.length-1){\\n            nums[j] = nums[j+1];\\n            nums[j+1] = nums.length;\\n            opr++;\\n            j++;\\n        }   \\n        return opr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909979,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the given 0-indexed array, we are allowed to perform swap on any two adjacent elements unit we make array nums a semi-ordered permutation.\\nwe can perform swap on element valued 1 till it reaches index 0.\\nSimilarly, we perform swap on element valued n (which is also the size of the array nums) till it reaches the last index that is (n-1).\\nWe return the number of swaps required in this process.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int cnt=0;\\n        bool f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                       swap(nums[i],nums[i+1]);\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                       swap(nums[i], nums[i-1]);\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int cnt=0;\\n        bool f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                       swap(nums[i],nums[i+1]);\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                       swap(nums[i], nums[i-1]);\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672706,
                "title": "2-c-solutions-beginner-friendly-approach-with-and-without-vector-find",
                "content": "\\n# Code\\n```\\n// Soution 1 (With find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size();\\n        int i = find(A.begin(), A.end(), 1) - A.begin(); \\n        int j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n}\\n\\n// Solution 2 (Without find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size(), count=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1){\\n                count+=i;\\n                for(int j=i; j>0; j--)\\n                    swap(nums[j], nums[j-1]); // we swap the numbers so that the later considering the case when 1 comes after n-1 because count will get repeated for such cases\\n                break;\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==n){ \\n                count+=(n-1)-i;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Soution 1 (With find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size();\\n        int i = find(A.begin(), A.end(), 1) - A.begin(); \\n        int j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n}\\n\\n// Solution 2 (Without find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size(), count=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1){\\n                count+=i;\\n                for(int j=i; j>0; j--)\\n                    swap(nums[j], nums[j-1]); // we swap the numbers so that the later considering the case when 1 comes after n-1 because count will get repeated for such cases\\n                break;\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==n){ \\n                count+=(n-1)-i;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672586,
                "title": "simple-code-c",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int start,end;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] == 1)\\n                start = i;\\n            if(nums[i] == n)\\n                end = i;\\n        }\\n        if(start > end)\\n            return start + n - end - 2;\\n        else \\n            return start + n - end-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int start,end;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] == 1)\\n                start = i;\\n            if(nums[i] == n)\\n                end = i;\\n        }\\n        if(start > end)\\n            return start + n - end - 2;\\n        else \\n            return start + n - end-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672114,
                "title": "c-2-pointer-solution-7ms-46-3mb",
                "content": "For this problem we have to just find the indexes of `1` and the value matching length of `nums`, then check how far they are from being in the first and in the last position - with a caveat: if the first position is `>` than the last one, when we start swapping one of the indexes we will put the latter closer to its position, so we need to take that into account.\\n\\nNow, to code our solution, let\\'s start with declaring our support variables:\\n* `len` will store the length of `nums`;\\n* `p1` and `p2` will be where we store the positions of the values `1` and `len` respectively, both initially set to be `-1`.\\n\\nWe will then loop with `i` across all the positions in `nums` until we have found both pointers (ie: `p1 == -1 || p2 == -1`) and:\\n* store `nums[i]` in `n`;\\n* if `n == 1`, we will set `p1` to be `i`;\\n* otherwise, if `n == len`, we will set `p2` to be `i`.\\n\\nOnce done, we will `return` the sum of the distances of `p1` from the first position (ie: `p1 - 0`) and `p2` from the last position (ie: `len - p2 - 1`), adjusted by `-1` as we mentioned in our incipit if `p1 > p2`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), p1 = -1, p2 = -1;\\n        // parsing nums\\n        for (int i = 0, n; p1 == -1 || p2 == -1; i++) {\\n            n = nums[i];\\n            if (n == 1) p1 = i;\\n            else if (n == len) p2 = i;\\n        }\\n        return (p1 > p2 ? -1 : 0) + p1 + len - p2 - 1;\\n    }\\n};\\n```\\n\\nAlternative version of that logic, working directly with a variable result `res` and a boolean flag `foundOne` to check if we had already found the other index before. Notice that now we need to do one less check at each loop iteration and that we use `foundOne` in the `else if` clause to decrease the value of `res` by `1` if we had found `1` before `len`; overall, this version seemed to perform a bit better:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), res = 0;\\n        bool foundOne = false;\\n        // parsing nums\\n        for (int i = 0, n; ; i++) {\\n            n = nums[i];\\n            if (n == 1) {\\n                res += i;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n            else if (n == len) {\\n                res += len - i - 1 - !foundOne;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), p1 = -1, p2 = -1;\\n        // parsing nums\\n        for (int i = 0, n; p1 == -1 || p2 == -1; i++) {\\n            n = nums[i];\\n            if (n == 1) p1 = i;\\n            else if (n == len) p2 = i;\\n        }\\n        return (p1 > p2 ? -1 : 0) + p1 + len - p2 - 1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), res = 0;\\n        bool foundOne = false;\\n        // parsing nums\\n        for (int i = 0, n; ; i++) {\\n            n = nums[i];\\n            if (n == 1) {\\n                res += i;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n            else if (n == len) {\\n                res += len - i - 1 - !foundOne;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626499,
                "title": "simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n        for (int x = 0; x<n; x++) {\\n            if (nums[x] == 1) i = x;\\n            if (nums[x] == n) j = x;\\n        }\\n\\n        if (j < i) return i + n-j-2;\\n        return i + n-j-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n        for (int x = 0; x<n; x++) {\\n            if (nums[x] == 1) i = x;\\n            if (nums[x] == n) j = x;\\n        }\\n\\n        if (j < i) return i + n-j-2;\\n        return i + n-j-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624244,
                "title": "formula-based-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int mx=0, mxidx=0;\\n        int mn=INT_MAX, mnidx;\\n        int count=0;\\n\\n        for(int i=0; i<n; i++){\\n            mx=max(mx, nums[i]);\\n            if(nums[i]==mx) mxidx=i;\\n\\n            mn=min(mn, nums[i]);\\n            if(nums[i]==mn) mnidx=i;\\n        }\\n        \\n        count=n+mnidx-mxidx-1;\\n        if(mnidx<mxidx) return count;\\n        return --count;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int mx=0, mxidx=0;\\n        int mn=INT_MAX, mnidx;\\n        int count=0;\\n\\n        for(int i=0; i<n; i++){\\n            mx=max(mx, nums[i]);\\n            if(nums[i]==mx) mxidx=i;\\n\\n            mn=min(mn, nums[i]);\\n            if(nums[i]==mn) mnidx=i;\\n        }\\n        \\n        count=n+mnidx-mxidx-1;\\n        if(mnidx<mxidx) return count;\\n        return --count;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600574,
                "title": "super-easy-solution-with-simple-logic-store-positions",
                "content": "# Intuition\\nSince we have to swap adjacent numbers to fulfil the given condition ,we will store the psoiton of 1 and the last number by iterating through loop. After the answer will be total number of swaps,hence we will add the number of swaps with the help of their positions.\\nBut if the last number i.e. n is present before the number 1 both of the them reach their destinantion simultaneously ,hence we will decrease the answer by 1.\\n\\n# Approach\\n- We will store the two psoitons in variables f and l.\\n- We will store the answer i.e. total number of swaps in variable\\n```\\nint ans=f+(n-1-l);\\n```\\n- We will check for the condition (mentioned in Intuiton above) and decrement answer by 1 if it is there.\\n```\\nif(l<f)\\n{\\n    ans=ans-1;\\n}\\n```\\n- Return the answer.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:It will be O(n) because of for loop.\\n\\n\\n- Space complexity:It wil be O(1) .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int f=0,l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                f=i;\\n            }\\n            if(nums[i]==n)\\n            {\\n                l=i;\\n            }\\n        }\\n        int ans=f+(n-1-l);\\n        if(l<f)\\n        {\\n            ans=ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if it helps!",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nint ans=f+(n-1-l);\\n```\n```\\nif(l<f)\\n{\\n    ans=ans-1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int f=0,l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                f=i;\\n            }\\n            if(nums[i]==n)\\n            {\\n                l=i;\\n            }\\n        }\\n        int ans=f+(n-1-l);\\n        if(l<f)\\n        {\\n            ans=ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597605,
                "title": "java-solution-beats-100-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int semiOrder(int nums[], int count) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length) {\\n            return count;\\n        }\\n        else if(nums[0]==1) {\\n            for(int i=0; i<nums.length-1; i++) {\\n                if(nums[i]==nums.length) {\\n                    nums[i]=nums[i+1];\\n                    nums[i+1]=nums.length;\\n                    break;\\n                }\\n            }\\n        }\\n        else {\\n            for(int i=1; i<nums.length; i++) {\\n                if(nums[i]==1) {\\n                    nums[i]=nums[i-1];\\n                    nums[i-1]=1;\\n                    break;\\n                }\\n            }\\n        }\\n        return semiOrder(nums,count+1);\\n    }\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        return semiOrder(nums, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int semiOrder(int nums[], int count) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length) {\\n            return count;\\n        }\\n        else if(nums[0]==1) {\\n            for(int i=0; i<nums.length-1; i++) {\\n                if(nums[i]==nums.length) {\\n                    nums[i]=nums[i+1];\\n                    nums[i+1]=nums.length;\\n                    break;\\n                }\\n            }\\n        }\\n        else {\\n            for(int i=1; i<nums.length; i++) {\\n                if(nums[i]==1) {\\n                    nums[i]=nums[i-1];\\n                    nums[i-1]=1;\\n                    break;\\n                }\\n            }\\n        }\\n        return semiOrder(nums,count+1);\\n    }\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        return semiOrder(nums, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596789,
                "title": "easiest-implementation",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx1,idxN;\\n        for(int i=0 ; i<n ; i++) {\\n            if(nums[i] == 1) idx1 = i;\\n            if(nums[i] == n) idxN = i;\\n        }\\n        \\n        int ans = idx1 + n-1-idxN;\\n        if(idxN < idx1) ans--; // one common swap\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx1,idxN;\\n        for(int i=0 ; i<n ; i++) {\\n            if(nums[i] == 1) idx1 = i;\\n            if(nums[i] == n) idxN = i;\\n        }\\n        \\n        int ans = idx1 + n-1-idxN;\\n        if(idxN < idx1) ans--; // one common swap\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596433,
                "title": "step-by-step-explanation-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**We just need to find the index of both the elements min element=1\\nand maxelement=nums.size();**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# There are two cases only\\n1. If location of max element  is right to location of minimum  element like **[2,3,1,7,6,5,4]** *here 7 is at right of 1*\\nin this case answer is **n-maxIndex+minindex** i.e \\n**Index of 7 is 3 index of 1 is 2 and n=6 (last index of array)**\\n    6-3+2=5\\n\\n\\n2. If location of max is left of location of minimum like **[2,3,7,4,5,1,6]**\\nin this case answer is **n-maxIndex+minIndex-1** i.e \\n**Index of 7 is 2 index of 1 is 5 and n=6 (last index of array)**\\n 6-2+5-1=8\\n\\n### here 1 is subtracted because when we swap max element with elements to put it at right place it will be swapped once with min elelment\\n**[2,3,7,4,5,1,6]**\\nhere ist swap **[2,3,4,7,5,1,6]**\\nhere 2nd swap **[2,3,4,5,7,1,6]**\\nhere 3rd swap **[2,3,4,5,1,7,6]**\\n**Now look here the minimum element is changing it\\'s postion\\nSo -1 is done to count this** \\n\\n\\n\\n\\n**Here 7 is max element\\n 1 is min element**\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$  Constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n               int min=-1,max=-1,ans;\\n               int n=nums.size()-1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==1)\\n                        {\\n                min=i;\\n                        } //if\\n            if(nums[i]==nums.size())\\n                       {\\n                        max=i;\\n                            }//if\\n                \\n        if(min!=-1&&max!=-1){break;}//to break the loop \\n        }//for\\n        ans=min+(n-max);\\n        if(max<min) \\n             {\\n             return ans-1;\\n             }\\n    \\n     return ans; \\n        \\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max = Arrays.stream(nums).max().getAsInt();\\n        int indexMin=0;\\n        int indexMax=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indexMin=i;\\n            }\\n            if(nums[i]==max){\\n                indexMax=i;\\n            }\\n        }\\n        if(indexMax<indexMin){\\n            return indexMin + nums.length-1 -indexMax-1;\\n        }\\n        else{\\n            return indexMin + nums.length-1 -indexMax;\\n        }\\n        \\n    }\\n}\\n```\\n# UPVOTE IF IT\\'S HELPFUL\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n               int min=-1,max=-1,ans;\\n               int n=nums.size()-1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==1)\\n                        {\\n                min=i;\\n                        } //if\\n            if(nums[i]==nums.size())\\n                       {\\n                        max=i;\\n                            }//if\\n                \\n        if(min!=-1&&max!=-1){break;}//to break the loop \\n        }//for\\n        ans=min+(n-max);\\n        if(max<min) \\n             {\\n             return ans-1;\\n             }\\n    \\n     return ans; \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max = Arrays.stream(nums).max().getAsInt();\\n        int indexMin=0;\\n        int indexMax=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indexMin=i;\\n            }\\n            if(nums[i]==max){\\n                indexMax=i;\\n            }\\n        }\\n        if(indexMax<indexMin){\\n            return indexMin + nums.length-1 -indexMax-1;\\n        }\\n        else{\\n            return indexMin + nums.length-1 -indexMax;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596035,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        a=nums.index(min(nums))\\n        b=nums.index(max(nums))\\n        if b<a:\\n            return a+(len(nums)-1-b)-1\\n        else:\\n            return a+(len(nums)-1-b)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        a=nums.index(min(nums))\\n        b=nums.index(max(nums))\\n        if b<a:\\n            return a+(len(nums)-1-b)-1\\n        else:\\n            return a+(len(nums)-1-b)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595718,
                "title": "c-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int l = 0 , r = n - 1;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(nums[i] == 1) l = i;\\n\\n            if(nums[i] == n) r = i; \\n        }\\n\\n        if(r < l){\\n            return l + (n-1-r) - 1;\\n        }\\n\\n        return l + (n-1-r);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int l = 0 , r = n - 1;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(nums[i] == 1) l = i;\\n\\n            if(nums[i] == n) r = i; \\n        }\\n\\n        if(r < l){\\n            return l + (n-1-r) - 1;\\n        }\\n\\n        return l + (n-1-r);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595687,
                "title": "positions-solution-for-c-explanation-complexity",
                "content": "# Approach\\nThe idea is to find the positions of the element with a value 1 and the element with a value n.\\n* The first position is the number of iterations needed to move an element from its current position to the zero position.\\n* The (nums.length - second position) is the number of iterations needed to move an element from its current position to the last position.\\n\\nThe corner case is when the first position is larger than the second one. So, we use one swap to change both elements at once.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic int SemiOrderedPermutation(int[] nums)\\n{\\n    var leftIndex = -1;\\n    var rightIndex = -1;\\n\\n    // Find positions\\n    for (var i = 0; i < nums.Length; i++)\\n    {\\n        if (nums[i] == 1)\\n        {\\n            leftIndex = i;\\n        }\\n        else if (nums[i] == nums.Length)\\n        {\\n            rightIndex = i;\\n        }\\n        else if (leftIndex != -1 && rightIndex != -1)\\n        {\\n            break;\\n        }\\n    }\\n\\n    // Check if already semi-ordered\\n    if (leftIndex == 0 && rightIndex == nums.Length - 1)\\n    {\\n        return 0;\\n    }\\n\\n    // Calc number of iterations\\n    return leftIndex + (nums.Length - rightIndex - 1) + (leftIndex > rightIndex ? -1 : 0);\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int SemiOrderedPermutation(int[] nums)\\n{\\n    var leftIndex = -1;\\n    var rightIndex = -1;\\n\\n    // Find positions\\n    for (var i = 0; i < nums.Length; i++)\\n    {\\n        if (nums[i] == 1)\\n        {\\n            leftIndex = i;\\n        }\\n        else if (nums[i] == nums.Length)\\n        {\\n            rightIndex = i;\\n        }\\n        else if (leftIndex != -1 && rightIndex != -1)\\n        {\\n            break;\\n        }\\n    }\\n\\n    // Check if already semi-ordered\\n    if (leftIndex == 0 && rightIndex == nums.Length - 1)\\n    {\\n        return 0;\\n    }\\n\\n    // Calc number of iterations\\n    return leftIndex + (nums.Length - rightIndex - 1) + (leftIndex > rightIndex ? -1 : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595436,
                "title": "easy-understanding-with-intuition-and-approach-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI got to reach the solution with the help of some examples\\nYou may understand with the help of:-\\nexample 1: arr1=[2,1,4,3]\\n- first thing to observe is that the position of 1 and n are such that 1 appears before n\\n- we see that we have to swap the elements [((n-1)-position of n)+(position of first-0)]number of times\\n\\nexample 2: arr2=[2,4,1,3]\\n- first thing to observe is that the position of 1 and n are such that 1 appears after n\\n- we see that we have to swap the elements [((n-1)-position of n)+(position of first-0)]number of times\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. store the index of 1 and n\\n2. let us say index of 1 = first and n=last\\n3. the value of ans will be=((n-1)-last)+(first-0)\\n4. check if first > last\\n5. if so then decrease the value of answer(because we can see that we will be swapping once less as there will be a condition when 1 and n will be swapped,so need to count this just once)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& arr) {\\n        int n=arr.size();\\n        int first=-1,last=-1;\\n        //first store the index of 1 and n\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==n)last=i;\\n            if(arr[i]==1)first=i;\\n        }\\n        //now when we observe the solution with a few examples we get to know that there are two cases\\n        int ans=-1;\\n        if(last<first){\\n            ans=((n-1)-last)+(first-0);\\n            ans--;\\n        }\\n        else{\\n            ans=((n-1)-last)+(first-0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& arr) {\\n        int n=arr.size();\\n        int first=-1,last=-1;\\n        //first store the index of 1 and n\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==n)last=i;\\n            if(arr[i]==1)first=i;\\n        }\\n        //now when we observe the solution with a few examples we get to know that there are two cases\\n        int ans=-1;\\n        if(last<first){\\n            ans=((n-1)-last)+(first-0);\\n            ans--;\\n        }\\n        else{\\n            ans=((n-1)-last)+(first-0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595386,
                "title": "python3-solution-find-position",
                "content": "# Intuition\\nFind the position of 1 and n in the nums let say l and r resp., no. of swaps required to make l the first-number is `l` since we need to swap all the elements with 1 from index l to 0, Similarly for n be the last-number we required `n - r - 1` swaps.\\nBut there\\'s a catch if the index of n is less than 1 than we need to `subtract 1` from ans, as 1 swap is counted twice. When 1 and n are adjacent to each other after some operation\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = nums.index(1), nums.index(n)\\n        return l + n - r - 1 - (1 if r < l else 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = nums.index(1), nums.index(n)\\n        return l + n - r - 1 - (1 if r < l else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595368,
                "title": "2-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums.index(len(nums))<nums.index(1):return (len(nums)-1-nums.index(len(nums)))+nums.index(1)-1\\n        else:return (len(nums)-1-nums.index(len(nums)))+nums.index(1)\\n       \\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums.index(len(nums))<nums.index(1):return (len(nums)-1-nums.index(len(nums)))+nums.index(1)-1\\n        else:return (len(nums)-1-nums.index(len(nums)))+nums.index(1)\\n       \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595310,
                "title": "easy-c-solution-observation-based",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(nums[0] == 1 and nums[nums.size() - 1] == nums.size()) {\\n            return 0;\\n        }\\n        \\n        int pos1 = -1;\\n        int pos2 = -1;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == 1) {\\n                pos1 = i;\\n            }\\n            if(nums[i] == n) {\\n                pos2 = i;\\n            }\\n        }\\n        int ans = 0;\\n        if(pos1 < pos2) {\\n           ans = pos1 + (n - 1 - pos2); \\n        }\\n        \\n        if(pos1 > pos2) {\\n            int temp = pos1 - pos2;\\n            pos1 = pos2;\\n            pos2 = pos1 + 1;\\n            \\n            ans = pos1 + (n-1-pos2) + temp;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(nums[0] == 1 and nums[nums.size() - 1] == nums.size()) {\\n            return 0;\\n        }\\n        \\n        int pos1 = -1;\\n        int pos2 = -1;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == 1) {\\n                pos1 = i;\\n            }\\n            if(nums[i] == n) {\\n                pos2 = i;\\n            }\\n        }\\n        int ans = 0;\\n        if(pos1 < pos2) {\\n           ans = pos1 + (n - 1 - pos2); \\n        }\\n        \\n        if(pos1 > pos2) {\\n            int temp = pos1 - pos2;\\n            pos1 = pos2;\\n            pos2 = pos1 + 1;\\n            \\n            ans = pos1 + (n-1-pos2) + temp;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595300,
                "title": "simplest-solution-in-java-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int c=0;\\n        while(nums[0]!=1){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                int t=nums[i];\\n                nums[i]=nums[i-1];\\n                nums[i-1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        while(nums[nums.length-1]!=nums.length){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==nums.length){\\n                int t=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        return c;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int c=0;\\n        while(nums[0]!=1){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                int t=nums[i];\\n                nums[i]=nums[i-1];\\n                nums[i-1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        while(nums[nums.length-1]!=nums.length){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==nums.length){\\n                int t=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        return c;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595277,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx,idx2;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==1) idx=i;\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        int ans=0;\\n        for(int i = idx;i>=0;i--){\\n            if(i==0) break;\\n            swap(nums[i],nums[i-1]);\\n            ans++;\\n        }\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        for(int i = idx2;i<nums.size();i++){\\n            if(i==nums.size()-1) break;\\n            swap(nums[i],nums[i+1]);\\n            ans++;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx,idx2;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==1) idx=i;\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        int ans=0;\\n        for(int i = idx;i>=0;i--){\\n            if(i==0) break;\\n            swap(nums[i],nums[i-1]);\\n            ans++;\\n        }\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        for(int i = idx2;i<nums.size();i++){\\n            if(i==nums.size()-1) break;\\n            swap(nums[i],nums[i+1]);\\n            ans++;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595229,
                "title": "explained-cpp-solution",
                "content": "Certainly! Here\\'s an explanation of the code with comments:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();  // Get the size of the input vector\\n        int s = 0;  // Initialize variable s to store the index of value 1\\n        int e = 0;  // Initialize variable e to store the index of value n\\n\\n        // Loop through each element of the vector\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];  // Get the current element\\n\\n            // Check if the current element is equal to 1 or n\\n            if (val == 1 || val == n) {\\n                if (val == 1) {\\n                    s = i;  // If the element is 1, update s with the current index\\n                } else {\\n                    e = i;  // If the element is n, update e with the current index\\n                }\\n            }\\n        }\\n\\n        int diff = n - e;  // Calculate the difference between n and e\\n        diff--;  // Subtract 1 from diff\\n\\n        int ans = s + diff;  // Calculate ans by adding s and diff\\n\\n        // If s is greater than e, subtract 1 from ans\\n        if (s > e) {\\n            ans--;\\n        }\\n\\n        return ans;  // Return the final ans value\\n    }\\n};\\n```\\n\\nI hope this helps! Let me know if you have any further questions.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();  // Get the size of the input vector\\n        int s = 0;  // Initialize variable s to store the index of value 1\\n        int e = 0;  // Initialize variable e to store the index of value n\\n\\n        // Loop through each element of the vector\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];  // Get the current element\\n\\n            // Check if the current element is equal to 1 or n\\n            if (val == 1 || val == n) {\\n                if (val == 1) {\\n                    s = i;  // If the element is 1, update s with the current index\\n                } else {\\n                    e = i;  // If the element is n, update e with the current index\\n                }\\n            }\\n        }\\n\\n        int diff = n - e;  // Calculate the difference between n and e\\n        diff--;  // Subtract 1 from diff\\n\\n        int ans = s + diff;  // Calculate ans by adding s and diff\\n\\n        // If s is greater than e, subtract 1 from ans\\n        if (s > e) {\\n            ans--;\\n        }\\n\\n        return ans;  // Return the final ans value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595214,
                "title": "semi-order-permutation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        int i=0;\\n        while(i<n){\\n            if(nums[0]==1){\\n                break;\\n            }\\n            if(nums[i]==1&&i!=0){\\n                swap(nums[i],nums[i-1]);\\n                count++;\\n                i--;\\n            }\\n            else i++;\\n        }\\n        int value=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==n)value=i;\\n        }\\n        return count+n-value-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        int i=0;\\n        while(i<n){\\n            if(nums[0]==1){\\n                break;\\n            }\\n            if(nums[i]==1&&i!=0){\\n                swap(nums[i],nums[i-1]);\\n                count++;\\n                i--;\\n            }\\n            else i++;\\n        }\\n        int value=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==n)value=i;\\n        }\\n        return count+n-value-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595139,
                "title": "o-n-approach-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0] == 1 && nums[n-1] == n)\\n            return 0;\\n        int lo = 0, hi = n-1;\\n        for(int i = 0;i  < n; i++){\\n            if(nums[i] == 1){\\n                lo = i;\\n            }\\n            if(nums[i] == n){\\n                hi = i;\\n            }\\n        }\\n        int ans;\\n        if(lo > hi){\\n            ans = lo + abs(n-1-hi-1);\\n        }\\n        else{\\n            ans = lo + abs(n-1-hi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0] == 1 && nums[n-1] == n)\\n            return 0;\\n        int lo = 0, hi = n-1;\\n        for(int i = 0;i  < n; i++){\\n            if(nums[i] == 1){\\n                lo = i;\\n            }\\n            if(nums[i] == n){\\n                hi = i;\\n            }\\n        }\\n        int ans;\\n        if(lo > hi){\\n            ans = lo + abs(n-1-hi-1);\\n        }\\n        else{\\n            ans = lo + abs(n-1-hi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595108,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code works based on the intuition that for a semi-ordered permutation, we need to bring the number 1 to the front of the array and the maximum number to the end. The number of elements between these two positions represents the elements that need to be rearranged. By finding the positions of 1 and the maximum number, the code calculates the answer accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses two pointers, l and r, to keep track of the positions of specific numbers in the array.\\n\\nIt iterates over the elements of the array to find the last occurrences of the numbers 1 and the maximum number.\\n\\nIt calculates the answer by adding the position of the last occurrence of 1 (l) and the number of elements between the right pointer (r) and the end of the array.\\n\\nIf there are duplicate elements between the two pointers (l > r), it adjusts the answer by decrementing it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the size of the input array nums. This is because the code iterates over the array once to find the positions of 1 and the maximum number. The time taken is directly proportional to the size of the input array. Therefore, the time complexity is linear with respect to the input size.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1), as it uses a constant amount of extra space to store the left pointer (l), the right pointer (r), and the answer. The space usage does not depend on the size of the input array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int semiOrderedPermutation(vector<int>& nums) {\\n    int l = 0, r = 0;\\n    for(int i = 0; i < nums.size(); i++) {\\n        if(nums[i] == 1)\\n            l = i; // Update the left pointer if the current number is 1\\n        if(nums[i] == nums.size())\\n            r = i; // Update the right pointer if the current number is equal to the size of the array\\n    }\\n    int ans = l + (nums.size() - 1 - r); // Calculate the answer by adding the left pointer position and the number of elements between the right pointer and the end of the array\\n    if(l > r)\\n        ans--; // Adjust the answer if the left pointer is greater than the right pointer\\n    return ans; // Return the calculated answer\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int semiOrderedPermutation(vector<int>& nums) {\\n    int l = 0, r = 0;\\n    for(int i = 0; i < nums.size(); i++) {\\n        if(nums[i] == 1)\\n            l = i; // Update the left pointer if the current number is 1\\n        if(nums[i] == nums.size())\\n            r = i; // Update the right pointer if the current number is equal to the size of the array\\n    }\\n    int ans = l + (nums.size() - 1 - r); // Calculate the answer by adding the left pointer position and the number of elements between the right pointer and the end of the array\\n    if(l > r)\\n        ans--; // Adjust the answer if the left pointer is greater than the right pointer\\n    return ans; // Return the calculated answer\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595053,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        if(nums[0]==1 && nums[n-1]==n) return 0;\\n        int swaps=0;\\n        int i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) break;\\n        }\\n        for(int x=i; x>=1; x--)\\n        {\\n            swap(nums[x],nums[x-1]);\\n            swaps++;\\n        }\\n        i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==n) break;\\n        }\\n        for(int x=i; x<n-1; x++)\\n        {\\n            swap(nums[x],nums[x+1]);\\n            swaps++;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        if(nums[0]==1 && nums[n-1]==n) return 0;\\n        int swaps=0;\\n        int i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) break;\\n        }\\n        for(int x=i; x>=1; x--)\\n        {\\n            swap(nums[x],nums[x-1]);\\n            swaps++;\\n        }\\n        i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==n) break;\\n        }\\n        for(int x=i; x<n-1; x++)\\n        {\\n            swap(nums[x],nums[x+1]);\\n            swaps++;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595005,
                "title": "easy-java-fast-brute-force",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n int count=0;\\n        if(nums[0]==1&& nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int indst=0;\\n        int indend=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indst =i;\\n            }\\n            if(nums[i]==nums.length){\\n                indend=i;\\n            }\\n        }\\n        if(indst>indend){\\n            count+=indst+(nums.length-2-indend);\\n        }\\n        else{\\n            count+=indst+nums.length-1-indend;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n int count=0;\\n        if(nums[0]==1&& nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int indst=0;\\n        int indend=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indst =i;\\n            }\\n            if(nums[i]==nums.length){\\n                indend=i;\\n            }\\n        }\\n        if(indst>indend){\\n            count+=indst+(nums.length-2-indend);\\n        }\\n        else{\\n            count+=indst+nums.length-1-indend;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594979,
                "title": "index-of-1-and-n-simple-solution-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int first = 0, last = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n           if(nums[i]==1){\\n               first=i;\\n           }\\n            if(nums[i]==n){\\n                last=i;\\n            }\\n        }\\n        int min = 0;\\n        if(first<last)\\n            min = (first + (n-last-1));\\n        else\\n            min = (first + (n-last-2));\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int first = 0, last = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n           if(nums[i]==1){\\n               first=i;\\n           }\\n            if(nums[i]==n){\\n                last=i;\\n            }\\n        }\\n        int min = 0;\\n        if(first<last)\\n            min = (first + (n-last-1));\\n        else\\n            min = (first + (n-last-2));\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594936,
                "title": "c-easy-solution",
                "content": "The given code represents a solution in C++ for the problem of finding the number of operations required to transform a given permutation of integers into a semi-ordered permutation.\\nThe variable n is assigned the size of the nums vector, which represents the length of the permutation.\\n\\nThe variables s and e are initialized to 0. These variables will track the indices of the first occurrence of 1 and the last occurrence of n, respectively\\n\\nAfter the loop, the variable diff is calculated as the difference between the total length of the permutation n and the index of the last occurrence of n e. This represents the number of elements that need to be moved to the left to transform the permutation into a semi-ordered permutation.\\n\\nThe variable diff is decremented by 1 to exclude the element at index e from the count of operations since it is already in its correct position.\\n\\nThe variable ans is calculated by adding the index of the first occurrence of 1 s and the adjusted diff. This represents the final position of the last element in the semi-ordered permutation.\\n\\nIf s is greater than e, it means that the first occurrence of 1 appears after the last occurrence of n. In this case, ans is decremented by 1 to account for this overlap between the two elements.\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n        int s=0;\\n        int e=0;\\n        for (int i = 0 ; i<n;i++){\\n            int val = nums[i];\\n            if(val ==1 ||val==n){\\n                if (val == 1){\\n                    s = i;\\n                }\\n                else {\\n                    e  = i;\\n                }\\n            }\\n        }\\n        int diff = n - e;\\n        diff--;\\n        int ans = s + diff;\\n        if(s>e){\\n            ans--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n        int s=0;\\n        int e=0;\\n        for (int i = 0 ; i<n;i++){\\n            int val = nums[i];\\n            if(val ==1 ||val==n){\\n                if (val == 1){\\n                    s = i;\\n                }\\n                else {\\n                    e  = i;\\n                }\\n            }\\n        }\\n        int diff = n - e;\\n        diff--;\\n        int ans = s + diff;\\n        if(s>e){\\n            ans--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078796,
                "title": "java-solution-100-faster-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int maxInd = 0;\\n        int minInd = 0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(max < nums[i]){\\n                max = nums[i];\\n                maxInd = i;\\n            }\\n            if(min > nums[i]){\\n                min = nums[i];\\n                minInd = i;\\n            }\\n        }\\n\\n        int count = minInd + nums.length-maxInd-1;\\n\\n        if(minInd > maxInd)\\n            count--;\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int maxInd = 0;\\n        int minInd = 0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(max < nums[i]){\\n                max = nums[i];\\n                maxInd = i;\\n            }\\n            if(min > nums[i]){\\n                min = nums[i];\\n                minInd = i;\\n            }\\n        }\\n\\n        int count = minInd + nums.length-maxInd-1;\\n\\n        if(minInd > maxInd)\\n            count--;\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058631,
                "title": "easier-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMax(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()-1];\\n    }\\n    int findMin(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[0];\\n    }\\n    int findInd(int no, vector<int> nums){\\n        for(int i=0;i<=nums.size()-1;i++){\\n            if(nums[i]==no){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int si=nums.size();\\n        int min=findMin(nums);\\n        int max=findMax(nums);\\n        int minInd=findInd(min, nums);\\n        int maxInd=findInd(max, nums);\\n        if(minInd<maxInd){\\n           return minInd + (si-maxInd) - 1;\\n        }\\n        return minInd + (si-maxInd) - 2;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMax(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()-1];\\n    }\\n    int findMin(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[0];\\n    }\\n    int findInd(int no, vector<int> nums){\\n        for(int i=0;i<=nums.size()-1;i++){\\n            if(nums[i]==no){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int si=nums.size();\\n        int min=findMin(nums);\\n        int max=findMax(nums);\\n        int minInd=findInd(min, nums);\\n        int maxInd=findInd(max, nums);\\n        if(minInd<maxInd){\\n           return minInd + (si-maxInd) - 1;\\n        }\\n        return minInd + (si-maxInd) - 2;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027981,
                "title": "php-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function semiOrderedPermutation($nums) {\\n        $min = min($nums);\\n        $max = max($nums);\\n        $ln = count($nums);\\n        \\n        if ($nums[0] === $min && $nums[$ln - 1] === $max) {\\n            return 0;\\n        }\\n\\n        $minIndex = array_search($min, $nums);\\n        $maxIndex = array_search($max, $nums);\\n        $n = $minIndex > $maxIndex? 2: 1;\\n\\n        return $minIndex + $ln - $maxIndex - $n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function semiOrderedPermutation($nums) {\\n        $min = min($nums);\\n        $max = max($nums);\\n        $ln = count($nums);\\n        \\n        if ($nums[0] === $min && $nums[$ln - 1] === $max) {\\n            return 0;\\n        }\\n\\n        $minIndex = array_search($min, $nums);\\n        $maxIndex = array_search($max, $nums);\\n        $n = $minIndex > $maxIndex? 2: 1;\\n\\n        return $minIndex + $ln - $maxIndex - $n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020620,
                "title": "python-3-solution-beats-60-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse while loops and count the swaps\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ - Worst case scenario\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        smallest = min(nums)\\n        largest = max(nums)\\n\\n        count = 0\\n\\n        while nums[0] != smallest:\\n            small_index = nums.index(smallest)\\n            nums[small_index], nums[small_index - 1] = nums[small_index - 1], nums[small_index]\\n            count += 1        \\n        \\n        while nums[-1] != largest:\\n            large_index = nums.index(largest)\\n            nums[large_index], nums[large_index + 1] = nums[large_index + 1], nums[large_index]\\n            count += 1\\n\\n        return count        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        smallest = min(nums)\\n        largest = max(nums)\\n\\n        count = 0\\n\\n        while nums[0] != smallest:\\n            small_index = nums.index(smallest)\\n            nums[small_index], nums[small_index - 1] = nums[small_index - 1], nums[small_index]\\n            count += 1        \\n        \\n        while nums[-1] != largest:\\n            large_index = nums.index(largest)\\n            nums[large_index], nums[large_index + 1] = nums[large_index + 1], nums[large_index]\\n            count += 1\\n\\n        return count        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007684,
                "title": "java-100-o-n-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int indexOfOne = -1;\\n        int indexOfN = -1;\\n        for(int i = 0; i < n; i++){\\n            if(indexOfOne != -1 && indexOfN != -1) break;\\n            if(indexOfOne == -1 && nums[i] == 1) indexOfOne = i;\\n            if(indexOfN == -1 && nums[i] == n) indexOfN = i;\\n        }\\n        if(indexOfN < indexOfOne) return indexOfOne + (n-1 - indexOfN) - 1;\\n        return indexOfOne + (n-1 - indexOfN);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int indexOfOne = -1;\\n        int indexOfN = -1;\\n        for(int i = 0; i < n; i++){\\n            if(indexOfOne != -1 && indexOfN != -1) break;\\n            if(indexOfOne == -1 && nums[i] == 1) indexOfOne = i;\\n            if(indexOfN == -1 && nums[i] == n) indexOfN = i;\\n        }\\n        if(indexOfN < indexOfOne) return indexOfOne + (n-1 - indexOfN) - 1;\\n        return indexOfOne + (n-1 - indexOfN);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992262,
                "title": "semi-ordered-permutation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    find the index of 1 and n in the given array.\\n    based on the index value of 1 and n we just need to find the \\n    number of swap required to take 1 and n to the 0th and n-1th index\\n    \\n    for 1 the number of swap required to bring it to 0th index is\\n    same as the index at which it was found. ( you can try it out)\\n\\n    for n the number of swap required to bring it to n-1th index is \\n    equal to (n-i-index_max). where index_max is the index where n \\n    was found.\\n    hence return the total of swap for 1 and n. \\n\\n    but there is one exception if the index_max < index_min then we \\n    must return total - 1 because one swap will be counted twice \\n    one during swapping of 1 and one during swapping of n. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max_index = -1;\\n        int min_index = -1;\\n        \\n        for(int i = 0; i< nums.length; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                min_index = i;\\n            }\\n            if(nums[i] == nums.length)\\n            {\\n                max_index = i;\\n            }\\n            if(max_index != -1 && min_index != -1) break;\\n        }\\n        \\n        if(max_index > min_index) {\\n            return min_index + nums.length-1 - max_index; \\n        }else{\\n             return min_index + nums.length-2 - max_index;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max_index = -1;\\n        int min_index = -1;\\n        \\n        for(int i = 0; i< nums.length; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                min_index = i;\\n            }\\n            if(nums[i] == nums.length)\\n            {\\n                max_index = i;\\n            }\\n            if(max_index != -1 && min_index != -1) break;\\n        }\\n        \\n        if(max_index > min_index) {\\n            return min_index + nums.length-1 - max_index; \\n        }else{\\n             return min_index + nums.length-2 - max_index;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983842,
                "title": "c-solution-o-n-s-1",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int idx_1 = 0;\\n        int idx_n = 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                idx_1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                idx_n = i;\\n            }\\n        }\\n\\n        int res = 0;\\n        res -= (idx_n < idx_1);\\n\\n        res += idx_1;\\n        res += nums.size() - idx_n - 1;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int idx_1 = 0;\\n        int idx_n = 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                idx_1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                idx_n = i;\\n            }\\n        }\\n\\n        int res = 0;\\n        res -= (idx_n < idx_1);\\n\\n        res += idx_1;\\n        res += nums.size() - idx_n - 1;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976732,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-99-memory",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int output = 0;\\n        int t = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                output += i;\\n                t = i;\\n                i = nums.length;\\n            }\\n            while (t > 0) {\\n                int temp = nums[t-1];\\n                nums[t] = temp;\\n                nums[--t] = 1;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == nums.length) {\\n                output += nums.length - 1 - i;\\n                break;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int output = 0;\\n        int t = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                output += i;\\n                t = i;\\n                i = nums.length;\\n            }\\n            while (t > 0) {\\n                int temp = nums[t-1];\\n                nums[t] = temp;\\n                nums[--t] = 1;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == nums.length) {\\n                output += nums.length - 1 - i;\\n                break;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960477,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l = nums.index(min(nums))\\n        count = 0\\n\\n        while l >= 1:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            count += 1\\n        \\n        r = nums.index(max(nums))\\n\\n        while r < len(nums) - 1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            count += 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l = nums.index(min(nums))\\n        count = 0\\n\\n        while l >= 1:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            count += 1\\n        \\n        r = nums.index(max(nums))\\n\\n        while r < len(nums) - 1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            count += 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956485,
                "title": "easy-python-pointer-solution-beats-97-64-11-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, we find where \\'1\\' and \\'n\\' are and grab their indices. Then we bubble \\'1\\' to the first of the array counting passes as we go. Then we bubble \\'n\\' to the end of the array counting passes as we go.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        res = 0\\n        l = nums.index(1)\\n        while l != 0:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            res += 1\\n        r = nums.index(len(nums))\\n        while r != len(nums)-1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            res += 1\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        res = 0\\n        l = nums.index(1)\\n        while l != 0:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            res += 1\\n        r = nums.index(len(nums))\\n        while r != len(nums)-1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            res += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917935,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n       int i1=0,i2=0;\\n    \\tint n=nums.length;\\n    \\t\\n    \\tfor(int i=0;i<n;i++) {\\n    \\t\\tif(nums[i]==1) {\\n    \\t\\t\\ti1=i;\\n    \\t\\t}\\n    \\t\\tif(nums[i]==n) {\\n    \\t\\t\\ti2=i;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tif(i1<i2) {\\n    \\t\\treturn i1+(n-1)-i2;\\n    \\t}else {\\n    \\t\\treturn i1+(n-2)-i2;\\n    \\t} \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n       int i1=0,i2=0;\\n    \\tint n=nums.length;\\n    \\t\\n    \\tfor(int i=0;i<n;i++) {\\n    \\t\\tif(nums[i]==1) {\\n    \\t\\t\\ti1=i;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3910195,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the given 0-indexed array, we are allowed to perform swap on any two adjacent elements unit we make array nums a semi-ordered permutation.\\nwe can perform swap on element valued 1 to make it reach index 0.\\nSimilarly, we perform swap on element valued n (which is also the size of the array nums) till it reaches the last index that is (n-1).\\nWe return the number of swaps required in this process.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n          int n=nums.length;\\n        int cnt=0;\\n        boolean f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                      int temp= nums[i];\\n                      nums[i]=nums[i+1];\\n                      nums[i+1]=temp;\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                     int temp= nums[i-1];\\n                     nums[i-1]=nums[i];\\n                     nums[i]=temp;\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n          int n=nums.length;\\n        int cnt=0;\\n        boolean f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                      int temp= nums[i];\\n                      nums[i]=nums[i+1];\\n                      nums[i+1]=temp;\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                     int temp= nums[i-1];\\n                     nums[i-1]=nums[i];\\n                     nums[i]=temp;\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892012,
                "title": "c-solution-using-only-for-loops",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n      int one=0;\\n      int last=0;\\n      int ans=0;\\n      int n=nums.size();\\n      if(nums[0]!=1){\\n          for(int i=0; i<n; i++){\\n              if(nums[i]==1){\\n                 one=i;\\n                  break;\\n              }\\n          }\\n          for(int i=one; i>0; i--){\\n              nums[i]=nums[i-1];\\n              ans++;\\n          }\\n          nums[0]=1;\\n      }\\n\\n      if(nums[n-1]!=n){\\n           for(int i=0; i<n; i++){\\n              if(nums[i]==n){\\n                   last=i;\\n                  break;\\n              }\\n      }\\n       for(int i=last; i<n-1; i++){\\n              nums[i]=nums[i+1];\\n              ans++;\\n          }\\n          nums[n-1]=n;\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n      int one=0;\\n      int last=0;\\n      int ans=0;\\n      int n=nums.size();\\n      if(nums[0]!=1){\\n          for(int i=0; i<n; i++){\\n              if(nums[i]==1){\\n                 one=i;\\n                  break;\\n              }\\n          }\\n          for(int i=one; i>0; i--){\\n              nums[i]=nums[i-1];\\n              ans++;\\n          }\\n          nums[0]=1;\\n      }\\n\\n      if(nums[n-1]!=n){\\n           for(int i=0; i<n; i++){\\n              if(nums[i]==n){\\n                   last=i;\\n                  break;\\n              }\\n      }\\n       for(int i=last; i<n-1; i++){\\n              nums[i]=nums[i+1];\\n              ans++;\\n          }\\n          nums[n-1]=n;\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889234,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int max = 0; \\n        int min = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1) min = i;\\n            if(nums[i] == n) max = i;\\n        }\\n\\n        return (min <  max) ? n - 1 - max + min :  n - 1 - max + min - 1;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int max = 0; \\n        int min = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1) min = i;\\n            if(nums[i] == n) max = i;\\n        }\\n\\n        return (min <  max) ? n - 1 - max + min :  n - 1 - max + min - 1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865059,
                "title": "simple-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function(nums) {\\n  const length = nums.length;\\n  const positionOf1 = nums.indexOf(1);\\n  const positionOfMaxNum = nums.indexOf(length);\\n  const minimumSwap = positionOf1 + (length - positionOfMaxNum - 1);\\n\\n  return (positionOf1 < positionOfMaxNum) ? minimumSwap : minimumSwap - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function(nums) {\\n  const length = nums.length;\\n  const positionOf1 = nums.indexOf(1);\\n  const positionOfMaxNum = nums.indexOf(length);\\n  const minimumSwap = positionOf1 + (length - positionOfMaxNum - 1);\\n\\n  return (positionOf1 < positionOfMaxNum) ? minimumSwap : minimumSwap - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864561,
                "title": "java-1ms-beats-100-00",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        int idxOf1 = -1;\\n        int idxOfN = -1;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == 1) {\\n                idxOf1 = i;\\n            } else if (nums[i] == n) {\\n                idxOfN = i;\\n            }\\n        }\\n\\n        if (idxOf1 < idxOfN) {\\n            return idxOf1 + (n - idxOfN - 1);\\n        } else {  // idxOf1 > idxOfN\\n            return idxOf1 + (n - idxOfN - 2);\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        int idxOf1 = -1;\\n        int idxOfN = -1;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == 1) {\\n                idxOf1 = i;\\n            } else if (nums[i] == n) {\\n                idxOfN = i;\\n            }\\n        }\\n\\n        if (idxOf1 < idxOfN) {\\n            return idxOf1 + (n - idxOfN - 1);\\n        } else {  // idxOf1 > idxOfN\\n            return idxOf1 + (n - idxOfN - 2);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864057,
                "title": "semi-ordered-permutation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums[0]==1 and nums[-1]==len(nums):\\n            return 0\\n        num=0\\n        while nums[-1]!=len(nums):\\n            nummax=nums.index(len(nums))\\n            nums[nummax],nums[nummax+1]=nums[nummax+1],len(nums)\\n            num+=1\\n        while nums[0]!=1:\\n            nummin=nums.index(1)\\n            nums[nummin],nums[nummin-1]=nums[nummin-1],1\\n            num+=1\\n        return num\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums[0]==1 and nums[-1]==len(nums):\\n            return 0\\n        num=0\\n        while nums[-1]!=len(nums):\\n            nummax=nums.index(len(nums))\\n            nums[nummax],nums[nummax+1]=nums[nummax+1],len(nums)\\n            num+=1\\n        while nums[0]!=1:\\n            nummin=nums.index(1)\\n            nums[nummin],nums[nummin-1]=nums[nummin-1],1\\n            num+=1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862667,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        \\n        let f = nums.firstIndex(of: 1)!\\n        let l = nums.firstIndex(of: nums.count)!\\n        \\n        var res = f + (nums.count - l - 1)\\n\\n        if l < f { res -= 1 }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        \\n        let f = nums.firstIndex(of: 1)!\\n        let l = nums.firstIndex(of: nums.count)!\\n        \\n        var res = f + (nums.count - l - 1)\\n\\n        if l < f { res -= 1 }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857591,
                "title": "best-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1&&nums[n-1]==n) return 0;\\n        int a,b;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) a=i;\\n            if(nums[i]==n) b=i;\\n        }\\n        if(a>b){\\n            return a+(n-1)-b-1;\\n        }\\n        else\\n            return a+(n-1)-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1&&nums[n-1]==n) return 0;\\n        int a,b;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) a=i;\\n            if(nums[i]==n) b=i;\\n        }\\n        if(a>b){\\n            return a+(n-1)-b-1;\\n        }\\n        else\\n            return a+(n-1)-b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853758,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplementation\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=0;\\n        int pos1=-1,pos2=-1;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==1)pos1=i;\\n        }\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==nums.size())pos2=i;\\n        }\\n\\n        int n=nums.size();\\n        ++pos1,++pos2;\\n\\n        ans=abs(1-pos1)+abs(pos2-n);\\n        if(pos1>pos2)--ans;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=0;\\n        int pos1=-1,pos2=-1;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==1)pos1=i;\\n        }\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==nums.size())pos2=i;\\n        }\\n\\n        int n=nums.size();\\n        ++pos1,++pos2;\\n\\n        ans=abs(1-pos1)+abs(pos2-n);\\n        if(pos1>pos2)--ans;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841295,
                "title": "brutefoce-easiest-approac-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[0]!=1){\\n                for(int j=1;j<nums.length;j++){\\n                    if(nums[j]==1){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j-1];\\n                        nums[j-1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        \\n        }\\n        int last=nums.length-1;\\n        int acc=nums.length;\\n\\n        for(int i=last;i>=0;i--){\\n            if(nums[last]!=nums.length){\\n                for(int j=last-1;j>=0;j--){\\n                    if(nums[j]==acc){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j+1];\\n                        nums[j+1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n\\n        for(int i=0;i<nums.length;i++){\\n            System.out.print(nums[i]+\" \");\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[0]!=1){\\n                for(int j=1;j<nums.length;j++){\\n                    if(nums[j]==1){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j-1];\\n                        nums[j-1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        \\n        }\\n        int last=nums.length-1;\\n        int acc=nums.length;\\n\\n        for(int i=last;i>=0;i--){\\n            if(nums[last]!=nums.length){\\n                for(int j=last-1;j>=0;j--){\\n                    if(nums[j]==acc){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j+1];\\n                        nums[j+1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n\\n        for(int i=0;i<nums.length;i++){\\n            System.out.print(nums[i]+\" \");\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837038,
                "title": "c-simple-iteration-easy-and-understandable-clean-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind index of 1 and n let x is index of 1 and y is index of n then \\n\\nlets tae an example\\n\\n     [2, 6 , 7 , 8 , 9 , 1 , 4 , 10 , 5 , 15 , 12 , 13 , 14 , 11 , 3 ]\\n\\n\\n\\nhere x = 5 and y = 9 \\n\\n\\nif x < y so in this case to move 1 to the 0th position we need x operation and to move 15 to 14th position we need 14 -9 or  n-1-y\\n\\n\\n\\nnow another case \\n\\n\\nnow if  x > y\\n\\n     [2, 6 , 7 , 8 , 9 , 15 , 4 , 10 , 5 , 1 , 12 , 13 , 14 , 11 , 3 ]\\n\\nhere x = 9  and y = 5 \\n\\nnow first we move 1 to 0th position  so array will be \\n\\n    [1, 2 , 6 , 7 , 8 , 9 , 15 , 4 , 10 , 5 , 12 , 13 , 14 , 11 , 3 ]\\n\\nnow value of y is chaneged  y = 5 to y =6 means in this need 14 -6 = 8 operations\\n\\nmeas if  x > y then we need 1 operation less than if x<y\\n\\n\\n\\n\\n\\nfinal \\n\\nif(x>y) return   return  x  + n-2 - y ;\\nif(x<y) return  return  x  + n-1 - y ;\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Iteration\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n.\\n.\\n.\\n.\\n.\\n\\nPlease correct me if I am wrong anywhere or have anyMemoization general suggestions.\\nPlease correct me if I am wrong anywhere or have anyMemoization general suggestions.\\n\\n.\\n.\\n.\\n.\\n.\\n\\n# Code\\n\\n\\n\\n\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n = nums.size() ;\\n        int x = 0 ,  y  = 0 ;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) x = i ;\\n            else if(nums[i]==n) y = i ;\\n        }\\n        if(x > y) return  x  + n-2 - y ;\\n        return x  + n-1 - y ;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n = nums.size() ;\\n        int x = 0 ,  y  = 0 ;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) x = i ;\\n            else if(nums[i]==n) y = i ;\\n        }\\n        if(x > y) return  x  + n-2 - y ;\\n        return x  + n-1 - y ;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826272,
                "title": "48ms-beats-100-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of swaps depends on the initial positions of the lowest and highest values in the array.\\n\\nIf the index of the maximum value is lower than the index of the minimum value, you can swap both of their places in one swap, thus we need to take this into account by subtracting 1 if this is the case.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the index of the max and min values\\n2. Calculate how far the max is from the end (from `nums.length - 1`)\\n3. Calculate how far the min is from the start (Basically just the index of the min value)\\n4. Add these 2 values from steps 2 and 3 to get the answer, but if the index of the max value is lower than the index of the min value, subtract 1\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const maximum = nums.indexOf(Math.max(...nums))\\n    const minimum = nums.indexOf(Math.min(...nums))\\n\\n    return maximum < minimum ? (nums.length - 1 - maximum) + minimum - 1 : (nums.length - 1 - maximum) + minimum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const maximum = nums.indexOf(Math.max(...nums))\\n    const minimum = nums.indexOf(Math.min(...nums))\\n\\n    return maximum < minimum ? (nums.length - 1 - maximum) + minimum - 1 : (nums.length - 1 - maximum) + minimum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803742,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        \\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == 1){\\n                nums.erase(nums.begin() + i);\\n                ans += i;\\n                break;\\n            }\\n        }\\n\\n        nums.insert(nums.begin() , 1);\\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == n){\\n                ans += n-1-i;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        \\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == 1){\\n                nums.erase(nums.begin() + i);\\n                ans += i;\\n                break;\\n            }\\n        }\\n\\n        nums.insert(nums.begin() , 1);\\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == n){\\n                ans += n-1-i;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793561,
                "title": "swift-simple-solution-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var l = -1\\n        var r = -1\\n        var pointer = 0\\n        \\n        while l == -1 || r == -1 {\\n            if nums[pointer] == 1 {\\n                l = pointer\\n            } else if nums[pointer] == nums.count {\\n                r = pointer\\n            }\\n            pointer += 1\\n        }\\n        \\n        let count = l + nums.count - 1 - r\\n\\n        return l < r ? count : count - 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var l = -1\\n        var r = -1\\n        var pointer = 0\\n        \\n        while l == -1 || r == -1 {\\n            if nums[pointer] == 1 {\\n                l = pointer\\n            } else if nums[pointer] == nums.count {\\n                r = pointer\\n            }\\n            pointer += 1\\n        }\\n        \\n        let count = l + nums.count - 1 - r\\n\\n        return l < r ? count : count - 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786054,
                "title": "esay",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        i1 = nums.index(1)\\n        i2 = nums.index(n)\\n        c = i1+(n-i2-1)\\n        if i2<i1:\\n            c-=1 \\n        return c\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        i1 = nums.index(1)\\n        i2 = nums.index(n)\\n        c = i1+(n-i2-1)\\n        if i2<i1:\\n            c-=1 \\n        return c\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784381,
                "title": "cpp-very-easy-beginner-lvl-solution-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int index=0;\\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == 1 ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int op = 0;\\n        if( index != 0){\\n            for( int i = index ; i > 0 ; i--){\\n                swap(nums[i],nums[i-1]);\\n                op++;\\n            }\\n        }\\n        \\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == nums.size() ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        if( index != nums.size()-1 ){\\n            for( int i = index ; i<nums.size()-1 ;i++){\\n                swap(nums[i] , nums[i+1]);\\n                op++;\\n            }\\n        }\\n        \\n        return op;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int index=0;\\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == 1 ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int op = 0;\\n        if( index != 0){\\n            for( int i = index ; i > 0 ; i--){\\n                swap(nums[i],nums[i-1]);\\n                op++;\\n            }\\n        }\\n        \\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == nums.size() ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        if( index != nums.size()-1 ){\\n            for( int i = index ; i<nums.size()-1 ;i++){\\n                swap(nums[i] , nums[i+1]);\\n                op++;\\n            }\\n        }\\n        \\n        return op;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777106,
                "title": "easy-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        // Get the indexes of 1 and n as p1 and p2\\n        int p1= 0;\\n        int p2 = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] ==1){\\n                p1 = i;\\n            }\\n            else if(nums[i] == n){\\n                p2 = i;\\n            }\\n        }\\n        /*if 1 is before n then simply 1 and n will swap without altering each other\\'s coordinates*/ \\n        int temp = p1 + (n-1-p2);\\n        /*else if n is before 1 then we will encounter n thus swapping and taking n an index close to its final position thereby reducing moves required by 1*/\\n        if(p1>p2){\\n            return temp-1;\\n        }\\n        return temp;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        // Get the indexes of 1 and n as p1 and p2\\n        int p1= 0;\\n        int p2 = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] ==1){\\n                p1 = i;\\n            }\\n            else if(nums[i] == n){\\n                p2 = i;\\n            }\\n        }\\n        /*if 1 is before n then simply 1 and n will swap without altering each other\\'s coordinates*/ \\n        int temp = p1 + (n-1-p2);\\n        /*else if n is before 1 then we will encounter n thus swapping and taking n an index close to its final position thereby reducing moves required by 1*/\\n        if(p1>p2){\\n            return temp-1;\\n        }\\n        return temp;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775782,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    let min = 0;\\n    let max = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) min = i;\\n        if (nums[i] === nums.length) max = i;\\n    }\\n    let result = min + (nums.length - max - 1)\\n    return min < max ? result : result-1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    let min = 0;\\n    let max = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) min = i;\\n        if (nums[i] === nums.length) max = i;\\n    }\\n    let result = min + (nums.length - max - 1)\\n    return min < max ? result : result-1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770810,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn semi_ordered_permutation(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let first = nums.iter().position(|&x| x == 1).unwrap();\\n        let last = nums.iter().position(|&x| x == n as i32).unwrap();\\n\\n        if first < last {\\n            (first + n - last - 1) as _\\n        } else {\\n            (first + n - last - 2) as _\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn semi_ordered_permutation(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let first = nums.iter().position(|&x| x == 1).unwrap();\\n        let last = nums.iter().position(|&x| x == n as i32).unwrap();\\n\\n        if first < last {\\n            (first + n - last - 1) as _\\n        } else {\\n            (first + n - last - 2) as _\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3769993,
                "title": "semiorderedpermutation",
                "content": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int min = nums.Min();\\n        int max = nums.Max();\\n\\n        int indexOfMin = Array.IndexOf(nums, min);\\n        int indexOfMax = Array.IndexOf(nums, max);\\n\\n        int swaps = 0;\\n       \\n        if(indexOfMin == 0 && indexOfMax + 1 == nums.Length) return 0;\\n        if(nums.Length == 2) return swaps = (indexOfMin == 0) ? 0:1;\\n\\n        swaps += indexOfMin;\\n        swaps += nums.Length - (indexOfMax+1);\\n        if(indexOfMax < indexOfMin) swaps-=1;\\n\\n        return swaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int min = nums.Min();\\n        int max = nums.Max();\\n\\n        int indexOfMin = Array.IndexOf(nums, min);\\n        int indexOfMax = Array.IndexOf(nums, max);\\n\\n        int swaps = 0;\\n       \\n        if(indexOfMin == 0 && indexOfMax + 1 == nums.Length) return 0;\\n        if(nums.Length == 2) return swaps = (indexOfMin == 0) ? 0:1;\\n\\n        swaps += indexOfMin;\\n        swaps += nums.Length - (indexOfMax+1);\\n        if(indexOfMax < indexOfMin) swaps-=1;\\n\\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766730,
                "title": "very-easy-c-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int fir = -1, last = -1;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == 1){\\n                fir = i;\\n                break;\\n            }\\n        }\\n\\n        if(fir != 0){\\n            for(int i=fir; i>=1; i--){\\n                swap(nums[i], nums[i-1]);\\n                count++;\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == n){\\n                last = i;\\n                break;\\n            }\\n        }\\n\\n        if(last != n-1){\\n            for(int i=last; i<n-1; i++){\\n                swap(nums[i], nums[i+1]);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int fir = -1, last = -1;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == 1){\\n                fir = i;\\n                break;\\n            }\\n        }\\n\\n        if(fir != 0){\\n            for(int i=fir; i>=1; i--){\\n                swap(nums[i], nums[i-1]);\\n                count++;\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == n){\\n                last = i;\\n                break;\\n            }\\n        }\\n\\n        if(last != n-1){\\n            for(int i=last; i<n-1; i++){\\n                swap(nums[i], nums[i+1]);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746225,
                "title": "java-o-n-100-faster",
                "content": "In the end, **b** shows the distance between largest number and the end of the array.\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 1, b = nums.length, idxA = 0, idxB = 0, res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == a) idxA = i;\\n            if (nums[i] == b) idxB = i;\\n        }\\n        b = b - idxB - 1;\\n        return idxB < idxA ? idxA + b - 1 : idxA + b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 1, b = nums.length, idxA = 0, idxB = 0, res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == a) idxA = i;\\n            if (nums[i] == b) idxB = i;\\n        }\\n        b = b - idxB - 1;\\n        return idxB < idxA ? idxA + b - 1 : idxA + b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732498,
                "title": "find-position-1-and-n-c",
                "content": "\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int x = 0, y = 0, swp = 0, n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) x = i;\\n            if(nums[i] == n) y = n - i - 1;\\n            if(y && x == 0 && nums[0] != 1) swp = 1;\\n        }\\n        return x + y - swp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int x = 0, y = 0, swp = 0, n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) x = i;\\n            if(nums[i] == n) y = n - i - 1;\\n            if(y && x == 0 && nums[0] != 1) swp = 1;\\n        }\\n        return x + y - swp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729288,
                "title": "javascript-bubblesort",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    return bubbleSort(nums)\\n};\\n\\nfunction bubbleSort(arr) {\\n  \\n    var i, j;\\n    var len = arr.length;\\n    let count = 0;\\n  \\n    var isSwapped = false;\\n  \\n    for (i = 0; i < len; i++) {\\n  \\n        isSwapped = false;\\n  \\n        for (j = 0; j < len; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                var temp = arr[j]\\n                arr[j] = arr[j + 1];\\n                arr[j + 1] = temp;\\n                isSwapped = true;\\n\\n                if (\\n                    (arr[j] == 1 || arr[j+1] == len) ||\\n                    (arr[j+1] == 1 || arr[j] == len)\\n                )\\n                count++;\\n            }\\n        }\\n  \\n        if (!isSwapped) {\\n            break;\\n        }\\n    }\\n  \\n    //return arr\\n    return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    return bubbleSort(nums)\\n};\\n\\nfunction bubbleSort(arr) {\\n  \\n    var i, j;\\n    var len = arr.length;\\n    let count = 0;\\n  \\n    var isSwapped = false;\\n  \\n    for (i = 0; i < len; i++) {\\n  \\n        isSwapped = false;\\n  \\n        for (j = 0; j < len; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                var temp = arr[j]\\n                arr[j] = arr[j + 1];\\n                arr[j + 1] = temp;\\n                isSwapped = true;\\n\\n                if (\\n                    (arr[j] == 1 || arr[j+1] == len) ||\\n                    (arr[j+1] == 1 || arr[j] == len)\\n                )\\n                count++;\\n            }\\n        }\\n  \\n        if (!isSwapped) {\\n            break;\\n        }\\n    }\\n  \\n    //return arr\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3725988,
                "title": "basic-c-solution-easy-to-understand-explained-beats-90-runtime-and-memory-beginner",
                "content": "# Intuition\\nSure! Let me explain the code in first person and discuss its complexity.\\n\\nIn this code, I see a class named `Solution` with a member function `semiOrderedPermutation`. This function takes a reference to a vector of integers `nums` as input and calculates a count value based on certain conditions.\\n\\n# Approach\\n\\nNow, let\\'s go through the code step by step:\\n\\n1. First, there is an `if` condition that checks if the first element of `nums` is `1` and the last element is equal to the size of `nums`. If this condition is true, it means that the vector is already a semi-ordered permutation, and there is no need to perform any operations. In this case, the function returns `0`.\\n\\n2. If the condition in the previous step is not met, the code initializes a variable `count` to `0`. This variable will be used to keep track of the count value.\\n\\n3. The code then enters a `for` loop that iterates over the elements of the `nums` vector. Inside this loop:\\n   - It checks if the current element is equal to `1`.\\n   - If the condition is true, it means that we have found the first element of the permutation. We update the `count` by adding the current index `i` to it. This is because we want to count the number of swaps required to bring the first element (`1`) to its correct position.\\n   - Next, there is a nested `while` loop that performs the actual swapping of elements. Starting from the current index `j = i`, it iterates backwards and swaps `nums[j]` with `nums[j-1]` until `j` becomes `0`. This effectively moves the first element to the front of the vector.\\n\\n4. After the first loop finishes, the code enters another `for` loop that iterates over the elements of `nums` once again. Inside this loop:\\n   - It checks if the current element is equal to the size of `nums`. If the condition is true, it means we have found the last element of the permutation. We update the `count` by adding the difference between `(nums.size() - 1)` and the current index `i` to it. This accounts for the number of swaps required to bring the last element to its correct position.\\n\\n5. Finally, the function returns the calculated `count` value, representing the number of swaps needed to obtain a semi-ordered permutation of `nums`.\\n\\n# Complexity\\n- Time complexity : The code runs two nested loops, each iterating over the elements of `nums`, so the time complexity is O(n^2), where n is the size of the vector.\\n\\n- Space complexity : The space complexity of the code is O(1) as it only uses a constant amount of additional space, regardless of the input size.\\n\\n![star-wars-bb8.gif](https://assets.leetcode.com/users/images/decbf26e-0058-4c78-9c8f-144a49fed944_1688628814.790765.gif)\\n\\n# Do upvote if you like the solution , happy leetcoding\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] == 1 && nums[nums.size()-1] == nums.size())\\n        {\\n            return 0;\\n        }\\n            int count = 0;\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == 1)\\n                {\\n                    count = count + i;\\n                    int j = i;\\n                    while(j>0)\\n                    {\\n                        int temp = nums[j];\\n                        nums[j] = nums[j-1];\\n                        nums[j-1] = temp;\\n                        j--;\\n                    }\\n                }\\n            }\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == nums.size())\\n                {\\n                    count = count + ((nums.size()-1)-i);\\n                }\\n            }\\n            return count;    \\n    }\\n}; //Please Upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] == 1 && nums[nums.size()-1] == nums.size())\\n        {\\n            return 0;\\n        }\\n            int count = 0;\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == 1)\\n                {\\n                    count = count + i;\\n                    int j = i;\\n                    while(j>0)\\n                    {\\n                        int temp = nums[j];\\n                        nums[j] = nums[j-1];\\n                        nums[j-1] = temp;\\n                        j--;\\n                    }\\n                }\\n            }\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == nums.size())\\n                {\\n                    count = count + ((nums.size()-1)-i);\\n                }\\n            }\\n            return count;    \\n    }\\n}; //Please Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722194,
                "title": "find-indexof-1-and-lastindexof-n",
                "content": "# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  const firstOne = nums.indexOf(1);\\n  const lastN = nums.lastIndexOf(nums.length);\\n  return firstOne > lastN\\n    ? nums.length - lastN - 2 + firstOne\\n    : nums.length - lastN - 1 + firstOne;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  const firstOne = nums.indexOf(1);\\n  const lastN = nums.lastIndexOf(nums.length);\\n  return firstOne > lastN\\n    ? nums.length - lastN - 2 + firstOne\\n    : nums.length - lastN - 1 + firstOne;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3722031,
                "title": "array-manipulation-to-find-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int total_score=0;\\n        int index1=0,index2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n                break;\\n            }\\n        }\\n        nums.erase(nums.begin()+index1);\\n        reverse(nums.begin(),nums.end());\\n        nums.push_back(1);\\n        reverse(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                index2=i;\\n                break;\\n            }\\n        }\\n        total_score=index1+(nums.size()-1-index2);\\n        return total_score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int total_score=0;\\n        int index1=0,index2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n                break;\\n            }\\n        }\\n        nums.erase(nums.begin()+index1);\\n        reverse(nums.begin(),nums.end());\\n        nums.push_back(1);\\n        reverse(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                index2=i;\\n                break;\\n            }\\n        }\\n        total_score=index1+(nums.size()-1-index2);\\n        return total_score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714726,
                "title": "python-3-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l  = len(nums)\\n        if nums.index(l) < nums.index(1):\\n            return l - 2 -nums.index(l) + nums.index(1)\\n        if nums.index(l) > nums.index(1):\\n            return l - 1  -nums.index(l) + nums.index(1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l  = len(nums)\\n        if nums.index(l) < nums.index(1):\\n            return l - 2 -nums.index(l) + nums.index(1)\\n        if nums.index(l) > nums.index(1):\\n            return l - 1  -nums.index(l) + nums.index(1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711226,
                "title": "very-simple-short-solution-with-explanation-c",
                "content": "# Intuition\\nThe problem asks for the minimum number of swaps required to transform a given array into a semi-ordered permutation. A semi-ordered permutation is defined as an array where the first element is 1, the last element is n, and all other elements are in increasing order. \\n\\nTo solve this problem, we can find the positions of the elements 1 and n in the given array. Depending on their relative positions, we can determine the minimum number of swaps required to transform the array into a semi-ordered permutation.\\n\\n# Approach\\n1. Find the positions of the elements 1 and n in the given array.\\n2. Calculate the distance of the element 1 from the beginning of the array (`posOne`) and the distance of the element n from the end of the array (`posN`).\\n3. If `posOne` is greater than `posN`, it means that the element 1 is located after the element n in the array. In this case, we need to swap the positions of the elements 1 and n, as well as adjust the positions `posOne` and `posN` accordingly.\\n4. Calculate the minimum number of swaps required by adding `posOne` and `posN` together and subtracting 1 (since we don\\'t need to swap the element 1 with itself).\\n5. If `posOne` is less than or equal to `posN`, it means that the element 1 is located before the element n in the array. In this case, we don\\'t need to swap any elements, so the minimum number of swaps required is equal to `posOne` + `posN`.\\n6. Return the minimum number of swaps as the result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the input array. The algorithm iterates through the array once to find the positions of the elements 1 and n.\\n- Space complexity: O(1). The algorithm uses a constant amount of extra space to store the positions `posOne` and `posN`.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        auto oneFind = find(nums.begin(), nums.end(), 1);\\n        auto nFind = find(nums.begin(), nums.end(), n);\\n\\n        int posOne = distance(nums.begin(), oneFind);\\n        int posN = distance(nums.begin(), nFind);\\n\\n        if (posOne > posN) {\\n            posN = n - posN - 1;\\n            return posOne + posN - 1;\\n        }\\n        \\n        posN = n - posN - 1;\\n        return posOne + posN;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        auto oneFind = find(nums.begin(), nums.end(), 1);\\n        auto nFind = find(nums.begin(), nums.end(), n);\\n\\n        int posOne = distance(nums.begin(), oneFind);\\n        int posN = distance(nums.begin(), nFind);\\n\\n        if (posOne > posN) {\\n            posN = n - posN - 1;\\n            return posOne + posN - 1;\\n        }\\n        \\n        posN = n - posN - 1;\\n        return posOne + posN;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697442,
                "title": "java-1000-accurate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n            int one  = 0;\\n        int n = 0;\\n        int ans = 0;\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!( nums[nums.length-1] == nums.length)){\\n            ans++;\\n            int temp = nums[n+1];\\n            nums[n+1] = nums[n];\\n            nums[n] = temp;\\n            n++;\\n        }\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!(nums[0] == 1 )){\\n            ans++;\\n\\n            int temp = nums[one-1];\\n            nums[one-1] = nums[one];\\n            nums[one] = temp;\\n            one--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n            int one  = 0;\\n        int n = 0;\\n        int ans = 0;\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!( nums[nums.length-1] == nums.length)){\\n            ans++;\\n            int temp = nums[n+1];\\n            nums[n+1] = nums[n];\\n            nums[n] = temp;\\n            n++;\\n        }\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!(nums[0] == 1 )){\\n            ans++;\\n\\n            int temp = nums[one-1];\\n            nums[one-1] = nums[one];\\n            nums[one] = temp;\\n            one--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697333,
                "title": "permutation-js-min-max-indexes-89-93-88-ms",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    a = 1\\n    b = nums.length\\n\\n    x = nums.indexOf(a)\\n    y = nums.indexOf(b)\\n\\n    return x < y ? (b - 1) - y + x : (b - 1) - y + x - 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    a = 1\\n    b = nums.length\\n\\n    x = nums.indexOf(a)\\n    y = nums.indexOf(b)\\n\\n    return x < y ? (b - 1) - y + x : (b - 1) - y + x - 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3693002,
                "title": "very-easy-ts-js-solution-by-just-swapping-elements",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur goal is to bring the smallest element that is 1 to the start of the array and N i.e nums.length to the end of the array. \\nSo we create two functions let say swapFirstIndex() which swaps elements starting from the index where 1 is present, untill 1 comes to the start of the array. \\nThen we create another function swapLastIndex() which elements starting from the index where n is present, untill n comes to the end of the array.\\n\\nAnd every time we do the swap we increase the counter in both the functions. \\n\\n**Note** - To find the index of 1 and n we use indexOf() function.\\n\\n**If you find my solution easy to understand and helpful, please upvote. It motivates me to post more solutions**\\n**Happy Coding !!**\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let count = 0\\n    let n = nums.length\\n    if(nums[0] == 1 && nums[n-1] == n){\\n        return count\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] == n){\\n        return swapFirstIndex(nums,count)\\n    }\\n\\n    if(nums[0] == 1 && nums[n-1] !== n){\\n        return swapLastIndex(nums,count,n)\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] !== n){\\n        return swapFirstIndex(nums,count) + swapLastIndex(nums,count,n)\\n    }\\n};\\n\\nfunction swapFirstIndex(nums,count){\\n    while(!(nums[0] == 1)){\\n        let indexOne = nums.indexOf(1)\\n        let right = indexOne\\n        let left = right - 1\\n            \\n        let temp = nums[right]\\n        nums[right] = nums[left]\\n        nums[left] = temp\\n        count ++\\n    }\\n    return count\\n}\\n\\nfunction swapLastIndex(nums,count,n){\\n    while(!(nums[n-1] == n)){\\n        let indexOne = nums.indexOf(n)\\n        let left = indexOne\\n        let right = left + 1\\n        \\n        let temp = nums[left]\\n        nums[left] = nums[right]\\n        nums[right] = temp\\n        \\n        count ++\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let count = 0\\n    let n = nums.length\\n    if(nums[0] == 1 && nums[n-1] == n){\\n        return count\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] == n){\\n        return swapFirstIndex(nums,count)\\n    }\\n\\n    if(nums[0] == 1 && nums[n-1] !== n){\\n        return swapLastIndex(nums,count,n)\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] !== n){\\n        return swapFirstIndex(nums,count) + swapLastIndex(nums,count,n)\\n    }\\n};\\n\\nfunction swapFirstIndex(nums,count){\\n    while(!(nums[0] == 1)){\\n        let indexOne = nums.indexOf(1)\\n        let right = indexOne\\n        let left = right - 1\\n            \\n        let temp = nums[right]\\n        nums[right] = nums[left]\\n        nums[left] = temp\\n        count ++\\n    }\\n    return count\\n}\\n\\nfunction swapLastIndex(nums,count,n){\\n    while(!(nums[n-1] == n)){\\n        let indexOne = nums.indexOf(n)\\n        let left = indexOne\\n        let right = left + 1\\n        \\n        let temp = nums[left]\\n        nums[left] = nums[right]\\n        nums[right] = temp\\n        \\n        count ++\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691144,
                "title": "video-walkthrough",
                "content": "https://youtu.be/jdyrzn5KGqI",
                "solutionTags": [
                    "C++"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3685238,
                "title": "a-math-asb-solution",
                "content": "# Approach\\nCheck if the permutation is already semi-ordered. If so, return 0. If not, continue on to get the index of 1 and `n`. Return the sum of the distance of 1 from the 0-index and the distance of `n` from the (n-1)-index, which represents the path each value must take to its semi-ordered position. If these paths overlap (the index of `n` is less than the index of 1), then reduce this sum by one. This is because they will eventually end up being swapped with each other, moving both one index closer to the positions with only one move. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        if (nums[0] == 1 && nums[n - 1] == n) return 0;\\n\\n        int pos1 = -1, posN = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) pos1 = i;\\n            else if (nums[i] == n) posN = i;\\n            if (pos1 != -1 && posN != -1) break;\\n        }\\n\\n        int overlap = posN < pos1 ? -1 : 0;\\n        return Math.abs(0 - pos1) + Math.abs(n - 1 - posN) + overlap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        if (nums[0] == 1 && nums[n - 1] == n) return 0;\\n\\n        int pos1 = -1, posN = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) pos1 = i;\\n            else if (nums[i] == n) posN = i;\\n            if (pos1 != -1 && posN != -1) break;\\n        }\\n\\n        int overlap = posN < pos1 ? -1 : 0;\\n        return Math.abs(0 - pos1) + Math.abs(n - 1 - posN) + overlap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675679,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0]==1 and nums[n-1]==n) return 0;\\n        int low=0;\\n        int high=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) low=i;\\n            if(nums[i]==n) high=i;\\n        }\\n\\n        if(low>high){\\n            return (low-0) + (n-1-high) -1;\\n        }\\n        else return (low-0) + (n-1-high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0]==1 and nums[n-1]==n) return 0;\\n        int low=0;\\n        int high=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) low=i;\\n            if(nums[i]==n) high=i;\\n        }\\n\\n        if(low>high){\\n            return (low-0) + (n-1-high) -1;\\n        }\\n        else return (low-0) + (n-1-high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670489,
                "title": "beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int index1=-1;\\n        int indexN=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1=i;\\n            }\\n            else if(nums[i]==nums.length){\\n                indexN=i;\\n            }\\n        }\\n        return index1+(nums.length-1-indexN)-(index1 > indexN ? 1 : 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int index1=-1;\\n        int indexN=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1=i;\\n            }\\n            else if(nums[i]==nums.length){\\n                indexN=i;\\n            }\\n        }\\n        return index1+(nums.length-1-indexN)-(index1 > indexN ? 1 : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657263,
                "title": "java-easy-solution-beats-100",
                "content": "# Complexity\\n- Time complexity:- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 0;\\n        int b = 0;\\n        int n = nums.length;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == 1)\\n                a = i;\\n            if(nums[i] == n)\\n                b = i;\\n        }\\n        if(a > b)\\n            b++;\\n        b = n - b - 1;\\n        return a+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 0;\\n        int b = 0;\\n        int n = nums.length;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == 1)\\n                a = i;\\n            if(nums[i] == n)\\n                b = i;\\n        }\\n        if(a > b)\\n            b++;\\n        b = n - b - 1;\\n        return a+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655641,
                "title": "java-simple-explained",
                "content": "**Idea:** \\n* Keep swapping 1 and n to their left and right neighbors respectively. \\n* You\\'ll notice that the number of swaps required (S) = distance of 1 from start + distance of n from end (but there\\'s a condition)\\n* If 1 is to the left of n, then the above formulat is correct\\n* Else if 1 is to the right of n, then in order to come to the 0th index 1 will swap itself with n, thus bringing down the swap count for n by 1, so anwer here will be S - 1\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int semiOrderedPermutation(int[] nums) {\\n\\tvar oneIdx = -1;\\n\\tvar nIdx = -1;\\n\\tvar n = nums.length;\\n\\n\\tfor (var i = 0; i < n && (oneIdx == -1 || nIdx == -1) ; i++)\\n\\t\\tif (nums[i] == 1)\\n\\t\\t\\toneIdx = i;\\n\\t\\telse if (nums[i] == n)\\n\\t\\t\\tnIdx = i;\\n\\n\\tvar swaps = oneIdx + (n - 1 - nIdx);\\n\\treturn oneIdx < nIdx ? swaps : --swaps;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int semiOrderedPermutation(int[] nums) {\\n\\tvar oneIdx = -1;\\n\\tvar nIdx = -1;\\n\\tvar n = nums.length;\\n\\n\\tfor (var i = 0; i < n && (oneIdx == -1 || nIdx == -1) ; i++)\\n\\t\\tif (nums[i] == 1)\\n\\t\\t\\toneIdx = i;\\n\\t\\telse if (nums[i] == n)\\n\\t\\t\\tnIdx = i;\\n\\n\\tvar swaps = oneIdx + (n - 1 - nIdx);\\n\\treturn oneIdx < nIdx ? swaps : --swaps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650284,
                "title": "simple-java-n-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] arr) {\\n        int idx1=0;\\n        int idx2=0;\\n        int n=arr.length;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n            idx1=i;\\n            if(arr[i]==n)\\n            idx2=i;\\n        }\\n        return idx1<idx2 ? idx1+(n-1-idx2) : idx1+(n-1-idx2)-1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] arr) {\\n        int idx1=0;\\n        int idx2=0;\\n        int n=arr.length;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n            idx1=i;\\n            if(arr[i]==n)\\n            idx2=i;\\n        }\\n        return idx1<idx2 ? idx1+(n-1-idx2) : idx1+(n-1-idx2)-1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648318,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1 and nums[n-1]==n){\\n            return 0;\\n        }\\n       int st,en;\\n       for(int i=0;i<n;i++){\\n         \\n         if(nums[i]==1){\\n             st=i;\\n         }\\n         if(nums[i]==n){\\n             en=i;\\n         }\\n       }\\n      if(st>en)return st+n-en-2;\\n      return st+n-1-en;\\n     \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1 and nums[n-1]==n){\\n            return 0;\\n        }\\n       int st,en;\\n       for(int i=0;i<n;i++){\\n         \\n         if(nums[i]==1){\\n             st=i;\\n         }\\n         if(nums[i]==n){\\n             en=i;\\n         }\\n       }\\n      if(st>en)return st+n-en-2;\\n      return st+n-1-en;\\n     \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648077,
                "title": "simple-solution-by-swapping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var c = 0\\n        var temp = 0\\n        var nums = nums\\n        while(true){\\n            if(nums[0] == 1 && nums[nums.count-1] == nums.count){\\n                return c\\n            }else{\\n                for i in 0..<nums.count{\\n                    if(nums[i] == 1 && i != 0){\\n                        temp = nums[i-1]\\n                        nums[i-1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                if(nums[0] == 1){\\n                    for i in 0..<nums.count{\\n                    if(nums[i] == nums.count && i != nums.count-1){\\n                        temp = nums[i+1]\\n                        nums[i+1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var c = 0\\n        var temp = 0\\n        var nums = nums\\n        while(true){\\n            if(nums[0] == 1 && nums[nums.count-1] == nums.count){\\n                return c\\n            }else{\\n                for i in 0..<nums.count{\\n                    if(nums[i] == 1 && i != 0){\\n                        temp = nums[i-1]\\n                        nums[i-1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                if(nums[0] == 1){\\n                    for i in 0..<nums.count{\\n                    if(nums[i] == nums.count && i != nums.count-1){\\n                        temp = nums[i+1]\\n                        nums[i+1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647548,
                "title": "ts-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  let minIndex = 0;\\n  let maxIndex = nums.length - 1\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === 1) {\\n      minIndex = i\\n    } else if (nums[i] === nums.length) {\\n      maxIndex = i\\n    }\\n  }\\n  return minIndex + nums.length - 1 - maxIndex - (minIndex > maxIndex ? 1 : 0)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  let minIndex = 0;\\n  let maxIndex = nums.length - 1\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === 1) {\\n      minIndex = i\\n    } else if (nums[i] === nums.length) {\\n      maxIndex = i\\n    }\\n  }\\n  return minIndex + nums.length - 1 - maxIndex - (minIndex > maxIndex ? 1 : 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3647435,
                "title": "java-100-beats-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {int c= 0,j=0,k=0;\\n    if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n    {\\n        return 0;\\n    }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                j=i;\\n            }\\n            if(nums[i]==nums.length)\\n            {\\n                k=i;\\n            }\\n        }\\n        if(j<k)\\n        {\\n            c=(j-0)+(nums.length-1-k);\\n        }\\n        if(k<j)\\n        {\\n             c=(j-0)+(nums.length-1-k)-1;\\n        }\\n  return c;  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {int c= 0,j=0,k=0;\\n    if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n    {\\n        return 0;\\n    }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                j=i;\\n            }\\n            if(nums[i]==nums.length)\\n            {\\n                k=i;\\n            }\\n        }\\n        if(j<k)\\n        {\\n            c=(j-0)+(nums.length-1-k);\\n        }\\n        if(k<j)\\n        {\\n             c=(j-0)+(nums.length-1-k)-1;\\n        }\\n  return c;  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647048,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int count =0;\\n        int max = nums.Max();\\n        int maxIndex = Array.IndexOf(nums, max);\\n        int min = nums.Min();\\n        int minIndex = Array.IndexOf(nums, min);\\n        if(minIndex>maxIndex){\\n            maxIndex++;\\n        }\\n        count = minIndex + nums.Length-maxIndex-1;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int count =0;\\n        int max = nums.Max();\\n        int maxIndex = Array.IndexOf(nums, max);\\n        int min = nums.Min();\\n        int minIndex = Array.IndexOf(nums, min);\\n        if(minIndex>maxIndex){\\n            maxIndex++;\\n        }\\n        count = minIndex + nums.Length-maxIndex-1;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646155,
                "title": "eazy-to-understand-c-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) check if they are at there desired positions if yes ? return 0.\\n2) find position of 1 (oneIsAt), define a counter (count).\\n3) swap 1 to its desired position and count no.of swaps.\\n4) find the position of n, check whether the last element(n) is at its position if yes return count.\\n> step 4 is important because if we do not check this then n+1 in our next step would throw error \"Array Index Out Of Bound\".\\n5) Swap the n to its place and count no of swaps.\\n6) Return count.\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N) -> worst case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return 0;\\n        }\\n        int oneIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                oneIsAt = i;\\n            }\\n        }\\n       \\n        int count = 0;\\n        while(nums[0] != 1){\\n            swap(nums[oneIsAt] , nums[oneIsAt-1]);\\n            oneIsAt--;\\n            count ++;\\n        }\\n         int nIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == nums.size()){\\n                nIsAt = i;\\n            }\\n        }\\n         if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return count;\\n        }\\n        while(nums[nums.size()-1] != nums.size()){\\n            swap(nums[nIsAt] , nums[nIsAt+1]);\\n            nIsAt++;\\n            count ++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return 0;\\n        }\\n        int oneIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                oneIsAt = i;\\n            }\\n        }\\n       \\n        int count = 0;\\n        while(nums[0] != 1){\\n            swap(nums[oneIsAt] , nums[oneIsAt-1]);\\n            oneIsAt--;\\n            count ++;\\n        }\\n         int nIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == nums.size()){\\n                nIsAt = i;\\n            }\\n        }\\n         if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return count;\\n        }\\n        while(nums[nums.size()-1] != nums.size()){\\n            swap(nums[nIsAt] , nums[nIsAt+1]);\\n            nIsAt++;\\n            count ++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645742,
                "title": "python-3-code-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need to count swaps think like that...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n***Case 1*:**\\nFirst check is there any need to swap or not.\\n\\n***case 2*:**\\nCheck for *`nums[0] == 1`* if not find the index of` 1 `and store it to `i`(current index) just swap the previous index element with the current index because in question only we need to swap with adjacent element now every swap increase the count by `1`do this until `n` comes in into position.\\n\\n*****case 3***:**\\nCheck for *`nums[len(nums)-1] == len(nums)`* if not find the index of *`len(nums)`* and store it to `i`(current index) just swap the next index element with the current index because in question only we need to swap with adjacent element now every swap increase the count by `1` do this until `n` comes in into position.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        count = 0\\n\\n        #case 1\\n        if nums[0] == 1 and nums[len(nums)-1] == len(nums):\\n            return 0\\n\\n        #case 2\\n        if nums[0] != 1:  \\n            while nums[0] != 1:\\n                i = nums.index(1)                       #finding index\\n                nums[i],nums[i-1] = nums[i-1],nums[i]   # swapping previous index with current index\\n                count += 1\\n\\n        #case 3\\n        if nums[len(nums)-1] != len(nums):  \\n            while nums[len(nums)-1] != len(nums):\\n                i = nums.index(len(nums))                   #finding index\\n                nums[i],nums[i+1] = nums[i+1],nums[i]       # swapping next index with current index\\n                count += 1\\n        \\n        return count\\n\\n```\\n\\nIf there is any mistake/suggestion please let me know below...\\uD83D\\uDC47",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        count = 0\\n\\n        #case 1\\n        if nums[0] == 1 and nums[len(nums)-1] == len(nums):\\n            return 0\\n\\n        #case 2\\n        if nums[0] != 1:  \\n            while nums[0] != 1:\\n                i = nums.index(1)                       #finding index\\n                nums[i],nums[i-1] = nums[i-1],nums[i]   # swapping previous index with current index\\n                count += 1\\n\\n        #case 3\\n        if nums[len(nums)-1] != len(nums):  \\n            while nums[len(nums)-1] != len(nums):\\n                i = nums.index(len(nums))                   #finding index\\n                nums[i],nums[i+1] = nums[i+1],nums[i]       # swapping next index with current index\\n                count += 1\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640995,
                "title": "easy-to-understand-solution-just-3-lines",
                "content": "## Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        first, n_th = nums.index(1), nums.index(n)\\n        return first + n - 1 - n_th - (first > n_th)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        first, n_th = nums.index(1), nums.index(n)\\n        return first + n - 1 - n_th - (first > n_th)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640484,
                "title": "100-beat-java-beginner-friendly-solution",
                "content": "#\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n     int n = nums.length;\\n     int a=0,b=0,c=0;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==1){\\n             a = i;\\n         }\\n     }\\n         while(nums[0]!=1){\\n             int temp = nums[a-1];\\n             nums[a-1] = nums[a];\\n             nums[a] = temp;\\n             a = a-1;\\n             c++;\\n         }\\n         for(int j=0;j<n;j++){\\n         if(nums[j]==n){\\n             b = j;\\n         }\\n     }\\n         while(nums[n-1]!=n && b+1<n){\\n             int t = nums[b+1];\\n             nums[b+1] = nums[b];\\n             nums[b] = t;\\n             b = b+1;\\n             c++;\\n         }\\n     return c;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n     int n = nums.length;\\n     int a=0,b=0,c=0;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==1){\\n             a = i;\\n         }\\n     }\\n         while(nums[0]!=1){\\n             int temp = nums[a-1];\\n             nums[a-1] = nums[a];\\n             nums[a] = temp;\\n             a = a-1;\\n             c++;\\n         }\\n         for(int j=0;j<n;j++){\\n         if(nums[j]==n){\\n             b = j;\\n         }\\n     }\\n         while(nums[n-1]!=n && b+1<n){\\n             int t = nums[b+1];\\n             nums[b+1] = nums[b];\\n             nums[b] = t;\\n             b = b+1;\\n             c++;\\n         }\\n     return c;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639729,
                "title": "c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int firstElIndex = -1;\\n        int lastElIndex = -1;\\n\\n        for(int i=0; i<nums.Length; i++){\\n            if(nums[i] == 1){\\n                firstElIndex = i;\\n            }\\n\\n            if(nums[i] == nums.Length){\\n                lastElIndex = i;\\n            }\\n        }\\n\\n        int numberOfSwaps = firstElIndex + nums.Length - lastElIndex - 1;\\n        return firstElIndex > lastElIndex ? numberOfSwaps - 1 : numberOfSwaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int firstElIndex = -1;\\n        int lastElIndex = -1;\\n\\n        for(int i=0; i<nums.Length; i++){\\n            if(nums[i] == 1){\\n                firstElIndex = i;\\n            }\\n\\n            if(nums[i] == nums.Length){\\n                lastElIndex = i;\\n            }\\n        }\\n\\n        int numberOfSwaps = firstElIndex + nums.Length - lastElIndex - 1;\\n        return firstElIndex > lastElIndex ? numberOfSwaps - 1 : numberOfSwaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639093,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        const auto index1 = find(begin(nums), end(nums), 1);\\n        const auto indexN = find(begin(nums), end(nums), nums.size());\\n        return distance(begin(nums), index1) + distance(indexN, end(nums)) - 1 - (indexN < index1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        const auto index1 = find(begin(nums), end(nums), 1);\\n        const auto indexN = find(begin(nums), end(nums), nums.size());\\n        return distance(begin(nums), index1) + distance(indexN, end(nums)) - 1 - (indexN < index1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629006,
                "title": "java-easy-solution-100-faster-o-n-time-complexity-o-1-space",
                "content": "# Intuition\\nFind total shifts needed to shift 1 and n to correct posiitons.\\n\\n# Approach\\nIf n is present before 1, we would need one less shift, as they both can be shifted once when they cross the path and it would count as 1 operation instead of 2.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = -1;\\n        int lastIndex = -1;\\n        int ops =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == 1) oneIndex = i;\\n            if(nums[i] == n) lastIndex = i; \\n        }\\n\\n        //Total Shifts to make 1 reach the start\\n        ops += oneIndex;\\n        //Total Shifts to make n reach the last.\\n        ops += (n-1)-lastIndex;\\n        //If n is before 1, we have to do one less shift.\\n        if(lastIndex < oneIndex) ops--;\\n\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = -1;\\n        int lastIndex = -1;\\n        int ops =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == 1) oneIndex = i;\\n            if(nums[i] == n) lastIndex = i; \\n        }\\n\\n        //Total Shifts to make 1 reach the start\\n        ops += oneIndex;\\n        //Total Shifts to make n reach the last.\\n        ops += (n-1)-lastIndex;\\n        //If n is before 1, we have to do one less shift.\\n        if(lastIndex < oneIndex) ops--;\\n\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628737,
                "title": "super-easy-2ms-java-code",
                "content": "# APPROACH \\nfind index-i of 1 ie i operations needed\\nfind index-j of n ie n-j-1 operations needed\\nadd both i+j\\nand if j<i then do -1\\n\\n#\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\n class Solution{\\n    public int semiOrderedPermutation(int[] nums) \\n    {\\n        int n=nums.length,res=0,indexOf1=0,indexOfn=n;\\n        for(int i=0;i<n;i++)\\n        {\\n        if(nums[i]==1) indexOf1=i;\\n        if(nums[i]==n) indexOfn=i;\\n        }\\n        res=n+ indexOf1-indexOfn-1;\\n         if(indexOfn<indexOf1)\\n         res--;\\n         return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution{\\n    public int semiOrderedPermutation(int[] nums) \\n    {\\n        int n=nums.length,res=0,indexOf1=0,indexOfn=n;\\n        for(int i=0;i<n;i++)\\n        {\\n        if(nums[i]==1) indexOf1=i;\\n        if(nums[i]==n) indexOfn=i;\\n        }\\n        res=n+ indexOf1-indexOfn-1;\\n         if(indexOfn<indexOf1)\\n         res--;\\n         return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627502,
                "title": "iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                one=i\\n            elif nums[i] ==len(nums):\\n                last=i\\n        if one<last:\\n            return one+(len(nums)-1-last)\\n        else:\\n            return one+(len(nums)-1-last)-1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                one=i\\n            elif nums[i] ==len(nums):\\n                last=i\\n        if one<last:\\n            return one+(len(nums)-1-last)\\n        else:\\n            return one+(len(nums)-1-last)-1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625619,
                "title": "c-solution",
                "content": "```\\nint semiOrderedPermutation(vector<int>& nums) {\\n\\tauto mn = min_element(begin(nums), end(nums));\\n\\tauto mx = max_element(begin(nums), end(nums));\\n\\tint stPos = distance(begin(nums), mn);\\n\\tint endPos = distance(begin(nums), mx);\\n\\tint res = stPos + nums.size() - endPos - 1;\\n\\treturn res < nums.size() ? res : res - 1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint semiOrderedPermutation(vector<int>& nums) {\\n\\tauto mn = min_element(begin(nums), end(nums));\\n\\tauto mx = max_element(begin(nums), end(nums));\\n\\tint stPos = distance(begin(nums), mn);\\n\\tint endPos = distance(begin(nums), mx);\\n\\tint res = stPos + nums.size() - endPos - 1;\\n\\treturn res < nums.size() ? res : res - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625459,
                "title": "from-simulation-to-formula",
                "content": "**Simulation: brute-force**\\n1. Find pos of `min` and `max` values\\n2. Simulate what you would do with swaps on an array:\\n- swap `max` right till you have `[N - 1] = N`\\n- swap `min` left till you have `[0] = 1`\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = max_pos = 0\\n        for i in range(N):\\n            if nums[i] == 1:\\n                min_pos = i\\n            if nums[i] == N:\\n                max_pos = i\\n        count = 0\\n        while nums[0] != 1 or nums[N - 1] != N:\\n            if nums[0] != 1:\\n                nums[min_pos], nums[min_pos - 1] = nums[min_pos - 1], nums[min_pos]\\n                if nums[min_pos] == N:\\n                    max_pos += 1\\n                min_pos -= 1\\n            elif nums[N - 1] != N:\\n                nums[max_pos], nums[max_pos + 1] = nums[max_pos + 1], nums[max_pos]\\n                if nums[max_pos] == 1:\\n                    min_pos -= 1\\n                max_pos += 1\\n            count += 1\\n        return count\\n```\\n\\n**Formula**\\nAnalysis of what simulaton does:\\nSimulate what you would do with swaps on an array:\\n- swap `max` right till you have `[N - 1] = N`\\n- swap `min` left till you have `[0] = 1`\\n\\n2 examples would be enough to show observations and logic:\\n\\n1 ) `min_pos` does not cross `max_pos` position\\n```\\n<---- ---->\\n3 2 1 6 5 4\\n  1 # 1 swap\\n1 # 1 swap\\n        6 # 1 swap\\n          6 # 1 swap\\n```\\n2 ) `min_pos` crosses `max_pos` position\\n```\\n<---- ---->\\n6 5 4 3 2 1\\n  6 # 1 swap\\n    6 # 1 swap\\n      6 # 1 swap\\n        6 # 1 swap\\n\\n*** !!! This is the important moment, when min_pos and max_pos are in adjacent positions !!! ***\\n6 5 4 3[6 1]\\n       [1 6] # 1 swap, but this swap also swaps 1 to the left by 1 !!! This is a free ride for min_pos left by 1 pos!!!\\n```\\nSo you need to calc travel for `min_pos` to get to `[0]` + `max_pos` to get to `[N-1]` - 1 pos if you have case #2 (`min_pos` > `max_pos`)\\n\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = nums.index(1)\\n        max_pos = nums.index(N)\\n\\t\\t# min_pos to [0] + max_pos to [N - 1] - free ride, if any\\n        return (min_pos) + (N - 1 - max_pos) - (min_pos > max_pos)\\n```\\n\\nFor 1-line fans:\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        return (min_pos := nums.index(1)) + (N := len(nums)) - 1 - (max_pos := nums.index(N)) - (min_pos > max_pos)\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = max_pos = 0\\n        for i in range(N):\\n            if nums[i] == 1:\\n                min_pos = i\\n            if nums[i] == N:\\n                max_pos = i\\n        count = 0\\n        while nums[0] != 1 or nums[N - 1] != N:\\n            if nums[0] != 1:\\n                nums[min_pos], nums[min_pos - 1] = nums[min_pos - 1], nums[min_pos]\\n                if nums[min_pos] == N:\\n                    max_pos += 1\\n                min_pos -= 1\\n            elif nums[N - 1] != N:\\n                nums[max_pos], nums[max_pos + 1] = nums[max_pos + 1], nums[max_pos]\\n                if nums[max_pos] == 1:\\n                    min_pos -= 1\\n                max_pos += 1\\n            count += 1\\n        return count\\n```\n```\\n<---- ---->\\n3 2 1 6 5 4\\n  1 # 1 swap\\n1 # 1 swap\\n        6 # 1 swap\\n          6 # 1 swap\\n```\n```\\n<---- ---->\\n6 5 4 3 2 1\\n  6 # 1 swap\\n    6 # 1 swap\\n      6 # 1 swap\\n        6 # 1 swap\\n\\n*** !!! This is the important moment, when min_pos and max_pos are in adjacent positions !!! ***\\n6 5 4 3[6 1]\\n       [1 6] # 1 swap, but this swap also swaps 1 to the left by 1 !!! This is a free ride for min_pos left by 1 pos!!!\\n```\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = nums.index(1)\\n        max_pos = nums.index(N)\\n\\t\\t# min_pos to [0] + max_pos to [N - 1] - free ride, if any\\n        return (min_pos) + (N - 1 - max_pos) - (min_pos > max_pos)\\n```\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        return (min_pos := nums.index(1)) + (N := len(nums)) - 1 - (max_pos := nums.index(N)) - (min_pos > max_pos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621951,
                "title": "c-no-swap-o-n",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int p1 = -1, pn = -1, n = nums.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                p1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                pn = i;\\n            }\\n        }\\n\\n        return p1 + (n - pn - 1) - (p1 > pn);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int p1 = -1, pn = -1, n = nums.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                p1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                pn = i;\\n            }\\n        }\\n\\n        return p1 + (n - pn - 1) - (p1 > pn);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621126,
                "title": "using-index-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                f = i\\n            elif nums[i] == len(nums):\\n                l = i\\n        if l<f:\\n            return len(nums)-1-l+f-1\\n        else:\\n            return len(nums)-1-l+f\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                f = i\\n            elif nums[i] == len(nums):\\n                l = i\\n        if l<f:\\n            return len(nums)-1-l+f-1\\n        else:\\n            return len(nums)-1-l+f\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619924,
                "title": "elixir-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 381ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 62.4MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec semi_ordered_permutation(nums :: [integer]) :: integer\\n  def semi_ordered_permutation(nums) do\\n    n = Enum.count(nums)\\n    {_, {pos1, pos2}} =\\n      Enum.reduce(nums, {0, {0, 0}}, fn num, {i, {pos1, pos2}} ->\\n        cond do\\n          num == 1 ->\\n            {i + 1, {i, pos2}}\\n          num == n ->\\n            {i + 1, {pos1, i}}\\n          true ->\\n            {i + 1, {pos1, pos2}}\\n        end\\n      end)\\n    if pos1 > pos2, do: pos1 + n - 1 - pos2 - 1, else: pos1 + n - 1 - pos2\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec semi_ordered_permutation(nums :: [integer]) :: integer\\n  def semi_ordered_permutation(nums) do\\n    n = Enum.count(nums)\\n    {_, {pos1, pos2}} =\\n      Enum.reduce(nums, {0, {0, 0}}, fn num, {i, {pos1, pos2}} ->\\n        cond do\\n          num == 1 ->\\n            {i + 1, {i, pos2}}\\n          num == n ->\\n            {i + 1, {pos1, i}}\\n          true ->\\n            {i + 1, {pos1, pos2}}\\n        end\\n      end)\\n    if pos1 > pos2, do: pos1 + n - 1 - pos2 - 1, else: pos1 + n - 1 - pos2\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3619531,
                "title": "java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int p1 = 0,pn = 0;\\n        for(int i = 0;i < nums.length;i++){\\n            if(nums[i] == 1) p1 = i;\\n            else if(nums[i] == nums.length) pn = i;\\n        }\\n        int ans = p1 + nums.length - 1 - pn;\\n        if(p1 > pn) --ans; // because in this case `1` and `n` will share one common swap\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int p1 = 0,pn = 0;\\n        for(int i = 0;i < nums.length;i++){\\n            if(nums[i] == 1) p1 = i;\\n            else if(nums[i] == nums.length) pn = i;\\n        }\\n        int ans = p1 + nums.length - 1 - pn;\\n        if(p1 > pn) --ans; // because in this case `1` and `n` will share one common swap\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619471,
                "title": "easy-clean-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a very straightforward approach, we can simply, easily simulate it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep track of the given indices of 1 and the last element. Perform swaps and calculate swaps to find the required answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the size of nums\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        reqd = {1:0, n:(n-1)}\\n        given = {1:0, n:0}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                given[1] = i\\n            if nums[i] == n:\\n                given[n] = i\\n        if given == reqd: return 0\\n        if given[n] < given[1]:\\n            return n-1-given[n]+given[1]-1\\n        else:\\n            return given[1] + (n-1) - given[n]\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        reqd = {1:0, n:(n-1)}\\n        given = {1:0, n:0}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                given[1] = i\\n            if nums[i] == n:\\n                given[n] = i\\n        if given == reqd: return 0\\n        if given[n] < given[1]:\\n            return n-1-given[n]+given[1]-1\\n        else:\\n            return given[1] + (n-1) - given[n]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619132,
                "title": "find-positions-and-return",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let fPos = 0;\\n    let lPos = 0;\\n    const n = nums.length;\\n    for(let i=0; i<n; i++) {\\n        if(nums[i] == 1) fPos = i;\\n        else if(nums[i] == n) lPos = i;\\n    }\\n    \\n    return lPos < fPos? (n - lPos + fPos - 2) : (n - lPos + fPos - 1); \\n    \\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let fPos = 0;\\n    let lPos = 0;\\n    const n = nums.length;\\n    for(let i=0; i<n; i++) {\\n        if(nums[i] == 1) fPos = i;\\n        else if(nums[i] == n) lPos = i;\\n    }\\n    \\n    return lPos < fPos? (n - lPos + fPos - 2) : (n - lPos + fPos - 1); \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619013,
                "title": "java-solution-easy-to-understand-swap-2ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int s=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                s=i;\\n                break;\\n            }\\n        }\\n        int e=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==nums.length){\\n                e=i;\\n                break;\\n            }\\n        }\\n        int s1=s;\\n        int e1=e;\\n        int c=0;\\n        while(e!=nums.length-1){\\n            c++;\\n            e++;\\n        }\\n        while(s!=0){\\n            c++;\\n            s--;\\n        }\\n        if(s1>e1)return c-1;\\n        else return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int s=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                s=i;\\n                break;\\n            }\\n        }\\n        int e=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==nums.length){\\n                e=i;\\n                break;\\n            }\\n        }\\n        int s1=s;\\n        int e1=e;\\n        int c=0;\\n        while(e!=nums.length-1){\\n            c++;\\n            e++;\\n        }\\n        while(s!=0){\\n            c++;\\n            s--;\\n        }\\n        if(s1>e1)return c-1;\\n        else return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618551,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min_indx = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int max_indx = max_element(nums.begin(),nums.end()) - nums.begin();\\n        int n = nums.size();\\n        int cnt = 0;\\n        cnt += (min_indx);\\n        cnt += (n-1-max_indx);\\n        //this is because if max_indx is less than min_indx then by swaping the max_indx will get increase by 1;\\n        if(min_indx>max_indx){\\n            cnt--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min_indx = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int max_indx = max_element(nums.begin(),nums.end()) - nums.begin();\\n        int n = nums.size();\\n        int cnt = 0;\\n        cnt += (min_indx);\\n        cnt += (n-1-max_indx);\\n        //this is because if max_indx is less than min_indx then by swaping the max_indx will get increase by 1;\\n        if(min_indx>max_indx){\\n            cnt--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618477,
                "title": "2ms-100-java-solution",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        int index1=0;\\n        int indexn=0;\\n        int n=nums.length;\\n        if(n==1)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n            }\\n            else if(nums[i]==n)\\n            {\\n                indexn=i;\\n            }\\n        }\\n        int carry=(index1>indexn)?1:0;\\n        return index1+(n-indexn-1)-carry;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        int index1=0;\\n        int indexn=0;\\n        int n=nums.length;\\n        if(n==1)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n            }\\n            else if(nums[i]==n)\\n            {\\n                indexn=i;\\n            }\\n        }\\n        int carry=(index1>indexn)?1:0;\\n        return index1+(n-indexn-1)-carry;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618086,
                "title": "simulate-the-process-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums)\\n    {\\n          int count = 0;\\n          //we can just simulate the whole process using the loop or iteratons\\n\\n          //we need to find the position of the 1 in the nums vector\\n          int onepos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == 1)\\n              {\\n                  onepos = i;\\n                  break;\\n              }\\n          }\\n          if(onepos != 0)\\n          {\\n               while(onepos != 0)\\n               {\\n                   int temp       = nums[onepos-1];\\n                   nums[onepos-1] = nums[onepos];\\n                   nums[onepos]   = temp;\\n                   count++;\\n\\n                   onepos = onepos - 1;   \\n               }\\n          }\\n\\n          //we need to fnd the positon of the n in the nums vector\\n          int npos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == nums.size())\\n              {\\n                  npos = i;\\n                  break;\\n              }\\n          }\\n          if(npos != nums.size()-1)\\n          {\\n               while(npos != nums.size()-1)\\n               {\\n                   int temp       = nums[npos+1];\\n                   nums[npos+1] = nums[npos];\\n                   nums[npos]   = temp;\\n                   count++;\\n\\n                   npos = npos + 1;   \\n               }\\n          }\\n          return count;          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums)\\n    {\\n          int count = 0;\\n          //we can just simulate the whole process using the loop or iteratons\\n\\n          //we need to find the position of the 1 in the nums vector\\n          int onepos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == 1)\\n              {\\n                  onepos = i;\\n                  break;\\n              }\\n          }\\n          if(onepos != 0)\\n          {\\n               while(onepos != 0)\\n               {\\n                   int temp       = nums[onepos-1];\\n                   nums[onepos-1] = nums[onepos];\\n                   nums[onepos]   = temp;\\n                   count++;\\n\\n                   onepos = onepos - 1;   \\n               }\\n          }\\n\\n          //we need to fnd the positon of the n in the nums vector\\n          int npos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == nums.size())\\n              {\\n                  npos = i;\\n                  break;\\n              }\\n          }\\n          if(npos != nums.size()-1)\\n          {\\n               while(npos != nums.size()-1)\\n               {\\n                   int temp       = nums[npos+1];\\n                   nums[npos+1] = nums[npos];\\n                   nums[npos]   = temp;\\n                   count++;\\n\\n                   npos = npos + 1;   \\n               }\\n          }\\n          return count;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616433,
                "title": "easy-python-just-find-the-index-of-1-and-n",
                "content": "\\tclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)+1\\n        j=nums.index(n)+1\\n        if i<j:\\n            return (n-j)+(i-1)\\n        else:\\n            return (n-j)+(i-1) -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)+1\\n        j=nums.index(n)+1\\n        if i<j:\\n            return (n-j)+(i-1)\\n        else:\\n            return (n-j)+(i-1) -1",
                "codeTag": "Java"
            },
            {
                "id": 3615997,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def semiOrderedPermutation(nums: Array[Int]): Int = {\\n    val n = nums.length\\n    val left = nums.indexOf(1)\\n    val right = nums.indexOf(n)\\n    left + (n - 1 - right) - (if(left > right) 1 else 0)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def semiOrderedPermutation(nums: Array[Int]): Int = {\\n    val n = nums.length\\n    val left = nums.indexOf(1)\\n    val right = nums.indexOf(n)\\n    left + (n - 1 - right) - (if(left > right) 1 else 0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3615811,
                "title": "c-basic-searching-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int  n=size(nums),i=find(begin(nums),end(nums),1)-begin(nums),j=find(begin(nums),end(nums),n)-begin(nums);\\n        return n-1-j+i-(i>j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int  n=size(nums),i=find(begin(nums),end(nums),1)-begin(nums),j=find(begin(nums),end(nums),n)-begin(nums);\\n        return n-1-j+i-(i>j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615465,
                "title": "c-python-code-easy-to-understanf",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx1 , idxn , n = nums.size() ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                idx1 = i ;\\n            }\\n            else if(nums[i] == n)\\n            {\\n                idxn = i ;\\n            }\\n        }\\n        return idx1 > idxn ? idx1 + (n - idxn) - 2 : idx1 + (n - idxn) - 1 ;\\n    }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        val1 = -1\\n        valn = -1\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] == 1:\\n                val1 = i\\n            elif nums[i] == n:\\n                valn = i\\n        if val1 > valn:\\n            return val1 + (n - valn) - 2\\n        return val1 + (n-valn) - 1\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx1 , idxn , n = nums.size() ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                idx1 = i ;\\n            }\\n            else if(nums[i] == n)\\n            {\\n                idxn = i ;\\n            }\\n        }\\n        return idx1 > idxn ? idx1 + (n - idxn) - 2 : idx1 + (n - idxn) - 1 ;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        val1 = -1\\n        valn = -1\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] == 1:\\n                val1 = i\\n            elif nums[i] == n:\\n                valn = i\\n        if val1 > valn:\\n            return val1 + (n - valn) - 2\\n        return val1 + (n-valn) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615378,
                "title": "python-3",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        f, l = nums.index(1), nums.index(n)\\n\\n        if f < l:\\n            return f + (n - 1 - l)\\n\\n        else:\\n            return f + (n - 1 - l - 1)\\n\\n        \\n        \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        f, l = nums.index(1), nums.index(n)\\n\\n        if f < l:\\n            return f + (n - 1 - l)\\n\\n        else:\\n            return f + (n - 1 - l - 1)\\n\\n        \\n        \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614690,
                "title": "simple-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        last=max(nums)\\n        if(nums[0]==1 and nums[-1]==last):\\n            return 0\\n        count=0\\n        while(nums[0]!=1):\\n            index1=nums.index(1)\\n            i=index1-1\\n            nums[index1], nums[i]=nums[i],nums[index1]\\n            count+=1\\n            \\n        while(nums[len(nums)-1]!=last):\\n            indexlast=nums.index(last)\\n            i=indexlast+1\\n            nums[indexlast], nums[i]=nums[i],nums[indexlast]\\n            count+=1\\n        \\n        return count\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        last=max(nums)\\n        if(nums[0]==1 and nums[-1]==last):\\n            return 0\\n        count=0\\n        while(nums[0]!=1):\\n            index1=nums.index(1)\\n            i=index1-1\\n            nums[index1], nums[i]=nums[i],nums[index1]\\n            count+=1\\n            \\n        while(nums[len(nums)-1]!=last):\\n            indexlast=nums.index(last)\\n            i=indexlast+1\\n            nums[indexlast], nums[i]=nums[i],nums[indexlast]\\n            count+=1\\n        \\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613943,
                "title": "best-solution-with-example-beats-100-without-swapping",
                "content": "# Intuition\\nproblem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\n\\nfind index of minimum element i.e 1 and maximum element i.e nums.length\\n\\nthat means elements before index1 and after index2 have to be swapped \\n![20230608_192346.jpg](https://assets.leetcode.com/users/images/b3a4eeea-66de-4fd8-8c4f-8d8ca9709d4d_1686232773.1585362.jpeg)\\n\\nwhat if index2<index1 you can you figure it out by your own? :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index1 =0;\\n        int index2 =0;\\n        \\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1 =i;\\n                continue;\\n            }\\n            \\n            if(nums[i]==nums.length){\\n                index2 = i;\\n                continue;\\n            }\\n        }\\n        \\n        if(index2<index1){\\n            index2 = nums.length-1 - index2;\\n            \\n            return (index1+index2)-1;\\n        }\\n        \\n        index2 = nums.length -1 - index2;\\n        \\n        return (index1+index2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index1 =0;\\n        int index2 =0;\\n        \\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1 =i;\\n                continue;\\n            }\\n            \\n            if(nums[i]==nums.length){\\n                index2 = i;\\n                continue;\\n            }\\n        }\\n        \\n        if(index2<index1){\\n            index2 = nums.length-1 - index2;\\n            \\n            return (index1+index2)-1;\\n        }\\n        \\n        index2 = nums.length -1 - index2;\\n        \\n        return (index1+index2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613588,
                "title": "java-simple-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n public int semiOrderedPermutation(int[] nums) {\\n    int indexOf1 = -1, indexOfN = -1;\\n    for(int i = 0; i < nums.length; i++){\\n        if(nums[i] == 1) indexOf1 = i;\\n        else if(nums[i] == nums.length) indexOfN = i;\\n    }\\n    return indexOf1 + nums.length - 1 - indexOfN - ((indexOfN < indexOf1) ? 1 : 0) ;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int semiOrderedPermutation(int[] nums) {\\n    int indexOf1 = -1, indexOfN = -1;\\n    for(int i = 0; i < nums.length; i++){\\n        if(nums[i] == 1) indexOf1 = i;\\n        else if(nums[i] == nums.length) indexOfN = i;\\n    }\\n    return indexOf1 + nums.length - 1 - indexOfN - ((indexOfN < indexOf1) ? 1 : 0) ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611842,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=fun1(nums)+fun2(nums);\\n        return ans;\\n    }\\n    int fun1(vector<int>&nums)\\n    {\\n        if(nums[0]==1)\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                swap(nums[i],nums[i-1]);\\n                return 1+fun1(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n    int fun2(vector<int>&nums)\\n    {\\n        if(nums[nums.size()-1]==nums.size())\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                swap(nums[i],nums[i+1]);\\n                return 1+fun2(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=fun1(nums)+fun2(nums);\\n        return ans;\\n    }\\n    int fun1(vector<int>&nums)\\n    {\\n        if(nums[0]==1)\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                swap(nums[i],nums[i-1]);\\n                return 1+fun1(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n    int fun2(vector<int>&nums)\\n    {\\n        if(nums[nums.size()-1]==nums.size())\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                swap(nums[i],nums[i+1]);\\n                return 1+fun2(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611295,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        var min = (int.MaxValue, 0);\\n        var max = (0, 0);\\n        for(var i = 0; i < nums.Length; i++){\\n            if(nums[i] < min.Item1)\\n                min = (nums[i], i);\\n            if(nums[i] > max.Item1)\\n                max = (nums[i], i);\\n        }\\n\\n        if(min.Item2 > max.Item2)\\n            return min.Item2 + (nums.Length - 2 - max.Item2);\\n        else\\n            return min.Item2 + (nums.Length - 1 - max.Item2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        var min = (int.MaxValue, 0);\\n        var max = (0, 0);\\n        for(var i = 0; i < nums.Length; i++){\\n            if(nums[i] < min.Item1)\\n                min = (nums[i], i);\\n            if(nums[i] > max.Item1)\\n                max = (nums[i], i);\\n        }\\n\\n        if(min.Item2 > max.Item2)\\n            return min.Item2 + (nums.Length - 2 - max.Item2);\\n        else\\n            return min.Item2 + (nums.Length - 1 - max.Item2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610955,
                "title": "js-solution-95-ms",
                "content": "# Complexity\\n- Time complexity:\\n95 ms\\n\\n- Space complexity:\\n45.5 MB\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n  const indexMin = nums.indexOf(Math.min(...nums))\\n  const indexMax = nums.indexOf(Math.max(...nums))\\n\\n  if(indexMin > indexMax){\\n    return indexMin + nums.length - 1 - indexMax - 1\\n  } else {\\n    return indexMin + nums.length - 1 - indexMax\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n  const indexMin = nums.indexOf(Math.min(...nums))\\n  const indexMax = nums.indexOf(Math.max(...nums))\\n\\n  if(indexMin > indexMax){\\n    return indexMin + nums.length - 1 - indexMax - 1\\n  } else {\\n    return indexMin + nums.length - 1 - indexMax\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610805,
                "title": "simple-formula",
                "content": "\\n# Code\\n```\\ndef semiOrderedPermutation(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    return nums.index(1) + n - 1 - nums.index(n) - int(nums.index(1) > nums.index(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef semiOrderedPermutation(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    return nums.index(1) + n - 1 - nums.index(n) - int(nums.index(1) > nums.index(n))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3609704,
                "title": "easyyyyy",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        c1=0\\n        cn=0\\n        ind1=nums.index(1)\\n        for i in range(ind1-1,-1,-1):\\n            if nums[i]!=n:\\n                c1+=1\\n        indn=nums.index(n)\\n        for j in range(indn+1,n):\\n            cn+=1\\n        return c1+cn\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        c1=0\\n        cn=0\\n        ind1=nums.index(1)\\n        for i in range(ind1-1,-1,-1):\\n            if nums[i]!=n:\\n                c1+=1\\n        indn=nums.index(n)\\n        for j in range(indn+1,n):\\n            cn+=1\\n        return c1+cn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609283,
                "title": "pure-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        \\n        int n = nums.length;\\n        int r1=0;\\n        int r2=0;\\n        while (true) {\\n            if(nums[0]==1 && nums[n-1]==n){\\n                break;\\n            }\\n            while(nums[0]!=1){\\n                int first = getPosition(1,nums);\\n                swap(first,first-1,nums);\\n                r1++;\\n            }\\n            while(nums[n-1]!=n){\\n                int last = getPosition(n,nums);\\n                swap(last,last+1,nums);\\n                r2++;\\n            }\\n        }\\n        int result = r1+r2;\\n        return result;\\n        \\n    }\\n    \\n     public static void swap(int a,int b,int[] nums){\\n\\n        int temp= nums[a];\\n        nums[a]= nums[b];\\n        nums[b]=temp;\\n\\n//        System.out.println(\"a\"+a+\"b\"+b);\\n    }\\n\\n    public static int getPosition(int a,int[] nums){\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==a){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        \\n        int n = nums.length;\\n        int r1=0;\\n        int r2=0;\\n        while (true) {\\n            if(nums[0]==1 && nums[n-1]==n){\\n                break;\\n            }\\n            while(nums[0]!=1){\\n                int first = getPosition(1,nums);\\n                swap(first,first-1,nums);\\n                r1++;\\n            }\\n            while(nums[n-1]!=n){\\n                int last = getPosition(n,nums);\\n                swap(last,last+1,nums);\\n                r2++;\\n            }\\n        }\\n        int result = r1+r2;\\n        return result;\\n        \\n    }\\n    \\n     public static void swap(int a,int b,int[] nums){\\n\\n        int temp= nums[a];\\n        nums[a]= nums[b];\\n        nums[b]=temp;\\n\\n//        System.out.println(\"a\"+a+\"b\"+b);\\n    }\\n\\n    public static int getPosition(int a,int[] nums){\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==a){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608830,
                "title": "easy-cpp-solution-6-line-code",
                "content": "\\n# Approach\\nfind min and max element index by using stl (min & max element)\\nif max is left of min then \\nwe find min index from start ans max index from end \\nboth add and -1 for (one we swap both)\\notherwise we simple max from end index \\nadd min and max index then return add of both\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n- 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min=min_element(nums.begin(),nums.end())-nums.begin();\\n        int max=max_element(nums.begin(),nums.end())-nums.begin();\\n        if(max<min){\\n            max=(nums.size()-1)-max;\\n            return (max+min)-1;\\n        }\\n        max=(nums.size()-1)-max;\\n        return max+min;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min=min_element(nums.begin(),nums.end())-nums.begin();\\n        int max=max_element(nums.begin(),nums.end())-nums.begin();\\n        if(max<min){\\n            max=(nums.size()-1)-max;\\n            return (max+min)-1;\\n        }\\n        max=(nums.size()-1)-max;\\n        return max+min;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608172,
                "title": "straight-forward",
                "content": "# Intuition\\nbased on the location of 1 and the nums.length\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index_of_first = 0;\\n        int index_of_last = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1)\\n                index_of_first = i;\\n            if (nums[i] == nums.length)\\n                index_of_last = i;\\n        }\\n\\n        if (index_of_first > index_of_last) {\\n            return index_of_first + nums.length - 1 - index_of_last - 1;\\n        } else {\\n            return index_of_first + nums.length - 1 - index_of_last;\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index_of_first = 0;\\n        int index_of_last = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1)\\n                index_of_first = i;\\n            if (nums[i] == nums.length)\\n                index_of_last = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3608123,
                "title": "recursive-swapping",
                "content": "# Intuition\\nRecursive swapping.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       boolean checkForCross=true;\\n       int global_first=0;\\n       int global_second=0;\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        int first=0;\\n        int second=0;\\n     \\n        if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n        return 0;\\n       else if(nums[0]==1)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==nums.length)\\n                {\\n                    return nums.length-i-1;\\n                }\\n            }\\n        }\\n       else if(nums[nums.length-1]==nums.length)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n            global_first=first;global_second=second;\\n\\n           int finalResult=swap(nums,first,second);\\n           return finalResult;\\n        }\\n        return -1;\\n    }\\n    \\n    public int swap(int[] nums,int first,int second)\\n    {\\nif(nums[0]==1 && checkForCross==false)return global_first+(nums.length-1-global_second)-1;\\nif(nums[0]==1 && checkForCross==true)return global_first+(nums.length-1-global_second);\\n       for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n       if(second==first-1)checkForCross=false;\\n       int dummy=nums[first];\\n       nums[first]=nums[first-1];\\n       nums[first-1]=dummy;\\n       return swap(nums,first,second);\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       boolean checkForCross=true;\\n       int global_first=0;\\n       int global_second=0;\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        int first=0;\\n        int second=0;\\n     \\n        if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n        return 0;\\n       else if(nums[0]==1)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==nums.length)\\n                {\\n                    return nums.length-i-1;\\n                }\\n            }\\n        }\\n       else if(nums[nums.length-1]==nums.length)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n            global_first=first;global_second=second;\\n\\n           int finalResult=swap(nums,first,second);\\n           return finalResult;\\n        }\\n        return -1;\\n    }\\n    \\n    public int swap(int[] nums,int first,int second)\\n    {\\nif(nums[0]==1 && checkForCross==false)return global_first+(nums.length-1-global_second)-1;\\nif(nums[0]==1 && checkForCross==true)return global_first+(nums.length-1-global_second);\\n       for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n       if(second==first-1)checkForCross=false;\\n       int dummy=nums[first];\\n       nums[first]=nums[first-1];\\n       nums[first-1]=dummy;\\n       return swap(nums,first,second);\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607981,
                "title": "ez-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = -1, high = -1;\\n        if(nums[0] == 1 and nums[n-1] == n) return 0;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1)\\n              low = i;\\n            else if(nums[i] == n)\\n              high = i;\\n        }\\n        if(low > high) return (low - 0) + (n - 1 - high) - 1;\\n        else return (low - 0) + (n - 1 - high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = -1, high = -1;\\n        if(nums[0] == 1 and nums[n-1] == n) return 0;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1)\\n              low = i;\\n            else if(nums[i] == n)\\n              high = i;\\n        }\\n        if(low > high) return (low - 0) + (n - 1 - high) - 1;\\n        else return (low - 0) + (n - 1 - high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607180,
                "title": "python-simple-and-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe calculate the difference between indedx and the value of 1 or n. The difference is the number of steps required.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the absolute difference of (index of 1 - 1) and (index of n - n). Sum the difference and that is the return value.\\n\\nAfter each operation, we would re-order the list to mimic the swap action. (Slower but intuitive)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        cnt = 0 \\n\\n        for i in [1, len(nums)]:\\n            if nums.index(i) != i - 1:\\n                cnt += abs(nums.index(i) - (i - 1))\\n                if i == 1:\\n                    nums[i-1:i-1] = [nums.pop(nums.index(i))] # Swap the location\\n\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        cnt = 0 \\n\\n        for i in [1, len(nums)]:\\n            if nums.index(i) != i - 1:\\n                cnt += abs(nums.index(i) - (i - 1))\\n                if i == 1:\\n                    nums[i-1:i-1] = [nums.pop(nums.index(i))] # Swap the location\\n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606980,
                "title": "javascript-tc-o-n-sc-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n \\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const n = nums.length;\\n    let fi = -1, li = -1;\\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] === 1) {\\n            fi = i;\\n        } else if (nums[i] === n) {\\n            li = i;\\n        }\\n    }\\n    let ans = fi - 0 + n - 1 - li;\\n    if (li < fi) {\\n        ans--;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n \\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const n = nums.length;\\n    let fi = -1, li = -1;\\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] === 1) {\\n            fi = i;\\n        } else if (nums[i] === n) {\\n            li = i;\\n        }\\n    }\\n    let ans = fi - 0 + n - 1 - li;\\n    if (li < fi) {\\n        ans--;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605904,
                "title": "100-fast-java-c-explain-with-images",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**step 1.** find min and max number **index** as **min** and **max** variable\\n**step 2.** for min to **0th** index there are **min - 0** swaps == min swaps\\n**step 3.** for max to **end** index there are **end - max** swaps\\n**step 4.** totalswaps = min + (end - max)\\n\\n**step 5.** if (min < max), return totalswaps\\n            else return totalswaps -1;\\n**NOTE:: here, -1 because min and max swap count added twice as shown below**\\n![1686072871283.jpg](https://assets.leetcode.com/users/images/5dff1329-02cb-4ea3-906e-65d31d9d08c3_1686074160.5710166.jpeg)\\n\\n![1686072871276.jpg](https://assets.leetcode.com/users/images/ad8a8733-9486-47c8-90d2-ef4587983f06_1686074103.3038957.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0] == 1 && nums[nums.length-1] == nums.length) return 0;\\n        int end = nums.length-1;\\n        int min = 0;\\n        int max = end;\\n        \\n        for(int i=0; i< nums.length;i++){\\n            if(nums[i] == nums.length){\\n                max = i;\\n            }\\n            if(nums[i] == 1){\\n                min = i;\\n            }\\n        }\\n        int totalSwaps = min + (end - max);\\n        if(min < max) return totalSwaps;\\n\\n        else return totalSwaps  - 1; //because max and min are already swapped \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0] == 1 && nums[nums.length-1] == nums.length) return 0;\\n        int end = nums.length-1;\\n        int min = 0;\\n        int max = end;\\n        \\n        for(int i=0; i< nums.length;i++){\\n            if(nums[i] == nums.length){\\n                max = i;\\n            }\\n            if(nums[i] == 1){\\n                min = i;\\n            }\\n        }\\n        int totalSwaps = min + (end - max);\\n        if(min < max) return totalSwaps;\\n\\n        else return totalSwaps  - 1; //because max and min are already swapped \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603696,
                "title": "c-o-n-solution-without-extra-space",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size(), index1 = -1, index2 = -1;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        for (int i=0;i<n;i++) {\\n            if (nums[i] == 1) {\\n                index1 = i;\\n            } \\n            if (nums[i] == n) {\\n                index2 = i;\\n            }\\n        }\\n        if (index1 < index2) {\\n            return index1 + n - 1 - index2;\\n        } else {\\n            return index2 + n - 1 - index1 + 2*(index1 - index2 - 1) + 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size(), index1 = -1, index2 = -1;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        for (int i=0;i<n;i++) {\\n            if (nums[i] == 1) {\\n                index1 = i;\\n            } \\n            if (nums[i] == n) {\\n                index2 = i;\\n            }\\n        }\\n        if (index1 < index2) {\\n            return index1 + n - 1 - index2;\\n        } else {\\n            return index2 + n - 1 - index1 + 2*(index1 - index2 - 1) + 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603326,
                "title": "java-simple-solution-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int firstNumber = 0;\\n        int lastNumber = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                firstNumber = i;\\n            }\\n            if (nums[i] == n) {\\n                lastNumber = i;\\n            }\\n        }\\n\\n        int lessMove = 0;\\n        if (firstNumber > lastNumber) {\\n            lessMove = 1;\\n        }\\n\\n        return firstNumber + (n - 1 - lastNumber) - lessMove;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int firstNumber = 0;\\n        int lastNumber = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                firstNumber = i;\\n            }\\n            if (nums[i] == n) {\\n                lastNumber = i;\\n            }\\n        }\\n\\n        int lessMove = 0;\\n        if (firstNumber > lastNumber) {\\n            lessMove = 1;\\n        }\\n\\n        return firstNumber + (n - 1 - lastNumber) - lessMove;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603198,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n       int index1 = 0;\\n        int indexlast = n;\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i] == 1) index1 = i;\\n            if(nums[i] == n) indexlast = i;\\n        }\\n        int ans = index1 + n - indexlast -1;\\n        if(index1 > indexlast) ans--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n       int index1 = 0;\\n        int indexlast = n;\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i] == 1) index1 = i;\\n            if(nums[i] == n) indexlast = i;\\n        }\\n        int ans = index1 + n - indexlast -1;\\n        if(index1 > indexlast) ans--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602382,
                "title": "swift-fast-one-pass",
                "content": "**One Pass (accepted answer)**\\n```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        let N = nums.count\\n        var p = 0\\n        var q = nums[N-1] == N ? N - 1 : 0\\n        \\n        for (i,num) in nums.enumerated() where num == 1 || num == N {\\n            (p,q) = num == 1 ? (i,q) : (p,i) \\n            guard p*q == 0 else { break }\\n        }\\n        \\n        return p + (N - 1 - q) + (p>q ? -1 : 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        let N = nums.count\\n        var p = 0\\n        var q = nums[N-1] == N ? N - 1 : 0\\n        \\n        for (i,num) in nums.enumerated() where num == 1 || num == N {\\n            (p,q) = num == 1 ? (i,q) : (p,i) \\n            guard p*q == 0 else { break }\\n        }\\n        \\n        return p + (N - 1 - q) + (p>q ? -1 : 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602044,
                "title": "easy-solution-python-simple-and-best",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        idx_1 = nums.index(1)\\n        idx_n = nums.index(len(nums))\\n\\n        if idx_1 > idx_n:\\n            return idx_1 + (len(nums) - idx_n - 1) - 1\\n        else:\\n            return idx_1 + (len(nums) - idx_n - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        idx_1 = nums.index(1)\\n        idx_n = nums.index(len(nums))\\n\\n        if idx_1 > idx_n:\\n            return idx_1 + (len(nums) - idx_n - 1) - 1\\n        else:\\n            return idx_1 + (len(nums) - idx_n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601750,
                "title": "easiest-approach-with-intuition-cpp",
                "content": "# Intuition\\nThis is a very easy problem..\\nWe don\\'t need to swap and just observe the output array.\\nIf index of n < index of 1 then there will be one less swap as 1 will swap with n once.\\nand If index of n> index of 1 then simply we will subtract the index.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int sz=nums.size();\\n        int n=nums.size()-1;\\n        int lastele;\\n        int firstele;\\n        for(int i=0 ; i<=n ; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                firstele=i;   //we will store the index of 1\\n            }\\n            if(nums[i]==sz)   // we will store the index of n\\n            {\\n                lastele=i;\\n            }\\n        }\\n        \\n        int count;\\n        if(lastele<firstele)   //we will compare for both the cases\\n        {\\n            count=((firstele-0)+(n-lastele))-1;\\n        }\\n        else{\\n            count=((firstele-0)+(n-lastele));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int sz=nums.size();\\n        int n=nums.size()-1;\\n        int lastele;\\n        int firstele;\\n        for(int i=0 ; i<=n ; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                firstele=i;   //we will store the index of 1\\n            }\\n            if(nums[i]==sz)   // we will store the index of n\\n            {\\n                lastele=i;\\n            }\\n        }\\n        \\n        int count;\\n        if(lastele<firstele)   //we will compare for both the cases\\n        {\\n            count=((firstele-0)+(n-lastele))-1;\\n        }\\n        else{\\n            count=((firstele-0)+(n-lastele));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601694,
                "title": "simple-c-solution-by-finding-positions-of-maximum-and-minimum-element",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int i1=0,i2=0,mini=nums[0],maxi=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                i2=i;\\n                maxi=nums[i];\\n            }\\n            if(nums[i]<mini)\\n            {\\n                i1=i;\\n                mini=nums[i];\\n            }\\n        }\\n        if(i1>i2)\\n        return ((i1-0)+(nums.size()-1-i2))-1;\\n        else\\n        return ((i1-0)+(nums.size()-1-i2));\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int i1=0,i2=0,mini=nums[0],maxi=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                i2=i;\\n                maxi=nums[i];\\n            }\\n            if(nums[i]<mini)\\n            {\\n                i1=i;\\n                mini=nums[i];\\n            }\\n        }\\n        if(i1>i2)\\n        return ((i1-0)+(nums.size()-1-i2))-1;\\n        else\\n        return ((i1-0)+(nums.size()-1-i2));\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601615,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        first = last = None\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                first = i\\n            elif nums[i] == len(nums):\\n                last = i\\n        \\n        return first + (len(nums)-1-last) - (0 if first<last else 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        first = last = None\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                first = i\\n            elif nums[i] == len(nums):\\n                last = i\\n        \\n        return first + (len(nums)-1-last) - (0 if first<last else 1)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1916664,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1916079,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1959233,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1925801,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1921322,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum of Matrix After Queries",
        "question_content": "<p>You are given an integer <code>n</code> and a <strong>0-indexed</strong>&nbsp;<strong>2D array</strong> <code>queries</code> where <code>queries[i] = [type<sub>i</sub>, index<sub>i</sub>, val<sub>i</sub>]</code>.</p>\n\n<p>Initially, there is a <strong>0-indexed</strong> <code>n x n</code> matrix filled with <code>0</code>&#39;s. For each query, you must apply one of the following changes:</p>\n\n<ul>\n\t<li>if <code>type<sub>i</sub> == 0</code>, set the values in the row with <code>index<sub>i</sub></code> to <code>val<sub>i</sub></code>, overwriting any previous values.</li>\n\t<li>if <code>type<sub>i</sub> == 1</code>, set the values in the column with <code>index<sub>i</sub></code> to <code>val<sub>i</sub></code>, overwriting any previous values.</li>\n</ul>\n\n<p>Return <em>the sum of integers in the matrix after all queries are applied</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/05/11/exm1.png\" style=\"width: 681px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]\n<strong>Output:</strong> 23\n<strong>Explanation:</strong> The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 23. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/05/11/exm2.png\" style=\"width: 681px; height: 331px;\" />\n<pre>\n<strong>Input:</strong> n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]\n<strong>Output:</strong> 17\n<strong>Explanation:</strong> The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 17.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>queries[i].length == 3</code></li>\n\t<li><code>0 &lt;= type<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt; n</code></li>\n\t<li><code>0 &lt;= val<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3594967,
                "title": "explained-reverse-iteration-o-n-very-simple-and-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n## Approach \\n1. Here iterate from the end & Keep track number of rows and number of cols that can be assigned a value\\n3. Add to answer val * remaining row when col operation is performed &\\n    add to answer val * remaining col when row operation is performed.\\n4. Decreament remaining row when row operation is performed &\\n    reamining col when col operation is performed\\n\\nNote : The trick is to when ever we perform a row operation then number of column remaining for next col operation 1 less and same is the case for col operation.\\n\\nFAQ : Why we are considering only once every index, even there is duplicate possible ?\\nAns: Even if there is duplicate, the last one will overwrite the effect of the previous query excution on the same index. So as we iterate from last, we need to only consider the last one and not any other occurance of it.\\n\\n## Complexity \\nTime : O(N) where N = q.size()\\nSpace : O(N) where N = n\\n\\n## Code\\n\\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& q) {\\n    vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n    long long ans = 0, rowRemain = n, colRemain = n;\\n    for(int i = q.size()-1; i >= 0; --i){\\n        if(q[i][0] == 0 && rowFlag[q[i][1]]) { ans += colRemain * q[i][2];    rowFlag[q[i][1]] = 0; rowRemain--; }\\n        if(q[i][0] == 1 && colFlag[q[i][1]]) { ans += rowRemain * q[i][2];    colFlag[q[i][1]] = 0; colRemain--; }\\n    }\\n    return ans;\\n}\\n\\n```\\n\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long matrixSumQueries(int n, vector<vector<int>>& q) {\\n    vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n    long long ans = 0, rowRemain = n, colRemain = n;\\n    for(int i = q.size()-1; i >= 0; --i){\\n        if(q[i][0] == 0 && rowFlag[q[i][1]]) { ans += colRemain * q[i][2];    rowFlag[q[i][1]] = 0; rowRemain--; }\\n        if(q[i][0] == 1 && colFlag[q[i][1]]) { ans += rowRemain * q[i][2];    colFlag[q[i][1]] = 0; colRemain--; }\\n    }\\n    return ans;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595010,
                "title": "c-java-python-track-seen-count-with-image-example",
                "content": "# Intuition\\n```\\nn = 10, queries = [[1, 7, 1], [0, 6, 2]]\\n```\\n![image.png](https://assets.leetcode.com/users/images/f398ef4c-142a-4692-9c06-282f8e3728d2_1685851113.5247235.png)\\n\\nThe queries which will come later will have a **greater** impact on final sum because it will overwrite any cell that was filled/not-filled before. Therefore, we can try to make sum by traversing in reverse direction of `queries`.\\n\\nIn above example,\\n1. We can first add `2 * 10 = 20` to our sum because it will overwrite everything as it is the **last** query.\\n2. Then, while considering the previous query `[1, 7, 1]`, we need to know how many rows will be there that would have been overwritten in upcoming queries. So, we can track this by maintaining seen rows\\' count. By this we will know that there is one row that will be overwritten in future so we add `1 * 9 = 9` to our sum.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int rowSeenCount = 0, colSeenCount = 0;\\n        vector<bool> rowSeen(n), colSeen(n);\\n        long long sum = 0;\\n        for (int qi = queries.size() - 1; qi >= 0; qi--) {\\n            int type = queries[qi][0], index = queries[qi][1], val = queries[qi][2];\\n            if (type == 0 && !rowSeen[index]) {\\n                rowSeenCount++;\\n                rowSeen[index] = true;\\n                sum += 1LL * (n - colSeenCount) * val;\\n            }\\n            if (type == 1 && !colSeen[index]) {\\n                colSeenCount++;\\n                colSeen[index] = true;\\n                sum += 1LL * (n - rowSeenCount) * val;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowSeenCount = 0, colSeenCount = 0;\\n        boolean[] rowSeen = new boolean[n];\\n        boolean[] colSeen = new boolean[n];\\n        long sum = 0;\\n        for (int qi = queries.length - 1; qi >= 0; qi--) {\\n            int type = queries[qi][0], index = queries[qi][1], val = queries[qi][2];\\n            if (type == 0 && !rowSeen[index]) {\\n                rowSeenCount++;\\n                rowSeen[index] = true;\\n                sum += (n - colSeenCount) * val;\\n            }\\n            if (type == 1 && !colSeen[index]) {\\n                colSeenCount++;\\n                colSeen[index] = true;\\n                sum += (n - rowSeenCount) * val;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rowSeenCount, colSeenCount, total = 0, 0, 0\\n        rowSeen, colSeen = [False] * n, [False] * n\\n        for qi in range(len(queries) - 1, -1, -1):\\n            typei, index, val = queries[qi][0], queries[qi][1], queries[qi][2]\\n            if typei == 0 and not rowSeen[index]:\\n                rowSeenCount += 1\\n                rowSeen[index] = True\\n                total += (n - colSeenCount) * val\\n            if typei == 1 and not colSeen[index]:\\n                colSeenCount += 1\\n                colSeen[index] = True\\n                total += (n - rowSeenCount) * val\\n        return total\\n```\\n\\n# Complexity\\n- Time complexity: $$O(queries.length)$$\\n- Space complexity: $$O(n)$$\\n\\n# QnA\\n**Q:** [@Bacon_lord](/Bacon_lord) : I dont understand why we need to track the rows/cols, shouldn\\'t counting the rows/cols be enough, and once you reach n no need to increment further.... this is wrong but i dont understand why it\\'s wrong?\\n**A:** It is required as there can be multiple queries for same row (or same column). Take same example as above, add another query: \\n```\\nn = 10, queries = [[1, 7, 1], [0, 6, 3], [0, 6, 2]]\\n```\\nFinal matrix will be same as in above image. But if we counted same row `6` twice, then when we reach `[1, 7, 1]` we will do `1 * 8 = 8` but we should have done `1 * 9 = 9`.\\nAlso, those multiple queries are meaningless because only last of all the same will be in the final result as it will overwrite on completely same row (or column). Since we are traversing in reverse direction, we put it in hashmap or visited array and we will not consider queries to same row (or column) that would have been made in past with respect to it.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nn = 10, queries = [[1, 7, 1], [0, 6, 2]]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int rowSeenCount = 0, colSeenCount = 0;\\n        vector<bool> rowSeen(n), colSeen(n);\\n        long long sum = 0;\\n        for (int qi = queries.size() - 1; qi >= 0; qi--) {\\n            int type = queries[qi][0], index = queries[qi][1], val = queries[qi][2];\\n            if (type == 0 && !rowSeen[index]) {\\n                rowSeenCount++;\\n                rowSeen[index] = true;\\n                sum += 1LL * (n - colSeenCount) * val;\\n            }\\n            if (type == 1 && !colSeen[index]) {\\n                colSeenCount++;\\n                colSeen[index] = true;\\n                sum += 1LL * (n - rowSeenCount) * val;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowSeenCount = 0, colSeenCount = 0;\\n        boolean[] rowSeen = new boolean[n];\\n        boolean[] colSeen = new boolean[n];\\n        long sum = 0;\\n        for (int qi = queries.length - 1; qi >= 0; qi--) {\\n            int type = queries[qi][0], index = queries[qi][1], val = queries[qi][2];\\n            if (type == 0 && !rowSeen[index]) {\\n                rowSeenCount++;\\n                rowSeen[index] = true;\\n                sum += (n - colSeenCount) * val;\\n            }\\n            if (type == 1 && !colSeen[index]) {\\n                colSeenCount++;\\n                colSeen[index] = true;\\n                sum += (n - rowSeenCount) * val;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rowSeenCount, colSeenCount, total = 0, 0, 0\\n        rowSeen, colSeen = [False] * n, [False] * n\\n        for qi in range(len(queries) - 1, -1, -1):\\n            typei, index, val = queries[qi][0], queries[qi][1], queries[qi][2]\\n            if typei == 0 and not rowSeen[index]:\\n                rowSeenCount += 1\\n                rowSeen[index] = True\\n                total += (n - colSeenCount) * val\\n            if typei == 1 and not colSeen[index]:\\n                colSeenCount += 1\\n                colSeen[index] = True\\n                total += (n - rowSeenCount) * val\\n        return total\\n```\n```\\nn = 10, queries = [[1, 7, 1], [0, 6, 3], [0, 6, 2]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594928,
                "title": "last-query-wins",
                "content": "We start with the last query and go backwards.\\n\\n\\nWe track `id` of rows and columns we have seen - so we can ignore earlier queries that will be  overwritten.\\n\\nWe also track how many rows and columns are still not covered by any query. That way, each query adds:\\n- `v * cols_cnt` for a row,\\n- `v * rows_cnt` for a column.\\n\\n## Minimalizm Version\\nIn this version, we abstract from rows and columns, and use `type` as an idex.\\n\\nSee a verbose version below (could be easier to understand).\\n\\n**C++**\\n```cpp\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cnt[2] = {n, n};\\n    bool seen[2][10001] = {};\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (!seen[type][id]) {\\n            seen[type][id] = true;\\n            res += v * cnt[!type];\\n            --cnt[type];\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\n## Verbose Version\\n**C++**\\n```cpp\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cols_cnt = n, rows_cnt = n;\\n    vector<bool> cols(n), rows(n);\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (type == 0) { // row\\n            if (!rows[id]) {\\n                rows[id] = true;\\n                --rows_cnt;\\n                res += v * cols_cnt;\\n            }\\n        }\\n        else { // col\\n            if (!cols[id]) {\\n                cols[id] = true;\\n                --cols_cnt;    \\n                res += v * rows_cnt;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cnt[2] = {n, n};\\n    bool seen[2][10001] = {};\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (!seen[type][id]) {\\n            seen[type][id] = true;\\n            res += v * cnt[!type];\\n            --cnt[type];\\n        }\\n    }\\n    return res;\\n}\\n```\n```cpp\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cols_cnt = n, rows_cnt = n;\\n    vector<bool> cols(n), rows(n);\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (type == 0) { // row\\n            if (!rows[id]) {\\n                rows[id] = true;\\n                --rows_cnt;\\n                res += v * cols_cnt;\\n            }\\n        }\\n        else { // col\\n            if (!cols[id]) {\\n                cols[id] = true;\\n                --cols_cnt;    \\n                res += v * rows_cnt;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595045,
                "title": "java-c-python-reverse-queries",
                "content": "# **Why people down vote this thread without even a word or reason?**\\n# **Please upvote this, thanks.**\\n\\n# **Intuition**\\n\"overwriting any previous values.\"\\nSo we don\\'t know whether the current value will be overrote by later query.\\nWe can iterate `queries` reversely,\\nso we can make sure once the value filled,\\nit won\\'t be changed anymore.\\n<br>\\n\\n# **Explanation**\\n`col[i]` the values in the row with index `i`.\\n`row[i]` the values in the col with index `i`.\\n\\n\\nIterate `queries` reversely,\\nif `col[i]` or `row[i]` already set,\\nignore it.\\notherwise set the value.\\n\\nIf `row[i]` is set,\\nwe didn\\'t set `n` values in matrix,\\nsince there length of `col` have already been set,\\nwe only fill in `n - col.size()` cell in `i`th row,\\nso the total value is incresed by `v * (n - col.size())`.\\nIf `col[i]` is set, similar case.\\n\\nFinally we return result.\\n<br>\\n\\n# **Complexity**\\nTime `O(queries)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Map<Integer, Integer> col = new HashMap<>(), row = new HashMap<>();\\n        long res = 0;\\n        for (int j = queries.length - 1; j >= 0; --j) {\\n            int t = queries[j][0], i = queries[j][1], v = queries[j][2];\\n            if (t == 0 && !col.containsKey(i)) {\\n                col.put(i, v);\\n                res += 1L * v * (n - row.size());\\n            }\\n            if (t == 1 && !row.containsKey(i)) {\\n                row.put(i, v);\\n                res += 1L * v * (n - col.size());\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_map<int, int> col, row;\\n        long long res = 0;\\n        for (int j = queries.size() - 1; j >= 0; --j) {\\n            int t = queries[j][0], i = queries[j][1], v = queries[j][2];\\n            if (t == 0 && !col.count(i)) {\\n                col[i] = v;\\n                res += v * (n - row.size());\\n            }\\n            if (t == 1 && !row.count(i)) {\\n                row[i] = v;\\n                res += v * (n - col.size());\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        col, row = {}, {}\\n        res = 0\\n        for t,i,v in queries[::-1]:\\n            if t == 0 and i not in row:\\n                row[i] = v\\n                res += v * (n - len(col))\\n            if t == 1 and i not in col:\\n                col[i] = v\\n                res += v * (n - len(row))\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Map<Integer, Integer> col = new HashMap<>(), row = new HashMap<>();\\n        long res = 0;\\n        for (int j = queries.length - 1; j >= 0; --j) {\\n            int t = queries[j][0], i = queries[j][1], v = queries[j][2];\\n            if (t == 0 && !col.containsKey(i)) {\\n                col.put(i, v);\\n                res += 1L * v * (n - row.size());\\n            }\\n            if (t == 1 && !row.containsKey(i)) {\\n                row.put(i, v);\\n                res += 1L * v * (n - col.size());\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_map<int, int> col, row;\\n        long long res = 0;\\n        for (int j = queries.size() - 1; j >= 0; --j) {\\n            int t = queries[j][0], i = queries[j][1], v = queries[j][2];\\n            if (t == 0 && !col.count(i)) {\\n                col[i] = v;\\n                res += v * (n - row.size());\\n            }\\n            if (t == 1 && !row.count(i)) {\\n                row[i] = v;\\n                res += v * (n - col.size());\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        col, row = {}, {}\\n        res = 0\\n        for t,i,v in queries[::-1]:\\n            if t == 0 and i not in row:\\n                row[i] = v\\n                res += v * (n - len(col))\\n            if t == 1 and i not in col:\\n                col[i] = v\\n                res += v * (n - len(row))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3595038,
                "title": "dedicated-to-beginners-image-explanation-c-java-python",
                "content": "**IMPORTANT\\uD83D\\uDCDD**  : If you want to master the concept of sliding window and want to solve all slding window (20+) problems just using single template you may check out my youtube channel by clicking my profile icon and you will find the link of channel. Best of Luck \\u270C\\uFE0F\\n**It took a lot of efforts to prepare a image explanation , please upvote this post so that other can find it easily.**\\nThankyou,\\n\\n![image](https://assets.leetcode.com/users/images/c9c5c980-4dad-42cb-b2f8-766fd1d7196d_1685897211.6367457.png)\\n![image](https://assets.leetcode.com/users/images/d15f48f8-d72e-408c-99ba-6ac2cee67287_1685897057.0139484.png)\\n![image](https://assets.leetcode.com/users/images/28656679-747a-4c8d-8f43-44e7f1c6e17e_1685898753.1859484.png)\\n![image](https://assets.leetcode.com/users/images/e7b90e9f-c855-4a54-a096-9eed05f9f501_1685899477.3602993.png)\\n![image](https://assets.leetcode.com/users/images/760b9c3e-1848-490f-91f2-80fac33523f5_1685898930.5690446.png)\\n![image](https://assets.leetcode.com/users/images/e86d9d46-b43d-4c13-a6df-b049d39c0d92_1685899716.3258834.png)\\n\\n\\n\\n\\n\\n**1. C++**\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n         long sum = 0;\\n         int row = n, col = n;\\n        \\n         unordered_set<int>Rowvis;       // storage of index for type==0\\n         unordered_set<int>Colvis;        // storage of index for type==1\\n\\n    for (int i = queries.size() - 1; i >= 0; i--) {\\n        \\n        int type=queries[i][0];\\n        int idx=queries[i][1];\\n        int value=queries[i][2];\\n        \\n        if (type==0) {\\n            if (Rowvis.find(idx)!=Rowvis.end()) {            // because this index is already calculated\\n                continue;\\n            } \\n            else {                     \\n               \\n                sum += col* value;     // update its value if not filled this index already (updated col value will handle it)\\n                Rowvis.insert(idx);    // mark this index as updated for type==0                          \\n                row --;               // decrement row value because this row value is now permanent we can not update it further\\n              \\n            }\\n        } else {\\n            if (Colvis.find(idx)!=Colvis.end()) {        // because this index is already calculated\\n                continue;\\n            }\\n            else {\\n               \\n                sum += row * value;   // update its value if not filled this index already (updated row value will handle it)\\n                Colvis.insert(idx);   // mark this index as updated for type==1\\n                col --;             // decrement col value because this col value is now permanent we can not update it \\n            }\\n        }\\n    }\\n\\n    return sum;\\n\\n    }\\n};\\n```\\n \\n **More Optimized C++ code:**\\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>visrow(n),viscol(n);\\n        \\n        reverse(queries.begin(), queries.end());\\n        \\n        int row=n, col= n;\\n        long long sum= 0;\\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            int type= queries[i][0];\\n            int idx= queries[i][1];\\n            \\n            if(type == 0 and visrow[idx] == 0){        \\n               \\n                int value= queries[i][2];\\n                \\n                sum+= row * value;            \\n                visrow[idx] = 1;              // this row is changed so dont visit it again\\n                col--;                        // now 1 more col is reserved you cant fill this\\n            }\\n            \\n            else if(type ==1 and viscol[idx] == 0){             \\n               \\n                int value= queries[i][2];\\n                \\n                sum+= col * value;\\n                viscol[idx]= 1;            // this col is changed so dont visit it again\\n                row--;                     // now 1 more row is reserved you cant fill this\\n            } \\n        }\\n        \\n        return sum;\\n    }\\n```\\n\\n**2. PYTHON**\\n\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n, queries):\\n        sum_val = 0\\n        row = n\\n        col = n\\n        \\n        row_vis = set()    # storage of index for type==0\\n        col_vis = set()    # storage of index for type==1\\n        \\n        for i in range(len(queries) - 1, -1, -1):\\n            query_type = queries[i][0]\\n            idx = queries[i][1]\\n            value = queries[i][2]\\n            \\n            if query_type == 0:\\n                if idx in row_vis:    # because this index is already calculated\\n                    continue\\n                else:\\n                    sum_val += col * value    # update its value if not filled this index already (updated col value will handle it)\\n                    row_vis.add(idx)    # mark this index as updated for type==0\\n                    row -= 1    # decrement row value because this row value is now permanent we cannot update it further\\n            else:\\n                if idx in col_vis:    # because this index is already calculated\\n                    continue\\n                else:\\n                    sum_val += row * value    # update its value if not filled this index already (updated row value will handle it)\\n                    col_vis.add(idx)    # mark this index as updated for type==1\\n                    col -= 1    # decrement col value because this col value is now permanent we cannot update it further\\n        \\n        return sum_val\\n\\n```\\n\\n**3. JAVA**\\n\\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\nimport java.util.List;\\n\\nclass Solution {\\n    public long matrixSumQueries(int n, List<List<Integer>> queries) {\\n        long sumVal = 0;\\n        int row = n;\\n        int col = n;\\n\\n        Set<Integer> rowVis = new HashSet<>();    // storage of index for type==0\\n        Set<Integer> colVis = new HashSet<>();    // storage of index for type==1\\n\\n        for (int i = queries.size() - 1; i >= 0; i--) {\\n            int type = queries.get(i).get(0);\\n            int idx = queries.get(i).get(1);\\n            int value = queries.get(i).get(2);\\n\\n            if (type == 0) {\\n                if (rowVis.contains(idx)) {    // because this index is already calculated\\n                    continue;\\n                } else {\\n                    sumVal += col * value;    // update its value if not filled this index already (updated col value will handle it)\\n                    rowVis.add(idx);    // mark this index as updated for type==0\\n                    row--;    // decrement row value because this row value is now permanent we cannot update it further\\n                }\\n            } else {\\n                if (colVis.contains(idx)) {    // because this index is already calculated\\n                    continue;\\n                } else {\\n                    sumVal += row * value;    // update its value if not filled this index already (updated row value will handle it)\\n                    colVis.add(idx);    // mark this index as updated for type==1\\n                    col--;    // decrement col value because this col value is now permanent we cannot update it further\\n                }\\n            }\\n        }\\n\\n        return sumVal;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n         long sum = 0;\\n         int row = n, col = n;\\n        \\n         unordered_set<int>Rowvis;       // storage of index for type==0\\n         unordered_set<int>Colvis;        // storage of index for type==1\\n\\n    for (int i = queries.size() - 1; i >= 0; i--) {\\n        \\n        int type=queries[i][0];\\n        int idx=queries[i][1];\\n        int value=queries[i][2];\\n        \\n        if (type==0) {\\n            if (Rowvis.find(idx)!=Rowvis.end()) {            // because this index is already calculated\\n                continue;\\n            } \\n            else {                     \\n               \\n                sum += col* value;     // update its value if not filled this index already (updated col value will handle it)\\n                Rowvis.insert(idx);    // mark this index as updated for type==0                          \\n                row --;               // decrement row value because this row value is now permanent we can not update it further\\n              \\n            }\\n        } else {\\n            if (Colvis.find(idx)!=Colvis.end()) {        // because this index is already calculated\\n                continue;\\n            }\\n            else {\\n               \\n                sum += row * value;   // update its value if not filled this index already (updated row value will handle it)\\n                Colvis.insert(idx);   // mark this index as updated for type==1\\n                col --;             // decrement col value because this col value is now permanent we can not update it \\n            }\\n        }\\n    }\\n\\n    return sum;\\n\\n    }\\n};\\n```\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>visrow(n),viscol(n);\\n        \\n        reverse(queries.begin(), queries.end());\\n        \\n        int row=n, col= n;\\n        long long sum= 0;\\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            int type= queries[i][0];\\n            int idx= queries[i][1];\\n            \\n            if(type == 0 and visrow[idx] == 0){        \\n               \\n                int value= queries[i][2];\\n                \\n                sum+= row * value;            \\n                visrow[idx] = 1;              // this row is changed so dont visit it again\\n                col--;                        // now 1 more col is reserved you cant fill this\\n            }\\n            \\n            else if(type ==1 and viscol[idx] == 0){             \\n               \\n                int value= queries[i][2];\\n                \\n                sum+= col * value;\\n                viscol[idx]= 1;            // this col is changed so dont visit it again\\n                row--;                     // now 1 more row is reserved you cant fill this\\n            } \\n        }\\n        \\n        return sum;\\n    }\\n```\n```\\nclass Solution:\\n    def matrixSumQueries(self, n, queries):\\n        sum_val = 0\\n        row = n\\n        col = n\\n        \\n        row_vis = set()    # storage of index for type==0\\n        col_vis = set()    # storage of index for type==1\\n        \\n        for i in range(len(queries) - 1, -1, -1):\\n            query_type = queries[i][0]\\n            idx = queries[i][1]\\n            value = queries[i][2]\\n            \\n            if query_type == 0:\\n                if idx in row_vis:    # because this index is already calculated\\n                    continue\\n                else:\\n                    sum_val += col * value    # update its value if not filled this index already (updated col value will handle it)\\n                    row_vis.add(idx)    # mark this index as updated for type==0\\n                    row -= 1    # decrement row value because this row value is now permanent we cannot update it further\\n            else:\\n                if idx in col_vis:    # because this index is already calculated\\n                    continue\\n                else:\\n                    sum_val += row * value    # update its value if not filled this index already (updated row value will handle it)\\n                    col_vis.add(idx)    # mark this index as updated for type==1\\n                    col -= 1    # decrement col value because this col value is now permanent we cannot update it further\\n        \\n        return sum_val\\n\\n```\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\nimport java.util.List;\\n\\nclass Solution {\\n    public long matrixSumQueries(int n, List<List<Integer>> queries) {\\n        long sumVal = 0;\\n        int row = n;\\n        int col = n;\\n\\n        Set<Integer> rowVis = new HashSet<>();    // storage of index for type==0\\n        Set<Integer> colVis = new HashSet<>();    // storage of index for type==1\\n\\n        for (int i = queries.size() - 1; i >= 0; i--) {\\n            int type = queries.get(i).get(0);\\n            int idx = queries.get(i).get(1);\\n            int value = queries.get(i).get(2);\\n\\n            if (type == 0) {\\n                if (rowVis.contains(idx)) {    // because this index is already calculated\\n                    continue;\\n                } else {\\n                    sumVal += col * value;    // update its value if not filled this index already (updated col value will handle it)\\n                    rowVis.add(idx);    // mark this index as updated for type==0\\n                    row--;    // decrement row value because this row value is now permanent we cannot update it further\\n                }\\n            } else {\\n                if (colVis.contains(idx)) {    // because this index is already calculated\\n                    continue;\\n                } else {\\n                    sumVal += row * value;    // update its value if not filled this index already (updated row value will handle it)\\n                    colVis.add(idx);    // mark this index as updated for type==1\\n                    col--;    // decrement col value because this col value is now permanent we cannot update it further\\n                }\\n            }\\n        }\\n\\n        return sumVal;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594918,
                "title": "reverse-iteration-through-queries-python",
                "content": "# Explanation\\n- Do reverse iteration through queries because latest rows and cols have contribution to our final answer.\\n- Add visited rows and cols to hash set.\\n# Complexity\\n`Time O(length of queries)`\\n`Space O(N)`\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        cols, rows = set(), set()\\n        res = 0\\n        for ty, index, val in queries[::-1]:\\n            if ty:\\n                if index not in cols:\\n                    cols.add(index)\\n                    res += val * n\\n                    res -= val * len(rows)\\n            else:\\n                if index not in rows:\\n                    rows.add(index)\\n                    res += val * n\\n                    res -= val * len(cols)\\n        return res\\n```\\nUpVote, if you like **:)**",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        cols, rows = set(), set()\\n        res = 0\\n        for ty, index, val in queries[::-1]:\\n            if ty:\\n                if index not in cols:\\n                    cols.add(index)\\n                    res += val * n\\n                    res -= val * len(rows)\\n            else:\\n                if index not in rows:\\n                    rows.add(index)\\n                    res += val * n\\n                    res -= val * len(cols)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595075,
                "title": "explained-reverse-iteration-o-n",
                "content": "# EXPLANATION\\nWe start at the bottom-right corner of the grid.\\n\\nFor each cell, we check if it is a row operation or a column operation.\\n\\nIf it\\'s a row operation, we multiply the cell value by the number of remaining rows. This value represents how many times this cell\\'s value will contribute to the final answer.\\n\\nIf it\\'s a column operation, we multiply the cell value by the number of remaining columns. This value represents how many times this cell\\'s value will contribute to the final answer.\\n\\nAfter each row operation, we decrement the count of remaining rows by 1 because the next column operation will have one less row to work with.\\n\\nAfter each column operation, we decrement the count of remaining columns by 1 because the next row operation will have one less column to work with.\\n\\nWe continue this process until we reach the top-left corner of the grid.\\n\\nFinally, we return the sum of all the values obtained from the above steps as the answer.\\n# CODE\\n\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n    vector<bool> rowFlag(n, true), colFlag(n, true);\\n    long long totalSum = 0, remainingRows = n, remainingCols = n;\\n\\n    for (int i = queries.size() - 1; i >= 0; --i) {\\n        int queryType = queries[i][0];\\n        int index = queries[i][1];\\n        int value = queries[i][2];\\n\\n        if (queryType == 0 && rowFlag[index]) {\\n            totalSum += remainingCols * value;\\n            rowFlag[index] = false;\\n            remainingRows--;\\n        }\\n        if (queryType == 1 && colFlag[index]) {\\n            totalSum += remainingRows * value;\\n            colFlag[index] = false;\\n            remainingCols--;\\n        }\\n    }\\n\\n    return totalSum;\\n    }\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "# EXPLANATION\\nWe start at the bottom-right corner of the grid.\\n\\nFor each cell, we check if it is a row operation or a column operation.\\n\\nIf it\\'s a row operation, we multiply the cell value by the number of remaining rows. This value represents how many times this cell\\'s value will contribute to the final answer.\\n\\nIf it\\'s a column operation, we multiply the cell value by the number of remaining columns. This value represents how many times this cell\\'s value will contribute to the final answer.\\n\\nAfter each row operation, we decrement the count of remaining rows by 1 because the next column operation will have one less row to work with.\\n\\nAfter each column operation, we decrement the count of remaining columns by 1 because the next row operation will have one less column to work with.\\n\\nWe continue this process until we reach the top-left corner of the grid.\\n\\nFinally, we return the sum of all the values obtained from the above steps as the answer.\\n# CODE\\n\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n    vector<bool> rowFlag(n, true), colFlag(n, true);\\n    long long totalSum = 0, remainingRows = n, remainingCols = n;\\n\\n    for (int i = queries.size() - 1; i >= 0; --i) {\\n        int queryType = queries[i][0];\\n        int index = queries[i][1];\\n        int value = queries[i][2];\\n\\n        if (queryType == 0 && rowFlag[index]) {\\n            totalSum += remainingCols * value;\\n            rowFlag[index] = false;\\n            remainingRows--;\\n        }\\n        if (queryType == 1 && colFlag[index]) {\\n            totalSum += remainingRows * value;\\n            colFlag[index] = false;\\n            remainingCols--;\\n        }\\n    }\\n\\n    return totalSum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3595012,
                "title": "start-from-the-end-o-q-c-java-python",
                "content": "# Intuition\\n**```Start from reverse since at the end we end up at the latest configuration of the matrix. Afterwards if there is case of overwriting then we would not consider it as we starting from latest to initial configuration```**\\n\\n# Approach\\n**```Take two maps one for row , and one for the column. Take two variable which would keep the count of no. of columns and no. of rows```**\\n**``` ```**\\n\\nAt any point while performing the row query add **``` val_at_the_row * (n - colums_already_painted) ```**\\nAt any point while performing the col query add **``` val_at_the_col * (n - rows_already_painted) ```**\\n\\n\\n# Complexity\\n- Time complexity:\\n**```Since it requires just to traverse the entire query only once the time complexity is: O(q) where q is the size of the query list```**\\n\\n- Space complexity:\\n**```We are using here 2 map one for row and other for col so Space taken by a map can be at max N, so O(N) where N is the number of rows and columns```**\\n\\n# Code (C++)\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0, rsum = 0, csum = 0;\\n        unordered_map<int, int> mpr, mpc;\\n        reverse(queries.begin(), queries.end());\\n        for (auto it : queries)\\n        {\\n            if (it[0] == 0)\\n            {\\n                // row\\n                int r = it[1];\\n                int val = it[2];\\n                if (mpr.find(r) == mpr.end())\\n                {\\n                    rsum ++;\\n                    mpr[r] = val;\\n                    ans += val * (n - csum);\\n                }\\n            }\\n            else\\n            {\\n                //col\\n                int c = it[1];\\n                int val = it[2];\\n                if (mpc.find(c) == mpc.end())\\n                {\\n                    csum ++;\\n                    mpc[c] = val;\\n                    ans += val * (n - rsum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code(Java)\\n``` import java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Collections;\\n\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans = 0, rsum = 0, csum = 0;\\n        Map<Integer, Integer> mpr = new HashMap<>();\\n        Map<Integer, Integer> mpc = new HashMap<>();\\n        List<List<Integer>> queryList = new ArrayList<>();\\n\\n        for (int[] query : queries) {\\n            List<Integer> list = new ArrayList<>();\\n            for (int i = 0; i < query.length; i++) {\\n                list.add(query[i]);\\n            }\\n            queryList.add(list);\\n        }\\n        \\n        Collections.reverse(queryList);\\n        \\n        for (List<Integer> it : queryList) {\\n            if (it.get(0) == 0) {\\n                // row\\n                int r = it.get(1);\\n                int val = it.get(2);\\n                if (!mpr.containsKey(r)) {\\n                    rsum++;\\n                    mpr.put(r, val);\\n                    ans += val * (n - csum);\\n                }\\n            } else {\\n                // col\\n                int c = it.get(1);\\n                int val = it.get(2);\\n                if (!mpc.containsKey(c)) {\\n                    csum++;\\n                    mpc.put(c, val);\\n                    ans += val * (n - rsum);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n# Code(Python)\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n, queries):\\n        ans = 0\\n        rsum = 0\\n        csum = 0\\n        mpr = {}\\n        mpc = {}\\n        queries.reverse()\\n        \\n        for it in queries:\\n            if it[0] == 0:\\n                # row\\n                r = it[1]\\n                val = it[2]\\n                if r not in mpr:\\n                    rsum += 1\\n                    mpr[r] = val\\n                    ans += val * (n - csum)\\n            else:\\n                # col\\n                c = it[1]\\n                val = it[2]\\n                if c not in mpc:\\n                    csum += 1\\n                    mpc[c] = val\\n                    ans += val * (n - rsum)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```Start from reverse since at the end we end up at the latest configuration of the matrix. Afterwards if there is case of overwriting then we would not consider it as we starting from latest to initial configuration```\n```Take two maps one for row , and one for the column. Take two variable which would keep the count of no. of columns and no. of rows```\n``` ```\n``` val_at_the_row * (n - colums_already_painted) ```\n``` val_at_the_col * (n - rows_already_painted) ```\n```Since it requires just to traverse the entire query only once the time complexity is: O(q) where q is the size of the query list```\n```We are using here 2 map one for row and other for col so Space taken by a map can be at max N, so O(N) where N is the number of rows and columns```\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0, rsum = 0, csum = 0;\\n        unordered_map<int, int> mpr, mpc;\\n        reverse(queries.begin(), queries.end());\\n        for (auto it : queries)\\n        {\\n            if (it[0] == 0)\\n            {\\n                // row\\n                int r = it[1];\\n                int val = it[2];\\n                if (mpr.find(r) == mpr.end())\\n                {\\n                    rsum ++;\\n                    mpr[r] = val;\\n                    ans += val * (n - csum);\\n                }\\n            }\\n            else\\n            {\\n                //col\\n                int c = it[1];\\n                int val = it[2];\\n                if (mpc.find(c) == mpc.end())\\n                {\\n                    csum ++;\\n                    mpc[c] = val;\\n                    ans += val * (n - rsum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` import java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Collections;\\n\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans = 0, rsum = 0, csum = 0;\\n        Map<Integer, Integer> mpr = new HashMap<>();\\n        Map<Integer, Integer> mpc = new HashMap<>();\\n        List<List<Integer>> queryList = new ArrayList<>();\\n\\n        for (int[] query : queries) {\\n            List<Integer> list = new ArrayList<>();\\n            for (int i = 0; i < query.length; i++) {\\n                list.add(query[i]);\\n            }\\n            queryList.add(list);\\n        }\\n        \\n        Collections.reverse(queryList);\\n        \\n        for (List<Integer> it : queryList) {\\n            if (it.get(0) == 0) {\\n                // row\\n                int r = it.get(1);\\n                int val = it.get(2);\\n                if (!mpr.containsKey(r)) {\\n                    rsum++;\\n                    mpr.put(r, val);\\n                    ans += val * (n - csum);\\n                }\\n            } else {\\n                // col\\n                int c = it.get(1);\\n                int val = it.get(2);\\n                if (!mpc.containsKey(c)) {\\n                    csum++;\\n                    mpc.put(c, val);\\n                    ans += val * (n - rsum);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def matrixSumQueries(self, n, queries):\\n        ans = 0\\n        rsum = 0\\n        csum = 0\\n        mpr = {}\\n        mpc = {}\\n        queries.reverse()\\n        \\n        for it in queries:\\n            if it[0] == 0:\\n                # row\\n                r = it[1]\\n                val = it[2]\\n                if r not in mpr:\\n                    rsum += 1\\n                    mpr[r] = val\\n                    ans += val * (n - csum)\\n            else:\\n                # col\\n                c = it[1]\\n                val = it[2]\\n                if c not in mpc:\\n                    csum += 1\\n                    mpc[c] = val\\n                    ans += val * (n - rsum)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595858,
                "title": "c-simple-and-easy-to-understand-time-o-q-space-o-n",
                "content": "# Intuition\\nStart from reverse since at the end we end up at the latest configuration of the matrix. Afterwards if there is case of overwriting then we would not consider it as we starting from latest to initial configuration\\n\\n# Approach\\nTake two unordered set one for row , and one for the column. Take two variable which would keep the count of number of rows and columns.\\n\\nAt any point while performing the row query add `val_at_the_row * (number of colums available)` and decrease the number of row by 1.\\nAt any point while performing the col query add `val_at_the_col * (number of rows available)` and decrease the number of column by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(q)$$ where q is the size of the query list\\n\\n- Space complexity:\\n$$O(N)$$ where N is the number of rows and columns to store in unordered set\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>> &q)\\n    {\\n        unordered_set<int> row, col;\\n        int nrow = n, ncol = n;\\n        long long int sum = 0;\\n        for (int i = q.size() - 1; i >= 0; i--)\\n        {\\n            int type = q[i][0];\\n            int indx = q[i][1];\\n            int val = q[i][2];\\n            if (type == 0 && row.find(indx) == row.end())\\n            {\\n                sum += (ncol * val);\\n                row.insert(indx);\\n                nrow--;\\n            }\\n            else if (type == 1 && col.find(indx) == col.end())\\n            {\\n                sum += (nrow * val);\\n                col.insert(indx);\\n                ncol--;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n![LEETCODE.png](https://assets.leetcode.com/users/images/86abe9b8-5bc8-4506-892c-6e61c18fe2c5_1685861372.3619711.png)\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>> &q)\\n    {\\n        unordered_set<int> row, col;\\n        int nrow = n, ncol = n;\\n        long long int sum = 0;\\n        for (int i = q.size() - 1; i >= 0; i--)\\n        {\\n            int type = q[i][0];\\n            int indx = q[i][1];\\n            int val = q[i][2];\\n            if (type == 0 && row.find(indx) == row.end())\\n            {\\n                sum += (ncol * val);\\n                row.insert(indx);\\n                nrow--;\\n            }\\n            else if (type == 1 && col.find(indx) == col.end())\\n            {\\n                sum += (nrow * val);\\n                col.insert(indx);\\n                ncol--;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595078,
                "title": "python-reverse-the-queries-o-q-explained",
                "content": "Idea behind Reverse :\\nif the cells udated by the query i then some or all cells may be overwrite by the i+1 th query and so on\\n\\n\\tclass Solution:\\n\\t\\t\\t\\tdef matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\t\\t\\t\\t\\trows = [0]*n  # row[i] : is ith row already filled ?\\n\\t\\t\\t\\t\\tcols = [0]*n  # col[i] : is ith col already filled ?\\n\\t\\t\\t\\t\\tfillRows = 0\\n\\t\\t\\t\\t\\tfillCols = 0\\n\\n\\t\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\t\\tfor i in range(len(queries)-1,-1,-1):\\n\\t\\t\\t\\t\\t\\ttyp,idx,val = queries[i]\\n\\t\\t\\t\\t\\t\\tif typ == 0:\\n\\t\\t\\t\\t\\t\\t\\tif rows[idx] == 1:  # idx row already filled\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t\\tres += (n - fillCols)*val   # fillCols cells already filled in the row idx\\n\\t\\t\\t\\t\\t\\t\\trows[idx] = 1  # idx row is filled now\\n\\t\\t\\t\\t\\t\\t\\tfillRows += 1  # increase the fill rows count as idx row is filled now\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tif cols[idx] == 1:  # idx col already filled\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t\\tres += (n - fillRows)*val   # fillRows cells already filled in the col idx\\n\\t\\t\\t\\t\\t\\t\\tcols[idx] = 1  # idx col is filled now\\n\\t\\t\\t\\t\\t\\t\\tfillCols += 1  # increase the fill cols count as idx col is filled now\\n\\t\\t\\t\\t\\treturn res\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "Idea behind Reverse :\\nif the cells udated by the query i then some or all cells may be overwrite by the i+1 th query and so on\\n\\n\\tclass Solution:\\n\\t\\t\\t\\tdef matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\t\\t\\t\\t\\trows = [0]*n  # row[i] : is ith row already filled ?\\n\\t\\t\\t\\t\\tcols = [0]*n  # col[i] : is ith col already filled ?\\n\\t\\t\\t\\t\\tfillRows = 0\\n\\t\\t\\t\\t\\tfillCols = 0\\n\\n\\t\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\t\\tfor i in range(len(queries)-1,-1,-1):\\n\\t\\t\\t\\t\\t\\ttyp,idx,val = queries[i]\\n\\t\\t\\t\\t\\t\\tif typ == 0:\\n\\t\\t\\t\\t\\t\\t\\tif rows[idx] == 1:  # idx row already filled\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t\\tres += (n - fillCols)*val   # fillCols cells already filled in the row idx\\n\\t\\t\\t\\t\\t\\t\\trows[idx] = 1  # idx row is filled now\\n\\t\\t\\t\\t\\t\\t\\tfillRows += 1  # increase the fill rows count as idx row is filled now\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tif cols[idx] == 1:  # idx col already filled\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t\\tres += (n - fillRows)*val   # fillRows cells already filled in the col idx\\n\\t\\t\\t\\t\\t\\t\\tcols[idx] = 1  # idx col is filled now\\n\\t\\t\\t\\t\\t\\t\\tfillCols += 1  # increase the fill cols count as idx col is filled now\\n\\t\\t\\t\\t\\treturn res\\n",
                "codeTag": "Java"
            },
            {
                "id": 3594999,
                "title": "c-greedy-easy-and-short-solution",
                "content": "# Approach \\n- Updation of the most recent query\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long ans=0;\\n        long long r=0,c=0;\\n        vector<int>row(n+1),col(n+1);\\n        // Here we are eliminating all the repeating queries and just keeping the most recent query\\n        // We are eliminating query by changing the type of the query\\n        for(int i=q.size()-1;i>=0;i--){\\n            if(q[i][0]==0){\\n                if(row[q[i][1]]!=0) q[i][0]=2;\\n                else row[q[i][1]]=1;\\n            }\\n            else{\\n                if(col[q[i][1]]!=0) q[i][0]=2;\\n                else col[q[i][1]]=1;                \\n            }\\n        }\\n        // Just adding the complete val*n and subtracting all the previous values that have been put into rows \\n        // if the query is of column and vice versa\\n        for(auto& i:q){\\n            if(i[0]==0){               \\n                r+=i[2];\\n                ans+= i[2]*n;\\n                ans-=c; \\n            }\\n            else if(i[0]==1){\\n                c+=i[2];\\n                ans+=i[2]*n;\\n                ans-=r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long ans=0;\\n        long long r=0,c=0;\\n        vector<int>row(n+1),col(n+1);\\n        // Here we are eliminating all the repeating queries and just keeping the most recent query\\n        // We are eliminating query by changing the type of the query\\n        for(int i=q.size()-1;i>=0;i--){\\n            if(q[i][0]==0){\\n                if(row[q[i][1]]!=0) q[i][0]=2;\\n                else row[q[i][1]]=1;\\n            }\\n            else{\\n                if(col[q[i][1]]!=0) q[i][0]=2;\\n                else col[q[i][1]]=1;                \\n            }\\n        }\\n        // Just adding the complete val*n and subtracting all the previous values that have been put into rows \\n        // if the query is of column and vice versa\\n        for(auto& i:q){\\n            if(i[0]==0){               \\n                r+=i[2];\\n                ans+= i[2]*n;\\n                ans-=c; \\n            }\\n            else if(i[0]==1){\\n                c+=i[2];\\n                ans+=i[2]*n;\\n                ans-=r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594914,
                "title": "java-c-easy-to-understand-faster-than-100-with-set-o-10-5",
                "content": "# Intuition\\nI tried n^2 approach but it was giving tle\\n\\n# Approach\\nWe can declare two variables row and col which is the current length of row and col we then just take sum of the elements as we move forward.\\n\\n# Java Code \\n(special thanks to @sai_prashant)\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long row=n,col=n;\\n        long sum=0;\\n        HashSet<Integer> rowMap=new HashSet<>();\\n        HashSet<Integer> colMap=new HashSet<>();\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n                if(col<=0||rowMap.contains(queries[i][1]))continue;\\n                sum+=(col)*(long)queries[i][2];\\n                rowMap.add(queries[i][1]);\\n                row--;\\n            }else{\\n                if(row<=0||colMap.contains(queries[i][1]))continue;\\n                sum+=(row)*(long)queries[i][2];\\n                colMap.add(queries[i][1]);\\n                col--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n# C++ Code\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // so the logic is we start iterating queries array from the last\\n    // we only update one row/col only once and then skip if they appear again\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int row = n,col = n;\\n        long long ans = 0;\\n        int x = queries.size();\\n        unordered_set<int> rows,cols;\\n        for(int i=(x-1);i>=0;i--){\\n            if(col > 0 && queries[i][0] == 0){\\n                if(rows.find(queries[i][1]) == rows.end()){\\n                    ans += col * (long long) queries[i][2];\\n                    row--;\\n                    rows.insert(queries[i][1]);\\n                }\\n            }else if(row > 0){\\n                if(cols.find(queries[i][1]) == cols.end()){\\n                    ans += row * (long long) queries[i][2];\\n                    col--;\\n                    cols.insert(queries[i][1]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long row=n,col=n;\\n        long sum=0;\\n        HashSet<Integer> rowMap=new HashSet<>();\\n        HashSet<Integer> colMap=new HashSet<>();\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n                if(col<=0||rowMap.contains(queries[i][1]))continue;\\n                sum+=(col)*(long)queries[i][2];\\n                rowMap.add(queries[i][1]);\\n                row--;\\n            }else{\\n                if(row<=0||colMap.contains(queries[i][1]))continue;\\n                sum+=(row)*(long)queries[i][2];\\n                colMap.add(queries[i][1]);\\n                col--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // so the logic is we start iterating queries array from the last\\n    // we only update one row/col only once and then skip if they appear again\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int row = n,col = n;\\n        long long ans = 0;\\n        int x = queries.size();\\n        unordered_set<int> rows,cols;\\n        for(int i=(x-1);i>=0;i--){\\n            if(col > 0 && queries[i][0] == 0){\\n                if(rows.find(queries[i][1]) == rows.end()){\\n                    ans += col * (long long) queries[i][2];\\n                    row--;\\n                    rows.insert(queries[i][1]);\\n                }\\n            }else if(row > 0){\\n                if(cols.find(queries[i][1]) == cols.end()){\\n                    ans += row * (long long) queries[i][2];\\n                    col--;\\n                    cols.insert(queries[i][1]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596016,
                "title": "c-only-last-replacement-matters",
                "content": "```\\n// rows -> number of rows visited \\n// cols->number of columns visited\\n// row X cols intersection can change the values \\n// for row : r columns can change r times val of row , so just we count till now: how many number of col visited that affects the values in row (intially n values in that row)\\n// same for column \\n// visited array to maintain the index of rows/column visited to avoid the repeated replacement of same column /row\\n// only last replacement of particular row/column matters! and give contribution to sum\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) \\n    {\\n        long long ans=0;\\n        int row=0;\\n        int col=0;\\n        vector<bool> visrow(n,0),viscol(n,0);\\n        for(int i=q.size()-1;i>=0;i--)\\n        {\\n            int type=q[i][0];\\n            int val=q[i][2];\\n            if(type==0)\\n            {\\n                int rowind=q[i][1];\\n                if(visrow[rowind]==0)\\n                {\\n                ans+=1LL*val*(n-col);\\n                row++;\\n                    visrow[rowind]=1;\\n                }\\n                \\n            }\\n            else\\n            {\\n                \\n                int colind=q[i][1];\\n                if(viscol[colind]==0)\\n                {\\n                    ans+=1LL*val*(n-row);\\n                col++;\\n                    viscol[colind]=1;\\n                }\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\n// rows -> number of rows visited \\n// cols->number of columns visited\\n// row X cols intersection can change the values \\n// for row : r columns can change r times val of row , so just we count till now: how many number of col visited that affects the values in row (intially n values in that row)\\n// same for column \\n// visited array to maintain the index of rows/column visited to avoid the repeated replacement of same column /row\\n// only last replacement of particular row/column matters! and give contribution to sum\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) \\n    {\\n        long long ans=0;\\n        int row=0;\\n        int col=0;\\n        vector<bool> visrow(n,0),viscol(n,0);\\n        for(int i=q.size()-1;i>=0;i--)\\n        {\\n            int type=q[i][0];\\n            int val=q[i][2];\\n            if(type==0)\\n            {\\n                int rowind=q[i][1];\\n                if(visrow[rowind]==0)\\n                {\\n                ans+=1LL*val*(n-col);\\n                row++;\\n                    visrow[rowind]=1;\\n                }\\n                \\n            }\\n            else\\n            {\\n                \\n                int colind=q[i][1];\\n                if(viscol[colind]==0)\\n                {\\n                    ans+=1LL*val*(n-row);\\n                col++;\\n                    viscol[colind]=1;\\n                }\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595095,
                "title": "c-clean-concise-easy-to-read-and-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApproach is simple we calculate the contribution of row or col according to last query which have most priority , So we start from last and as we add contribution of any row and col we mark it as visited \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nclass Solution {\\npublic:\\n   \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n\\n        long long ans=0;       \\n       vector<int>row(n,0),col(n,0);   //making visited array for row and column\\n        \\n    int cntr=0,cntc=0;                 ///storing the count of num of row and col \\n        for(int i=q.size()-1;i>=0;i--){     //taking last querie which have more priority \\n             int ind=q[i][1];               //finding index of row or col\\n             int val=q[i][2];\\n                                             \\n            if(q[i][0]==0){               //if type ==0 it\\'s mean it is row\\n               \\n              if(row[ind]==0){\\n                  ans+=val*(n-cntc);       //  adding contribution of (n-cntc ) row cell which will have value ==val\\n                  row[ind]=1;               //mark visited\\n                  cntr++;                 \\n\\n              }\\n               \\n            }\\n            else {                             //if type ==1 it\\'s mean it is col\\n                \\n             if(col[ind]==0){\\n                ans+=val*(n-cntr);               //  adding contribution of (n-cntr ) col cell which will have value ==val\\n                cntc++;\\n                col[ind]=1;            //mark visited\\n                }\\n            \\n            }\\n            if(cntc+cntr==2*n) return ans;    //if all row and col visited then return ans\\n        }\\n               \\n        return ans;\\n    }\\n};\\n\\n# please upvote \\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n\\n        long long ans=0;       \\n       vector<int>row(n,0),col(n,0);   //making visited array for row and column\\n        \\n    int cntr=0,cntc=0;                 ///storing the count of num of row and col \\n        for(int i=q.size()-1;i>=0;i--){     //taking last querie which have more priority \\n             int ind=q[i][1];               //finding index of row or col\\n             int val=q[i][2];\\n                                             \\n            if(q[i][0]==0){               //if type ==0 it\\'s mean it is row\\n               \\n              if(row[ind]==0){\\n                  ans+=val*(n-cntc);       //  adding contribution of (n-cntc ) row cell which will have value ==val\\n                  row[ind]=1;               //mark visited\\n                  cntr++;                 \\n\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3594909,
                "title": "java-easy-solution-15-lines",
                "content": "# Complexity\\n- Time complexity: $$O(m)$$ where `m = queries.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long matrixSumQueries(int n, int[][] queries) {\\n    var rows = new boolean[n];\\n    var cols = new boolean[n];\\n    int rowCnt = n, colCnt = n;\\n    var sum = 0L;\\n    \\n    for (var i = queries.length - 1; i >=0 && rowCnt > 0 && colCnt > 0; i--) {\\n      if (queries[i][0] == 0) {\\n        if (rows[queries[i][1]]) continue;\\n        \\n        rows[queries[i][1]] = true;\\n        rowCnt--;\\n        sum += colCnt * queries[i][2];\\n      } else {\\n        if (cols[queries[i][1]]) continue;\\n        \\n        cols[queries[i][1]] = true;\\n        colCnt--;\\n        sum += rowCnt * queries[i][2];\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  public long matrixSumQueries(int n, int[][] queries) {\\n    var rows = new boolean[n];\\n    var cols = new boolean[n];\\n    int rowCnt = n, colCnt = n;\\n    var sum = 0L;\\n    \\n    for (var i = queries.length - 1; i >=0 && rowCnt > 0 && colCnt > 0; i--) {\\n      if (queries[i][0] == 0) {\\n        if (rows[queries[i][1]]) continue;\\n        \\n        rows[queries[i][1]] = true;\\n        rowCnt--;\\n        sum += colCnt * queries[i][2];\\n      } else {\\n        if (cols[queries[i][1]]) continue;\\n        \\n        cols[queries[i][1]] = true;\\n        colCnt--;\\n        sum += rowCnt * queries[i][2];\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595409,
                "title": "o-n-solution-no-tle-explained-line-by-line-fully-commented",
                "content": "# Intuition\\n First did this problem in O(n*n) , but got tle , then thought a little more and found that we are actually not required to check for all the queries and we can actually reduce the time complexity to O(n) (where n I am considering as the size of queries vector).\\n\\n# Approach\\nThe approach is that rather than starting from the start of the queries vector , i will start from the end , and for each query i will see whether it is related to the row or column. After that i will see that whether i have already considered this row/column or not. If i have already seen this row/column earlier in my query than i will not do anything , if it\\'s the first time i will do the changes then .\\n\\nAs i know there are n row/colums and i have to convert all them to new value (queries[i][2]) , so why don\\'t i just do n * queries[i][2].\\nBut the catch here is that if i will only do this then i will get sum of some cell more than one time , therefore i will subtract the sum of all the cell that i didn\\'t change this time and calculating the correct sum.\\n\\n**I hope I could make you understand the approach , go through the code ones , all the steps are very well commented.**\\n\\n# Complexity\\n- Time complexity:\\n **O(queries.size())**\\n\\n- Space complexity:\\n **all we are using is some variables to store count and 2 vectors of size n each \\nso total space complexity is O(2*n) i.e O(n).**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        // to store the final answer\\n        long long int sum = 0;\\n        \\n        // to keep check of the rows i have already seen.\\n        vector<int> row(n,0);\\n\\n        // to keep check of the rows i have already seen.\\n        vector<int> col(n,0);\\n\\n        // these will keep the count of the no. of rows and columns that i have changed\\n        int countrow = 0, countcol = 0;\\n        \\n        for(int i = queries.size()-1 ; i >= 0 ; i--){\\n            \\n            \\n            if(queries[i][0] == 0){     // i have to do operation in row\\n                \\n                // i will only update the values if i haven\\'t already done for this particular row\\n                if(row[queries[i][1]] == 0){    \\n\\n                    // total n rows , value of each cell will be queries[i][2] , so for n it will get multiplied but we will subtract the value of this queries[i][2] for the cells that were already filled.\\n                    sum += (n * queries[i][2]) - (countcol*queries[i][2]);  \\n                    countrow++;\\n                    row[queries[i][1]] = 1;\\n                }\\n                \\n            }\\n\\n            if(queries[i][0] == 1){     // i have to do operation in column\\n\\n                // i will only update the values if i haven\\'t already done for this particular row\\n                if(col[queries[i][1]] == 0){\\n\\n                    // total n colums , value of each cell will be queries[i][2] , so for n it will get multiplied but we will subtract the value of this queries[i][2] for the cells that were already filled.\\n                    sum += (n*queries[i][2]) - (countrow*queries[i][2]);\\n                    countcol++;\\n                    col[queries[i][1]] = 1;\\n                }\\n            }      \\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        // to store the final answer\\n        long long int sum = 0;\\n        \\n        // to keep check of the rows i have already seen.\\n        vector<int> row(n,0);\\n\\n        // to keep check of the rows i have already seen.\\n        vector<int> col(n,0);\\n\\n        // these will keep the count of the no. of rows and columns that i have changed\\n        int countrow = 0, countcol = 0;\\n        \\n        for(int i = queries.size()-1 ; i >= 0 ; i--){\\n            \\n            \\n            if(queries[i][0] == 0){     // i have to do operation in row\\n                \\n                // i will only update the values if i haven\\'t already done for this particular row\\n                if(row[queries[i][1]] == 0){    \\n\\n                    // total n rows , value of each cell will be queries[i][2] , so for n it will get multiplied but we will subtract the value of this queries[i][2] for the cells that were already filled.\\n                    sum += (n * queries[i][2]) - (countcol*queries[i][2]);  \\n                    countrow++;\\n                    row[queries[i][1]] = 1;\\n                }\\n                \\n            }\\n\\n            if(queries[i][0] == 1){     // i have to do operation in column\\n\\n                // i will only update the values if i haven\\'t already done for this particular row\\n                if(col[queries[i][1]] == 0){\\n\\n                    // total n colums , value of each cell will be queries[i][2] , so for n it will get multiplied but we will subtract the value of this queries[i][2] for the cells that were already filled.\\n                    sum += (n*queries[i][2]) - (countrow*queries[i][2]);\\n                    countcol++;\\n                    col[queries[i][1]] = 1;\\n                }\\n            }      \\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595345,
                "title": "good-question-with-simple-and-readable-solution-o-n-time-and-o-n-space",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        # make dictionary with default value of [1,1] where first\\n        # value represents whether type 0 is processed or not.\\n        # Similarly, second value represents whether type 1 is\\n        # processed or not\\n        d = defaultdict(lambda: [1,1])\\n\\n        # stores the summation of vlaues of matrix entries\\n        ans = 0\\n\\n        # cr, cc denotes number of rows / columns processed\\n        cr, cc = 0, 0\\n\\n        # start query from reversed fashion as we know the fact we can overwrite the\\n        # values\\n        for x, y, z in reversed(queries):\\n\\n            # For index = y and type = x, process the matrix and\\n            # later, make the value to 0.\\n            # (Remember, we move in reversed manner)\\n            # Eg. for a particular query with index y and type 0,\\n            # we made d[y] = [0,1], so that we\\'ve liabilty to process\\n            # index y with type 1 as it is set to 1\\n            if d[y][x]:\\n                # x = 0 means type 0, so increment row\\'s count\\n                if x == 0:\\n                    cr += 1\\n                # x = 1 means type 1, so increment col\\'s count\\n                else:\\n                    cc += 1\\n\\n                # while processing yth row, we\\'ve to remove those columns which are\\n                # already processed\\n                if x == 0:\\n                    remaining = n - cc\\n                # while processing yth col, we\\'ve to remove those rows which are\\n                # already processed\\n                else:\\n                    remaining = n - cr\\n\\n                # multiply with value to get the desired result and add to variable ans    \\n                ans += remaining * z\\n\\n                # since, we process the yth row / col depend upon type i.e. x, we can\\n                # now mark to 0 (Remember, we move in reversed manner)\\n                d[y][x] = 0\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        # make dictionary with default value of [1,1] where first\\n        # value represents whether type 0 is processed or not.\\n        # Similarly, second value represents whether type 1 is\\n        # processed or not\\n        d = defaultdict(lambda: [1,1])\\n\\n        # stores the summation of vlaues of matrix entries\\n        ans = 0\\n\\n        # cr, cc denotes number of rows / columns processed\\n        cr, cc = 0, 0\\n\\n        # start query from reversed fashion as we know the fact we can overwrite the\\n        # values\\n        for x, y, z in reversed(queries):\\n\\n            # For index = y and type = x, process the matrix and\\n            # later, make the value to 0.\\n            # (Remember, we move in reversed manner)\\n            # Eg. for a particular query with index y and type 0,\\n            # we made d[y] = [0,1], so that we\\'ve liabilty to process\\n            # index y with type 1 as it is set to 1\\n            if d[y][x]:\\n                # x = 0 means type 0, so increment row\\'s count\\n                if x == 0:\\n                    cr += 1\\n                # x = 1 means type 1, so increment col\\'s count\\n                else:\\n                    cc += 1\\n\\n                # while processing yth row, we\\'ve to remove those columns which are\\n                # already processed\\n                if x == 0:\\n                    remaining = n - cc\\n                # while processing yth col, we\\'ve to remove those rows which are\\n                # already processed\\n                else:\\n                    remaining = n - cr\\n\\n                # multiply with value to get the desired result and add to variable ans    \\n                ans += remaining * z\\n\\n                # since, we process the yth row / col depend upon type i.e. x, we can\\n                # now mark to 0 (Remember, we move in reversed manner)\\n                d[y][x] = 0\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604681,
                "title": "python-elegant-short-o-n-hash-map",
                "content": "# Complexity\\n- Time complexity: $$O(m)$$, where $$m$$ - length of ```queries```\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        used_cols = set()\\n        used_rows = set()\\n\\n        # Initially matrix filled with zeros\\n        queries_sum = 0\\n\\n        for op, idx, val in reversed(queries):\\n            # Fills an untouched row\\n            if op == 0 and idx not in used_rows:\\n                queries_sum += val * (n - len(used_cols))  # Column may have already filled cells with other rows\\n                used_rows.add(idx)\\n            # Fills an untouched column\\n            elif op == 1 and idx not in used_cols:\\n                queries_sum += val * (n - len(used_rows))  # Row may have already filled cells with other columns\\n                used_cols.add(idx)\\n\\n        return queries_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```queries```\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        used_cols = set()\\n        used_rows = set()\\n\\n        # Initially matrix filled with zeros\\n        queries_sum = 0\\n\\n        for op, idx, val in reversed(queries):\\n            # Fills an untouched row\\n            if op == 0 and idx not in used_rows:\\n                queries_sum += val * (n - len(used_cols))  # Column may have already filled cells with other rows\\n                used_rows.add(idx)\\n            # Fills an untouched column\\n            elif op == 1 and idx not in used_cols:\\n                queries_sum += val * (n - len(used_rows))  # Row may have already filled cells with other columns\\n                used_cols.add(idx)\\n\\n        return queries_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598544,
                "title": "python-3-7-lines-bitmap-t-m-99-90",
                "content": "\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        rowcol, ans, Seen = [n,n], 0, [0,0]\\n\\n        for typ, idx, val in reversed(queries):\\n     \\n            if Seen[typ]&(1<<idx): continue\\n            Seen[typ]|= (1<<idx)\\n    \\n            ans+= val * rowcol[typ]\\n            rowcol[typ^1]-= 1\\n\\n        return  ans\\n```\\n[https://leetcode.com/problems/sum-of-matrix-after-queries/submissions/1011786423/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(queries)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        rowcol, ans, Seen = [n,n], 0, [0,0]\\n\\n        for typ, idx, val in reversed(queries):\\n     \\n            if Seen[typ]&(1<<idx): continue\\n            Seen[typ]|= (1<<idx)\\n    \\n            ans+= val * rowcol[typ]\\n            rowcol[typ^1]-= 1\\n\\n        return  ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595969,
                "title": "simple-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& v) {\\n        long long int ans = 0;\\n        int a = n, b = n;\\n        vector<int> c(b,0),r(n,0);\\n        reverse(v.begin(),v.end());//traverse from back\\n        for(auto &i: v){\\n            cout<<a<<\" \"<<b<<endl;\\n            if(i[0]){\\n                if(a>0){\\n                    if(c[i[1]]>0)continue;\\n                    ans += i[2]*1LL*a;\\n                    c[i[1]] = i[2];\\n                }\\n                b--;\\n            }else{\\n                if(b>0){\\n                    if(r[i[1]]>0)continue;\\n                    ans += i[2]*1LL*b;\\n                    r[i[1]] = i[2];\\n                }\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& v) {\\n        long long int ans = 0;\\n        int a = n, b = n;\\n        vector<int> c(b,0),r(n,0);\\n        reverse(v.begin(),v.end());//traverse from back\\n        for(auto &i: v){\\n            cout<<a<<\" \"<<b<<endl;\\n            if(i[0]){\\n                if(a>0){\\n                    if(c[i[1]]>0)continue;\\n                    ans += i[2]*1LL*a;\\n                    c[i[1]] = i[2];\\n                }\\n                b--;\\n            }else{\\n                if(b>0){\\n                    if(r[i[1]]>0)continue;\\n                    ans += i[2]*1LL*b;\\n                    r[i[1]] = i[2];\\n                }\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3595356,
                "title": "step-by-step-detailed-explanation-of-short-code",
                "content": "# Intuition\\nThe problem involves performing sum queries on a matrix. We are given the size of the matrix n and a list of queries, where each query specifies whether to add a value to a row or column and the corresponding index. Our goal is to calculate the sum after applying all the queries.\\n\\n# Approach\\n1. Initialize a variable sum to keep track of the sum and set it to 0.\\n2. Create two sets, row and col, to store the indices of the rows and columns affected by the queries.\\n3. Iterate over the queries in reverse order, starting from the last query. This allows us to process the queries in reverse order while still maintaining the correct sum.\\n4. For each query, extract the type, index, and value.\\n5. If the query type is 1 (column query), check if the column index ind is already present in the col set. If it is, continue to the next query.\\n6. Add the column index ind to the col set.\\n7. Update the sum by adding the product of the value val and the number of rows not affected by the column queries (n - row.size).\\n8. If the query type is 0 (row query), check if the row index ind is already present in the row set. If it is, continue to the next query.\\nAdd the row index ind to the row set.\\n9. Update the sum by adding the product of the value val and the number of columns not affected by the row queries (n - col.size).\\n10. After processing all the queries, return the final value of sum.\\n# Complexity\\n* Time complexity: O(k), where k is the number of queries. We iterate over the queries in reverse order, performing constant time operations for each query.\\n* Space complexity: O(n), where n is the size of the matrix. We use two sets to store the indices of the affected rows and columns, which can have a maximum size of n.\\n\\n# Code\\n```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n    let sum = 0 ;\\n    let row = new Set() , col = new Set() , len = queries.length;\\n    for( let i = len - 1 ; i >= 0 ; i-- ){\\n        let [type , ind , val] = queries[i];\\n        if(type){\\n            if(col.has(ind))continue;\\n            col.add(ind);\\n            sum += (val * (n - row.size));\\n        }\\n        else {\\n            if(row.has(ind))continue;\\n            row.add(ind);\\n            sum += (val * (n - col.size));\\n        }\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n    let sum = 0 ;\\n    let row = new Set() , col = new Set() , len = queries.length;\\n    for( let i = len - 1 ; i >= 0 ; i-- ){\\n        let [type , ind , val] = queries[i];\\n        if(type){\\n            if(col.has(ind))continue;\\n            col.add(ind);\\n            sum += (val * (n - row.size));\\n        }\\n        else {\\n            if(row.has(ind))continue;\\n            row.add(ind);\\n            sum += (val * (n - col.size));\\n        }\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595171,
                "title": "greedy-c-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        vector<long long>col(n),row(n);\\n        \\n        long long ans=0, ro=0,co=0;\\n        \\n        for(int i=q.size()-1;i>=0;i--){\\n            \\n            int type = q[i][0];\\n            int index = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type==0){\\n                if(row[index]){\\n                    q[i][0]=2;\\n                }\\n                else {\\n                    row[index] = 1;\\n                }\\n            }\\n            else{\\n                if(col[index]){\\n                    q[i][0]=2;\\n                }\\n                else {\\n                    col[index] = 1;  \\n                }              \\n            }\\n            \\n        }\\n        for(int i=0;i<q.size();i++){\\n            \\n            int type = q[i][0];\\n            int index = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type==0){   \\n                \\n                ro+=val;\\n                ans+= val*n;\\n                ans-=co; \\n                \\n            }\\n            if(type==1){\\n                \\n                co+=val;\\n                ans+=val*n;\\n                ans-=ro;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        vector<long long>col(n),row(n);\\n        \\n        long long ans=0, ro=0,co=0;\\n        \\n        for(int i=q.size()-1;i>=0;i--){\\n            \\n            int type = q[i][0];\\n            int index = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type==0){\\n                if(row[index]){\\n                    q[i][0]=2;\\n                }\\n                else {\\n                    row[index] = 1;\\n                }\\n            }\\n            else{\\n                if(col[index]){\\n                    q[i][0]=2;\\n                }\\n                else {\\n                    col[index] = 1;  \\n                }              \\n            }\\n            \\n        }\\n        for(int i=0;i<q.size();i++){\\n            \\n            int type = q[i][0];\\n            int index = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type==0){   \\n                \\n                ro+=val;\\n                ans+= val*n;\\n                ans-=co; \\n                \\n            }\\n            if(type==1){\\n                \\n                co+=val;\\n                ans+=val*n;\\n                ans-=ro;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595013,
                "title": "reverse-order-is-the-key-c",
                "content": "# Approach\\nApply the queries in reverse order by carrying the number of rows and cols available, it is very straighfoward to update these values.\\n# Complexity\\n- Time complexity:\\n- $O(|queries|)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0; \\n        long long R= n,C =n;\\n        vector<bool> Rused(n),Cused(n);\\n        \\n        int M = queries.size();\\n        for(int i = M-1;i>=0;i--){\\n            int t = queries[i][0];     \\n            int id = queries[i][1];      \\n            long long x = queries[i][2];      \\n            \\n            if(t == 0){\\n                if(Rused[id])continue;\\n                ans += C*x;\\n                Rused[id] = true;\\n                R--;\\n            }\\n            else{\\n                if(Cused[id])continue;\\n                ans += R*x;\\n                Cused[id] = true;\\n                C--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0; \\n        long long R= n,C =n;\\n        vector<bool> Rused(n),Cused(n);\\n        \\n        int M = queries.size();\\n        for(int i = M-1;i>=0;i--){\\n            int t = queries[i][0];     \\n            int id = queries[i][1];      \\n            long long x = queries[i][2];      \\n            \\n            if(t == 0){\\n                if(Rused[id])continue;\\n                ans += C*x;\\n                Rused[id] = true;\\n                R--;\\n            }\\n            else{\\n                if(Cused[id])continue;\\n                ans += R*x;\\n                Cused[id] = true;\\n                C--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594984,
                "title": "python-reverse-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        queries.reverse()\\n        rows = set()\\n        cols = set()\\n        res = 0\\n        for t,i,val in queries:\\n            if t == 0:\\n                if i not in rows:\\n                    res += val*(n-len(cols))\\n                rows.add(i)\\n            else:\\n                if i not in cols:\\n                    res += val*(n-len(rows))\\n                cols.add(i)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        queries.reverse()\\n        rows = set()\\n        cols = set()\\n        res = 0\\n        for t,i,val in queries:\\n            if t == 0:\\n                if i not in rows:\\n                    res += val*(n-len(cols))\\n                rows.add(i)\\n            else:\\n                if i not in cols:\\n                    res += val*(n-len(rows))\\n                cols.add(i)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594962,
                "title": "strict-test-cases-3-solutions-o-n-explanation",
                "content": "Intuition:\\nGiven the input matrix and a set of queries, we need to calculate the sum of values in the matrix based on the queries. The queries specify whether to calculate row sums or column sums, along with the indices and values to be added or subtracted. To efficiently calculate the sum, we can process the queries in reverse order and keep track of the processed rows and columns.\\n\\nApproach:\\n\\nInitialize the cumulative sum variable sumi to 0.\\nCreate sets row and col to keep track of processed rows and columns, respectively.\\nIterate through the queries in reverse order using a for loop.\\nFor each query, check the value of a (0 for row sum, 1 for column sum).\\nIf a is 0 (row sum):\\nCheck if the row index b is already in the row set.\\nIf not, add the row index to the row set and update sumi by adding c * (n - len(col)), where c is the value to be added or subtracted, and (n - len(col)) represents the number of unprocessed columns.\\nIf a is 1 (column sum):\\nCheck if the column index b is already in the col set.\\nIf not, add the column index to the col set and update sumi by adding c * (n - len(row)), where (n - len(row)) represents the number of unprocessed rows.\\nReturn the final value of sumi as the result.\\nComplexity:\\n\\nTime complexity: The algorithm iterates through the queries once in reverse order, resulting in a time complexity of O(q), where q is the number of queries.\\nSpace complexity: The algorithm uses additional space to store the row and col sets, which can have at most n elements (assuming an n x n matrix). Therefore, the space complexity is O(n).\\n\\n# Code\\nACCEPTED\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        sumi = 0\\n        row = set()\\n        col = set()\\n\\n        for a, b, c in reversed(queries):\\n            if a == 0:\\n                if b not in row:\\n                    row.add(b)\\n                    sumi += c * (n - len(col))\\n            else:\\n                if b not in col:\\n                    col.add(b)\\n                    sumi += c * (n - len(row))\\n        \\n        return sumi\\n\\n\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/96e80b2b-bf6f-4773-9493-38541adeafe0_1685851459.9388924.png)\\n```\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        sumi=0\\n        row=[0]*n\\n        col=[0]*n\\n        \\n        for i in range(len(queries)-1,-1,-1):\\n            a,b,c=queries[i]\\n            if a==0:\\n                if row[b]!=1:\\n                    row[b]=1\\n                    sumi+=c*(n-sum(col))\\n                \\n            else:\\n                if col[b]!=1:\\n                    col[b]=1\\n                    sumi+=c*(n-sum(row))\\n        return sumi\\n```\\n![image.png](https://assets.leetcode.com/users/images/206dfc2c-7828-4a35-b2ba-56bcec1519d4_1685851567.7818458.png)\\n\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        d=defaultdict(int)\\n        \\n        for a,b,c in queries[::-1]:\\n            if a==0:\\n                i=0\\n                while 0<=i<n:\\n                    if (b,i) not in d:\\n                        d[(b,i)]=c\\n                    i+=1\\n            else:\\n                i=0\\n                while 0<=i<n:\\n                    if (i,b) not in d:\\n                        d[(i,b)]=c\\n                    i+=1\\n        # print(d)\\n        return sum(d.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        sumi = 0\\n        row = set()\\n        col = set()\\n\\n        for a, b, c in reversed(queries):\\n            if a == 0:\\n                if b not in row:\\n                    row.add(b)\\n                    sumi += c * (n - len(col))\\n            else:\\n                if b not in col:\\n                    col.add(b)\\n                    sumi += c * (n - len(row))\\n        \\n        return sumi\\n\\n\\n\\n```\n```\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        sumi=0\\n        row=[0]*n\\n        col=[0]*n\\n        \\n        for i in range(len(queries)-1,-1,-1):\\n            a,b,c=queries[i]\\n            if a==0:\\n                if row[b]!=1:\\n                    row[b]=1\\n                    sumi+=c*(n-sum(col))\\n                \\n            else:\\n                if col[b]!=1:\\n                    col[b]=1\\n                    sumi+=c*(n-sum(row))\\n        return sumi\\n```\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        d=defaultdict(int)\\n        \\n        for a,b,c in queries[::-1]:\\n            if a==0:\\n                i=0\\n                while 0<=i<n:\\n                    if (b,i) not in d:\\n                        d[(b,i)]=c\\n                    i+=1\\n            else:\\n                i=0\\n                while 0<=i<n:\\n                    if (i,b) not in d:\\n                        d[(i,b)]=c\\n                    i+=1\\n        # print(d)\\n        return sum(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594958,
                "title": "java-c-set-math-greedy-algo",
                "content": "Idea is to check the lastest entry for columns and rows only and \\nentries to take in a latest row = (n - number column entries considered till now ) * value of latest row \\nentries to take in a latest column = (n - number row entries considered till now) * value of latest column\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long totalSum = 0, cNo = 0, rNo = 0;\\n        unordered_set<int> r, c;\\n        for(int indx = q.size()-1; indx > - 1 ; indx--){\\n            auto qs = q[indx];\\n            if(!qs[0] && r.find(qs[1]) == r.end()){\\n                r.insert(qs[1]);\\n                rNo++;\\n               totalSum += (qs[2] * (n-cNo));\\n      \\n            }else if(qs[0] && c.find(qs[1]) == c.end()){\\n                c.insert(qs[1]);\\n                cNo++;\\n               totalSum += (qs[2] * (n- rNo));\\n            }\\n            \\n        }\\n        return totalSum;\\n     \\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] q) {\\n        long totalSum = 0, cNo = 0, rNo = 0;\\n        HashSet<Integer> r = new HashSet<>(), c = new HashSet<>();\\n        for(int indx = q.length-1; indx > - 1 ; indx--){\\n            var qs = q[indx];\\n            if(qs[0] == 0 && !r.contains(qs[1])){\\n                r.add(qs[1]);\\n                rNo++;\\n               totalSum += (qs[2] * (n-cNo));\\n      \\n            }else if(qs[0] == 1 && !c.contains(qs[1])){\\n                c.add(qs[1]);\\n                cNo++;\\n               totalSum += (qs[2] * (n- rNo));\\n            }\\n            \\n        }\\n        return totalSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long totalSum = 0, cNo = 0, rNo = 0;\\n        unordered_set<int> r, c;\\n        for(int indx = q.size()-1; indx > - 1 ; indx--){\\n            auto qs = q[indx];\\n            if(!qs[0] && r.find(qs[1]) == r.end()){\\n                r.insert(qs[1]);\\n                rNo++;\\n               totalSum += (qs[2] * (n-cNo));\\n      \\n            }else if(qs[0] && c.find(qs[1]) == c.end()){\\n                c.insert(qs[1]);\\n                cNo++;\\n               totalSum += (qs[2] * (n- rNo));\\n            }\\n            \\n        }\\n        return totalSum;\\n     \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] q) {\\n        long totalSum = 0, cNo = 0, rNo = 0;\\n        HashSet<Integer> r = new HashSet<>(), c = new HashSet<>();\\n        for(int indx = q.length-1; indx > - 1 ; indx--){\\n            var qs = q[indx];\\n            if(qs[0] == 0 && !r.contains(qs[1])){\\n                r.add(qs[1]);\\n                rNo++;\\n               totalSum += (qs[2] * (n-cNo));\\n      \\n            }else if(qs[0] == 1 && !c.contains(qs[1])){\\n                c.add(qs[1]);\\n                cNo++;\\n               totalSum += (qs[2] * (n- rNo));\\n            }\\n            \\n        }\\n        return totalSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594891,
                "title": "real-hard-3-methods-explained",
                "content": "**<<<<UPvote**\\n\\n\\n\\n**IDEA**\\nThe brute force requires every cell to be traversed so it will cause TLE (n^2).\\nSince the order of queries also matters, so we can\\'t simply store the change and result them all later.\\n**1st Approach**\\nIn this approach, we iterate from the end and keep track of remaining rows and columns. We calculate the contribution based on the current value and remaining rows/columns, considering the effect of row and column operations. By decrementing the counts for each operation, we ensure accurate calculation of the contribution.\\n\\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n        long long ans = 0, rowRemain = n, colRemain = n;\\n        for(int i = q.size()-1; i >= 0; --i){\\n            if(q[i][0] == 0 && rowFlag[q[i][1]]) { ans += colRemain * q[i][2];    rowFlag[q[i][1]] = 0; rowRemain--; }\\n            if(q[i][0] == 1 && colFlag[q[i][1]]) { ans += rowRemain * q[i][2];    colFlag[q[i][1]] = 0; colRemain--; }\\n        }\\n        return ans;\\n    }\\n\\n```\\n\\n\\n\\n**2nd Approach**\\n\\nWe start with the last query and go backwards.\\n\\nWe track if we have seen a row or column with id - so we can ignore earlier queries that will be overwritten.\\n\\nWe also count how many rows and columns have not been seen in cnt.\\n\\nThis way, each query adds v * cnt, where cnt is the count of unseen rows (for type == 0) or columns (for type == 1).\\n\\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cnt[2] = {n, n};\\n    bool seen[2][10001] = {};\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (!seen[type][id]) {\\n            seen[type][id] = true;\\n            res += v * cnt[!type];\\n            --cnt[type];\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\n**3rd Approach**\\n\\n\\nSuppose if a cell is made under two or more updations, then the final value will surely update the previous and it will be the answer. So if we approach from backwards (in the queries array) and then check if the current cell is already updated then it means we don\\'t need to sum the current value.\\n\\n**Complexity**\\nTime complexity:\\nO(queries.length())\\nSpace complexity:\\nO(n)\\nCode\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> rowV(n, -1), colV(n, -1);\\n        int rowC, colC;\\n        \\n        //It is done only to make the backward iteration simpler.\\n        reverse(queries.begin(), queries.end());\\n        \\n        long long sum=0;\\n        for(auto q : queries) {\\n            if((q[0] == 0 && rowV[q[1]] != -1) || (q[0] == 1 && colV[q[1]] != -1)) {\\n                continue;        \\n            }\\n            else {\\n                if(q[0] == 0) {\\n                    sum += (n-colC)*q[2];\\n                    rowV[q[1]] = q[2];\\n                    rowC++;\\n                }\\n                else {\\n                    sum += (n-rowC)*q[2];\\n                    colV[q[1]] = q[2];\\n                    colC++;\\n                }\\n                \\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n        long long ans = 0, rowRemain = n, colRemain = n;\\n        for(int i = q.size()-1; i >= 0; --i){\\n            if(q[i][0] == 0 && rowFlag[q[i][1]]) { ans += colRemain * q[i][2];    rowFlag[q[i][1]] = 0; rowRemain--; }\\n            if(q[i][0] == 1 && colFlag[q[i][1]]) { ans += rowRemain * q[i][2];    colFlag[q[i][1]] = 0; colRemain--; }\\n        }\\n        return ans;\\n    }\\n\\n```\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cnt[2] = {n, n};\\n    bool seen[2][10001] = {};\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (!seen[type][id]) {\\n            seen[type][id] = true;\\n            res += v * cnt[!type];\\n            --cnt[type];\\n        }\\n    }\\n    return res;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> rowV(n, -1), colV(n, -1);\\n        int rowC, colC;\\n        \\n        //It is done only to make the backward iteration simpler.\\n        reverse(queries.begin(), queries.end());\\n        \\n        long long sum=0;\\n        for(auto q : queries) {\\n            if((q[0] == 0 && rowV[q[1]] != -1) || (q[0] == 1 && colV[q[1]] != -1)) {\\n                continue;        \\n            }\\n            else {\\n                if(q[0] == 0) {\\n                    sum += (n-colC)*q[2];\\n                    rowV[q[1]] = q[2];\\n                    rowC++;\\n                }\\n                else {\\n                    sum += (n-rowC)*q[2];\\n                    colV[q[1]] = q[2];\\n                    colC++;\\n                }\\n                \\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606245,
                "title": "c-java-iterating-from-the-final-query-to-the-first",
                "content": "The problem statement reveals that iterating from the first to the last query allows each subsequent query to overwrite previous values. Consequently, when we reverse this process, iterating from the last query to the first, no query can supersede the one following it. Instead, they only fill values in specific rows or columns if there are entries with a value of 0.\\n\\nTo facilitate this, we utilize two variables: `rows_filled` and `cols_filled` to track how many rows and columns have been populated so far. When filling a row, the focus is on the number of columns yet to be filled. Values are then filled into these columns, and `rows_filled` is incremented by one. Similarly, when filling a column, the emphasis is on the unpopulated rows. Values are filled into these rows, and `cols_filled` is increased by one.\\n\\nHowever, we must account for a potential edge case where the queries attempt to fill a row or column multiple times. Since our reverse iteration prevents any query from overwriting a previous one, each row or column can only be filled once. To handle this, we deploy two boolean arrays that track whether a row or column has already been filled.\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int rows_filled = 0, cols_filled = 0;\\n        vector<bool> rows(n, 0), cols(n, 0);\\n        long sum = 0l;\\n        for (int i = queries.size() - 1; i >= 0; i--) {\\n            vector<int> q = queries[i];\\n            if (q[0] == 0) {\\n                if (rows[q[1]]) continue;\\n                rows[q[1]] = 1;\\n                sum += q[2] * (n - cols_filled);\\n                rows_filled++;\\n            } else {\\n                if (cols[q[1]]) continue;\\n                cols[q[1]] = 1;\\n                sum += q[2] * (n - rows_filled);\\n                cols_filled++;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowsFilled = 0, colsFilled = 0;\\n        boolean[] rows = new boolean[n], cols = new boolean[n];\\n        long sum = 0l;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int[] q = queries[i];\\n            if (q[0] == 0) {\\n                if (rows[q[1]]) continue;\\n                rows[q[1]] = true;\\n                sum += q[2] * (n - colsFilled);\\n                rowsFilled++;\\n            } else {\\n                if (cols[q[1]]) continue;\\n                cols[q[1]] = true;\\n                sum += q[2] * (n - rowsFilled);\\n                colsFilled++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int rows_filled = 0, cols_filled = 0;\\n        vector<bool> rows(n, 0), cols(n, 0);\\n        long sum = 0l;\\n        for (int i = queries.size() - 1; i >= 0; i--) {\\n            vector<int> q = queries[i];\\n            if (q[0] == 0) {\\n                if (rows[q[1]]) continue;\\n                rows[q[1]] = 1;\\n                sum += q[2] * (n - cols_filled);\\n                rows_filled++;\\n            } else {\\n                if (cols[q[1]]) continue;\\n                cols[q[1]] = 1;\\n                sum += q[2] * (n - rows_filled);\\n                cols_filled++;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowsFilled = 0, colsFilled = 0;\\n        boolean[] rows = new boolean[n], cols = new boolean[n];\\n        long sum = 0l;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int[] q = queries[i];\\n            if (q[0] == 0) {\\n                if (rows[q[1]]) continue;\\n                rows[q[1]] = true;\\n                sum += q[2] * (n - colsFilled);\\n                rowsFilled++;\\n            } else {\\n                if (cols[q[1]]) continue;\\n                cols[q[1]] = true;\\n                sum += q[2] * (n - rowsFilled);\\n                colsFilled++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599051,
                "title": "c-straight-forward-o-n-solution-w-intuition-code-traversing-queries-from-end",
                "content": "# Intuition\\nWe can think of this problem as painting a grid wall. At every query, you\\'re painting the $$q[i][1]^{th}$$ row/columns based on type, with paint $$q[i][2]$$.\\nNow a simple thing that you need to think of is that when the if a part of wall is painted with color `x` and later on if that part is painted with paint `y` then the color `y` will be the current color of the wall which in this case is the value of the cell.\\n\\nThis means that we can traverse the queries from the end and add the `val` for the respective row/columns, and if the same row/column is being painted in an earlier query we can ignore the change.\\n\\nAnother important thing is to know is that if we\\'re painting a row and if two columns of that row are painted in a later query, we need to ignore those two columns\\' values. We\\'ll decrease the number of columns when we paint rows and vice versa. This will be more clearer in the approach and the code.\\nSimilar to the above point, we need to take care of the same row/column being painted twice. Only the latest query for that row should be considered. (we\\'ll use a HashSet for this)\\n\\n# Approach\\n1. Store the number of rows `r` and columns `c`\\n2. Create two vectors (one for Rows Filled and one for Columns Filled) to see if the row/columns is already filled at a later point.\\n3. Repeat step `4` to `x` for all queries from **end** to **start**\\n4. If `type == 0` and `row is not painted` then add `c*val` to the answer. Reduce `r` by `1`. Mark row as painted.\\n5. If `type == 1` and `column is not painted` then add `r*val` to the answer. Reduce `c` by `1`. Mark columns as painted.\\n\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int r=n, c=n;\\n        vector<bool> rf(n, false), cf(n, false);\\n        long long res{0ll};\\n        for(int i=queries.size()-1; i>=0 && r>=0 && c>=0; i--) {\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            if (type == 0) {\\n                if (rf[idx]) continue;\\n                res += (long long)c*val;\\n                r--;\\n                rf[idx] = true;\\n            }\\n            else {\\n                if (cf[idx]) continue;\\n                res += (long long)r*val;\\n                c--;\\n                cf[idx] = true;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(||queries||)$$\\nSince we\\'re traversing through all the queries, it\\'ll take the number of queries time.\\n\\n- Space complexity: $$O(n + n)$$\\nSince we\\'re using two Arrays/HashSets.\\n\\n\\n> ### Note\\n> - Upvote if you liked my solution\\n> - Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int r=n, c=n;\\n        vector<bool> rf(n, false), cf(n, false);\\n        long long res{0ll};\\n        for(int i=queries.size()-1; i>=0 && r>=0 && c>=0; i--) {\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            if (type == 0) {\\n                if (rf[idx]) continue;\\n                res += (long long)c*val;\\n                r--;\\n                rf[idx] = true;\\n            }\\n            else {\\n                if (cf[idx]) continue;\\n                res += (long long)r*val;\\n                c--;\\n                cf[idx] = true;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596202,
                "title": "c-most-easy-greedy-solution-by-reverse-iteration",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(),queries.end());\\n        unordered_set<ll> row,col;\\n        ll cntr=0,cntc=0;\\n        ll ans=0;\\n        for(auto it:queries)\\n        {\\n            int type=it[0];\\n            int ind=it[1];\\n            int val=it[2];\\n            if(type==0)\\n            {\\n                if(row.find(ind)==row.end())\\n                {\\n                row.insert(ind);\\n                ans+=(n-cntc)*val*1LL;\\n                cntr++;\\n                }\\n            }\\n            if(type==1)\\n            {\\n                 if(col.find(ind)==col.end())\\n                 {\\n                     col.insert(ind);\\n                    ans+=(n-cntr)*val*1LL;\\n                    cntc++;\\n                 }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(),queries.end());\\n        unordered_set<ll> row,col;\\n        ll cntr=0,cntc=0;\\n        ll ans=0;\\n        for(auto it:queries)\\n        {\\n            int type=it[0];\\n            int ind=it[1];\\n            int val=it[2];\\n            if(type==0)\\n            {\\n                if(row.find(ind)==row.end())\\n                {\\n                row.insert(ind);\\n                ans+=(n-cntc)*val*1LL;\\n                cntr++;\\n                }\\n            }\\n            if(type==1)\\n            {\\n                 if(col.find(ind)==col.end())\\n                 {\\n                     col.insert(ind);\\n                    ans+=(n-cntr)*val*1LL;\\n                    cntc++;\\n                 }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595596,
                "title": "java-o-n-solution-with-explanation-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLast query will always have all row/col filled. Starting from last query to 1st, each query will fill only those empty spaces left by pervious query.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - Maintain a set each for rows and cols.\\n - For each query starting from the last to first, check if the row/col to be filled is already filled. \\n - If its already filled, that means in the natural order(first to last), the current value will get overwritten so no need to consider this query.\\n - If not filled, add the row/col index to the row/col set respectively.\\n - Check the size of col set for type == 0 and row set for type == 1. This will tell us number of columns/rows already filled. We will therefore have (n-size) cells which will be filled by current query. So increment in total sum from this query will be (n - size) * value(i.e. queries[i][2]) \\n\\n# Complexity\\n- Time complexity: O(K), where K = length of queries array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        long sum = 0;\\n        for(int i=queries.length-1; i>=0; i--) {\\n            long currSum = 0;\\n            if(queries[i][0] == 0) {\\n                int row = queries[i][1];\\n                if(rows.contains(row))\\n                    continue;\\n                rows.add(queries[i][1]);\\n                int count = n - cols.size();\\n                \\n                currSum = (long) queries[i][2] * count;\\n            } else {\\n                int col = queries[i][1];\\n                if(cols.contains(col))\\n                    continue;\\n                \\n                cols.add(queries[i][1]);\\n                int count = n - rows.size();\\n                \\n                currSum = (long) queries[i][2] * count;\\n            }\\n            \\n            sum += currSum;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        long sum = 0;\\n        for(int i=queries.length-1; i>=0; i--) {\\n            long currSum = 0;\\n            if(queries[i][0] == 0) {\\n                int row = queries[i][1];\\n                if(rows.contains(row))\\n                    continue;\\n                rows.add(queries[i][1]);\\n                int count = n - cols.size();\\n                \\n                currSum = (long) queries[i][2] * count;\\n            } else {\\n                int col = queries[i][1];\\n                if(cols.contains(col))\\n                    continue;\\n                \\n                cols.add(queries[i][1]);\\n                int count = n - rows.size();\\n                \\n                currSum = (long) queries[i][2] * count;\\n            }\\n            \\n            sum += currSum;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594998,
                "title": "c-using-two-sets",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        unordered_set<int> row, col;\\n        for (int i = queries.size() - 1; i >= 0; i--){\\n            if(queries[i][0]){\\n                if(col.find(queries[i][1]) == col.end()){\\n                    col.insert(queries[i][1]);\\n                    sum += (n - row.size()) * queries[i][2];\\n                }\\n            }\\n            else{\\n                if(row.find(queries[i][1]) == row.end()){\\n                    row.insert(queries[i][1]);\\n                    sum += (n - col.size()) * queries[i][2];\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        unordered_set<int> row, col;\\n        for (int i = queries.size() - 1; i >= 0; i--){\\n            if(queries[i][0]){\\n                if(col.find(queries[i][1]) == col.end()){\\n                    col.insert(queries[i][1]);\\n                    sum += (n - row.size()) * queries[i][2];\\n                }\\n            }\\n            else{\\n                if(row.find(queries[i][1]) == row.end()){\\n                    row.insert(queries[i][1]);\\n                    sum += (n - col.size()) * queries[i][2];\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594911,
                "title": "easy-explaination-intution-0-n-easy-and-simple-code",
                "content": "# Intuition\\nDon\\'t worry if you were not able to solve this problem during the contest,\\nLets get into the question:\\n\\nwe have to **Return the sum of integers in the matrix after all queries are applied ** So, If you observe the if we see the changes made in the **REVERSE ORDER** , then you just need to update the 2d matrix once, if again the same indices appear do not bother about it.\\n\\nA problem was not how to build an effective algorithm.\\n1. Observe the change when a column or a row is added, what changes do we see for the upcoming values.\\n\\nEverytime a new column or row filled with a given value is added, next time empty places for the upcoming element decreses by 1.\\n\\n---\\nSee:\\n        Take a 3X3 matrix all filled with 0,s\\n        0 0 0\\n        0 0 0\\n        0 0 0\\nNow lets us add value 1 to the first row:\\n        1 1 1\\n        0 0 0\\n        0 0 0\\nNow see for and upcoming values for the column you\\'ll have n-1 places to fill it, the same goes vice versa. \\n\\n\\n\\n\\n      \\n\\n\\n# Approach\\n1. Firstly reverse the array.\\n2. Initialize a set data structue to keep the track of the row number or the column number for which you have made the changes.\\n3. Add to answer val * remaining row when col operation is performed &\\nadd to answer val * remaining col when row operation is performed.\\n4. Decreament remaining row when row operation is performed &\\nreamining col when col operation is performed.\\n\\n# Complexity\\n- Time complexity:\\n0(n) where n is the number of queries\\n\\n- Space complexity:\\n0(n) set size where n is the number of indices\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& a) {\\n        int x = a.size();\\n        int row = n,col = n;\\n        reverse(a.begin(),a.end()); // Key observaition\\n        long long ans = 0;\\n        set<pair<int,int>> st;\\n        for(int i=0;i<x;i++)\\n        {\\n            int type = a[i][0];\\n            int flag = a[i][1];\\n            int val = a[i][2];\\n            if(st.find({type,flag})==st.end())\\n            {\\n                st.insert({type,flag});\\n                if(type==0)\\n                {\\n                    long long temp1 = row*val; // Simple maths\\n                    col--;\\n                    ans+= temp1;\\n                }\\n                else if(type==1)\\n                {\\n                    long long temp2 = col*val;\\n                    row--;\\n                    ans+= temp2;\\n                }\\n            }\\n            else if(st.find({type,flag})!=st.end())continue;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& a) {\\n        int x = a.size();\\n        int row = n,col = n;\\n        reverse(a.begin(),a.end()); // Key observaition\\n        long long ans = 0;\\n        set<pair<int,int>> st;\\n        for(int i=0;i<x;i++)\\n        {\\n            int type = a[i][0];\\n            int flag = a[i][1];\\n            int val = a[i][2];\\n            if(st.find({type,flag})==st.end())\\n            {\\n                st.insert({type,flag});\\n                if(type==0)\\n                {\\n                    long long temp1 = row*val; // Simple maths\\n                    col--;\\n                    ans+= temp1;\\n                }\\n                else if(type==1)\\n                {\\n                    long long temp2 = col*val;\\n                    row--;\\n                    ans+= temp2;\\n                }\\n            }\\n            else if(st.find({type,flag})!=st.end())continue;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594896,
                "title": "only-logic-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) The brute force requires every cell to be traversed so it will cause TLE (n^2).\\n2) Since the order of queries also matters, so we can\\'t simply store the change and result them all later.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose if a cell is made under two or more updations, then the final value will surely update the previous and it will be the answer. So if we approach from backwards (in the queries array) and then check if the current cell is already updated then it means we don\\'t need to sum the current value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(queries.length())\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> rowV(n, -1), colV(n, -1);\\n        int rowC, colC;\\n        \\n        //It is done only to make the backward iteration simpler.\\n        reverse(queries.begin(), queries.end());\\n        \\n        long long sum=0;\\n        for(auto q : queries) {\\n            if((q[0] == 0 && rowV[q[1]] != -1) || (q[0] == 1 && colV[q[1]] != -1)) {\\n                continue;        \\n            }\\n            else {\\n                if(q[0] == 0) {\\n                    sum += (n-colC)*q[2];\\n                    rowV[q[1]] = q[2];\\n                    rowC++;\\n                }\\n                else {\\n                    sum += (n-rowC)*q[2];\\n                    colV[q[1]] = q[2];\\n                    colC++;\\n                }\\n                \\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> rowV(n, -1), colV(n, -1);\\n        int rowC, colC;\\n        \\n        //It is done only to make the backward iteration simpler.\\n        reverse(queries.begin(), queries.end());\\n        \\n        long long sum=0;\\n        for(auto q : queries) {\\n            if((q[0] == 0 && rowV[q[1]] != -1) || (q[0] == 1 && colV[q[1]] != -1)) {\\n                continue;        \\n            }\\n            else {\\n                if(q[0] == 0) {\\n                    sum += (n-colC)*q[2];\\n                    rowV[q[1]] = q[2];\\n                    rowC++;\\n                }\\n                else {\\n                    sum += (n-rowC)*q[2];\\n                    colV[q[1]] = q[2];\\n                    colC++;\\n                }\\n                \\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619738,
                "title": "simple-small-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MatrixSumQueries(int n, int[][] queries) {\\n        \\n        var rows = new HashSet<int>();\\n        var columns = new HashSet<int>();\\n        long sum = 0;\\n\\n        for(int i = queries.Length - 1; i >= 0; i--)\\n        {\\n            var isRow = queries[i][0] == 0;\\n            var isColumn = queries[i][0] == 1;\\n            var index = queries[i][1];\\n            var val =  queries[i][2];\\n\\n            if(isRow && !rows.Contains(index))\\n            {\\n                sum += (n - columns.Count) * val;\\n                rows.Add(index);\\n            }\\n            else if(isColumn && !columns.Contains(index))\\n            {\\n                sum +=  (n - rows.Count) * val;\\n                columns.Add(index);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MatrixSumQueries(int n, int[][] queries) {\\n        \\n        var rows = new HashSet<int>();\\n        var columns = new HashSet<int>();\\n        long sum = 0;\\n\\n        for(int i = queries.Length - 1; i >= 0; i--)\\n        {\\n            var isRow = queries[i][0] == 0;\\n            var isColumn = queries[i][0] == 1;\\n            var index = queries[i][1];\\n            var val =  queries[i][2];\\n\\n            if(isRow && !rows.Contains(index))\\n            {\\n                sum += (n - columns.Count) * val;\\n                rows.Add(index);\\n            }\\n            else if(isColumn && !columns.Contains(index))\\n            {\\n                sum +=  (n - rows.Count) * val;\\n                columns.Add(index);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619429,
                "title": "easy-clean-python3-solution-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved even with simulating the process but that approach is too slow. So, what we can do is maintain sets of rows and columns changed and start with final queries (i.e., the queries whose changes don\\'t get modified again)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by iterating the queries in reverse order as the final query will never get overrridden and is final. We keep a count of number of rows and columns changed so far in order to keep track of how many cells are modified at each query.\\nWe also keep track of all the changed rows and columns (using sets) so that once a row or column is modified, it isn\\'t modified again (as we are traversing in reverse order, the later changes are actually ones which were supposed to happen earlier but were overridden by later queries)\\nThe ans variable is updated with each query.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the size od queries list\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0 \\n        rowchng, colchng = 0,0\\n        row, col = set(), set()\\n        for i in range(len(queries)-1,-1,-1):\\n            typ, ind, val = queries[i]\\n            if typ == 0:\\n                if ind not in row:\\n                    row.add(ind)\\n                    ans += (n-colchng)*val\\n                    rowchng += 1\\n            else:\\n                if ind not in col:\\n                    ans += (n-rowchng)*val\\n                    colchng += 1\\n                    col.add(ind)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0 \\n        rowchng, colchng = 0,0\\n        row, col = set(), set()\\n        for i in range(len(queries)-1,-1,-1):\\n            typ, ind, val = queries[i]\\n            if typ == 0:\\n                if ind not in row:\\n                    row.add(ind)\\n                    ans += (n-colchng)*val\\n                    rowchng += 1\\n            else:\\n                if ind not in col:\\n                    ans += (n-rowchng)*val\\n                    colchng += 1\\n                    col.add(ind)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598293,
                "title": "easiy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long sum=0;\\n        map<int,int> mpr,mpc;\\n        set<int> sr,sc;\\n        int some=q.size();\\n        for(int i=some-1;i>=0;i--){\\n            int type=q[i][0];\\n            int ind=q[i][1];\\n            int val=q[i][2];\\n            if(type==0){\\n                if(mpr[ind]==0){\\n                    sum+=((n-sc.size())*val);\\n                    mpr[ind]=1;\\n                    sr.insert(ind);\\n                }\\n            }\\n            else{\\n                if(mpc[ind]==0){\\n                    sum+=((n-sr.size())*val);\\n                    mpc[ind]=1;\\n                    sc.insert(ind);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long sum=0;\\n        map<int,int> mpr,mpc;\\n        set<int> sr,sc;\\n        int some=q.size();\\n        for(int i=some-1;i>=0;i--){\\n            int type=q[i][0];\\n            int ind=q[i][1];\\n            int val=q[i][2];\\n            if(type==0){\\n                if(mpr[ind]==0){\\n                    sum+=((n-sc.size())*val);\\n                    mpr[ind]=1;\\n                    sr.insert(ind);\\n                }\\n            }\\n            else{\\n                if(mpc[ind]==0){\\n                    sum+=((n-sr.size())*val);\\n                    mpc[ind]=1;\\n                    sc.insert(ind);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597048,
                "title": "easy-cpp-solution",
                "content": "# Approach \\nTry reverse order of queries.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        #define ll long long\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n            ios_base::sync_with_stdio(false);\\n            cin.tie(NULL);\\n            ll ans = 0;\\n            vector<bool>row(n),col(n);\\n            ll size = n*n;\\n            ll colu=0,rowu=0;\\n            for(int i=queries.size()-1;i>=0;i--){\\n                    int type = queries[i][0];\\n                    if(type==0){\\n                            if(row[queries[i][1]]==false){\\n                                    ll op = n-colu;\\n                                    ans+=(1LL*queries[i][2]*op);\\n                                    rowu++;\\n                                    row[queries[i][1]]=true;\\n                            } \\n                    }else{\\n                            if(col[queries[i][1]]==false){\\n                                   ll op = n-rowu;\\n                                   ans+=(1LL*queries[i][2]*op);\\n                                   colu++; \\n                                   col[queries[i][1]]=true;\\n                            }\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        #define ll long long\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n            ios_base::sync_with_stdio(false);\\n            cin.tie(NULL);\\n            ll ans = 0;\\n            vector<bool>row(n),col(n);\\n            ll size = n*n;\\n            ll colu=0,rowu=0;\\n            for(int i=queries.size()-1;i>=0;i--){\\n                    int type = queries[i][0];\\n                    if(type==0){\\n                            if(row[queries[i][1]]==false){\\n                                    ll op = n-colu;\\n                                    ans+=(1LL*queries[i][2]*op);\\n                                    rowu++;\\n                                    row[queries[i][1]]=true;\\n                            } \\n                    }else{\\n                            if(col[queries[i][1]]==false){\\n                                   ll op = n-rowu;\\n                                   ans+=(1LL*queries[i][2]*op);\\n                                   colu++; \\n                                   col[queries[i][1]]=true;\\n                            }\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596562,
                "title": "video-explanation-binary-search-intuition",
                "content": "# Explanation\\n\\n[Click here for the video](https://youtu.be/OJiVpzztP_s)\\n\\n# Code\\n```\\ntypedef long long int ll;\\n\\n#define pii pair<int, int>\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<pii> rows(n, make_pair(-1, 0));\\n        vector<pii> cols(n, make_pair(-1, 0));\\n        \\n        for (int j = 0; j < queries.size(); j ++) {\\n            vector<int> q = queries[j];\\n            \\n            if (q[0] == 0) \\n                rows[q[1]] = {j, q[2]};\\n            else \\n                cols[q[1]] = {j, q[2]};\\n        }\\n        \\n        long long result = 0;\\n        \\n        /*\\n        for (int r = 0; r < n; r ++) {\\n            for (int c = 0; c < n; c ++) {\\n                pii val = max (rows[r], cols[c]);\\n                result += val.S;\\n            }\\n        }\\n        */\\n        \\n        sort (cols.begin(), cols.end());\\n        \\n        vector<ll> prefix_cols(n+1, 0);\\n        for (int j = 1; j <= n; j ++) prefix_cols[j] = prefix_cols[j-1] + cols[j-1].S;\\n        \\n        for (int r = 0; r < n; r ++) {\\n            pii row = rows[r];\\n            ll col_pos = lower_bound(cols.begin(), cols.end(), row) - cols.begin();\\n            \\n            result += col_pos * row.S;\\n            if (col_pos < n) result += (prefix_cols[n] - prefix_cols[col_pos]);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\n#define pii pair<int, int>\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<pii> rows(n, make_pair(-1, 0));\\n        vector<pii> cols(n, make_pair(-1, 0));\\n        \\n        for (int j = 0; j < queries.size(); j ++) {\\n            vector<int> q = queries[j];\\n            \\n            if (q[0] == 0) \\n                rows[q[1]] = {j, q[2]};\\n            else \\n                cols[q[1]] = {j, q[2]};\\n        }\\n        \\n        long long result = 0;\\n        \\n        /*\\n        for (int r = 0; r < n; r ++) {\\n            for (int c = 0; c < n; c ++) {\\n                pii val = max (rows[r], cols[c]);\\n                result += val.S;\\n            }\\n        }\\n        */\\n        \\n        sort (cols.begin(), cols.end());\\n        \\n        vector<ll> prefix_cols(n+1, 0);\\n        for (int j = 1; j <= n; j ++) prefix_cols[j] = prefix_cols[j-1] + cols[j-1].S;\\n        \\n        for (int r = 0; r < n; r ++) {\\n            pii row = rows[r];\\n            ll col_pos = lower_bound(cols.begin(), cols.end(), row) - cols.begin();\\n            \\n            result += col_pos * row.S;\\n            if (col_pos < n) result += (prefix_cols[n] - prefix_cols[col_pos]);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596280,
                "title": "clean-best-c-code-greedy-traverse-from-back",
                "content": "# Complexity\\n- Time complexity:\\nO(q) where \\'q\\' is the size of the query\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long sum = 0;\\n        vector<int> row(n),col(n);\\n        int row_visited = 0,col_visited = 0,que_size = queries.size();\\n        for(int i=que_size-1;i>=0;i--){\\n            int type = queries[i][0],ind = queries[i][1],val = queries[i][2];\\n            if((type && col[ind]) || (!type && row[ind]))\\n                continue;\\n            if(type){\\n                sum += (n - row_visited)*val; \\n                col_visited++;\\n                col[ind] = 1;\\n            }\\n            else{\\n                sum += (n - col_visited)*val; \\n                row_visited++;\\n                row[ind] = 1;\\n            }\\n                \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long sum = 0;\\n        vector<int> row(n),col(n);\\n        int row_visited = 0,col_visited = 0,que_size = queries.size();\\n        for(int i=que_size-1;i>=0;i--){\\n            int type = queries[i][0],ind = queries[i][1],val = queries[i][2];\\n            if((type && col[ind]) || (!type && row[ind]))\\n                continue;\\n            if(type){\\n                sum += (n - row_visited)*val; \\n                col_visited++;\\n                col[ind] = 1;\\n            }\\n            else{\\n                sum += (n - col_visited)*val; \\n                row_visited++;\\n                row[ind] = 1;\\n            }\\n                \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596093,
                "title": "c-easy-to-understand-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code processes a series of queries, each representing either a row or a column in a matrix.\\n2. It stores the values assigned to each row and column in separate vectors (row and col).\\n3. The code sorts the row queries based on their order of occurrence.\\n4. It calculates the cumulative sum of row values, representing the sum of values in each row up to that point.\\n5. It creates a vector (ans) with the indices of the row queries.\\n6. The code iterates through the column queries and finds the relevant row queries using binary search.\\n7. It calculates the sum based on the contributions of rows and columns.\\n8. Finally, it returns the computed sum as the result.\\n\\n# Complexity\\n- Time complexity: O(N*LOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(3*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<pair<int,long long>> row(n,{0,0}),col(n,{0,0});\\n        for(int i=0;i<queries.size();++i){\\n            int type=queries[i][0];\\n            int x=queries[i][1];\\n            int val=queries[i][2];\\n            if(type==0){\\n                row[x]=make_pair(i+1,val);\\n            }\\n            else{\\n                col[x]=make_pair(i+1,val);\\n            }\\n        }\\n        sort(row.begin(),row.end());\\n        for(int i=1;i<n;++i){\\n            row[i].second+=row[i-1].second;\\n        }\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n;++i){\\n            ans[i]=row[i].first;\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;++i){\\n            int ind=upper_bound(ans.begin(),ans.end(),col[i].first)-ans.begin();\\n            if(ind==0){\\n                sum+=row[n-1].second*1ll;\\n            }\\n            else{\\n                sum+=(ind*col[i].second)*1ll;\\n                sum+=(row[n-1].second-row[ind-1].second)*1ll;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<pair<int,long long>> row(n,{0,0}),col(n,{0,0});\\n        for(int i=0;i<queries.size();++i){\\n            int type=queries[i][0];\\n            int x=queries[i][1];\\n            int val=queries[i][2];\\n            if(type==0){\\n                row[x]=make_pair(i+1,val);\\n            }\\n            else{\\n                col[x]=make_pair(i+1,val);\\n            }\\n        }\\n        sort(row.begin(),row.end());\\n        for(int i=1;i<n;++i){\\n            row[i].second+=row[i-1].second;\\n        }\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n;++i){\\n            ans[i]=row[i].first;\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;++i){\\n            int ind=upper_bound(ans.begin(),ans.end(),col[i].first)-ans.begin();\\n            if(ind==0){\\n                sum+=row[n-1].second*1ll;\\n            }\\n            else{\\n                sum+=(ind*col[i].second)*1ll;\\n                sum+=(row[n-1].second-row[ind-1].second)*1ll;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595988,
                "title": "easiest-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        vector<int>row(n, 0);\\n        vector<int>col(n, 0);\\n        \\n        long long ans = 0;\\n        int r = 0, c = 0;\\n        for(int i = q.size()-1; i >= 0; i--)\\n        {\\n            int type = q[i][0];\\n            int ind = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type == 0 && row[ind] == 0 )\\n            {\\n                r++;\\n                row[ind] = 1;\\n                ans += (n - c) * val;\\n            }\\n            \\n            if(type == 1 && col[ind] == 0)\\n            {\\n                c++;\\n                col[ind] = 1;\\n                ans += (n - r) * val;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        vector<int>row(n, 0);\\n        vector<int>col(n, 0);\\n        \\n        long long ans = 0;\\n        int r = 0, c = 0;\\n        for(int i = q.size()-1; i >= 0; i--)\\n        {\\n            int type = q[i][0];\\n            int ind = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type == 0 && row[ind] == 0 )\\n            {\\n                r++;\\n                row[ind] = 1;\\n                ans += (n - c) * val;\\n            }\\n            \\n            if(type == 1 && col[ind] == 0)\\n            {\\n                c++;\\n                col[ind] = 1;\\n                ans += (n - r) * val;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595881,
                "title": "traverse-queries-in-reverse-c",
                "content": "# Complexity\\n- Time complexity :  $$O(Q)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity :  $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        long long ans = 0;\\n        unordered_set<int> visRow;\\n        unordered_set<int> visCol;\\n        for(int i=q-1 ; i>=0 ; i--) {\\n            int type = queries[i][0];\\n            int val = queries[i][2];\\n            if(queries[i][0] == 1) {\\n                int col = queries[i][1];\\n                if(visCol.count(col)) continue;\\n                \\n                ans += 1ll*(n-visRow.size())*val;\\n                visCol.insert(col);\\n            }\\n            \\n            else {\\n                int row = queries[i][1];\\n                if(visRow.count(row)) continue;\\n                \\n                ans += 1ll*(n-visCol.size())*val;\\n                visRow.insert(row);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        long long ans = 0;\\n        unordered_set<int> visRow;\\n        unordered_set<int> visCol;\\n        for(int i=q-1 ; i>=0 ; i--) {\\n            int type = queries[i][0];\\n            int val = queries[i][2];\\n            if(queries[i][0] == 1) {\\n                int col = queries[i][1];\\n                if(visCol.count(col)) continue;\\n                \\n                ans += 1ll*(n-visRow.size())*val;\\n                visCol.insert(col);\\n            }\\n            \\n            else {\\n                int row = queries[i][1];\\n                if(visRow.count(row)) continue;\\n                \\n                ans += 1ll*(n-visCol.size())*val;\\n                visRow.insert(row);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595798,
                "title": "simple-and-easy-to-understand-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int size = queries.size();\\n        int rows = n, cols = n;\\n        vector<bool> rowVis(n,0), colVis(n,0);\\n        long ans = 0;\\n        \\n        //Iterating in reverse order so we don\\'t have to update already visited rows/cols.\\n        for(int i=size-1; i>=0; i--)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(type == 0)\\n            {\\n              if(rowVis[index] == 0) //Checking whether the row is already visited.\\n              {\\n                rowVis[index] = 1;\\n                ans += val*rows;\\n                cols--; //No need to update already visited elements in next iterations.\\n              }\\n            }\\n            else\\n            {\\n                if(colVis[index] == 0)\\n                {\\n                    colVis[index] = 1;\\n                    ans += val*cols;\\n                    rows--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int size = queries.size();\\n        int rows = n, cols = n;\\n        vector<bool> rowVis(n,0), colVis(n,0);\\n        long ans = 0;\\n        \\n        //Iterating in reverse order so we don\\'t have to update already visited rows/cols.\\n        for(int i=size-1; i>=0; i--)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(type == 0)\\n            {\\n              if(rowVis[index] == 0) //Checking whether the row is already visited.\\n              {\\n                rowVis[index] = 1;\\n                ans += val*rows;\\n                cols--; //No need to update already visited elements in next iterations.\\n              }\\n            }\\n            else\\n            {\\n                if(colVis[index] == 0)\\n                {\\n                    colVis[index] = 1;\\n                    ans += val*cols;\\n                    rows--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595698,
                "title": "line-by-line-comments-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, we consider the simulation approach. We iterate form the first query to the last query, and set value for each cell. Then we traverse the matrix, ans get the final sum. But the simulation approach\\'s time complexity is too high. We handle a cell too many times. After thinking for a while, we realized that we only need to handle the last value of one cell, although it\\'s not easy to think of that.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key point to solve this problem is only handle the last value of one cell. So we iterate from the last query to the first query. Whenever we added a row of values or a column of values to the result, we marked that row or column deleted, because all previously setted values are overrided. There is no need to handle these values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(queries.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] q) {\\n        boolean[] row = new boolean[n]; // mark rows that are deleted. true meas deleted\\n        boolean[] col = new boolean[n]; // mark columns that are deleted. true meas deleted\\n        int rowRemain = n; // count the number of rows that are not deleted\\n        int colRemain = n; // count the number of columns that are not deleted\\n        long ans = 0;\\n        for (int i = q.length - 1; i >= 0; --i) {\\n            int type = q[i][0], index = q[i][1], value = q[i][2];\\n            if (type == 0) {\\n                if (!row[index]) { // the row has not been deleted\\n                    // only not deleted columns contribute to the final sum\\n                    ans += value * colRemain;\\n                    row[index] = true; // mark this row is deleted\\n                    --rowRemain; // decrease the number of not deleted rows\\n                }\\n            } else {\\n                if (!col[index]) { // the column has not been deleted\\n                    // only not deleted rows contribute to the final sum\\n                    ans += value * rowRemain;\\n                    col[index] = true; // mark this column is deleted\\n                    --colRemain; // decrease the number of not deleted columns\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] q) {\\n        boolean[] row = new boolean[n]; // mark rows that are deleted. true meas deleted\\n        boolean[] col = new boolean[n]; // mark columns that are deleted. true meas deleted\\n        int rowRemain = n; // count the number of rows that are not deleted\\n        int colRemain = n; // count the number of columns that are not deleted\\n        long ans = 0;\\n        for (int i = q.length - 1; i >= 0; --i) {\\n            int type = q[i][0], index = q[i][1], value = q[i][2];\\n            if (type == 0) {\\n                if (!row[index]) { // the row has not been deleted\\n                    // only not deleted columns contribute to the final sum\\n                    ans += value * colRemain;\\n                    row[index] = true; // mark this row is deleted\\n                    --rowRemain; // decrease the number of not deleted rows\\n                }\\n            } else {\\n                if (!col[index]) { // the column has not been deleted\\n                    // only not deleted rows contribute to the final sum\\n                    ans += value * rowRemain;\\n                    col[index] = true; // mark this column is deleted\\n                    --colRemain; // decrease the number of not deleted columns\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595697,
                "title": "explained-with-short-examples-o-q-c",
                "content": "# Intuition and Appraoch\\nIt doesnt make sense to process the queries from the start.\\nBecause some query from the future can replace this query that can change the answer.\\n\\n***So its better to process queries from the end***\\n\\nAnd we dont need to process pair duplicate queries(For ex: 0 operation on row 5 once happened, cant happen again, as we are traversing backwards)\\nStore the first two part of the queries in set or hashset to check for this condition.\\n\\n***Any row operation reduces the cells in the columns which contribute to the sum and any column operation reduces the cells in rows that contribute to the sum(this was the main operation)***\\n\\nFor ex: Once we replace all values of row 4, as we are processing queries form the end, doesnt matter what queries are, this row will remain unchanged.\\nIt is the same as reducing a cell form every column of the matrix.\\nSame goes for column operation and row cells.\\n\\n[ Read example again and think, if not able to understand, its like layers ]\\n\\nSo maintaing a rowCellCount and colCellCount will be helpful to make the answer.\\n\\nif (type == 0){\\n\\t\\tcolCells--;\\n\\t\\tans += rowCells * val;\\n}\\nelse{\\n\\t\\trowCells--;\\n\\t\\tans += colCells * val;\\n}\\n\\n\\n# Complexity\\n- Time complexity:\\nO(queries.size)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n\\tlong long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n\\t\\tlong long ans = 0;\\n\\t\\tll rowCells = n;\\n\\t\\tll colCells = n;\\n\\t\\tunordered_set<int> st;\\n\\t\\tll type, index, val;\\n\\t\\tint key;\\n\\t\\tfor (int i = queries.size() - 1; i >= 0 ; --i)\\n\\t\\t{\\n\\t\\t\\ttype = queries[i][0];\\n\\t\\t\\tindex = queries[i][1];\\n\\t\\t\\tval = queries[i][2];\\n\\t\\t\\tkey = type==0? 0 : n;\\n\\t\\t\\tkey += index;\\n\\t\\t\\tif (st.find(key) != end(st))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tst.insert(key);\\n\\t\\t\\tif (type == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolCells--;\\n\\t\\t\\t\\tans += rowCells * val;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\trowCells--;\\n\\t\\t\\t\\tans += colCells * val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n\\n```\\n\\nUpvote if you found this helpful!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n\\tlong long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n\\t\\tlong long ans = 0;\\n\\t\\tll rowCells = n;\\n\\t\\tll colCells = n;\\n\\t\\tunordered_set<int> st;\\n\\t\\tll type, index, val;\\n\\t\\tint key;\\n\\t\\tfor (int i = queries.size() - 1; i >= 0 ; --i)\\n\\t\\t{\\n\\t\\t\\ttype = queries[i][0];\\n\\t\\t\\tindex = queries[i][1];\\n\\t\\t\\tval = queries[i][2];\\n\\t\\t\\tkey = type==0? 0 : n;\\n\\t\\t\\tkey += index;\\n\\t\\t\\tif (st.find(key) != end(st))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tst.insert(key);\\n\\t\\t\\tif (type == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolCells--;\\n\\t\\t\\t\\tans += rowCells * val;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\trowCells--;\\n\\t\\t\\t\\tans += colCells * val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595543,
                "title": "reverse-iteration-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we are overwriting the queries its easy to manage them in reverse order.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate the queries in reverse fashion and keep track of the row and column which are used or for which a query is already encountered before and also keep a track of at each step how many rows and cols are modified. We need to do this because (lets say we have already made a column as any value say 4, if we encounter query to perform on a row we know that one of its column is already set we cant modify this so we just add in our ans the values of the remaing columns).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN) -> iterating through the queries for once and insertion in set takes logn\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) -> space due to use of set\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        long long ans = 0;\\n        \\n        int col = 0;\\n        int row = 0;\\n        \\n        set<pair<int, int>> st;\\n        \\n        for(int i = q.size() - 1; i >= 0; i--){\\n            \\n            long long mulRow = row;\\n            long long mulCol = col;\\n\\n            int type = q[i][0];\\n            int ind = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(st.count({type, ind}) == 0){\\n                ans += (n * val) - ((type == 0 ? mulRow : mulCol) * val);\\n                if(type == 1) row++;\\n                else col++;\\n            }\\n            \\n            st.insert({type, ind});\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        long long ans = 0;\\n        \\n        int col = 0;\\n        int row = 0;\\n        \\n        set<pair<int, int>> st;\\n        \\n        for(int i = q.size() - 1; i >= 0; i--){\\n            \\n            long long mulRow = row;\\n            long long mulCol = col;\\n\\n            int type = q[i][0];\\n            int ind = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(st.count({type, ind}) == 0){\\n                ans += (n * val) - ((type == 0 ? mulRow : mulCol) * val);\\n                if(type == 1) row++;\\n                else col++;\\n            }\\n            \\n            st.insert({type, ind});\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595485,
                "title": "counting-and-reverse-iteration-solution-explanation",
                "content": "# Approach\\n`cntR` and `cntC` are the no. of rows and columns resp. which are not set yet.\\nwe are iterating the queries in `reverse`, since the last elements in the query are prefferable since they are the one whose set value is reflected in the matrix , they `overwrite the others`.\\nTherefore we are tracking record of the row and column which are visited or not, if it is visited, we should not evaluate its set value and if it is not visited we evaluate and reduce the `cnt by 1` for the corresponding row or column and mark it visited that it should not be evaluted afterwards. \\n\\n# Complexity\\n- Time complexity: $$O(len(queries))$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0\\n        cntR, cntC = n, n\\n        R = [True] * n\\n        C = [True] * n\\n        for t, i, v in queries[::-1]:\\n            if t == 0 and R[i]:\\n                ans += v * cntC\\n                cntR -= 1\\n                R[i] = False\\n            elif t == 1 and C[i]:\\n                ans += v * cntR\\n                cntC -= 1\\n                C[i] = False\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0\\n        cntR, cntC = n, n\\n        R = [True] * n\\n        C = [True] * n\\n        for t, i, v in queries[::-1]:\\n            if t == 0 and R[i]:\\n                ans += v * cntC\\n                cntR -= 1\\n                R[i] = False\\n            elif t == 1 and C[i]:\\n                ans += v * cntR\\n                cntC -= 1\\n                C[i] = False\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595449,
                "title": "c-solution-greedy-brute-force-optimized",
                "content": "# Intuition\\n* Process the queries in reversed order because if you process from forward, you will have to update matrix each time..\\n* By processing in reverse , you make sure that no further changes can be made on that row or column.\\n\\n# Approach\\n* Here iterate in reverse order & Keep track number of rows and number of cols that can be assigned a value, using row counter and column counter.\\n* Add to answer $$(val * remainingRow)$$ when col operation is performed & add to answer $$(val * remainingCol)$$ when row operation is performed.\\n* Decreament remaining $$row$$ when row operation is performed &\\nreamining $$col$$ when col operation is performed\\n* Note : The trick is to when ever we perform a $$row$$ operation then number of column remaining for next $$col$$ operation 1 less and same is the case for col operation.\\n\\n\\n# Code\\n\\n\\n## Brute Force - TLE\\n* Time Complexity - $$O(N^2)$$\\n* Space Complexity - $$O(N^2)$$\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        if(queries.size() == 0){\\n            return 0;\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        for(auto &q : queries){\\n            int t = q[0];\\n            int i = q[1];\\n            int v = q[2];\\n            \\n            //col\\n            if(t == 1){\\n                for(int k = 0; k < n; k++){\\n                    ans[k][i] = v;\\n                }\\n            }\\n            //row\\n            else{\\n                for(int k = 0; k < n; k++){\\n                    ans[i][k] = v;\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                res += ans[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n## Optimized Approach\\n* Time Complexity - $$O(N)$$\\n* Space Complexity - $$O(N)$$\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int m = queries.size();\\n        unordered_set<int> rowMap;\\n        unordered_set<int> colMap;\\n        \\n        long long ans = 0;\\n        \\n        long long rowCounter = 0;\\n        long long colCounter = 0;\\n        \\n        \\n        for(int i = m - 1; i >= 0; i--){\\n            int t = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(t == 1){\\n                if(colMap.count(idx)){\\n                    continue;\\n                }\\n                else{\\n                    colMap.insert(idx);\\n                    ans += (n - rowCounter) * val;\\n                    colCounter++;\\n                }\\n            }\\n            else if(t == 0){\\n                if(rowMap.count(idx)){\\n                    continue;\\n                }\\n                else{\\n                    rowMap.insert(idx);\\n                    ans += (n - colCounter) * val;\\n                    rowCounter++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        if(queries.size() == 0){\\n            return 0;\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        for(auto &q : queries){\\n            int t = q[0];\\n            int i = q[1];\\n            int v = q[2];\\n            \\n            //col\\n            if(t == 1){\\n                for(int k = 0; k < n; k++){\\n                    ans[k][i] = v;\\n                }\\n            }\\n            //row\\n            else{\\n                for(int k = 0; k < n; k++){\\n                    ans[i][k] = v;\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                res += ans[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int m = queries.size();\\n        unordered_set<int> rowMap;\\n        unordered_set<int> colMap;\\n        \\n        long long ans = 0;\\n        \\n        long long rowCounter = 0;\\n        long long colCounter = 0;\\n        \\n        \\n        for(int i = m - 1; i >= 0; i--){\\n            int t = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(t == 1){\\n                if(colMap.count(idx)){\\n                    continue;\\n                }\\n                else{\\n                    colMap.insert(idx);\\n                    ans += (n - rowCounter) * val;\\n                    colCounter++;\\n                }\\n            }\\n            else if(t == 0){\\n                if(rowMap.count(idx)){\\n                    continue;\\n                }\\n                else{\\n                    rowMap.insert(idx);\\n                    ans += (n - colCounter) * val;\\n                    rowCounter++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595331,
                "title": "c-o-n-reverse-iteration",
                "content": "We reverse the queries given bcoz in reverse manner what we place in the matrix will cannot be changed by any other operations. \\nlet if the operation is on row then we set that row to zero and increment the col bcoz when we perform operation in row then one col is occupied and same for cols.\\nEdge Case: if cols[i] or rows[i] is already zero then we dont have to decrement the srow or scol as there is no new col or row is changed\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>rows(n,n),cols(n,n);\\n        reverse(queries.begin(),queries.end());\\n        long long sum=0,scol=0,srow=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long type=queries[i][0],indx=queries[i][1],val=queries[i][2];\\n            if(type)\\n            {\\n                sum+=max(cols[indx]-scol,0ll)*(long long)val;\\n                if(srow<n&&cols[indx]!=0)\\n\\t\\t\\t\\t\\tsrow++;\\n                cols[indx]=0;\\n            }\\n            else \\n            {\\n                sum+=max(rows[indx]-srow,0ll)*(long long)val;\\n                if(scol<n&&rows[indx]!=0)\\n\\t\\t\\t\\t\\tscol++;  \\n                rows[indx]=0;\\n            }\\n        }\\n        return sum;\\n    }\\n};``\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>rows(n,n),cols(n,n);\\n        reverse(queries.begin(),queries.end());\\n        long long sum=0,scol=0,srow=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long type=queries[i][0],indx=queries[i][1],val=queries[i][2];\\n            if(type)\\n            {\\n                sum+=max(cols[indx]-scol,0ll)*(long long)val;\\n                if(srow<n&&cols[indx]!=0)\\n\\t\\t\\t\\t\\tsrow++;\\n                cols[indx]=0;\\n            }\\n            else \\n            {\\n                sum+=max(rows[indx]-srow,0ll)*(long long)val;\\n                if(scol<n&&rows[indx]!=0)\\n\\t\\t\\t\\t\\tscol++;  \\n                rows[indx]=0;\\n            }\\n        }\\n        return sum;\\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595325,
                "title": "javascript-time-o-q-space-o-n-3-solutions-8-lines-of-code-in-the-shortest-one",
                "content": "# Approach\\n1. Iterate from the end and Keep track number of rows and number of cols that can be assigned a value.\\n2. Add to answer val * row rest when col operation is performed and add to answer val * col rest when row operation is performed.\\n3. Decrement row rest when row operation is performed and col rest when col operation is performed.\\n\\n# With Arrays\\n```javascript\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [\\n    new Uint8Array(n),\\n    new Uint8Array(n),\\n  ];\\n  const rest = [n, n];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (seen[type][index] === 0) {\\n      seen[type][index] = 1;\\n      ans += rest[1-type] * val;\\n      rest[type]--;\\n    }\\n  }\\n  \\n  return ans;\\n};\\n```\\n# Or shorter with Sets\\n```\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [new Set(), new Set()];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (!seen[type].has(index)) {\\n      seen[type].add(index);\\n      ans += (n-seen[1-type].size) * val;\\n    }\\n  }\\n  \\n  return ans;\\n};\\n\\n```\\n# Or the shortest with Sets and ReduceRight\\n```\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [new Set(), new Set()];\\n  return queries.reduceRight((sum, [type, index, val]) => \\n    !seen[type].has(index)\\n      ? (seen[type].add(index), sum + (n-seen[1-type].size) * val)\\n      : sum\\n  , 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [\\n    new Uint8Array(n),\\n    new Uint8Array(n),\\n  ];\\n  const rest = [n, n];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (seen[type][index] === 0) {\\n      seen[type][index] = 1;\\n      ans += rest[1-type] * val;\\n      rest[type]--;\\n    }\\n  }\\n  \\n  return ans;\\n};\\n```\n```\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [new Set(), new Set()];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (!seen[type].has(index)) {\\n      seen[type].add(index);\\n      ans += (n-seen[1-type].size) * val;\\n    }\\n  }\\n  \\n  return ans;\\n};\\n\\n```\n```\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [new Set(), new Set()];\\n  return queries.reduceRight((sum, [type, index, val]) => \\n    !seen[type].has(index)\\n      ? (seen[type].add(index), sum + (n-seen[1-type].size) * val)\\n      : sum\\n  , 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595324,
                "title": "c-greedy-easy-and-short-solution",
                "content": "# Intuition\\nBy reading problem statement it look simple greedy with optimized brute force problem.\\n\\n# Approach\\n- Start iterating from the end, while keeping track of the count of assignable rows and columns.\\n- When performing a column operation, multiply the value by the remaining number of rows and add it to the answer. When performing a row operation, multiply the value by the remaining number of columns and add it to the answer.\\n- Decrease the count of remaining rows when a row operation is performed, and decrease the count of remaining columns when a column operation is performed.\\n\\n# Complexity\\n- Time complexity: \\n  `O(q)` where q is number of queries.\\n\\n- Space complexity:\\n  `O(n)` where n is number of rows/colums. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& ques) {\\n        vector<int> row(n,0), col(n,0); \\n        int rfill = 0, cfill = 0,ind;\\n        long long val,sum = 0;\\n\\n        for(int i = ques.size()-1; i>=0;--i){\\n            ind = ques[i][1];\\n            val = ques[i][2];\\n            if(ques[i][0] == 0){\\n                if(!row[ind]){\\n                    sum += val * (n-cfill);\\n                    ++rfill;\\n                    row[ind] = val;\\n                }\\n            }else{\\n                if(!col[ind]){\\n                    sum += val * (n-rfill);\\n                    ++cfill;\\n                    col[ind] = val;\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& ques) {\\n        vector<int> row(n,0), col(n,0); \\n        int rfill = 0, cfill = 0,ind;\\n        long long val,sum = 0;\\n\\n        for(int i = ques.size()-1; i>=0;--i){\\n            ind = ques[i][1];\\n            val = ques[i][2];\\n            if(ques[i][0] == 0){\\n                if(!row[ind]){\\n                    sum += val * (n-cfill);\\n                    ++rfill;\\n                    row[ind] = val;\\n                }\\n            }else{\\n                if(!col[ind]){\\n                    sum += val * (n-rfill);\\n                    ++cfill;\\n                    col[ind] = val;\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595239,
                "title": "c-simple-solution",
                "content": "# Intuition\\nWhen we make a column change then all row would get affected similarly if we make a row change then all columns would be affected.\\nNow keeping this in mind we now just have to think how many row or columns are affected and that can be done by storing number of column change and row change in a variable (Here r and c).\\nThen we can easily subtract that amount from our answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int d[n][2];\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            d[i][0]=1;\\n            d[i][1]=1;\\n        }\\n        int r=0,c=0;\\n        int q=queries.size();\\n        for(int i=q-1;i>=0;i--){\\n            if(d[queries[i][1]][queries[i][0]]){\\n            if(queries[i][0]) c++;\\n            else r++;\\n            ans+=(n-(queries[i][0]==0? c:r))*queries[i][2];\\n            d[queries[i][1]][queries[i][0]]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int d[n][2];\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            d[i][0]=1;\\n            d[i][1]=1;\\n        }\\n        int r=0,c=0;\\n        int q=queries.size();\\n        for(int i=q-1;i>=0;i--){\\n            if(d[queries[i][1]][queries[i][0]]){\\n            if(queries[i][0]) c++;\\n            else r++;\\n            ans+=(n-(queries[i][0]==0? c:r))*queries[i][2];\\n            d[queries[i][1]][queries[i][0]]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595237,
                "title": "o-n-solution-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust think this question as if you are trying to color a square paper with different color paint.\\nIn each stroke you color some part of the paper.\\nAfter you are done with painting the only the last paint would be visible.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the above intution we can say that the row or colum which was last changed will be persisted while other will be lost.\\nSo, for each query we need to find how many cells will be remain unchanged after the finaly query.\\nTo achive this we need to maintain two boolean array represting which row or col has been used. Apart from that we need to keep track of how many row or col has been used.\\n\\ntc -> no. of cols used\\ntr-> no. of rows used\\nFor each query : q\\n    Type 1 : val(i) * (n-tc)\\n    Type 2  : val(i) * (n-tr)\\n\\n# Complexity\\n- Time complexity: O( queries.size() )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  \\n\\n- Space complexity: O(n) -> to store the bool array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(),queries.end());\\n        \\n        vector<bool> rcheck(n,false),ccheck(n,false);\\n        long long ans = 0, tr = 0, tc = 0;\\n        for( auto &q : queries ){\\n            int tq = q[0];\\n            if( tq==0 ){\\n                int rn = q[1];\\n                int val = q[2];\\n                \\n                if( rcheck[rn] )\\n                    continue;\\n                \\n                rcheck[rn] = true;\\n                tr++;\\n                ans += val * (n-tc);\\n            }\\n            else {\\n                int cn = q[1];\\n                int val = q[2];\\n                \\n                if( ccheck[cn] )\\n                    continue;\\n                \\n                ccheck[cn] = true;\\n                tc++;\\n                ans += val * (n-tr);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(),queries.end());\\n        \\n        vector<bool> rcheck(n,false),ccheck(n,false);\\n        long long ans = 0, tr = 0, tc = 0;\\n        for( auto &q : queries ){\\n            int tq = q[0];\\n            if( tq==0 ){\\n                int rn = q[1];\\n                int val = q[2];\\n                \\n                if( rcheck[rn] )\\n                    continue;\\n                \\n                rcheck[rn] = true;\\n                tr++;\\n                ans += val * (n-tc);\\n            }\\n            else {\\n                int cn = q[1];\\n                int val = q[2];\\n                \\n                if( ccheck[cn] )\\n                    continue;\\n                \\n                ccheck[cn] = true;\\n                tc++;\\n                ans += val * (n-tr);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595165,
                "title": "easy-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse from backward and add in the ans accordingly..\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        // cd - column done , rd - row done\\n        vector<int> cd (n , 0) , rd(n , 0);\\n        long long ans = 0;\\n        int cnc = 0, cnr = 0;  // cnc-to store the col done count , cnr-to store the row done count \\n        \\n        \\n        for(int i=queries.size()-1 ; i>=0 ; i--){\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(type == 0){\\n                if(rd[idx] == 0){\\n                    ans += (n-cnc)*val;\\n                    rd[idx] = 1;\\n                    cnr++;\\n               }\\n            }\\n            else if(type == 1){\\n               if(cd[idx] == 0){\\n                    ans += (n-cnr)*val;\\n                    cd[idx] = 1;\\n                    cnc++;\\n               }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        // cd - column done , rd - row done\\n        vector<int> cd (n , 0) , rd(n , 0);\\n        long long ans = 0;\\n        int cnc = 0, cnr = 0;  // cnc-to store the col done count , cnr-to store the row done count \\n        \\n        \\n        for(int i=queries.size()-1 ; i>=0 ; i--){\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(type == 0){\\n                if(rd[idx] == 0){\\n                    ans += (n-cnc)*val;\\n                    rd[idx] = 1;\\n                    cnr++;\\n               }\\n            }\\n            else if(type == 1){\\n               if(cd[idx] == 0){\\n                    ans += (n-cnr)*val;\\n                    cd[idx] = 1;\\n                    cnc++;\\n               }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595156,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code works based on the intuition that for each query, it checks if a row or column index has been visited before. If it hasn\\'t, it adds the product of the remaining row or column count and the value to the sum. This ensures that the sum considers only the elements that have not been previously accounted for in the visited rows or columns.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses two sets, r and c, to store the row and column indices encountered in the queries.\\n\\nThe queries are reversed to iterate over them in reverse order.\\n\\nA variable ans is initialized to store the sum of matrix elements.\\n\\nThe code iterates over each query, performs row or column operations, and updates the sum accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(q), where q is the number of queries. Since the code iterates over the queries in reverse order, it performs constant time operations for each query. Therefore, the time complexity is linear with respect to the number of queries.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the size of the matrix. This is because the code uses two sets, r and c, to store visited row and column indices. The size of these sets can grow at most up to the number of rows or columns in the matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n    set<int> r, c; // Create two sets to store the row and column indices\\n    reverse(queries.begin(), queries.end()); // Reverse the order of queries\\n    long long ans = 0; // Initialize a variable to store the sum of matrix elements\\n    for(auto it : queries) {\\n        if(it[0] == 0) { // Query type 0: row operation\\n            if(r.find(it[1]) == r.end()) { // If the row index is not present in the set\\n                ans += (n - c.size()) * it[2]; // Add the product of (remaining column count) and the value to the answer\\n                r.insert(it[1]); // Insert the row index into the set\\n            }\\n        }\\n        else { // Query type 1: column operation\\n            if(c.find(it[1]) == c.end()) { // If the column index is not present in the set\\n                ans += (n - r.size()) * it[2]; // Add the product of (remaining row count) and the value to the answer\\n                c.insert(it[1]); // Insert the column index into the set\\n            }\\n        }\\n    }\\n    return ans; // Return the final sum of matrix elements\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n    set<int> r, c; // Create two sets to store the row and column indices\\n    reverse(queries.begin(), queries.end()); // Reverse the order of queries\\n    long long ans = 0; // Initialize a variable to store the sum of matrix elements\\n    for(auto it : queries) {\\n        if(it[0] == 0) { // Query type 0: row operation\\n            if(r.find(it[1]) == r.end()) { // If the row index is not present in the set\\n                ans += (n - c.size()) * it[2]; // Add the product of (remaining column count) and the value to the answer\\n                r.insert(it[1]); // Insert the row index into the set\\n            }\\n        }\\n        else { // Query type 1: column operation\\n            if(c.find(it[1]) == c.end()) { // If the column index is not present in the set\\n                ans += (n - r.size()) * it[2]; // Add the product of (remaining row count) and the value to the answer\\n                c.insert(it[1]); // Insert the column index into the set\\n            }\\n        }\\n    }\\n    return ans; // Return the final sum of matrix elements\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595061,
                "title": "easy-java-fast-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] query) {\\n      int[][] res = new int[n][2];\\n        long answer = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            res[i][0] = 1;\\n            res[i][1] = 1;\\n        }\\n        int cr = 0, cc = 0;\\n\\n        for (int i = query.length - 1; i >= 0; i--) {\\n            if (res[query[i][1]][query[i][0]] != 0) {\\n                if (query[i][0] == 0) {\\n                    cr++;\\n                } else {\\n                    cc++;\\n                }\\n                answer += (n - (query[i][0] == 0 ? cc : cr)) * query[i][2];\\n                res[query[i][1]][query[i][0]] = 0;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] query) {\\n      int[][] res = new int[n][2];\\n        long answer = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            res[i][0] = 1;\\n            res[i][1] = 1;\\n        }\\n        int cr = 0, cc = 0;\\n\\n        for (int i = query.length - 1; i >= 0; i--) {\\n            if (res[query[i][1]][query[i][0]] != 0) {\\n                if (query[i][0] == 0) {\\n                    cr++;\\n                } else {\\n                    cc++;\\n                }\\n                answer += (n - (query[i][0] == 0 ? cc : cr)) * query[i][2];\\n                res[query[i][1]][query[i][0]] = 0;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595052,
                "title": "sum-of-matrix-after-queries-solution-time-complexity-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> rowUsed(n,0);\\n        vector<int> colUsed(n,0);\\n        int countRowsUsed=0,countColsUsed=0;\\n        int sz=queries.size();\\n        long long res=0;\\n        for(int q=sz-1;q>=0;q--){\\n            int type=queries[q][0];\\n            if(type==0){\\n                int rowIdx=queries[q][1];\\n                if(rowUsed[rowIdx]==0){\\n                    rowUsed[rowIdx]=1;\\n                    countRowsUsed++;\\n                    res+=((n-countColsUsed)*queries[q][2]);\\n                }\\n            }\\n            else{\\n                int colIdx=queries[q][1];\\n                if(colUsed[colIdx]==0){\\n                    colUsed[colIdx]=1;\\n                    countColsUsed++;\\n                    res+=((n-countRowsUsed)*queries[q][2]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> rowUsed(n,0);\\n        vector<int> colUsed(n,0);\\n        int countRowsUsed=0,countColsUsed=0;\\n        int sz=queries.size();\\n        long long res=0;\\n        for(int q=sz-1;q>=0;q--){\\n            int type=queries[q][0];\\n            if(type==0){\\n                int rowIdx=queries[q][1];\\n                if(rowUsed[rowIdx]==0){\\n                    rowUsed[rowIdx]=1;\\n                    countRowsUsed++;\\n                    res+=((n-countColsUsed)*queries[q][2]);\\n                }\\n            }\\n            else{\\n                int colIdx=queries[q][1];\\n                if(colUsed[colIdx]==0){\\n                    colUsed[colIdx]=1;\\n                    countColsUsed++;\\n                    res+=((n-countRowsUsed)*queries[q][2]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594955,
                "title": "c-o-queries-size-reverse-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        // int count = 0;\\n        long long sol = 0;\\n        int row = n;\\n        int col = n;\\n        vector<vector<int>>vis(n+1,vector<int>(3,0));\\n       for(int i=queries.size()-1;i>=0;i--)\\n       {\\n           int a = queries[i][0];\\n           int b = queries[i][1];\\n           int c = queries[i][2];\\n           if(vis[b][a])continue;\\n           vis[b][a] = 1;\\n           if(a==1)\\n           {\\n               // cout<<c<<\" \"<<row<<endl;;\\n               sol+=(long long)c*row;\\n               col--;\\n           }\\n           else\\n           {\\n               // cout<<c<<\" \"<<col<<endl;\\n               sol+=(long long)c*col;\\n               row--;\\n               \\n           }\\n       }\\n        return sol;\\n        // vector<vector<int>>ans(n+1,vector<int>(n+1,0));\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         auto x = row[i];\\n        //         auto y = col[j];\\n        //         if(x.first > y.first)\\n        //         {\\n        //             ans[i][j]  = x.second;\\n        //         }\\n        //         else\\n        //         {\\n        //             ans[i][j] = y.second;\\n        //         }\\n        //     }\\n        // }\\n        // long long sol = 0;\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         sol+=(long long)ans[i][j];\\n        //     }\\n        // }\\n        // return sol;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        // int count = 0;\\n        long long sol = 0;\\n        int row = n;\\n        int col = n;\\n        vector<vector<int>>vis(n+1,vector<int>(3,0));\\n       for(int i=queries.size()-1;i>=0;i--)\\n       {\\n           int a = queries[i][0];\\n           int b = queries[i][1];\\n           int c = queries[i][2];\\n           if(vis[b][a])continue;\\n           vis[b][a] = 1;\\n           if(a==1)\\n           {\\n               // cout<<c<<\" \"<<row<<endl;;\\n               sol+=(long long)c*row;\\n               col--;\\n           }\\n           else\\n           {\\n               // cout<<c<<\" \"<<col<<endl;\\n               sol+=(long long)c*col;\\n               row--;\\n               \\n           }\\n       }\\n        return sol;\\n        // vector<vector<int>>ans(n+1,vector<int>(n+1,0));\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         auto x = row[i];\\n        //         auto y = col[j];\\n        //         if(x.first > y.first)\\n        //         {\\n        //             ans[i][j]  = x.second;\\n        //         }\\n        //         else\\n        //         {\\n        //             ans[i][j] = y.second;\\n        //         }\\n        //     }\\n        // }\\n        // long long sol = 0;\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         sol+=(long long)ans[i][j];\\n        //     }\\n        // }\\n        // return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3594920,
                "title": "c-o-n-solution-without-using-matrix",
                "content": "High level intuition:\\n1. If you traverse the queries in reverse order, once a spot is occupied, it cannot be overtaken by an earlier query.\\n2. Do not use matrices since O(n * n) in this case will exceed the time limit (10^8).\\n3. For each element in the matrix, there is only one row and one column that can mutate it.\\n4. When you fill up a row, all columns will have lost the opportunity to fill up one element. Vice versa for filling up columns.\\n5. Therefore, You can keep a total count of number of elements that can still be filled for all columns (and for all rows).\\n6. Use a visited array for rows and columns to ensure no earlier query can override the values in that row/column.\\n\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> row(n, 1), col(n, 1);\\n        int rowc = n, colc = n;\\n        reverse(queries.begin(), queries.end());\\n        for (auto query : queries) {\\n            auto type = query[0], index = query[1], val = query[2];\\n            if (type == 0 && row[index]) {\\n                ans += rowc * val;\\n                colc -= 1;\\n                row[index] = 0;\\n            } else if (type == 1 && col[index]) {\\n                ans += colc * val;\\n                rowc -= 1;\\n                col[index] = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> row(n, 1), col(n, 1);\\n        int rowc = n, colc = n;\\n        reverse(queries.begin(), queries.end());\\n        for (auto query : queries) {\\n            auto type = query[0], index = query[1], val = query[2];\\n            if (type == 0 && row[index]) {\\n                ans += rowc * val;\\n                colc -= 1;\\n                row[index] = 0;\\n            } else if (type == 1 && col[index]) {\\n                ans += colc * val;\\n                rowc -= 1;\\n                col[index] = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594903,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long countRowsChanged = n;\\n        boolean[] rowsChanged = new boolean[n];\\n        long countColsChanged = n;\\n        boolean[] colsChanged = new boolean[n];\\n        long result = 0;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int[] query = queries[i];\\n            int type = query[0];\\n            int index = query[1];\\n            long value =  (long) query[2];\\n            if (type == 0) {\\n                if (rowsChanged[index]) {\\n                    continue;\\n                }\\n                result = result + (long) (countColsChanged * value);\\n                countRowsChanged--;\\n                rowsChanged[index] = true;\\n            } else {\\n                if (colsChanged[index]) {\\n                    continue;\\n                }\\n                result = result + (long) (countRowsChanged * value);\\n                countColsChanged--;\\n                colsChanged[index] = true;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long countRowsChanged = n;\\n        boolean[] rowsChanged = new boolean[n];\\n        long countColsChanged = n;\\n        boolean[] colsChanged = new boolean[n];\\n        long result = 0;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int[] query = queries[i];\\n            int type = query[0];\\n            int index = query[1];\\n            long value =  (long) query[2];\\n            if (type == 0) {\\n                if (rowsChanged[index]) {\\n                    continue;\\n                }\\n                result = result + (long) (countColsChanged * value);\\n                countRowsChanged--;\\n                rowsChanged[index] = true;\\n            } else {\\n                if (colsChanged[index]) {\\n                    continue;\\n                }\\n                result = result + (long) (countRowsChanged * value);\\n                countColsChanged--;\\n                colsChanged[index] = true;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958523,
                "title": "golang-solution",
                "content": "# Code\\n```go\\nfunc matrixSumQueries(n int, queries [][]int) int64 {\\n\\trowFlush, colFlush := make([][2]int, n), make([][2]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\trowFlush[i] = [2]int{-1, 0}\\n\\t\\tcolFlush[i] = [2]int{-1, 0}\\n\\t}\\n\\tfor i, q := range queries {\\n\\t\\tswitch q[0] {\\n\\t\\tcase 0:\\n\\t\\t\\trowFlush[q[1]] = [2]int{i, q[2]}\\n\\t\\tcase 1:\\n\\t\\t\\tcolFlush[q[1]] = [2]int{i, q[2]}\\n\\t\\t}\\n\\t}\\n\\tsummation := 0\\n\\tfor r := 0; r < n; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tif rowFlush[r][0] > colFlush[c][0] {\\n\\t\\t\\t\\tsummation += rowFlush[r][1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsummation += colFlush[c][1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int64(summation)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc matrixSumQueries(n int, queries [][]int) int64 {\\n\\trowFlush, colFlush := make([][2]int, n), make([][2]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\trowFlush[i] = [2]int{-1, 0}\\n\\t\\tcolFlush[i] = [2]int{-1, 0}\\n\\t}\\n\\tfor i, q := range queries {\\n\\t\\tswitch q[0] {\\n\\t\\tcase 0:\\n\\t\\t\\trowFlush[q[1]] = [2]int{i, q[2]}\\n\\t\\tcase 1:\\n\\t\\t\\tcolFlush[q[1]] = [2]int{i, q[2]}\\n\\t\\t}\\n\\t}\\n\\tsummation := 0\\n\\tfor r := 0; r < n; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tif rowFlush[r][0] > colFlush[c][0] {\\n\\t\\t\\t\\tsummation += rowFlush[r][1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsummation += colFlush[c][1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int64(summation)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913446,
                "title": "keep-track-of-seen-rows-and-cols-beats-96-explanation",
                "content": "\"\"\"\\n        Process queries in reversed order, as the latest queries represent the \\n        most recent changes in the matrix.\\n\\n        Once you encounter an operation on some row/column, \\n        no further operations will affect the values in this row/column. \\n        Keep track of seen rows and columns with a set.\\n\\n        When operating on an unseen row/column, \\n        the number of affected cells is the number of columns/rows you haven\\u2019t previously seen.\\n        \"\"\"\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen_cols = set()\\n        seen_rows = set() \\n        result = 0\\n        for query in queries[::-1]:\\n            typ, index, val = query[:]\\n            if typ and index not in seen_rows:\\n                result+=(val*n) - (len(seen_cols) * val)\\n                seen_rows.add(index)\\n            elif not typ and index not in seen_cols:   \\n                result+=(val*n) - (len(seen_rows)*val)\\n                seen_cols.add(index)\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen_cols = set()\\n        seen_rows = set() \\n        result = 0\\n        for query in queries[::-1]:\\n            typ, index, val = query[:]\\n            if typ and index not in seen_rows:\\n                result+=(val*n) - (len(seen_cols) * val)\\n                seen_rows.add(index)\\n            elif not typ and index not in seen_cols:   \\n                result+=(val*n) - (len(seen_rows)*val)\\n                seen_cols.add(index)\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913371,
                "title": "java-solution-by-hashset",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        HashSet<Integer>row=new HashSet<>();\\n        HashSet<Integer>col=new HashSet<>();\\n        long ans=0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            boolean col1=false;\\n           \\n              if(queries[i][0]==1)col1=true;\\n              if(col1){\\n                  if(!col.contains(queries[i][1])){\\n                      ans+=((n-row.size())*queries[i][2]);\\n                  }\\n                  col.add(queries[i][1]);\\n              }\\n              else{\\n                  if(!row.contains(queries[i][1])){\\n                      ans+=((n-col.size())*queries[i][2]);\\n                  }\\n                  row.add(queries[i][1]);\\n              }\\n              \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        HashSet<Integer>row=new HashSet<>();\\n        HashSet<Integer>col=new HashSet<>();\\n        long ans=0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            boolean col1=false;\\n           \\n              if(queries[i][0]==1)col1=true;\\n              if(col1){\\n                  if(!col.contains(queries[i][1])){\\n                      ans+=((n-row.size())*queries[i][2]);\\n                  }\\n                  col.add(queries[i][1]);\\n              }\\n              else{\\n                  if(!row.contains(queries[i][1])){\\n                      ans+=((n-col.size())*queries[i][2]);\\n                  }\\n                  row.add(queries[i][1]);\\n              }\\n              \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884904,
                "title": "hashmap-and-hashset-implemented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n         int row = n;\\n        int col = n; \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        Set<Integer> unqRow = new HashSet<>();\\n        Set<Integer> unqCol = new HashSet<>();\\n        int len = queries.length - 1; \\n\\n        while (len >= 0) {\\n            int[] arr = queries[len];\\n\\n            if (arr[0] == 1&& !unqCol.contains(arr[1])) { \\n                m.put(arr[2], m.getOrDefault(arr[2], 0) + row);\\n                unqCol.add(arr[1]);\\n                col--;\\n            } \\n            \\n            if(arr[0] == 0&& !unqRow.contains(arr[1])){\\n                m.put(arr[2], m.getOrDefault(arr[2], 0) + col);\\n                unqRow.add(arr[1]);\\n                row--;\\n            }\\n\\n\\n            len--;\\n        }\\n        long total = 0;\\n\\n        for (int key : m.keySet()) { \\n            total +=(long) key * m.get(key);\\n\\n        }\\n      \\n        return total;\\n\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n         int row = n;\\n        int col = n; \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        Set<Integer> unqRow = new HashSet<>();\\n        Set<Integer> unqCol = new HashSet<>();\\n        int len = queries.length - 1; \\n\\n        while (len >= 0) {\\n            int[] arr = queries[len];\\n\\n            if (arr[0] == 1&& !unqCol.contains(arr[1])) { \\n                m.put(arr[2], m.getOrDefault(arr[2], 0) + row);\\n                unqCol.add(arr[1]);\\n                col--;\\n            } \\n            \\n            if(arr[0] == 0&& !unqRow.contains(arr[1])){\\n                m.put(arr[2], m.getOrDefault(arr[2], 0) + col);\\n                unqRow.add(arr[1]);\\n                row--;\\n            }\\n\\n\\n            len--;\\n        }\\n        long total = 0;\\n\\n        for (int key : m.keySet()) { \\n            total +=(long) key * m.get(key);\\n\\n        }\\n      \\n        return total;\\n\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845332,
                "title": "c-easy-to-understand-clean",
                "content": "# Intuition\\ngoing backwards, until all rows or cols are used up.\\n\\n# Approach\\nkeep track of how many rows and cols have been used up so far.\\nIf one particular row/col is already used, skip.\\n\\n# Complexity\\n- Time complexity:\\nO(N) ( queries length or n)\\n\\n- Space complexity:\\nO(n) two sets to save which row/col have been used. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        unordered_set<int> row, col;\\n        for(int k = queries.size()-1; k>=0 && row.size()<n && col.size()<n; k--) {\\n            vector<int> q = queries[k];\\n            if (q[0] == 0) {\\n                // row insert\\n                auto [_, added] = row.insert(q[1]);\\n                if (added) ans += q[2]*(n-col.size());\\n            } else {\\n                // col insert\\n                auto [_, added] = col.insert(q[1]);\\n                if (added) ans += q[2]*(n-row.size());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        unordered_set<int> row, col;\\n        for(int k = queries.size()-1; k>=0 && row.size()<n && col.size()<n; k--) {\\n            vector<int> q = queries[k];\\n            if (q[0] == 0) {\\n                // row insert\\n                auto [_, added] = row.insert(q[1]);\\n                if (added) ans += q[2]*(n-col.size());\\n            } else {\\n                // col insert\\n                auto [_, added] = col.insert(q[1]);\\n                if (added) ans += q[2]*(n-row.size());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837463,
                "title": "c-reverse-traversal-easy-and-understandable-clean-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nReverse Traversal\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force ( TLE TLE TLE )  also can not declare array \\n\\nReverse Traversal\\n\\n\\n# Complexity\\n- Time complexity: O(q) // q is size of queries\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n.\\n.\\n.\\n.\\n.\\n\\nPlease correct me if I am wrong anywhere or have anyMemoization general suggestions.\\nPlease correct me if I am wrong anywhere or have anyMemoization general suggestions.\\n\\n.\\n.\\n.\\n.\\n.\\n\\n# Code\\n\\nMethod -1 \\n\\n\\n```\\n\\n\\n\\n// //                           \\n// //                           \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// //                             \\n// // //   Time Complexity   = O(n^2)   \\n// //                              \\n// // //   Space Complexity  = O(n^2)   \\n// //                               \\n\\n\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> mat (n, vector<int>(n,0)) ;\\n        long long ans  = 0 ;\\n        int m = queries.size() ;\\n        for(int i=0; i<m; i++)\\n        {\\n            int type = queries[i][0] ;\\n            int ind = queries[i][1] ;\\n            int val = queries[i][2] ;\\n            // ans += n * val ;\\n            if(type==0) for(int j=0; j<n; j++) mat[ind][j] = val;\\n            else if(type==1) for(int k=0; k<n; k++) mat[k][ind] = val;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++) ans += mat[i][j] ;\\n        }\\n        return  ans ;\\n    }\\n};\\n\\n\\n\\n\\n```\\n\\n\\n\\n\\n\\nMethod -2\\n\\n\\n```\\n\\n\\n\\n\\n// //                           \\n// //                           \\n// // //  2nd Method    ======>  Reverse Traversal   \\n// // //  2nd Method    ======>  Reverse Traversal   \\n// // //  2nd Method    ======>  Reverse Traversal  \\n// //                             \\n// // //   Time Complexity   = O(q)    // q is size of queries\\n// //                              \\n// // //   Space Complexity  = O(2*n)  \\n// //                               \\n\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        int q = queries.size() ;\\n        long long ans = 0 ; \\n        vector<int> row(n+5 , 0) ;   \\n        vector<int> col(n+5 , 0) ;  \\n        int row_ct = 0 , col_ct = 0 ; \\n        for(int i=q-1; i>=0; i--)\\n        {\\n            cout<<i<<endl;\\n            int type = queries[i][0] ;\\n            int ind = queries[i][1] ;\\n            int val = queries[i][2] ;\\n            if(type==0 && row[ind]==0 )\\n            {\\n                row[ind] = 1 ;\\n                ans +=  val * 1LL * (n -col_ct) ;\\n                row_ct++ ;\\n            }\\n            else if( type==1 && col[ind]==0)\\n            {\\n                col[ind] = 1 ;\\n                ans +=  val * 1LL * (n -row_ct) ;\\n                col_ct++ ;\\n            }\\n        }\\n        return ans  ; \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\n\\n// //                           \\n// //                           \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// //                             \\n// // //   Time Complexity   = O(n^2)   \\n// //                              \\n// // //   Space Complexity  = O(n^2)   \\n// //                               \\n\\n\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> mat (n, vector<int>(n,0)) ;\\n        long long ans  = 0 ;\\n        int m = queries.size() ;\\n        for(int i=0; i<m; i++)\\n        {\\n            int type = queries[i][0] ;\\n            int ind = queries[i][1] ;\\n            int val = queries[i][2] ;\\n            // ans += n * val ;\\n            if(type==0) for(int j=0; j<n; j++) mat[ind][j] = val;\\n            else if(type==1) for(int k=0; k<n; k++) mat[k][ind] = val;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++) ans += mat[i][j] ;\\n        }\\n        return  ans ;\\n    }\\n};\\n\\n\\n\\n\\n```\n```\\n\\n\\n\\n\\n// //                           \\n// //                           \\n// // //  2nd Method    ======>  Reverse Traversal   \\n// // //  2nd Method    ======>  Reverse Traversal   \\n// // //  2nd Method    ======>  Reverse Traversal  \\n// //                             \\n// // //   Time Complexity   = O(q)    // q is size of queries\\n// //                              \\n// // //   Space Complexity  = O(2*n)  \\n// //                               \\n\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        int q = queries.size() ;\\n        long long ans = 0 ; \\n        vector<int> row(n+5 , 0) ;   \\n        vector<int> col(n+5 , 0) ;  \\n        int row_ct = 0 , col_ct = 0 ; \\n        for(int i=q-1; i>=0; i--)\\n        {\\n            cout<<i<<endl;\\n            int type = queries[i][0] ;\\n            int ind = queries[i][1] ;\\n            int val = queries[i][2] ;\\n            if(type==0 && row[ind]==0 )\\n            {\\n                row[ind] = 1 ;\\n                ans +=  val * 1LL * (n -col_ct) ;\\n                row_ct++ ;\\n            }\\n            else if( type==1 && col[ind]==0)\\n            {\\n                col[ind] = 1 ;\\n                ans +=  val * 1LL * (n -row_ct) ;\\n                col_ct++ ;\\n            }\\n        }\\n        return ans  ; \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3827106,
                "title": "java-solution-using-reverse-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\u2B55(m), where m = queries.length;\\n\\n- Space complexity:\\n\\u2B55(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowVisited = n;\\n        int colVisited = n;\\n        boolean[] isVisitedRow = new boolean[n];\\n        boolean[] isVisitedCol = new boolean[n];\\n        long sum = 0;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int indx = queries[i][1];\\n            int val = queries[i][2];\\n            if (type == 0 && ! isVisitedRow[indx]) {\\n                sum += colVisited * val;\\n                isVisitedRow[indx] = true;\\n                rowVisited--;\\n            } \\n             if (type == 1 && ! isVisitedCol[indx]) {\\n                sum += rowVisited * val;\\n                isVisitedCol[indx] = true;\\n                colVisited--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowVisited = n;\\n        int colVisited = n;\\n        boolean[] isVisitedRow = new boolean[n];\\n        boolean[] isVisitedCol = new boolean[n];\\n        long sum = 0;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int indx = queries[i][1];\\n            int val = queries[i][2];\\n            if (type == 0 && ! isVisitedRow[indx]) {\\n                sum += colVisited * val;\\n                isVisitedRow[indx] = true;\\n                rowVisited--;\\n            } \\n             if (type == 1 && ! isVisitedCol[indx]) {\\n                sum += rowVisited * val;\\n                isVisitedCol[indx] = true;\\n                colVisited--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824141,
                "title": "traverse-in-reverse-order",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> row(n,0);\\n        vector<int> col(n,0);\\n        long long rowSum = 0;\\n        long long colSum = 0;\\n        long long sum = 0;\\n        for(int i=queries.size()-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            if(type==0){\\n                if(row[index]==0){\\n                    sum += val*(n-colSum);\\n                    row[index]=1;\\n                    rowSum++;\\n                }\\n\\n            }\\n            else{\\n                if(col[index]==0){\\n                    sum += val*(n-rowSum);\\n                    col[index]=1;\\n                    colSum++;\\n                }\\n            }\\n            cout<<sum<<endl;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> row(n,0);\\n        vector<int> col(n,0);\\n        long long rowSum = 0;\\n        long long colSum = 0;\\n        long long sum = 0;\\n        for(int i=queries.size()-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            if(type==0){\\n                if(row[index]==0){\\n                    sum += val*(n-colSum);\\n                    row[index]=1;\\n                    rowSum++;\\n                }\\n\\n            }\\n            else{\\n                if(col[index]==0){\\n                    sum += val*(n-rowSum);\\n                    col[index]=1;\\n                    colSum++;\\n                }\\n            }\\n            cout<<sum<<endl;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3795768,
                "title": "easy-self-explanatory-code",
                "content": "# Intuition\\nThe brute approach was to just follow what the problem statement states as we can see the later a query comes that val has more chances to stay on the matrix.\\n\\n# Approach\\nSo why not just iterate the queries from behind and keep track of num of rows and num of cols to update the ans but what if a row or col that has already been filled comes agaiin so we need to keep track of the already filled rows and cols.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n\\n        int numRowsLeft=n;\\n        int numColsLeft=n;\\n\\n        long long sum=0;\\n        int sz=queries.size();\\n        unordered_set<int> rowsVisited;\\n        unordered_set<int> colsVisited;\\n\\n        for(int i=sz-1;i>=0;i--){\\n            if(queries[i][0]==0 && rowsVisited.find(queries[i][1])==rowsVisited.end()){\\n                numRowsLeft--;\\n                sum+=numColsLeft*queries[i][2];\\n                rowsVisited.insert(queries[i][1]);\\n            }\\n            else if(queries[i][0]==1 && colsVisited.find(queries[i][1])==colsVisited.end()){\\n                numColsLeft--;\\n                sum+=numRowsLeft*queries[i][2];\\n                colsVisited.insert(queries[i][1]);\\n\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n\\n        int numRowsLeft=n;\\n        int numColsLeft=n;\\n\\n        long long sum=0;\\n        int sz=queries.size();\\n        unordered_set<int> rowsVisited;\\n        unordered_set<int> colsVisited;\\n\\n        for(int i=sz-1;i>=0;i--){\\n            if(queries[i][0]==0 && rowsVisited.find(queries[i][1])==rowsVisited.end()){\\n                numRowsLeft--;\\n                sum+=numColsLeft*queries[i][2];\\n                rowsVisited.insert(queries[i][1]);\\n            }\\n            else if(queries[i][0]==1 && colsVisited.find(queries[i][1])==colsVisited.end()){\\n                numColsLeft--;\\n                sum+=numRowsLeft*queries[i][2];\\n                colsVisited.insert(queries[i][1]);\\n\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769505,
                "title": "beats-86-short-fast-and-easy-solution-in-python",
                "content": "# PLEASEEEEEEEEE UPVOTEEEEE \\uD83E\\uDD7A\\uD83D\\uDC9D\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        row=set()\\n        col=set()\\n        ans=0\\n        for i,j,k in queries[::-1]:\\n            if i==0:\\n                if j not in row:\\n                    ans+=(n-len(col))*k\\n                    row.add(j)\\n            if i==1:\\n                if j not in col:\\n                    ans+=(n-len(row))*k\\n                    col.add(j)\\n        return ans\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        row=set()\\n        col=set()\\n        ans=0\\n        for i,j,k in queries[::-1]:\\n            if i==0:\\n                if j not in row:\\n                    ans+=(n-len(col))*k\\n                    row.add(j)\\n            if i==1:\\n                if j not in col:\\n                    ans+=(n-len(row))*k\\n                    col.add(j)\\n        return ans\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743046,
                "title": "beat-100-java-solution-with-explanation",
                "content": "# Intuition\\nEach element in the matrix will only **honor** the last query because the value of an old query will be override by the value of a new query.  Given that said, we will scan queries in reverse order,  like queries[x-1], queries[x-2], ..., queries[1], queries[0].\\n\\nFor each query, we need to find how many elements to override. There are several cases.\\n\\n1. If the row (or col) has already been queried by a later query in time sequence, we will skip this query.\\n2. If the row (or col) is not queries, we have to think about how many elements to override. For row query, the elements to override in the row are the ones that have not been covered by any column query. Same for column query, the elements to override in the column are the ones that have not been covered by row query.\\n\\n\\n# Approach\\n**Define two boolean arrays that represent if a row or column has been queried, and two integers that represent the numbers rows or columns that have not been queried**\\n```\\nboolean[] queriedRow = new boolean[n];\\nboolean[] queriedCol = new boolean[n];\\nint remainingRows = n, remainingCols = n;\\n```\\n\\nFor row query \\n```\\nqueriedRow[row] = true\\nremainingRows--\\n```\\n\\nFor column query, \\n```\\nqueriedCol[col] = true\\nremainingCols--\\n```\\n\\n\\n**Calculate sum for each query**\\n\\nFor row query, \\n```\\nsum += value * remainingCols\\n```\\n\\nFor column query, \\n```\\nsum += value * remainingRows\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(m), m is the length of queries\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        boolean[] queriedRow = new boolean[n];\\n        boolean[] queriedCol = new boolean[n];\\n\\n        long sum = 0;\\n        int remainingRows = n, remainingCols = n;\\n        for (int i = queries.length - 1; i >=0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n            if (type == 0) {\\n                if (queriedRow[index]) {\\n                    continue;\\n                }\\n\\n                sum += (long)(value * remainingCols);\\n                remainingRows --;\\n                queriedRow[index] = true;\\n            } else {\\n                if (queriedCol[index]) {\\n                    continue;\\n                }\\n                \\n                sum += (long)(value * remainingRows);\\n                remainingCols --;\\n                queriedCol[index] = true;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nboolean[] queriedRow = new boolean[n];\\nboolean[] queriedCol = new boolean[n];\\nint remainingRows = n, remainingCols = n;\\n```\n```\\nqueriedRow[row] = true\\nremainingRows--\\n```\n```\\nqueriedCol[col] = true\\nremainingCols--\\n```\n```\\nsum += value * remainingCols\\n```\n```\\nsum += value * remainingRows\\n```\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        boolean[] queriedRow = new boolean[n];\\n        boolean[] queriedCol = new boolean[n];\\n\\n        long sum = 0;\\n        int remainingRows = n, remainingCols = n;\\n        for (int i = queries.length - 1; i >=0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n            if (type == 0) {\\n                if (queriedRow[index]) {\\n                    continue;\\n                }\\n\\n                sum += (long)(value * remainingCols);\\n                remainingRows --;\\n                queriedRow[index] = true;\\n            } else {\\n                if (queriedCol[index]) {\\n                    continue;\\n                }\\n                \\n                sum += (long)(value * remainingRows);\\n                remainingCols --;\\n                queriedCol[index] = true;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735229,
                "title": "c-hash-table-beginner-friendly-clean-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans=0;\\n        long long row=0;\\n        long long column=0;\\n        map<int,int> m0;\\n        map<int,int> m1;\\n\\n        for(int i=queries.size()-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n                if(m0.find(queries[i][1])!=m0.end()){\\n                    continue;\\n                }\\n                ans+=queries[i][2]*(n-column);\\n                m0[queries[i][1]]++;\\n                row++;\\n            }\\n            else{\\n                if(m1.find(queries[i][1])!=m1.end()){\\n                    continue;\\n                }\\n                ans+=queries[i][2]*(n-row);\\n                m1[queries[i][1]]++;\\n                column++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans=0;\\n        long long row=0;\\n        long long column=0;\\n        map<int,int> m0;\\n        map<int,int> m1;\\n\\n        for(int i=queries.size()-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n                if(m0.find(queries[i][1])!=m0.end()){\\n                    continue;\\n                }\\n                ans+=queries[i][2]*(n-column);\\n                m0[queries[i][1]]++;\\n                row++;\\n            }\\n            else{\\n                if(m1.find(queries[i][1])!=m1.end()){\\n                    continue;\\n                }\\n                ans+=queries[i][2]*(n-row);\\n                m1[queries[i][1]]++;\\n                column++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717449,
                "title": "python-micro-optimized-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rows, cols = [0] * (n + 1), [0] * (n + 1) \\n        rows[-1], cols[-1] = n, n# last index stores length of hashset\\n        result = 0\\n        action_for_query = [(rows, cols), (cols, rows)]\\n        for query_type, index, value in reversed(queries):\\n            modified_axis, opposite_axis = action_for_query[query_type]\\n            if modified_axis[index] == 0:\\n                modified_axis[index] = 1 # 1 = used\\n                modified_axis[-1] -= 1 # decrease the count at the last index\\n                result += opposite_axis[-1] * value\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rows, cols = [0] * (n + 1), [0] * (n + 1) \\n        rows[-1], cols[-1] = n, n# last index stores length of hashset\\n        result = 0\\n        action_for_query = [(rows, cols), (cols, rows)]\\n        for query_type, index, value in reversed(queries):\\n            modified_axis, opposite_axis = action_for_query[query_type]\\n            if modified_axis[index] == 0:\\n                modified_axis[index] = 1 # 1 = used\\n                modified_axis[-1] -= 1 # decrease the count at the last index\\n                result += opposite_axis[-1] * value\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717429,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_map<int,bool> rVisit, cVisit;\\n        ll sum=0;\\n\\n        // traverse queries array in reverse order\\n\\n        for(int i=queries.size()-1; i>=0; i--){\\n            if(queries[i][0]==0){\\n                int rowIndex = queries[i][1];\\n                int val = queries[i][2];\\n                if(rVisit[rowIndex]) continue;\\n\\n                ll temp = n-cVisit.size();\\n                sum += temp*val;  \\n                rVisit[rowIndex] = 1;          \\n            }\\n            else{\\n                int colIndex = queries[i][1];\\n                int val = queries[i][2];\\n                if(cVisit[colIndex]) continue;\\n\\n                ll temp = n-rVisit.size();\\n                sum += temp*val;\\n                cVisit[colIndex] = 1;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_map<int,bool> rVisit, cVisit;\\n        ll sum=0;\\n\\n        // traverse queries array in reverse order\\n\\n        for(int i=queries.size()-1; i>=0; i--){\\n            if(queries[i][0]==0){\\n                int rowIndex = queries[i][1];\\n                int val = queries[i][2];\\n                if(rVisit[rowIndex]) continue;\\n\\n                ll temp = n-cVisit.size();\\n                sum += temp*val;  \\n                rVisit[rowIndex] = 1;          \\n            }\\n            else{\\n                int colIndex = queries[i][1];\\n                int val = queries[i][2];\\n                if(cVisit[colIndex]) continue;\\n\\n                ll temp = n-rVisit.size();\\n                sum += temp*val;\\n                cVisit[colIndex] = 1;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717424,
                "title": "simple-python-beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rows, cols = set(i for i in range(n)), set(i for i in range(n))\\n        result = 0\\n        action_for_query = {0: (rows, cols), 1: (cols, rows)}\\n        for query_type, index, value in reversed(queries):\\n            modified_axis, opposite_axis = action_for_query[query_type]\\n            if index in modified_axis:\\n                modified_axis.remove(index)\\n                result += len(opposite_axis) * value\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rows, cols = set(i for i in range(n)), set(i for i in range(n))\\n        result = 0\\n        action_for_query = {0: (rows, cols), 1: (cols, rows)}\\n        for query_type, index, value in reversed(queries):\\n            modified_axis, opposite_axis = action_for_query[query_type]\\n            if index in modified_axis:\\n                modified_axis.remove(index)\\n                result += len(opposite_axis) * value\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715454,
                "title": "c-traverse-from-end",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(max(n, queries.size()))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long res = 0;\\n        vector<int> col(n, -1), row(n, -1);\\n        int rowCnt = 0, colCnt = 0;\\n        for (int i = queries.size() - 1; i >= 0; -- i) {\\n            if (queries[i][0]) {\\n                if (col[queries[i][1]] == -1) {\\n                    col[queries[i][1]] = queries[i][2];\\n                    res += queries[i][2] * (n - rowCnt);\\n                    ++ colCnt;\\n                }\\n            } else {\\n                if (row[queries[i][1]] == -1) {\\n                    row[queries[i][1]] = queries[i][2];\\n                    res += queries[i][2] * (n - colCnt);\\n                    ++ rowCnt;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long res = 0;\\n        vector<int> col(n, -1), row(n, -1);\\n        int rowCnt = 0, colCnt = 0;\\n        for (int i = queries.size() - 1; i >= 0; -- i) {\\n            if (queries[i][0]) {\\n                if (col[queries[i][1]] == -1) {\\n                    col[queries[i][1]] = queries[i][2];\\n                    res += queries[i][2] * (n - rowCnt);\\n                    ++ colCnt;\\n                }\\n            } else {\\n                if (row[queries[i][1]] == -1) {\\n                    row[queries[i][1]] = queries[i][2];\\n                    res += queries[i][2] * (n - colCnt);\\n                    ++ rowCnt;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704732,
                "title": "sum-of-matrix-after-queries-souvik-hazra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n    ans = 0\\n    # seen[0] := row, seen[1] := col\\n    seen = [[False] * n for _ in range(2)]\\n    # notSet[0] = row, notSet[1] := col\\n    notSet = [n] * 2\\n\\n    # Late queries dominate.\\n    for type, index, val in reversed(queries):\\n      if not seen[type][index]:\\n        ans += val * notSet[type ^ 1]\\n        seen[type][index] = True\\n        notSet[type] -= 1\\n\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n    ans = 0\\n    # seen[0] := row, seen[1] := col\\n    seen = [[False] * n for _ in range(2)]\\n    # notSet[0] = row, notSet[1] := col\\n    notSet = [n] * 2\\n\\n    # Late queries dominate.\\n    for type, index, val in reversed(queries):\\n      if not seen[type][index]:\\n        ans += val * notSet[type ^ 1]\\n        seen[type][index] = True\\n        notSet[type] -= 1\\n\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700314,
                "title": "sum-of-matrix-after-queries-java-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rows=new HashSet<>();\\n        Set<Integer> cols=new HashSet<>();\\n        long sum=0;\\n        for (int i=queries.length-1;i>=0;i--){\\n            int [] q=queries[i];\\n            int type=q[0];\\n            int index=q[1];\\n            int val=q[2];\\n            if (type==0){\\n                if (!rows.contains(index)){\\n                    sum+=(n-cols.size())*val;\\n                    rows.add(index);\\n                }\\n            }else {\\n                if (!cols.contains(index)){\\n                    sum+=(n-rows.size())*val;\\n                    cols.add(index);\\n                }\\n            }\\n        }\\n        return sum;        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rows=new HashSet<>();\\n        Set<Integer> cols=new HashSet<>();\\n        long sum=0;\\n        for (int i=queries.length-1;i>=0;i--){\\n            int [] q=queries[i];\\n            int type=q[0];\\n            int index=q[1];\\n            int val=q[2];\\n            if (type==0){\\n                if (!rows.contains(index)){\\n                    sum+=(n-cols.size())*val;\\n                    rows.add(index);\\n                }\\n            }else {\\n                if (!cols.contains(index)){\\n                    sum+=(n-rows.size())*val;\\n                    cols.add(index);\\n                }\\n            }\\n        }\\n        return sum;        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682382,
                "title": "c-count-number-of-row-and-col-left",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n        long long ans = 0, rowRemain = n, colRemain = n;\\n        for(int i = q.size()-1; i >= 0; --i){\\n            if(q[i][0] == 0 && rowFlag[q[i][1]]) \\n            { ans += colRemain * q[i][2];    \\n            rowFlag[q[i][1]] = 0; \\n            rowRemain--; }\\n            if(q[i][0] == 1 && colFlag[q[i][1]])\\n            { ans += rowRemain * q[i][2];    \\n             colFlag[q[i][1]] = 0;\\n             colRemain--; }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n        long long ans = 0, rowRemain = n, colRemain = n;\\n        for(int i = q.size()-1; i >= 0; --i){\\n            if(q[i][0] == 0 && rowFlag[q[i][1]]) \\n            { ans += colRemain * q[i][2];    \\n            rowFlag[q[i][1]] = 0; \\n            rowRemain--; }\\n            if(q[i][0] == 1 && colFlag[q[i][1]])\\n            { ans += rowRemain * q[i][2];    \\n             colFlag[q[i][1]] = 0;\\n             colRemain--; }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680252,
                "title": "beats-90-o-n-in-time-and-space-neat-and-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int qs = queries.size(), no_of_col = n, no_of_row = n;\\n        long long ans = 0;\\n        vector<bool> row(n,0), col(n,0);\\n     //start iterating queries from the last   \\n        for(int i=qs-1; i>=0; i--)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n                 if(type == 0 && !row[index]) //if previously not changed, then\\n                  {\\n                    row[index] = 1;\\n                    ans += no_of_col*val;\\n                    no_of_row--; //so that we do not change this row again\\n\\n                  }\\n                 if(type == 1 && !col[index]) //if previously not changed, then\\n                  {\\n                    col[index] = 1;\\n                    ans += no_of_row*val;\\n                    no_of_col--; //so that we do not change this col again\\n                  }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int qs = queries.size(), no_of_col = n, no_of_row = n;\\n        long long ans = 0;\\n        vector<bool> row(n,0), col(n,0);\\n     //start iterating queries from the last   \\n        for(int i=qs-1; i>=0; i--)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n                 if(type == 0 && !row[index]) //if previously not changed, then\\n                  {\\n                    row[index] = 1;\\n                    ans += no_of_col*val;\\n                    no_of_row--; //so that we do not change this row again\\n\\n                  }\\n                 if(type == 1 && !col[index]) //if previously not changed, then\\n                  {\\n                    col[index] = 1;\\n                    ans += no_of_row*val;\\n                    no_of_col--; //so that we do not change this col again\\n                  }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678662,
                "title": "readable-python-solution",
                "content": "```\\nclass Solution:    \\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int        \\n        seen_rows, seen_cols = set(), set()\\n        total_sum = 0\\n\\n        for q_type, q_idx, q_val in reversed(queries):\\n            if q_type == 0:  \\n                if q_idx not in seen_rows:\\n                    total_sum += q_val * (n - len(seen_cols))\\n                    seen_rows.add(q_idx)\\n            else:  \\n                if q_idx not in seen_cols:\\n                    total_sum += q_val * (n - len(seen_rows))\\n                    seen_cols.add(q_idx)\\n\\n        return total_sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:    \\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int        \\n        seen_rows, seen_cols = set(), set()\\n        total_sum = 0\\n\\n        for q_type, q_idx, q_val in reversed(queries):\\n            if q_type == 0:  \\n                if q_idx not in seen_rows:\\n                    total_sum += q_val * (n - len(seen_cols))\\n                    seen_rows.add(q_idx)\\n            else:  \\n                if q_idx not in seen_cols:\\n                    total_sum += q_val * (n - len(seen_rows))\\n                    seen_cols.add(q_idx)\\n\\n        return total_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674126,
                "title": "c-solution-by-reverse-traversal-of-given-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(queries.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int m=queries.size();\\n        vector<int> row(n,0), col(n,0);\\n        for(int i=m-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n               if(row[queries[i][1]]==0) row[queries[i][1]]=1;\\n                else queries[i][1]=n;\\n            }\\n            if(queries[i][0]==1){\\n              if(col[queries[i][1]]==0)  col[queries[i][1]]=1;\\n                else queries[i][1]=n;\\n            }\\n        }\\n        \\n        int r=n,c=n;\\n        long long int ans=0;\\n        \\n        for(int i=m-1;i>=0;i--){\\n            int type=queries[i][0];\\n            int ind=queries[i][1];\\n            int val=queries[i][2];\\n            \\n            if(type==0 && ind!=n){\\n                ans+=c*val;\\n                r--;\\n            }\\n            if(type==1 && ind!=n){\\n                ans+=r*val;\\n                c--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int m=queries.size();\\n        vector<int> row(n,0), col(n,0);\\n        for(int i=m-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n               if(row[queries[i][1]]==0) row[queries[i][1]]=1;\\n                else queries[i][1]=n;\\n            }\\n            if(queries[i][0]==1){\\n              if(col[queries[i][1]]==0)  col[queries[i][1]]=1;\\n                else queries[i][1]=n;\\n            }\\n        }\\n        \\n        int r=n,c=n;\\n        long long int ans=0;\\n        \\n        for(int i=m-1;i>=0;i--){\\n            int type=queries[i][0];\\n            int ind=queries[i][1];\\n            int val=queries[i][2];\\n            \\n            if(type==0 && ind!=n){\\n                ans+=c*val;\\n                r--;\\n            }\\n            if(type==1 && ind!=n){\\n                ans+=r*val;\\n                c--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669321,
                "title": "c-map-based-easy-solution-intuitive-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int size = queries.size();\\n        long long sum = 0;\\n        \\n        map<int, bool> markRow;\\n        map<int, bool> markCol; \\n\\n        for(int i=size-1; i>=0; i--){\\n            vector<int> query = queries[i];\\n            bool isCol = (queries[i][0] == 1) ? true : false;\\n            int index  = queries[i][1];\\n            int value = queries[i][2];\\n            if(isCol){\\n                if(markCol.find(index) != markCol.end()){\\n                    continue;\\n                }\\n                else{\\n                    sum += (n - markRow.size()) * value;\\n                    markCol[index] = true;\\n                }\\n\\n            }\\n            else{\\n                if(markRow.find(index) != markRow.end()){\\n                    continue;\\n                }\\n                else{\\n                    sum += (n - markCol.size()) * value;\\n                    markRow[index] = true;\\n                }\\n            }           \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int size = queries.size();\\n        long long sum = 0;\\n        \\n        map<int, bool> markRow;\\n        map<int, bool> markCol; \\n\\n        for(int i=size-1; i>=0; i--){\\n            vector<int> query = queries[i];\\n            bool isCol = (queries[i][0] == 1) ? true : false;\\n            int index  = queries[i][1];\\n            int value = queries[i][2];\\n            if(isCol){\\n                if(markCol.find(index) != markCol.end()){\\n                    continue;\\n                }\\n                else{\\n                    sum += (n - markRow.size()) * value;\\n                    markCol[index] = true;\\n                }\\n\\n            }\\n            else{\\n                if(markRow.find(index) != markRow.end()){\\n                    continue;\\n                }\\n                else{\\n                    sum += (n - markCol.size()) * value;\\n                    markRow[index] = true;\\n                }\\n            }           \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660881,
                "title": "simple-reverse-iteration-new-differernt-approach",
                "content": "[![image](https://assets.leetcode.com/users/images/c531954e-243c-4632-b4db-79a61fc3c981_1687253322.0880413.png)\\n](http://)\\n**MY  FIRST APPROACH GET FAILED AT SOME CASES. ALTHOUGH IT WAS QUITE NEAR TO THE DESIRED SOLUTION.\\nMy intuition was simple, since constraints were high I need to think about some thing in which I\\'m only taking into account rows and colm. Because we cant keep updating array then it would be quite simple question. We need to think somethng different. Since values are keep updating, so it was quite obvious to think the answer from the back **\\n\\nCode for 1st Approach: \\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int N=queries.size();\\n        int row=0;\\n        int colm=0;\\n        for(int i=N-1;i>=0;i--){\\n            \\n            \\n            if(queries[i][0]==0){// row\\n                queries[i].push_back(colm);\\n                row++;\\n            }else{\\n                queries[i].push_back(row);\\n                colm++;\\n            }\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<N;i++){\\n            int k=n-queries[i][3];\\n            int ans=k*queries[i][2];\\n            sum+=ans;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\nI was failed because I did\\'nt take into account that if same row or colm query is asked again.  If that happened then that value will be overwritten and sum will be not be taken into account towards our answer. \\nFor that i created two visited arrays for both row and colm. \\n\\n2nd Approach\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int N=queries.size();\\n        long long row=0;\\n        long long colm=0;\\n        long long sum=0;\\n        map<int,int>mpr,mpc;\\n        for(int i=N-1;i>=0;i--){\\n            \\n            int id=queries[i][1];\\n            \\n            if(queries[i][0]==0 && mpr[id]==0){// row\\n                // queries[i].push_back(colm);\\n                long long k=n-colm;\\n                long long ans=k*queries[i][2];\\n                sum+=ans;\\n                mpr[id]=1;\\n                row++;\\n            }else if(queries[i][0]==1 && mpc[id]==0){\\n                // queries[i].push_back(row);\\n                \\n                long long k=n-row;\\n                long long ans=k*queries[i][2];\\n                sum+=ans;\\n                mpc[id]=1;\\n                colm++;\\n            }\\n        }\\n        \\n       \\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int N=queries.size();\\n        int row=0;\\n        int colm=0;\\n        for(int i=N-1;i>=0;i--){\\n            \\n            \\n            if(queries[i][0]==0){// row\\n                queries[i].push_back(colm);\\n                row++;\\n            }else{\\n                queries[i].push_back(row);\\n                colm++;\\n            }\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<N;i++){\\n            int k=n-queries[i][3];\\n            int ans=k*queries[i][2];\\n            sum+=ans;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int N=queries.size();\\n        long long row=0;\\n        long long colm=0;\\n        long long sum=0;\\n        map<int,int>mpr,mpc;\\n        for(int i=N-1;i>=0;i--){\\n            \\n            int id=queries[i][1];\\n            \\n            if(queries[i][0]==0 && mpr[id]==0){// row\\n                // queries[i].push_back(colm);\\n                long long k=n-colm;\\n                long long ans=k*queries[i][2];\\n                sum+=ans;\\n                mpr[id]=1;\\n                row++;\\n            }else if(queries[i][0]==1 && mpc[id]==0){\\n                // queries[i].push_back(row);\\n                \\n                long long k=n-row;\\n                long long ans=k*queries[i][2];\\n                sum+=ans;\\n                mpc[id]=1;\\n                colm++;\\n            }\\n        }\\n        \\n       \\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651884,
                "title": "easy-linear-time-faster-than-100-reverse-traversal-query",
                "content": "*Approach is being explained at each step and fully explained using Comments.*\\n\\n# Complexity\\n- Time complexity: **O(Queries.size())**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)** \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        long long ans = 0;\\n\\n        // Visited arrays for row and column\\n        vector <int> rowVisited(n,0);\\n        vector <int> colVisited(n,0);\\n\\n        int rowAffectedCnt = 0 ;\\n        int colAffectedCnt = 0 ; \\n\\n        // Traversing in a reverse order of queries as queries at the end / last has a more dominant affect on values \\n\\n        for(int i=queries.size()-1 ; i>=0 ; i--){\\n\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n            // Row operation\\n            if(type == 0){\\n\\n                // not previously affected/changed this row\\n                if(rowVisited[index] == 0){\\n\\n                    rowVisited[index] = 1; // now mark affected or changed\\n\\n                    // No of Changes to be done will be the n - TOTAL previously column which are already affected , since we are not going to change those cells whose column is changed before this current operation on row\\n                    int noOfChanges = n - colAffectedCnt;\\n\\n                    ans += 1ll*val*noOfChanges; // Just add val * noOfChanges\\n\\n                    rowAffectedCnt++; // increment the no. of rows being affected\\n                }\\n\\n                // If any previously affected row is made any changes it will have a no effect\\n\\n            }\\n\\n\\n            // Col operation\\n            else{\\n\\n                // not previously affected this col\\n                if(colVisited[index] == 0){\\n\\n                    colVisited[index] = 1; // not mark affected or changed\\n\\n                    // No of Changes to be done will be the n - TOTAL previously rows which are already affected , since we are not going to change those cells whose rows is changed before this current operation on column\\n\\n                    int noOfChanges = n - rowAffectedCnt;\\n\\n                    ans += 1ll*val*noOfChanges;\\n\\n                    colAffectedCnt++; // increment the no. of cols being affected\\n            \\n                }\\n\\n                // If any previously affected COL is made any changes it will have a no effect\\n\\n            }\\n\\n\\n        }\\n\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```\\n\\n**If you liked the approach , PLEASE UPVOTE ...!**",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        long long ans = 0;\\n\\n        // Visited arrays for row and column\\n        vector <int> rowVisited(n,0);\\n        vector <int> colVisited(n,0);\\n\\n        int rowAffectedCnt = 0 ;\\n        int colAffectedCnt = 0 ; \\n\\n        // Traversing in a reverse order of queries as queries at the end / last has a more dominant affect on values \\n\\n        for(int i=queries.size()-1 ; i>=0 ; i--){\\n\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n            // Row operation\\n            if(type == 0){\\n\\n                // not previously affected/changed this row\\n                if(rowVisited[index] == 0){\\n\\n                    rowVisited[index] = 1; // now mark affected or changed\\n\\n                    // No of Changes to be done will be the n - TOTAL previously column which are already affected , since we are not going to change those cells whose column is changed before this current operation on row\\n                    int noOfChanges = n - colAffectedCnt;\\n\\n                    ans += 1ll*val*noOfChanges; // Just add val * noOfChanges\\n\\n                    rowAffectedCnt++; // increment the no. of rows being affected\\n                }\\n\\n                // If any previously affected row is made any changes it will have a no effect\\n\\n            }\\n\\n\\n            // Col operation\\n            else{\\n\\n                // not previously affected this col\\n                if(colVisited[index] == 0){\\n\\n                    colVisited[index] = 1; // not mark affected or changed\\n\\n                    // No of Changes to be done will be the n - TOTAL previously rows which are already affected , since we are not going to change those cells whose rows is changed before this current operation on column\\n\\n                    int noOfChanges = n - rowAffectedCnt;\\n\\n                    ans += 1ll*val*noOfChanges;\\n\\n                    colAffectedCnt++; // increment the no. of cols being affected\\n            \\n                }\\n\\n                // If any previously affected COL is made any changes it will have a no effect\\n\\n            }\\n\\n\\n        }\\n\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649307,
                "title": "java-reverse-loop",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou will see the set of rows just keep overwriting previous resuls. \\nYou just need to find out the last operation of each cols and rows.\\n\\nKeep in mind:\\nWhen you check cols, the vals in cols will be overwritten by later query of rows, and vice versa. see comment like \"// the value in rows.size() cells is already added.\"\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTC: O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSC: O(N)\\n# Code\\n```\\npublic long matrixSumQueries(int n, int[][] qs) {\\n    Set<Integer> rows = new HashSet<>(), cols = new HashSet<>();\\n    long res = 0;\\n    for (int i = qs.length - 1; i >= 0; i--) {\\n        int[] q = qs[i];\\n        if (q[0] == 0 ) { // rows\\n            // the value in cols.size() cells is already added.\\n            if (rows.add(q[1])) res += q[2] * (n - cols.size());\\n        } else if (cols.add(q[1])) { // cols\\n            // the value in rows.size() cells is already added.\\n            res += q[2] * (n - rows.size());\\n        }\\n        if (rows.size() == n && cols.size() == n) break;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long matrixSumQueries(int n, int[][] qs) {\\n    Set<Integer> rows = new HashSet<>(), cols = new HashSet<>();\\n    long res = 0;\\n    for (int i = qs.length - 1; i >= 0; i--) {\\n        int[] q = qs[i];\\n        if (q[0] == 0 ) { // rows\\n            // the value in cols.size() cells is already added.\\n            if (rows.add(q[1])) res += q[2] * (n - cols.size());\\n        } else if (cols.add(q[1])) { // cols\\n            // the value in rows.size() cells is already added.\\n            res += q[2] * (n - rows.size());\\n        }\\n        if (rows.size() == n && cols.size() == n) break;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642562,
                "title": "latest-updates-only-one-if-block",
                "content": "# Intuition\\n\\n1. The latest update on the any particular row / column dominates the matrix. \\n2. To find the sum effeciently its optimal to consider queries in reverse order.\\n3. Initially let number of columns and rows that are not updated be equal to n.\\n4. If latest query updates cth column for the first time, then it contributes to the sum by **value x activeRows**.\\n5. Query update on the cth column dominates throughout other queries, therefore the number of active columns decreases by 1.\\n6. If latest query updates rth row for the first time, then it contributes to the sum by **value x activeCols**.\\n7. Query update on the rth row dominates throughout other queries, therefore the number of active rows decreases by 1.\\n\\n# Approach (Two IF Blocks)\\n  \\n    if(type == 0) // change row\\n        {\\n                int row = queries[i][1];\\n                if(!rowHash[row]) rowHash[row] = true, (sumOfMatrix += (queries[i][2] * activeCols)), --activeRows;\\n        }\\n     else if(type == 1) // change col\\n        {\\n            int col = queries[i][1]; \\n            if(!colHash[col]) colHash[col] = true, (sumOfMatrix += (queries[i][2] * activeRows)), --activeCols;\\n        }\\n\\n**The above TWO IF BLOCKS can be reduced to a SINGLE IF LINE by making using of 2D array maps.**(See code for its implementation)\\n    \\n# Complexity\\n- Time complexity:  $$0(q)$$\\n\\n- Space complexity: $$0(n)$$\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution \\n{\\n    public:\\n\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    \\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {    \\n        // rowHash[r] = true => row r has been updated by earlier query.\\n        // colHash[c] = true => col c has been updated by earlier query.\\n\\n        vector<vector<bool>> hash(2, vector<bool>(n, false)); // hash[0] = rowHash[0...n-1], hash[1] = colHash[0...n-1]\\n        \\n        vector<int> active(2, n); // active[0] = active_rows, active[1] = active_cols\\n        \\n        int q             = (int) queries.size();\\n        \\n        ll sumOfMatrix    = 0LL;\\n          \\n        for(int i = q - 1; i >= 0; --i)\\n        {\\n            int type = queries[i][0];\\n            \\n            if(!hash[type][queries[i][1]]) (hash[type][queries[i][1]] = true), (sumOfMatrix += (queries[i][2] * active[type ^ 1])), (--active[type]);\\n          \\n        }\\n         \\n        return sumOfMatrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution \\n{\\n    public:\\n\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    \\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {    \\n        // rowHash[r] = true => row r has been updated by earlier query.\\n        // colHash[c] = true => col c has been updated by earlier query.\\n\\n        vector<vector<bool>> hash(2, vector<bool>(n, false)); // hash[0] = rowHash[0...n-1], hash[1] = colHash[0...n-1]\\n        \\n        vector<int> active(2, n); // active[0] = active_rows, active[1] = active_cols\\n        \\n        int q             = (int) queries.size();\\n        \\n        ll sumOfMatrix    = 0LL;\\n          \\n        for(int i = q - 1; i >= 0; --i)\\n        {\\n            int type = queries[i][0];\\n            \\n            if(!hash[type][queries[i][1]]) (hash[type][queries[i][1]] = true), (sumOfMatrix += (queries[i][2] * active[type ^ 1])), (--active[type]);\\n          \\n        }\\n         \\n        return sumOfMatrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639930,
                "title": "simple-reverse-iteration-and-using-maps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        ll sum = 0;\\n        map<int, int> rmp, cmp;// duplicate complete row, col change\\n        int rcnt = 0, ccnt = 0;\\n        for(int i = queries.size()-1;i>=0;i--){\\n            vector<int> e = queries[i];\\n            int t = e[0], rcn = e[1], x = e[2];\\n            if(t == 0){//row set\\n                if(!rmp.count(rcn)){// nhi milna chaiye\\n                    sum += (n-ccnt)*1ll*x;\\n                    rcnt++;\\n                }\\n                rmp[rcn] = x;\\n            }else{// col set\\n                if(!cmp.count(rcn)){// nhi milna chaiye\\n                    sum += (n-rcnt)*1ll*x;\\n                    ccnt++;\\n                }\\n                cmp[rcn] = x;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        ll sum = 0;\\n        map<int, int> rmp, cmp;// duplicate complete row, col change\\n        int rcnt = 0, ccnt = 0;\\n        for(int i = queries.size()-1;i>=0;i--){\\n            vector<int> e = queries[i];\\n            int t = e[0], rcn = e[1], x = e[2];\\n            if(t == 0){//row set\\n                if(!rmp.count(rcn)){// nhi milna chaiye\\n                    sum += (n-ccnt)*1ll*x;\\n                    rcnt++;\\n                }\\n                rmp[rcn] = x;\\n            }else{// col set\\n                if(!cmp.count(rcn)){// nhi milna chaiye\\n                    sum += (n-rcnt)*1ll*x;\\n                    ccnt++;\\n                }\\n                cmp[rcn] = x;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638072,
                "title": "c-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity:  $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) \\n    {\\n        int r = n;\\n        int c = n;\\n        long long int ans = 0;\\n        vector<int> row_vis(n, 0);\\n        vector<int> col_vis(n, 0);\\n        \\n        for(int i=q.size()-1; i>=0; i--)\\n        {\\n            if(q[i][0]==0 && row_vis[q[i][1]]==0){\\n                ans = ans+(c*q[i][2]);\\n                r--;\\n                row_vis[q[i][1]]=1;\\n            }\\n            else if(q[i][0]==1 && col_vis[q[i][1]]==0){\\n                ans = ans+(r*q[i][2]);\\n                c--;\\n                col_vis[q[i][1]]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) \\n    {\\n        int r = n;\\n        int c = n;\\n        long long int ans = 0;\\n        vector<int> row_vis(n, 0);\\n        vector<int> col_vis(n, 0);\\n        \\n        for(int i=q.size()-1; i>=0; i--)\\n        {\\n            if(q[i][0]==0 && row_vis[q[i][1]]==0){\\n                ans = ans+(c*q[i][2]);\\n                r--;\\n                row_vis[q[i][1]]=1;\\n            }\\n            else if(q[i][0]==1 && col_vis[q[i][1]]==0){\\n                ans = ans+(r*q[i][2]);\\n                c--;\\n                col_vis[q[i][1]]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635954,
                "title": "java-o-n-beats-100-optimal-solution-easy-explanation-beginner-friendly",
                "content": "# Intuition\\nDo we even need to create the matrix ??\\n\\n# Approach\\n**Start from the ending of the queries** because when traversed from back we are **garaunteed that the values wont change** as they are the latest and they would end up in ans. We keep a track of the rows and columns used so we dont use those again. So if a column is used, while adding the values from a row means that it can be added for all the cols except the once already used. so if there are 2 cols already used we cant add those grid cells as they have already been added. \\n\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# PLEASE UPVOTE FOR 100 YEARS OF GOOD LUCK!!!\\n\\n# Code Without Comments Below\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans=0;\\n        int c=n;  //number of columns not used\\n        int r=n;  //number of rows not used \\n        boolean[] row=new boolean[n];     //to track rows used\\n        boolean[] col=new boolean[n];     //to track columns used\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==1){\\n                //column to be used\\n                //check if the index col is used\\n                if(!col[queries[i][1]]){\\n\\n                    col[queries[i][1]]=true;    //make it used true\\n                    ans+=queries[i][2]*r;       //add the value multiplied by the no. of unused rows\\n                    c--;          //decrement value of cols used\\n                }\\n            }else{\\n            //row to be used \\n            //check if the index row is used\\n                    if(!row[queries[i][1]]){\\n                        row[queries[i][1]]=true;    //make it used true\\n                        ans+=queries[i][2]*c;       //add the value multiplied by the no. of unused cols\\n                        r--;                //decrement value of rows used     \\n                    }\\n                }    \\n            //if any rows and cols non used value goes to zero that means we have utilised every cell and need not traverse ahead\\n            if(r==0||c==0){\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n# Code Without Comments\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans=0;\\n        int c=n;  \\n        int r=n;  \\n        boolean[] row=new boolean[n];     \\n        boolean[] col=new boolean[n];\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==1){\\n                if(!col[queries[i][1]]){\\n                    col[queries[i][1]]=true;\\n                    ans+=queries[i][2]*r;\\n                    c--;    \\n                }\\n            }else{\\n                    if(!row[queries[i][1]]){\\n                        row[queries[i][1]]=true;\\n                        ans+=queries[i][2]*c;\\n                        r--;\\n                    }\\n                }    \\n            if(r==0||c==0){\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans=0;\\n        int c=n;  //number of columns not used\\n        int r=n;  //number of rows not used \\n        boolean[] row=new boolean[n];     //to track rows used\\n        boolean[] col=new boolean[n];     //to track columns used\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==1){\\n                //column to be used\\n                //check if the index col is used\\n                if(!col[queries[i][1]]){\\n\\n                    col[queries[i][1]]=true;    //make it used true\\n                    ans+=queries[i][2]*r;       //add the value multiplied by the no. of unused rows\\n                    c--;          //decrement value of cols used\\n                }\\n            }else{\\n            //row to be used \\n            //check if the index row is used\\n                    if(!row[queries[i][1]]){\\n                        row[queries[i][1]]=true;    //make it used true\\n                        ans+=queries[i][2]*c;       //add the value multiplied by the no. of unused cols\\n                        r--;                //decrement value of rows used     \\n                    }\\n                }    \\n            //if any rows and cols non used value goes to zero that means we have utilised every cell and need not traverse ahead\\n            if(r==0||c==0){\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans=0;\\n        int c=n;  \\n        int r=n;  \\n        boolean[] row=new boolean[n];     \\n        boolean[] col=new boolean[n];\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==1){\\n                if(!col[queries[i][1]]){\\n                    col[queries[i][1]]=true;\\n                    ans+=queries[i][2]*r;\\n                    c--;    \\n                }\\n            }else{\\n                    if(!row[queries[i][1]]){\\n                        row[queries[i][1]]=true;\\n                        ans+=queries[i][2]*c;\\n                        r--;\\n                    }\\n                }    \\n            if(r==0||c==0){\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635692,
                "title": "python-runtime-o-n-memory-o-n",
                "content": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = rowCovered = colCovered = 0\\n        row = [0]*n\\n        col = [0]*n\\n        \\n        for j in range(len(queries)-1, -1, -1):\\n            t, i, v = queries[j]\\n            if t == 0:\\n                if row[i] == 0:\\n                    rowCovered += 1\\n                    ans += (n - colCovered)*v\\n                    row[i] = 1\\n            else:\\n                if col[i] == 0:\\n                    colCovered += 1\\n                    ans += (n - rowCovered)*v\\n                    col[i] = 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = rowCovered = colCovered = 0\\n        row = [0]*n\\n        col = [0]*n\\n        \\n        for j in range(len(queries)-1, -1, -1):\\n            t, i, v = queries[j]\\n            if t == 0:\\n                if row[i] == 0:\\n                    rowCovered += 1\\n                    ans += (n - colCovered)*v\\n                    row[i] = 1\\n            else:\\n                if col[i] == 0:\\n                    colCovered += 1\\n                    ans += (n - rowCovered)*v\\n                    col[i] = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634975,
                "title": "c-reverse-iterative-row-col-hashmap-solution",
                "content": "# Intuition\\nIn order to compute the sum after the queries, we need to simulate some part of performing the queries. However, actually holding a large 2D array can be very memory-intensive.\\n\\nEach query overwrites the values in a row or col. That means, after a bunch of overlapping queries, only the most recent would be visible. Therefore, we should iterate backwards through the queries and keep track of which row and col indexes have already been filled.\\n\\n# Approach\\nMake a long to hold the final sum and two hashsets to keep track of the row and col indexes we have filled.\\n\\nIterate through each query backwards and get their type, index, and value. Based on the type, decide which set to fill and which set to compare against. If the set to fill does not contain our current index, add to our sum the query\\'s val * (n - the size of the comparison set).\\n\\n**Explanation**\\n\\nAs we iterate backwards, we want to simulate filling in rows and columns that have not been filled yet. This algorithm first checks if we\\'ve already filled the entire target row/col index. If so, we can\\'t fill anything here so we skip it. If it hasn\\'t been filled, then we check how many values have been filled in the comparison set. We can use this to determine how many blank row/col values we can fill using the query\\'s value.\\n\\nFor example, if the matrix is size 10 and we want to fill row 2 with the value 5, we\\'ll first check to make sure that row 2 has not been filled (since that means we can\\'t put anything here). Then, we check how many cols have been filled. Let\\'s say 6 have been filled. Since 6 cols have been filled, we can still fill 4 (10 - 6) row spaces with our value 5. 4 spaces * 5 value = 20 added to the sum. Then we make sure to mark row 2 as filled.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - We do constant-time operations for each query.\\n\\n- Space complexity:\\n$$O(n)$$ - In the worst case scenario, both hashsets will be filled with n integers.\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public long MatrixSumQueries(int n, int[][] queries)\\n    {\\n        long sum = 0;\\n        HashSet<int> filledRows = new HashSet<int>();\\n        HashSet<int> filledCols = new HashSet<int>();\\n\\n        for (int i = queries.Length - 1; i >= 0; --i)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n            var setToFill = (type == 0) ? filledRows : filledCols;\\n            var setToCompare = (type == 0) ? filledCols : filledRows;\\n            \\n            if (!setToFill.Contains(index))\\n            {\\n                sum += (val * (n - setToCompare.Count));\\n                setToFill.Add(index);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long MatrixSumQueries(int n, int[][] queries)\\n    {\\n        long sum = 0;\\n        HashSet<int> filledRows = new HashSet<int>();\\n        HashSet<int> filledCols = new HashSet<int>();\\n\\n        for (int i = queries.Length - 1; i >= 0; --i)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n            var setToFill = (type == 0) ? filledRows : filledCols;\\n            var setToCompare = (type == 0) ? filledCols : filledRows;\\n            \\n            if (!setToFill.Contains(index))\\n            {\\n                sum += (val * (n - setToCompare.Count));\\n                setToFill.Add(index);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630780,
                "title": "python-thinking-process",
                "content": "This reminds me 2D version of https://leetcode.com/problems/stamping-the-sequence/ \\n\\n1. A few observations from constraints:\\nYou can\\'t just fill out rows/cols for each query and even if you, then you still need to calc the grid\\'s sum.\\nWhich will be `10^4^2`. Maybe TLE. Maybe not.\\nSo we need something that is `O(1)` to calculate the matrix\\'s sum :/\\n\\nThat was brute-force analysis :/\\n\\nWhat can we do to optimize it??? Not much, throw it away.\\n\\n2. Observations from provided examples:\\nThe key to success is to draw a few examples and analyze what\\'s going on.\\n**The vizualization is the key:**\\n![image](https://assets.leetcode.com/users/images/48f16c0c-8362-4147-b4bd-30a6fb9674cf_1686613341.355105.png)\\nWhat do we see here?\\nEach query overrides an existing `column` or `row`.\\n`1` is the solid and **goes across the grid**.\\n`2` is **the solid** and goes across the grid. It\\'s now **the only** solid line that goes across the trid.\\nit overrides `1` in the intersection part.\\n`3` is **the solid** and goes across the grid. It\\'s now **the only** solid line that goes across the trid.\\nit overrides `2` in the intersection part.\\nThis is the interesting part:\\n`4` is **the solid** and goes across the grid. It\\'s now **the only** solid line that goes across the trid.\\nit overrides `1` **AND** `3` in the 2 intersection parts.\\n\\nWhat can we conclude from this process?\\n1. the last query\\'s line is the only line that has all n values\\n2. as soon as the previous line meets some intersections on `rows` or `cols` (actually for `rows` it intersects with `cols` and the opposite) the number of intersections is the number of overriden values by the next line.\\n\\nSo it makes sense to go backward fom the last query to the first one and count number of cells that are left not overriden by the next line:\\n`4` has all cells not overriden\\n`4` overrides 1 cell from `3` line\\n`3` is overriden by `4` and overrides 1 cell from `2` line\\n`2` is overriden by `3` and overrides 1 cell from `1` line\\n!!! `1` is overriden by `2` and `4` lines\\n\\nLook at the image above again.\\n\\nSo each time we travel back we need to count number of intersections with the already present lines (`rows` or `cols`).\\n\\n`4` has 0 intersections -> `+(N - 0) * val`\\n`3` has 1 intersection with `4` -> `+(N - 1) * val`\\n`2` has 1 intersection with `3` -> `+(N - 1) * val`\\n`1` has 2 intersection with `1` and `4` -> `+(N - 2) * val`\\n\\nAnd don\\'t forget that you cannot **count** the same line multiple times during traversal!!!\\n\\n```\\nclass Solution:\\n    def matrixSumQueries(self, N: int, queries: List[List[int]]) -> int:\\n        used_r = set()\\n        used_c = set()\\n        # t = 0 - row, 1 - column\\n        count = 0\\n        for t, i, v in reversed(queries):\\n            if t == 0:\\n                if i not in used_r:\\n                    count += (N - len(used_c)) * v\\n                    used_r.add(i)\\n            else:\\n                if i not in used_c:\\n                    count += (N - len(used_r)) * v\\n                    used_c.add(i)\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, N: int, queries: List[List[int]]) -> int:\\n        used_r = set()\\n        used_c = set()\\n        # t = 0 - row, 1 - column\\n        count = 0\\n        for t, i, v in reversed(queries):\\n            if t == 0:\\n                if i not in used_r:\\n                    count += (N - len(used_c)) * v\\n                    used_r.add(i)\\n            else:\\n                if i not in used_c:\\n                    count += (N - len(used_r)) * v\\n                    used_c.add(i)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627219,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        summ = 0\\n        rows = set()\\n        cols = set()\\n\\n        for x in queries[::-1]:\\n            if x[1] not in (cols if x[0] else rows):\\n                summ += (n-len(rows if x[0] else cols))*x[2]\\n                (cols if x[0] else rows).add(x[1])\\n        \\n        return summ\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        summ = 0\\n        rows = set()\\n        cols = set()\\n\\n        for x in queries[::-1]:\\n            if x[1] not in (cols if x[0] else rows):\\n                summ += (n-len(rows if x[0] else cols))*x[2]\\n                (cols if x[0] else rows).add(x[1])\\n        \\n        return summ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626573,
                "title": "simple-approach-detailed-explanation-o-n-time-complexity",
                "content": "# Intuition\\nClassic problem of how to solve 2D array problem with large constraint. Make another row and column array, 1D, to store the result of row and column in O(N).\\nThe very initial observation that the queries at last will not get updated. And if for any row the query is already dealt we need not update it again. \\n\\n# Approach\\nThe apprach was to make 2 new matrix of name row and col.\\nNow traverse the queries matrix from the last.\\nThe values palced at the last will not be changed. So we move in the same fashion.\\nAgain if query type is 1 we place the value in column and decrease the row number by one. \\nSimilarly for type 0.\\nWe also make sure that once a row is traversed it\\'s not traversed again. So we place a check for that purpose.\\nYou will get more clarity of the concept and how it is done by dry run of the code.\\nThank You.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) + O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size()-1;\\n        int row[n], col[n];\\n        for(int i=0;i<n;i++) {\\n            row[i] = i;\\n            col[i] = i;\\n        }\\n        int r = n, c = n;\\n        long long ans = 0;\\n        for(int i=m;i>=0;i--) {\\n            if(queries[i][0] == 1) {\\n                if(col[queries[i][1]] != -1) {\\n                    col[queries[i][1]] = -1;\\n                    ans += queries[i][2] * c;\\n                    r--;\\n                }\\n            }\\n            else {\\n                if(row[queries[i][1]] != -1) {\\n                    row[queries[i][1]] = -1;\\n                    ans += queries[i][2] * r;\\n                    c--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size()-1;\\n        int row[n], col[n];\\n        for(int i=0;i<n;i++) {\\n            row[i] = i;\\n            col[i] = i;\\n        }\\n        int r = n, c = n;\\n        long long ans = 0;\\n        for(int i=m;i>=0;i--) {\\n            if(queries[i][0] == 1) {\\n                if(col[queries[i][1]] != -1) {\\n                    col[queries[i][1]] = -1;\\n                    ans += queries[i][2] * c;\\n                    r--;\\n                }\\n            }\\n            else {\\n                if(row[queries[i][1]] != -1) {\\n                    row[queries[i][1]] = -1;\\n                    ans += queries[i][2] * r;\\n                    c--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625193,
                "title": "simple-approach-c-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Approach is very Simple ,that For every Row and column. Start from last Queries , because Last value comes n times in the matrix . \\n\\nCreate two variable rowCount and ColCount,It will track the count, that How much Time need to add that value in sum. \\n\\nTo Make sure that the Final operation on any Row/column Not get lost, and not get changed,So, Can create a Visted array for both row and columns.\\n\\n# Complexity\\n- Time complexity:\\n\\nHere Time Complexity is O(m), Where m is the length of queries \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nTwo array are Created for Tracking the attemp on that particular row and column. Hence O(2n) ,Here n is the number of rows/columns\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int rwCount=n; \\n        int clCount=n; \\n        \\n        int m=queries.size();\\n        int i=m-1; \\n        \\n        vector<bool> rows(n, false); \\n        vector<bool> cols(n, false);\\n        \\n        long long int sum=0;\\n        while(i>=0 )\\n        {\\n          if(queries[i][0]==0 && rwCount!=0 && !rows[queries[i][1]]){ // that means it is Row; \\n          sum+=(queries[i][2]*rwCount);\\n              rows[queries[i][1]]=true;\\n              clCount--;\\n          }\\n          else if(queries[i][0]==1 && clCount!=0 && !cols[queries[i][1]])\\n          {\\n              cols[queries[i][1]]=true; \\n              sum+=(queries[i][2]*clCount);\\n              rwCount--;\\n          }\\n            i--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int rwCount=n; \\n        int clCount=n; \\n        \\n        int m=queries.size();\\n        int i=m-1; \\n        \\n        vector<bool> rows(n, false); \\n        vector<bool> cols(n, false);\\n        \\n        long long int sum=0;\\n        while(i>=0 )\\n        {\\n          if(queries[i][0]==0 && rwCount!=0 && !rows[queries[i][1]]){ // that means it is Row; \\n          sum+=(queries[i][2]*rwCount);\\n              rows[queries[i][1]]=true;\\n              clCount--;\\n          }\\n          else if(queries[i][0]==1 && clCount!=0 && !cols[queries[i][1]])\\n          {\\n              cols[queries[i][1]]=true; \\n              sum+=(queries[i][2]*clCount);\\n              rwCount--;\\n          }\\n            i--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624816,
                "title": "reverse-engineering-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs each query is overwriting and we are aiming at final result, its better traversing from backwards i.e from the last query to first query because whatever may be the begninnig query\\'s functionality will we focus on ultimate query\\'s impact hence move on removing each strip from the matrix and saving the sum at each step.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhenever already visited row or column is appeared we should not consider any operation as the same row/col is already overwritten completely and we donot at all bother about the previous value.\\n# Complexity\\n- Time complexity:  $O(Queries.length)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rowVisited = new HashSet<>();\\n        Set<Integer> colVisited = new HashSet<>();\\n        long sum = 0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            int[] q = queries[i];\\n            int type = q[0];\\n            int index = q[1];\\n            int val = q[2];\\n            if(type==0){\\n                if(!rowVisited.contains(index)){\\n                    sum += (n-colVisited.size())*val;\\n                    rowVisited.add(index);\\n                }\\n            }else{\\n                if(!colVisited.contains(index)){\\n                    sum += (n-rowVisited.size())*val;\\n                    colVisited.add(index);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rowVisited = new HashSet<>();\\n        Set<Integer> colVisited = new HashSet<>();\\n        long sum = 0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            int[] q = queries[i];\\n            int type = q[0];\\n            int index = q[1];\\n            int val = q[2];\\n            if(type==0){\\n                if(!rowVisited.contains(index)){\\n                    sum += (n-colVisited.size())*val;\\n                    rowVisited.add(index);\\n                }\\n            }else{\\n                if(!colVisited.contains(index)){\\n                    sum += (n-rowVisited.size())*val;\\n                    colVisited.add(index);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621675,
                "title": "backwards-mind",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust think backwards, do it like keeping wooden plank over a wooden plank. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> done(n, vector<int>(2, 0));\\n        long long ans = 0;\\n        vector<int> additionalIndexes(2, n);\\n        for(int i = queries.size() -1; i >= 0; i--){\\n            int type = queries[i][0], index = queries[i][1], value = queries[i][2];\\n            if(!done[index][type]){\\n                done[index][type] = 1;\\n                ans += value*additionalIndexes[!type];\\n                additionalIndexes[type]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> done(n, vector<int>(2, 0));\\n        long long ans = 0;\\n        vector<int> additionalIndexes(2, n);\\n        for(int i = queries.size() -1; i >= 0; i--){\\n            int type = queries[i][0], index = queries[i][1], value = queries[i][2];\\n            if(!done[index][type]){\\n                done[index][type] = 1;\\n                ans += value*additionalIndexes[!type];\\n                additionalIndexes[type]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621352,
                "title": "easy-solution-using-row-and-column-matrix-and-counter-variable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        int q_size=q.size();\\n\\n        int row=0, col=0;\\n\\n        long long sum=0;\\n\\n        vector<bool> rowArray(n,false);\\n        vector<bool> colArray(n,false);\\n\\n        for(int i=q.size()-1; i>=0; i--)\\n        {\\n\\n            int check=q[i][0];\\n            int val=q[i][2];\\n            int idx=q[i][1];\\n\\n            //row\\n            if(check==0 && rowArray[idx]==false)\\n            {\\n                rowArray[idx]=true;\\n                sum+=val*(n-col);\\n                row++;\\n            }\\n            //column\\n            else if(check==1 && colArray[idx]==false)\\n            {\\n                colArray[idx]=true;\\n                sum+=val*(n-row);\\n                col++;\\n            }   \\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        int q_size=q.size();\\n\\n        int row=0, col=0;\\n\\n        long long sum=0;\\n\\n        vector<bool> rowArray(n,false);\\n        vector<bool> colArray(n,false);\\n\\n        for(int i=q.size()-1; i>=0; i--)\\n        {\\n\\n            int check=q[i][0];\\n            int val=q[i][2];\\n            int idx=q[i][1];\\n\\n            //row\\n            if(check==0 && rowArray[idx]==false)\\n            {\\n                rowArray[idx]=true;\\n                sum+=val*(n-col);\\n                row++;\\n            }\\n            //column\\n            else if(check==1 && colArray[idx]==false)\\n            {\\n                colArray[idx]=true;\\n                sum+=val*(n-row);\\n                col++;\\n            }   \\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620886,
                "title": "c-concise-o-n-solution",
                "content": "\\nKeep track of the rows and columns being set. \\nTraverse from right to left as the right side changes will overwrite the left side changes.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) - To keep track of rows/columns already set previously.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        int row = n, col = n;\\n        vector<bool> row_visited(n, false);\\n        vector<bool> col_visited(n, false);\\n        for (vector<vector<int>>::reverse_iterator it = queries.rbegin(); it != queries.rend(); it++) {\\n            int type = (*it)[0];\\n            int index = (*it)[1];\\n            int val = (*it)[2];\\n            if (type == 0) {\\n                if (row_visited[index] == false) {\\n                    row_visited[index] = true;\\n                    sum+=(col)*val;\\n                    row--;\\n                }\\n            } else {\\n                if (col_visited[index] == false) {\\n                    col_visited[index] = true;\\n                    sum+=(row)*val;\\n                    col--;\\n                }\\n            }\\n        }\\n        return sum;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        int row = n, col = n;\\n        vector<bool> row_visited(n, false);\\n        vector<bool> col_visited(n, false);\\n        for (vector<vector<int>>::reverse_iterator it = queries.rbegin(); it != queries.rend(); it++) {\\n            int type = (*it)[0];\\n            int index = (*it)[1];\\n            int val = (*it)[2];\\n            if (type == 0) {\\n                if (row_visited[index] == false) {\\n                    row_visited[index] = true;\\n                    sum+=(col)*val;\\n                    row--;\\n                }\\n            } else {\\n                if (col_visited[index] == false) {\\n                    col_visited[index] = true;\\n                    sum+=(row)*val;\\n                    col--;\\n                }\\n            }\\n        }\\n        return sum;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619811,
                "title": "python3-solution-using-hash-set-time-and-space-optimized",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was to create a 0-filled n x n matrix and then use a nested for loop to update the rows and columns of the matrix. And thereafter loop through the rows of the matrix to find the total sum. However, I ran into TLE error as this Brute Force approach could not handle the extreme cases.\\nThen, I looked again and saw the hints provided:\\n1. Process queries in reversed order, as the latest queries represent the most recent changes in the matrix.\\n2. Once you encounter an operation on some row/column, no further operations will affect the values in this row/column. Keep track of seen rows and columns with a set.\\n3. When operating on an unseen row/column, the number of affected cells is the number of columns/rows you haven\\u2019t previously seen.\\n\\nSince the latest queries represent the most recent changes in the matrix. Now, instead of a 2D matrix, I set up two hash sets to track both the visited row and column indices and avoid changing them again. I also, set up a counter and initiated it to 0 to cumulatively compute the integer sum as I looped through the queries.\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the size of the queries\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, where n is the length of the matrix\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        visited_rows = set()\\n        visited_cols = set()\\n\\n        total_sum = 0\\n\\n        for query_type, index, value in reversed(queries):\\n\\n            if query_type == 0:\\n                if index not in visited_rows:\\n                    visited_rows.add(index)\\n                    total_sum += (n - len(visited_cols)) * value\\n            elif query_type == 1:\\n                if index not in visited_cols:\\n                    visited_cols.add(index)\\n                    total_sum += (n - len(visited_rows)) * value\\n\\n        return total_sum\\n\\n    # Time complexity: O(n), where n is the size of the queries\\n    # Space complexity: $$O(n)$$, where n is the length of the matrix\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        visited_rows = set()\\n        visited_cols = set()\\n\\n        total_sum = 0\\n\\n        for query_type, index, value in reversed(queries):\\n\\n            if query_type == 0:\\n                if index not in visited_rows:\\n                    visited_rows.add(index)\\n                    total_sum += (n - len(visited_cols)) * value\\n            elif query_type == 1:\\n                if index not in visited_cols:\\n                    visited_cols.add(index)\\n                    total_sum += (n - len(visited_rows)) * value\\n\\n        return total_sum\\n\\n    # Time complexity: O(n), where n is the size of the queries\\n    # Space complexity: $$O(n)$$, where n is the length of the matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617929,
                "title": "iterate-from-reverse-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate from reverse over queries. keep track of rows and columns(usually consider map or set) you have visited if they appear again simply ignore these queries.\\nAnd calculation for query 0 is sum += value*(n-cols.size()),\\nAnd calculation for query 1 is sum += value*(n-rows.size()),\\n\\n\\n# Complexity\\n- Time complexity:$$O(q*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(), queries.end());\\n        long long sum = 0;\\n        set<int> rows,cols;\\n        for(auto q : queries){\\n            int query = q[0];\\n            int indx = q[1];\\n            int value = q[2];\\n            \\n            if(query==0){\\n                if(rows.count(indx)) continue;\\n                sum += value*(n-cols.size());\\n                rows.insert(indx);\\n            }\\n            else{\\n                if(cols.count(indx)) continue;\\n                sum += value*(n-rows.size());\\n                cols.insert(indx);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(), queries.end());\\n        long long sum = 0;\\n        set<int> rows,cols;\\n        for(auto q : queries){\\n            int query = q[0];\\n            int indx = q[1];\\n            int value = q[2];\\n            \\n            if(query==0){\\n                if(rows.count(indx)) continue;\\n                sum += value*(n-cols.size());\\n                rows.insert(indx);\\n            }\\n            else{\\n                if(cols.count(indx)) continue;\\n                sum += value*(n-rows.size());\\n                cols.insert(indx);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617834,
                "title": "sum-of-matrix-after-queries-with-o-q-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI got this idea from \"Hint\", start taking queries from reverse so if a row/column is changed the it should not be affected in further iterations as the latest queries represent the most recent changes in the matrix\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf a whole column is changed then one element of a row is affected similarly if a row is chnaged then one element of a column is affected. So we need to keep track of how many rows and columns are affected. So everytime a whole row/column is changed it reduces one element from each column/row. We can just multiply the the number i.e queries[i][2] with the no.of rows/columns that are not not affected to get the value we need to add to the sum for each query.\\n\\n# Complexity\\n- Time complexity:$$O(q)$$\\nq -> queries.length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n\\n        long sum = 0;\\n\\n        int cols_not_affected = n, rows_not_affected = n;\\n        boolean[] cols_affected = new boolean[n], rows_affected = new boolean[n];\\n\\n        for(int i=0; i<n; ++i){\\n            cols_affected[i]=false;\\n            rows_affected[i]=false;\\n        }\\n\\n        for(int i=queries.length-1; i>-1; --i){\\n            if(queries[i][0]==0){\\n                if(!rows_affected[queries[i][1]]){\\n                    rows_affected[queries[i][1]]=true;\\n                    rows_not_affected-=1;\\n                    sum += (cols_not_affected*queries[i][2]);\\n                }\\n            } else {\\n                if(!cols_affected[queries[i][1]]){\\n                    cols_affected[queries[i][1]]=true;\\n                    cols_not_affected-=1;\\n                    sum += (rows_not_affected*queries[i][2]);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n\\n        long sum = 0;\\n\\n        int cols_not_affected = n, rows_not_affected = n;\\n        boolean[] cols_affected = new boolean[n], rows_affected = new boolean[n];\\n\\n        for(int i=0; i<n; ++i){\\n            cols_affected[i]=false;\\n            rows_affected[i]=false;\\n        }\\n\\n        for(int i=queries.length-1; i>-1; --i){\\n            if(queries[i][0]==0){\\n                if(!rows_affected[queries[i][1]]){\\n                    rows_affected[queries[i][1]]=true;\\n                    rows_not_affected-=1;\\n                    sum += (cols_not_affected*queries[i][2]);\\n                }\\n            } else {\\n                if(!cols_affected[queries[i][1]]){\\n                    cols_affected[queries[i][1]]=true;\\n                    cols_not_affected-=1;\\n                    sum += (rows_not_affected*queries[i][2]);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617733,
                "title": "ruby",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer} n\\n# @param {Integer[][]} queries\\n# @return {Integer}\\ndef matrix_sum_queries(n, queries)  \\n  sum = 0  \\n  row_count = 0 \\n  col_count = 0 \\n  length = queries.length\\n  row_seen = Array.new(n)\\n  col_seen = Array.new(n)\\n  \\n  for i in ((length-1).downto(0)) do \\n    query = queries[i]\\n\\n    if query[0] == 0 and !row_seen[query[1]]\\n        row_count += 1\\n        sum += (n-col_count)*query[2]\\n        row_seen[query[1]] = true \\n    elsif query[0] == 1 and !col_seen[query[1]]\\n        col_count += 1\\n        sum += (n-row_count)*query[2]\\n        col_seen[query[1]] = true \\n    end \\n\\n  end \\n  \\n  sum \\n  \\nend \\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @param {Integer[][]} queries\\n# @return {Integer}\\ndef matrix_sum_queries(n, queries)  \\n  sum = 0  \\n  row_count = 0 \\n  col_count = 0 \\n  length = queries.length\\n  row_seen = Array.new(n)\\n  col_seen = Array.new(n)\\n  \\n  for i in ((length-1).downto(0)) do \\n    query = queries[i]\\n\\n    if query[0] == 0 and !row_seen[query[1]]\\n        row_count += 1\\n        sum += (n-col_count)*query[2]\\n        row_seen[query[1]] = true \\n    elsif query[0] == 1 and !col_seen[query[1]]\\n        col_count += 1\\n        sum += (n-row_count)*query[2]\\n        col_seen[query[1]] = true \\n    end \\n\\n  end \\n  \\n  sum \\n  \\nend \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3617554,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlast query overwrites everything.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate from the last query and reduce the number of rows and columns which can be later considered in the sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> row(n,-1);\\n        vector<int> col(n,-1);\\n        int r = n,c = n;\\n        for(int i = queries.size()-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int rc = queries[i][1];\\n            int val = queries[i][2];\\n            if(type == 0){\\n                if(row[rc] == -1){\\n                    ans+=(c*val);\\n                    row[rc] = 1;\\n                    r--;\\n                }\\n            }\\n            else{\\n                if(col[rc] == -1){\\n                    ans+=(r*val);\\n                    col[rc] = 1;\\n                    c--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> row(n,-1);\\n        vector<int> col(n,-1);\\n        int r = n,c = n;\\n        for(int i = queries.size()-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int rc = queries[i][1];\\n            int val = queries[i][2];\\n            if(type == 0){\\n                if(row[rc] == -1){\\n                    ans+=(c*val);\\n                    row[rc] = 1;\\n                    r--;\\n                }\\n            }\\n            else{\\n                if(col[rc] == -1){\\n                    ans+=(r*val);\\n                    col[rc] = 1;\\n                    c--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616789,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def matrixSumQueries(n: Int, queries: Array[Array[Int]]): Long = {\\n    val rowSeen = Array.fill(n)(false)\\n    val colSeen = Array.fill(n)(false)\\n    queries.foldRight(0L, 0, 0)((cur, acc) => {\\n      val ty = cur(0)\\n      val id = cur(1)\\n      val value = cur(2)\\n      if(ty == 0 && !rowSeen(id)){\\n        rowSeen(id) = true\\n        (acc._1 + (n - acc._3) * value, acc._2 + 1, acc._3)\\n      } else if(ty == 1 && !colSeen(id)){\\n        colSeen(id) = true\\n        (acc._1 + (n - acc._2) * value, acc._2, acc._3 + 1)\\n      } else acc\\n    })._1\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def matrixSumQueries(n: Int, queries: Array[Array[Int]]): Long = {\\n    val rowSeen = Array.fill(n)(false)\\n    val colSeen = Array.fill(n)(false)\\n    queries.foldRight(0L, 0, 0)((cur, acc) => {\\n      val ty = cur(0)\\n      val id = cur(1)\\n      val value = cur(2)\\n      if(ty == 0 && !rowSeen(id)){\\n        rowSeen(id) = true\\n        (acc._1 + (n - acc._3) * value, acc._2 + 1, acc._3)\\n      } else if(ty == 1 && !colSeen(id)){\\n        colSeen(id) = true\\n        (acc._1 + (n - acc._2) * value, acc._2, acc._3 + 1)\\n      } else acc\\n    })._1\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3616014,
                "title": "interesting-problem-java-100-runtime-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReading description, didnt noticed about queries will always override latest value.\\nAfter multiple submissions, by reading tip mentioned in discussions would have helped me to resolve.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nQueries will always override with latest value.\\nBetter start from reverse, no need to override, keep track of visited rows and columns.\\nAdd them into sum and make sure you will not add values which are already added as a part of previous visits. Below one statement is most important to consider.\\n`sum += (val * (n-colsVisited));`\\n\\n# Complexity\\n- Time complexity: O(k) - k queries\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) - visited rows/cols & O(1) for sum\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        boolean[] visitedRows = new boolean[n];\\n        boolean[] visitedCols = new boolean[n];\\n        long sum =0;\\n\\n        int rowsVisited = 0;\\n        int colsVisited = 0;\\n\\n        for(int i=queries.length-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int j = queries[i][1];\\n            int val = queries[i][2];\\n\\n            if(type==0 && !visitedRows[j]){\\n                rowsVisited++;\\n                sum += (val * (n-colsVisited));\\n                visitedRows[j] = true;\\n            }else if(type==1 && !visitedCols[j]){\\n                colsVisited++;\\n                sum += (val* (n-rowsVisited));\\n                visitedCols[j] = true;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        boolean[] visitedRows = new boolean[n];\\n        boolean[] visitedCols = new boolean[n];\\n        long sum =0;\\n\\n        int rowsVisited = 0;\\n        int colsVisited = 0;\\n\\n        for(int i=queries.length-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int j = queries[i][1];\\n            int val = queries[i][2];\\n\\n            if(type==0 && !visitedRows[j]){\\n                rowsVisited++;\\n                sum += (val * (n-colsVisited));\\n                visitedRows[j] = true;\\n            }else if(type==1 && !visitedCols[j]){\\n                colsVisited++;\\n                sum += (val* (n-rowsVisited));\\n                visitedCols[j] = true;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615906,
                "title": "easy-java-solution-o-n",
                "content": "\\n# Complexity\\n- Time complexity: O( k )  [ where k = queries.length ]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n        long row = (long)n;\\n        long colm = (long)n;\\n        HashSet<Integer> rSet = new HashSet<>();\\n        HashSet<Integer> cSet = new HashSet<>();\\n        long ans = 0l;\\n\\n        for(int i=queries.length-1; i>=0; i--){\\n\\n            if(queries[i][0] == 1){\\n                if(!cSet.contains(queries[i][1])){\\n                    ans += row*((long)queries[i][2]);\\n                    colm--;\\n                    cSet.add(queries[i][1]);\\n                }\\n            }\\n            else{\\n                if(!rSet.contains(queries[i][1])){\\n                    ans += colm*((long)queries[i][2]);\\n                    row--;\\n                    rSet.add(queries[i][1]);\\n                }\\n            }\\n            \\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n        long row = (long)n;\\n        long colm = (long)n;\\n        HashSet<Integer> rSet = new HashSet<>();\\n        HashSet<Integer> cSet = new HashSet<>();\\n        long ans = 0l;\\n\\n        for(int i=queries.length-1; i>=0; i--){\\n\\n            if(queries[i][0] == 1){\\n                if(!cSet.contains(queries[i][1])){\\n                    ans += row*((long)queries[i][2]);\\n                    colm--;\\n                    cSet.add(queries[i][1]);\\n                }\\n            }\\n            else{\\n                if(!rSet.contains(queries[i][1])){\\n                    ans += colm*((long)queries[i][2]);\\n                    row--;\\n                    rSet.add(queries[i][1]);\\n                }\\n            }\\n            \\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615649,
                "title": "swift-track-visited-axes",
                "content": "**Track Visited Axes (accepted answer)**\\n```\\nclass Solution {\\n    func matrixSumQueries(_ n: Int, _ queries: [[Int]]) -> Int {\\n        var result = 0\\n        var visited = Array(repeating: [false,false], count: n)\\n        var unvisited = [n,n]\\n        for q in queries.reversed() where !visited[q[1]][q[0]] {\\n            let (axis, i) = (q[0], q[1])\\n            visited[i][axis] = true\\n            result += q[2] * unvisited[axis ^ 1]\\n            unvisited[axis] -= 1\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func matrixSumQueries(_ n: Int, _ queries: [[Int]]) -> Int {\\n        var result = 0\\n        var visited = Array(repeating: [false,false], count: n)\\n        var unvisited = [n,n]\\n        for q in queries.reversed() where !visited[q[1]][q[0]] {\\n            let (axis, i) = (q[0], q[1])\\n            visited[i][axis] = true\\n            result += q[2] * unvisited[axis ^ 1]\\n            unvisited[axis] -= 1\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615424,
                "title": "java-5ms-100-and-clean-code",
                "content": "# Approach\\n1. As queries have priority, it makes sense to process the queries in reverse order.\\n2. Use a 2 x boolean[n] to keep track of what rows or cold have been queried.\\n    - Also count how many rows / cols have been queried\\n3. When processing a query, select the query type: row or col. If it has not been process (boolean[]), mark and process it\\n4. If a whole column get set a certain value, do you multiply n by value?\\n    - No, as certain rows from that column might have been already pre-processed\\n    - EG: n = 10, \\n    - last query : col 4 value 5. => this means sum += 5 * 10 (10 rows)\\n    - query -1: row 3 value 7= > we can\\'t add 10 * 7 (70) to sum because on previous query we have updated column 4, which already overrode row 3. Thus, we can only add 7 * 9 to sum (63).\\n    - With each query, count the edited number of rows/cols as each modification will only have partial benefit (diminishing returns)\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long sum = 0L;\\n        boolean[] modifiedRows = new boolean[n];\\n        boolean[] modifiedCols = new boolean[n];\\n        int touchedRows = 0, touchedCols = 0;\\n        int[] query;\\n        for (int i = queries.length -1; i >= 0; i--) {\\n            query = queries[i];\\n            if (query[0] == 0) {\\n                if (!modifiedRows[query[1]]) {\\n                    modifiedRows[query[1]] = true;\\n                    touchedRows++;\\n                    sum += ((long)query[2] * (n - touchedCols));\\n                }\\n            } else if (!modifiedCols[query[1]]) {\\n                modifiedCols[query[1]] = true;\\n                touchedCols++;\\n                sum += ((long)query[2] * (n - touchedRows));\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long sum = 0L;\\n        boolean[] modifiedRows = new boolean[n];\\n        boolean[] modifiedCols = new boolean[n];\\n        int touchedRows = 0, touchedCols = 0;\\n        int[] query;\\n        for (int i = queries.length -1; i >= 0; i--) {\\n            query = queries[i];\\n            if (query[0] == 0) {\\n                if (!modifiedRows[query[1]]) {\\n                    modifiedRows[query[1]] = true;\\n                    touchedRows++;\\n                    sum += ((long)query[2] * (n - touchedCols));\\n                }\\n            } else if (!modifiedCols[query[1]]) {\\n                modifiedCols[query[1]] = true;\\n                touchedCols++;\\n                sum += ((long)query[2] * (n - touchedRows));\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615211,
                "title": "two-hashset-o-queries-length-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.The last query win the battle, map them in the HashSet.\\n2.Every count how many visited spaces in the column/row by the size of row/column\\n3.Add value* count to the answer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(queries.length)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**0(2*n)**\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rowM = new HashSet<>();\\n        Set<Integer> colM = new HashSet<>();\\n        long ans =0;\\n        for(int i=queries.length-1; i>=0; i--){\\n            int[] q = queries[i];\\n            int count =0;\\n            if(q[0] ==0){\\n                if(rowM.contains(q[1])) continue;\\n                count = n-colM.size();\\n                rowM.add(q[1]);\\n            }else{\\n                if(colM.contains(q[1]))continue;\\n                count = n- rowM.size();\\n                colM.add(q[1]);\\n            }\\n            ans += count*q[2];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rowM = new HashSet<>();\\n        Set<Integer> colM = new HashSet<>();\\n        long ans =0;\\n        for(int i=queries.length-1; i>=0; i--){\\n            int[] q = queries[i];\\n            int count =0;\\n            if(q[0] ==0){\\n                if(rowM.contains(q[1])) continue;\\n                count = n-colM.size();\\n                rowM.add(q[1]);\\n            }else{\\n                if(colM.contains(q[1]))continue;\\n                count = n- rowM.size();\\n                colM.add(q[1]);\\n            }\\n            ans += count*q[2];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614946,
                "title": "easy-java-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int[] row = new int[n];\\n        int[] col = new int[n];\\n        int num_row = n, num_col = n;\\n        long sum = 0;\\n        for(int i=queries.length-1;i>=0;i--) {\\n            if(queries[i][0] == 0) \\n            {\\n                if(row[queries[i][1]] == 0) \\n                {\\n                    row[queries[i][1]] = 1;\\n                    num_row--;\\n                    sum += queries[i][2]*num_col;\\n                    \\n                }\\n            }\\n            else \\n            {\\n                if(col[queries[i][1]] == 0) \\n                {\\n                    col[queries[i][1]] = 1;\\n                    num_col--;\\n                    sum += queries[i][2]*num_row;\\n                    \\n                }\\n            }\\n            if(num_row == 0 || num_col == 0) return sum;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int[] row = new int[n];\\n        int[] col = new int[n];\\n        int num_row = n, num_col = n;\\n        long sum = 0;\\n        for(int i=queries.length-1;i>=0;i--) {\\n            if(queries[i][0] == 0) \\n            {\\n                if(row[queries[i][1]] == 0) \\n                {\\n                    row[queries[i][1]] = 1;\\n                    num_row--;\\n                    sum += queries[i][2]*num_col;\\n                    \\n                }\\n            }\\n            else \\n            {\\n                if(col[queries[i][1]] == 0) \\n                {\\n                    col[queries[i][1]] = 1;\\n                    num_col--;\\n                    sum += queries[i][2]*num_row;\\n                    \\n                }\\n            }\\n            if(num_row == 0 || num_col == 0) return sum;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611008,
                "title": "python3-two-sets-and-backwards",
                "content": "# Intuition\\na query will only add values if\\n1. there is no query who at the same row/col\\n2. n - col_covered if it\\'s a row, or n - row_covered if it\\'s a col\\n\\n# Approach\\ntwo sets to record how many col/row are covered\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, Q: List[List[int]]) -> int:\\n        res = 0\\n        seens = [set() for _ in range(2)]\\n        for m, i, v in Q[::-1]:\\n            if i not in seens[m]:\\n                res += v * (n - len(seens[1 - m]))\\n            seens[m].add(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, Q: List[List[int]]) -> int:\\n        res = 0\\n        seens = [set() for _ in range(2)]\\n        for m, i, v in Q[::-1]:\\n            if i not in seens[m]:\\n                res += v * (n - len(seens[1 - m]))\\n            seens[m].add(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609002,
                "title": "very-easy-and-simple-solution-o-n-explained",
                "content": "**Approach:  Last wale ka prabhav sb me dikhega to kyu na hm last se shuru kre!**\\n\\n*\\u2B50\\u2714simply calculate the sum of values in a matrix by processing the queries in reverse order and keeping track of visited rows and columns. The unvisited rows or columns are multiplied by the respective query value and added to the final answer\\u2B50.* \\n\\nLet\\'s break down the approach:\\n\\nInitialize two vectors, visCol and visRow, of size n with all elements set to 0. These vectors are used to keep track of visited columns and rows.\\n\\nInitialize variables NoOfRowsOperated and NoOfColOperated to 0. These variables count the number of rows and columns operated on.\\n\\nInitialize the variable ans to 0. This variable stores the final sum of values in the matrix.\\n\\nIterate through the queries in reverse order (from the last query to the first).\\n\\nFor each query, extract the query type (t), the index (ind), and the value (val).\\n\\nIf the query type is 0, check if the row at index ind has not been visited (visRow[ind] == 0). If it hasn\\'t been visited, update the answer (ans) by adding the product of val and the number of unvisited columns (n - NoOfColOperated). Increment NoOfRowsOperated and mark the row as visited (visRow[ind] = 1).\\n\\nIf the query type is 1, perform a similar operation for the column at index ind. Check if it has not been visited (visCol[ind] == 0), update the answer (ans) by adding the product of val and the number of unvisited rows (n - NoOfRowsOperated). Increment NoOfColOperated and mark the column as visited (visCol[ind] = 1).\\n\\nAfter processing all the queries, return the final answer (ans), which represents the sum of values in the matrix based on the given queries.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(long long n, vector<vector<int>>& q) {\\n        vector<int>visCol(n,0); \\n        vector<int>visRow(n,0);\\n        long long NoOfRowsOperated=0,NoOfColOperated=0;\\n        long long ans=0;\\n        for(int i=q.size()-1;i>=0;i--){\\n            int t=q[i][0];\\n            int ind=q[i][1];\\n            long long val=q[i][2];\\n            if(t==0){\\n               if(!visRow[ind]) {\\n                   ans+=val*(n-NoOfColOperated);\\n                   NoOfRowsOperated++;\\n                   visRow[ind]=1;\\n                   \\n               }\\n            }\\n            else{\\n                if(!visCol[ind]) {\\n                   ans+=val*(n-NoOfRowsOperated);\\n                    NoOfColOperated++;\\n                    visCol[ind]=1;\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(long long n, vector<vector<int>>& q) {\\n        vector<int>visCol(n,0); \\n        vector<int>visRow(n,0);\\n        long long NoOfRowsOperated=0,NoOfColOperated=0;\\n        long long ans=0;\\n        for(int i=q.size()-1;i>=0;i--){\\n            int t=q[i][0];\\n            int ind=q[i][1];\\n            long long val=q[i][2];\\n            if(t==0){\\n               if(!visRow[ind]) {\\n                   ans+=val*(n-NoOfColOperated);\\n                   NoOfRowsOperated++;\\n                   visRow[ind]=1;\\n                   \\n               }\\n            }\\n            else{\\n                if(!visCol[ind]) {\\n                   ans+=val*(n-NoOfRowsOperated);\\n                    NoOfColOperated++;\\n                    visCol[ind]=1;\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608496,
                "title": "java-easy-to-understand-reverse-iteration",
                "content": "The optimal solution involves traversing the given queries in reverse order. This is done so that we dont have to go through the trouble of subtracting the values which are overwritten.\\nHere, we directly start of with the max possible occurences of any element, given the number of rows and column which are still left to be occupied.\\n\\n# Complexity\\n- Time complexity: O(m), m being the number of queries\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int r = n;\\n        int c = n;\\n        int m = queries.length;\\n        Set<Integer> visitedRows = new HashSet<>();\\n        Set<Integer> visitedCols = new HashSet<>();\\n        long sum = 0;\\n        for(int i = m-1; i>=0; i--)\\n        {\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            if(queries[i][0] == 0 && !visitedRows.contains(index))\\n            {\\n                sum += (long)c*queries[i][2];\\n                visitedRows.add(index);\\n                r--;\\n            }\\n            else if(queries[i][0] == 1 && !visitedCols.contains(index))\\n            {\\n                sum += (long)r*queries[i][2];\\n                visitedCols.add(index);\\n                c--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int r = n;\\n        int c = n;\\n        int m = queries.length;\\n        Set<Integer> visitedRows = new HashSet<>();\\n        Set<Integer> visitedCols = new HashSet<>();\\n        long sum = 0;\\n        for(int i = m-1; i>=0; i--)\\n        {\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            if(queries[i][0] == 0 && !visitedRows.contains(index))\\n            {\\n                sum += (long)c*queries[i][2];\\n                visitedRows.add(index);\\n                r--;\\n            }\\n            else if(queries[i][0] == 1 && !visitedCols.contains(index))\\n            {\\n                sum += (long)r*queries[i][2];\\n                visitedCols.add(index);\\n                c--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607840,
                "title": "beats-100-java-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int seenColCount = 0;\\n        int seenRowCount = 0;\\n        long sum = 0;\\n\\n        boolean[] rowSeen = new boolean[n];\\n        boolean[] colSeen = new boolean[n];\\n\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n\\n            if (type == 0 && !rowSeen[index]) {\\n                seenRowCount++;\\n                rowSeen[index] = true;\\n                sum += (n - seenColCount) * value;\\n            } else if (type == 1 && !colSeen[index]) {\\n                seenColCount++;\\n                colSeen[index] = true;\\n                sum += (n - seenRowCount) * value;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int seenColCount = 0;\\n        int seenRowCount = 0;\\n        long sum = 0;\\n\\n        boolean[] rowSeen = new boolean[n];\\n        boolean[] colSeen = new boolean[n];\\n\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n\\n            if (type == 0 && !rowSeen[index]) {\\n                seenRowCount++;\\n                rowSeen[index] = true;\\n                sum += (n - seenColCount) * value;\\n            } else if (type == 1 && !colSeen[index]) {\\n                seenColCount++;\\n                colSeen[index] = true;\\n                sum += (n - seenRowCount) * value;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607459,
                "title": "simple-c-solution",
                "content": "\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long res=0;\\n        int c=n,r=n;\\n        map<int,int> col,row;\\n        for(int i=queries.size()-1;i>=0;i--){\\n            int type=queries[i][0],ind=queries[i][1],val=queries[i][2];\\n            if(type==0 && row[ind]!=1){\\n              row[ind]=1;\\n              res+=(c*val);  \\n              r--;  \\n            }\\n            else if(type==1 && col[ind]!=1){\\n              col[ind]=1;\\n              res+=(r*val);   \\n              c--;  \\n            }\\n        }\\n      \\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long res=0;\\n        int c=n,r=n;\\n        map<int,int> col,row;\\n        for(int i=queries.size()-1;i>=0;i--){\\n            int type=queries[i][0],ind=queries[i][1],val=queries[i][2];\\n            if(type==0 && row[ind]!=1){\\n              row[ind]=1;\\n              res+=(c*val);  \\n              r--;  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3607345,
                "title": "python-o-n-time-complexity-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnly the last query of the rows or columns will affect the matrix sum. Therefore, we will process the queries backward and skip the seen rows and columns.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will process the queries backward, for each query, we will increase the sum by val * (n - number of seen row/column). If we are working on row, we subtract the no. of seen column, and vice versa. The intuition behind subtracting number of seen row/column is that the later operation will overwrite the previous value, the later query\\'s value (which we will process first) have the priority in the returned sum.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, n is the queries\\' length here.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$, m is the matrix\\'s length.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen = set()\\n        row_cnt, col_cnt = 0, 0\\n        res = 0\\n        \\n        for t, i, val in queries[::-1]:\\n            if (t, i) not in seen:\\n                if t == 0:\\n                    row_cnt += 1\\n                    res += val * (n - col_cnt)\\n                else:\\n                    col_cnt += 1\\n                    res += val * (n - row_cnt)\\n                \\n                seen.add((t, i))\\n        \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen = set()\\n        row_cnt, col_cnt = 0, 0\\n        res = 0\\n        \\n        for t, i, val in queries[::-1]:\\n            if (t, i) not in seen:\\n                if t == 0:\\n                    row_cnt += 1\\n                    res += val * (n - col_cnt)\\n                else:\\n                    col_cnt += 1\\n                    res += val * (n - row_cnt)\\n                \\n                seen.add((t, i))\\n        \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607335,
                "title": "c-think-in-reverse",
                "content": "# Intuition\\nLast operation values will be n..\\n\\n# Approach\\nKeep track of the filled number of rows and columns and also visited rows and columns.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& qu) {\\n        long long int ans = 0;\\n        int q = qu.size();\\n        vector<vector<int>> vis (2 , vector<int>(n , 0));\\n        int cn[2];\\n        cn[0] = 0 , cn[1] = 0;//cn[0] stores the filled number of rows , cn[1] stores columns filled. \\n        for(int i = q - 1; i >= 0; i--)\\n        {\\n            int ty = qu[i][0] , in = qu[i][1] , val = qu[i][2];\\n           \\n                if(vis[ty][in] == 0)\\n                {\\n                    ans += (val) * (n - (cn[ty ^ 1]));\\n                    vis[ty][in]++;\\n                    cn[ty]++;\\n                }\\n            \\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& qu) {\\n        long long int ans = 0;\\n        int q = qu.size();\\n        vector<vector<int>> vis (2 , vector<int>(n , 0));\\n        int cn[2];\\n        cn[0] = 0 , cn[1] = 0;//cn[0] stores the filled number of rows , cn[1] stores columns filled. \\n        for(int i = q - 1; i >= 0; i--)\\n        {\\n            int ty = qu[i][0] , in = qu[i][1] , val = qu[i][2];\\n           \\n                if(vis[ty][in] == 0)\\n                {\\n                    ans += (val) * (n - (cn[ty ^ 1]));\\n                    vis[ty][in]++;\\n                    cn[ty]++;\\n                }\\n            \\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606594,
                "title": "c-traverse-from-the-last-query-and-maintain-unordered-set-for-rows-and-column",
                "content": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_set<int> rows;\\n        unordered_set<int> cols;\\n        \\n        long long ans =0;\\n        int type=0,index=0,val=0;\\n        for (int i=queries.size()-1;i>=0;i--){\\n            type = queries[i][0];\\n            index = queries[i][1];\\n            val = queries[i][2];\\n            if (type==0){\\n                if (rows.find(index)==rows.end()){\\n                    ans += val * (n-cols.size());\\n                    rows.insert(index);\\n                }\\n            }\\n            else{\\n                if (cols.find(index)==cols.end()){\\n                    ans += val * (n-rows.size());\\n                    cols.insert(index);\\n                }\\n            }\\n        }\\n        return ans;\\n         \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_set<int> rows;\\n        unordered_set<int> cols;\\n        \\n        long long ans =0;\\n        int type=0,index=0,val=0;\\n        for (int i=queries.size()-1;i>=0;i--){\\n            type = queries[i][0];\\n            index = queries[i][1];\\n            val = queries[i][2];\\n            if (type==0){\\n                if (rows.find(index)==rows.end()){\\n                    ans += val * (n-cols.size());\\n                    rows.insert(index);\\n                }\\n            }\\n            else{\\n                if (cols.find(index)==cols.end()){\\n                    ans += val * (n-rows.size());\\n                    cols.insert(index);\\n                }\\n            }\\n        }\\n        return ans;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606455,
                "title": "python-o-q-count-opposite-types",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince a later query will overwrite any previous values in the matrix, we need to consider queries in reverse order.\\n\\nNotice that if a later query writes to a row, then any earlier query that writes to a column contributes one less value to the final matrix.\\n\\nSpecifically, an earlier query of a [row | column] will contribute `(n - k) * val` to the total, where `k` is the number of later queries (of opposite type) that write to distinct [columns | rows].\\n\\nSince every query writes to the whole row or column, we dont need to care about _where_ the missing values are, but only _how many_ there are.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep a count of the number of missing query types, `missing`. At first, there will be `n` values missing in every row and `n` values missing in every column.\\n\\nKeep a set of distinct query types, `seen` to know when a later query type has written to a specific row or column.\\n\\n- For each query type not yet seen:\\n    - Mark the query type as seen.\\n    - Add the number of missing values of that type to the total.\\n    - Decrement the number of missing values for the current type.\\n\\n# Complexity\\n- Time complexity:  $$ O(q) $$, where $$ q $$ is number of queries.\\n    - Must check at least $$ n + n $$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(n) $$\\n    - Store at most $$ n + n $$ query types in `seen`.\\n    - Store count of missing rows and columns.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```py\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen = set()\\n        missing = [n, n]\\n        total = 0\\n        \\n        for i in range(len(queries) - 1, -1, -1):\\n            typ, ind, val = queries[i]\\n            if (typ, ind) not in seen:\\n                seen.add((typ, ind))\\n                total += val * missing[typ]\\n                missing[typ ^ 1] -= 1\\n        \\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen = set()\\n        missing = [n, n]\\n        total = 0\\n        \\n        for i in range(len(queries) - 1, -1, -1):\\n            typ, ind, val = queries[i]\\n            if (typ, ind) not in seen:\\n                seen.add((typ, ind))\\n                total += val * missing[typ]\\n                missing[typ ^ 1] -= 1\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605625,
                "title": "c-solution-using-unordered-sets",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_set<int>rows;\\n        unordered_set<int>cols;\\n        int q_rows = queries.size();\\n        long long sum=0;\\n        for(int i=q_rows-1; i>=0; i--){\\n            if(queries[i][0]==0 && rows.find(queries[i][1])==rows.end()){\\n                sum+=queries[i][2]*(n-cols.size());\\n                rows.insert(queries[i][1]);\\n            }\\n            else if(queries[i][0]==1 && cols.find(queries[i][1])==cols.end()){\\n                sum+=queries[i][2]*(n-rows.size());\\n                cols.insert(queries[i][1]);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_set<int>rows;\\n        unordered_set<int>cols;\\n        int q_rows = queries.size();\\n        long long sum=0;\\n        for(int i=q_rows-1; i>=0; i--){\\n            if(queries[i][0]==0 && rows.find(queries[i][1])==rows.end()){\\n                sum+=queries[i][2]*(n-cols.size());\\n                rows.insert(queries[i][1]);\\n            }\\n            else if(queries[i][0]==1 && cols.find(queries[i][1])==cols.end()){\\n                sum+=queries[i][2]*(n-rows.size());\\n                cols.insert(queries[i][1]);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605424,
                "title": "python3-o-n-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        row_counter, col_counter = 0, 0\\n        seen_row, seen_col = set(), set()\\n        res = 0\\n        for type_i, index_i, val_i in queries[::-1]:\\n            if type_i == 0:\\n                if index_i not in seen_row:\\n                    seen_row.add(index_i)\\n                    res += (val_i * (n - col_counter))\\n                    row_counter += 1\\n            else:\\n                if index_i not in seen_col:\\n                    seen_col.add(index_i)\\n                    res += (val_i * (n - row_counter))\\n                    col_counter += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        row_counter, col_counter = 0, 0\\n        seen_row, seen_col = set(), set()\\n        res = 0\\n        for type_i, index_i, val_i in queries[::-1]:\\n            if type_i == 0:\\n                if index_i not in seen_row:\\n                    seen_row.add(index_i)\\n                    res += (val_i * (n - col_counter))\\n                    row_counter += 1\\n            else:\\n                if index_i not in seen_col:\\n                    seen_col.add(index_i)\\n                    res += (val_i * (n - row_counter))\\n                    col_counter += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605347,
                "title": "javascript-typescript-go-backwards-track-only-top-cols-and-rows",
                "content": "# Intuition\\nimagine each row and column as a strip of paper\\nnow lay them all down, one on top of the other until the matrix is full.\\n\\nthe sum is the visible numbers \\nHowever, actually building it this way takes too long.\\n\\nso instead, start from the end. Lay down rows and columns in reverse because the end ones are the ones going to be on top.\\n\\nIf you are laying down a row, it must go \\'under\\' the previously laid columns so we must subtract their values as they will cover up those indexes of the row.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (queries length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO (n ** 2)\\n\\n# Code\\n```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n\\n    let sum: number = 0\\n    let rowSeen: Set<number> = new Set()\\n    let colSeen: Set<number> = new Set()\\n\\n    for (const [type, index, val] of queries.reverse()) {\\n        // row\\n        if (type === 0 && !rowSeen.has(index)) {\\n            rowSeen.add(index)\\n            sum += n * val - colSeen.size * val\\n        }\\n\\n        // col\\n        if (type === 1 && !colSeen.has(index)) {\\n            colSeen.add(index)\\n            sum += n * val - rowSeen.size * val\\n        }\\n    }\\n\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n\\n    let sum: number = 0\\n    let rowSeen: Set<number> = new Set()\\n    let colSeen: Set<number> = new Set()\\n\\n    for (const [type, index, val] of queries.reverse()) {\\n        // row\\n        if (type === 0 && !rowSeen.has(index)) {\\n            rowSeen.add(index)\\n            sum += n * val - colSeen.size * val\\n        }\\n\\n        // col\\n        if (type === 1 && !colSeen.has(index)) {\\n            colSeen.add(index)\\n            sum += n * val - rowSeen.size * val\\n        }\\n    }\\n\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605062,
                "title": "easy-o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        int m = queries.size();\\n        long long rowCnt = n;\\n        long long colCnt = n;\\n        unordered_set<int> visRow;//For visited rows\\n        unordered_set<int> visCol;//For visited cols\\n\\n        for(int i=m-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            long long val = queries[i][2];\\n\\n            if(type==0 and visRow.count(index)==0){//To change the Rows\\n                sum += val * colCnt;\\n                rowCnt--;//Decreasing row count\\n                visRow.insert(index);//Marked as visited row index\\n            }\\n            else if(type==1 and visCol.count(index)==0){//To change the Cols\\n                sum += val * rowCnt;\\n                colCnt--;//Decreasing col count\\n                visCol.insert(index);//Marked as visited col index\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        int m = queries.size();\\n        long long rowCnt = n;\\n        long long colCnt = n;\\n        unordered_set<int> visRow;//For visited rows\\n        unordered_set<int> visCol;//For visited cols\\n\\n        for(int i=m-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            long long val = queries[i][2];\\n\\n            if(type==0 and visRow.count(index)==0){//To change the Rows\\n                sum += val * colCnt;\\n                rowCnt--;//Decreasing row count\\n                visRow.insert(index);//Marked as visited row index\\n            }\\n            else if(type==1 and visCol.count(index)==0){//To change the Cols\\n                sum += val * rowCnt;\\n                colCnt--;//Decreasing col count\\n                visCol.insert(index);//Marked as visited col index\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604587,
                "title": "my-c-solution",
                "content": "# Intuition\\nMain thing to observe here is that **traversing from right to left is optimal** because last time val is overwritten, we\\'ll be considering that val.\\n\\nI have taken two visited arr (row and col) as we are traversing from right to left if particular row or col is already considered then no need to overwrite the value with val, continue the iteration, else overwrite the values with val and mark that ind(row or col) true.\\n\\nI have also taken rowCount and colCount to optimize the solution(to get rid of extra O(n) time complexity) we know, for any row if we are overwriting the values we have to check for colCount if it is not zero then we can\\'t add that particular cell values because we already add it in our answer previously(as we are moving from right to left and last values are to be considered at last).\\n\\nfor given row, our sum will be = val + val + ....n times ==> n*val;\\nbut if colCount is not zero means we cannot add colCount number of cells in our sum, sum = (n-colCount)*val.\\n\\nsame goes for every col.\\n\\n# Complexity\\n- Time complexity:O(queries.size()) => O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        vector<bool> row(n, false);\\n        vector<bool> col(n, false);\\n        int rowCount = 0;\\n        int colCount = 0;\\n        \\n        // traversing from right to left\\n        for(int i = queries.size()-1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int ind = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            // row\\n            if(type == 0) {\\n                // check if for this row values are already considered in our sum because we only want last overwritten values and as we are going from right to left we have already taken into account.\\n                if(!row[ind]) {\\n                    // increase row count to further avoid considering values which were already considered.\\n                    rowCount++;\\n                    row[ind] = true;\\n                    sum += (n-colCount)*val;\\n                }\\n            // column\\n            } else {\\n                if(!col[ind]) {\\n                    colCount++;\\n                    col[ind] = true;\\n                    sum += (n-rowCount)*val;\\n                }\\n            }\\n            \\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        vector<bool> row(n, false);\\n        vector<bool> col(n, false);\\n        int rowCount = 0;\\n        int colCount = 0;\\n        \\n        // traversing from right to left\\n        for(int i = queries.size()-1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int ind = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            // row\\n            if(type == 0) {\\n                // check if for this row values are already considered in our sum because we only want last overwritten values and as we are going from right to left we have already taken into account.\\n                if(!row[ind]) {\\n                    // increase row count to further avoid considering values which were already considered.\\n                    rowCount++;\\n                    row[ind] = true;\\n                    sum += (n-colCount)*val;\\n                }\\n            // column\\n            } else {\\n                if(!col[ind]) {\\n                    colCount++;\\n                    col[ind] = true;\\n                    sum += (n-rowCount)*val;\\n                }\\n            }\\n            \\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603989,
                "title": "easy-to-understand-python-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0\\n        rows = set()\\n        cols = set()\\n        rowsNum = n\\n        colsNum = n\\n\\n        while rows != [] or cols != []:\\n\\n            if queries:\\n                que = queries.pop()\\n                t = que[0]\\n                index = que[1]\\n                val = que[2]\\n                if t == 0 and index not in rows:\\n                    ans += colsNum * val\\n                    rows.add(index)\\n                    rowsNum -= 1\\n                elif t == 1 and index not in cols:\\n                    ans += rowsNum * val\\n                    cols.add(index)\\n                    colsNum -= 1\\n            else:\\n                break\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0\\n        rows = set()\\n        cols = set()\\n        rowsNum = n\\n        colsNum = n\\n\\n        while rows != [] or cols != []:\\n\\n            if queries:\\n                que = queries.pop()\\n                t = que[0]\\n                index = que[1]\\n                val = que[2]\\n                if t == 0 and index not in rows:\\n                    ans += colsNum * val\\n                    rows.add(index)\\n                    rowsNum -= 1\\n                elif t == 1 and index not in cols:\\n                    ans += rowsNum * val\\n                    cols.add(index)\\n                    colsNum -= 1\\n            else:\\n                break\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603165,
                "title": "c-think-reverse",
                "content": "# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        set<int> r,c;\\n        long long ans = 0ll;\\n        reverse(queries.begin(),queries.end());\\n        for(auto& que:queries){\\n            int type = que[0], index = que[1], val = que[2];\\n            if(type==0){\\n                if(r.find(index)==r.end()){\\n                    ans+=(n-c.size())*val;\\n                    r.insert(index);\\n                }\\n            }else{\\n                if(c.find(index)==c.end()){\\n                    ans+=(n-r.size())*val;\\n                    c.insert(index);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        set<int> r,c;\\n        long long ans = 0ll;\\n        reverse(queries.begin(),queries.end());\\n        for(auto& que:queries){\\n            int type = que[0], index = que[1], val = que[2];\\n            if(type==0){\\n                if(r.find(index)==r.end()){\\n                    ans+=(n-c.size())*val;\\n                    r.insert(index);\\n                }\\n            }else{\\n                if(c.find(index)==c.end()){\\n                    ans+=(n-r.size())*val;\\n                    c.insert(index);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602795,
                "title": "java-simple-solution",
                "content": "The idea is to traverse queries backwards so we see the newest queries first.\\n\\nIf the query type is 0, that means a row is replaced, and the amount of tiles in the row that was replaced depends on how many columns overwritten it afterwards. We keep track of which rows and columns have been replaced as we traverse backwards.\\n\\nThe idea of the formula `sum += (curVal * (n-placedCols.size()))` is the following example:\\nIf n = 4, val = 2, and a row was replaced on the last query, 4 tiles would be replaced with the value 2 (since obviously nothing overwritten the tiles after, so `placedCols.size() = 0` here). However, if the same query was done but 3 different columns were replaced after it, then only 1 tile would be replaced (`placedCols.size() = 3` here). This basically suggests that as we are iterating backwards on the queries, more and more unique row/col overwrites happened after `queries[i]` so the amount of tiles the older values occupy become less and less.\\n\\nThe idea of\\n```               \\nif (placedRows.contains(curIdx)) {\\n\\tcontinue;\\n}\\n```\\nis that a newer query overwritten this specific row index, so this value is not relevant to the sum anymore.\\n\\n**Java Solution:**\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        //Keep track of rows/cols already filled\\n        Set<Integer> placedRows = new HashSet<>();\\n        Set<Integer> placedCols = new HashSet<>();\\n        long sum = 0;\\n        for (int i = queries.length-1; i >= 0; i--) {\\n            int curType = queries[i][0];\\n            int curIdx = queries[i][1];\\n            long curVal = queries[i][2];\\n            //Row\\n            if (curType == 0) {\\n                //If already contains, then don\\'t do anything because we overwritten it\\n                if (placedRows.contains(curIdx)) {\\n                    continue;\\n                }\\n                placedRows.add(curIdx);\\n                //Older queries are less populated\\n                sum += (curVal * (n-placedCols.size()));\\n                \\n            }\\n            //Col\\n            else if (curType == 1) {\\n                if (placedCols.contains(curIdx)) {\\n                    continue;\\n                }\\n                placedCols.add(curIdx);\\n                sum += (curVal * (n-placedRows.size()));\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```               \\nif (placedRows.contains(curIdx)) {\\n\\tcontinue;\\n}\\n```\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        //Keep track of rows/cols already filled\\n        Set<Integer> placedRows = new HashSet<>();\\n        Set<Integer> placedCols = new HashSet<>();\\n        long sum = 0;\\n        for (int i = queries.length-1; i >= 0; i--) {\\n            int curType = queries[i][0];\\n            int curIdx = queries[i][1];\\n            long curVal = queries[i][2];\\n            //Row\\n            if (curType == 0) {\\n                //If already contains, then don\\'t do anything because we overwritten it\\n                if (placedRows.contains(curIdx)) {\\n                    continue;\\n                }\\n                placedRows.add(curIdx);\\n                //Older queries are less populated\\n                sum += (curVal * (n-placedCols.size()));\\n                \\n            }\\n            //Col\\n            else if (curType == 1) {\\n                if (placedCols.contains(curIdx)) {\\n                    continue;\\n                }\\n                placedCols.add(curIdx);\\n                sum += (curVal * (n-placedRows.size()));\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602764,
                "title": "python3-o-len-queries-neat-code-reverse-traverse",
                "content": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans, overlaps = 0, [set(), set()]\\n        for t, i, v in reversed(queries):\\n            if i in overlaps[t]: continue\\n            ans += v * (n - len(overlaps[1 - t]))\\n            overlaps[t].add(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans, overlaps = 0, [set(), set()]\\n        for t, i, v in reversed(queries):\\n            if i in overlaps[t]: continue\\n            ans += v * (n - len(overlaps[1 - t]))\\n            overlaps[t].add(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602720,
                "title": "easy-to-understand-reverse-one-pass-hashset",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn matrix_sum_queries(n: i32, queries: Vec<Vec<i32>>) -> i64 {\\n        let (mut rows, mut cols) = (HashSet::new(), HashSet::new());\\n        let n = n as i64;\\n        let mut ans = 0;\\n        \\n        for q in queries.iter().rev() {\\n            if q[0] == 0 {\\n                if !rows.insert(q[1]) { continue };\\n                ans += (n - cols.len() as i64) * q[2] as i64;\\n            } else {\\n                if !cols.insert(q[1]) { continue };\\n                ans += (n - rows.len() as i64) * q[2] as i64;\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn matrix_sum_queries(n: i32, queries: Vec<Vec<i32>>) -> i64 {\\n        let (mut rows, mut cols) = (HashSet::new(), HashSet::new());\\n        let n = n as i64;\\n        let mut ans = 0;\\n        \\n        for q in queries.iter().rev() {\\n            if q[0] == 0 {\\n                if !rows.insert(q[1]) { continue };\\n                ans += (n - cols.len() as i64) * q[2] as i64;\\n            } else {\\n                if !cols.insert(q[1]) { continue };\\n                ans += (n - rows.len() as i64) * q[2] as i64;\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602361,
                "title": "rust-simple-solution-o-n-time-and-space",
                "content": "# Idea \\nBypass queries in reverse order. Process only unused rows and columns\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nimpl Solution {\\n    pub fn matrix_sum_queries(n: i32, queries: Vec<Vec<i32>>) -> i64 {\\n        let size = n as usize;\\n        let (mut cnt_rows, mut cnt_cols) = (0, 0);\\n        let mut used_rows = vec![0; size];\\n        let mut used_cols = vec![0; size];\\n        let mut res: i64 = 0;\\n        \\n        for i in (0..queries.len()).rev() {\\n            if queries[i][0] == 0 && used_rows[queries[i][1] as usize] == 0 { // rows\\n                used_rows[queries[i][1] as usize] = 1;\\n                cnt_rows += 1;\\n                res += ((n - cnt_cols) * queries[i][2]) as i64;\\n            } else if queries[i][0] == 1 && used_cols[queries[i][1] as usize] == 0 { // cols\\n                used_cols[queries[i][1] as usize] = 1;\\n                cnt_cols += 1;\\n                res += ((n - cnt_rows) * queries[i][2]) as i64;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn matrix_sum_queries(n: i32, queries: Vec<Vec<i32>>) -> i64 {\\n        let size = n as usize;\\n        let (mut cnt_rows, mut cnt_cols) = (0, 0);\\n        let mut used_rows = vec![0; size];\\n        let mut used_cols = vec![0; size];\\n        let mut res: i64 = 0;\\n        \\n        for i in (0..queries.len()).rev() {\\n            if queries[i][0] == 0 && used_rows[queries[i][1] as usize] == 0 { // rows\\n                used_rows[queries[i][1] as usize] = 1;\\n                cnt_rows += 1;\\n                res += ((n - cnt_cols) * queries[i][2]) as i64;\\n            } else if queries[i][0] == 1 && used_cols[queries[i][1] as usize] == 0 { // cols\\n                used_cols[queries[i][1] as usize] = 1;\\n                cnt_cols += 1;\\n                res += ((n - cnt_rows) * queries[i][2]) as i64;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602264,
                "title": "tc-100-5ms-sc-99-java-sol-with-comments",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Traverse the queries in reverse because for the same row/column, only the last query\\'s results will be preserved (fully or partially)\\n- Use 2 visited arrays to mark if a row or column has already been checked\\n- Use 2 variables rowsRem & colsRem to track unchecked rows & columns\\n- Feel free to comment if you have any question\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        // Create visited array to store if a row or column has been filled\\n        boolean[] visitedRows = new boolean[n];\\n        boolean[] visitedCols = new boolean[n];\\n        int rowsRem = n, colsRem = n;\\n        long ans = 0;\\n        // Starting from last query since only the latest one for each row/column will be preserved\\n        for (int i = queries.length - 1; i >= 0; i--){\\n            // If it is a row query\\n            if (queries[i][0] == 0){\\n                // If the row was already visited, skip\\n                if (visitedRows[queries[i][1]] == true){\\n                    continue;\\n                // Start incrementing answer depending on colRem\\n                // Because you can only fill the cells in empty columns\\n                } else {\\n                    visitedRows[queries[i][1]] = true;\\n                    ans += colsRem * queries[i][2];\\n                    rowsRem--;\\n                }\\n            // If it is a column query\\n            } else {\\n                // If the column was already visited, skip\\n                if (visitedCols[queries[i][1]] == true){\\n                    continue;\\n                // Start incrementing answer depending on rowRem\\n                // Because you can only fill the cells in empty rows\\n                } else {\\n                    visitedCols[queries[i][1]] = true;\\n                    ans += rowsRem * queries[i][2];\\n                    colsRem--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Thanks for reading!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        // Create visited array to store if a row or column has been filled\\n        boolean[] visitedRows = new boolean[n];\\n        boolean[] visitedCols = new boolean[n];\\n        int rowsRem = n, colsRem = n;\\n        long ans = 0;\\n        // Starting from last query since only the latest one for each row/column will be preserved\\n        for (int i = queries.length - 1; i >= 0; i--){\\n            // If it is a row query\\n            if (queries[i][0] == 0){\\n                // If the row was already visited, skip\\n                if (visitedRows[queries[i][1]] == true){\\n                    continue;\\n                // Start incrementing answer depending on colRem\\n                // Because you can only fill the cells in empty columns\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3602224,
                "title": "python-o-lengthof-queries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(len(queries))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        res = 0\\n        # the number of row/col that have been overwritten\\n        writtenRowCount, writtenColCount = 0,0\\n        # mark each row/col whether it is overwritten or not\\n        # we traverse the queries in a reverse order, therefore, \\n        # once we met a row/col that has been overwritten before, we skip them.\\n        # beacause we are in reversed traversal and this row/col will be overwritten in the original case.\\n        writtenRow, writtenCol = [False] * n, [False] * n\\n\\n        for tpy, idx, val in reversed(queries):\\n            if tpy == 0 and not writtenRow[idx]:\\n                # only cells that is not be overwritten will be count into the result\\n                res += val * (n - writtenColCount)\\n                # now this row should be marked as overwritten\\n                writtenRow[idx] = True\\n                # we have one more overwritten row now\\n                writtenRowCount += 1\\n            if tpy == 1 and not writtenCol[idx]:\\n                # only cells that is not be overwritten will be count into the result\\n                res += val * (n - writtenRowCount)\\n                # now this col should be marked as overwritten\\n                writtenCol[idx] = True\\n                # we have one more overwritten col now\\n                writtenColCount += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        res = 0\\n        # the number of row/col that have been overwritten\\n        writtenRowCount, writtenColCount = 0,0\\n        # mark each row/col whether it is overwritten or not\\n        # we traverse the queries in a reverse order, therefore, \\n        # once we met a row/col that has been overwritten before, we skip them.\\n        # beacause we are in reversed traversal and this row/col will be overwritten in the original case.\\n        writtenRow, writtenCol = [False] * n, [False] * n\\n\\n        for tpy, idx, val in reversed(queries):\\n            if tpy == 0 and not writtenRow[idx]:\\n                # only cells that is not be overwritten will be count into the result\\n                res += val * (n - writtenColCount)\\n                # now this row should be marked as overwritten\\n                writtenRow[idx] = True\\n                # we have one more overwritten row now\\n                writtenRowCount += 1\\n            if tpy == 1 and not writtenCol[idx]:\\n                # only cells that is not be overwritten will be count into the result\\n                res += val * (n - writtenRowCount)\\n                # now this col should be marked as overwritten\\n                writtenCol[idx] = True\\n                # we have one more overwritten col now\\n                writtenColCount += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602080,
                "title": "c-602-ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, const vector<vector<int>>& queries)\\n    {\\n        enum { ROW = 0, TYPE = 0, INDEX, VALUE, };\\n        const int len = queries.size();\\n\\n        int row_count = 0;\\n        int col_count = 0;\\n        long long res = 0;\\n        vector<bool> row(n);\\n        vector<bool> col(n);\\n\\n        for(int i = len - 1; i >= 0; --i)\\n        {\\n            int pos = queries[i][INDEX];\\n\\n            if(queries[i][TYPE] == ROW) {\\n                if(row[pos] == true) continue;\\n                row[pos] = true;\\n                res += queries[i][VALUE] * (n - col_count);\\n                ++row_count;\\n            }\\n            else {\\n                if(col[pos] == true) continue;\\n                col[pos] = true;\\n                res += queries[i][VALUE] * (n - row_count);\\n                ++col_count;\\n            }\\n\\n            if(row_count == n and col_count == n) break;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, const vector<vector<int>>& queries)\\n    {\\n        enum { ROW = 0, TYPE = 0, INDEX, VALUE, };\\n        const int len = queries.size();\\n\\n        int row_count = 0;\\n        int col_count = 0;\\n        long long res = 0;\\n        vector<bool> row(n);\\n        vector<bool> col(n);\\n\\n        for(int i = len - 1; i >= 0; --i)\\n        {\\n            int pos = queries[i][INDEX];\\n\\n            if(queries[i][TYPE] == ROW) {\\n                if(row[pos] == true) continue;\\n                row[pos] = true;\\n                res += queries[i][VALUE] * (n - col_count);\\n                ++row_count;\\n            }\\n            else {\\n                if(col[pos] == true) continue;\\n                col[pos] = true;\\n                res += queries[i][VALUE] * (n - row_count);\\n                ++col_count;\\n            }\\n\\n            if(row_count == n and col_count == n) break;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602073,
                "title": "java-o-n-beats-100-using-set-and-reverse-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> row=new HashSet();\\n        Set<Integer> col=new HashSet();\\n        int r=n, c=n;\\n        long sum=0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            int type=queries[i][0];\\n            int index=queries[i][1];\\n            int value=queries[i][2];\\n            \\n            if(type==0 && !row.contains(index)){\\n                sum+=value*r;\\n                c--;\\n                row.add(index);\\n            }\\n            else if(type==1 && !col.contains(index)){\\n                sum+=value*c;\\n                r--;\\n                col.add(index);\\n            }\\n            \\n        }\\n        return sum;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> row=new HashSet();\\n        Set<Integer> col=new HashSet();\\n        int r=n, c=n;\\n        long sum=0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            int type=queries[i][0];\\n            int index=queries[i][1];\\n            int value=queries[i][2];\\n            \\n            if(type==0 && !row.contains(index)){\\n                sum+=value*r;\\n                c--;\\n                row.add(index);\\n            }\\n            else if(type==1 && !col.contains(index)){\\n                sum+=value*c;\\n                r--;\\n                col.add(index);\\n            }\\n            \\n        }\\n        return sum;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601898,
                "title": "easy-solution-o-n-hashmap",
                "content": "# Intuition\\nmake use of 2 maps one for visited rows and one for visited column :::\\n\\n# Approach\\nstart  from the lastmost  query and keep count of both visited index of row and columns .\\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n  O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q ) {\\n         long long  sum = 0 ; \\n         map< int , int > r , c ;\\n         int rows = 0 , cols = 0 ;\\n         for( int i = q.size()-1 ; i>=0 ; i-- ){\\n              if( q[i][0] == 0 ){\\n                   if( r.find(  q[i][1] )  == r.end() ){\\n                       sum+=( (n-c.size())*q[i][2] ) ;\\n                       \\n                       r[q[i][1]]++ ;\\n                   }\\n               }\\n              else {\\n                   if(  c.find( q[i][1] )  == c.end() ){\\n                       sum+=((n-r.size())*q[i][2]) ;\\n                       cols++ ;\\n                       c[q[i][1]]++ ;\\n                   }\\n              }\\n         }\\n         return sum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q ) {\\n         long long  sum = 0 ; \\n         map< int , int > r , c ;\\n         int rows = 0 , cols = 0 ;\\n         for( int i = q.size()-1 ; i>=0 ; i-- ){\\n              if( q[i][0] == 0 ){\\n                   if( r.find(  q[i][1] )  == r.end() ){\\n                       sum+=( (n-c.size())*q[i][2] ) ;\\n                       \\n                       r[q[i][1]]++ ;\\n                   }\\n               }\\n              else {\\n                   if(  c.find( q[i][1] )  == c.end() ){\\n                       sum+=((n-r.size())*q[i][2]) ;\\n                       cols++ ;\\n                       c[q[i][1]]++ ;\\n                   }\\n              }\\n         }\\n         return sum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601548,
                "title": "python-video-walkthrough-time-o-q-space-o-n-three-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/tQPI4lHed_s)\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        A, res = [set(), set()], 0\\n        for t,i,v in queries[::-1]: res, _ = res + v * (n - len(A[(t + 1) % 2])) * int(i not in A[t]), A[t].add(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        A, res = [set(), set()], 0\\n        for t,i,v in queries[::-1]: res, _ = res + v * (n - len(A[(t + 1) % 2])) * int(i not in A[t]), A[t].add(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601110,
                "title": "solution-reverse-iteration-o-n-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nProcess queries from last to first.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) where N = queries.size()\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> visRow(n), visCol(n);\\n        int cntVisRow = 0, cntVisCol = 0;\\n        for(int i = queries.size() - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n            if(type == 0) {\\n                if(visRow[index] == 0) {\\n                    ans += (long long)(n - cntVisCol) * value;\\n                    visRow[index] = 1;\\n                    cntVisRow++;\\n                }\\n            } else {\\n                if(visCol[index] == 0) {\\n                    ans += (long long)(n - cntVisRow) * value;\\n                    visCol[index] = 1;\\n                    cntVisCol++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> visRow(n), visCol(n);\\n        int cntVisRow = 0, cntVisCol = 0;\\n        for(int i = queries.size() - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n            if(type == 0) {\\n                if(visRow[index] == 0) {\\n                    ans += (long long)(n - cntVisCol) * value;\\n                    visRow[index] = 1;\\n                    cntVisRow++;\\n                }\\n            } else {\\n                if(visCol[index] == 0) {\\n                    ans += (long long)(n - cntVisRow) * value;\\n                    visCol[index] = 1;\\n                    cntVisCol++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601040,
                "title": "easy-solution-by-taking-two-array",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int> row(n,0),col(n,0);\\n        int r=0,c=0;\\n        long long sum=0;\\n        for(int i=queries.size()-1;i>=0;i--)\\n        {\\n            int t=queries[i][0];\\n            int in = queries[i][1];\\n            int v = queries[i][2];\\n            if(t==1)\\n            {\\n                if(!row[in])\\n                {\\n                    sum=sum+(n-c)*v;\\n                    row[in]=1;\\n                    r++;\\n                }\\n            }\\n            if(t==0)\\n            {\\n                if(!col[in])\\n                {\\n                    sum+=(n-r)*v;\\n                    col[in]=1;\\n                    c++;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int> row(n,0),col(n,0);\\n        int r=0,c=0;\\n        long long sum=0;\\n        for(int i=queries.size()-1;i>=0;i--)\\n        {\\n            int t=queries[i][0];\\n            int in = queries[i][1];\\n            int v = queries[i][2];\\n            if(t==1)\\n            {\\n                if(!row[in])\\n                {\\n                    sum=sum+(n-c)*v;\\n                    row[in]=1;\\n                    r++;\\n                }\\n            }\\n            if(t==0)\\n            {\\n                if(!col[in])\\n                {\\n                    sum+=(n-r)*v;\\n                    col[in]=1;\\n                    c++;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600963,
                "title": "golang-o-n-reverse-order-traversal",
                "content": "# Intuition\\nFuture rows and columns will overwrite previous ones\\n\\n# Approach\\n- Traverse the queries array in reversed order\\n- Mark the row or column as visited\\n- Increaes sum\\n    - If `type == 0` inc with `q[i][2]` * `number of columns` then dec `number of rows` by `1`\\n    - If `type == 1` inc with `q[i][2]` * `number of rows` then dec `number of columns` by `1`\\n\\n# Complexity\\n- Time complexity: **O(len(q))**\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\nfunc matrixSumQueries(n int, q [][]int) int64 {\\n    var sum int\\n\\n    nrow := n\\n    ncolumn := n\\n    row := make(map[int]bool)\\n    column := make(map[int]bool)\\n\\n    for i := len(q)-1; i >= 0; i-- {\\n        if q[i][0] == 0 && !row[q[i][1]] {\\n            sum += ncolumn * q[i][2]\\n            row[q[i][1]] = true\\n            nrow--\\n        } \\n        if q[i][0] == 1 && !column[q[i][1]] {\\n            sum += nrow * q[i][2]\\n            column[q[i][1]] = true\\n            ncolumn--\\n        }\\n    }\\n    \\n    return int64(sum)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc matrixSumQueries(n int, q [][]int) int64 {\\n    var sum int\\n\\n    nrow := n\\n    ncolumn := n\\n    row := make(map[int]bool)\\n    column := make(map[int]bool)\\n\\n    for i := len(q)-1; i >= 0; i-- {\\n        if q[i][0] == 0 && !row[q[i][1]] {\\n            sum += ncolumn * q[i][2]\\n            row[q[i][1]] = true\\n            nrow--\\n        } \\n        if q[i][0] == 1 && !column[q[i][1]] {\\n            sum += nrow * q[i][2]\\n            column[q[i][1]] = true\\n            ncolumn--\\n        }\\n    }\\n    \\n    return int64(sum)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600857,
                "title": "typescript-easy-solution",
                "content": "# Approach\\n- Do reverse iteration through queries because latest rows and  cols have contribution to our final answer.\\n- Add visited rows and cols to hash set.\\n\\n# Complexity\\nTime O(length of queries)\\nSpace O(N)\\n\\n\\n# Code\\n```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n    let rowMap: Map<number, boolean> = new Map();\\n    let colMap: Map<number, boolean> = new Map();\\n    let sum: number = 0;\\n    for (let index = queries.length - 1; index >= 0; index--) {\\n        let val: number[] = queries[index];\\n        if (val[0] === 1 && !colMap.get(val[1])) {\\n            sum += val[2] * (n - rowMap.size)\\n            colMap.set(val[1], true);\\n        } else if (val[0] === 0 && !rowMap.get(val[1])) {\\n            sum += val[2] * (n - colMap.size);\\n            rowMap.set(val[1], true);\\n        }\\n    }\\n    return sum;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n    let rowMap: Map<number, boolean> = new Map();\\n    let colMap: Map<number, boolean> = new Map();\\n    let sum: number = 0;\\n    for (let index = queries.length - 1; index >= 0; index--) {\\n        let val: number[] = queries[index];\\n        if (val[0] === 1 && !colMap.get(val[1])) {\\n            sum += val[2] * (n - rowMap.size)\\n            colMap.set(val[1], true);\\n        } else if (val[0] === 0 && !rowMap.get(val[1])) {\\n            sum += val[2] * (n - colMap.size);\\n            rowMap.set(val[1], true);\\n        }\\n    }\\n    return sum;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600804,
                "title": "start-from-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart from the end. This helps us in knowning any value will be changed in the future or not. If it is changed we dont add it in sum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q )\\n    {\\n        long long ans =0;\\n        reverse(q.begin(),q.end());\\n        vector<bool> row(n,false), col(n,false);\\n        int r=0,c=0;\\n        for(auto it : q)\\n        {\\n            int x = it[0],y = it[1],z= it[2];\\n            if(it[0] == 0 && !row[y])\\n            {\\n                 ans+= ((n-c)*z);\\n                 row[y] =true;\\n                 r++;\\n            }\\n            else if(it[0] == 1 && !col[y])\\n            {\\n                ans+=((n-r)*z);\\n                col[y]=true;\\n                c++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q )\\n    {\\n        long long ans =0;\\n        reverse(q.begin(),q.end());\\n        vector<bool> row(n,false), col(n,false);\\n        int r=0,c=0;\\n        for(auto it : q)\\n        {\\n            int x = it[0],y = it[1],z= it[2];\\n            if(it[0] == 0 && !row[y])\\n            {\\n                 ans+= ((n-c)*z);\\n                 row[y] =true;\\n                 r++;\\n            }\\n            else if(it[0] == 1 && !col[y])\\n            {\\n                ans+=((n-r)*z);\\n                col[y]=true;\\n                c++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600575,
                "title": "o-n-solution-reverse-traversal-java",
                "content": "# Approach\\nO(N) solution with reverse order traversal\\n\\n# Complexity\\n- Time complexity:\\nO(q) : number of queries\\n\\n- Space complexity:\\nO(N) : number of row and column\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int N, int[][] queries) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        \\n        int rowSize = 0;\\n        int colSize = 0;\\n        long sum = 0;\\n        int n = queries.length;\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            if(queries[i][0] == 0) {\\n                if(!row.contains(queries[i][1])) {\\n                    row.add(queries[i][1]);\\n                    rowSize++;\\n                    sum += queries[i][2]*(N-colSize);\\n                }\\n            }\\n            else {\\n                if(!col.contains(queries[i][1])) {\\n                    col.add(queries[i][1]);\\n                    colSize++;\\n                    sum += queries[i][2]*(N-rowSize);\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int N, int[][] queries) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        \\n        int rowSize = 0;\\n        int colSize = 0;\\n        long sum = 0;\\n        int n = queries.length;\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            if(queries[i][0] == 0) {\\n                if(!row.contains(queries[i][1])) {\\n                    row.add(queries[i][1]);\\n                    rowSize++;\\n                    sum += queries[i][2]*(N-colSize);\\n                }\\n            }\\n            else {\\n                if(!col.contains(queries[i][1])) {\\n                    col.add(queries[i][1]);\\n                    colSize++;\\n                    sum += queries[i][2]*(N-rowSize);\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600573,
                "title": "o-n-solution-reverse-traversal-java",
                "content": "# Approach\\nO(N) solution with reverse order traversal\\n\\n# Complexity\\n- Time complexity:\\nO(q) : number of queries\\n\\n- Space complexity:\\nO(N) : number of row and column\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int N, int[][] queries) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        \\n        int rowSize = 0;\\n        int colSize = 0;\\n        long sum = 0;\\n        int n = queries.length;\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            if(queries[i][0] == 0) {\\n                if(!row.contains(queries[i][1])) {\\n                    row.add(queries[i][1]);\\n                    rowSize++;\\n                    sum += queries[i][2]*(N-colSize);\\n                }\\n            }\\n            else {\\n                if(!col.contains(queries[i][1])) {\\n                    col.add(queries[i][1]);\\n                    colSize++;\\n                    sum += queries[i][2]*(N-rowSize);\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int N, int[][] queries) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        \\n        int rowSize = 0;\\n        int colSize = 0;\\n        long sum = 0;\\n        int n = queries.length;\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            if(queries[i][0] == 0) {\\n                if(!row.contains(queries[i][1])) {\\n                    row.add(queries[i][1]);\\n                    rowSize++;\\n                    sum += queries[i][2]*(N-colSize);\\n                }\\n            }\\n            else {\\n                if(!col.contains(queries[i][1])) {\\n                    col.add(queries[i][1]);\\n                    colSize++;\\n                    sum += queries[i][2]*(N-rowSize);\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600560,
                "title": "heavily-commented-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf following  by the word of what the question asks you to do and defining a n*n sized array, you will run out of heap space in large test cases and Node JS will throw an error.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe declare 2 sets of n length each instead and traverse the queries from the end since the newest values would have overwritten the older ones.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number}\\n*/\\n\\nvar matrixSumQueries = function(n, queries) {\\n\\n    //instead of declaring a n*n matrix to solve we declare 2 sets , n+n;\\n    let row = new Set(),\\n        col = new Set(),\\n        sum = 0;\\n\\n    queries.reverse(); // staring from end since newer values will overwrite older ones\\n\\n    for( [type,index,val] of queries ){\\n        if(!type){\\n            if(row.has(index))  continue;       //row already parsed by newer query\\n\\n            row.add(index);\\n            sum += val * (n - col.size)         //value * ( total size - number of newer command COLUMNS that overwrote it)\\n\\n        }\\n        else{\\n            if(col.has(index))  continue;       //col already parsed by newer query\\n\\n            col.add(index);\\n            sum += val * (n - row.size)         //value * ( total size - number of newer command ROWS that overwrote it)\\n\\n        }\\n    }\\n\\n    return sum;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number}\\n*/\\n\\nvar matrixSumQueries = function(n, queries) {\\n\\n    //instead of declaring a n*n matrix to solve we declare 2 sets , n+n;\\n    let row = new Set(),\\n        col = new Set(),\\n        sum = 0;\\n\\n    queries.reverse(); // staring from end since newer values will overwrite older ones\\n\\n    for( [type,index,val] of queries ){\\n        if(!type){\\n            if(row.has(index))  continue;       //row already parsed by newer query\\n\\n            row.add(index);\\n            sum += val * (n - col.size)         //value * ( total size - number of newer command COLUMNS that overwrote it)\\n\\n        }\\n        else{\\n            if(col.has(index))  continue;       //col already parsed by newer query\\n\\n            col.add(index);\\n            sum += val * (n - row.size)         //value * ( total size - number of newer command ROWS that overwrote it)\\n\\n        }\\n    }\\n\\n    return sum;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600538,
                "title": "simple-and-concise-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need to pay attention to the latest query operation on the item as it will over write the old value, so we need to track the rows and cols we are changing.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate through the list of queries in reverse order. For each op, use a counter and a set to keep track of the rows/cols you\\'re changing. The counter will help you to determine which all row/col items should be overwritten. The set will help you to avoid redundant overwrites, that is, if your last query overwrites the 2nd row, all previous ops on 2nd row can be ignored.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        r, c = 0, 0\\n        r_set, c_set = set(), set()\\n        sum = 0\\n        for q in reversed(queries):\\n            if q[0] == 0 and q[1] not in r_set:\\n                sum += q[2] * (n - c)\\n                r_set.add(q[1])\\n                r += 1 if r < n else 0\\n            if q[0] == 1 and q[1] not in c_set:\\n                sum += q[2] * (n - r)\\n                c_set.add(q[1])\\n                c += 1 if c < n else 0\\n\\n        return sum\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        r, c = 0, 0\\n        r_set, c_set = set(), set()\\n        sum = 0\\n        for q in reversed(queries):\\n            if q[0] == 0 and q[1] not in r_set:\\n                sum += q[2] * (n - c)\\n                r_set.add(q[1])\\n                r += 1 if r < n else 0\\n            if q[0] == 1 and q[1] not in c_set:\\n                sum += q[2] * (n - r)\\n                c_set.add(q[1])\\n                c += 1 if c < n else 0\\n\\n        return sum\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600461,
                "title": "simple-o-n-reverse-iteration-full-explanation-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the reverse iteration the operation performed will be fixed and can\\'t be overwriiten.\\nUsing this logic once row or column operation is performed the value is fixed and can\\'t be change for the next column or row operation respectively.\\nWe maintain the row and column count for the fixed values and thus for next column operation we subtract the fixed rows and then add the the value to result, \\nsimilarly for next row operation we subtract the fixed column and then add the value to result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int row=0, col=0;\\n\\n        vector<pair<int,int>> rowhead(n,make_pair(0,-1)), colhead(n,make_pair(0,-1));\\n        long long result = 0;\\n        for(int i=queries.size()-1; i>=0; i--) {\\n            if(queries[i][0]==0) {\\n                if(rowhead[queries[i][1]].second==-1) {\\n                    result += (n-col)*queries[i][2];\\n                    rowhead[queries[i][1]].first = queries[i][2];\\n                    rowhead[queries[i][1]].second = i;\\n                    row++;\\n                }\\n            } else {\\n                if(colhead[queries[i][1]].second==-1) {\\n                    result += (n-row)*queries[i][2];\\n                    colhead[queries[i][1]].first = queries[i][2];\\n                    colhead[queries[i][1]].second = i;\\n                    col++;\\n                }\\n            }\\n        }\\n\\n        \\n        return result;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int row=0, col=0;\\n\\n        vector<pair<int,int>> rowhead(n,make_pair(0,-1)), colhead(n,make_pair(0,-1));\\n        long long result = 0;\\n        for(int i=queries.size()-1; i>=0; i--) {\\n            if(queries[i][0]==0) {\\n                if(rowhead[queries[i][1]].second==-1) {\\n                    result += (n-col)*queries[i][2];\\n                    rowhead[queries[i][1]].first = queries[i][2];\\n                    rowhead[queries[i][1]].second = i;\\n                    row++;\\n                }\\n            } else {\\n                if(colhead[queries[i][1]].second==-1) {\\n                    result += (n-row)*queries[i][2];\\n                    colhead[queries[i][1]].first = queries[i][2];\\n                    colhead[queries[i][1]].second = i;\\n                    col++;\\n                }\\n            }\\n        }\\n\\n        \\n        return result;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600360,
                "title": "so-what-s-wrong-with-this-code",
                "content": "I can\\'t find what\\'s wrong with this code? \\n\\n\\n```java\\n    public static long matrixSumQueries(int n, int[][] queries) {\\n        Map<Integer, Integer> rows = new HashMap<>();\\n        Map<Integer, Integer> cols = new HashMap<>();\\n\\n        long ans = 0;\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int value = queries[i][2];\\n\\n            if (type == 0) {\\n                int prev = rows.getOrDefault(idx, 0);\\n\\n                ans += (long) (value - prev) * (n - cols.size());\\n\\n                for (int x : cols.values()) {\\n                    ans += value - x;\\n                }\\n\\n                rows.put(idx, value);\\n            } else {\\n                int prev = cols.getOrDefault(idx, 0);\\n\\n                ans += (long) (value - prev) * (n - rows.size());\\n\\n                for (int x : rows.values()) {\\n                    ans += value - x;\\n                }\\n\\n                cols.put(idx, value);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```java\\n    public static long matrixSumQueries(int n, int[][] queries) {\\n        Map<Integer, Integer> rows = new HashMap<>();\\n        Map<Integer, Integer> cols = new HashMap<>();\\n\\n        long ans = 0;\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int value = queries[i][2];\\n\\n            if (type == 0) {\\n                int prev = rows.getOrDefault(idx, 0);\\n\\n                ans += (long) (value - prev) * (n - cols.size());\\n\\n                for (int x : cols.values()) {\\n                    ans += value - x;\\n                }\\n\\n                rows.put(idx, value);\\n            } else {\\n                int prev = cols.getOrDefault(idx, 0);\\n\\n                ans += (long) (value - prev) * (n - rows.size());\\n\\n                for (int x : rows.values()) {\\n                    ans += value - x;\\n                }\\n\\n                cols.put(idx, value);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1915956,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916121,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915938,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916145,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916996,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916193,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915953,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916012,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915961,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916447,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915956,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916121,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915938,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916145,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916996,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916193,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915953,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916012,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915961,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916447,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1947988,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1939923,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1936163,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1931174,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1918460,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1916908,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1916871,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1916470,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1916257,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1916202,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count of Integers",
        "question_content": "<p>You are given two numeric strings <code>num1</code> and <code>num2</code> and two integers <code>max_sum</code> and <code>min_sum</code>. We denote an integer <code>x</code> to be <em>good</em> if:</p>\n\n<ul>\n\t<li><code>num1 &lt;= x &lt;= num2</code></li>\n\t<li><code>min_sum &lt;= digit_sum(x) &lt;= max_sum</code>.</li>\n</ul>\n\n<p>Return <em>the number of good integers</em>. Since the answer may be large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>Note that <code>digit_sum(x)</code> denotes the sum of the digits of <code>x</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;1&quot;, num2 = &quot;12&quot;, <code>min_sum</code> = 1, max_sum = 8\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> There are 11 integers whose sum of digits lies between 1 and 8 are 1,2,3,4,5,6,7,8,10,11, and 12. Thus, we return 11.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;1&quot;, num2 = &quot;5&quot;, <code>min_sum</code> = 1, max_sum = 5\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The 5 integers whose sum of digits lies between 1 and 5 are 1,2,3,4, and 5. Thus, we return 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1 &lt;= num2 &lt;= 10<sup>22</sup></code></li>\n\t<li><code>1 &lt;= min_sum &lt;= max_sum &lt;= 400</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3594894,
                "title": "classic-digit-dp-similar-problems",
                "content": "# Intuition\\nSince N<=1e22 so we can\\'t count the numbers manually.\\n\\n# Approach\\n1. let a = numbers between num1 & num2 with digitsum <= max_sum\\n2. let b = numbers between num1 & num2 with digitsum <= min_sum-1\\n3. a-b is the answer. Since a-b gives numbers with digitsum>=min_sum-1 (since all the numbers lowers got subtracted) and digitsum<=max_sum.\\n\\n# Detailed Explanation\\nThe basic idea is to try all possible digits at every index without exceeding higher number while being equal to or more than lower number.\\n1. $$tight1$$ tells us if all the digits we\\'ve choosen so far are the lowest possible ones, so if $$tight1$$ is true we can\\'t choose a digit less than *lowest digit allowed* at that index otherwise our number would become lower than *lowest number allowed*.\\n2. Hence if $$tight1$$ is true and we still choose *lowest digit allowed*, it remains true otherwise it becomes false i.e. lowest digit can be 0 in further places.\\n3. $$tight2$$ tells us if all the digits we\\'ve choosen so far are the highest possible ones, so if $$tight2$$ is true we can\\'t choose a digit higher than *largest digit allowed* at that index otherwise our number would become higher than *largest number allowed*.\\n4. Similarly if $$tight2$$ is true and we still choose *largest digit allowed*, it remains true otherwise it becomes false i.e. largest digit can be 9 in further places.\\n# Code\\n```\\nconst int MOD = 1e9 + 7;\\n\\nclass Solution {\\n    int dp[23][2][2][401];\\n\\n    int countStrings(int i, bool tight1, bool tight2, int sum, string& num1, string& num2) {\\n        if (sum < 0) return 0;\\n        if (i == num2.size()) return 1;\\n        if (dp[i][tight1][tight2][sum] != -1) return dp[i][tight1][tight2][sum];\\n\\n        int lo = tight1 ? num1[i] - \\'0\\' : 0;\\n        int hi = tight2 ? num2[i] - \\'0\\' : 9;\\n\\n        int count = 0;\\n        for (int idx = lo; idx <= hi; idx++) {\\n            count = (count % MOD + countStrings(i + 1,\\n                     tight1 & (idx == lo), tight2 & (idx == hi),\\n                     sum - idx, num1, num2) % MOD) % MOD;\\n        }\\n\\n        return dp[i][tight1][tight2][sum] = count;\\n    }\\n\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof(dp));\\n        int leadingZeroes = num2.length() - num1.length();\\n        string num1extended = string(leadingZeroes,\\'0\\')+num1;\\n\\n        //Avoid dealing with different length numbers\\n        //If the numbers are 1 and 999 convert 1 into 001\\n\\n        int total = countStrings(0, 1, 1, max_sum, num1extended, num2);\\n        int unnecessary = countStrings(0, 1, 1, min_sum - 1, num1extended, num2);\\n        int ans = (total - unnecessary) % MOD;\\n        \\n        return (ans < 0) ? ans+MOD : ans;\\n    }\\n};\\n\\n```\\n# Complexity\\n- **Time complexity:**\\nO(10 * 2 * 2 * Number_Of_Digits * Sum)\\ni.e. O(Number_Of_Digits * Sum)\\n\\n- **Space complexity:**\\nO(Number_Of_Digits * Sum) \\n# Similar Problems:\\n1. [233. Number of Digit One](https://leetcode.com/problems/number-of-digit-one/?envType=list&envId=owsh7g4c)\\n2. [600. Non-negative Integers without Consecutive Ones](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/?envType=list&envId=owsh7g4c)\\n3. [902. Numbers At Most N Given Digit Set](https://leetcode.com/problems/numbers-at-most-n-given-digit-set/?envType=list&envId=owsh7g4c)\\n4. [1012. Numbers With Repeated Digits](https://leetcode.com/problems/numbers-with-repeated-digits/?envType=list&envId=owsh7g4c)\\n5. [1397. Find All Good Strings](https://leetcode.com/problems/find-all-good-strings/?envType=list&envId=owsh7g4c) (Very tough, prerequisite-KMP)\\n<!-- # Study Resources -->\\n<!-- - **Youtube** : Kartik Arora\\'s [playlist on Digit DP](https://youtube.com/playlist?list=PLb3g_Z8nEv1hB69JL9K7KfEyK8iQNj9nX) -->\\n# Edit\\n- For Java Code people can refer to @hitzy\\'s comment\\n- We don\\'t need to reset dp array between min_sum and max_sum function calls, hence omitted that\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nconst int MOD = 1e9 + 7;\\n\\nclass Solution {\\n    int dp[23][2][2][401];\\n\\n    int countStrings(int i, bool tight1, bool tight2, int sum, string& num1, string& num2) {\\n        if (sum < 0) return 0;\\n        if (i == num2.size()) return 1;\\n        if (dp[i][tight1][tight2][sum] != -1) return dp[i][tight1][tight2][sum];\\n\\n        int lo = tight1 ? num1[i] - \\'0\\' : 0;\\n        int hi = tight2 ? num2[i] - \\'0\\' : 9;\\n\\n        int count = 0;\\n        for (int idx = lo; idx <= hi; idx++) {\\n            count = (count % MOD + countStrings(i + 1,\\n                     tight1 & (idx == lo), tight2 & (idx == hi),\\n                     sum - idx, num1, num2) % MOD) % MOD;\\n        }\\n\\n        return dp[i][tight1][tight2][sum] = count;\\n    }\\n\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof(dp));\\n        int leadingZeroes = num2.length() - num1.length();\\n        string num1extended = string(leadingZeroes,\\'0\\')+num1;\\n\\n        //Avoid dealing with different length numbers\\n        //If the numbers are 1 and 999 convert 1 into 001\\n\\n        int total = countStrings(0, 1, 1, max_sum, num1extended, num2);\\n        int unnecessary = countStrings(0, 1, 1, min_sum - 1, num1extended, num2);\\n        int ans = (total - unnecessary) % MOD;\\n        \\n        return (ans < 0) ? ans+MOD : ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595618,
                "title": "c-digit-dp-recursive-memoization-top-down-tabulation-bottom-up",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will try to implement question in another way. We will implement the function which counts the integers which is less or equal to given string `s` and whose digit sum is between the given boundaries.\\n\\n**Que:** From this function, can we get numbers which is between num1 and num2.\\n\\n**Ans:** Yes.\\n**How?:** Here in the given question, we have to find the numbers which are in between `num1` and `num2` and whose digit sum is between `min_sum` and `max_sum`. We have already implemented function which gives all the numbers less than equal to given string.\\n\\nHere `num1 <= num2`. So if we were asked to find the number of integers between `num1` and `num2`. we will first find number which is less than equal to num2 and which will give all number satisfying the condition including smaller than `num1`. So we have to delete those extra number which can be found by the same function by passing `num1` string as bound.\\n\\nSo, `Ans(num1, num2) = subAns(num2) - subAns(num1 - 1)`;\\n\\nI haven\\'t code for the string subtraction, rather i have found the answer for `<= num1` and have checked manually for `num1`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDigit DP Approach will be used here.\\n\\n# Complexity\\n- Time complexity:\\n$$O(max(len(num1), len(num2)) * max(sum(num1), sum(num2)) * 2 * 10)$$\\n- Space complexity:\\n$$O(max(len(num1), len(num2)) * max(sum(num1), sum(num2)) * 2) + StackSpace$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    long dp[23][401][2];\\n    long solve(int idx, int sum, bool tight, const int &min_sum, const int &max_sum, string &s)\\n    {\\n        if (idx == s.size())\\n            return sum >= min_sum and sum <= max_sum;\\n\\n        if (dp[idx][sum][tight] != -1)\\n            return dp[idx][sum][tight];\\n\\n        long ans = 0;\\n        if (tight)\\n        {\\n            for (int i = 0; i <= s[idx] - \\'0\\'; i++)\\n            {\\n                if ((s[idx] - \\'0\\') == i)\\n                    ans = (ans + solve(idx + 1, sum + i, true, min_sum, max_sum, s)) % mod;\\n                else\\n                    ans = (ans + solve(idx + 1, sum + i, false, min_sum, max_sum, s)) % mod;\\n            }\\n        }\\n        else\\n        {\\n            for (int i = 0; i <= 9; i++)\\n                ans = (ans + solve(idx + 1, sum + i, false, min_sum, max_sum, s)) % mod;\\n        }\\n        return dp[idx][sum][tight] = ans;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        long upper = solve(0, 0, true, min_sum, max_sum, num2);\\n        memset(dp, -1, sizeof(dp));\\n        long lower = solve(0, 0, true, min_sum, max_sum, num1);\\n\\n        int sum = 0;\\n        for (auto i : num1)\\n            sum += (i - \\'0\\');\\n\\n        if (sum >= min_sum and sum <= max_sum)\\n            lower--;\\n\\n        return ((upper - lower) + mod) % mod;\\n    }\\n};\\n```\\n#### Give a upvote if it helps you !! Will be uploading Bottom-Up Approach Soon.\\n\\n- #### UPDATE: Attaching Bottom-UP Solution for the same Approach.\\n```\\nclass Solution\\n{\\npublic:\\n    const int mod = 1e9 + 7;\\n    long subAns(string s, int min_sum, int max_sum)\\n    {\\n        int n = s.size();\\n        int mx = 501;\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(mx + 10, vector<int>(2)));\\n\\n        for (int sum = 0; sum < mx; sum++)\\n            if (sum >= min_sum and sum <= max_sum)\\n                dp[n][sum][0] = 1, dp[n][sum][1] = 1;\\n\\n        for (int idx = n - 1; idx >= 0; idx--)\\n        {\\n            for (int sum = mx - 1; sum >= 0; sum--)\\n            {\\n                for (int tight = 1; tight >= 0; tight--)\\n                {\\n                    long ans = 0;\\n                    if (tight)\\n                    {\\n                        for (int i = 0; i <= s[idx] - \\'0\\'; i++)\\n                        {\\n                            if ((s[idx] - \\'0\\') == i)\\n                                ans = (ans + dp[idx + 1][sum + i][1]) % mod;\\n                            else\\n                                ans = (ans + dp[idx + 1][sum + i][0]) % mod;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        for (int i = 0; i <= 9; i++)\\n                            ans = (ans + dp[idx + 1][sum + i][0]) % mod;\\n                    }\\n                    dp[idx][sum][tight] = ans;\\n                }\\n            }\\n        }\\n\\n        return dp[0][0][1];\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum)\\n    {\\n        long lower = subAns(num1, min_sum, max_sum);\\n        long upper = subAns(num2, min_sum, max_sum);\\n\\n        int sum = 0;\\n        for (auto i : num1)\\n            sum += (i - \\'0\\');\\n        if (sum >= min_sum and sum <= max_sum)\\n            lower--;\\n        return ((upper - lower) + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    long dp[23][401][2];\\n    long solve(int idx, int sum, bool tight, const int &min_sum, const int &max_sum, string &s)\\n    {\\n        if (idx == s.size())\\n            return sum >= min_sum and sum <= max_sum;\\n\\n        if (dp[idx][sum][tight] != -1)\\n            return dp[idx][sum][tight];\\n\\n        long ans = 0;\\n        if (tight)\\n        {\\n            for (int i = 0; i <= s[idx] - \\'0\\'; i++)\\n            {\\n                if ((s[idx] - \\'0\\') == i)\\n                    ans = (ans + solve(idx + 1, sum + i, true, min_sum, max_sum, s)) % mod;\\n                else\\n                    ans = (ans + solve(idx + 1, sum + i, false, min_sum, max_sum, s)) % mod;\\n            }\\n        }\\n        else\\n        {\\n            for (int i = 0; i <= 9; i++)\\n                ans = (ans + solve(idx + 1, sum + i, false, min_sum, max_sum, s)) % mod;\\n        }\\n        return dp[idx][sum][tight] = ans;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        long upper = solve(0, 0, true, min_sum, max_sum, num2);\\n        memset(dp, -1, sizeof(dp));\\n        long lower = solve(0, 0, true, min_sum, max_sum, num1);\\n\\n        int sum = 0;\\n        for (auto i : num1)\\n            sum += (i - \\'0\\');\\n\\n        if (sum >= min_sum and sum <= max_sum)\\n            lower--;\\n\\n        return ((upper - lower) + mod) % mod;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    const int mod = 1e9 + 7;\\n    long subAns(string s, int min_sum, int max_sum)\\n    {\\n        int n = s.size();\\n        int mx = 501;\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(mx + 10, vector<int>(2)));\\n\\n        for (int sum = 0; sum < mx; sum++)\\n            if (sum >= min_sum and sum <= max_sum)\\n                dp[n][sum][0] = 1, dp[n][sum][1] = 1;\\n\\n        for (int idx = n - 1; idx >= 0; idx--)\\n        {\\n            for (int sum = mx - 1; sum >= 0; sum--)\\n            {\\n                for (int tight = 1; tight >= 0; tight--)\\n                {\\n                    long ans = 0;\\n                    if (tight)\\n                    {\\n                        for (int i = 0; i <= s[idx] - \\'0\\'; i++)\\n                        {\\n                            if ((s[idx] - \\'0\\') == i)\\n                                ans = (ans + dp[idx + 1][sum + i][1]) % mod;\\n                            else\\n                                ans = (ans + dp[idx + 1][sum + i][0]) % mod;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        for (int i = 0; i <= 9; i++)\\n                            ans = (ans + dp[idx + 1][sum + i][0]) % mod;\\n                    }\\n                    dp[idx][sum][tight] = ans;\\n                }\\n            }\\n        }\\n\\n        return dp[0][0][1];\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum)\\n    {\\n        long lower = subAns(num1, min_sum, max_sum);\\n        long upper = subAns(num2, min_sum, max_sum);\\n\\n        int sum = 0;\\n        for (auto i : num1)\\n            sum += (i - \\'0\\');\\n        if (sum >= min_sum and sum <= max_sum)\\n            lower--;\\n        return ((upper - lower) + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717364,
                "title": "digit-dp-learning-resource-similar-problem-explanation",
                "content": "First of All who do not understand how to approach this, they must know that this is **CLASSIC DIGIT DP PROBLEM**\\n\\n**Solution Explanation** : \\n\\n* As Question say find number of integer from ***[num1,num2]*** whose digit sum is between ***minsum*** and ***maxsum***\\n\\n* One way to do this is find numbers from [0,num1] whose digit sum is between ***minsum*** and ***maxsum*** and then find numbers from [0,num2] whose digit sum is between ***minsum*** and ***maxsum*** and subtract them.\\n\\n* Let A = numbers from **[0,num1]** (including num1) having digit sum between ***minsum*** and ***maxsum*** \\n* Let B = numbers from **[0,num2]** (including num2) having digit sum between ***minsum*** and ***maxsum*** \\n* Answer is **B - A + check(num1)**. where check function checks if num1 has digit sum  between ***minsum*** and ***maxsum***  because num1 counted twice.\\n\\nTill Now, we understand the code inside the **count** Function and **check** function given below, \\n\\nNow Try to understand the code inside the **rec** function.\\n\\n# **Explaining  the rec function**\\n\\nSuppose we passed this in rec function(\"123\",0,0,false). \\n\\nHere **\"123\"** denote upper limit that up to which we can create number for example \"000\",\"001\" ........\"123\",**next 0 is 0th index of \"123\"**, **another 0 is the inital digit sum** and **false indicate that the prefix number we form is smaller than current prefix index**, for example we form number **\"11\"**, now we set false to true and it indicate at 2nd index we can use numbers from 1 to 9 to create index **\"111\",\"112\",\"113\"....** and if we form number **12** we can set true to false and it indicate at 2nd index we can only **use 1, 2 , 3 to form 121, 122, 123**  **if we use 4-9 it make digit 124, 125 .... which is greater then 123**\\n\\n\\n\\n\\n1.First If condition in rec function show if for \"123\" our ind reach 3 it means we reach at the end and here we check if digit sum is in range if it is we return 1 otherwise 0\\n\\n2.First recursive call help us to form numbers like \"000\",\"001\"....\\n\\n\\n3.Third if condition if(smaller) indicate if number we form is of something like this \"01\", \"11\" because if we form number something like this till 1st index we can use all numbers from 1 to 9 at 2nd index, thats what we are doing in 2nd recursive call in if condition\\nIt helps in forming number like \"010\",\"011\",\"012\"....\"111\",\"112\"....etc\\n\\n\\n4.Else condition indicate the number we already form is something like \"1\" hence at 1st index we can not use all digit from 1 to 9 if we use number become greater than 123, so we are findin the diff upto which we can use for 12. we can use 1, 2  on the next index and if we use 1  in the 1st index. our number become something like \"11\" and now we can use any numbers from 1 to 9 in 2nd index and if we use 2 our number beome \"12\" and we can use only 1,2,3 on 2nd index , This is what last two recursion calls are.\\n\\n\\n\\n\\n\\n\\nTough part of the question is to write function which give the numbers from **[0,num1]**(including num1) **having digit sum between minsum and maxsum**\\n\\nI can not explain the big concept in just few lines\\n\\n\\nI think this video explain digit DP in best way. Watch this \"[A Code Daily Digit DP](https://www.youtube.com/watch?v=pSW4mt0JMOM&t=1273s)\" on youtube, I can not paste the link (LC may delete this post) and solve this [problem](https://codeforces.com/problemset/problem/1036/C) and then came here to write recursive function and I am sure you can write. Give some time to this topic don\\'t try to copy paste the solution\\n\\nIf after watching the video and solving above given codeforces problem If you have any doubt regarding this question I will explain in comments\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int mn, mx;    \\n    int dp[23][500][2];    \\n    int mod = 1e9+7;    \\n    int rec(string &s1,int ind,int num,bool smaller){\\n            \\n            if(ind  == s1.size()){\\n                    if(num >= mn && num <= mx) return 1;\\n                    return 0;\\n            }\\n\\t\\t\\t\\n            if(dp[ind][num][smaller]  != -1) return dp[ind][num][smaller];\\n            \\n            int ans = 0;\\n            \\n            ans = (ans + rec(s1,ind+1,num + 0, smaller ? smaller : (s1[ind] != \\'0\\')))%mod; // for creating numbers like 000,001,002 etc.\\n\\t\\t\\t\\n            if(smaller){\\n                    for(int i = 1;i<=9;i++)\\n                    ans = (ans + rec(s1,ind+1,num + i, smaller))%mod;\\n            }else{\\n                    int diff = (s1[ind] - \\'0\\');\\n                    if(diff > 0){\\n                            for(int i = 1;i<diff;i++){\\n                                    ans = (ans + rec(s1,ind+1,num + i,true))%mod;\\n                            }\\n                    }\\n                    if(s1[ind] != \\'0\\')\\n                            ans = (ans + rec(s1,ind+1,num + diff,false))%mod;\\n            }\\n            return dp[ind][num][smaller] = ans;\\n    }    \\n        \\n    int check(string &num1){\\n            \\n            int ans = 0;\\n            for(int i = 0;i<num1.size();i++){\\n                    ans = ans + (num1[i] - \\'0\\');\\n            }\\n            \\n            if(ans >= mn && ans <= mx) return 1;\\n            return 0;\\n    }    \\n        \\n        \\n        \\n        \\n        \\n        \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n            \\n            mn = min_sum;\\n            mx = max_sum;\\n           \\n            memset(dp,-1,sizeof(dp));\\n            int a = rec(num2,0,0,false);\\n            \\n            memset(dp,-1,sizeof(dp));\\n            int b = rec(num1,0,0,false);\\n           \\n          \\n            return( a - b + check(num1) + mod)%mod;\\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\nProblem 1 : [Classy Numbers](https://codeforces.com/problemset/problem/1036/C)\\nProblem 2: [Magic Numbers](https://codeforces.com/contest/628/problem/D)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mn, mx;    \\n    int dp[23][500][2];    \\n    int mod = 1e9+7;    \\n    int rec(string &s1,int ind,int num,bool smaller){\\n            \\n            if(ind  == s1.size()){\\n                    if(num >= mn && num <= mx) return 1;\\n                    return 0;\\n            }\\n\\t\\t\\t\\n            if(dp[ind][num][smaller]  != -1) return dp[ind][num][smaller];\\n            \\n            int ans = 0;\\n            \\n            ans = (ans + rec(s1,ind+1,num + 0, smaller ? smaller : (s1[ind] != \\'0\\')))%mod; // for creating numbers like 000,001,002 etc.\\n\\t\\t\\t\\n            if(smaller){\\n                    for(int i = 1;i<=9;i++)\\n                    ans = (ans + rec(s1,ind+1,num + i, smaller))%mod;\\n            }else{\\n                    int diff = (s1[ind] - \\'0\\');\\n                    if(diff > 0){\\n                            for(int i = 1;i<diff;i++){\\n                                    ans = (ans + rec(s1,ind+1,num + i,true))%mod;\\n                            }\\n                    }\\n                    if(s1[ind] != \\'0\\')\\n                            ans = (ans + rec(s1,ind+1,num + diff,false))%mod;\\n            }\\n            return dp[ind][num][smaller] = ans;\\n    }    \\n        \\n    int check(string &num1){\\n            \\n            int ans = 0;\\n            for(int i = 0;i<num1.size();i++){\\n                    ans = ans + (num1[i] - \\'0\\');\\n            }\\n            \\n            if(ans >= mn && ans <= mx) return 1;\\n            return 0;\\n    }    \\n        \\n        \\n        \\n        \\n        \\n        \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n            \\n            mn = min_sum;\\n            mx = max_sum;\\n           \\n            memset(dp,-1,sizeof(dp));\\n            int a = rec(num2,0,0,false);\\n            \\n            memset(dp,-1,sizeof(dp));\\n            int b = rec(num1,0,0,false);\\n           \\n          \\n            return( a - b + check(num1) + mod)%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594954,
                "title": "python-easy-digit-dp-recursive-iterative",
                "content": "\\ntotal numbers in [num1, num2] = numbers in [0,num2] - numbers in [0,num1)\\nAs two states always used idx, tight in digit dp\\nand here use another third state to keep track the sum of digits\\nand rest are same as other digit dp\\'s \\n\\n\\n    class Solution:\\n\\t\\t\\tdef count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n\\t\\t\\t\\ts = \"\"\\n\\t\\t\\t\\tmod = 10**9 + 7\\n\\n\\t\\t\\t\\t@lru_cache(None)\\n\\t\\t\\t\\tdef dfs(idx, tight, sm):  \\n\\t\\t\\t\\t\\tnonlocal s,min_sum,max_sum,mod\\n\\n\\t\\t\\t\\t\\tif idx == len(s):\\n\\t\\t\\t\\t\\t\\tif sm >= min_sum and sm <= max_sum:\\n\\t\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\t\\tup = int(s[idx]) if tight else 9  \\n\\t\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\t\\tfor digit in range(up + 1):\\n\\t\\t\\t\\t\\t\\tnewSum = sm + digit\\n\\t\\t\\t\\t\\t\\tif newSum > max_sum: # next digits are more greater than curr so newSum always greater\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tres += dfs(idx + 1, tight and digit == up, newSum)\\n\\t\\t\\t\\t\\t\\tres %= mod\\n\\t\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\t\\ts = num2\\n\\t\\t\\t\\tres = dfs(0,1,0)\\n\\n\\t\\t\\t\\tdfs.cache_clear()  # clear the dp states for new dfs\\n\\n\\t\\t\\t\\ts = str(int(num1)-1)\\n\\t\\t\\t\\tres -= dfs(0,1,0)\\n\\n\\t\\t\\t\\treturn res % mod\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n## Iterative Version\\n\\n\\n\\tmod = 10**9 + 7\\n\\n\\tdef digitDP(s, minSum, maxSum):\\n\\t\\tn = len(s)\\n\\n\\t\\tdp = [[[0]*(maxSum+20) for _ in range(2)] for _ in range(n+1)]\\n\\n\\t\\t# Empty prefix with sum=0\\n\\t\\tdp[0][1][0] = 1\\n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tfor tight in range(2):\\n\\t\\t\\t\\tfor sm in range(maxSum+1):\\n\\t\\t\\t\\t\\tup = int(s[i]) if tight else 9\\n\\t\\t\\t\\t\\tfor digit in range(up + 1):\\n\\t\\t\\t\\t\\t\\tdp[i+1][tight and (digit == up)][sm+digit] += dp[i][tight][sm]\\n\\t\\t\\t\\t\\t\\tdp[i+1][tight and (digit == up)][sm+digit] %= mod\\n\\n\\t\\tres = 0\\n\\t\\tfor i in range(minSum, maxSum+1):\\n\\t\\t\\tres += (dp[n][1][i] + dp[n][0][i])\\n\\t\\t\\tres %= mod\\n\\n\\t\\treturn res % mod\\n\\n\\n\\tclass Solution:\\n\\t\\tdef count(self, num1: str, num2: str, minSum: int, maxSum: int) -> int:\\n\\t\\t\\tres = digitDP(num2,minSum,maxSum) \\n\\t\\t\\tres -= digitDP(str(int(num1)-1),minSum,maxSum)\\n\\t\\t\\treturn res % mod",
                "solutionTags": [],
                "code": "\\ntotal numbers in [num1, num2] = numbers in [0,num2] - numbers in [0,num1)\\nAs two states always used idx, tight in digit dp\\nand here use another third state to keep track the sum of digits\\nand rest are same as other digit dp\\'s \\n\\n\\n    class Solution:\\n\\t\\t\\tdef count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n\\t\\t\\t\\ts = \"\"\\n\\t\\t\\t\\tmod = 10**9 + 7\\n\\n\\t\\t\\t\\t@lru_cache(None)\\n\\t\\t\\t\\tdef dfs(idx, tight, sm):  \\n\\t\\t\\t\\t\\tnonlocal s,min_sum,max_sum,mod\\n\\n\\t\\t\\t\\t\\tif idx == len(s):\\n\\t\\t\\t\\t\\t\\tif sm >= min_sum and sm <= max_sum:\\n\\t\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\t\\tup = int(s[idx]) if tight else 9  \\n\\t\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\t\\tfor digit in range(up + 1):\\n\\t\\t\\t\\t\\t\\tnewSum = sm + digit\\n\\t\\t\\t\\t\\t\\tif newSum > max_sum: # next digits are more greater than curr so newSum always greater\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tres += dfs(idx + 1, tight and digit == up, newSum)\\n\\t\\t\\t\\t\\t\\tres %= mod\\n\\t\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\t\\ts = num2\\n\\t\\t\\t\\tres = dfs(0,1,0)\\n\\n\\t\\t\\t\\tdfs.cache_clear()  # clear the dp states for new dfs\\n\\n\\t\\t\\t\\ts = str(int(num1)-1)\\n\\t\\t\\t\\tres -= dfs(0,1,0)\\n\\n\\t\\t\\t\\treturn res % mod\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n## Iterative Version\\n\\n\\n\\tmod = 10**9 + 7\\n\\n\\tdef digitDP(s, minSum, maxSum):\\n\\t\\tn = len(s)\\n\\n\\t\\tdp = [[[0]*(maxSum+20) for _ in range(2)] for _ in range(n+1)]\\n\\n\\t\\t# Empty prefix with sum=0\\n\\t\\tdp[0][1][0] = 1\\n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tfor tight in range(2):\\n\\t\\t\\t\\tfor sm in range(maxSum+1):\\n\\t\\t\\t\\t\\tup = int(s[i]) if tight else 9\\n\\t\\t\\t\\t\\tfor digit in range(up + 1):\\n\\t\\t\\t\\t\\t\\tdp[i+1][tight and (digit == up)][sm+digit] += dp[i][tight][sm]\\n\\t\\t\\t\\t\\t\\tdp[i+1][tight and (digit == up)][sm+digit] %= mod\\n\\n\\t\\tres = 0\\n\\t\\tfor i in range(minSum, maxSum+1):\\n\\t\\t\\tres += (dp[n][1][i] + dp[n][0][i])\\n\\t\\t\\tres %= mod\\n\\n\\t\\treturn res % mod\\n\\n\\n\\tclass Solution:\\n\\t\\tdef count(self, num1: str, num2: str, minSum: int, maxSum: int) -> int:\\n\\t\\t\\tres = digitDP(num2,minSum,maxSum) \\n\\t\\t\\tres -= digitDP(str(int(num1)-1),minSum,maxSum)\\n\\t\\t\\treturn res % mod",
                "codeTag": "Java"
            },
            {
                "id": 3594897,
                "title": "dp-c-java-python",
                "content": "# Intuition\\nDP, not only for this question but also for similar questions. We can calculate the string digit by digit from the most significant position.\\n\\n\\n# Approach\\n\\n\\nGive a number x (string),  we construct a new string with the same length digit by digit from the most significant digit.\\n\\n\\nLet dp[i][j = 0/1][k] be the partial result, namely the number of strings that satisfy \\n\\n\\n(prefix) length is i,\\nj = 0 means the current prefix equals to x\\u2019s prefix of the same length.\\n       j = 1 means the current prefix is smaller than x\\u2019s prefix of the same length.\\nthe current sum of digits is k.\\n\\n\\nIt\\u2019s simple to right the dp induction if we enumerate the current digit (the least significant).\\nFor instance, if j == 0, the current digit must <= x\\u2019s digit at the same position.\\nAnd if j == 1, the current digit is arbitrary. This is just like the alphabet\\'s lexical order.\\n\\n\\nNote the dp induction relies on the value of x (which is hidden).\\nThen the number of strings that are no larger than x with digit sum in the range of [min_sum, max_sum] is\\nSigma (dp[length_of_x][j = 0/1][i]) where i is from min_sum to max_sum.\\n\\n\\nIf we create this helper function, the final answer is just \\nhelper(num2) - helper(num1 - 1) (we need to make num1 as an integer then minus 1, and change it back to string).\\nFor implementation, we can calculate helper(num2) - helper(num1) and if num1 is also one answer, we add the final result by 1 to avoid doing the \\u201C-1\\u201D in the string.\\n\\n\\n\\n\\n# Complexity\\n\\n\\n- Time complexity:\\nO(num2.length() * min(num2.length() * 9, max_sum) * 20)\\n- Space complexity:\\nO(min(num2.length() * 9, max_sum))\\n\\n\\n# Code\\n\\n\\nC++\\n```\\nclass Solution {\\n    const int M = 1000000007;\\n    \\n    void add(int &x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }\\n    }\\n    \\n    void sub(int &x, int y) {\\n        if ((x -= y) < 0) {\\n            x += M;\\n        }\\n    }\\n    \\n    int count(const string &s, int min_sum, int max_sum) {\\n        const int n = s.length();\\n        const int m = min(max_sum, 9 * n);\\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(2, vector<int>(m + 1)));\\n        dp[0][0][0] = 1;\\n        int last = 0;\\n        for (int i = 0, p = 0; i < n; ++i, p +=9) {\\n            const int now = last ^ 1;\\n            dp[now] = vector<vector<int>>(2, vector<int>(m + 1));\\n            for (int j = 0; j < 2; ++j) {\\n                for (int k = 0; k <= m && k <= p; ++k) {\\n                    if (dp[last][j][k] == 0) {\\n                        continue;\\n                    }\\n                    for (char c = j ? \\'9\\' : s[i]; c >= \\'0\\'; --c) {\\n                        const int q = k + c - \\'0\\';\\n                        if (q <= m) {\\n                           add(dp[now][j || c < s[i]][q], dp[last][j][k]); \\n                        }\\n                    }\\n                }\\n            }\\n            last ^= 1;\\n        }\\n        int r = 0;\\n        for (int i = 0; i < 2; ++i) {\\n            for (int j = min_sum; j <= m; ++j) {\\n                add(r, dp[last][i][j]);\\n                \\n            }\\n        }\\n        return r;\\n        \\n    }\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int s = 0;\\n        for (char c : num1) {\\n            s += c - \\'0\\'; \\n        }\\n        int r = count(num2, min_sum, max_sum);\\n        sub(r, count(num1, min_sum, max_sum));\\n        if (s >= min_sum && s <= max_sum) {\\n            add(r, 1);\\n        } \\n        return r;\\n    }\\n};\\n\\n\\n```\\n\\n\\nJava\\n```\\nclass Solution {\\n    private static final int M = 1000000007;\\n\\n\\n    private int add(int x, int y) {\\n        int sum = x + y;\\n        if (sum >= M) {\\n            sum -= M;\\n        }\\n        return sum;\\n    }\\n\\n\\n    private int sub(int x, int y) {\\n        int diff = x - y;\\n        if (diff < 0) {\\n            diff += M;\\n        }\\n        return diff;\\n    }\\n\\n\\n    private int count(String s, int min_sum, int max_sum) {\\n        final int n = s.length(), m = Math.min(max_sum, 9 * n);\\n        int[][][] dp = new int[2][2][m + 1];\\n        dp[0][0][0] = 1;\\n        int last = 0;\\n        for (int i = 0, p = 0; i < n; ++i, p += 9) {\\n            final int now = last ^ 1;\\n            dp[now] = new int[2][m + 1];\\n            for (int j = 0; j < 2; ++j) {\\n                for (int k = 0; k <= m && k <= p; ++k) {\\n                    if (dp[last][j][k] == 0) {\\n                        continue;\\n                    }\\n                    for (char c = j != 0 ? \\'9\\' : s.charAt(i); c >= \\'0\\'; --c) {\\n                        final int q = k + c - \\'0\\';\\n                        if (q <= m) {\\n                            dp[now][j != 0 || c < s.charAt(i) ? 1 : 0][q] = add(dp[now][j != 0 || c < s.charAt(i) ? 1 : 0][q], dp[last][j][k]);\\n                        }\\n                    }\\n                }\\n            }\\n            last ^= 1;\\n        }\\n        int r = 0;\\n        for (int i = 0; i < 2; ++i) {\\n            for (int j = min_sum; j <= m; ++j) {\\n                r = add(r, dp[last][i][j]);\\n            }\\n        }\\n        return r;\\n    }\\n\\n\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        int s = 0;\\n        for (char c : num1.toCharArray()) {\\n            s += c - \\'0\\';\\n        }\\n        int r = count(num2, min_sum, max_sum);\\n        r = sub(r, count(num1, min_sum, max_sum));\\n        if (s >= min_sum && s <= max_sum) {\\n            r = add(r, 1);\\n        }\\n        return r;\\n    }\\n}\\n\\n\\n\\n\\n```\\n\\n\\nPython3\\n```\\nclass Solution:\\n    M = 1000000007\\n\\n\\n    def add(self, x, y) -> int:\\n        x += y\\n        if x >= self.M:\\n            x -= self.M\\n        return x\\n\\n\\n    def sub(self, x, y) -> int:\\n        x -= y\\n        if x < 0:\\n            x += self.M\\n        return x\\n\\n\\n    def count_strings(self, s, min_sum, max_sum) -> int:\\n        n = len(s)\\n        m = min(max_sum, 9 * n)\\n        dp = [[[0 for _ in range(m + 1)] for _ in range(2)] for _ in range(2)]\\n        dp[0][0][0] = 1\\n        last = 0\\n        for i in range(n):\\n            p = i * 9\\n            now = last ^ 1\\n            dp[now] = [[0 for _ in range(m + 1)] for _ in range(2)]\\n            for j in range(2):\\n                for k in range(min(m, p) + 1):\\n                    if dp[last][j][k] == 0:\\n                        continue\\n                    for c in range(ord(\\'9\\') if j else ord(s[i]), ord(\\'0\\') - 1, -1):\\n                        q = k + c - ord(\\'0\\')\\n                        if q <= m:\\n                            dp[now][j or (c < ord(s[i]))][q] = self.add(\\n                                dp[now][j or (c < ord(s[i]))][q], dp[last][j][k]\\n                            )\\n            last ^= 1\\n        r = 0\\n        for i in range(2):\\n            for j in range(min_sum, m + 1):\\n                r = self.add(r, dp[last][i][j])\\n        return r\\n\\n\\n    def count(self, num1, num2, min_sum, max_sum) -> int:\\n        s = sum(int(c) for c in num1)\\n        r = self.count_strings(num2, min_sum, max_sum)\\n        r = self.sub(r, self.count_strings(num1, min_sum, max_sum))\\n        if min_sum <= s <= max_sum:\\n            r = self.add(r, 1)\\n        return r\\n\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    const int M = 1000000007;\\n    \\n    void add(int &x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }\\n    }\\n    \\n    void sub(int &x, int y) {\\n        if ((x -= y) < 0) {\\n            x += M;\\n        }\\n    }\\n    \\n    int count(const string &s, int min_sum, int max_sum) {\\n        const int n = s.length();\\n        const int m = min(max_sum, 9 * n);\\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(2, vector<int>(m + 1)));\\n        dp[0][0][0] = 1;\\n        int last = 0;\\n        for (int i = 0, p = 0; i < n; ++i, p +=9) {\\n            const int now = last ^ 1;\\n            dp[now] = vector<vector<int>>(2, vector<int>(m + 1));\\n            for (int j = 0; j < 2; ++j) {\\n                for (int k = 0; k <= m && k <= p; ++k) {\\n                    if (dp[last][j][k] == 0) {\\n                        continue;\\n                    }\\n                    for (char c = j ? \\'9\\' : s[i]; c >= \\'0\\'; --c) {\\n                        const int q = k + c - \\'0\\';\\n                        if (q <= m) {\\n                           add(dp[now][j || c < s[i]][q], dp[last][j][k]); \\n                        }\\n                    }\\n                }\\n            }\\n            last ^= 1;\\n        }\\n        int r = 0;\\n        for (int i = 0; i < 2; ++i) {\\n            for (int j = min_sum; j <= m; ++j) {\\n                add(r, dp[last][i][j]);\\n                \\n            }\\n        }\\n        return r;\\n        \\n    }\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int s = 0;\\n        for (char c : num1) {\\n            s += c - \\'0\\'; \\n        }\\n        int r = count(num2, min_sum, max_sum);\\n        sub(r, count(num1, min_sum, max_sum));\\n        if (s >= min_sum && s <= max_sum) {\\n            add(r, 1);\\n        } \\n        return r;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\n    private static final int M = 1000000007;\\n\\n\\n    private int add(int x, int y) {\\n        int sum = x + y;\\n        if (sum >= M) {\\n            sum -= M;\\n        }\\n        return sum;\\n    }\\n\\n\\n    private int sub(int x, int y) {\\n        int diff = x - y;\\n        if (diff < 0) {\\n            diff += M;\\n        }\\n        return diff;\\n    }\\n\\n\\n    private int count(String s, int min_sum, int max_sum) {\\n        final int n = s.length(), m = Math.min(max_sum, 9 * n);\\n        int[][][] dp = new int[2][2][m + 1];\\n        dp[0][0][0] = 1;\\n        int last = 0;\\n        for (int i = 0, p = 0; i < n; ++i, p += 9) {\\n            final int now = last ^ 1;\\n            dp[now] = new int[2][m + 1];\\n            for (int j = 0; j < 2; ++j) {\\n                for (int k = 0; k <= m && k <= p; ++k) {\\n                    if (dp[last][j][k] == 0) {\\n                        continue;\\n                    }\\n                    for (char c = j != 0 ? \\'9\\' : s.charAt(i); c >= \\'0\\'; --c) {\\n                        final int q = k + c - \\'0\\';\\n                        if (q <= m) {\\n                            dp[now][j != 0 || c < s.charAt(i) ? 1 : 0][q] = add(dp[now][j != 0 || c < s.charAt(i) ? 1 : 0][q], dp[last][j][k]);\\n                        }\\n                    }\\n                }\\n            }\\n            last ^= 1;\\n        }\\n        int r = 0;\\n        for (int i = 0; i < 2; ++i) {\\n            for (int j = min_sum; j <= m; ++j) {\\n                r = add(r, dp[last][i][j]);\\n            }\\n        }\\n        return r;\\n    }\\n\\n\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        int s = 0;\\n        for (char c : num1.toCharArray()) {\\n            s += c - \\'0\\';\\n        }\\n        int r = count(num2, min_sum, max_sum);\\n        r = sub(r, count(num1, min_sum, max_sum));\\n        if (s >= min_sum && s <= max_sum) {\\n            r = add(r, 1);\\n        }\\n        return r;\\n    }\\n}\\n\\n\\n\\n\\n```\n```\\nclass Solution:\\n    M = 1000000007\\n\\n\\n    def add(self, x, y) -> int:\\n        x += y\\n        if x >= self.M:\\n            x -= self.M\\n        return x\\n\\n\\n    def sub(self, x, y) -> int:\\n        x -= y\\n        if x < 0:\\n            x += self.M\\n        return x\\n\\n\\n    def count_strings(self, s, min_sum, max_sum) -> int:\\n        n = len(s)\\n        m = min(max_sum, 9 * n)\\n        dp = [[[0 for _ in range(m + 1)] for _ in range(2)] for _ in range(2)]\\n        dp[0][0][0] = 1\\n        last = 0\\n        for i in range(n):\\n            p = i * 9\\n            now = last ^ 1\\n            dp[now] = [[0 for _ in range(m + 1)] for _ in range(2)]\\n            for j in range(2):\\n                for k in range(min(m, p) + 1):\\n                    if dp[last][j][k] == 0:\\n                        continue\\n                    for c in range(ord(\\'9\\') if j else ord(s[i]), ord(\\'0\\') - 1, -1):\\n                        q = k + c - ord(\\'0\\')\\n                        if q <= m:\\n                            dp[now][j or (c < ord(s[i]))][q] = self.add(\\n                                dp[now][j or (c < ord(s[i]))][q], dp[last][j][k]\\n                            )\\n            last ^= 1\\n        r = 0\\n        for i in range(2):\\n            for j in range(min_sum, m + 1):\\n                r = self.add(r, dp[last][i][j])\\n        return r\\n\\n\\n    def count(self, num1, num2, min_sum, max_sum) -> int:\\n        s = sum(int(c) for c in num1)\\n        r = self.count_strings(num2, min_sum, max_sum)\\n        r = self.sub(r, self.count_strings(num1, min_sum, max_sum))\\n        if min_sum <= s <= max_sum:\\n            r = self.add(r, 1)\\n        return r\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594987,
                "title": "top-down-dp",
                "content": "We count good integers less than or equal `num2`, and less than `num1`, and return the difference.\\n\\nGenerating numbers of all sizes, less than (or equal) a number is a classic DP problem.\\n\\n> Note the `equal` parameter that controls whether we include the number itself.\\n\\nThe twist here is to check if the sum of digits is within the min/max. \\n\\n> Also note that the sum of digits cannot exceed `9 * 22`, which is about twice as small as `400`.\\n\\n**C++**\\n```cpp\\nint dp[23][9 * 22][2], mod = 1000000007;\\nclass Solution {\\npublic:\\nint dfs(int i, int sum, int min_sum, int max_sum, const string &num, bool lim, bool equal) {\\n    if (i == 0)\\n        memset(dp, -1, (num.size()) * sizeof(dp[0]));\\n    if (i == num.size() || sum > max_sum)\\n        return sum >= min_sum && sum <= max_sum && (equal || !lim);\\n    if (dp[i][sum][lim] == -1)\\n        for (char n = \\'0\\'; n <= (lim ? num[i] : \\'9\\'); ++n)\\n            dp[i][sum][lim] = (max(0, dp[i][sum][lim]) + \\n                dfs(i + 1, sum + n - \\'0\\', min_sum, max_sum, num, lim && n == num[i], equal)) % 1000000007;\\n    return dp[i][sum][lim];\\n}\\nint count(string num1, string num2, int min_sum, int max_sum) {\\n    return (mod + dfs(0, 0, min_sum, max_sum, num2, true, true)\\n                - dfs(0, 0, min_sum, max_sum, num1, true, false)) % mod;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[23][9 * 22][2], mod = 1000000007;\\nclass Solution {\\npublic:\\nint dfs(int i, int sum, int min_sum, int max_sum, const string &num, bool lim, bool equal) {\\n    if (i == 0)\\n        memset(dp, -1, (num.size()) * sizeof(dp[0]));\\n    if (i == num.size() || sum > max_sum)\\n        return sum >= min_sum && sum <= max_sum && (equal || !lim);\\n    if (dp[i][sum][lim] == -1)\\n        for (char n = \\'0\\'; n <= (lim ? num[i] : \\'9\\'); ++n)\\n            dp[i][sum][lim] = (max(0, dp[i][sum][lim]) + \\n                dfs(i + 1, sum + n - \\'0\\', min_sum, max_sum, num, lim && n == num[i], equal)) % 1000000007;\\n    return dp[i][sum][lim];\\n}\\nint count(string num1, string num2, int min_sum, int max_sum) {\\n    return (mod + dfs(0, 0, min_sum, max_sum, num2, true, true)\\n                - dfs(0, 0, min_sum, max_sum, num1, true, false)) % mod;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595728,
                "title": "video-explanation-digit-dp-explained-from-scratch",
                "content": "# Explanation\\n\\n[Click here for the video](https://youtu.be/ZsHbl-DEjX8)\\n\\n# Code\\n```\\nconst int MOD = 1e9+7;\\nconst int N = 23;\\n\\nint dp[2][23][200];\\n\\nclass Solution {\\n    \\n    string s;\\n    int max_sum, min_sum;\\n    \\n    string SubtractOne (string x) {\\n        int n = x.length();\\n        \\n        int last_non_zero_ind = n-1;\\n        while (last_non_zero_ind >= 0) {\\n            if (x[last_non_zero_ind] >= \\'1\\') break;\\n            last_non_zero_ind --;\\n        }\\n        \\n        x[last_non_zero_ind] --;\\n        for (int j = last_non_zero_ind+1; j < n; j ++) x[j] = \\'9\\';\\n        \\n        return x;\\n    }\\n    \\n    int GoodIntegers (bool is_smaller, int ind, int sum) {\\n        if (ind == s.size()) {\\n            if (min_sum <= sum && sum <= max_sum) return 1;\\n            return 0;\\n        }\\n        \\n        int &ans = dp[is_smaller][ind][sum];\\n        if (ans != -1) return ans;\\n        \\n        ans = 0;\\n        int st = 0, ed = 9;\\n        if (!is_smaller) ed = s[ind] - \\'0\\';\\n        \\n        for (int i = st; i <= ed; i ++) {\\n            ans = (ans + GoodIntegers((is_smaller == false && i == ed)? false : true, ind+1, sum+i)) % MOD;\\n        }\\n        return ans;\\n    }\\n    \\n    void buildS (string x) {\\n        int x_len = x.length();\\n        \\n        s = \"\";\\n        for (int j = 0; j < (N - x_len); j ++) s += \\'0\\';\\n        s += x;\\n    }\\n    \\n    int GoodIntegersLessThanX (string x) {\\n        memset(dp, -1, sizeof(dp));\\n        \\n        buildS (x);\\n        return GoodIntegers(false, 0, 0);\\n    }\\n    \\npublic:\\n    int count(string num1, string num2, int _min_sum, int _max_sum) {\\n        max_sum = _max_sum;\\n        min_sum = _min_sum;\\n        \\n        return (GoodIntegersLessThanX(num2) - GoodIntegersLessThanX(SubtractOne(num1)) + MOD) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int MOD = 1e9+7;\\nconst int N = 23;\\n\\nint dp[2][23][200];\\n\\nclass Solution {\\n    \\n    string s;\\n    int max_sum, min_sum;\\n    \\n    string SubtractOne (string x) {\\n        int n = x.length();\\n        \\n        int last_non_zero_ind = n-1;\\n        while (last_non_zero_ind >= 0) {\\n            if (x[last_non_zero_ind] >= \\'1\\') break;\\n            last_non_zero_ind --;\\n        }\\n        \\n        x[last_non_zero_ind] --;\\n        for (int j = last_non_zero_ind+1; j < n; j ++) x[j] = \\'9\\';\\n        \\n        return x;\\n    }\\n    \\n    int GoodIntegers (bool is_smaller, int ind, int sum) {\\n        if (ind == s.size()) {\\n            if (min_sum <= sum && sum <= max_sum) return 1;\\n            return 0;\\n        }\\n        \\n        int &ans = dp[is_smaller][ind][sum];\\n        if (ans != -1) return ans;\\n        \\n        ans = 0;\\n        int st = 0, ed = 9;\\n        if (!is_smaller) ed = s[ind] - \\'0\\';\\n        \\n        for (int i = st; i <= ed; i ++) {\\n            ans = (ans + GoodIntegers((is_smaller == false && i == ed)? false : true, ind+1, sum+i)) % MOD;\\n        }\\n        return ans;\\n    }\\n    \\n    void buildS (string x) {\\n        int x_len = x.length();\\n        \\n        s = \"\";\\n        for (int j = 0; j < (N - x_len); j ++) s += \\'0\\';\\n        s += x;\\n    }\\n    \\n    int GoodIntegersLessThanX (string x) {\\n        memset(dp, -1, sizeof(dp));\\n        \\n        buildS (x);\\n        return GoodIntegers(false, 0, 0);\\n    }\\n    \\npublic:\\n    int count(string num1, string num2, int _min_sum, int _max_sum) {\\n        max_sum = _max_sum;\\n        min_sum = _min_sum;\\n        \\n        return (GoodIntegersLessThanX(num2) - GoodIntegersLessThanX(SubtractOne(num1)) + MOD) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853979,
                "title": "image-solution-easy-to-understand-function-digit-dp-c",
                "content": "\\n\\n# Approach\\n-  we want number\\'s which sum is valid in given range\\n- function give the all number which range between 0 to $num1$ same thing we do with $num2$ , after that subtract $num1\\'s$ result from $num2\\'s$ result, because left inclusive then we manuall calculate single $num1$ digit sum and check is it in given range then add 1 else 0.\\n- $f(n, sum, tight)$ , n denote the index from right end sum carry the digit. suppose.\\n- given number 524 total 3 digit so,\\n- uper bound for index 2 is 4.\\n- tight will be false for 0,1,2,3 and true for 4. and so on..  \\n- $f(3, 1, 0) = f(2,0,0)+f(2,0,1)+f(2,0,2)+f(2,0,3)+f(2,1,4)$\\n![1.jpg](https://assets.leetcode.com/users/images/84b18f5b-4171-40d4-8e9d-198600afe532_1690992073.216345.jpeg)\\n\\n\\n# Complexity \\n- Time complexity: O($numberOfDigit*maxSum$)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O($numberOfDigit*maxSum$)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    const int m = 1e9 + 7;\\n    ll dp[100][401][2];\\n    int f(int n, int sum, bool tight, int min_sum, int max_sum, string &num){\\n        if(n == 0){\\n            if(sum >= min_sum && sum <= max_sum)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[n][sum][tight] != -1) return dp[n][sum][tight];\\n        ll ans = 0;\\n        ll ub = tight ? (num[num.size() - n])-\\'0\\' : 9;\\n        for(ll dig = 0; dig <= ub; dig++){\\n            ans += f(n-1, sum+dig, tight & (ub == dig), min_sum, max_sum, num)%m;\\n        } \\n        return dp[n][sum][tight] = ans%m;\\n\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof(dp));\\n        ll left = f(num1.size(), 0, 1, min_sum, max_sum, num1) % m;\\n        memset(dp, -1, sizeof(dp));\\n        ll right = f(num2.size(), 0, 1, min_sum, max_sum, num2) % m;\\n        ll result = right - left;\\n        result %= m;\\n        result += m;\\n        result %= m;\\n        ll atNum1 = 0;\\n        for(int i = 0; i < num1.size(); i++)\\n            atNum1 += (num1[i] - \\'0\\');\\n        return (result + ((atNum1 >= min_sum && atNum1 <= max_sum) ? 1 : 0))%m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    const int m = 1e9 + 7;\\n    ll dp[100][401][2];\\n    int f(int n, int sum, bool tight, int min_sum, int max_sum, string &num){\\n        if(n == 0){\\n            if(sum >= min_sum && sum <= max_sum)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[n][sum][tight] != -1) return dp[n][sum][tight];\\n        ll ans = 0;\\n        ll ub = tight ? (num[num.size() - n])-\\'0\\' : 9;\\n        for(ll dig = 0; dig <= ub; dig++){\\n            ans += f(n-1, sum+dig, tight & (ub == dig), min_sum, max_sum, num)%m;\\n        } \\n        return dp[n][sum][tight] = ans%m;\\n\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof(dp));\\n        ll left = f(num1.size(), 0, 1, min_sum, max_sum, num1) % m;\\n        memset(dp, -1, sizeof(dp));\\n        ll right = f(num2.size(), 0, 1, min_sum, max_sum, num2) % m;\\n        ll result = right - left;\\n        result %= m;\\n        result += m;\\n        result %= m;\\n        ll atNum1 = 0;\\n        for(int i = 0; i < num1.size(); i++)\\n            atNum1 += (num1[i] - \\'0\\');\\n        return (result + ((atNum1 >= min_sum && atNum1 <= max_sum) ? 1 : 0))%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595261,
                "title": "c-digit-dp-easy-approach-recursion",
                "content": "### \\uD83D\\uDD25Donn Forget to Upvote if you liked the approach.\\uD83D\\uDD25\\n# Approach\\n***The Problem is a simple variation of ordinary Digit DP with two numbers.*** The Approach is like we\\'ll move to each digit of the number and consider the cases as:\\n\\n1- If the no. that is formed by now is equal to the *num1* then we\\'ll give values to the current digit in between the range of the digit of *num1* at that index to 9.\\n2- If the no. that is formed by now is equal to the *num2* then we\\'ll give values to the current digit in between the range of 0 to the digit of *num2* at that index.\\n3- If the no. that is formed by now is equal to *num2* and *num1* aswell then we\\'ll give values to the current digit in between the range of the digit of *num1* at that index to the digit of *num2* at that index.\\n4- If none of the cases are true we\\'ll give values to the current index of the number from 0 to 9.\\n\\nIn the end we\\'ll check if the sum of the digits is in between the *min_sum* and *max_sum* we\\'ll increase our count by 1.\\nThen we\\'ll apply dp to the approach.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int mod=1000000007;\\n    long long int dp[250][25][2][2];\\n    long long int solve(int itr,int curr_sum,int cap1,int cap2,string min, string max,int mins,int maxs)\\n    {\\n        if(itr>=max.size())\\n        {\\n            if(curr_sum>=mins&&curr_sum<=maxs)return 1;\\n            return 0;\\n        }\\n        if(dp[curr_sum][itr][cap1][cap2]!=-1) return dp[curr_sum][itr][cap1][cap2];\\n        long long int sum=0;\\n        if(cap1==0&&cap2==0)\\n        {\\n            for(int i=0;i<=9;i++)\\n            {\\n                sum=(sum+solve(itr+1,curr_sum+i,0,0,min,max,mins,maxs))%mod;\\n            }\\n        }\\n        else if(cap1==1&&cap2==1)\\n        {\\n            for(int i=min[itr]-\\'0\\';i<=max[itr]-\\'0\\';i++)\\n            {\\n                if(i==min[itr]-\\'0\\'&&i==max[itr]-\\'0\\')sum=(sum+solve(itr+1,curr_sum+i,1,1,min,max,mins,maxs))%mod;\\n                else if(i==min[itr]-\\'0\\')sum=(sum+solve(itr+1,i+curr_sum,1,0,min,max,mins,maxs))%mod;\\n                else if(i==max[itr]-\\'0\\')sum=(sum+solve(itr+1,i+curr_sum,0,1,min,max,mins,maxs))%mod;\\n                else\\n                sum=(sum+solve(itr+1,i+curr_sum,0,0,min,max,mins,maxs))%mod;\\n            }\\n        }\\n        else if(cap1==1)\\n        {\\n            for(int i=min[itr]-\\'0\\';i<=9;i++)\\n            {\\n                if(i==min[itr]-\\'0\\')sum=(sum+solve(itr+1,i+curr_sum,1,0,min,max,mins,maxs))%mod;\\n                else\\n                sum=(sum+solve(itr+1,i+curr_sum,0,0,min,max,mins,maxs))%mod;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<=max[itr]-\\'0\\';i++)\\n            {\\n                if(i==max[itr]-\\'0\\')sum=(sum+solve(itr+1,i+curr_sum,0,1,min,max,mins,maxs))%mod;\\n                else\\n                sum=(sum+solve(itr+1,i+curr_sum,0,0,min,max,mins,maxs))%mod;\\n            }\\n        }\\n        return dp[curr_sum][itr][cap1][cap2]=sum;\\n    }\\n    \\n    \\n    \\n    int count(string n1, string n2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof(dp));\\n        string num1,num2;\\n//making num1 and num2 of same size =23 to avoid any edge case issue.\\n        for(int i=0;i<23-n1.size();i++)num1+=\"0\";\\n        for(int i=0;i<23-n2.size();i++)num2+=\"0\";\\n        num1+=n1;\\n        num2+=n2;\\n       long long int sum=0;\\n        for(int i=num1[0]-\\'0\\';i<=num2[0]-\\'0\\';i++)\\n        {\\n            if(i==num1[0]-\\'0\\'&&i==num2[0]-\\'0\\') sum=(sum+solve(0,i,1,1,num1,num2,min_sum,max_sum))%mod;\\n            else if(i==num1[0]-\\'0\\')\\n            sum=(sum+solve(0,i,1,0,num1,num2,min_sum,max_sum))%mod;\\n            else if(i==num2[0]-\\'0\\')\\n            sum=(sum+solve(0,i,0,1,num1,num2,min_sum,max_sum))%mod;\\n            else\\n            sum=(sum+solve(0,i,0,0,num1,num2,min_sum,max_sum))%mod;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mod=1000000007;\\n    long long int dp[250][25][2][2];\\n    long long int solve(int itr,int curr_sum,int cap1,int cap2,string min, string max,int mins,int maxs)\\n    {\\n        if(itr>=max.size())\\n        {\\n            if(curr_sum>=mins&&curr_sum<=maxs)return 1;\\n            return 0;\\n        }\\n        if(dp[curr_sum][itr][cap1][cap2]!=-1) return dp[curr_sum][itr][cap1][cap2];\\n        long long int sum=0;\\n        if(cap1==0&&cap2==0)\\n        {\\n            for(int i=0;i<=9;i++)\\n            {\\n                sum=(sum+solve(itr+1,curr_sum+i,0,0,min,max,mins,maxs))%mod;\\n            }\\n        }\\n        else if(cap1==1&&cap2==1)\\n        {\\n            for(int i=min[itr]-\\'0\\';i<=max[itr]-\\'0\\';i++)\\n            {\\n                if(i==min[itr]-\\'0\\'&&i==max[itr]-\\'0\\')sum=(sum+solve(itr+1,curr_sum+i,1,1,min,max,mins,maxs))%mod;\\n                else if(i==min[itr]-\\'0\\')sum=(sum+solve(itr+1,i+curr_sum,1,0,min,max,mins,maxs))%mod;\\n                else if(i==max[itr]-\\'0\\')sum=(sum+solve(itr+1,i+curr_sum,0,1,min,max,mins,maxs))%mod;\\n                else\\n                sum=(sum+solve(itr+1,i+curr_sum,0,0,min,max,mins,maxs))%mod;\\n            }\\n        }\\n        else if(cap1==1)\\n        {\\n            for(int i=min[itr]-\\'0\\';i<=9;i++)\\n            {\\n                if(i==min[itr]-\\'0\\')sum=(sum+solve(itr+1,i+curr_sum,1,0,min,max,mins,maxs))%mod;\\n                else\\n                sum=(sum+solve(itr+1,i+curr_sum,0,0,min,max,mins,maxs))%mod;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<=max[itr]-\\'0\\';i++)\\n            {\\n                if(i==max[itr]-\\'0\\')sum=(sum+solve(itr+1,i+curr_sum,0,1,min,max,mins,maxs))%mod;\\n                else\\n                sum=(sum+solve(itr+1,i+curr_sum,0,0,min,max,mins,maxs))%mod;\\n            }\\n        }\\n        return dp[curr_sum][itr][cap1][cap2]=sum;\\n    }\\n    \\n    \\n    \\n    int count(string n1, string n2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof(dp));\\n        string num1,num2;\\n//making num1 and num2 of same size =23 to avoid any edge case issue.\\n        for(int i=0;i<23-n1.size();i++)num1+=\"0\";\\n        for(int i=0;i<23-n2.size();i++)num2+=\"0\";\\n        num1+=n1;\\n        num2+=n2;\\n       long long int sum=0;\\n        for(int i=num1[0]-\\'0\\';i<=num2[0]-\\'0\\';i++)\\n        {\\n            if(i==num1[0]-\\'0\\'&&i==num2[0]-\\'0\\') sum=(sum+solve(0,i,1,1,num1,num2,min_sum,max_sum))%mod;\\n            else if(i==num1[0]-\\'0\\')\\n            sum=(sum+solve(0,i,1,0,num1,num2,min_sum,max_sum))%mod;\\n            else if(i==num2[0]-\\'0\\')\\n            sum=(sum+solve(0,i,0,1,num1,num2,min_sum,max_sum))%mod;\\n            else\\n            sum=(sum+solve(0,i,0,0,num1,num2,min_sum,max_sum))%mod;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612679,
                "title": "c-step-by-step-explanation-digit-dp-concept",
                "content": "Firstly observe the constrains we are give that num1 and num2 will have max limit 1e22 so number so index for maximum no will be from 0-22 for 1e22. Talking about the maximum sum of digits its max limit is 400 so sum can go from 0 to 400. Now coming to third parameter is a boolean named integer tight whose value can be 0 or 1 so it can have size 2.\\nso our dp array can have size 23X401X2;\\nwhere first parameter is length of the number or the index that we are currently on . 2 nd is the maximum sum of digits and third is whether to include digits from 0-9 at current index or to include digits from 0 to max value at current index.\\n\\nLet\\'s take an example for understanding the concept suppose you are given\\nnum= 87643\\nnow we have to find numbers between 0 to num whose sum of digits lie between min_sum and max_sum.\\nTo construct numbers which are lesser than num the first digit should be between 0 to 8.\\nthat is what value tight signifies that the value should lie between a given range of digits.\\nfor 2 nd digit if the value at first place is less than 8 then we can include all numbers from 0 to 9 at 2 nd place and remaining place .Otherwise if digit at 1 st position is 8 we can only include nos less than equal to 7 at 2 nd place this is what newtight value refers to.\\nNow to get our ans we find ans from 0 to num1 and then 0 to num2. We substract and get the result.But we have excluded num1 if it was a ans. So we check for num1 individully by calculating sum of its digit and checking condition. we increase ans if condition is satisfied.\\n\\n**Please Upvote if this was helpful!**\\n```\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    int dp[30][401][2];\\n    int digitsum(string str){\\n        int n= str.size();\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            ans+= str[i]-\\'0\\';            \\n        }\\n        return ans;\\n    }\\n int solve(string num, int minSum, int maxSum, int tight, int currSum, int index){\\n        if(index == num.length()){\\n            return (currSum>=minSum && currSum <= maxSum)?1:0;\\n        }\\n        \\n        if(dp[index][currSum][tight]!=-1){\\n            return dp[index][currSum][tight];\\n        }\\n        \\n        int ans = 0;\\n        int end = (tight==1)?num[index]-\\'0\\':9;\\n        for(int curr = 0;curr<=end;curr++){\\n            int newTight = (tight==1 && curr==end)?1:0;\\n            ans =  ans + solve(num, minSum, maxSum, newTight, currSum+curr, index+1);\\n            ans %= MOD;\\n        }\\n        return dp[index][currSum][tight] = ans;\\n    \\n    }\\n    \\n    int count(string num1, string num2, int minSum, int maxSum) {\\n        memset(dp,-1,sizeof(dp));\\n        int n1 = num1.length();\\n        int n2 = num2.length();   \\n        int ans = solve(num2, minSum,maxSum,1,0,0);\\n          memset(dp,-1,sizeof(dp));\\n        ans -= solve(num1, minSum,maxSum,1,0,0);\\n        int digitSum  = digitsum(num1); \\n        if(digitSum<=maxSum && digitSum>=minSum){\\n          ans++;  \\n        } \\n        ans %= MOD;\\n        \\n        return (ans + MOD) % MOD;\\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int MOD=1e9+7;\\n    int dp[30][401][2];\\n    int digitsum(string str){\\n        int n= str.size();\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            ans+= str[i]-\\'0\\';            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3595744,
                "title": "easy-to-understand-explanation-digit-dp-c",
                "content": "# Intuition\\nThis problem looks very similar to classical problems of digit dp (which you can find on Kartik Arora\\u2019s YT channel, I will add playlist link in comments)\\nSo my mind directly went to digit dp.\\n\\n# Approach\\nWe can have 22 digits max in our number and we have a range in which our number should lie i.e. nums1 to nums2.\\n\\nSo final ans = ans(0 to nums2) - ans(0 to (nums1-1))\\nOr\\nans = [ans(0 to nums2) - ans(0 to nums1)] + 0 or 1(whether nums1 is following condition or not)\\n\\nWe can run a recursion which runs on all the indexes of the string and puts different numbers on it to calculate answer.\\n\\nRecursion function:\\nrec(int ind, int sum, bool restriction, string& nums)\\n\\nind \\u2014> current index of string\\nsum \\u2014> digit sum till index-1\\nrestriction \\u2014> True or false based on whether we can place all digits from 0 to 9 on current index or not.\\n\\nIf true we can place digits from 0 to str[ind] only\\nelse we can put all digits\\n\\nFor ex: number = 5834\\n\\nIf I am at 0 index and I am placing 5 there \\nThen at next index I can only place digits from 0 to 8\\nOtherwise the formed number will exceed the given number in function\\n\\nBut if I am placing any number < 5 at 0 index\\nThen I can place any digit at all rest positions because they will always be lesser than the given number.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(22 * 198 * 2 * 9)\\nO(index * maxSum * 2 * 9)\\nindex = index of string\\nmaxSum = 198(9*22)\\n\\n- Space complexity:\\nO(22 * 198 * 2)\\n\\n# Code\\n```\\ntypedef long long ll;\\n#define mod 1000000007\\n#define all(x) begin(x), end(x)\\n\\nclass Solution {\\npublic:\\n\\tll minS, maxS;\\n\\tunordered_map<ll, unordered_map<ll, unordered_map<bool, ll>>> dp;\\n\\n\\tll rec(int ind, int sum, bool restriction, string& str) {\\n\\t\\tif (ind >= str.size())\\n\\t\\t\\tif (sum >= minS && sum <= maxS)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\tif (sum > maxS)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (dp.find(ind) != end(dp) && dp[ind].find(sum) != end(dp[ind]))\\n\\t\\t\\tif (dp[ind][sum].find(restriction) != end(dp[ind][sum]))\\n\\t\\t\\t\\treturn dp[ind][sum][restriction];\\n\\n\\t\\tll ans = 0;\\n\\t\\tif (restriction)\\n\\t\\t{\\n\\t\\t\\tfor (char ch = \\'0\\'; ch <= str[ind]; ch++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans += rec(ind + 1, sum + (ch - \\'0\\'), ch == str[ind] ? true : false, str);\\n\\t\\t\\t\\tans %= mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor (char ch = \\'0\\'; ch <= \\'9\\'; ch++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans += rec(ind + 1, sum + (ch - \\'0\\'), false, str);\\n\\t\\t\\t\\tans %= mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[ind][sum][restriction] = ans % mod;\\n\\t}\\n\\n\\tint count(string num1, string num2, int min_sum, int max_sum) {\\n\\t\\tminS = min_sum;\\n\\t\\tmaxS = max_sum;\\n\\n\\t\\treverse(all(num1));\\n\\t\\twhile (num1.size() != 22)\\n\\t\\t\\tnum1.push_back(\\'0\\');\\n\\t\\treverse(all(num1));\\n\\n\\t\\treverse(all(num2));\\n\\t\\twhile (num2.size() != 22)\\n\\t\\t\\tnum2.push_back(\\'0\\');\\n\\t\\treverse(all(num2));\\n\\n\\t\\tdp.clear();\\n\\t\\tll ans = rec(0, 0, true, num2) + mod;\\n\\t\\tdp.clear();\\n\\t\\tans -= rec(0, 0, true, num1);\\n\\t\\tint sum = 0;\\n\\t\\tfor (char ch : num1)\\n\\t\\t\\tsum += (ch - \\'0\\');\\n\\t\\tif (sum <= max_sum && sum >= min_sum)\\n\\t\\t\\tans++;\\n\\t\\treturn ans % mod;\\n\\t}\\n};\\n\\n```\\n\\nUpvote if you found this helpful!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\n#define mod 1000000007\\n#define all(x) begin(x), end(x)\\n\\nclass Solution {\\npublic:\\n\\tll minS, maxS;\\n\\tunordered_map<ll, unordered_map<ll, unordered_map<bool, ll>>> dp;\\n\\n\\tll rec(int ind, int sum, bool restriction, string& str) {\\n\\t\\tif (ind >= str.size())\\n\\t\\t\\tif (sum >= minS && sum <= maxS)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\tif (sum > maxS)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (dp.find(ind) != end(dp) && dp[ind].find(sum) != end(dp[ind]))\\n\\t\\t\\tif (dp[ind][sum].find(restriction) != end(dp[ind][sum]))\\n\\t\\t\\t\\treturn dp[ind][sum][restriction];\\n\\n\\t\\tll ans = 0;\\n\\t\\tif (restriction)\\n\\t\\t{\\n\\t\\t\\tfor (char ch = \\'0\\'; ch <= str[ind]; ch++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans += rec(ind + 1, sum + (ch - \\'0\\'), ch == str[ind] ? true : false, str);\\n\\t\\t\\t\\tans %= mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor (char ch = \\'0\\'; ch <= \\'9\\'; ch++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans += rec(ind + 1, sum + (ch - \\'0\\'), false, str);\\n\\t\\t\\t\\tans %= mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[ind][sum][restriction] = ans % mod;\\n\\t}\\n\\n\\tint count(string num1, string num2, int min_sum, int max_sum) {\\n\\t\\tminS = min_sum;\\n\\t\\tmaxS = max_sum;\\n\\n\\t\\treverse(all(num1));\\n\\t\\twhile (num1.size() != 22)\\n\\t\\t\\tnum1.push_back(\\'0\\');\\n\\t\\treverse(all(num1));\\n\\n\\t\\treverse(all(num2));\\n\\t\\twhile (num2.size() != 22)\\n\\t\\t\\tnum2.push_back(\\'0\\');\\n\\t\\treverse(all(num2));\\n\\n\\t\\tdp.clear();\\n\\t\\tll ans = rec(0, 0, true, num2) + mod;\\n\\t\\tdp.clear();\\n\\t\\tans -= rec(0, 0, true, num1);\\n\\t\\tint sum = 0;\\n\\t\\tfor (char ch : num1)\\n\\t\\t\\tsum += (ch - \\'0\\');\\n\\t\\tif (sum <= max_sum && sum >= min_sum)\\n\\t\\t\\tans++;\\n\\t\\treturn ans % mod;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594899,
                "title": "digit-dp-c",
                "content": "# Intuition\\nDigit DP\\n# Approach\\nDigit DP is a common technique for problems like: \\n> Count all numbers between $a \\\\leq x  \\\\leq b$ that satisfy some property. \\n\\nThe idea behind digit DP is to try to construct a number digit by digit in such a way that it does not exceed $maxNumber$ (in this problem $num1$ and $num2$) and commonly one has to carry other information in the construction, in this case we carry the sum of the digits, we will try to get an answer for the range $ 1 \\\\leq x \\\\leq max$ and for the case we need a specific range $a \\\\leq x \\\\leq b$ just subtract the solution for $ 1 \\\\leq x \\\\leq a-1$ from $ 1 \\\\leq x \\\\leq b$.\\n\\n let\\'s see how the DP sees and for that let\\'s define what our states are:\\n\\n- $idx$: Is the current position in our number under construction, i.e., the position where we will put some digit to create a valid number. \\n- $sum$: This state will tell the current sum of the digits already put in.\\n- $f$: (I always call it f, you can find a better name), this state is necessary to know if we can put an arbitrary digit in the position $idx$ or we are tied to limit not to create an invalid number but more importantly it is necessary to memoize correctly.\\n\\nTo better explain the state $f$ let\\'s look at an example. \\nLet\\'s define $num1=4382323$\\nAnd imagine the following states \\n$x = 43823?? \\\\rightarrow idx=5, \\\\; sum=20,\\\\; f = 0$.  \\n$y = 43814?? \\\\rightarrow idx=5, \\\\; sum=20,\\\\; f = 1$.\\n\\n\\nLet\\'s see that although the states $idx$ and $sum$ are equal we cannot treat both as the same case and memoize because for $x$ we are forced to put a digit $d\\\\leq num[idx] \\\\;, d\\\\leq2$ because if we put a greater digit we will create an invalid number because it will be greater than our limit, in the case of $y$ we can see that no matter what digit we put in $idx$ all possible numbers will still be less than our limit so both states are different, that\\'s because $f$ is important to memoize correctly.\\n\\nNow the transitions for the DP are: \\n\\n$DP[idx][sum][f] = \\\\Sigma_{i=0}^{lim} DP[idx+1][sum+i][nwF]$.\\n\\nWhere $limit$ can be defined by the following statement: **what is the maximum digit we can put in so that the number created is less equal to our limit $num1/2$** of course it will be obtained with $f$.\\nAnd $nwF$ is just the new value of $f$ see the code if you don\\'t know how to get it.\\n \\nAnd the base case when $idx==N, \\\\;N=nums.size()$ (There are no more digits to put)\\n\\n$$ DP[N][sum][f] =\\n  \\\\begin{cases}\\n    1       & \\\\quad \\\\text{if}\\\\quad minSum \\\\leq sum \\\\leq maxSum\\\\\\\\\\n    0       & \\\\quad \\\\text{otherwise } \\n  \\\\end{cases}\\n$$\\n\\n# Complexity\\n- Time complexity:\\n- $O(22 \\\\times maxSum \\\\times 2 \\\\times 10)$\\n\\n- Space complexity:\\n- $O(22 \\\\times maxSum \\\\times 2 )$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> num;\\n    int dp[24][407][2];\\n    \\n    int mx,mn;\\n    const int mod = 1e9+7;\\n    int solve(int idx,int sum,int f){\\n        if(idx == num.size()){\\n            if(sum>=mn && sum<=mx){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n            \\n        int &x = dp[idx][sum][f];\\n        if(x !=-1)return x;\\n        \\n        int lim = f?9:num[idx];\\n        \\n        int ans = 0;\\n        for(int i = 0;i<=lim;i++){\\n            int nwF = f?f:i<lim;\\n            \\n            ans+=solve(idx+1,sum+i,nwF);\\n            ans%=mod;\\n        }\\n        return x = ans;\\n    }\\n    \\n    int solveR(string lim){\\n        num.clear();\\n        for(auto c:lim){\\n            num.push_back(c-\\'0\\');\\n        }        \\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,0);\\n    }\\n    \\n    string rest(string num){\\n        int id = num.size()-1;\\n        while(id>=0 && num[id]==\\'0\\'){\\n            num[id] = \\'9\\';\\n            id--;\\n        }\\n        if(id == 0)return num.substr(1);\\n        num[id]--;\\n        return num;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        mx = max_sum;\\n        mn = min_sum;\\n        \\n        int R = solveR(num2);   \\n        if(rest(num1)==\"\")return R;\\n        int L = solveR(rest(num1));\\n        R-=L;\\n        if(R<0)R+=mod;\\n        return R;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> num;\\n    int dp[24][407][2];\\n    \\n    int mx,mn;\\n    const int mod = 1e9+7;\\n    int solve(int idx,int sum,int f){\\n        if(idx == num.size()){\\n            if(sum>=mn && sum<=mx){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n            \\n        int &x = dp[idx][sum][f];\\n        if(x !=-1)return x;\\n        \\n        int lim = f?9:num[idx];\\n        \\n        int ans = 0;\\n        for(int i = 0;i<=lim;i++){\\n            int nwF = f?f:i<lim;\\n            \\n            ans+=solve(idx+1,sum+i,nwF);\\n            ans%=mod;\\n        }\\n        return x = ans;\\n    }\\n    \\n    int solveR(string lim){\\n        num.clear();\\n        for(auto c:lim){\\n            num.push_back(c-\\'0\\');\\n        }        \\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,0);\\n    }\\n    \\n    string rest(string num){\\n        int id = num.size()-1;\\n        while(id>=0 && num[id]==\\'0\\'){\\n            num[id] = \\'9\\';\\n            id--;\\n        }\\n        if(id == 0)return num.substr(1);\\n        num[id]--;\\n        return num;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        mx = max_sum;\\n        mn = min_sum;\\n        \\n        int R = solveR(num2);   \\n        if(rest(num1)==\"\")return R;\\n        int L = solveR(rest(num1));\\n        R-=L;\\n        if(R<0)R+=mod;\\n        return R;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595545,
                "title": "python-solution",
                "content": "**Python**\\n```py\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        mod = 10 ** 9 + 7\\n\\n        def f(s, v):\\n            n = len(s)\\n            res = sum(map(int, s)) == v\\n            for i,c in enumerate(s):\\n                c = int(c)\\n                for c2 in range(min(c, v + 1)):\\n                    res += split(v - c2, n - i - 1)\\n                v -= c\\n            return res\\n\\n        @lru_cache(None)\\n        def split(v, k):\\n            if v == 0: return 1\\n            if v > 9 * k or v < 0 or k == 0: return 0\\n            return sum(split(v - vv, k - 1) for vv in range(10)) % mod\\n\\n        num1_1 = str(int(num1) - 1)\\n        return sum(f(num2, v) - f(num1_1, v) for v in range(min_sum, max_sum + 1)) % mod\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        mod = 10 ** 9 + 7\\n\\n        def f(s, v):\\n            n = len(s)\\n            res = sum(map(int, s)) == v\\n            for i,c in enumerate(s):\\n                c = int(c)\\n                for c2 in range(min(c, v + 1)):\\n                    res += split(v - c2, n - i - 1)\\n                v -= c\\n            return res\\n\\n        @lru_cache(None)\\n        def split(v, k):\\n            if v == 0: return 1\\n            if v > 9 * k or v < 0 or k == 0: return 0\\n            return sum(split(v - vv, k - 1) for vv in range(10)) % mod\\n\\n        num1_1 = str(int(num1) - 1)\\n        return sum(f(num2, v) - f(num1_1, v) for v in range(min_sum, max_sum + 1)) % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3596874,
                "title": "easy-explaination-digit-dp-solution-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question is quite tricky when it comes to thinking the approach of this problem. As you see the constrains, the values can go upto 10^22. This ensures you of one thing that you can definitely not go through the entire range of numbers between the given range. That\\'s where the digit dp comes into action.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly we\\'ll think of the recursive way to go through the problem. We are given two strings ```num1```, ```num2```. The basic approach of this problem is to find the result for higher number and then for the lower number and then subtract the two. So proceeding further we\\'ll find the total numbers that lie between 0 to num1 such that their sum of digits if between ```min_sum``` & ```max_sum```. And then similary repeat for num2.\\n\\n1) We will make the recursive call for an empty string and add numbers to it till its length becomes equal to n (where n is the length of string s)\\n2) The possibilities of number can be between 0-9, however to ensure that the number is less than given number, we\\'ll keep a ```bound``` variable to keep track of possible numbers.\\n3) We will keep the ```bound``` true initially that means the first index of our string is bounded.\\n4) At each recursive call we\\'ll keep a ```cnt``` to keep the track of sum of digits.\\n\\n# Code\\n## Recursion\\n``` Java []\\nclass Solution {\\n    String s;\\n    int min;\\n    int max;\\n    int mod = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        min = min_sum;\\n        max = max_sum;\\n        int sum = 0;\\n        for(char ch : num1.toCharArray()) sum += ch-\\'0\\';\\n\\n        s = num1;\\n        int ans1= f(0,true, 0);\\n        s = num2;\\n        int ans2= f(0,true, 0);\\n        if(sum >= min_sum && sum <= max_sum){\\n            return (ans2- ans1+mod)%mod +1;\\n        }\\n\\n        return (ans2- ans1+mod)%mod;\\n    }\\n\\n    public int f(int idx, boolean bound, int cnt){\\n        // Base case\\n        if(cnt > max) return 0;\\n        if(idx == s.length()){\\n            // Valid number only if count is between the given range\\n            if(cnt <= max && cnt >= min) {\\n                return 1;\\n            }\\n            return 0;\\n        }   \\n\\n        // If the bound variable is true then it means that we cannot take the entire values from 0 -> 9 at the current index\\n        int maxno = -1;\\n        if(bound){\\n            maxno = s.charAt(idx) - \\'0\\';\\n        }else{\\n            maxno = 9;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i<=maxno; i++){\\n            int updcnt = cnt + i;\\n            // If the number at next index in our string becomes equal to that of string s && we already had a bound on the current index then we will be having the bound on the next number as well\\n\\n            //Once the bound becomes false it means that we are already having a number greater than s\\n            ans = (ans +  f(idx+1, bound && (i == s.charAt(idx) - \\'0\\'), updcnt))%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n```C++ []\\nclass Solution {\\n    string s;\\n    int min_val;\\n    int max_val;\\n    int mod = 1000000007;\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        min_val = min_sum;\\n        max_val = max_sum;\\n        int sum = 0;\\n        for (char ch : num1)\\n            sum += ch - \\'0\\';\\n\\n        s = num1;\\n        int ans1 = f(0, true, 0);\\n        s = num2;\\n        int ans2 = f(0, true, 0);\\n\\n        if (sum >= min_sum && sum <= max_sum) {\\n            return (ans2 - ans1 + mod) % mod + 1;\\n        }\\n\\n        return (ans2 - ans1 + mod) % mod;\\n    }\\n\\n    int f(int idx, bool bound, int cnt) {\\n        if (cnt > max_val)\\n            return 0;\\n\\n        if (idx == s.length()) {\\n            if (cnt <= max_val && cnt >= min_val) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\n        int maxno = -1;\\n        if (bound) {\\n            maxno = s[idx] - \\'0\\';\\n        }\\n        else {\\n            maxno = 9;\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i <= maxno; i++) {\\n            int updcnt = cnt + i;\\n            ans = (ans + f(idx + 1, bound && (i == s[idx] - \\'0\\'), updcnt)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n\\n## Memoization\\n```Java []\\nclass Solution {\\n    String s;\\n    int min;\\n    int max;\\n    Integer[][][] dp;\\n    int mod = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        min = min_sum;\\n        max = max_sum;\\n        int sum = 0;\\n        for(char ch : num1.toCharArray()) sum += ch-\\'0\\';\\n\\n        s = num1;\\n        dp = new Integer[23][2][max+1];\\n        int ans1= f(0,true, 0);\\n        s = num2;\\n        dp = new Integer[23][2][max+1];\\n        int ans2= f(0,true, 0);\\n\\n        if(sum >= min_sum && sum <= max_sum){\\n            return (ans2- ans1+mod)%mod +1;\\n        }\\n\\n        return (ans2- ans1+mod)%mod;\\n    }\\n\\n    public int f(int idx, boolean bound, int cnt){\\n\\n        if(cnt > max) return 0;\\n\\n        if(idx == s.length()){\\n            if(cnt <= max && cnt >= min) {\\n                return 1;\\n            }\\n            return 0;\\n        }   \\n        if(dp[idx][bound ? 1:0][cnt] != null) return dp[idx][bound ? 1:0][cnt];\\n\\n        int maxno = -1;\\n        if(bound){\\n            maxno = s.charAt(idx) - \\'0\\';\\n        }else{\\n            maxno = 9;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i<=maxno; i++){\\n            int updcnt = cnt + i;\\n\\n            ans = (ans +  f(idx+1, bound && (i == s.charAt(idx) - \\'0\\'), updcnt))%mod;\\n        }\\n        return dp[idx][bound ? 1:0][cnt]= ans;\\n    }\\n}\\n```\\n\\n\\n```C++ []\\nclass Solution {\\n    string s;\\n    int min_val;\\n    int max_val;\\n    int dp[23][2][401];\\n    int mod = 1000000007;\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        min_val = min_sum;\\n        max_val = max_sum;\\n        int sum = 0;\\n        for (char ch : num1)\\n            sum += ch - \\'0\\';\\n\\n        s = num1;\\n        \\n        memset(dp, -1, sizeof(dp));\\n        int ans1 = f(0, true, 0);\\n\\n        s = num2;\\n        memset(dp, -1, sizeof(dp));\\n        int ans2 = f(0, true, 0);\\n\\n        if (sum >= min_sum && sum <= max_sum) {\\n            return (ans2 - ans1 + mod) % mod + 1;\\n        }\\n\\n        return (ans2 - ans1 + mod) % mod;\\n    }\\n\\n    int f(int idx, bool bound, int cnt) {\\n        if (cnt > max_val)\\n            return 0;\\n\\n        if (idx == s.length()) {\\n            if (cnt <= max_val && cnt >= min_val) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n    \\n        if (dp[idx][bound][cnt] != -1)\\n            return dp[idx][bound ? 1 : 0][cnt];\\n\\n        int maxno = -1;\\n        if (bound) {\\n            maxno = s[idx] - \\'0\\';\\n        }\\n        else {\\n            maxno = 9;\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i <= maxno; i++) {\\n            int updcnt = cnt + i;\\n            ans = (ans + f(idx + 1, bound && (i == s[idx] - \\'0\\'), updcnt)) % mod;\\n        }\\n\\n        return dp[idx][bound ? 1 : 0][cnt] = ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```num1```\n```num2```\n```min_sum```\n```max_sum```\n```bound```\n```bound```\n```cnt```\n``` Java []\\nclass Solution {\\n    String s;\\n    int min;\\n    int max;\\n    int mod = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        min = min_sum;\\n        max = max_sum;\\n        int sum = 0;\\n        for(char ch : num1.toCharArray()) sum += ch-\\'0\\';\\n\\n        s = num1;\\n        int ans1= f(0,true, 0);\\n        s = num2;\\n        int ans2= f(0,true, 0);\\n        if(sum >= min_sum && sum <= max_sum){\\n            return (ans2- ans1+mod)%mod +1;\\n        }\\n\\n        return (ans2- ans1+mod)%mod;\\n    }\\n\\n    public int f(int idx, boolean bound, int cnt){\\n        // Base case\\n        if(cnt > max) return 0;\\n        if(idx == s.length()){\\n            // Valid number only if count is between the given range\\n            if(cnt <= max && cnt >= min) {\\n                return 1;\\n            }\\n            return 0;\\n        }   \\n\\n        // If the bound variable is true then it means that we cannot take the entire values from 0 -> 9 at the current index\\n        int maxno = -1;\\n        if(bound){\\n            maxno = s.charAt(idx) - \\'0\\';\\n        }else{\\n            maxno = 9;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i<=maxno; i++){\\n            int updcnt = cnt + i;\\n            // If the number at next index in our string becomes equal to that of string s && we already had a bound on the current index then we will be having the bound on the next number as well\\n\\n            //Once the bound becomes false it means that we are already having a number greater than s\\n            ans = (ans +  f(idx+1, bound && (i == s.charAt(idx) - \\'0\\'), updcnt))%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\n    string s;\\n    int min_val;\\n    int max_val;\\n    int mod = 1000000007;\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        min_val = min_sum;\\n        max_val = max_sum;\\n        int sum = 0;\\n        for (char ch : num1)\\n            sum += ch - \\'0\\';\\n\\n        s = num1;\\n        int ans1 = f(0, true, 0);\\n        s = num2;\\n        int ans2 = f(0, true, 0);\\n\\n        if (sum >= min_sum && sum <= max_sum) {\\n            return (ans2 - ans1 + mod) % mod + 1;\\n        }\\n\\n        return (ans2 - ans1 + mod) % mod;\\n    }\\n\\n    int f(int idx, bool bound, int cnt) {\\n        if (cnt > max_val)\\n            return 0;\\n\\n        if (idx == s.length()) {\\n            if (cnt <= max_val && cnt >= min_val) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\n        int maxno = -1;\\n        if (bound) {\\n            maxno = s[idx] - \\'0\\';\\n        }\\n        else {\\n            maxno = 9;\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i <= maxno; i++) {\\n            int updcnt = cnt + i;\\n            ans = (ans + f(idx + 1, bound && (i == s[idx] - \\'0\\'), updcnt)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\n```Java []\\nclass Solution {\\n    String s;\\n    int min;\\n    int max;\\n    Integer[][][] dp;\\n    int mod = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        min = min_sum;\\n        max = max_sum;\\n        int sum = 0;\\n        for(char ch : num1.toCharArray()) sum += ch-\\'0\\';\\n\\n        s = num1;\\n        dp = new Integer[23][2][max+1];\\n        int ans1= f(0,true, 0);\\n        s = num2;\\n        dp = new Integer[23][2][max+1];\\n        int ans2= f(0,true, 0);\\n\\n        if(sum >= min_sum && sum <= max_sum){\\n            return (ans2- ans1+mod)%mod +1;\\n        }\\n\\n        return (ans2- ans1+mod)%mod;\\n    }\\n\\n    public int f(int idx, boolean bound, int cnt){\\n\\n        if(cnt > max) return 0;\\n\\n        if(idx == s.length()){\\n            if(cnt <= max && cnt >= min) {\\n                return 1;\\n            }\\n            return 0;\\n        }   \\n        if(dp[idx][bound ? 1:0][cnt] != null) return dp[idx][bound ? 1:0][cnt];\\n\\n        int maxno = -1;\\n        if(bound){\\n            maxno = s.charAt(idx) - \\'0\\';\\n        }else{\\n            maxno = 9;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i<=maxno; i++){\\n            int updcnt = cnt + i;\\n\\n            ans = (ans +  f(idx+1, bound && (i == s.charAt(idx) - \\'0\\'), updcnt))%mod;\\n        }\\n        return dp[idx][bound ? 1:0][cnt]= ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\n    string s;\\n    int min_val;\\n    int max_val;\\n    int dp[23][2][401];\\n    int mod = 1000000007;\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        min_val = min_sum;\\n        max_val = max_sum;\\n        int sum = 0;\\n        for (char ch : num1)\\n            sum += ch - \\'0\\';\\n\\n        s = num1;\\n        \\n        memset(dp, -1, sizeof(dp));\\n        int ans1 = f(0, true, 0);\\n\\n        s = num2;\\n        memset(dp, -1, sizeof(dp));\\n        int ans2 = f(0, true, 0);\\n\\n        if (sum >= min_sum && sum <= max_sum) {\\n            return (ans2 - ans1 + mod) % mod + 1;\\n        }\\n\\n        return (ans2 - ans1 + mod) % mod;\\n    }\\n\\n    int f(int idx, bool bound, int cnt) {\\n        if (cnt > max_val)\\n            return 0;\\n\\n        if (idx == s.length()) {\\n            if (cnt <= max_val && cnt >= min_val) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n    \\n        if (dp[idx][bound][cnt] != -1)\\n            return dp[idx][bound ? 1 : 0][cnt];\\n\\n        int maxno = -1;\\n        if (bound) {\\n            maxno = s[idx] - \\'0\\';\\n        }\\n        else {\\n            maxno = 9;\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i <= maxno; i++) {\\n            int updcnt = cnt + i;\\n            ans = (ans + f(idx + 1, bound && (i == s[idx] - \\'0\\'), updcnt)) % mod;\\n        }\\n\\n        return dp[idx][bound ? 1 : 0][cnt] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921805,
                "title": "c-self-explained-code-3d-dp-digit-dp",
                "content": "Here we can\\'t calculate low -1 as the string can\\'t be convert into number(not even in long long)\\nso we have to calculate ans for till left  and till right  and finally separately for string left (num1) \\n\\n```\\n#define ll long long\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    ll dp[23][2][401];\\n    ll mini;\\n    ll maxi;\\n    ll solve(string &s,int i,bool tight,ll tillsum)\\n    {\\n        if(i==s.size())\\n        {\\n            if(tillsum>=mini && tillsum<=maxi) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][tight][tillsum]!=-1) return dp[i][tight][tillsum];\\n        ll ans=0;\\n        int lim=tight?s[i]-\\'0\\':9;\\n        for(int dig=0;dig<=lim;dig++)\\n        {\\n            ans=(ans%mod+solve(s,i+1,tight&(dig==lim),tillsum+dig)%mod)%mod;\\n        }\\n        return dp[i][tight][tillsum]=ans%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) \\n    {\\n        mini=min_sum;\\n        maxi=max_sum;\\n        memset(dp,-1,sizeof(dp));\\n        ll l=solve(num1,0,1,0);\\n        l=l%mod;\\n        memset(dp,-1,sizeof(dp));\\n        ll r=solve(num2,0,1,0);\\n        r=r%mod;\\n        int sum=0;\\n        for(auto e:num1)\\n        {\\n            sum+=e-\\'0\\';\\n        }\\n        ll ans=(r-l+mod)%mod;\\n        if(sum>=mini && sum<=maxi)\\n        {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    ll dp[23][2][401];\\n    ll mini;\\n    ll maxi;\\n    ll solve(string &s,int i,bool tight,ll tillsum)\\n    {\\n        if(i==s.size())\\n        {\\n            if(tillsum>=mini && tillsum<=maxi) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][tight][tillsum]!=-1) return dp[i][tight][tillsum];\\n        ll ans=0;\\n        int lim=tight?s[i]-\\'0\\':9;\\n        for(int dig=0;dig<=lim;dig++)\\n        {\\n            ans=(ans%mod+solve(s,i+1,tight&(dig==lim),tillsum+dig)%mod)%mod;\\n        }\\n        return dp[i][tight][tillsum]=ans%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) \\n    {\\n        mini=min_sum;\\n        maxi=max_sum;\\n        memset(dp,-1,sizeof(dp));\\n        ll l=solve(num1,0,1,0);\\n        l=l%mod;\\n        memset(dp,-1,sizeof(dp));\\n        ll r=solve(num2,0,1,0);\\n        r=r%mod;\\n        int sum=0;\\n        for(auto e:num1)\\n        {\\n            sum+=e-\\'0\\';\\n        }\\n        ll ans=(r-l+mod)%mod;\\n        if(sum>=mini && sum<=maxi)\\n        {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596397,
                "title": "3d-digit-dp-c",
                "content": "We have to count the strings with digit sum betwen max_sum and min_sum.\\n\\nSo, first I have calculated strings less than **num1-1** (because we have to include num1 also) with the required digit sum and then similarly for num2. \\nTheir difference is our answer. \\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    //Strings less than or equal to s that has digit sum between max_sum and min_sum\\n    long long cal(int i, bool strict, int sum, string&s,int n,int min_sum, int max_sum,\\n    vector<vector<vector<int>>>&dp)\\n    {\\n        if(i==n)\\n            return sum>=min_sum && sum<=max_sum;\\n        if(dp[i][strict][sum]!=-1)\\n            return dp[i][strict][sum];\\n        char end = (strict)? s[i] : \\'9\\';\\n        long long ans = 0;\\n        for(char c=\\'0\\';c<=end;c++)\\n        {\\n            int newSum = sum+(c-\\'0\\');\\n            if(newSum > max_sum)\\n                break;\\n            ans = ( ans + cal(i+1,strict & c==end,newSum,s,n,min_sum,max_sum,dp)%mod)%mod;\\n        }    \\n        return dp[i][strict][sum] = ans%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int n = num1.size(),m = num2.size();\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(2,vector<int>(max_sum+1,-1)));\\n        int p = n-1;\\n\\n        //Getting num1 -1 as a string \\n        while(num1[p]==\\'0\\') p--; \\n        num1[p++]--;\\n        while(p<n) num1[p++] = \\'9\\';\\n        long long less = cal(0,1,0,num1,n,min_sum,max_sum,dp);\\n        dp.clear();\\n        dp.resize(m,vector<vector<int>>(2,vector<int>(max_sum+1,-1)));\\n      \\n        long long tot = cal(0,1,0,num2,m,min_sum,max_sum,dp);\\n        return (tot - less + mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    //Strings less than or equal to s that has digit sum between max_sum and min_sum\\n    long long cal(int i, bool strict, int sum, string&s,int n,int min_sum, int max_sum,\\n    vector<vector<vector<int>>>&dp)\\n    {\\n        if(i==n)\\n            return sum>=min_sum && sum<=max_sum;\\n        if(dp[i][strict][sum]!=-1)\\n            return dp[i][strict][sum];\\n        char end = (strict)? s[i] : \\'9\\';\\n        long long ans = 0;\\n        for(char c=\\'0\\';c<=end;c++)\\n        {\\n            int newSum = sum+(c-\\'0\\');\\n            if(newSum > max_sum)\\n                break;\\n            ans = ( ans + cal(i+1,strict & c==end,newSum,s,n,min_sum,max_sum,dp)%mod)%mod;\\n        }    \\n        return dp[i][strict][sum] = ans%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int n = num1.size(),m = num2.size();\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(2,vector<int>(max_sum+1,-1)));\\n        int p = n-1;\\n\\n        //Getting num1 -1 as a string \\n        while(num1[p]==\\'0\\') p--; \\n        num1[p++]--;\\n        while(p<n) num1[p++] = \\'9\\';\\n        long long less = cal(0,1,0,num1,n,min_sum,max_sum,dp);\\n        dp.clear();\\n        dp.resize(m,vector<vector<int>>(2,vector<int>(max_sum+1,-1)));\\n      \\n        long long tot = cal(0,1,0,num2,m,min_sum,max_sum,dp);\\n        return (tot - less + mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595077,
                "title": "using-dynamic-programming-c-approach",
                "content": "```\\nclass Solution {\\nprivate:\\n    const int mod = 1e9 + 7;\\n    int dp[30][405];\\n\\n    long long calculate(string s, int left, int right) {\\n        int sum = 0;\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            for (int j = 0; j < s[i] - \\'0\\'; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n                dp[i][sum + j]++;\\n            }\\n            sum += s[i] - \\'0\\';\\n        }\\n\\n        for (int i = 1; i < s.size(); i++) {\\n            for (int j = 1; j <= 9; j++) {\\n                dp[i][j]++;\\n            }\\n        }\\n\\n        for (int i = 0; i + 1 < s.size(); i++) {\\n            for (int j = 0; j < 405; j++) {\\n                for (int k = 0; k <= 9; k++) {\\n                    if (dp[i][j]) {\\n                        dp[i + 1][j + k] += dp[i][j];\\n                        dp[i + 1][j + k] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for (int i = left; i <= right; i++) {\\n            ans += dp[s.size() - 1][i];\\n        }\\n        \\n        return ans;\\n    }\\npublic:\\n    int count(string num1, string num2, int minSum, int maxSum) {\\n        long long ans = calculate(num2, minSum, maxSum) - calculate(num1, minSum, maxSum);\\n        int total = 0;\\n        \\n        for (auto it : num2) {\\n            total += it - \\'0\\';\\n        }\\n        \\n        if (total >= minSum && total <= maxSum)\\n            ans++;\\n\\n        ans = (ans % mod + mod) % mod;\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int mod = 1e9 + 7;\\n    int dp[30][405];\\n\\n    long long calculate(string s, int left, int right) {\\n        int sum = 0;\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            for (int j = 0; j < s[i] - \\'0\\'; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n                dp[i][sum + j]++;\\n            }\\n            sum += s[i] - \\'0\\';\\n        }\\n\\n        for (int i = 1; i < s.size(); i++) {\\n            for (int j = 1; j <= 9; j++) {\\n                dp[i][j]++;\\n            }\\n        }\\n\\n        for (int i = 0; i + 1 < s.size(); i++) {\\n            for (int j = 0; j < 405; j++) {\\n                for (int k = 0; k <= 9; k++) {\\n                    if (dp[i][j]) {\\n                        dp[i + 1][j + k] += dp[i][j];\\n                        dp[i + 1][j + k] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for (int i = left; i <= right; i++) {\\n            ans += dp[s.size() - 1][i];\\n        }\\n        \\n        return ans;\\n    }\\npublic:\\n    int count(string num1, string num2, int minSum, int maxSum) {\\n        long long ans = calculate(num2, minSum, maxSum) - calculate(num1, minSum, maxSum);\\n        int total = 0;\\n        \\n        for (auto it : num2) {\\n            total += it - \\'0\\';\\n        }\\n        \\n        if (total >= minSum && total <= maxSum)\\n            ans++;\\n\\n        ans = (ans % mod + mod) % mod;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936913,
                "title": "detailed-digit-dp-explanation-and-linked-resources-to-learn-digit-dp",
                "content": "# Intuition\\nLooking at the constraints (N<=1e22) which are really high so we can\\'t check every number whether it satisfies the given condition.\\nAdditionally in digit-dp problems we are generally asked about count of numbers between certain range which follows certain condition.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. if total = numbers between num1 & num2 with sum of digits <= max_sum  and\\n2. unnecessary = numbers between num1 & num2 with sum of digits <= min_sum-1\\n3. total - unnecessary is the answer. \\n**e.g **\\n1.1 count of nums which are in range [40,100] which are divisible by 10 is =>\\n1.2 total = [10,20,30,40,50,60,70,80,90,100] (considering between 0 to 100)\\nunnecessary = [10,20,30]\\n1.3 total - unnecessary = [10,20,30,40,50,60,70,80,90,100] - [10,20,30]\\n# Explanation\\nstate  = (i,tight1,tight2,sum,num1,num2)\\nthis state defines *count of all the numbers* with *sum of digits* equals to *sum* and which lies between *num1 and num2.*\\n**tight1 => to check number is always gretaer than equals to min_num;\\ntight2 => to check number is always greater than equals to max_num;\\n**\\nwhen tight1 is false it means lower bound can take any values because the number is surely greater than min_num but when tight1 is true it means lower bound must take values greater than or equals to the value at current index..\\nwhen tight2 is false it means higher bound can take any values because the number is surely lesser than max_num but when tight2 is true it means higher bound must take values lesser than or equals to the value at current index..\\n(this part must be difficicult to understand so lets see an example)\\nlets num is 5678\\nand for num to be greater than 5678 the first digit must be gretaer than equals to 5 (here tight  true)\\nsimilary if lets says 2nd digit is also 5 than 3 and 4th can take any digit values because surely the resulting number will be higher than the num (tight false).\\n(vice verse) \\n\\n\\nlo_bnd = lower bound it means the digit must be greater than equals to this val\\nhi_bnd = higher bound it means the digit must be smaller than equals to this val\\n**e.g.**\\nlets say the nums must lie between 5000 and 8000\\nthan lo_bnd will take values 5,7,8,9\\nand hi_bnd will take values 0,1,2,3,4,5,6,7,8\\n\\nso the digit will take values (5,6,7,8)\\n\\n\\n\\n\\n\\n# Code\\n```\\nconst int MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int dp[23][2][2][401];\\n// tight1 => to check number is always gretaer than equals to min_num;\\n// tight2 => to check number is always greater than equals to max_num;\\n\\n    int digitDp(int i,bool tight1,bool tight2,int sum,string& num1, string& num2){\\n        if(sum<0)\\n        return 0; // no positive number can be formed which has a negative sum og digits\\n        if(i==num1.size())\\n        return 1;//we got a number which is greater than euals to min_num ans less than equals to max_num;\\n        if(dp[i][tight1][tight2][sum]!=-1)\\n        return dp[i][tight1][tight2][sum];\\n\\n        int lo_bnd = tight1 ? num1[i]-\\'0\\' : 0;\\n        int hi_bnd = tight2 ? num2[i]-\\'0\\' : 9;\\n\\n        int cnt = 0;\\n        for(int val = lo_bnd ; val<=hi_bnd ; val++){\\n            cnt = (cnt + digitDp(i+1,tight1 & (val==lo_bnd),tight2 & (val==hi_bnd),sum - val, num1, num2)) % MOD;\\n        }\\n        return dp[i][tight1][tight2][sum] = cnt;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        // cout<<num2<<\" \"<<num1<<endl;\\n        int diff = num2.size() - num1.size(); // diff => difference in their size.\\n        num1 = string(diff,\\'0\\') + num1; // appending zeroes  in front of num1 which is the smaller number\\n        memset(dp,-1,sizeof(dp));\\n        int total = digitDp(0,1,1,max_sum,num1,num2); // (digit from lhs,tight1,tight2,max_sum,num1,num2)\\n        int unnecessary = digitDp(0,1,1,min_sum-1,num1,num2); // (digit from lhs,tight1,tight2,min_sum-1,num1,num2)\\n        int answer = (total - unnecessary) % MOD;\\n\\n        return answer <0 ? answer + MOD : answer;\\n    }\\n};\\n```\\n# Some Resources to learn digit dp\\nhttps://codeforces.com/blog/entry/53960 (This is enough to understand basics)\\n[https://www.scaler.com/topics/data-structures/digit-dp/]()\\nKartik Arora\\'s playlist on Digit DP is also really good",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nconst int MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int dp[23][2][2][401];\\n// tight1 => to check number is always gretaer than equals to min_num;\\n// tight2 => to check number is always greater than equals to max_num;\\n\\n    int digitDp(int i,bool tight1,bool tight2,int sum,string& num1, string& num2){\\n        if(sum<0)\\n        return 0; // no positive number can be formed which has a negative sum og digits\\n        if(i==num1.size())\\n        return 1;//we got a number which is greater than euals to min_num ans less than equals to max_num;\\n        if(dp[i][tight1][tight2][sum]!=-1)\\n        return dp[i][tight1][tight2][sum];\\n\\n        int lo_bnd = tight1 ? num1[i]-\\'0\\' : 0;\\n        int hi_bnd = tight2 ? num2[i]-\\'0\\' : 9;\\n\\n        int cnt = 0;\\n        for(int val = lo_bnd ; val<=hi_bnd ; val++){\\n            cnt = (cnt + digitDp(i+1,tight1 & (val==lo_bnd),tight2 & (val==hi_bnd),sum - val, num1, num2)) % MOD;\\n        }\\n        return dp[i][tight1][tight2][sum] = cnt;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        // cout<<num2<<\" \"<<num1<<endl;\\n        int diff = num2.size() - num1.size(); // diff => difference in their size.\\n        num1 = string(diff,\\'0\\') + num1; // appending zeroes  in front of num1 which is the smaller number\\n        memset(dp,-1,sizeof(dp));\\n        int total = digitDp(0,1,1,max_sum,num1,num2); // (digit from lhs,tight1,tight2,max_sum,num1,num2)\\n        int unnecessary = digitDp(0,1,1,min_sum-1,num1,num2); // (digit from lhs,tight1,tight2,min_sum-1,num1,num2)\\n        int answer = (total - unnecessary) % MOD;\\n\\n        return answer <0 ? answer + MOD : answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3849718,
                "title": "c-easy-solution-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7 ;\\n    int dp[24][2][401] ;\\n    int mini , maxi ; \\n    long long  cal(string & s, int pos= 0 , int tight= 1  , long long sum= 0 )\\n     {\\n      \\n         if(pos==s.length())\\n         {\\n             return (sum>=mini && sum<=maxi) ; \\n         }\\n         \\n         if(dp[pos][tight][sum]!=-1)\\n             return dp[pos][tight][sum] ; \\n         \\n         long long  ans =0 ; \\n         \\n         int ub = (tight) ? s[pos]-\\'0\\' : 9 ; \\n         \\n         for(int i =0 ; i<=ub; i++ )\\n         {\\n             ans= (ans+ cal(s, pos+1 , tight&(i==ub)  ,sum+i ))%mod ; \\n         }\\n         \\n         return dp[pos][tight][sum] =  ans%mod  ; \\n     }\\n    \\n    \\n    void solve(string &num )\\n    {\\n        int n = num.length() ; \\n        int i =n-1 ; \\n        while(i>=0)\\n        {\\n               if(num[i]==\\'0\\')\\n            {\\n                num[i] = \\'9\\' ; \\n            }\\n            else if(num[i]>\\'0\\')\\n            {\\n                num[i]-=1;\\n                break ;\\n            }\\n        i-- ;\\n        }\\n        if(num[0]==\\'0\\' &&  num.length()!=1)\\n        {\\n            num = num.substr(1) ;\\n        }\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n         mini = min_sum , maxi =max_sum ; \\n        \\n       solve(num1) ; \\n        memset(dp ,-1 , sizeof(dp)) ;\\n        long long  ans1 = cal(num1) ;\\n        memset(dp , -1, sizeof(dp)) ; \\n        long long  ans2  =cal(num2) ; \\n        \\n        return (ans2 -ans1+mod)%mod; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7 ;\\n    int dp[24][2][401] ;\\n    int mini , maxi ; \\n    long long  cal(string & s, int pos= 0 , int tight= 1  , long long sum= 0 )\\n     {\\n      \\n         if(pos==s.length())\\n         {\\n             return (sum>=mini && sum<=maxi) ; \\n         }\\n         \\n         if(dp[pos][tight][sum]!=-1)\\n             return dp[pos][tight][sum] ; \\n         \\n         long long  ans =0 ; \\n         \\n         int ub = (tight) ? s[pos]-\\'0\\' : 9 ; \\n         \\n         for(int i =0 ; i<=ub; i++ )\\n         {\\n             ans= (ans+ cal(s, pos+1 , tight&(i==ub)  ,sum+i ))%mod ; \\n         }\\n         \\n         return dp[pos][tight][sum] =  ans%mod  ; \\n     }\\n    \\n    \\n    void solve(string &num )\\n    {\\n        int n = num.length() ; \\n        int i =n-1 ; \\n        while(i>=0)\\n        {\\n               if(num[i]==\\'0\\')\\n            {\\n                num[i] = \\'9\\' ; \\n            }\\n            else if(num[i]>\\'0\\')\\n            {\\n                num[i]-=1;\\n                break ;\\n            }\\n        i-- ;\\n        }\\n        if(num[0]==\\'0\\' &&  num.length()!=1)\\n        {\\n            num = num.substr(1) ;\\n        }\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n         mini = min_sum , maxi =max_sum ; \\n        \\n       solve(num1) ; \\n        memset(dp ,-1 , sizeof(dp)) ;\\n        long long  ans1 = cal(num1) ;\\n        memset(dp , -1, sizeof(dp)) ; \\n        long long  ans2  =cal(num2) ; \\n        \\n        return (ans2 -ans1+mod)%mod; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598787,
                "title": "python-3-dp-with-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI first thought this sounded like a dp problem, most likely a top down version (although I\\'m always biased to top down). At first I thought there could be up to 4 inputs to the dp function, which I thought was a lot. When I saw the constraints that minSum <= maxSum <= 400 I realized we could do a calculation 400 times no problem and solve a simpler problem where the digitSum had to be EXACTLY some `sm`. Then I started writing a function taking in `n1`, `n2` and `sm`, but then I thought about a \"presum\" like solution where I could just answer \"how many numbers `x <= n` have digitSums == `sm`\", then my function could just have inputs `n` and `sm` and to get the numbers in between n1 and n2 I could just do `f(n2, sm) - f(n1 - 1, sm)`. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplement the function as described above and sum the output values over all possible sums.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI really don\\'t know, but I think we have max 400 `sm`s, 10 unique digits and numbers with at most 22 digist, so \\n$$O(400 * 10 * 22) = $$O(44,000) = $$O(1)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSame as time complexity I think. Maybe someone can school me\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        @cache\\n        def f(n, sm):\\n            if sm < 0: return 0\\n            if sm == 0: return 1\\n            sn = str(n)\\n            if len(sn) == 1: return int(n >= sm)\\n            res = f(int(sn[1:]), sm - int(sn[0]))\\n            for i in range(min(sm + 1, int(sn[0]))): \\n                res += f(int(\\'9\\' * (len(sn) - 1)), sm - i)\\n            # print(n, sm, res)\\n            return res\\n        \\n        return sum((f(int(num2), sm) - f(int(num1) - 1, sm) for sm in range(min_sum, max_sum + 1))) % int(1e9 + 7)\\n\\n# With comments version \\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        @cache\\n        def f(n, sm):\\n            \"\"\"Answers the question how many numbers less than \\n            or equal to n have digits that add up to sm.\\n            \"\"\"\\n            if sm < 0: return 0  # impossible so return 0\\n            if sm == 0: return 1 # only 0 will work\\n            sn = str(n)          # string version of n to make the rest easier\\n            \\n            # ie with n == 9 and sm == 6, only 6 will work\\n            if len(sn) == 1: return int(n >= sm) \\n            \\n            # if the first digit is fixed then the rest of the digits\\n            # must not represent a greater number than they currently do\\n            res = f(int(sn[1:]), sm - int(sn[0])) \\n\\n            # If the first digit is less than it is, then the rest can be up to 9999...\\n            for i in range(min(sm + 1, int(sn[0]))): \\n                res += f(int(\\'9\\' * (len(sn) - 1)), sm - i)\\n\\n            return res\\n            \\n        # With a max of 400 sm\\'s, we will go through each one. \\n        return sum((f(int(num2), sm) - f(int(num1) - 1, sm) for sm in range(min_sum, max_sum + 1))) % int(1e9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        @cache\\n        def f(n, sm):\\n            if sm < 0: return 0\\n            if sm == 0: return 1\\n            sn = str(n)\\n            if len(sn) == 1: return int(n >= sm)\\n            res = f(int(sn[1:]), sm - int(sn[0]))\\n            for i in range(min(sm + 1, int(sn[0]))): \\n                res += f(int(\\'9\\' * (len(sn) - 1)), sm - i)\\n            # print(n, sm, res)\\n            return res\\n        \\n        return sum((f(int(num2), sm) - f(int(num1) - 1, sm) for sm in range(min_sum, max_sum + 1))) % int(1e9 + 7)\\n\\n# With comments version \\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        @cache\\n        def f(n, sm):\\n            \"\"\"Answers the question how many numbers less than \\n            or equal to n have digits that add up to sm.\\n            \"\"\"\\n            if sm < 0: return 0  # impossible so return 0\\n            if sm == 0: return 1 # only 0 will work\\n            sn = str(n)          # string version of n to make the rest easier\\n            \\n            # ie with n == 9 and sm == 6, only 6 will work\\n            if len(sn) == 1: return int(n >= sm) \\n            \\n            # if the first digit is fixed then the rest of the digits\\n            # must not represent a greater number than they currently do\\n            res = f(int(sn[1:]), sm - int(sn[0])) \\n\\n            # If the first digit is less than it is, then the rest can be up to 9999...\\n            for i in range(min(sm + 1, int(sn[0]))): \\n                res += f(int(\\'9\\' * (len(sn) - 1)), sm - i)\\n\\n            return res\\n            \\n        # With a max of 400 sm\\'s, we will go through each one. \\n        return sum((f(int(num2), sm) - f(int(num1) - 1, sm) for sm in range(min_sum, max_sum + 1))) % int(1e9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596432,
                "title": "python-digit-dp-o-23-400-2-10-clean-code",
                "content": "# Code\\n```\\nfrom functools import cache\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        MOD = 10**9 + 7\\n        def solve(R):\\n            nR = len(R)\\n            @cache\\n            def dfs(n, x, tight):\\n                if x > max_sum: return 0\\n                if n == 0:\\n                    return min_sum <= x <= max_sum \\n                ubound = ord(R[nR-n]) - ord(\\'0\\') if tight else 9\\n                res = 0\\n                for dig in range(ubound+1):\\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\\n                return res % MOD\\n            return dfs(nR, 0, 1)\\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        MOD = 10**9 + 7\\n        def solve(R):\\n            nR = len(R)\\n            @cache\\n            def dfs(n, x, tight):\\n                if x > max_sum: return 0\\n                if n == 0:\\n                    return min_sum <= x <= max_sum \\n                ubound = ord(R[nR-n]) - ord(\\'0\\') if tight else 9\\n                res = 0\\n                for dig in range(ubound+1):\\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\\n                return res % MOD\\n            return dfs(nR, 0, 1)\\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596065,
                "title": "python-commented-readable-digit-dp-faster-than-100",
                "content": "```\\nclass Solution:\\n    def solve(self,num,mn,mx,n,sm,flag,dp):\\n        \\n        #base\\n        if n==1:\\n            upper_bound=9\\n            if flag==1:\\n                upper_bound=int(num[len(num)-n])\\n            val=0\\n            for i in range(0,upper_bound+1):\\n                if sm+i>=mn and sm+i<=mx:\\n                    val+=1\\n            return val\\n        \\n        if dp[n][sm][flag]!=-1:\\n            return dp[n][sm][flag]\\n        \\n#setting upperbound till where we can run our loop without crossing the num2 number\\n        upper_bound=9\\n        if flag==1:\\n            upper_bound=int(num[len(num)-n])\\n        \\n        ans=0\\n        for i in range(upper_bound+1):\\n            f=flag\\n            flag=flag&(upper_bound==i)\\n            ans+=self.solve(num,mn,mx,n-1,sm+i,flag,dp)\\n            flag=f\\n        dp[n][sm][flag]=ans\\n        return dp[n][sm][flag]\\n        \\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n    #3d dp for digits , sum and flag(it will tell up whether we have reached upperbound like in 56 upperbound for first digit is 5 after taking 5 at first place we have to be careful regarding second place that is we can\\'t take greater than 6 otherwise we will exceed our range)\\n        dp=[[[-1 for _ in range(2)] for _ in range(401)] for _ in range(24)]\\n    #First computing answer from 1 to num2\\n        val=self.solve(num2,min_sum,max_sum,len(num2),0,1,dp)\\n        dp=[[[-1 for _ in range(2)] for _ in range(401)] for _ in range(24)]\\n    #second computing answer from 1 to num1\\n        val2=self.solve(num1,min_sum,max_sum,len(num1),0,1,dp)\\n        \\n        digi_sum=0\\n        for i in num1:\\n            digi_sum+=int(i)\\n    #we have to include num1 as well if it satifies the good number criteria\\n        if digi_sum >= min_sum and digi_sum<=max_sum:\\n            val+=1\\n        return (val-val2)%1000000007\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self,num,mn,mx,n,sm,flag,dp):\\n        \\n        #base\\n        if n==1:\\n            upper_bound=9\\n            if flag==1:\\n                upper_bound=int(num[len(num)-n])\\n            val=0\\n            for i in range(0,upper_bound+1):\\n                if sm+i>=mn and sm+i<=mx:\\n                    val+=1\\n            return val\\n        \\n        if dp[n][sm][flag]!=-1:\\n            return dp[n][sm][flag]\\n        \\n#setting upperbound till where we can run our loop without crossing the num2 number\\n        upper_bound=9\\n        if flag==1:\\n            upper_bound=int(num[len(num)-n])\\n        \\n        ans=0\\n        for i in range(upper_bound+1):\\n            f=flag\\n            flag=flag&(upper_bound==i)\\n            ans+=self.solve(num,mn,mx,n-1,sm+i,flag,dp)\\n            flag=f\\n        dp[n][sm][flag]=ans\\n        return dp[n][sm][flag]\\n        \\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n    #3d dp for digits , sum and flag(it will tell up whether we have reached upperbound like in 56 upperbound for first digit is 5 after taking 5 at first place we have to be careful regarding second place that is we can\\'t take greater than 6 otherwise we will exceed our range)\\n        dp=[[[-1 for _ in range(2)] for _ in range(401)] for _ in range(24)]\\n    #First computing answer from 1 to num2\\n        val=self.solve(num2,min_sum,max_sum,len(num2),0,1,dp)\\n        dp=[[[-1 for _ in range(2)] for _ in range(401)] for _ in range(24)]\\n    #second computing answer from 1 to num1\\n        val2=self.solve(num1,min_sum,max_sum,len(num1),0,1,dp)\\n        \\n        digi_sum=0\\n        for i in num1:\\n            digi_sum+=int(i)\\n    #we have to include num1 as well if it satifies the good number criteria\\n        if digi_sum >= min_sum and digi_sum<=max_sum:\\n            val+=1\\n        return (val-val2)%1000000007\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595418,
                "title": "python3-9-lines-only-looking-at-edge-cases",
                "content": "# Disclaimer\\n\\nThis solution was obviously cheating. Regardless I think it\\'s a little shitty that LC changed the testcases and made this code TLE. For my proper solution that only requires 40ms runtime check out https://leetcode.com/problems/count-of-integers/solutions/3659413/py3-40ms-beats-100-only-upper-bounds-split-count9-countx/\\n\\n\\n# Intuition\\nFirst write the simplest approach, then start adding edge cases.\\n\\n# Approach\\nTurns out we only need to look at two edge cases:\\n\\n1. Every number in the range works\\n2. No number in the range works\\n\\nWe can detect 1. by checking if the min_sum is 1, and the max_sum is larger than the largest number we can achieve (num_digits * 9).\\n\\nWe can detect 2. by checking if the min_sum is larger than the largest number we can achieve (num_digits * 9).\\n\\n![image.png](https://assets.leetcode.com/users/images/91cda397-b636-41ea-b889-2aa993044e43_1685854170.2337527.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$ (or $$O(n)$$ for very small cases)\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        if min_sum > len(num2) * 9:\\n            return 0\\n        if min_sum == 1 and max_sum > len(num2) * 9:\\n            return (int(num2) - int(num1) + 1) % int(1e9 + 7)\\n        s = 0\\n        for i in range(int(num1), int(num2) + 1):\\n            if min_sum <= sum(map(int, str(i))) <= max_sum:\\n                s += 1\\n        return s % int(1e9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        if min_sum > len(num2) * 9:\\n            return 0\\n        if min_sum == 1 and max_sum > len(num2) * 9:\\n            return (int(num2) - int(num1) + 1) % int(1e9 + 7)\\n        s = 0\\n        for i in range(int(num1), int(num2) + 1):\\n            if min_sum <= sum(map(int, str(i))) <= max_sum:\\n                s += 1\\n        return s % int(1e9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595312,
                "title": "short-and-simple-digit-dp-with-explanations-beats-100-c",
                "content": "# Approach\\nWe have to find total number of numbers from `[nums1, nums2]` where sum of the digits is `mn <=s <= mx`.\\n\\nHelper finds total number of numbers from `[0, N]` where sum of digits is `mn <=s <= mx`.\\n\\n`int helper(string &s, int mn, int mx, int sum, int ind, bool tight)`\\n- `s` is the string \\n- `mx` and `mn` is the max and min val\\n- `ind` is the current index.\\n- `sum` is the sum of digits selected before `ind`\\n- `tight` represents whether thr range is strict or not (used to generate number less than or equal to l)\\n\\nSo, to find the answer we can do `ans = [0, num2] - [0, nums1]` but is makes the range `(num1, nums2]`***(nums1 is not included)*** so we calculate num1 seperately if sum of digits of `num1 <= mx && num1 >= mn` then we increase the ans by 1.\\n```\\nlong long ans = helper(num2, min_sum, max_sum, 0, 0, true);\\nans -= helper(num1, min_sum, max_sum, 0, 0, true);\\nint sum = 0;\\nfor(auto i : num1)sum += (i - \\'0\\');\\nif(sum >= min_sum && sum <= max_sum)ans++;\\n```\\n- if `tight = true` then we constraint to digits 0 to s[ind] but if `tight = false` we can insert any digit from 0 to 9.\\n- if(ind == s.length()) then check of `sum >= mn` return 1\\n\\n\\n# Code\\n``` C++ []\\nconst int MOD = 1e9 + 7;\\nint dp[9 * 24][24][2];\\nclass Solution {\\npublic:\\n    int helper(string &s, int mn, int mx, int sum, int ind, bool tight){\\n        if(sum > mx)return 0;\\n        if(ind == s.length()) return sum >= mn;\\n        if(dp[sum][ind][tight] != -1)return dp[sum][ind][tight];\\n        int ans = 0;\\n        int d = tight?(s[ind] - \\'0\\'):9;\\n        for(int i = 0; i <= d; i++)\\n            ans = ((ans%MOD) + (helper(s, mn, mx, sum + i, ind + 1, (tight && (i == d)))%MOD))%MOD;\\n        return dp[sum][ind][tight] = ans%MOD;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof dp);\\n        long long ans = helper(num2, min_sum, max_sum, 0, 0, true);\\n        memset(dp, -1, sizeof dp);\\n        ans -= helper(num1, min_sum, max_sum, 0, 0, true);\\n\\n        int sum = 0;\\n        for(auto i : num1)sum += (i - \\'0\\');\\n        if(sum >= min_sum && sum <= max_sum)ans++;\\n\\n        return (ans + MOD)%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nlong long ans = helper(num2, min_sum, max_sum, 0, 0, true);\\nans -= helper(num1, min_sum, max_sum, 0, 0, true);\\nint sum = 0;\\nfor(auto i : num1)sum += (i - \\'0\\');\\nif(sum >= min_sum && sum <= max_sum)ans++;\\n```\n``` C++ []\\nconst int MOD = 1e9 + 7;\\nint dp[9 * 24][24][2];\\nclass Solution {\\npublic:\\n    int helper(string &s, int mn, int mx, int sum, int ind, bool tight){\\n        if(sum > mx)return 0;\\n        if(ind == s.length()) return sum >= mn;\\n        if(dp[sum][ind][tight] != -1)return dp[sum][ind][tight];\\n        int ans = 0;\\n        int d = tight?(s[ind] - \\'0\\'):9;\\n        for(int i = 0; i <= d; i++)\\n            ans = ((ans%MOD) + (helper(s, mn, mx, sum + i, ind + 1, (tight && (i == d)))%MOD))%MOD;\\n        return dp[sum][ind][tight] = ans%MOD;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof dp);\\n        long long ans = helper(num2, min_sum, max_sum, 0, 0, true);\\n        memset(dp, -1, sizeof dp);\\n        ans -= helper(num1, min_sum, max_sum, 0, 0, true);\\n\\n        int sum = 0;\\n        for(auto i : num1)sum += (i - \\'0\\');\\n        if(sum >= min_sum && sum <= max_sum)ans++;\\n\\n        return (ans + MOD)%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595293,
                "title": "digit-dp-python-python3-easy-understanding-approach-100-faster-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne should easily get the idea of digit dp here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will calulate f(r) - f(l-1) where f(i) tells that how many numbers are there which follow given constraints and are less than or equal to i.\\nin given helper function. tight denotes that if there is tight condition or not. lets understand tight condition here. It simply denotes that can you take any number between 0 to 9 or not. \\nlead means leading zeroes.\\n\\n# Complexity\\n- Time complexity:\\n- 22*2*2*400\\n- because there can be maximum of 22 length of string number and 2 possible values for tight, 2 possible values for lead and cur can take values up to 400 (given in the question)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- same i.e. 22*2*400 ( to store the dp states)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, left: str, right: str, mn: int, mx: int) -> int:\\n        mod = 10**9 + 7\\n        @lru_cache(None)\\n        def helper(ind,tight,lead,cur):\\n            if ind == 0:\\n                if mn <= cur <= mx :\\n                    return 1\\n                return 0\\n            # if cur > mx :\\n            #     return 0\\n            ans = 0\\n            if lead:\\n                ans = helper(ind-1,0,1,cur)\\n                if tight:\\n                    upper = int(s[len(s)-ind])\\n                else:\\n                    upper = 9\\n                for j in range(1,upper+1):\\n                    ans += helper(ind-1, (tight and  j == upper), 0, cur+j)%mod\\n            else:\\n                if tight:\\n                    upper = int(s[len(s)-ind])\\n                else:\\n                    upper = 9\\n                for j in range(upper+1):\\n                    ans += helper(ind-1, (tight and j == upper), 0, cur+j)%mod\\n            return ans%mod\\n        @lru_cache(None)\\n        def find(ind,tight,lead,cur):\\n            if ind == 0:\\n                if mn <= cur <= mx :\\n                    return 1\\n                return 0\\n            # if cur > mx :\\n                # return 0\\n            ans = 0\\n            if lead:\\n                ans = find(ind-1,0,1,cur)\\n                if tight:\\n                    upper = int(s[len(s)-ind])\\n                else:\\n                    upper = 9\\n                for j in range(1,upper+1):\\n                    ans += find(ind-1, (tight and  j == upper), 0, cur+j)%mod\\n            else:\\n                if tight:\\n                    upper = int(s[len(s)-ind])\\n                else:\\n                    upper = 9\\n                for j in range(upper+1):\\n                    ans += find(ind-1, (tight and  j == upper), 0, cur+j)%mod\\n            return ans%mod\\n        s = str(right)\\n        a = helper(len(s),1,1,0)\\n        s = str(int(left)-1)\\n        b = find(len(s),1,1,0)\\n        # print(a,b)\\n        return (a-b + mod )% mod\\n    \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, left: str, right: str, mn: int, mx: int) -> int:\\n        mod = 10**9 + 7\\n        @lru_cache(None)\\n        def helper(ind,tight,lead,cur):\\n            if ind == 0:\\n                if mn <= cur <= mx :\\n                    return 1\\n                return 0\\n            # if cur > mx :\\n            #     return 0\\n            ans = 0\\n            if lead:\\n                ans = helper(ind-1,0,1,cur)\\n                if tight:\\n                    upper = int(s[len(s)-ind])\\n                else:\\n                    upper = 9\\n                for j in range(1,upper+1):\\n                    ans += helper(ind-1, (tight and  j == upper), 0, cur+j)%mod\\n            else:\\n                if tight:\\n                    upper = int(s[len(s)-ind])\\n                else:\\n                    upper = 9\\n                for j in range(upper+1):\\n                    ans += helper(ind-1, (tight and j == upper), 0, cur+j)%mod\\n            return ans%mod\\n        @lru_cache(None)\\n        def find(ind,tight,lead,cur):\\n            if ind == 0:\\n                if mn <= cur <= mx :\\n                    return 1\\n                return 0\\n            # if cur > mx :\\n                # return 0\\n            ans = 0\\n            if lead:\\n                ans = find(ind-1,0,1,cur)\\n                if tight:\\n                    upper = int(s[len(s)-ind])\\n                else:\\n                    upper = 9\\n                for j in range(1,upper+1):\\n                    ans += find(ind-1, (tight and  j == upper), 0, cur+j)%mod\\n            else:\\n                if tight:\\n                    upper = int(s[len(s)-ind])\\n                else:\\n                    upper = 9\\n                for j in range(upper+1):\\n                    ans += find(ind-1, (tight and  j == upper), 0, cur+j)%mod\\n            return ans%mod\\n        s = str(right)\\n        a = helper(len(s),1,1,0)\\n        s = str(int(left)-1)\\n        b = find(len(s),1,1,0)\\n        # print(a,b)\\n        return (a-b + mod )% mod\\n    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595157,
                "title": "dp-solution-with-0-ms",
                "content": "**Algorithm**\\nWe want to  **count numbers where 1. the value is less than or equal to N and 2. the digit sum is less than or equal to S**. Considering the **prefix of the number** (i.e. leading digitals), this will lead to another problem: **count numbers where 1. the length is K and 2. the digit sum is less than or equal to S**. We define and calculate **DP[K, S]** in the following way.\\n**1. DP[x,0]=DP[0,x]=1\\n2. DP[K,S]=DP[K-1, S]+...+DP[K-1, S-9]**\\n\\n**NOTE:** We  just need to calculate DP[K, S] once and use it for all test cases. Funny trick to improve overall running time.\\n\\n**Example**\\n```\\n// In case we want to count numbers between 2 and 22, with digital sum between 3 and 8\\n\\n// #1, we count the numbers less than or equal to 22 with digit sum no more than 8\\n// Prefix = 0*, +DP[1, 8-0]=9\\n// Prefix = 1*, +DP[1, 8-1]=8\\n// Prefix = 20, +DP[0, 8-2]=1\\n// Prefix = 21, +DP[0, 8-3]=1\\n// Prefix = 22, +DP[0, 8-4]=1\\n// Totally, we got 19\\n\\n// #2, we count the numbers less than or equal to 22 with digit sum less than 3\\n// #3, we count the numbers less than 2 with digit sum no more than 8\\n// #4, we count the numbers less than 2 with digit sum less than 3\\n\\n```\\n\\n**Performance**\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Count of Integers.\\nMemory Usage: 6.3 MB, less than 100.00% of C++ online submissions for Count of Integers.\\n```\\n**Note:** For people who want to reach 0ms, pls be aware that the running time usually varies for ~5ms. Especially, when you want to beat 100%, you should work on your codes and also need the support from the networks and servers.\\n![image](https://assets.leetcode.com/users/images/f4ad972c-fc93-4d51-af45-9b1a1ac0969d_1685899000.9919116.png)\\n\\n\\n**Code**\\n```\\nconst long M=1e9+7;\\nint a[23], b[23], init=1;\\nlong dp[23][401];\\nclass Solution {\\npublic:\\n    long dfs(int len, int sum) {\\n        if(len<0 || sum<0)\\n            return 0;\\n        if(dp[len][sum]>=0)\\n            return dp[len][sum];\\n        if(len==0 || sum==0)\\n            return dp[len][sum]=1;\\n        long ans=0;\\n        for(int i=0; i<=9; ++i) {\\n            ans+=dfs(len-1, sum-i);\\n        }\\n        return dp[len][sum]=ans%M;\\n    }\\n    long helper(int * dgt, int sum) {\\n        long ans=0;\\n        for(int i=0, j; i<23 && sum>=0; ++i) {\\n            for(j=0; j<dgt[i] && sum>=0; ++j, ans+=dfs(22-i, sum--)) {}\\n        }\\n        return (ans+(sum>=0))%M;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        if(init) {\\n            init=0;\\n            for(int i=0, j; i<23;  ++i) {\\n                for(j=0; j<=400; dp[i][j++]=-1) {}\\n            }\\n        }\\n        for(int i=num1.size()-1, j=22, carry=1; j>=0; --j) {\\n            a[j]=i>=0? num1[i--]-\\'0\\' : 0;\\n            if(a[j]<carry) {\\n                a[j]+=10-carry;\\n                carry=1;\\n            } else {\\n                a[j]-=carry;\\n                carry=0;\\n            }\\n        }\\n        for(int i=num2.size()-1, j=22; j>=0; b[j--]=i>=0? num2[i--]-\\'0\\' : 0) {}\\n        return (helper(b, max_sum)+M-helper(b, min_sum-1)+M-helper(a, max_sum)+helper(a, min_sum-1))%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// In case we want to count numbers between 2 and 22, with digital sum between 3 and 8\\n\\n// #1, we count the numbers less than or equal to 22 with digit sum no more than 8\\n// Prefix = 0*, +DP[1, 8-0]=9\\n// Prefix = 1*, +DP[1, 8-1]=8\\n// Prefix = 20, +DP[0, 8-2]=1\\n// Prefix = 21, +DP[0, 8-3]=1\\n// Prefix = 22, +DP[0, 8-4]=1\\n// Totally, we got 19\\n\\n// #2, we count the numbers less than or equal to 22 with digit sum less than 3\\n// #3, we count the numbers less than 2 with digit sum no more than 8\\n// #4, we count the numbers less than 2 with digit sum less than 3\\n\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Count of Integers.\\nMemory Usage: 6.3 MB, less than 100.00% of C++ online submissions for Count of Integers.\\n```\n```\\nconst long M=1e9+7;\\nint a[23], b[23], init=1;\\nlong dp[23][401];\\nclass Solution {\\npublic:\\n    long dfs(int len, int sum) {\\n        if(len<0 || sum<0)\\n            return 0;\\n        if(dp[len][sum]>=0)\\n            return dp[len][sum];\\n        if(len==0 || sum==0)\\n            return dp[len][sum]=1;\\n        long ans=0;\\n        for(int i=0; i<=9; ++i) {\\n            ans+=dfs(len-1, sum-i);\\n        }\\n        return dp[len][sum]=ans%M;\\n    }\\n    long helper(int * dgt, int sum) {\\n        long ans=0;\\n        for(int i=0, j; i<23 && sum>=0; ++i) {\\n            for(j=0; j<dgt[i] && sum>=0; ++j, ans+=dfs(22-i, sum--)) {}\\n        }\\n        return (ans+(sum>=0))%M;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        if(init) {\\n            init=0;\\n            for(int i=0, j; i<23;  ++i) {\\n                for(j=0; j<=400; dp[i][j++]=-1) {}\\n            }\\n        }\\n        for(int i=num1.size()-1, j=22, carry=1; j>=0; --j) {\\n            a[j]=i>=0? num1[i--]-\\'0\\' : 0;\\n            if(a[j]<carry) {\\n                a[j]+=10-carry;\\n                carry=1;\\n            } else {\\n                a[j]-=carry;\\n                carry=0;\\n            }\\n        }\\n        for(int i=num2.size()-1, j=22; j>=0; b[j--]=i>=0? num2[i--]-\\'0\\' : 0) {}\\n        return (helper(b, max_sum)+M-helper(b, min_sum-1)+M-helper(a, max_sum)+helper(a, min_sum-1))%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595021,
                "title": "python-dp-recursive-beat-98",
                "content": "```\\nclass Solution:\\n    MOD = 10 ** 9 + 7\\n    \\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        # padding (for convenience)\\n        num1 = \\'0\\' * (len(num2) - len(num1)) + num1\\n        \\n        @cache\\n        def dp(s: int, i: int, has_lower: bool, has_upper: bool) -> int:\\n            # base cases\\n            if s < 0:\\n                return 0\\n            if i == len(num1) and s == 0:  # satisfied\\n                return 1\\n            if i >= len(num1):\\n                return 0\\n            \\n            # bounds for next digit\\n            lower = int(num1[i]) if has_lower else 0\\n            upper = int(num2[i]) if has_upper else 9\\n            \\n            # transition\\n            return sum(\\n                dp(s - d, i + 1, has_lower and d == lower, has_upper and d == upper) for d in range(lower, upper + 1)\\n            )\\n        \\n        return sum(dp(s, 0, True, True) for s in range(min_sum, max_sum + 1)) % Solution.MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    MOD = 10 ** 9 + 7\\n    \\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        # padding (for convenience)\\n        num1 = \\'0\\' * (len(num2) - len(num1)) + num1\\n        \\n        @cache\\n        def dp(s: int, i: int, has_lower: bool, has_upper: bool) -> int:\\n            # base cases\\n            if s < 0:\\n                return 0\\n            if i == len(num1) and s == 0:  # satisfied\\n                return 1\\n            if i >= len(num1):\\n                return 0\\n            \\n            # bounds for next digit\\n            lower = int(num1[i]) if has_lower else 0\\n            upper = int(num2[i]) if has_upper else 9\\n            \\n            # transition\\n            return sum(\\n                dp(s - d, i + 1, has_lower and d == lower, has_upper and d == upper) for d in range(lower, upper + 1)\\n            )\\n        \\n        return sum(dp(s, 0, True, True) for s in range(min_sum, max_sum + 1)) % Solution.MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075053,
                "title": "short-and-easy-digit-dp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n\\n    int dp[25][401][2][2];//str, int , bool\\n\\n    int solve(string &num1,string &num2, int i, int x, bool tight1, bool tight2){//=ilen, x=sum, tight=bool\\n        int n=num2.length();\\n\\n        if(x<0)return 0; //pos**\\n        if(i==0)return 1;\\n       \\n\\n        if(dp[i][x][tight1][tight2]!=-1)return dp[i][x][tight1][tight2];\\n\\n        int ans=0;\\n        int lb=( tight1?num1[n-i]-\\'0\\':0);\\n        int ub=( tight2?num2[n-i]-\\'0\\':9);\\n\\n        //if tight then get UPPER BOUND from digit at that pos\\n\\n        for(int j=lb; j<=ub; j++){\\n            ans=ans%mod + solve(num1,num2, i-1, x-j, (tight1 &(j==lb)), (tight2 &(j==ub))) %mod; \\n            //if tight=1 & j=ub then remains tight for other also\\n        }\\n        // cout<<i<<\" \"<<ans<<endl;\\n\\n\\n        return dp[i][x][tight1][tight2]= ans;\\n\\n    }\\n\\n    int count(string nums1, string num2, int min_sum, int max_sum) {\\n        \\n        int res=0;\\n         memset(dp, -1, sizeof(dp));\\n        int leadingZeroes = num2.length() - nums1.length();\\n        string num1 = string(leadingZeroes,\\'0\\')+nums1;\\n\\n        //req= max_sum - [minsum-1] : as minsum has to be taken\\n        int tcnt=solve(num1,num2, num2.length(), max_sum, 1, 1)%mod;\\n        int un= solve(num1, num2, num2.length(), min_sum-1, 1, 1) %mod;\\n        res=(tcnt-un) %mod;\\n\\n\\n        return res<0 ? res+mod: res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n\\n    int dp[25][401][2][2];//str, int , bool\\n\\n    int solve(string &num1,string &num2, int i, int x, bool tight1, bool tight2){//=ilen, x=sum, tight=bool\\n        int n=num2.length();\\n\\n        if(x<0)return 0; //pos**\\n        if(i==0)return 1;\\n       \\n\\n        if(dp[i][x][tight1][tight2]!=-1)return dp[i][x][tight1][tight2];\\n\\n        int ans=0;\\n        int lb=( tight1?num1[n-i]-\\'0\\':0);\\n        int ub=( tight2?num2[n-i]-\\'0\\':9);\\n\\n        //if tight then get UPPER BOUND from digit at that pos\\n\\n        for(int j=lb; j<=ub; j++){\\n            ans=ans%mod + solve(num1,num2, i-1, x-j, (tight1 &(j==lb)), (tight2 &(j==ub))) %mod; \\n            //if tight=1 & j=ub then remains tight for other also\\n        }\\n        // cout<<i<<\" \"<<ans<<endl;\\n\\n\\n        return dp[i][x][tight1][tight2]= ans;\\n\\n    }\\n\\n    int count(string nums1, string num2, int min_sum, int max_sum) {\\n        \\n        int res=0;\\n         memset(dp, -1, sizeof(dp));\\n        int leadingZeroes = num2.length() - nums1.length();\\n        string num1 = string(leadingZeroes,\\'0\\')+nums1;\\n\\n        //req= max_sum - [minsum-1] : as minsum has to be taken\\n        int tcnt=solve(num1,num2, num2.length(), max_sum, 1, 1)%mod;\\n        int un= solve(num1, num2, num2.length(), min_sum-1, 1, 1) %mod;\\n        res=(tcnt-un) %mod;\\n\\n\\n        return res<0 ? res+mod: res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4046982,
                "title": "simple-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD = (int)1e9 +7;\\n    long long dp[401][23][2];\\n    int maxi, mini;\\n    long long digit_sum(int x, string &r, int t2, int i)\\n    {\\n        if(x<0)\\n        {\\n            return 0;\\n        }\\n        if(i == r.size())\\n        {\\n            return x>=mini and x<=maxi;\\n        }\\n\\n        if(dp[x][i][t2]!=-1)\\n        {\\n            return dp[x][i][t2];\\n        }\\n\\n        long long ans =0;\\n        int ub = t2 ? r[i]-\\'0\\' : 9;\\n        for(int j=0; j<=ub; j++)\\n        {\\n            ans = ans + digit_sum(x+j, r, t2&(j==ub), i+1);\\n            ans %= MOD;\\n        }\\n        return dp[x][i][t2] = ans%MOD;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        mini = min_sum, maxi = max_sum;\\n        long long ans =0;\\n        int last = num1.size()-1;\\n        \\n        while(num1[last]==\\'0\\')\\n        {\\n            num1[last] = \\'9\\';\\n            last--;\\n        }\\n        num1[last]--;\\n\\n        memset(dp, -1, sizeof dp);\\n        ans =  digit_sum(0, num2, 1, 0) % MOD;\\n        memset(dp, -1, sizeof dp);\\n        ans -= digit_sum(0, num1, 1, 0) % MOD;\\n        \\n        if(ans<0)\\n            return ans+MOD;\\n\\n        return ans%MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = (int)1e9 +7;\\n    long long dp[401][23][2];\\n    int maxi, mini;\\n    long long digit_sum(int x, string &r, int t2, int i)\\n    {\\n        if(x<0)\\n        {\\n            return 0;\\n        }\\n        if(i == r.size())\\n        {\\n            return x>=mini and x<=maxi;\\n        }\\n\\n        if(dp[x][i][t2]!=-1)\\n        {\\n            return dp[x][i][t2];\\n        }\\n\\n        long long ans =0;\\n        int ub = t2 ? r[i]-\\'0\\' : 9;\\n        for(int j=0; j<=ub; j++)\\n        {\\n            ans = ans + digit_sum(x+j, r, t2&(j==ub), i+1);\\n            ans %= MOD;\\n        }\\n        return dp[x][i][t2] = ans%MOD;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        mini = min_sum, maxi = max_sum;\\n        long long ans =0;\\n        int last = num1.size()-1;\\n        \\n        while(num1[last]==\\'0\\')\\n        {\\n            num1[last] = \\'9\\';\\n            last--;\\n        }\\n        num1[last]--;\\n\\n        memset(dp, -1, sizeof dp);\\n        ans =  digit_sum(0, num2, 1, 0) % MOD;\\n        memset(dp, -1, sizeof dp);\\n        ans -= digit_sum(0, num1, 1, 0) % MOD;\\n        \\n        if(ans<0)\\n            return ans+MOD;\\n\\n        return ans%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043485,
                "title": "simple-intutive-solution-c-trie-digit-dpd",
                "content": "\\n\\n# Code\\n```\\nconst int M=1e9+7;\\n\\nclass Solution {\\npublic:\\n    int dp[25][2][2][500]={0};\\n   string L,R;\\n   int min_sum,max_sum;\\n   int len;\\n   \\n   int solve(int idx, int lo, int hi, int sum)\\n   {\\n       if(idx== len)\\n       {\\n           if(sum>=min_sum && sum<=max_sum)\\n           {\\n               return 1;\\n           }\\n           return 0;\\n       }\\n\\n\\n       if(dp[idx][lo][hi][sum] == -1)\\n       { \\n\\n           long long ans=0;\\n           int lowLim = 0;\\n           int highLim=9;\\n           if(lo == 1)\\n           {\\n               lowLim=L[idx]-\\'0\\';\\n           }\\n           if(hi == 1)\\n           {\\n               highLim=R[idx]-\\'0\\';\\n           }\\n\\n           for(int i = lowLim;i<=highLim;i++)\\n           {\\n               int nlo = lo;\\n               int nhi= hi;\\n               if(i != L[idx]-\\'0\\' )\\n               {\\n                   nlo=0;\\n               }\\n               if(i != R[idx]-\\'0\\')\\n               {\\n                   nhi =0;\\n               }\\n              \\n              long long nsum = (sum+i);\\n\\n              ans =(ans%M+solve(idx+1,nlo,nhi,nsum)%M)%M; \\n               \\n           }\\n\\n           dp[idx][lo][hi][sum]=ans;\\n\\n       }\\n\\n       return dp[idx][lo][hi][sum];\\n   }\\n\\n\\n\\n  \\n    int count(string num1, string num2, int mini, int maxi) {\\n        int n = num2.size();\\n        int totalZeroAppend = n-num1.size();\\n        string temp=\"\";\\n        for(int i=0;i<totalZeroAppend;i++)\\n        {\\n            temp+=\\'0\\';\\n        }\\n        temp=temp+num1;\\n       \\n        L=temp;\\n        R=num2;\\n        min_sum=mini;\\n        max_sum=maxi;\\n        len=n;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,1,1,0);\\n\\n\\n    \\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nconst int M=1e9+7;\\n\\nclass Solution {\\npublic:\\n    int dp[25][2][2][500]={0};\\n   string L,R;\\n   int min_sum,max_sum;\\n   int len;\\n   \\n   int solve(int idx, int lo, int hi, int sum)\\n   {\\n       if(idx== len)\\n       {\\n           if(sum>=min_sum && sum<=max_sum)\\n           {\\n               return 1;\\n           }\\n           return 0;\\n       }\\n\\n\\n       if(dp[idx][lo][hi][sum] == -1)\\n       { \\n\\n           long long ans=0;\\n           int lowLim = 0;\\n           int highLim=9;\\n           if(lo == 1)\\n           {\\n               lowLim=L[idx]-\\'0\\';\\n           }\\n           if(hi == 1)\\n           {\\n               highLim=R[idx]-\\'0\\';\\n           }\\n\\n           for(int i = lowLim;i<=highLim;i++)\\n           {\\n               int nlo = lo;\\n               int nhi= hi;\\n               if(i != L[idx]-\\'0\\' )\\n               {\\n                   nlo=0;\\n               }\\n               if(i != R[idx]-\\'0\\')\\n               {\\n                   nhi =0;\\n               }\\n              \\n              long long nsum = (sum+i);\\n\\n              ans =(ans%M+solve(idx+1,nlo,nhi,nsum)%M)%M; \\n               \\n           }\\n\\n           dp[idx][lo][hi][sum]=ans;\\n\\n       }\\n\\n       return dp[idx][lo][hi][sum];\\n   }\\n\\n\\n\\n  \\n    int count(string num1, string num2, int mini, int maxi) {\\n        int n = num2.size();\\n        int totalZeroAppend = n-num1.size();\\n        string temp=\"\";\\n        for(int i=0;i<totalZeroAppend;i++)\\n        {\\n            temp+=\\'0\\';\\n        }\\n        temp=temp+num1;\\n       \\n        L=temp;\\n        R=num2;\\n        min_sum=mini;\\n        max_sum=maxi;\\n        len=n;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,1,1,0);\\n\\n\\n    \\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038865,
                "title": "digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount all the numbers that satisfy the given condition upto num2 (say x), then count all the numbers that satisfy the condition upto num1 (say y). Subtract y from x to get the desired result. One thing to note is num1 is inclusive so we explicitly again check for num1 and if it satisfies, we add that (i.e. 1) to our result. Since the number range is very large we cannot just convert to integers and then count, hence we move digit by digit upto the length of maximum string (ending number) possible and sum up each digit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse classic digit Dp approach to solve this problem. Move index by index considering all the possible digits at that position and sum up that digit. At the end if this sum satisfies our condition, we include that string (number in that range) to our ans else we reject.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are just filling our DP table and then re-using its results, hence the time taken is proportional to the time taken to fill the table.\\nlet max size of string possible to be n and the max sum to be m.\\nThe complexity will be $$O(2*n*m)$$.  \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using an array for our DP.\\nlet max size of string possible to be n and the max sum to be m.\\nThe complexity will be $$O(2*n*m)$$.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7, mini, maxi;\\n    long dp[23][2][401];\\n    long solve(int ind, bool tight, int sum, string &s){\\n        if (ind == s.size()){\\n            if (sum >= mini && sum <= maxi)\\n                return 1;\\n            return 0;\\n        }\\n        if (dp[ind][tight][sum] != -1)\\n            return dp[ind][tight][sum];\\n        int end = tight ? s[ind]-\\'0\\' : 9;\\n        long ans = 0;\\n        for (int digit = 0 ; digit <= end ; digit++){\\n            bool newTight = tight && (digit == end);\\n            ans = ((ans%mod) + (solve(ind+1,newTight,sum+digit,s)%mod)); \\n        }\\n        return dp[ind][tight][sum] = ans%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        mini = min_sum, maxi = max_sum;\\n        memset(dp,-1,sizeof(dp));\\n        long left = solve(0,1,0,num1);\\n        memset(dp,-1,sizeof(dp));\\n        long right = solve(0,1,0,num2);\\n        int val = 0;\\n        for (int i = 0 ; i < num1.size() ; i++){\\n            val += num1[i]-\\'0\\';\\n        }\\n        if (val >= min_sum && val <= max_sum)\\n            return (right-left+1+mod)%mod;\\n        return (right-left+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7, mini, maxi;\\n    long dp[23][2][401];\\n    long solve(int ind, bool tight, int sum, string &s){\\n        if (ind == s.size()){\\n            if (sum >= mini && sum <= maxi)\\n                return 1;\\n            return 0;\\n        }\\n        if (dp[ind][tight][sum] != -1)\\n            return dp[ind][tight][sum];\\n        int end = tight ? s[ind]-\\'0\\' : 9;\\n        long ans = 0;\\n        for (int digit = 0 ; digit <= end ; digit++){\\n            bool newTight = tight && (digit == end);\\n            ans = ((ans%mod) + (solve(ind+1,newTight,sum+digit,s)%mod)); \\n        }\\n        return dp[ind][tight][sum] = ans%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        mini = min_sum, maxi = max_sum;\\n        memset(dp,-1,sizeof(dp));\\n        long left = solve(0,1,0,num1);\\n        memset(dp,-1,sizeof(dp));\\n        long right = solve(0,1,0,num2);\\n        int val = 0;\\n        for (int i = 0 ; i < num1.size() ; i++){\\n            val += num1[i]-\\'0\\';\\n        }\\n        if (val >= min_sum && val <= max_sum)\\n            return (right-left+1+mod)%mod;\\n        return (right-left+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014071,
                "title": "digit-dp-count-of-integers-with-sum-in-given-range-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long int dp[23][230][2];\\n    // pos, sum, tight \\n    const int MOD = 1e9 + 7;\\n    int mi, mx;\\n    long long int memo(int pos, int sum, int tight, string &num){\\n        if(pos == num.size()){\\n            if(sum >= mi and sum <= mx) return 1;\\n            return 0;\\n        }\\n\\n        if(dp[pos][sum][tight]!=-1) return dp[pos][sum][tight];\\n        int limit = 9;\\n        if(tight) limit = num[pos]-\\'0\\';\\n        long long int ans = 0;\\n        for(int dig = 0; dig <= limit ; dig++){\\n            ans += memo(pos+1,sum+dig,tight&(limit == dig), num);\\n        }\\n\\n        return dp[pos][sum][tight] = ans%MOD;\\n    }\\n\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        mi = min_sum, mx = max_sum;\\n        memset(dp,-1,sizeof(dp));\\n        int right = memo(0,0,1,num2);\\n        memset(dp,-1,sizeof(dp));\\n        int left = memo(0,0,1,num1);\\n        long long int ans = (MOD + right%MOD - left%MOD)%MOD;\\n        int s = 0;\\n        for(int i = 0;i<num1.size();i++) s += (num1[i]-\\'0\\');\\n        if(s >= min_sum and s <= max_sum){\\n            ans +=1;\\n            ans %= MOD;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long int dp[23][230][2];\\n    // pos, sum, tight \\n    const int MOD = 1e9 + 7;\\n    int mi, mx;\\n    long long int memo(int pos, int sum, int tight, string &num){\\n        if(pos == num.size()){\\n            if(sum >= mi and sum <= mx) return 1;\\n            return 0;\\n        }\\n\\n        if(dp[pos][sum][tight]!=-1) return dp[pos][sum][tight];\\n        int limit = 9;\\n        if(tight) limit = num[pos]-\\'0\\';\\n        long long int ans = 0;\\n        for(int dig = 0; dig <= limit ; dig++){\\n            ans += memo(pos+1,sum+dig,tight&(limit == dig), num);\\n        }\\n\\n        return dp[pos][sum][tight] = ans%MOD;\\n    }\\n\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        mi = min_sum, mx = max_sum;\\n        memset(dp,-1,sizeof(dp));\\n        int right = memo(0,0,1,num2);\\n        memset(dp,-1,sizeof(dp));\\n        int left = memo(0,0,1,num1);\\n        long long int ans = (MOD + right%MOD - left%MOD)%MOD;\\n        int s = 0;\\n        for(int i = 0;i<num1.size();i++) s += (num1[i]-\\'0\\');\\n        if(s >= min_sum and s <= max_sum){\\n            ans +=1;\\n            ans %= MOD;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008139,
                "title": "c-digit-dp-not-so-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long  mod = 1e9+7;\\n    long double solve(int i, int sum, bool tight, int mins, int maxs, string R, int n, vector<vector<vector<long>>> &dp)\\n    {\\n        if(i == n)\\n        {\\n            if(sum >= mins && sum <= maxs)\\n            {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][sum][tight] != -1)\\n            return dp[i][sum][tight];\\n        long ans = 0;\\n        int ub = tight ? R[i]-\\'0\\' : 9;\\n        for(int j = 0 ; j <= ub ; j++)\\n        {\\n            if(tight && j == ub)\\n            {\\n                if(sum+j <= maxs)\\n                {\\n                    ans = ans + solve(i+1, sum+j, 1, mins, maxs, R, n, dp);\\n                    ans %= mod;\\n                }\\n            }\\n            else\\n            {\\n                if(sum+j <= maxs)\\n                {\\n                    ans = ans + solve(i+1, sum+j, 0, mins, maxs, R, n, dp);\\n                    ans %= mod;\\n                }\\n                    \\n            }\\n        } \\n        return dp[i][sum][tight] = ans;\\n    }\\n    int count(string L, string R, int min_sum, int max_sum) {\\n        //counting till right\\n        int n = R.length();\\n        int m = L.length();\\n        vector<vector<vector<long>>> dp(n+1, vector<vector<long>>(401, vector<long> (2, -1)));\\n        long  right = solve(0, 0, 1, min_sum, max_sum, R, n, dp);\\n        vector<vector<vector<long>>> dp2(m+1, vector<vector<long>>(401, vector<long> (2, -1)));\\n        long  left = solve(0, 0, 1, min_sum, max_sum, L, m, dp2);\\n        long  at_left = 0;\\n        int sum = 0;\\n        for(int i = 0 ; i < L.length() ; i++)\\n        {\\n            sum = sum + (L[i]-\\'0\\');\\n        }\\n        if(sum >= min_sum && sum <= max_sum)\\n            at_left = 1;    \\n        if ((right-left+at_left) < 0)\\n            return (right-left+at_left)+mod;\\n        return (right-left+at_left);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long  mod = 1e9+7;\\n    long double solve(int i, int sum, bool tight, int mins, int maxs, string R, int n, vector<vector<vector<long>>> &dp)\\n    {\\n        if(i == n)\\n        {\\n            if(sum >= mins && sum <= maxs)\\n            {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][sum][tight] != -1)\\n            return dp[i][sum][tight];\\n        long ans = 0;\\n        int ub = tight ? R[i]-\\'0\\' : 9;\\n        for(int j = 0 ; j <= ub ; j++)\\n        {\\n            if(tight && j == ub)\\n            {\\n                if(sum+j <= maxs)\\n                {\\n                    ans = ans + solve(i+1, sum+j, 1, mins, maxs, R, n, dp);\\n                    ans %= mod;\\n                }\\n            }\\n            else\\n            {\\n                if(sum+j <= maxs)\\n                {\\n                    ans = ans + solve(i+1, sum+j, 0, mins, maxs, R, n, dp);\\n                    ans %= mod;\\n                }\\n                    \\n            }\\n        } \\n        return dp[i][sum][tight] = ans;\\n    }\\n    int count(string L, string R, int min_sum, int max_sum) {\\n        //counting till right\\n        int n = R.length();\\n        int m = L.length();\\n        vector<vector<vector<long>>> dp(n+1, vector<vector<long>>(401, vector<long> (2, -1)));\\n        long  right = solve(0, 0, 1, min_sum, max_sum, R, n, dp);\\n        vector<vector<vector<long>>> dp2(m+1, vector<vector<long>>(401, vector<long> (2, -1)));\\n        long  left = solve(0, 0, 1, min_sum, max_sum, L, m, dp2);\\n        long  at_left = 0;\\n        int sum = 0;\\n        for(int i = 0 ; i < L.length() ; i++)\\n        {\\n            sum = sum + (L[i]-\\'0\\');\\n        }\\n        if(sum >= min_sum && sum <= max_sum)\\n            at_left = 1;    \\n        if ((right-left+at_left) < 0)\\n            return (right-left+at_left)+mod;\\n        return (right-left+at_left);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007406,
                "title": "c-easy-to-understand-easy-to-code-digit-dp-dp-memorization-recursion",
                "content": "----------------------------------------------------------------------\\n# Please Do upvote if you like this solution.\\n----------------------------------------------------------------------\\n# Let\\'s Connect on :- [LinkedIn](https://www.linkedin.com/in/mann-chandarana-115255230/)\\n\\n----------------------------------------------------------------------\\n\\n# Code\\n```\\n#define ll long long\\n\\nint mod = 1e9 + 7;\\n\\nint dp[24][2][401];\\n\\nint solve(string &nums, int min_sum, int max_sum, int pos = 0, int tight = 1, int sum = 0)\\n{\\n    if (pos == nums.size())\\n    {\\n        if (sum >= min_sum and sum <= max_sum)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n\\n    if (dp[pos][tight][sum] != -1)\\n        return dp[pos][tight][sum];\\n\\n    ll end = tight ? (nums[pos] - \\'0\\') : 9;\\n\\n    ll ans = 0;\\n    for (ll i = 0; i <= end; i++)\\n        ans += (solve(nums, min_sum, max_sum, pos + 1, (tight && (i == nums[pos] - \\'0\\')), (sum + i))) % mod;\\n\\n    return (dp[pos][tight][sum] = (ans%mod));\\n}\\n\\nint count(string num1, string num2, int min_sum, int max_sum)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    ll high = (solve(num2, min_sum, max_sum)) % mod;\\n\\n    memset(dp, -1, sizeof(dp));\\n    ll low = (solve(num1, min_sum, max_sum)) % mod;\\n\\n    ll result = (high - low);\\n    result+=mod;\\n    result%=mod;\\n\\n    ll atNum1 = 0;\\n    for (int i = 0; i < num1.size(); i++)\\n        atNum1 += (num1[i] - \\'0\\');\\n\\n    return (result + ((atNum1 >= min_sum and atNum1 <= max_sum) ? 1 : 0))%mod;\\n}\\n```\\n----------------------------------------------------------------------\\n![image.png](https://assets.leetcode.com/users/images/db062148-350c-4996-841c-813e079a3c14_1693949636.615403.png)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\n\\nint mod = 1e9 + 7;\\n\\nint dp[24][2][401];\\n\\nint solve(string &nums, int min_sum, int max_sum, int pos = 0, int tight = 1, int sum = 0)\\n{\\n    if (pos == nums.size())\\n    {\\n        if (sum >= min_sum and sum <= max_sum)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n\\n    if (dp[pos][tight][sum] != -1)\\n        return dp[pos][tight][sum];\\n\\n    ll end = tight ? (nums[pos] - \\'0\\') : 9;\\n\\n    ll ans = 0;\\n    for (ll i = 0; i <= end; i++)\\n        ans += (solve(nums, min_sum, max_sum, pos + 1, (tight && (i == nums[pos] - \\'0\\')), (sum + i))) % mod;\\n\\n    return (dp[pos][tight][sum] = (ans%mod));\\n}\\n\\nint count(string num1, string num2, int min_sum, int max_sum)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    ll high = (solve(num2, min_sum, max_sum)) % mod;\\n\\n    memset(dp, -1, sizeof(dp));\\n    ll low = (solve(num1, min_sum, max_sum)) % mod;\\n\\n    ll result = (high - low);\\n    result+=mod;\\n    result%=mod;\\n\\n    ll atNum1 = 0;\\n    for (int i = 0; i < num1.size(); i++)\\n        atNum1 += (num1[i] - \\'0\\');\\n\\n    return (result + ((atNum1 >= min_sum and atNum1 <= max_sum) ? 1 : 0))%mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962656,
                "title": "digit-dp-recursion-memorization-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int MOD = 1e9 + 7;\\n    long long G(string str, int pos, int tight, long long sum, int min_sum, int max_sum, int dp[23][2][207]) {\\n        // base case\\n        if(pos == str.size()) {\\n            if(sum >= min_sum and sum <= max_sum) return 1;\\n            return 0;\\n        }\\n\\n        if(dp[pos][tight][sum] != -1) return dp[pos][tight][sum];\\n\\n        if(tight) {\\n            long long cnt = 0;\\n            for(int i = 0; i <= str[pos] - \\'0\\'; i++) {\\n                if(i == str[pos] - \\'0\\') {\\n                    cnt += G(str, pos + 1, 1, sum + i, min_sum, max_sum, dp)%MOD;\\n                }\\n                else {\\n                    cnt += G(str, pos + 1, 0, sum + i, min_sum, max_sum, dp)%MOD;\\n                }\\n            }\\n            return dp[pos][tight][sum] = cnt%MOD;\\n        }\\n        else {\\n            long long cnt = 0;\\n            for(int i = 0; i <= 9; i++) {\\n                cnt += G(str, pos + 1, 0, sum + i, min_sum, max_sum, dp)%MOD;\\n            }\\n            return dp[pos][tight][sum] = cnt%MOD;\\n        }\\n    }\\n\\n    void solve(string &num1)\\n    {\\n        int n = num1.length() ; \\n        int i =n-1 ; \\n        while(i>=0)\\n        {\\n            if(num1[i]==\\'0\\')\\n            {\\n                num1[i] = \\'9\\' ; \\n            }\\n            else if(num1[i]>\\'0\\')\\n            {\\n                num1[i]-=1;\\n                break ;\\n            }\\n            i-- ;\\n        }\\n        if(num1[0]==\\'0\\' &&  num1.length()!=1)\\n        {\\n            num1 = num1.substr(1) ;\\n        }\\n    }\\n\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int dp[23][2][207];\\n\\n        solve(num1);\\n\\n        memset(dp, -1, sizeof(dp));\\n        long long ans1 = G(num1, 0, 1, 0, min_sum, max_sum, dp);\\n\\n        memset(dp, -1, sizeof(dp));\\n        long long ans2 = G(num2, 0, 1, 0, min_sum, max_sum, dp);\\n\\n        return (ans2 - ans1 + MOD)%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int MOD = 1e9 + 7;\\n    long long G(string str, int pos, int tight, long long sum, int min_sum, int max_sum, int dp[23][2][207]) {\\n        // base case\\n        if(pos == str.size()) {\\n            if(sum >= min_sum and sum <= max_sum) return 1;\\n            return 0;\\n        }\\n\\n        if(dp[pos][tight][sum] != -1) return dp[pos][tight][sum];\\n\\n        if(tight) {\\n            long long cnt = 0;\\n            for(int i = 0; i <= str[pos] - \\'0\\'; i++) {\\n                if(i == str[pos] - \\'0\\') {\\n                    cnt += G(str, pos + 1, 1, sum + i, min_sum, max_sum, dp)%MOD;\\n                }\\n                else {\\n                    cnt += G(str, pos + 1, 0, sum + i, min_sum, max_sum, dp)%MOD;\\n                }\\n            }\\n            return dp[pos][tight][sum] = cnt%MOD;\\n        }\\n        else {\\n            long long cnt = 0;\\n            for(int i = 0; i <= 9; i++) {\\n                cnt += G(str, pos + 1, 0, sum + i, min_sum, max_sum, dp)%MOD;\\n            }\\n            return dp[pos][tight][sum] = cnt%MOD;\\n        }\\n    }\\n\\n    void solve(string &num1)\\n    {\\n        int n = num1.length() ; \\n        int i =n-1 ; \\n        while(i>=0)\\n        {\\n            if(num1[i]==\\'0\\')\\n            {\\n                num1[i] = \\'9\\' ; \\n            }\\n            else if(num1[i]>\\'0\\')\\n            {\\n                num1[i]-=1;\\n                break ;\\n            }\\n            i-- ;\\n        }\\n        if(num1[0]==\\'0\\' &&  num1.length()!=1)\\n        {\\n            num1 = num1.substr(1) ;\\n        }\\n    }\\n\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int dp[23][2][207];\\n\\n        solve(num1);\\n\\n        memset(dp, -1, sizeof(dp));\\n        long long ans1 = G(num1, 0, 1, 0, min_sum, max_sum, dp);\\n\\n        memset(dp, -1, sizeof(dp));\\n        long long ans2 = G(num2, 0, 1, 0, min_sum, max_sum, dp);\\n\\n        return (ans2 - ans1 + MOD)%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959509,
                "title": "standard-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[25][401][2];\\n    int maxi, mini;\\n    int mod = (int)1e9 + 7;\\n    long long solve(string &s, int ind, int sum, bool tight) {\\n        if (ind == s.size()) {\\n            if(sum >= mini && sum <= maxi) return 1;\\n            return 0;\\n        }\\n        if (dp[ind][sum][tight] != -1) return dp[ind][sum][tight];\\n\\n        int ub = tight ? (s[ind] - \\'0\\') : 9;\\n        long long ans = 0;\\n\\n        for (int i = 0; i <= ub; i++) {\\n            bool ntight = tight;\\n            if (tight && i < ub) ntight = false;\\n            ans += solve(s, ind + 1, sum + i, ntight);\\n            ans %= mod;\\n        }\\n\\n        return dp[ind][sum][tight] = (int) ans ;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int n = num1.size();\\n        this -> maxi = max_sum;\\n        this -> mini = min_sum;\\n\\n        if(num1[n - 1] != \\'0\\') --num1[n - 1];\\n        else {\\n            int i = n - 1;\\n            bool sub = false;\\n            for(; i >= 0 ;i --) {\\n                if(num1[i] == \\'0\\') num1[i] = \\'9\\', sub = true;\\n                else break;\\n            }\\n            if(sub) --num1[i];\\n            else --num1[n - 1];\\n            if(num1[0] == \\'0\\') num1 = num1.substr(1); \\n        }\\n\\n        memset(dp, -1, sizeof dp);\\n        long long temp = solve(num1, 0, 0 , true);\\n\\n        memset(dp , -1, sizeof dp);\\n        long long  temp1 = solve(num2, 0, 0, true);\\n\\n        return (temp1 - temp + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[25][401][2];\\n    int maxi, mini;\\n    int mod = (int)1e9 + 7;\\n    long long solve(string &s, int ind, int sum, bool tight) {\\n        if (ind == s.size()) {\\n            if(sum >= mini && sum <= maxi) return 1;\\n            return 0;\\n        }\\n        if (dp[ind][sum][tight] != -1) return dp[ind][sum][tight];\\n\\n        int ub = tight ? (s[ind] - \\'0\\') : 9;\\n        long long ans = 0;\\n\\n        for (int i = 0; i <= ub; i++) {\\n            bool ntight = tight;\\n            if (tight && i < ub) ntight = false;\\n            ans += solve(s, ind + 1, sum + i, ntight);\\n            ans %= mod;\\n        }\\n\\n        return dp[ind][sum][tight] = (int) ans ;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int n = num1.size();\\n        this -> maxi = max_sum;\\n        this -> mini = min_sum;\\n\\n        if(num1[n - 1] != \\'0\\') --num1[n - 1];\\n        else {\\n            int i = n - 1;\\n            bool sub = false;\\n            for(; i >= 0 ;i --) {\\n                if(num1[i] == \\'0\\') num1[i] = \\'9\\', sub = true;\\n                else break;\\n            }\\n            if(sub) --num1[i];\\n            else --num1[n - 1];\\n            if(num1[0] == \\'0\\') num1 = num1.substr(1); \\n        }\\n\\n        memset(dp, -1, sizeof dp);\\n        long long temp = solve(num1, 0, 0 , true);\\n\\n        memset(dp , -1, sizeof dp);\\n        long long  temp1 = solve(num2, 0, 0, true);\\n\\n        return (temp1 - temp + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953565,
                "title": "easy-to-understand-no-dp-intuitive-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp[24][401][2];\\n    int mod=1e9+7;\\n    int func(string &num,int n,bool tight,int sum,int maxtarget,int mintarget){\\n        if(sum>maxtarget) return 0;\\n        if(n==0 && sum<mintarget) return 0;\\n        if(n==0 && sum<=maxtarget && sum>=mintarget) return 1;\\n        if(dp[n][sum][tight]!=-1) return dp[n][sum][tight];\\n        long long ans=0;\\n        int ub=(tight)?(num[num.length()-n]-\\'0\\'):9;\\n        for(int i=0;i<=ub;i++){\\n            ans+=func(num,n-1,(tight && (i==ub)),sum+i,maxtarget,mintarget);\\n            ans%=mod;\\n        }\\n        return dp[n][sum][tight]=ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1LL,sizeof(dp));\\n        long long ans1=func(num1,num1.length(),1,0,max_sum,min_sum);\\n        memset(dp,-1LL,sizeof(dp));\\n        long long ans2=func(num2,num2.length(),1,0,max_sum,min_sum);\\n        int temp=0;\\n        for(int i=0;i<num1.length();i++){\\n            temp+=(num1[i]-\\'0\\');\\n        }\\n        if(temp>=min_sum && temp<=max_sum){\\n            ans2++;\\n        }\\n        return (ans2-ans1+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[24][401][2];\\n    int mod=1e9+7;\\n    int func(string &num,int n,bool tight,int sum,int maxtarget,int mintarget){\\n        if(sum>maxtarget) return 0;\\n        if(n==0 && sum<mintarget) return 0;\\n        if(n==0 && sum<=maxtarget && sum>=mintarget) return 1;\\n        if(dp[n][sum][tight]!=-1) return dp[n][sum][tight];\\n        long long ans=0;\\n        int ub=(tight)?(num[num.length()-n]-\\'0\\'):9;\\n        for(int i=0;i<=ub;i++){\\n            ans+=func(num,n-1,(tight && (i==ub)),sum+i,maxtarget,mintarget);\\n            ans%=mod;\\n        }\\n        return dp[n][sum][tight]=ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1LL,sizeof(dp));\\n        long long ans1=func(num1,num1.length(),1,0,max_sum,min_sum);\\n        memset(dp,-1LL,sizeof(dp));\\n        long long ans2=func(num2,num2.length(),1,0,max_sum,min_sum);\\n        int temp=0;\\n        for(int i=0;i<num1.length();i++){\\n            temp+=(num1[i]-\\'0\\');\\n        }\\n        if(temp>=min_sum && temp<=max_sum){\\n            ans2++;\\n        }\\n        return (ans2-ans1+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953204,
                "title": "digit-dp-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int dp[23][2][200];\\n    \\n    int recur(string &s, int &mini, int &maxi, int pos, int tight, int sum) {\\n        if (pos == s.size()) {\\n            if (sum >= mini && sum <= maxi) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if (dp[pos][tight][sum] != -1) {\\n            return dp[pos][tight][sum];\\n        }\\n        \\n        int ans = 0;\\n        int ub = tight ? s[pos] - \\'0\\' : 9;\\n        \\n        for (int digit = 0; digit <= ub; digit++) {\\n            int nt = tight && (digit == ub);\\n            ans = (ans + recur(s, mini, maxi, pos + 1, nt, sum + digit)) % mod;\\n        }\\n        \\n        return dp[pos][tight][sum] = ans;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof dp);\\n        int a = recur(num1, min_sum, max_sum, 0, 1, 0);\\n        \\n        memset(dp, -1, sizeof dp);\\n        int b = recur(num2, min_sum, max_sum, 0, 1, 0);\\n        \\n        int x = 0;\\n        for (char c : num1) {\\n            x += (c - \\'0\\');\\n        }\\n        \\n        int result = (b - a + (x >= min_sum && x <= max_sum)) % mod;\\n        if (result < 0) {\\n            result += mod;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int dp[23][2][200];\\n    \\n    int recur(string &s, int &mini, int &maxi, int pos, int tight, int sum) {\\n        if (pos == s.size()) {\\n            if (sum >= mini && sum <= maxi) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if (dp[pos][tight][sum] != -1) {\\n            return dp[pos][tight][sum];\\n        }\\n        \\n        int ans = 0;\\n        int ub = tight ? s[pos] - \\'0\\' : 9;\\n        \\n        for (int digit = 0; digit <= ub; digit++) {\\n            int nt = tight && (digit == ub);\\n            ans = (ans + recur(s, mini, maxi, pos + 1, nt, sum + digit)) % mod;\\n        }\\n        \\n        return dp[pos][tight][sum] = ans;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof dp);\\n        int a = recur(num1, min_sum, max_sum, 0, 1, 0);\\n        \\n        memset(dp, -1, sizeof dp);\\n        int b = recur(num2, min_sum, max_sum, 0, 1, 0);\\n        \\n        int x = 0;\\n        for (char c : num1) {\\n            x += (c - \\'0\\');\\n        }\\n        \\n        int result = (b - a + (x >= min_sum && x <= max_sum)) % mod;\\n        if (result < 0) {\\n            result += mod;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949892,
                "title": "digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long dp[23][401][2][2];\\n\\n   int mod=1e9+7;\\nlong long  fun(int i,int total,int strict,int strict1,string&first,string&second,int l){\\n\\n     if(i>=first.size()){\\n         if(total<=l&&total>0) return 1;\\n         return 0;\\n     }\\n\\n     long long  ans=0;\\n if(dp[i][total][strict][strict1]!=-1) return dp[i][total][strict][strict1];\\n\\n\\n    if(total==0){\\n        if(strict1==1){\\n          for(int j=first[i]-\\'0\\';j<=second[i]-\\'0\\';j++){\\n              long long  val=0,val1=0;\\n              if(first[i]-\\'0\\'==j) val=1;\\n              if(second[i]-\\'0\\'==j) val1=1;\\n              ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n          }\\n        }\\n        else{\\n            if(strict==1){\\n                for(int j=first[i]-\\'0\\';j<=9;j++){\\n                    long long  val=0,val1=0;\\n                   if(first[i]-\\'0\\'==j) val=1;\\n                    ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n                }\\n            }\\n                else{\\n                    for(int j=1;j<=9;j++){\\n                    long long  val=0,val1=0;\\n                     ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n                }\\n                }\\n            }\\n\\n        }\\n    \\n\\n\\n\\n    else{\\n        if(strict1==1){\\n            if(strict==1){\\n              for(int j=first[i]-\\'0\\';j<=second[i]-\\'0\\';j++){\\n              long long  val=0,val1=0;\\n              if(first[i]-\\'0\\'==j) val=1;\\n              if(second[i]-\\'0\\'==j) val1=1;\\n              ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n          }\\n        }\\n        else{\\n            for(int j=0;j<=second[i]-\\'0\\';j++){\\n              long long  val=0,val1=0;\\n              if(second[i]-\\'0\\'==j) val1=1;\\n              ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n          }\\n        }\\n          \\n        }\\n        else{\\n            if(strict==1){\\n                for(int j=first[i]-\\'0\\';j<=9;j++){\\n                    long long  val=0,val1=0;\\n                    if(first[i]-\\'0\\'==j) val=1;\\n                    ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n                }\\n            }\\n                else{\\n                    for(int j=0;j<=9;j++){\\n                     long long  val=0,val1=0;\\n                     ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n                }\\n                }\\n            }\\n\\n        }\\n    \\n       return dp[i][total][strict][strict1]=ans%mod;\\n}\\n\\n\\n\\n    int count(string num1, string num2, int l, int r) { \\n    memset(dp,-1,sizeof(dp));\\n    string first=\"\";\\n    int n=num2.size();\\n    int n1=num1.size();\\n    n-=n1;\\n    for(int i=0;i<n;i++) first+=\\'0\\';\\n    first+=num1;\\n    l-=1;\\n    int val=fun(0,0,1,1,first,num2,l);\\n    memset(dp,-1,sizeof(dp));\\n    int val1=fun(0,0,1,1,first,num2,r);\\n    return (val1-val+mod)%mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long dp[23][401][2][2];\\n\\n   int mod=1e9+7;\\nlong long  fun(int i,int total,int strict,int strict1,string&first,string&second,int l){\\n\\n     if(i>=first.size()){\\n         if(total<=l&&total>0) return 1;\\n         return 0;\\n     }\\n\\n     long long  ans=0;\\n if(dp[i][total][strict][strict1]!=-1) return dp[i][total][strict][strict1];\\n\\n\\n    if(total==0){\\n        if(strict1==1){\\n          for(int j=first[i]-\\'0\\';j<=second[i]-\\'0\\';j++){\\n              long long  val=0,val1=0;\\n              if(first[i]-\\'0\\'==j) val=1;\\n              if(second[i]-\\'0\\'==j) val1=1;\\n              ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n          }\\n        }\\n        else{\\n            if(strict==1){\\n                for(int j=first[i]-\\'0\\';j<=9;j++){\\n                    long long  val=0,val1=0;\\n                   if(first[i]-\\'0\\'==j) val=1;\\n                    ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n                }\\n            }\\n                else{\\n                    for(int j=1;j<=9;j++){\\n                    long long  val=0,val1=0;\\n                     ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n                }\\n                }\\n            }\\n\\n        }\\n    \\n\\n\\n\\n    else{\\n        if(strict1==1){\\n            if(strict==1){\\n              for(int j=first[i]-\\'0\\';j<=second[i]-\\'0\\';j++){\\n              long long  val=0,val1=0;\\n              if(first[i]-\\'0\\'==j) val=1;\\n              if(second[i]-\\'0\\'==j) val1=1;\\n              ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n          }\\n        }\\n        else{\\n            for(int j=0;j<=second[i]-\\'0\\';j++){\\n              long long  val=0,val1=0;\\n              if(second[i]-\\'0\\'==j) val1=1;\\n              ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n          }\\n        }\\n          \\n        }\\n        else{\\n            if(strict==1){\\n                for(int j=first[i]-\\'0\\';j<=9;j++){\\n                    long long  val=0,val1=0;\\n                    if(first[i]-\\'0\\'==j) val=1;\\n                    ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n                }\\n            }\\n                else{\\n                    for(int j=0;j<=9;j++){\\n                     long long  val=0,val1=0;\\n                     ans=(ans+fun(i+1,total+j,val,val1,first,second,l))%mod;\\n                }\\n                }\\n            }\\n\\n        }\\n    \\n       return dp[i][total][strict][strict1]=ans%mod;\\n}\\n\\n\\n\\n    int count(string num1, string num2, int l, int r) { \\n    memset(dp,-1,sizeof(dp));\\n    string first=\"\";\\n    int n=num2.size();\\n    int n1=num1.size();\\n    n-=n1;\\n    for(int i=0;i<n;i++) first+=\\'0\\';\\n    first+=num1;\\n    l-=1;\\n    int val=fun(0,0,1,1,first,num2,l);\\n    memset(dp,-1,sizeof(dp));\\n    int val1=fun(0,0,1,1,first,num2,r);\\n    return (val1-val+mod)%mod;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933081,
                "title": "one-pass-easy-dp",
                "content": "# Complexity\\n- Time complexity: O(24 x 400 x 2 x 2)\\n\\n- Space complexity: O(24 x 400 x 2 x 2)\\n\\n# Prerequisite\\n-  Digit DP\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[24][401][2][2];\\n    int mod = 1000000007;\\n    int solve(string& num2, string& num1, int n, int max_sum, int min_sum, int curr_sum, int tight1, int tight2){\\n        if(curr_sum > max_sum) return 0;\\n        if(n == 0){\\n            if(curr_sum >= min_sum && curr_sum <= max_sum) return 1;\\n            return 0;\\n        }\\n        if(dp[n][curr_sum][tight1][tight2] != -1)return dp[n][curr_sum][tight1][tight2]; \\n        int ans = 0, rightLimit = num2[num2.size()-n]-\\'0\\', leftLimit = num1[num2.size()-n]-\\'0\\';\\n        if(!tight2)rightLimit = 9;\\n        if(!tight1)leftLimit = 0;\\n        for(int i = leftLimit; i<= rightLimit; i++){\\n            ans = (ans + solve(num2, num1, n-1, max_sum, min_sum, curr_sum+i, tight1&(i==leftLimit),tight2&(i==rightLimit)))%mod;\\n        }\\n        return dp[n][curr_sum][tight1][tight2] = ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof(dp));\\n        int n = num2.size();\\n        int k = (num2.size()-num1.size());\\n        string temp;\\n        while(k--) temp += \"0\";\\n        temp.append(num1);\\n        int r = solve(num2, temp, n, max_sum, min_sum, 0, 1, 1);\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[24][401][2][2];\\n    int mod = 1000000007;\\n    int solve(string& num2, string& num1, int n, int max_sum, int min_sum, int curr_sum, int tight1, int tight2){\\n        if(curr_sum > max_sum) return 0;\\n        if(n == 0){\\n            if(curr_sum >= min_sum && curr_sum <= max_sum) return 1;\\n            return 0;\\n        }\\n        if(dp[n][curr_sum][tight1][tight2] != -1)return dp[n][curr_sum][tight1][tight2]; \\n        int ans = 0, rightLimit = num2[num2.size()-n]-\\'0\\', leftLimit = num1[num2.size()-n]-\\'0\\';\\n        if(!tight2)rightLimit = 9;\\n        if(!tight1)leftLimit = 0;\\n        for(int i = leftLimit; i<= rightLimit; i++){\\n            ans = (ans + solve(num2, num1, n-1, max_sum, min_sum, curr_sum+i, tight1&(i==leftLimit),tight2&(i==rightLimit)))%mod;\\n        }\\n        return dp[n][curr_sum][tight1][tight2] = ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof(dp));\\n        int n = num2.size();\\n        int k = (num2.size()-num1.size());\\n        string temp;\\n        while(k--) temp += \"0\";\\n        temp.append(num1);\\n        int r = solve(num2, temp, n, max_sum, min_sum, 0, 1, 1);\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860131,
                "title": "python3-easy-to-understand-easy-to-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        dp_num1 = [[[-1 for _ in range(401)] for _ in range(2)] for _ in range(len(num1) + 1)]\\n        dp_num2 = [[[-1 for _ in range(401)] for _ in range(2)] for _ in range(len(num2) + 1)]\\n        def dfs(i, curr_sum, tight, num, dp):\\n            if i == len(num):\\n                if min_sum <= curr_sum <= max_sum:\\n                    return 1\\n                else:\\n                    return 0\\n            if curr_sum > max_sum:\\n                return 0\\n            if dp[i][tight][curr_sum] != -1:\\n                return dp[i][tight][curr_sum]\\n            ans = 0\\n            upper_bound = int(num[i]) if tight else 9\\n            for new_digit in range(upper_bound + 1):\\n                ans += dfs(i + 1, curr_sum + new_digit, tight and (new_digit == upper_bound), num, dp)\\n            dp[i][tight][curr_sum] = ans\\n            return dp[i][tight][curr_sum]\\n        up_to_num2 = dfs(0, 0, True, num2, dp_num2)\\n        up_to_num1 = dfs(0, 0, True, num1, dp_num1)\\n        num1_sum = 0\\n        is_num1_inside_constraints = 0\\n        for char in num1:\\n            num1_sum += int(char)\\n        if min_sum <= num1_sum <= max_sum:\\n            is_num1_inside_constraints = 1\\n        return (up_to_num2 - up_to_num1 + is_num1_inside_constraints) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        dp_num1 = [[[-1 for _ in range(401)] for _ in range(2)] for _ in range(len(num1) + 1)]\\n        dp_num2 = [[[-1 for _ in range(401)] for _ in range(2)] for _ in range(len(num2) + 1)]\\n        def dfs(i, curr_sum, tight, num, dp):\\n            if i == len(num):\\n                if min_sum <= curr_sum <= max_sum:\\n                    return 1\\n                else:\\n                    return 0\\n            if curr_sum > max_sum:\\n                return 0\\n            if dp[i][tight][curr_sum] != -1:\\n                return dp[i][tight][curr_sum]\\n            ans = 0\\n            upper_bound = int(num[i]) if tight else 9\\n            for new_digit in range(upper_bound + 1):\\n                ans += dfs(i + 1, curr_sum + new_digit, tight and (new_digit == upper_bound), num, dp)\\n            dp[i][tight][curr_sum] = ans\\n            return dp[i][tight][curr_sum]\\n        up_to_num2 = dfs(0, 0, True, num2, dp_num2)\\n        up_to_num1 = dfs(0, 0, True, num1, dp_num1)\\n        num1_sum = 0\\n        is_num1_inside_constraints = 0\\n        for char in num1:\\n            num1_sum += int(char)\\n        if min_sum <= num1_sum <= max_sum:\\n            is_num1_inside_constraints = 1\\n        return (up_to_num2 - up_to_num1 + is_num1_inside_constraints) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843296,
                "title": "elegant-dynamic-programming-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int dp[2][2][23][401];\\n    \\n    int solve(int index, bool order, bool started, string& reference, int sum, int max_sum, int min_sum) {\\n        \\n        if(sum > max_sum) return 0;\\n        \\n        if(index == reference.size()) {\\n            return min_sum <= sum;\\n        }\\n        else if(dp[order][started][index][sum] != -1) {\\n            return dp[order][started][index][sum];\\n        }\\n        int bound = order ? 9 : reference[index] - \\'0\\';\\n        \\n        int answer = 0;\\n        \\n        for(int i = 0; i <= bound; i++) {\\n            bool o = order ? true : i!=bound;\\n            bool s = started ? true : i!=0;\\n            answer = (answer + solve(index+1, o, s, reference, sum + i, max_sum, min_sum))%mod;\\n        }\\n        \\n        return dp[order][started][index][sum] = answer;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        int f = solve(0, false, false, num2, 0, max_sum, min_sum);\\n        int counter = 0;\\n        for(char x: num1){\\n            counter+= x-\\'0\\';\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        int s = solve(0, false, false, num1, 0, max_sum, min_sum);\\n        \\n        return ((f-s + (min_sum <=counter and counter <= max_sum) ) + mod)%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int dp[2][2][23][401];\\n    \\n    int solve(int index, bool order, bool started, string& reference, int sum, int max_sum, int min_sum) {\\n        \\n        if(sum > max_sum) return 0;\\n        \\n        if(index == reference.size()) {\\n            return min_sum <= sum;\\n        }\\n        else if(dp[order][started][index][sum] != -1) {\\n            return dp[order][started][index][sum];\\n        }\\n        int bound = order ? 9 : reference[index] - \\'0\\';\\n        \\n        int answer = 0;\\n        \\n        for(int i = 0; i <= bound; i++) {\\n            bool o = order ? true : i!=bound;\\n            bool s = started ? true : i!=0;\\n            answer = (answer + solve(index+1, o, s, reference, sum + i, max_sum, min_sum))%mod;\\n        }\\n        \\n        return dp[order][started][index][sum] = answer;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        int f = solve(0, false, false, num2, 0, max_sum, min_sum);\\n        int counter = 0;\\n        for(char x: num1){\\n            counter+= x-\\'0\\';\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        int s = solve(0, false, false, num1, 0, max_sum, min_sum);\\n        \\n        return ((f-s + (min_sum <=counter and counter <= max_sum) ) + mod)%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842942,
                "title": "rust-digital-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count(num1: String, num2: String, min_sum: i32, max_sum: i32) -> i32 {\\n        let (low, up) = (min_sum as usize, max_sum as usize);\\n        let MOD = 1_000_000_007;\\n        let mut ret = (Self::cal(&num2, low, up) - Self::cal(&num1, low, up)) % MOD;\\n        (ret + Self::adjust(&num1, low, up) + MOD) % MOD\\n    }\\n\\n    fn adjust(num: &String, low: usize, up: usize) -> i32 {\\n        let mut cnt = 0;\\n        for c in num.chars() {\\n            cnt += c as usize - \\'0\\' as usize;\\n        }\\n        \\n        if cnt >= low && cnt <= up { 1 } else { 0 }\\n    }\\n\\n    fn cal(num: &String, low: usize, up: usize) -> i32 {\\n        let mut dp = vec![vec![vec![0; 2]; 401]; 23];\\n        let num = num.chars().into_iter().collect::<Vec<_>>();\\n        let MOD = 1_000_000_007;\\n        let temp = num[0] as usize - \\'0\\' as usize;\\n        \\n        dp[0][temp][0] = 1;\\n        for d in 0 .. temp { dp[0][d][1] = 1; }\\n\\n        for i in 1 .. num.len() {\\n            let k = num[i] as usize - \\'0\\' as usize;\\n            for d in 0 .. 10 {\\n                if d == k {\\n                    for s in 0 ..= up {\\n                        if s + d > up { break }\\n                        dp[i][s + d][0] = (dp[i][s + d][0] + dp[i - 1][s][0]) % MOD;\\n                    } \\n                }\\n\\n                if d < k {\\n                    for s in 0 ..= up {\\n                        if s + d > up { break }\\n                        dp[i][s + d][1] = (dp[i][s + d][1] + dp[i - 1][s][0]) % MOD;\\n                    } \\n                }\\n\\n                for s in 0 ..= up {\\n                    if s + d > up { break }\\n                    dp[i][s + d][1] = (dp[i][s + d][1] + dp[i - 1][s][1]) % MOD;\\n                }\\n            }\\n        }\\n        let (mut ret, n) = (0, num.len());\\n        for s in low ..= up { \\n            ret = (ret + (dp[n - 1][s][0] + dp[n - 1][s][1]) % MOD) % MOD; \\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count(num1: String, num2: String, min_sum: i32, max_sum: i32) -> i32 {\\n        let (low, up) = (min_sum as usize, max_sum as usize);\\n        let MOD = 1_000_000_007;\\n        let mut ret = (Self::cal(&num2, low, up) - Self::cal(&num1, low, up)) % MOD;\\n        (ret + Self::adjust(&num1, low, up) + MOD) % MOD\\n    }\\n\\n    fn adjust(num: &String, low: usize, up: usize) -> i32 {\\n        let mut cnt = 0;\\n        for c in num.chars() {\\n            cnt += c as usize - \\'0\\' as usize;\\n        }\\n        \\n        if cnt >= low && cnt <= up { 1 } else { 0 }\\n    }\\n\\n    fn cal(num: &String, low: usize, up: usize) -> i32 {\\n        let mut dp = vec![vec![vec![0; 2]; 401]; 23];\\n        let num = num.chars().into_iter().collect::<Vec<_>>();\\n        let MOD = 1_000_000_007;\\n        let temp = num[0] as usize - \\'0\\' as usize;\\n        \\n        dp[0][temp][0] = 1;\\n        for d in 0 .. temp { dp[0][d][1] = 1; }\\n\\n        for i in 1 .. num.len() {\\n            let k = num[i] as usize - \\'0\\' as usize;\\n            for d in 0 .. 10 {\\n                if d == k {\\n                    for s in 0 ..= up {\\n                        if s + d > up { break }\\n                        dp[i][s + d][0] = (dp[i][s + d][0] + dp[i - 1][s][0]) % MOD;\\n                    } \\n                }\\n\\n                if d < k {\\n                    for s in 0 ..= up {\\n                        if s + d > up { break }\\n                        dp[i][s + d][1] = (dp[i][s + d][1] + dp[i - 1][s][0]) % MOD;\\n                    } \\n                }\\n\\n                for s in 0 ..= up {\\n                    if s + d > up { break }\\n                    dp[i][s + d][1] = (dp[i][s + d][1] + dp[i - 1][s][1]) % MOD;\\n                }\\n            }\\n        }\\n        let (mut ret, n) = (0, num.len());\\n        for s in low ..= up { \\n            ret = (ret + (dp[n - 1][s][0] + dp[n - 1][s][1]) % MOD) % MOD; \\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840808,
                "title": "digit-dp-recursion-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int dp[25][401][2][2];\\n        int mod = 1e9+7;\\n        function <int(int,int,int,int,string&)> dfs = [&](int idx,int sum,int start,int tight,string &s){\\n            if(idx == s.size()+1){\\n                if(sum >= min_sum && sum <= max_sum){\\n                    return 1;\\n                }\\n                return 0;\\n            }\\n            if(dp[idx][sum][start][tight] != -1){\\n                return dp[idx][sum][start][tight];\\n            }\\n            int tot = 0;\\n            int r = 9;\\n            if(tight == 1){\\n                r = s[idx-1] - \\'0\\';\\n            }\\n            if(start == 1){\\n                for(int i=1;i<=r;i++){\\n                    tot += dfs(idx+1,sum+i,0,(i==r)&tight,s);\\n                    tot %= mod;\\n                }\\n                tot += dfs(idx+1,0,1,0,s);\\n                tot %= mod;\\n            }\\n            else{\\n                for(int i=0;i<=r;i++){\\n                    tot += dfs(idx+1,sum+i,0,(i==r)&tight,s);\\n                    tot %= mod;\\n                }\\n            }\\n            return dp[idx][sum][start][tight] = tot;\\n        };\\n        int check = 0;int sum = 0;\\n        for(auto i:num1){\\n            sum += i-\\'0\\';\\n        }\\n        if(sum >= min_sum && sum <= max_sum){\\n            check = 1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = dfs(1,0,1,1,num2);\\n        memset(dp,-1,sizeof(dp));\\n        ans = (ans - dfs(1,0,1,1,num1) + mod + check) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int dp[25][401][2][2];\\n        int mod = 1e9+7;\\n        function <int(int,int,int,int,string&)> dfs = [&](int idx,int sum,int start,int tight,string &s){\\n            if(idx == s.size()+1){\\n                if(sum >= min_sum && sum <= max_sum){\\n                    return 1;\\n                }\\n                return 0;\\n            }\\n            if(dp[idx][sum][start][tight] != -1){\\n                return dp[idx][sum][start][tight];\\n            }\\n            int tot = 0;\\n            int r = 9;\\n            if(tight == 1){\\n                r = s[idx-1] - \\'0\\';\\n            }\\n            if(start == 1){\\n                for(int i=1;i<=r;i++){\\n                    tot += dfs(idx+1,sum+i,0,(i==r)&tight,s);\\n                    tot %= mod;\\n                }\\n                tot += dfs(idx+1,0,1,0,s);\\n                tot %= mod;\\n            }\\n            else{\\n                for(int i=0;i<=r;i++){\\n                    tot += dfs(idx+1,sum+i,0,(i==r)&tight,s);\\n                    tot %= mod;\\n                }\\n            }\\n            return dp[idx][sum][start][tight] = tot;\\n        };\\n        int check = 0;int sum = 0;\\n        for(auto i:num1){\\n            sum += i-\\'0\\';\\n        }\\n        if(sum >= min_sum && sum <= max_sum){\\n            check = 1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = dfs(1,0,1,1,num2);\\n        memset(dp,-1,sizeof(dp));\\n        ans = (ans - dfs(1,0,1,1,num1) + mod + check) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839181,
                "title": "easy-c-digit-dp-most-optimal-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n        \\n    long long int dp[23][401][2];\\n    const long long int mod = 1e9+7;\\n\\n    long long int getCount(string num, int minSum, int maxSum, int i, int preSum, int tight){\\n\\n        if(preSum>maxSum)\\n        return 0;\\n\\n        if(i == num.size())\\n        return preSum>=minSum and preSum<=maxSum;\\n\\n        if(dp[i][preSum][tight] != -1)\\n        return dp[i][preSum][tight];\\n\\n        long long int ub = tight ? num[i] - \\'0\\' : 9;\\n\\n        long long int ans = 0;\\n\\n        for(long long int j=0;j<=ub;j++){\\n\\n            ans+=getCount(num, minSum, maxSum, i+1, preSum + j, tight and j==ub);\\n\\n        }\\n        //cout<<num<<\"  i  \"<<i<<\"  presum  \"<<preSum<<\"    tight\"<<tight<<\"    ans\"<<ans<<endl;\\n        return dp[i][preSum][tight] = ans%mod%mod;\\n\\n    }\\n\\n    int check(string low, int minsum, int maxsum){\\n\\n        int s=0;\\n        for(auto i : low)\\n        s+=(int)(i)-\\'0\\';\\n\\n        return s>=minsum and s<=maxsum;\\n    }\\n    \\n    int count(string low, string high, int min_sum, int max_sum) {\\n\\n        memset(dp, -1, sizeof(dp));        \\n        long long int l = getCount(low, min_sum, max_sum, 0, 0, 1)%mod;\\n        memset(dp, -1, sizeof(dp));\\n        long long int r = getCount(high, min_sum, max_sum, 0, 0, 1)%mod;\\n        //cout<<l<<r;\\n        return (check(low, min_sum, max_sum)%mod + r%mod-l%mod +mod)%mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n    long long int dp[23][401][2];\\n    const long long int mod = 1e9+7;\\n\\n    long long int getCount(string num, int minSum, int maxSum, int i, int preSum, int tight){\\n\\n        if(preSum>maxSum)\\n        return 0;\\n\\n        if(i == num.size())\\n        return preSum>=minSum and preSum<=maxSum;\\n\\n        if(dp[i][preSum][tight] != -1)\\n        return dp[i][preSum][tight];\\n\\n        long long int ub = tight ? num[i] - \\'0\\' : 9;\\n\\n        long long int ans = 0;\\n\\n        for(long long int j=0;j<=ub;j++){\\n\\n            ans+=getCount(num, minSum, maxSum, i+1, preSum + j, tight and j==ub);\\n\\n        }\\n        //cout<<num<<\"  i  \"<<i<<\"  presum  \"<<preSum<<\"    tight\"<<tight<<\"    ans\"<<ans<<endl;\\n        return dp[i][preSum][tight] = ans%mod%mod;\\n\\n    }\\n\\n    int check(string low, int minsum, int maxsum){\\n\\n        int s=0;\\n        for(auto i : low)\\n        s+=(int)(i)-\\'0\\';\\n\\n        return s>=minsum and s<=maxsum;\\n    }\\n    \\n    int count(string low, string high, int min_sum, int max_sum) {\\n\\n        memset(dp, -1, sizeof(dp));        \\n        long long int l = getCount(low, min_sum, max_sum, 0, 0, 1)%mod;\\n        memset(dp, -1, sizeof(dp));\\n        long long int r = getCount(high, min_sum, max_sum, 0, 0, 1)%mod;\\n        //cout<<l<<r;\\n        return (check(low, min_sum, max_sum)%mod + r%mod-l%mod +mod)%mod;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3837938,
                "title": "classic-digit-dp-dynamic-programming-on-digits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<long long>>> dp1;\\n    vector<vector<vector<long long>>> dp2;\\n    long long mod = 1e9 + 7;\\n    long long solve(int idx, int sum, bool edge, int mx_sum, int mn_sum, string num, vector<vector<vector<long long>>> &dp){\\n        if(sum > mx_sum) return 0;\\n        if(idx == num.length()){\\n            if(sum >= mn_sum && sum <= mx_sum) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][sum][edge] != -1) return dp[idx][sum][edge];\\n        int max_digit = 9;\\n        if(edge) max_digit = num[idx] - \\'0\\';\\n        long long ans = 0;\\n        for(int i = 0; i<=max_digit; i++){\\n            ans += solve(idx + 1, sum + i, edge && (i == num[idx] - \\'0\\'), mx_sum, mn_sum, num, dp)%mod;\\n            ans = ans%mod;\\n        }\\n        return dp[idx][sum][edge] = ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        dp1 = vector<vector<vector<long long>>> (num1.length()+1, vector<vector<long long>> (410, vector<long long> (2, -1)));\\n        dp2 = vector<vector<vector<long long>>> (num2.length()+1, vector<vector<long long>> (410, vector<long long> (2, -1)));\\n        long long cnt1 = solve(0, 0, 1, max_sum, min_sum, num1, dp1);\\n        long long cnt2 = solve(0, 0, 1, max_sum, min_sum, num2, dp2);\\n        long long sum = 0;\\n        for(auto i:num1) sum += i-\\'0\\';\\n        long long ans = (cnt2 - cnt1 + mod)%mod;\\n        if(sum >= min_sum && sum <= max_sum) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<long long>>> dp1;\\n    vector<vector<vector<long long>>> dp2;\\n    long long mod = 1e9 + 7;\\n    long long solve(int idx, int sum, bool edge, int mx_sum, int mn_sum, string num, vector<vector<vector<long long>>> &dp){\\n        if(sum > mx_sum) return 0;\\n        if(idx == num.length()){\\n            if(sum >= mn_sum && sum <= mx_sum) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][sum][edge] != -1) return dp[idx][sum][edge];\\n        int max_digit = 9;\\n        if(edge) max_digit = num[idx] - \\'0\\';\\n        long long ans = 0;\\n        for(int i = 0; i<=max_digit; i++){\\n            ans += solve(idx + 1, sum + i, edge && (i == num[idx] - \\'0\\'), mx_sum, mn_sum, num, dp)%mod;\\n            ans = ans%mod;\\n        }\\n        return dp[idx][sum][edge] = ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        dp1 = vector<vector<vector<long long>>> (num1.length()+1, vector<vector<long long>> (410, vector<long long> (2, -1)));\\n        dp2 = vector<vector<vector<long long>>> (num2.length()+1, vector<vector<long long>> (410, vector<long long> (2, -1)));\\n        long long cnt1 = solve(0, 0, 1, max_sum, min_sum, num1, dp1);\\n        long long cnt2 = solve(0, 0, 1, max_sum, min_sum, num2, dp2);\\n        long long sum = 0;\\n        for(auto i:num1) sum += i-\\'0\\';\\n        long long ans = (cnt2 - cnt1 + mod)%mod;\\n        if(sum >= min_sum && sum <= max_sum) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673084,
                "title": "digit-dp-memoization-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[30][501][2];\\n    int mod = 1000000007;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n         memset(dp,-1,sizeof(dp));\\n         long long l = solve(0,0,num1,min_sum,max_sum,1);\\n         memset(dp,-1,sizeof(dp));\\n         long long r = solve(0,0,num2,min_sum,max_sum,1);\\n         int sm = 0;\\n         for(char n : num1) sm+=(n - \\'0\\');\\n         // prefix computation : all good integers between (L,R): count good integers <= R minus count good integers <= L - 1.\\n         sm <= max_sum && sm >= min_sum ? r++ : r;    // +1 if L is also a good integer.\\n         return (r - l + mod) % mod;\\n    }\\n    int solve(int pos,int sm,string &s,int ml,int mr,int limit) {\\n        if(pos>=s.size()) return sm >= ml && sm <= mr;\\n        if(dp[pos][sm][limit]!=-1) return dp[pos][sm][limit];\\n        long long cnt = 0;\\n        for(int i=0; i<=9; i++) {\\n             if(limit) {\\n                 if(s[pos] - \\'0\\' >= i) {\\n\\t\\t\\t\\t\\t // if we took a digit less than current when limit is on , we remove limit\\n                     cnt = (cnt + solve(pos+1,sm+i,s,ml,mr,(s[pos] - \\'0\\' > i)?0:1)) % mod; \\n                 }\\n             }else {\\n\\t\\t\\t     // if limit is removed , take any digit. \\n                 cnt = (cnt + solve(pos+1,sm+i,s,ml,mr,limit)) % mod;\\n             }\\n        }\\n        return dp[pos][sm][limit] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[30][501][2];\\n    int mod = 1000000007;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n         memset(dp,-1,sizeof(dp));\\n         long long l = solve(0,0,num1,min_sum,max_sum,1);\\n         memset(dp,-1,sizeof(dp));\\n         long long r = solve(0,0,num2,min_sum,max_sum,1);\\n         int sm = 0;\\n         for(char n : num1) sm+=(n - \\'0\\');\\n         // prefix computation : all good integers between (L,R): count good integers <= R minus count good integers <= L - 1.\\n         sm <= max_sum && sm >= min_sum ? r++ : r;    // +1 if L is also a good integer.\\n         return (r - l + mod) % mod;\\n    }\\n    int solve(int pos,int sm,string &s,int ml,int mr,int limit) {\\n        if(pos>=s.size()) return sm >= ml && sm <= mr;\\n        if(dp[pos][sm][limit]!=-1) return dp[pos][sm][limit];\\n        long long cnt = 0;\\n        for(int i=0; i<=9; i++) {\\n             if(limit) {\\n                 if(s[pos] - \\'0\\' >= i) {\\n\\t\\t\\t\\t\\t // if we took a digit less than current when limit is on , we remove limit\\n                     cnt = (cnt + solve(pos+1,sm+i,s,ml,mr,(s[pos] - \\'0\\' > i)?0:1)) % mod; \\n                 }\\n             }else {\\n\\t\\t\\t     // if limit is removed , take any digit. \\n                 cnt = (cnt + solve(pos+1,sm+i,s,ml,mr,limit)) % mod;\\n             }\\n        }\\n        return dp[pos][sm][limit] = cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659413,
                "title": "py3-40ms-beats-100-only-upper-bounds-split-count9-countx",
                "content": "# Intuition\\n\\n`count(num1, num2, sum1, sum2)` is equal to `count(0, num2, sum1, sum2) - count(0, num1 - 1, sum1, sum2)`.\\n\\nFurthermore, `count(0, num, sum1, sum2)` is equal to `count(0, num, 0, sum2) - count(0, num, 0, sum1 - 1)`.\\n\\nThis means we can simplify our approach by only implementing `sb(num, sum)` which is equal to the number of integers `i` from `0` to `num` for which `sum_digits(i) <= sum`.\\n\\nNow, we only need to realize one more crucial insight:\\nMost operations while calculating `sb` are working on a range from `0` to `9`. We only look at upper boundaries `x != 9` once for every digit in `num`. Thus, we can define:\\n\\nCount x only looks at the digit at index n. We count the digits to the right x times. For the first count, we will iterate through all the digits up to y where y is the next digit. For all other counts, we\\'re looking at i from 0 to x-1. For these i\\'s, we iterate 0 to 9 for all digits to the right.\\n\\nThis makes `count9` easily cachable. Not just across one call of `count` but globally, since none of the parameters include `num`.\\n\\n![image.png](https://assets.leetcode.com/users/images/e6bd3e33-bd6b-49b5-995c-6c0b9d9ae562_1687233110.548488.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        if min_sum > len(num2) * 9: return 0\\n\\n        num1 = str(int(num1) - 1)\\n        min_sum -= 1\\n        v = sb(num2, max_sum) - sb(num2, min_sum) - sb(num1, max_sum) + sb(num1, min_sum)\\n        return v % int(1e9 + 7)\\n\\n# sum below\\ndef sb(num, sum):\\n    return count_x(len(num), sum, num)\\n\\n@cache\\ndef count_9(n_digits, max_sum):\\n    if max_sum < 0: return 0\\n    if n_digits == 1: return min(9, max_sum) + 1\\n    c = 0\\n    for i in range(10):\\n        c += count_9(n_digits - 1, max_sum - i)\\n    return c\\n\\ndef count_x(n_digits, max_sum, num):\\n    if max_sum < 0: return 0\\n    x = int(num[-n_digits])\\n    if n_digits == 1: return min(x, max_sum) + 1\\n    c = count_x(n_digits - 1, max_sum - x, num)\\n    for i in range(x):\\n        c += count_9(n_digits - 1, max_sum - i)\\n    return c\\n```\\n\\n\\n# Slightly faster code to reach 100%:\\n\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        if min_sum > len(num2) * 9: return 0\\n\\n        num1 = list(str(int(num1) - 1))\\n        num2 = list(num2)\\n        min_sum -= 1\\n        v = sb(num2, max_sum) - sb(num2, min_sum) - sb(num1, max_sum) + sb(num1, min_sum)\\n        return v % int(1e9 + 7)\\n\\n# sum below\\ndef sb(num, sum):\\n    return count_x(len(num), sum, num, len(num))\\n\\n@cache\\ndef count_9(n_digits, max_sum):\\n    if max_sum < 0: return 0\\n    if max_sum == 0: return 1\\n    if n_digits == 1: return min(9, max_sum) + 1\\n    c = 0\\n    for i in range(10):\\n        c += count_9(n_digits - 1, max_sum - i)\\n    return c\\n\\ndef count_x(n_digits, max_sum, num, n):\\n    if max_sum < 0: return 0\\n    if max_sum == 0: return 1\\n    x = int(num[n-n_digits])\\n    if n_digits == 1: return min(x, max_sum) + 1\\n    c = count_x(n_digits - 1, max_sum - x, num, n)\\n    for i in range(x):\\n        c += count_9(n_digits - 1, max_sum - i)\\n    return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        if min_sum > len(num2) * 9: return 0\\n\\n        num1 = str(int(num1) - 1)\\n        min_sum -= 1\\n        v = sb(num2, max_sum) - sb(num2, min_sum) - sb(num1, max_sum) + sb(num1, min_sum)\\n        return v % int(1e9 + 7)\\n\\n# sum below\\ndef sb(num, sum):\\n    return count_x(len(num), sum, num)\\n\\n@cache\\ndef count_9(n_digits, max_sum):\\n    if max_sum < 0: return 0\\n    if n_digits == 1: return min(9, max_sum) + 1\\n    c = 0\\n    for i in range(10):\\n        c += count_9(n_digits - 1, max_sum - i)\\n    return c\\n\\ndef count_x(n_digits, max_sum, num):\\n    if max_sum < 0: return 0\\n    x = int(num[-n_digits])\\n    if n_digits == 1: return min(x, max_sum) + 1\\n    c = count_x(n_digits - 1, max_sum - x, num)\\n    for i in range(x):\\n        c += count_9(n_digits - 1, max_sum - i)\\n    return c\\n```\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        if min_sum > len(num2) * 9: return 0\\n\\n        num1 = list(str(int(num1) - 1))\\n        num2 = list(num2)\\n        min_sum -= 1\\n        v = sb(num2, max_sum) - sb(num2, min_sum) - sb(num1, max_sum) + sb(num1, min_sum)\\n        return v % int(1e9 + 7)\\n\\n# sum below\\ndef sb(num, sum):\\n    return count_x(len(num), sum, num, len(num))\\n\\n@cache\\ndef count_9(n_digits, max_sum):\\n    if max_sum < 0: return 0\\n    if max_sum == 0: return 1\\n    if n_digits == 1: return min(9, max_sum) + 1\\n    c = 0\\n    for i in range(10):\\n        c += count_9(n_digits - 1, max_sum - i)\\n    return c\\n\\ndef count_x(n_digits, max_sum, num, n):\\n    if max_sum < 0: return 0\\n    if max_sum == 0: return 1\\n    x = int(num[n-n_digits])\\n    if n_digits == 1: return min(x, max_sum) + 1\\n    c = count_x(n_digits - 1, max_sum - x, num, n)\\n    for i in range(x):\\n        c += count_9(n_digits - 1, max_sum - i)\\n    return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643457,
                "title": "c-readable-code-digit-dp-explanation",
                "content": "# Intuition\\nA Standard Digit DP problem, We use the fact that we can find out the given Digit condition meeting numbers by calculating from (1,r) and (1, l - 1) and then subtracting both to get our answer.\\n\\n# Approach\\nWe use the function twice, once for calculating the numbers meeting the condition uptill upperbound num2, the second uptill lowerbound num1. Here because the range is till $$10^{22}$$ and the number we get is in the string form. Hence we cannot just reduce it by 1 as we generally to do in this type of problem.\\nHence after we calculate the answer for `num1`, which is `lower`. We will see if `num1` fits the condition, if it doesn\\'t we will subtract 1 and that\\'s how we solve this problem. At last we get the answer as `Upper - Lower + Mod`  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(len(num2) * max(sum(num1), sum(num2)) * 10 * 2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //dp[pos][sum][tight]\\n    int dp[23][22 * 9][2];\\n    int MOD = 1e9 + 7;\\n    int rec(string str, int min_sum, int max_sum, int tight, int pos, int sum)\\n    {\\n        //Digit Sum condition\\n        if(pos == str.size())\\n        {\\n            if(sum >= min_sum && sum <= max_sum)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        //memoization check\\n        if(dp[pos][sum][tight] != -1)\\n            return dp[pos][sum][tight];\\n        if(tight)\\n        {\\n            int res = 0;\\n            //iterating from zero till the upper bound digit at that position\\n            for(int i = 0; i <= (str[pos] - \\'0\\'); i++)\\n            {\\n                if(i == (str[pos] - \\'0\\'))\\n                    res = (res + rec(str, min_sum, max_sum, 1, pos + 1, sum + i))% MOD ;\\n                else\\n                    res = (res + rec(str, min_sum, max_sum, 0, pos + 1, sum + i))% MOD;\\n            }\\n            dp[pos][sum][tight] = res;\\n        }\\n        else\\n        {\\n            int res = 0;\\n            //No Tight condition , we can iterate till 9\\n            for(int i = 0; i <= 9; i++)\\n                res = (res + rec(str, min_sum, max_sum, 0, pos + 1, sum + i))% MOD;\\n            //memoize it\\n            dp[pos][sum][tight] = res;\\n        }\\n        return dp[pos][sum][tight];\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        //G(x) = [1,x]\\n        //G(l,r) = G(r) - G(l - 1)\\n        memset(dp, -1, sizeof(dp));\\n        int upper = rec(num2, min_sum, max_sum, 1, 0, 0) % MOD;\\n        memset(dp, -1, sizeof(dp));\\n        int lower = rec(num1, min_sum, max_sum, 1, 0, 0) % MOD;\\n        int sum = 0;\\n        for (auto i : num1)\\n            sum += (i - \\'0\\');\\n        if (sum >= min_sum and sum <= max_sum)\\n            lower--;\\n        //Final Ans is the difference of the two ranges\\n        int ans = (upper - lower + MOD) % MOD;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //dp[pos][sum][tight]\\n    int dp[23][22 * 9][2];\\n    int MOD = 1e9 + 7;\\n    int rec(string str, int min_sum, int max_sum, int tight, int pos, int sum)\\n    {\\n        //Digit Sum condition\\n        if(pos == str.size())\\n        {\\n            if(sum >= min_sum && sum <= max_sum)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        //memoization check\\n        if(dp[pos][sum][tight] != -1)\\n            return dp[pos][sum][tight];\\n        if(tight)\\n        {\\n            int res = 0;\\n            //iterating from zero till the upper bound digit at that position\\n            for(int i = 0; i <= (str[pos] - \\'0\\'); i++)\\n            {\\n                if(i == (str[pos] - \\'0\\'))\\n                    res = (res + rec(str, min_sum, max_sum, 1, pos + 1, sum + i))% MOD ;\\n                else\\n                    res = (res + rec(str, min_sum, max_sum, 0, pos + 1, sum + i))% MOD;\\n            }\\n            dp[pos][sum][tight] = res;\\n        }\\n        else\\n        {\\n            int res = 0;\\n            //No Tight condition , we can iterate till 9\\n            for(int i = 0; i <= 9; i++)\\n                res = (res + rec(str, min_sum, max_sum, 0, pos + 1, sum + i))% MOD;\\n            //memoize it\\n            dp[pos][sum][tight] = res;\\n        }\\n        return dp[pos][sum][tight];\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        //G(x) = [1,x]\\n        //G(l,r) = G(r) - G(l - 1)\\n        memset(dp, -1, sizeof(dp));\\n        int upper = rec(num2, min_sum, max_sum, 1, 0, 0) % MOD;\\n        memset(dp, -1, sizeof(dp));\\n        int lower = rec(num1, min_sum, max_sum, 1, 0, 0) % MOD;\\n        int sum = 0;\\n        for (auto i : num1)\\n            sum += (i - \\'0\\');\\n        if (sum >= min_sum and sum <= max_sum)\\n            lower--;\\n        //Final Ans is the difference of the two ranges\\n        int ans = (upper - lower + MOD) % MOD;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633853,
                "title": "short-and-fast-top-down-dp-in-python-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to https://leetcode.com/problems/find-all-good-strings/ but simpler. \\nThe solution can be obtained by using top-down DP with carefully handling of the upper bound and the lower bound. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(NM)$$ where $$N$$ is the length of `num2` and $$M$$ is `max_sum`, which is also bound by $$N$$ because the maximum sum cannot exceed $$9N$$. Thus, the overall complexity is $$O(N^2)$$. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        n = len(num2)\\n        num1 = \"0\"*(n - len(num1)) + num1\\n\\n        @cache\\n        def dp(i, s, upper_bound, lower_bound):\\n            if s > max_sum or (n-i)*9 + s < min_sum:\\n                return 0\\n            if i == n:\\n                return 1 \\n            r = 0\\n            for d in string.digits:\\n                if (upper_bound and d > num2[i]) or (lower_bound and d < num1[i]):\\n                    continue\\n                ub = True if upper_bound and d == num2[i] else False\\n                lb = True if lower_bound and d == num1[i] else False\\n                r = (r + dp(i+1, s + int(d), ub, lb)) % 1000000007\\n            return r\\n\\n        return dp(0, 0, True, True)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        n = len(num2)\\n        num1 = \"0\"*(n - len(num1)) + num1\\n\\n        @cache\\n        def dp(i, s, upper_bound, lower_bound):\\n            if s > max_sum or (n-i)*9 + s < min_sum:\\n                return 0\\n            if i == n:\\n                return 1 \\n            r = 0\\n            for d in string.digits:\\n                if (upper_bound and d > num2[i]) or (lower_bound and d < num1[i]):\\n                    continue\\n                ub = True if upper_bound and d == num2[i] else False\\n                lb = True if lower_bound and d == num1[i] else False\\n                r = (r + dp(i+1, s + int(d), ub, lb)) % 1000000007\\n            return r\\n\\n        return dp(0, 0, True, True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621512,
                "title": "rust-bitmask-like-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTypical problem if you have seen similar one before\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndp state would be (pos, lower, higher, cur_dig_sum)\\nlower & higher are boolean variables which decide the range of digits we can recurse at current state.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO( log(num1) * 2* 2* max_dig_sum* 10)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/***\\nbitmask dp like \\n\\nf(pos, cur_sum, dig_sum)\\n\\n\\n**/\\n\\nuse std::collections::BTreeMap;\\n\\n// const mod: i64 = 1_000_000_007 ; \\nconst MOD: i64 = 1000000007 ; \\n\\nimpl Solution {\\n\\n    fn solve(pos: usize, lower: bool, higher: bool, dig_sum: i16, num1: &Vec<i16>, num2: &Vec<i16>, min_sum: i16, max_sum: i16, cache: &mut BTreeMap<(usize, bool, bool, i16), i64> ) -> i64{\\n        \\n        // println!(\"{} \", pos);\\n        if (pos==num1.len()){\\n            if (dig_sum>= min_sum && dig_sum<=max_sum){\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        // if (pos==num1.len() && dig_sum>= num1.iter().sum() && dig_sum<=num2.iter().sum()){ \\n        //     return 1;\\n        // }\\n\\n        if cache.contains_key(&(pos, lower, higher, dig_sum)){\\n            return *cache.get(&(pos, lower, higher, dig_sum)).unwrap();\\n        }\\n\\n        let lo = if lower==false {num1[pos] } else {0};\\n        let hi = if higher==false {num2[pos] } else {9};\\n        // println!(\"pos {}, lo {}, hi {}\", pos, lo, hi);\\n        let mut count: i64 = 0;\\n\\n        for idx in lo..=hi{\\n            if (dig_sum+idx<=max_sum){ \\n                // println!(\"pos {},  idx {}\", pos, idx);\\n                count = (count + Self::solve(pos+1, lower || (idx>lo), higher || (idx<hi), dig_sum+idx, num1, num2, min_sum, max_sum, cache))%MOD;\\n            }\\n\\n        }\\n\\n        cache.entry((pos, lower, higher, dig_sum)).or_insert(count);\\n        count\\n    }\\n\\n    pub fn count(num1: String, num2: String, min_sum: i32, max_sum: i32) -> i32 {\\n        \\n        let mut _num1 = String::from(\"\");\\n        // let mut num2 = String::from(\"\");\\n        let mut leading_zeros = num2.len() - num1.len();\\n        while leading_zeros>0{\\n            _num1.push_str(\"0\");\\n            leading_zeros-=1;\\n        }\\n        _num1.push_str(num1.as_str());\\n        let num1 = _num1;\\n\\n        // println!(\"num1 {:?} \", num1);\\n        // println!(\"num2 {:?} \", num2);\\n        let mut cache: BTreeMap<(usize, bool, bool, i16), i64> = BTreeMap::new();\\n\\n        let num1 = num1.chars().map(|c| (c.to_digit(10).unwrap() as i16)).collect::<Vec<i16>>();\\n        let num2 = num2.chars().map(|c| (c.to_digit(10).unwrap() as i16)).collect::<Vec<i16>>();\\n        // let num2 = num2.chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<i16>>();\\n\\n        Self::solve(0, false, false, 0, &num1, &num2, min_sum as i16, max_sum as i16, &mut cache) as i32\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n/***\\nbitmask dp like \\n\\nf(pos, cur_sum, dig_sum)\\n\\n\\n**/\\n\\nuse std::collections::BTreeMap;\\n\\n// const mod: i64 = 1_000_000_007 ; \\nconst MOD: i64 = 1000000007 ; \\n\\nimpl Solution {\\n\\n    fn solve(pos: usize, lower: bool, higher: bool, dig_sum: i16, num1: &Vec<i16>, num2: &Vec<i16>, min_sum: i16, max_sum: i16, cache: &mut BTreeMap<(usize, bool, bool, i16), i64> ) -> i64{\\n        \\n        // println!(\"{} \", pos);\\n        if (pos==num1.len()){\\n            if (dig_sum>= min_sum && dig_sum<=max_sum){\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        // if (pos==num1.len() && dig_sum>= num1.iter().sum() && dig_sum<=num2.iter().sum()){ \\n        //     return 1;\\n        // }\\n\\n        if cache.contains_key(&(pos, lower, higher, dig_sum)){\\n            return *cache.get(&(pos, lower, higher, dig_sum)).unwrap();\\n        }\\n\\n        let lo = if lower==false {num1[pos] } else {0};\\n        let hi = if higher==false {num2[pos] } else {9};\\n        // println!(\"pos {}, lo {}, hi {}\", pos, lo, hi);\\n        let mut count: i64 = 0;\\n\\n        for idx in lo..=hi{\\n            if (dig_sum+idx<=max_sum){ \\n                // println!(\"pos {},  idx {}\", pos, idx);\\n                count = (count + Self::solve(pos+1, lower || (idx>lo), higher || (idx<hi), dig_sum+idx, num1, num2, min_sum, max_sum, cache))%MOD;\\n            }\\n\\n        }\\n\\n        cache.entry((pos, lower, higher, dig_sum)).or_insert(count);\\n        count\\n    }\\n\\n    pub fn count(num1: String, num2: String, min_sum: i32, max_sum: i32) -> i32 {\\n        \\n        let mut _num1 = String::from(\"\");\\n        // let mut num2 = String::from(\"\");\\n        let mut leading_zeros = num2.len() - num1.len();\\n        while leading_zeros>0{\\n            _num1.push_str(\"0\");\\n            leading_zeros-=1;\\n        }\\n        _num1.push_str(num1.as_str());\\n        let num1 = _num1;\\n\\n        // println!(\"num1 {:?} \", num1);\\n        // println!(\"num2 {:?} \", num2);\\n        let mut cache: BTreeMap<(usize, bool, bool, i16), i64> = BTreeMap::new();\\n\\n        let num1 = num1.chars().map(|c| (c.to_digit(10).unwrap() as i16)).collect::<Vec<i16>>();\\n        let num2 = num2.chars().map(|c| (c.to_digit(10).unwrap() as i16)).collect::<Vec<i16>>();\\n        // let num2 = num2.chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<i16>>();\\n\\n        Self::solve(0, false, false, 0, &num1, &num2, min_sum as i16, max_sum as i16, &mut cache) as i32\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619501,
                "title": "digit-dp-technique-java-solution-clean-code",
                "content": "# Code\\n```java\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    int MOD = (int)1e9 + 7;\\n    int min;\\n    int max;\\n    long dp[][][];\\n    boolean check(int sum){\\n        return min <= sum && sum <= max;\\n    }\\n    long helper(String num,int idx,int sum,int tight){\\n        if(idx >= num.length()){\\n            return check(sum) ? 1L : 0L;\\n        }\\n        if(dp[idx][sum][tight] != -1) return dp[idx][sum][tight];\\n        long ans = 0;\\n        int max = 9;\\n        if(tight == 1) max = num.charAt(idx) - \\'0\\';\\n        for(int i = 0;i <= max;i++){\\n            if(i == max){\\n                ans = (ans + helper(num,idx + 1,sum + i,tight)) % MOD;\\n            }\\n            else{\\n                ans = (ans + helper(num,idx + 1,sum + i,0)) % MOD;\\n            }\\n        }\\n        return dp[idx][sum][tight] = ans % MOD;\\n        \\n    }\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        String l = new BigInteger(num1).subtract(new BigInteger(\"1\")).toString();\\n        String r = num2;\\n        min = min_sum;\\n        max = max_sum;\\n        dp = new long[25][200][2];\\n        for(var m:dp) for(var a:m) Arrays.fill(a,-1);\\n        long rb = helper(r,0,0,1);\\n        for(var m:dp) for(var a:m) Arrays.fill(a,-1);\\n        long lb = helper(l,0,0,1);\\n        return (int)((rb - lb + MOD) % MOD);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    int MOD = (int)1e9 + 7;\\n    int min;\\n    int max;\\n    long dp[][][];\\n    boolean check(int sum){\\n        return min <= sum && sum <= max;\\n    }\\n    long helper(String num,int idx,int sum,int tight){\\n        if(idx >= num.length()){\\n            return check(sum) ? 1L : 0L;\\n        }\\n        if(dp[idx][sum][tight] != -1) return dp[idx][sum][tight];\\n        long ans = 0;\\n        int max = 9;\\n        if(tight == 1) max = num.charAt(idx) - \\'0\\';\\n        for(int i = 0;i <= max;i++){\\n            if(i == max){\\n                ans = (ans + helper(num,idx + 1,sum + i,tight)) % MOD;\\n            }\\n            else{\\n                ans = (ans + helper(num,idx + 1,sum + i,0)) % MOD;\\n            }\\n        }\\n        return dp[idx][sum][tight] = ans % MOD;\\n        \\n    }\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        String l = new BigInteger(num1).subtract(new BigInteger(\"1\")).toString();\\n        String r = num2;\\n        min = min_sum;\\n        max = max_sum;\\n        dp = new long[25][200][2];\\n        for(var m:dp) for(var a:m) Arrays.fill(a,-1);\\n        long rb = helper(r,0,0,1);\\n        for(var m:dp) for(var a:m) Arrays.fill(a,-1);\\n        long lb = helper(l,0,0,1);\\n        return (int)((rb - lb + MOD) % MOD);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618968,
                "title": "cpp-intuitive-digit-dp",
                "content": "But this might fail on some test case for example consider a large string num1 which ends with \\'0\\', so in this case it will be tough to find num1-1  using the method I used. I have to write seperate code for that.\\n```\\nclass Solution {\\n    private:\\n        long long mod = 1e9+7;\\n    public:\\n    \\n    long long solve(string& r, long long n, long long sm, bool tight, int min_sum, int max_sum, vector<vector<vector<long long>>>& dp){\\n        \\n        if(n == 0){\\n            if(sm >= min_sum && sm <= max_sum) return 1;\\n            return 0;\\n        }\\n        if(dp[n][sm][tight] != -1) return dp[n][sm][tight];\\n        \\n        long long ans = 0;\\n        \\n        int upr = tight ? r[r.length()-n] - \\'0\\': 9;\\n        \\n        for(int i=0; i<=upr; i++){\\n            ans =  (ans + solve(r, n-1, sm+i, tight & (i == upr), min_sum, max_sum,dp))%mod;\\n        }\\n        \\n        return dp[n][sm][tight] = ans;\\n    }\\n    \\n    long long count(string num1, string num2, int min_sum, int max_sum) {\\n    int  temp=num1.back()-\\'0\\';\\n        num1.pop_back();\\n        temp--;\\n        num1.push_back(temp+\\'0\\');\\n\\n        vector<vector<vector<long long>>>dp(num2.length()+1, vector<vector<long long>>(400, vector<long long>(2,-1)));\\n\\n        long long m = solve(num2,num2.length(),0,true, min_sum,max_sum, dp);\\n        \\n           for (size_t i = 0; i < dp.size(); ++i) {\\n        for (size_t j = 0; j < dp[i].size(); ++j) {\\n            for (size_t k = 0; k < dp[i][j].size(); ++k) {\\n                dp[i][j][k] = -1;\\n            }\\n        }\\n    }\\n        \\n        long long n = solve(num1,num1.length(),0,true, min_sum,max_sum, dp);\\n        \\n        return (m-n+mod)%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n        long long mod = 1e9+7;\\n    public:\\n    \\n    long long solve(string& r, long long n, long long sm, bool tight, int min_sum, int max_sum, vector<vector<vector<long long>>>& dp){\\n        \\n        if(n == 0){\\n            if(sm >= min_sum && sm <= max_sum) return 1;\\n            return 0;\\n        }\\n        if(dp[n][sm][tight] != -1) return dp[n][sm][tight];\\n        \\n        long long ans = 0;\\n        \\n        int upr = tight ? r[r.length()-n] - \\'0\\': 9;\\n        \\n        for(int i=0; i<=upr; i++){\\n            ans =  (ans + solve(r, n-1, sm+i, tight & (i == upr), min_sum, max_sum,dp))%mod;\\n        }\\n        \\n        return dp[n][sm][tight] = ans;\\n    }\\n    \\n    long long count(string num1, string num2, int min_sum, int max_sum) {\\n    int  temp=num1.back()-\\'0\\';\\n        num1.pop_back();\\n        temp--;\\n        num1.push_back(temp+\\'0\\');\\n\\n        vector<vector<vector<long long>>>dp(num2.length()+1, vector<vector<long long>>(400, vector<long long>(2,-1)));\\n\\n        long long m = solve(num2,num2.length(),0,true, min_sum,max_sum, dp);\\n        \\n           for (size_t i = 0; i < dp.size(); ++i) {\\n        for (size_t j = 0; j < dp[i].size(); ++j) {\\n            for (size_t k = 0; k < dp[i][j].size(); ++k) {\\n                dp[i][j][k] = -1;\\n            }\\n        }\\n    }\\n        \\n        long long n = solve(num1,num1.length(),0,true, min_sum,max_sum, dp);\\n        \\n        return (m-n+mod)%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618943,
                "title": "c-digit-dp-simplified",
                "content": "# Intuition\\nWhenever you see these kind of problems where you have to find the number of integers in a given range, digit DP should always strike your mind.\\n\\n# Approach\\nJust keep track of the sum of the digits and in the base case use that sum to find your counts. \\nNote : If you want to find the count of a given range(l,r) you will have to subtract 1 from your l. r to l = 0 to r - 0 to l-1.\\n\\nIn the final result note that I have added MOD, this is because due to MOD the r can become less than l, so the whole answer becomes negative and to avoid it I\\'ve added MOD.\\n\\n\\n\\n\\n\\n# Code\\n```\\nconst int MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int dp[25][2][401];\\n    int solve(string num, int pos, int rest,int sum,int min_sum,int max_sum){\\n        if(pos>=num.size()){\\n            if(sum>=min_sum and sum<=max_sum){\\n                return dp[pos][rest][sum] = 1;\\n            }\\n            return dp[pos][rest][sum] = 0;\\n        }\\n        if(dp[pos][rest][sum]!=-1)return dp[pos][rest][sum];\\n        \\n        int res = 0;\\n        int lim = rest==1?num[pos]-\\'0\\':9;\\n        for(int i = 0;i<=lim;i++){\\n            int nrest  = rest;\\n            if(i<lim)nrest = 0;\\n        //    cout<<sum<<endl;\\n            res= res%MOD + solve(num,pos+1,nrest,sum+i,min_sum,max_sum)%MOD;\\n            // cout<<\"res \"<<res<<endl;\\n        }\\n        \\n        return dp[pos][rest][sum] =  res%MOD;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        string num = num1;\\n        int carry = 1;\\n         for (int i = num.size() - 1; i >= 0; i--) {\\n        int digit = num[i] - \\'0\\';\\n        digit -= carry;\\n        if (digit < 0) {\\n            digit += 10;\\n            carry = 1;\\n        } else {\\n            carry = 0;\\n        }\\n        num[i] = digit + \\'0\\';\\n    }\\n\\n    // Remove leading zeros if any\\n    // while (num[0] == \\'0\\') {\\n    //     num.erase(0, 1);\\n    // }\\n        // cout<<num;\\n        memset(dp,-1,sizeof(dp));\\n        int l = solve(num,0,1,0, min_sum, max_sum);\\n        memset(dp,-1,sizeof(dp));\\n        int r = solve(num2,0,1,0,min_sum,max_sum);\\n        return r-l<0?(r-l)+MOD:r-l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int dp[25][2][401];\\n    int solve(string num, int pos, int rest,int sum,int min_sum,int max_sum){\\n        if(pos>=num.size()){\\n            if(sum>=min_sum and sum<=max_sum){\\n                return dp[pos][rest][sum] = 1;\\n            }\\n            return dp[pos][rest][sum] = 0;\\n        }\\n        if(dp[pos][rest][sum]!=-1)return dp[pos][rest][sum];\\n        \\n        int res = 0;\\n        int lim = rest==1?num[pos]-\\'0\\':9;\\n        for(int i = 0;i<=lim;i++){\\n            int nrest  = rest;\\n            if(i<lim)nrest = 0;\\n        //    cout<<sum<<endl;\\n            res= res%MOD + solve(num,pos+1,nrest,sum+i,min_sum,max_sum)%MOD;\\n            // cout<<\"res \"<<res<<endl;\\n        }\\n        \\n        return dp[pos][rest][sum] =  res%MOD;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        string num = num1;\\n        int carry = 1;\\n         for (int i = num.size() - 1; i >= 0; i--) {\\n        int digit = num[i] - \\'0\\';\\n        digit -= carry;\\n        if (digit < 0) {\\n            digit += 10;\\n            carry = 1;\\n        } else {\\n            carry = 0;\\n        }\\n        num[i] = digit + \\'0\\';\\n    }\\n\\n    // Remove leading zeros if any\\n    // while (num[0] == \\'0\\') {\\n    //     num.erase(0, 1);\\n    // }\\n        // cout<<num;\\n        memset(dp,-1,sizeof(dp));\\n        int l = solve(num,0,1,0, min_sum, max_sum);\\n        memset(dp,-1,sizeof(dp));\\n        int r = solve(num2,0,1,0,min_sum,max_sum);\\n        return r-l<0?(r-l)+MOD:r-l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3618660,
                "title": "digit-dp-solution-c-recursion",
                "content": "# Video Link\\n\\n[https://www.youtube.com/watch?v=I9jsjtSvqoc&t=356s]()\\n\\n# Complexity\\n\\nTime Complexity : O(Number Of digits * 2 * 9 * Number of digits)\\nSpace complexity : O(22*2*216). (Since we are initializing whole dp array by using memset)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int M = 1000000007;\\n    int mi,ma,n;\\n    int dp[24][2][216];\\n    int rec(int i,int flag,int cur_sum,string &x){\\n        if(i == n){\\n            if((cur_sum >= mi)&&(cur_sum <= ma)){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][flag][cur_sum] != -1){\\n            return dp[i][flag][cur_sum];\\n        }\\n        int limit = 9;\\n        char a = x[i];\\n        if(flag == 1){\\n            limit = a-\\'0\\';\\n        }\\n        int ans,ind;\\n        ans = 0;\\n        ind = 0;\\n        while(ind <= limit){\\n            if(ind == limit){\\n                if(flag == 0){\\n                    ans = (ans+rec(i+1,0,cur_sum+ind,x))%M;\\n                }else{\\n                    ans = (ans+rec(i+1,1,cur_sum+ind,x))%M;\\n                }\\n            }else{\\n                ans = (ans+rec(i+1,0,cur_sum+ind,x))%M;\\n            }\\n            ind += 1;\\n        }\\n        return dp[i][flag][cur_sum] = ans;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int i;\\n        memset(dp,-1,sizeof(dp));\\n        int diff = num2.size()-num1.size();\\n        string temp = \"\";\\n        i = 0;\\n        while(i < diff){\\n            temp += \"0\";\\n            i += 1;\\n        }\\n        num1 = temp+num1;\\n        mi = min_sum;\\n        ma = max_sum;\\n        int ans1,ans2;\\n        n = num2.size();\\n        ans1 = rec(0,1,0,num1);\\n        memset(dp,-1,sizeof(dp));\\n        ans2 = (rec(0,1,0,num2)-ans1)%M;\\n        ans2 = (ans2+1000000007)%M;\\n        int som = 0;\\n        i = 0;\\n        int val;\\n        char b;\\n        while(i < n){\\n            b = num1[i];\\n            val = b-\\'0\\';\\n            som = som+val;\\n            i += 1;\\n        }\\n        if((som >= mi)&&(som <= ma)){\\n            return (ans2+1)%M;\\n        }\\n        return ans2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M = 1000000007;\\n    int mi,ma,n;\\n    int dp[24][2][216];\\n    int rec(int i,int flag,int cur_sum,string &x){\\n        if(i == n){\\n            if((cur_sum >= mi)&&(cur_sum <= ma)){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][flag][cur_sum] != -1){\\n            return dp[i][flag][cur_sum];\\n        }\\n        int limit = 9;\\n        char a = x[i];\\n        if(flag == 1){\\n            limit = a-\\'0\\';\\n        }\\n        int ans,ind;\\n        ans = 0;\\n        ind = 0;\\n        while(ind <= limit){\\n            if(ind == limit){\\n                if(flag == 0){\\n                    ans = (ans+rec(i+1,0,cur_sum+ind,x))%M;\\n                }else{\\n                    ans = (ans+rec(i+1,1,cur_sum+ind,x))%M;\\n                }\\n            }else{\\n                ans = (ans+rec(i+1,0,cur_sum+ind,x))%M;\\n            }\\n            ind += 1;\\n        }\\n        return dp[i][flag][cur_sum] = ans;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int i;\\n        memset(dp,-1,sizeof(dp));\\n        int diff = num2.size()-num1.size();\\n        string temp = \"\";\\n        i = 0;\\n        while(i < diff){\\n            temp += \"0\";\\n            i += 1;\\n        }\\n        num1 = temp+num1;\\n        mi = min_sum;\\n        ma = max_sum;\\n        int ans1,ans2;\\n        n = num2.size();\\n        ans1 = rec(0,1,0,num1);\\n        memset(dp,-1,sizeof(dp));\\n        ans2 = (rec(0,1,0,num2)-ans1)%M;\\n        ans2 = (ans2+1000000007)%M;\\n        int som = 0;\\n        i = 0;\\n        int val;\\n        char b;\\n        while(i < n){\\n            b = num1[i];\\n            val = b-\\'0\\';\\n            som = som+val;\\n            i += 1;\\n        }\\n        if((som >= mi)&&(som <= ma)){\\n            return (ans2+1)%M;\\n        }\\n        return ans2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614290,
                "title": "neat-code-precise-implementation-digit-dp-recursion-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n#define ull unsigned long long\\n#define rep0(i,n) for(ll i = 0; i < n; i++)\\n#define rep1(i,n) for(ll i = 1; i <= n; i++)\\n#define rrep0(i, n) for(ll i = n-1; i >= 0; i--)\\n#define rrep1(i, n) for(ll i = n; i >= 0; i--)\\n#define For(i, left, right, cnt) for(ll i = left; i < right; i++)\\n#define all(a) (a.begin()), (a.end())\\n#define memo(a) memset(a, -1, sizeof(a));\\n#define put(n) (cout << n << endl)\\n#define get(n) (cin >> n);\\n#define get2(a,b)get(a)get(b)\\n#define get3(a,b,c)get2(a,b)get(c)\\n#define get4(a,b,c,d)get2(a,b)get2(c,d)\\n#define get5(a,b,c,d,e)get4(a,b,c,d)get(e)\\n#define len(x) ((ll)x.size()) \\n#define pb push_back\\n#define MIN(v) *min_element(all(v))\\n#define MAX(v) *max_element(all(v))\\n#define LB(c, x) distance((c).begin(), lower_bound(all(c), (x)))\\n#define UB(c, x) distance((c).begin(), upper_bound(all(c), (x)))\\nconst ll MOD = 1000000007;\\nconst long long oo = 1e16;\\nconst ll MX = (1LL<<60);\\nconst int LOG = 60;\\nconst ll N = 1e5+10;\\ntypedef vector<ll> vi;\\ntypedef pair<ll, ll> pii;\\n\\nclass Solution {\\npublic:\\n    int dp[30][401][3];\\n    bool is_ok(string& left, int min_sum, int max_sum) {\\n        int sum = 0;\\n        rep0(i, len(left)) {\\n            sum += (left[i] - \\'0\\');\\n        }\\n\\n        return (sum >= min_sum && sum <= max_sum);\\n    }\\n\\n    int rec(string& right, int n, int digit_sum, int min_sum, int max_sum, int tight) {\\n        if(digit_sum >  max_sum) return 0;\\n        \\n        if(n == 0) {\\n            return (digit_sum >= min_sum && digit_sum <= max_sum);\\n        } \\n\\n        if(dp[n][digit_sum][tight] != -1) return dp[n][digit_sum][tight];\\n\\n        int ans = 0, ub = tight ? (right[len(right) - n] - \\'0\\') : 9;\\n        for(int dig = 0; dig <= ub; dig++) {\\n            ans += rec(right, n-1, digit_sum + dig, min_sum, max_sum, (tight && (dig == ub)));\\n            ans %= MOD;\\n        }\\n\\n        return dp[n][digit_sum][tight] = ans;\\n    }\\n\\n    int count(string left, string right, int min_sum, int max_sum) {\\n        memo(dp);\\n        int ans = rec(right, len(right), 0, min_sum, max_sum, 1);\\n\\n        memo(dp);\\n        ans -= rec(left, len(left), 0, min_sum, max_sum, 1);\\n\\n        if(is_ok(left, min_sum, max_sum)) ++ans;\\n\\n        ans %= MOD;\\n        ans += MOD;\\n        ans %= MOD;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long\\n#define ull unsigned long long\\n#define rep0(i,n) for(ll i = 0; i < n; i++)\\n#define rep1(i,n) for(ll i = 1; i <= n; i++)\\n#define rrep0(i, n) for(ll i = n-1; i >= 0; i--)\\n#define rrep1(i, n) for(ll i = n; i >= 0; i--)\\n#define For(i, left, right, cnt) for(ll i = left; i < right; i++)\\n#define all(a) (a.begin()), (a.end())\\n#define memo(a) memset(a, -1, sizeof(a));\\n#define put(n) (cout << n << endl)\\n#define get(n) (cin >> n);\\n#define get2(a,b)get(a)get(b)\\n#define get3(a,b,c)get2(a,b)get(c)\\n#define get4(a,b,c,d)get2(a,b)get2(c,d)\\n#define get5(a,b,c,d,e)get4(a,b,c,d)get(e)\\n#define len(x) ((ll)x.size()) \\n#define pb push_back\\n#define MIN(v) *min_element(all(v))\\n#define MAX(v) *max_element(all(v))\\n#define LB(c, x) distance((c).begin(), lower_bound(all(c), (x)))\\n#define UB(c, x) distance((c).begin(), upper_bound(all(c), (x)))\\nconst ll MOD = 1000000007;\\nconst long long oo = 1e16;\\nconst ll MX = (1LL<<60);\\nconst int LOG = 60;\\nconst ll N = 1e5+10;\\ntypedef vector<ll> vi;\\ntypedef pair<ll, ll> pii;\\n\\nclass Solution {\\npublic:\\n    int dp[30][401][3];\\n    bool is_ok(string& left, int min_sum, int max_sum) {\\n        int sum = 0;\\n        rep0(i, len(left)) {\\n            sum += (left[i] - \\'0\\');\\n        }\\n\\n        return (sum >= min_sum && sum <= max_sum);\\n    }\\n\\n    int rec(string& right, int n, int digit_sum, int min_sum, int max_sum, int tight) {\\n        if(digit_sum >  max_sum) return 0;\\n        \\n        if(n == 0) {\\n            return (digit_sum >= min_sum && digit_sum <= max_sum);\\n        } \\n\\n        if(dp[n][digit_sum][tight] != -1) return dp[n][digit_sum][tight];\\n\\n        int ans = 0, ub = tight ? (right[len(right) - n] - \\'0\\') : 9;\\n        for(int dig = 0; dig <= ub; dig++) {\\n            ans += rec(right, n-1, digit_sum + dig, min_sum, max_sum, (tight && (dig == ub)));\\n            ans %= MOD;\\n        }\\n\\n        return dp[n][digit_sum][tight] = ans;\\n    }\\n\\n    int count(string left, string right, int min_sum, int max_sum) {\\n        memo(dp);\\n        int ans = rec(right, len(right), 0, min_sum, max_sum, 1);\\n\\n        memo(dp);\\n        ans -= rec(left, len(left), 0, min_sum, max_sum, 1);\\n\\n        if(is_ok(left, min_sum, max_sum)) ++ans;\\n\\n        ans %= MOD;\\n        ans += MOD;\\n        ans %= MOD;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3611765,
                "title": "digit-dp-question-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, weneed to generate all possible integers between num1 and num2,while keeping track of the sum of their digits and check if the sum lies between min_sum and max_sum. Now to generate all possible num we use a recursive approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can recursively iterate through each digit position and try all possible digit values for that position. We need to consider two cases:\\n1. If the current digit position is fixed (isFixed = true), we can only choose the digit value that is less than or\\n    equal to the corresponding digit in num2.\\n2. If the current digit position is not fixed (isFixed = false), we can choose any digit value from 0 to 9.\\n\\n**We can use memoization (dp array) to store the intermediate results and avoid redundant calculations.**\\n\\n# Complexity\\n- Time complexity: $$O(N * 10 * M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere N is the maximum length of num1 or num2, and M is the maximum digit sum (max_sum).\\n\\nThis complexity arises from the nested loops in the solve() function, where we iterate through each digit position,each possible digit value (0 to 9), and for each digit value, we make a recursive call.\\n\\n*Note that the maximum length of num1 or num2 is at most 22 digits, and the maximum digit sum is at most 400.*\\n\\n- Space complexity: $$O(N * 2 * M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n where N is the maximum length of num1 or num2, and M is the maximum digit sum (max_sum).\\n\\nThis space is used to store the dp array, which has dimensions [23][2][401].\\n\\n*Note that the maximum length of num1 or num2 is at most 22 digits, and the maximum digit sum is at most 400.*\\n\\n# Code\\n```\\n#define MOD 1000000007\\nclass Solution {\\nprivate:\\n    int dp[23][2][401];\\npublic:\\n    int getDigitSum(string str) {\\n        int sum = 0;\\n        for(int i=0;i<str.length();i++){\\n            sum += (str[i]-\\'0\\');\\n        } \\n        return sum;\\n    }\\n    int solve(int idx,bool isFixed,int curr_sum, string num,int min_sum,int max_sum)\\n    { \\n        // If idx reaches the end of the number, check if the current sum falls within the desired range\\n        if(idx==num.size())\\n        return (curr_sum>=min_sum && curr_sum <= max_sum)?1:0;\\n\\n        // Check if the result for the current state is already computed\\n        if(dp[idx][isFixed][curr_sum]!=-1)\\n         return dp[idx][isFixed][curr_sum];\\n       \\n        // Determine the upper limit for the current digit position\\n         int upperLimit = isFixed ? num[idx]-\\'0\\': 9;\\n         int ans = 0;\\n        // Try all possible digit values for the current position\\n         for(int i=0;i<=upperLimit;i++)\\n         {\\n            // Determine if the next digit position should be fixed\\n             bool nextFixed = isFixed && i==upperLimit;\\n             ans= (ans +solve(idx+1,nextFixed,curr_sum+i,num,min_sum,max_sum))%MOD;\\n         }\\n        // Store the result in the dp array and return it\\n        return dp[idx][isFixed][curr_sum]=ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof(dp));\\n        //calculation of count of good number till num2\\n        int ans = solve(0,1,0,num2,min_sum,max_sum);\\n\\n        //calculation of count of good number till num1\\n        memset(dp,-1,sizeof(dp));\\n         ans-= solve(0,1,0,num1,min_sum,max_sum);\\n        //subtraction above will give count of good nunmbers from [a+1,b]\\n\\n        // Check if num1 itself is a good number\\n        int sum_num1 =getDigitSum(num1);\\n        if(sum_num1>=min_sum&&sum_num1<=max_sum)\\n        ans++;\\n\\n        return (ans+MOD)%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define MOD 1000000007\\nclass Solution {\\nprivate:\\n    int dp[23][2][401];\\npublic:\\n    int getDigitSum(string str) {\\n        int sum = 0;\\n        for(int i=0;i<str.length();i++){\\n            sum += (str[i]-\\'0\\');\\n        } \\n        return sum;\\n    }\\n    int solve(int idx,bool isFixed,int curr_sum, string num,int min_sum,int max_sum)\\n    { \\n        // If idx reaches the end of the number, check if the current sum falls within the desired range\\n        if(idx==num.size())\\n        return (curr_sum>=min_sum && curr_sum <= max_sum)?1:0;\\n\\n        // Check if the result for the current state is already computed\\n        if(dp[idx][isFixed][curr_sum]!=-1)\\n         return dp[idx][isFixed][curr_sum];\\n       \\n        // Determine the upper limit for the current digit position\\n         int upperLimit = isFixed ? num[idx]-\\'0\\': 9;\\n         int ans = 0;\\n        // Try all possible digit values for the current position\\n         for(int i=0;i<=upperLimit;i++)\\n         {\\n            // Determine if the next digit position should be fixed\\n             bool nextFixed = isFixed && i==upperLimit;\\n             ans= (ans +solve(idx+1,nextFixed,curr_sum+i,num,min_sum,max_sum))%MOD;\\n         }\\n        // Store the result in the dp array and return it\\n        return dp[idx][isFixed][curr_sum]=ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof(dp));\\n        //calculation of count of good number till num2\\n        int ans = solve(0,1,0,num2,min_sum,max_sum);\\n\\n        //calculation of count of good number till num1\\n        memset(dp,-1,sizeof(dp));\\n         ans-= solve(0,1,0,num1,min_sum,max_sum);\\n        //subtraction above will give count of good nunmbers from [a+1,b]\\n\\n        // Check if num1 itself is a good number\\n        int sum_num1 =getDigitSum(num1);\\n        if(sum_num1>=min_sum&&sum_num1<=max_sum)\\n        ans++;\\n\\n        return (ans+MOD)%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606728,
                "title": "golang-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Golang implementation of solution from `https://www.youtube.com/watch?v=ZsHbl-DEjX8`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype State struct {\\n    isSmaller bool\\n    index int\\n    sum int\\n}\\n\\nconst (\\n    MOD = 1e9+7\\n    maxLength = 23\\n)\\n\\nfunc count(num1 string, num2 string, min_sum int, max_sum int) int {\\n    numGoodInts2 := numGoodIntsLessThan(padLeadingZeros(num2), min_sum, max_sum, make(map[State]int))\\n    numGoodInts1 := numGoodIntsLessThan(minusOne(padLeadingZeros(num1)), min_sum, max_sum, make(map[State]int))\\n    return (numGoodInts2 - numGoodInts1 + MOD ) % MOD\\n}\\n\\n\\nfunc padLeadingZeros(num string) []byte {\\n    out := make([]byte, maxLength)\\n    for i := range num {\\n        out[maxLength-len(num)+i] = num[i] - \\'0\\'\\n    }\\n    return out\\n}\\n\\n\\nfunc minusOne(num []byte) []byte {\\n    lastNonZeroIndex := len(num)\\n    for i := len(num)-1; i >= 0; i-- {\\n        if num[i] > 0 {\\n            lastNonZeroIndex = i\\n            break\\n        }\\n    }\\n\\n    num[lastNonZeroIndex]--\\n    for i := lastNonZeroIndex+1; i < len(num); i++ {\\n        num[i] = 9\\n    }\\n    return num\\n}\\n\\n\\nfunc getNumGoodInts(num []byte, min_sum int, max_sum int, isSmaller bool, index int, sum int, dp map[State]int) int {\\n    if index == len(num) {\\n        if min_sum <= sum && sum <= max_sum {\\n            return 1\\n        }\\n        return 0\\n    }\\n\\n    if sum > max_sum {\\n        return 0\\n    }\\n\\n    state := State{isSmaller, index, sum}\\n    if v, ok := dp[state]; ok {\\n        return v\\n    }\\n\\n    endVal := 9\\n    if !isSmaller {\\n        endVal = int(num[index])\\n    }\\n    count := 0\\n    for i := 0; i <= endVal; i++ {\\n        count = (count + getNumGoodInts(num, min_sum, max_sum, isSmaller || i < endVal, index+1, sum+i, dp)%MOD ) % MOD\\n    }\\n    dp[state] = count\\n\\n    return count\\n}\\n\\nfunc numGoodIntsLessThan(num []byte, min_sum int, max_sum int, dp map[State]int) int {\\n    return getNumGoodInts(num, min_sum, max_sum, false, 0, 0, dp)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype State struct {\\n    isSmaller bool\\n    index int\\n    sum int\\n}\\n\\nconst (\\n    MOD = 1e9+7\\n    maxLength = 23\\n)\\n\\nfunc count(num1 string, num2 string, min_sum int, max_sum int) int {\\n    numGoodInts2 := numGoodIntsLessThan(padLeadingZeros(num2), min_sum, max_sum, make(map[State]int))\\n    numGoodInts1 := numGoodIntsLessThan(minusOne(padLeadingZeros(num1)), min_sum, max_sum, make(map[State]int))\\n    return (numGoodInts2 - numGoodInts1 + MOD ) % MOD\\n}\\n\\n\\nfunc padLeadingZeros(num string) []byte {\\n    out := make([]byte, maxLength)\\n    for i := range num {\\n        out[maxLength-len(num)+i] = num[i] - \\'0\\'\\n    }\\n    return out\\n}\\n\\n\\nfunc minusOne(num []byte) []byte {\\n    lastNonZeroIndex := len(num)\\n    for i := len(num)-1; i >= 0; i-- {\\n        if num[i] > 0 {\\n            lastNonZeroIndex = i\\n            break\\n        }\\n    }\\n\\n    num[lastNonZeroIndex]--\\n    for i := lastNonZeroIndex+1; i < len(num); i++ {\\n        num[i] = 9\\n    }\\n    return num\\n}\\n\\n\\nfunc getNumGoodInts(num []byte, min_sum int, max_sum int, isSmaller bool, index int, sum int, dp map[State]int) int {\\n    if index == len(num) {\\n        if min_sum <= sum && sum <= max_sum {\\n            return 1\\n        }\\n        return 0\\n    }\\n\\n    if sum > max_sum {\\n        return 0\\n    }\\n\\n    state := State{isSmaller, index, sum}\\n    if v, ok := dp[state]; ok {\\n        return v\\n    }\\n\\n    endVal := 9\\n    if !isSmaller {\\n        endVal = int(num[index])\\n    }\\n    count := 0\\n    for i := 0; i <= endVal; i++ {\\n        count = (count + getNumGoodInts(num, min_sum, max_sum, isSmaller || i < endVal, index+1, sum+i, dp)%MOD ) % MOD\\n    }\\n    dp[state] = count\\n\\n    return count\\n}\\n\\nfunc numGoodIntsLessThan(num []byte, min_sum int, max_sum int, dp map[State]int) int {\\n    return getNumGoodInts(num, min_sum, max_sum, false, 0, 0, dp)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3606613,
                "title": "c-dp",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(max(len(num1),len(num2))\\u2217max(sum(num1),sum(num2)))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(max(len(num1),len(num2))\\u2217max(sum(num1),sum(num2)))$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7; \\n    int dp[23][410]; \\n\\n    long long sumLessThanNum(string num, int l, int r) {\\n        memset(dp, 0, sizeof(dp)); \\n        int n = num.size(); \\n        /*\\n        i: 0 to n-1 ==> most significant bit to least significant bit\\n        For each number of bit, the max sum of previous bits with any combination of current bit. \\n        ( not inlcuded the number itself )\\n        */\\n        for ( int i = 0, sum = 0; i < n; i++ ) {\\n            for ( int j = 0; j < num[i]-\\'0\\'; j++ ) {\\n                if ( i == 0 && j == 0 ) { continue; }\\n                dp[i][sum+j]++;\\n            }\\n            sum += num[i] - \\'0\\';\\n        }\\n        /*\\n        When only the ith bit has value (the rest are zeros), and its value is j. \\n        */\\n        for ( int i = 1; i < n; i++ ) {\\n            /* \\n            If zero is set for this bit, all bits are zeros. \\n            So, 0 is excluded. \\n            */\\n            for ( int j = 1; j <= 9; j++ ) {\\n                dp[i][j]++; \\n            }\\n        }\\n        /*\\n        Given previous ith bits, count the number of sums for i+1 bit ( remaining cases. )\\n        */\\n        for ( int i = 0; i+1 < n; i++ ) {\\n            for ( int j = 1; j < 410; j++ ) {\\n                if ( dp[i][j] != 0 ) {\\n                    for ( int k = 0; k <= 9; k++ ){\\n                        dp[i+1][j+k] += dp[i][j];\\n                        dp[i+1][j+k] %= mod; \\n                    }\\n                } else { break; }\\n            }\\n        }\\n        long long ret = 0;\\n        for ( int i = l; i <= r; i++ ) {\\n            ret += dp[n-1][i];\\n            ret %= mod; \\n        }\\n        return ret;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        long long ret = sumLessThanNum(num2, min_sum, max_sum) - sumLessThanNum(num1, min_sum, max_sum);\\n        int sum_num2 = 0;\\n        for ( int i = 0; i < num2.size(); i++ ) {\\n            sum_num2 += num2[i]-\\'0\\';\\n        }\\n        if ( sum_num2 >= min_sum && sum_num2 <= max_sum ) { ret++; }\\n        int ans = (ret % mod + mod) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7; \\n    int dp[23][410]; \\n\\n    long long sumLessThanNum(string num, int l, int r) {\\n        memset(dp, 0, sizeof(dp)); \\n        int n = num.size(); \\n        /*\\n        i: 0 to n-1 ==> most significant bit to least significant bit\\n        For each number of bit, the max sum of previous bits with any combination of current bit. \\n        ( not inlcuded the number itself )\\n        */\\n        for ( int i = 0, sum = 0; i < n; i++ ) {\\n            for ( int j = 0; j < num[i]-\\'0\\'; j++ ) {\\n                if ( i == 0 && j == 0 ) { continue; }\\n                dp[i][sum+j]++;\\n            }\\n            sum += num[i] - \\'0\\';\\n        }\\n        /*\\n        When only the ith bit has value (the rest are zeros), and its value is j. \\n        */\\n        for ( int i = 1; i < n; i++ ) {\\n            /* \\n            If zero is set for this bit, all bits are zeros. \\n            So, 0 is excluded. \\n            */\\n            for ( int j = 1; j <= 9; j++ ) {\\n                dp[i][j]++; \\n            }\\n        }\\n        /*\\n        Given previous ith bits, count the number of sums for i+1 bit ( remaining cases. )\\n        */\\n        for ( int i = 0; i+1 < n; i++ ) {\\n            for ( int j = 1; j < 410; j++ ) {\\n                if ( dp[i][j] != 0 ) {\\n                    for ( int k = 0; k <= 9; k++ ){\\n                        dp[i+1][j+k] += dp[i][j];\\n                        dp[i+1][j+k] %= mod; \\n                    }\\n                } else { break; }\\n            }\\n        }\\n        long long ret = 0;\\n        for ( int i = l; i <= r; i++ ) {\\n            ret += dp[n-1][i];\\n            ret %= mod; \\n        }\\n        return ret;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        long long ret = sumLessThanNum(num2, min_sum, max_sum) - sumLessThanNum(num1, min_sum, max_sum);\\n        int sum_num2 = 0;\\n        for ( int i = 0; i < num2.size(); i++ ) {\\n            sum_num2 += num2[i]-\\'0\\';\\n        }\\n        if ( sum_num2 >= min_sum && sum_num2 <= max_sum ) { ret++; }\\n        int ans = (ret % mod + mod) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605367,
                "title": "only-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n\\n\\n        m=(10**9)+7\\n        @cache\\n        def fun(ind,temp,l,h):\\n            nonlocal num1,num2,m\\n            if temp>max_sum:\\n                return 0\\n            if ind==len(num2):\\n                if temp>=min_sum and temp<=max_sum:\\n                    # print(val)\\n                    return 1\\n                return 0\\n            start=int(num1[ind-(len(num2)-len(num1))]) if (l and len(num2)-len(num1)<ind+1) else 0\\n            end=int(num2[ind]) if h else 9\\n            ans=0\\n            for i in range(start,end+1):\\n                ll=l&((len(num2)-len(num1)>=ind+1 and i==0) or (len(num2)-len(num1)<ind+1 and i==int(num1[ind-(len(num2)-len(num1))])))\\n                hh=h&(i==int(num2[ind]))\\n                ans+=fun(ind+1,temp+i,ll,hh)\\n            return ans%m\\n        return fun(0,0,True,True)\\n\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n\\n\\n        m=(10**9)+7\\n        @cache\\n        def fun(ind,temp,l,h):\\n            nonlocal num1,num2,m\\n            if temp>max_sum:\\n                return 0\\n            if ind==len(num2):\\n                if temp>=min_sum and temp<=max_sum:\\n                    # print(val)\\n                    return 1\\n                return 0\\n            start=int(num1[ind-(len(num2)-len(num1))]) if (l and len(num2)-len(num1)<ind+1) else 0\\n            end=int(num2[ind]) if h else 9\\n            ans=0\\n            for i in range(start,end+1):\\n                ll=l&((len(num2)-len(num1)>=ind+1 and i==0) or (len(num2)-len(num1)<ind+1 and i==int(num1[ind-(len(num2)-len(num1))])))\\n                hh=h&(i==int(num2[ind]))\\n                ans+=fun(ind+1,temp+i,ll,hh)\\n            return ans%m\\n        return fun(0,0,True,True)\\n\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604899,
                "title": "java-solution-4d-digit-dp",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n    private int[][][][] dp;\\n\\n    public int countStrings(int i, boolean tight1, boolean tight2, int sum, String num1, String num2) {\\n        if (sum < 0) return 0;\\n        if (i == num2.length()) return 1;\\n        if (dp[i][tight1 ? 1 : 0][tight2 ? 1 : 0][sum] != -1)\\n            return dp[i][tight1 ? 1 : 0][tight2 ? 1 : 0][sum];\\n\\n        int lo = tight1 ? num1.charAt(i) - \\'0\\' : 0;\\n        int hi = tight2 ? num2.charAt(i) - \\'0\\' : 9;\\n\\n        int count = 0;\\n        for (int idx = lo; idx <= hi; idx++) {\\n            count = (count % MOD + countStrings(i + 1,\\n                    tight1 & (idx == lo), tight2 & (idx == hi),\\n                    sum - idx, num1, num2) % MOD) % MOD;\\n        }\\n\\n        return dp[i][tight1 ? 1 : 0][tight2 ? 1 : 0][sum] = count;\\n    }\\n\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        int maxLength = num2.length();\\n        int minLength = num1.length();\\n        int leadingZeroes = maxLength - minLength;\\n        String num1extended = \"0\".repeat(leadingZeroes) + num1;\\n\\n        dp = new int[maxLength][2][2][401];\\n        for (int[][][] dim1 : dp) {\\n            for (int[][] dim2 : dim1) {\\n                for (int[] dim3 : dim2) {\\n                    Arrays.fill(dim3, -1);\\n                }\\n            }\\n        }\\n\\n        int total = countStrings(0, true, true, max_sum, num1extended, num2);\\n        int unnecessary = countStrings(0, true, true, min_sum - 1, num1extended, num2);\\n        int ans = (total - unnecessary) % MOD;\\n\\n        if (ans < 0) {\\n            ans += MOD;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n    private int[][][][] dp;\\n\\n    public int countStrings(int i, boolean tight1, boolean tight2, int sum, String num1, String num2) {\\n        if (sum < 0) return 0;\\n        if (i == num2.length()) return 1;\\n        if (dp[i][tight1 ? 1 : 0][tight2 ? 1 : 0][sum] != -1)\\n            return dp[i][tight1 ? 1 : 0][tight2 ? 1 : 0][sum];\\n\\n        int lo = tight1 ? num1.charAt(i) - \\'0\\' : 0;\\n        int hi = tight2 ? num2.charAt(i) - \\'0\\' : 9;\\n\\n        int count = 0;\\n        for (int idx = lo; idx <= hi; idx++) {\\n            count = (count % MOD + countStrings(i + 1,\\n                    tight1 & (idx == lo), tight2 & (idx == hi),\\n                    sum - idx, num1, num2) % MOD) % MOD;\\n        }\\n\\n        return dp[i][tight1 ? 1 : 0][tight2 ? 1 : 0][sum] = count;\\n    }\\n\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        int maxLength = num2.length();\\n        int minLength = num1.length();\\n        int leadingZeroes = maxLength - minLength;\\n        String num1extended = \"0\".repeat(leadingZeroes) + num1;\\n\\n        dp = new int[maxLength][2][2][401];\\n        for (int[][][] dim1 : dp) {\\n            for (int[][] dim2 : dim1) {\\n                for (int[] dim3 : dim2) {\\n                    Arrays.fill(dim3, -1);\\n                }\\n            }\\n        }\\n\\n        int total = countStrings(0, true, true, max_sum, num1extended, num2);\\n        int unnecessary = countStrings(0, true, true, min_sum - 1, num1extended, num2);\\n        int ans = (total - unnecessary) % MOD;\\n\\n        if (ans < 0) {\\n            ans += MOD;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604650,
                "title": "digit-dp",
                "content": "```\\nint mod = 1e9+7;\\nusing ll = long long;\\nll dp[25][235][2];\\nclass Solution {\\npublic:\\nbool check(ll sum, int mini, int maxi)\\n{\\n    return sum>=mini && sum<=maxi;\\n}\\n    \\nint G(string number, int mini, int maxi, ll pos = 0, ll sum = 0, ll tight = 1)\\n{\\n\\tif(pos == number.size()) \\n\\t{\\n\\t\\tif(check(sum, mini, maxi)) return 1;\\n        return 0;\\n\\t}\\n\\telse if(dp[pos][sum][tight] != -1) return dp[pos][sum][tight];\\n\\telse if(tight == 1)\\n\\t{\\n\\t\\tll res = 0;\\n\\t\\tfor(int i = 0;i<=number[pos]-\\'0\\';i++)\\n\\t\\t{\\n\\t\\t\\tif(i == number[pos] - \\'0\\')\\n\\t\\t\\t\\tres += G(number, mini, maxi, pos+1, sum+i, 1)%mod;\\n\\t\\t\\telse \\n\\t\\t\\t\\tres += G(number, mini, maxi, pos+1, sum+i, 0)%mod;\\n\\t\\t}\\n\\t\\treturn dp[pos][sum][tight] = res%mod;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tll res = 0;\\n\\t\\tfor(int i = 0;i<=9;i++)\\n\\t\\t{\\n\\t\\t\\tres += G(number, mini, maxi, pos+1, sum+i, 0)%mod;\\n\\t\\t}\\n\\t\\treturn dp[pos][sum][tight] = res%mod;\\n\\t}\\n}\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof(dp));\\n        ll ans1 = G(num2, min_sum, max_sum); \\n        memset(dp, -1, sizeof(dp));\\n        int n = num1.size();\\n        int p = n-1;\\n        //Getting num1 - 1 as a string \\n        while(num1[p]==\\'0\\') p--; \\n        num1[p++]--;\\n        while(p<n) num1[p++] = \\'9\\';\\n        ll ans2 = G(num1, min_sum, max_sum);\\n        int res = (ans1-ans2+mod)%mod;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint mod = 1e9+7;\\nusing ll = long long;\\nll dp[25][235][2];\\nclass Solution {\\npublic:\\nbool check(ll sum, int mini, int maxi)\\n{\\n    return sum>=mini && sum<=maxi;\\n}\\n    \\nint G(string number, int mini, int maxi, ll pos = 0, ll sum = 0, ll tight = 1)\\n{\\n\\tif(pos == number.size()) \\n\\t{\\n\\t\\tif(check(sum, mini, maxi)) return 1;\\n        return 0;\\n\\t}\\n\\telse if(dp[pos][sum][tight] != -1) return dp[pos][sum][tight];\\n\\telse if(tight == 1)\\n\\t{\\n\\t\\tll res = 0;\\n\\t\\tfor(int i = 0;i<=number[pos]-\\'0\\';i++)\\n\\t\\t{\\n\\t\\t\\tif(i == number[pos] - \\'0\\')\\n\\t\\t\\t\\tres += G(number, mini, maxi, pos+1, sum+i, 1)%mod;\\n\\t\\t\\telse \\n\\t\\t\\t\\tres += G(number, mini, maxi, pos+1, sum+i, 0)%mod;\\n\\t\\t}\\n\\t\\treturn dp[pos][sum][tight] = res%mod;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tll res = 0;\\n\\t\\tfor(int i = 0;i<=9;i++)\\n\\t\\t{\\n\\t\\t\\tres += G(number, mini, maxi, pos+1, sum+i, 0)%mod;\\n\\t\\t}\\n\\t\\treturn dp[pos][sum][tight] = res%mod;\\n\\t}\\n}\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp, -1, sizeof(dp));\\n        ll ans1 = G(num2, min_sum, max_sum); \\n        memset(dp, -1, sizeof(dp));\\n        int n = num1.size();\\n        int p = n-1;\\n        //Getting num1 - 1 as a string \\n        while(num1[p]==\\'0\\') p--; \\n        num1[p++]--;\\n        while(p<n) num1[p++] = \\'9\\';\\n        ll ans2 = G(num1, min_sum, max_sum);\\n        int res = (ans1-ans2+mod)%mod;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602934,
                "title": "javascript-code-explained-dp-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @param {number} min_sum\\n * @param {number} max_sum\\n * @return {number}\\n */\\nvar count = function(num1, num2, min_sum, max_sum) {\\n    const modulo = 10**9 + 7\\n\\n    // dp - 2D array\\n    // dp[i][j] - count of numbers of length i with digits sum equals j\\n    // so dp[0] - is empty\\n    // dp[1] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] - for a number with 1 digit \\n    // there 10 possible sums of its digits - from 0 to 9, each sum can be acheaved in a single way\\n    //\\n    // dp[2] - count of numbers of length 2, can be calculated using dp[1] and digits 0 to 9\\n\\n    const dp = [[], Array(10).fill(1)]\\n    const l2 = num2.length\\n    for (let i = 2; i <= l2; i++) {\\n        let tmp = Array(9 + dp.at(-1).length).fill(0)\\n        for (let n = 0; n <= 9; n++) {\\n            // n + k <= 400 based on the task constains \\n            // 1 <= min_sum <= max_sum <= 400\\n            for (let k = 0; k < dp.at(-1).length && n + k <= 400; k++) {\\n                tmp[n + k] += dp.at(-1)[k] % modulo\\n            }\\n        }\\n        dp.push(tmp)\\n    }\\n    \\n\\n    // using dp array we can calculate a count of numbers of length len\\n    // with their digits sum in the range [min : max]\\n    const getCountByNumberLength = (min, max, len) => {\\n        if (max < 0) return 0\\n        let sum = 0\\n        for (let i = 0; i <= max && i < dp[len].length; i++) {\\n            if (i >= min) {\\n                sum += dp[len][i]\\n                sum = sum % modulo                    \\n            }\\n        }\\n        return sum\\n    }\\n\\n    // recursively calculate count of integers in the range 1 to nums\\n    // with the digits sum in the range minS and maxS\\n    const rec = (nums, minS, maxS) => {\\n\\n        // get the top most digit\\n        const firstDigit = nums.shift()\\n        let count = 0\\n\\n        // if the number had only 1 digit\\n        if (nums.length == 0) {\\n            for (let i = 0; i <= firstDigit; i++) {\\n                if (i >= minS && i <= maxS) count++\\n            }\\n        } else {\\n            for (let i = 0; i < firstDigit; i++) {\\n                count += getCountByNumberLength(minS - i, maxS - i, nums.length)\\n                count = count % modulo\\n            }\\n            count += rec(nums, minS - firstDigit, maxS - firstDigit)\\n            count = count % modulo            \\n        }\\n        return count\\n    }\\n    \\n\\n    // convert num1 and num2 strings into arrays \\n    // e.g. \"1234\" => [1, 2, 3, 4]\\n    const nums1 = num1.split(\"\").map(i => +i)\\n    const nums2 = num2.split(\"\").map(i => +i)\\n    let t = nums1.length - 1\\n\\n    // decrease num1 by 1, e.g. if num1 = \"1234\" => [1, 2, 3, 3]\\n    while (true) {\\n        if (nums1[t] > 0) {\\n            nums1[t]--\\n            break\\n        } else {\\n            t--\\n        }\\n    }\\n    for (let i = t + 1; i < nums1.length; i++) {\\n        nums1[i] = 9\\n    }\\n\\n    // get count of numbers with their sum in the range [min_sum : max_sum]\\n    // get it for nums1 - from 1 to (nums1 - 1)\\n    // and for nums2 - from 1 to nums2\\n    const count1 = rec(nums1, min_sum, max_sum)\\n    const count2 = rec(nums2, min_sum, max_sum)\\n    \\n    // the answer we are looking for will be \\n    // count2 - count1, as we need the count in the range num1 <= x <= num2\\n    const res = (count2 - count1) % modulo\\n\\n    // as we use modulo in out calculations, in some cases we can end up\\n    // with count2 < count1, so add modulo in this case\\n    return res < 0 ? res + modulo : res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @param {number} min_sum\\n * @param {number} max_sum\\n * @return {number}\\n */\\nvar count = function(num1, num2, min_sum, max_sum) {\\n    const modulo = 10**9 + 7\\n\\n    // dp - 2D array\\n    // dp[i][j] - count of numbers of length i with digits sum equals j\\n    // so dp[0] - is empty\\n    // dp[1] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] - for a number with 1 digit \\n    // there 10 possible sums of its digits - from 0 to 9, each sum can be acheaved in a single way\\n    //\\n    // dp[2] - count of numbers of length 2, can be calculated using dp[1] and digits 0 to 9\\n\\n    const dp = [[], Array(10).fill(1)]\\n    const l2 = num2.length\\n    for (let i = 2; i <= l2; i++) {\\n        let tmp = Array(9 + dp.at(-1).length).fill(0)\\n        for (let n = 0; n <= 9; n++) {\\n            // n + k <= 400 based on the task constains \\n            // 1 <= min_sum <= max_sum <= 400\\n            for (let k = 0; k < dp.at(-1).length && n + k <= 400; k++) {\\n                tmp[n + k] += dp.at(-1)[k] % modulo\\n            }\\n        }\\n        dp.push(tmp)\\n    }\\n    \\n\\n    // using dp array we can calculate a count of numbers of length len\\n    // with their digits sum in the range [min : max]\\n    const getCountByNumberLength = (min, max, len) => {\\n        if (max < 0) return 0\\n        let sum = 0\\n        for (let i = 0; i <= max && i < dp[len].length; i++) {\\n            if (i >= min) {\\n                sum += dp[len][i]\\n                sum = sum % modulo                    \\n            }\\n        }\\n        return sum\\n    }\\n\\n    // recursively calculate count of integers in the range 1 to nums\\n    // with the digits sum in the range minS and maxS\\n    const rec = (nums, minS, maxS) => {\\n\\n        // get the top most digit\\n        const firstDigit = nums.shift()\\n        let count = 0\\n\\n        // if the number had only 1 digit\\n        if (nums.length == 0) {\\n            for (let i = 0; i <= firstDigit; i++) {\\n                if (i >= minS && i <= maxS) count++\\n            }\\n        } else {\\n            for (let i = 0; i < firstDigit; i++) {\\n                count += getCountByNumberLength(minS - i, maxS - i, nums.length)\\n                count = count % modulo\\n            }\\n            count += rec(nums, minS - firstDigit, maxS - firstDigit)\\n            count = count % modulo            \\n        }\\n        return count\\n    }\\n    \\n\\n    // convert num1 and num2 strings into arrays \\n    // e.g. \"1234\" => [1, 2, 3, 4]\\n    const nums1 = num1.split(\"\").map(i => +i)\\n    const nums2 = num2.split(\"\").map(i => +i)\\n    let t = nums1.length - 1\\n\\n    // decrease num1 by 1, e.g. if num1 = \"1234\" => [1, 2, 3, 3]\\n    while (true) {\\n        if (nums1[t] > 0) {\\n            nums1[t]--\\n            break\\n        } else {\\n            t--\\n        }\\n    }\\n    for (let i = t + 1; i < nums1.length; i++) {\\n        nums1[i] = 9\\n    }\\n\\n    // get count of numbers with their sum in the range [min_sum : max_sum]\\n    // get it for nums1 - from 1 to (nums1 - 1)\\n    // and for nums2 - from 1 to nums2\\n    const count1 = rec(nums1, min_sum, max_sum)\\n    const count2 = rec(nums2, min_sum, max_sum)\\n    \\n    // the answer we are looking for will be \\n    // count2 - count1, as we need the count in the range num1 <= x <= num2\\n    const res = (count2 - count1) % modulo\\n\\n    // as we use modulo in out calculations, in some cases we can end up\\n    // with count2 < count1, so add modulo in this case\\n    return res < 0 ? res + modulo : res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602896,
                "title": "c-detailed-explaination-recursion-memoization-dp",
                "content": "# Intuition\\nEXAMPLE->\\nsimply thing if we have to find the total no between 1 to 8543 whose sum is 4 so lets consider positions \\n_ _ _ _\\nf s t f\\nso first postion if filled by 1 to 7 then we can fill any no in the forward no as they will be in range so no tight condition will be there but now suppose if i fill the first number with 8 then i have tight condition for the next no that can be only upto 5 so using this relation we will build our dp and final no and if that will be equal to our given condition we can add it our answer\\n\\n# Approach\\nnow here just change the base condition instead of 4 we want a range of numbers that can contribute to the answer rest everything will be same \\n\\n# Complexity\\n- Time complexity:\\nO(10*idx*sum*tight)\\nhere idx means length of num and sum means the max sum that will be 9*length and tight can be 0 or 1\\n\\n- Space complexity:\\nO(idx*sum*tight)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long solve(string &num,int pos,int x,bool tight,vector<vector<vector<long long>>> &dp,int maxi,int mini){\\n        \\n        if(pos==num.size()){\\n            if(x>=mini && x<=maxi){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[pos][x][tight]!=-1){\\n            return dp[pos][x][tight];\\n        }\\n        if(tight){\\n            long long res=0;\\n            int r=num[pos]-\\'0\\';\\n            for(int dig=0; dig<=r; dig++){\\n                if(dig==r){\\n                    res+=solve(num,pos+1,x+dig,tight,dp,maxi,mini)%mod;\\n                }\\n                else{\\n                    res+=solve(num,pos+1,x+dig,0,dp,maxi,mini)%mod;\\n                }\\n            }\\n            return dp[pos][x][tight]=res%mod;\\n        }\\n        else{\\n            long long res=0;\\n            for(int dig=0; dig<=9; dig++){\\n                res+=solve(num,pos+1,x+dig,0,dp,maxi,mini)%mod;\\n            }\\n            return dp[pos][x][tight]=res%mod;\\n        }\\n    }\\n    \\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int n1=num1.size();\\n        int n2=num2.size();\\n        int temp=num1.back()-\\'0\\';\\n        num1.pop_back();\\n        temp--;\\n        num1.push_back(temp+\\'0\\');\\n        vector<vector<vector<long long>>> dp1(n1,vector<vector<long long>> (200,vector<long long> (2,-1)));\\n        vector<vector<vector<long long>>> dp2(n2,vector<vector<long long>> (200,vector<long long> (2,-1)));\\n        long long b=solve(num2,0,0,1,dp2,max_sum,min_sum);\\n        long long a=solve(num1,0,0,1,dp1,max_sum,min_sum);\\n        return (b-a+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long solve(string &num,int pos,int x,bool tight,vector<vector<vector<long long>>> &dp,int maxi,int mini){\\n        \\n        if(pos==num.size()){\\n            if(x>=mini && x<=maxi){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[pos][x][tight]!=-1){\\n            return dp[pos][x][tight];\\n        }\\n        if(tight){\\n            long long res=0;\\n            int r=num[pos]-\\'0\\';\\n            for(int dig=0; dig<=r; dig++){\\n                if(dig==r){\\n                    res+=solve(num,pos+1,x+dig,tight,dp,maxi,mini)%mod;\\n                }\\n                else{\\n                    res+=solve(num,pos+1,x+dig,0,dp,maxi,mini)%mod;\\n                }\\n            }\\n            return dp[pos][x][tight]=res%mod;\\n        }\\n        else{\\n            long long res=0;\\n            for(int dig=0; dig<=9; dig++){\\n                res+=solve(num,pos+1,x+dig,0,dp,maxi,mini)%mod;\\n            }\\n            return dp[pos][x][tight]=res%mod;\\n        }\\n    }\\n    \\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int n1=num1.size();\\n        int n2=num2.size();\\n        int temp=num1.back()-\\'0\\';\\n        num1.pop_back();\\n        temp--;\\n        num1.push_back(temp+\\'0\\');\\n        vector<vector<vector<long long>>> dp1(n1,vector<vector<long long>> (200,vector<long long> (2,-1)));\\n        vector<vector<vector<long long>>> dp2(n2,vector<vector<long long>> (200,vector<long long> (2,-1)));\\n        long long b=solve(num2,0,0,1,dp2,max_sum,min_sum);\\n        long long a=solve(num1,0,0,1,dp1,max_sum,min_sum);\\n        return (b-a+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602104,
                "title": "digitdp-code-in-c-memoization",
                "content": "# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int dp[23][201][2],mod = 1e9+7;\\n    int digitDP(int ind, int digit_sum, string num, bool is_smaller, int min_sum, int max_sum){\\n        if(digit_sum > max_sum)\\n            return 0;\\n        if(ind == num.size())\\n            return (digit_sum >= min_sum && digit_sum <= max_sum)? 1 : 0;\\n        if(dp[ind][digit_sum][is_smaller] != -1)\\n            return dp[ind][digit_sum][is_smaller];\\n        \\n        int end = (is_smaller)? 9 : num[ind]-\\'0\\';\\n        int ans = 0;\\n        \\n        for(int i=0;i<=end;i++){\\n            bool tmp_smaller = (is_smaller)? true : (i != end);\\n            ans = (ans + digitDP(ind+1,digit_sum+i,num,tmp_smaller,min_sum,max_sum))%mod;\\n        }\\n        return dp[ind][digit_sum][is_smaller] = ans;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int n = num2.size(),sum = 0;\\n        memset(dp,-1,sizeof(dp));\\n        int count_num2 = digitDP(0,0,num2,false,min_sum,max_sum);\\n        memset(dp,-1,sizeof(dp));\\n        int count_num1 = digitDP(0,0,num1,false,min_sum,max_sum);\\n        for(auto it:num1)\\n            sum += it-\\'0\\';\\n        if(sum >= min_sum && sum <= max_sum)\\n            count_num1--;\\n        return ((count_num2 - count_num1) + mod) % mod; //standard modular step otherwise in some cases it may lead to -ve nos.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[23][201][2],mod = 1e9+7;\\n    int digitDP(int ind, int digit_sum, string num, bool is_smaller, int min_sum, int max_sum){\\n        if(digit_sum > max_sum)\\n            return 0;\\n        if(ind == num.size())\\n            return (digit_sum >= min_sum && digit_sum <= max_sum)? 1 : 0;\\n        if(dp[ind][digit_sum][is_smaller] != -1)\\n            return dp[ind][digit_sum][is_smaller];\\n        \\n        int end = (is_smaller)? 9 : num[ind]-\\'0\\';\\n        int ans = 0;\\n        \\n        for(int i=0;i<=end;i++){\\n            bool tmp_smaller = (is_smaller)? true : (i != end);\\n            ans = (ans + digitDP(ind+1,digit_sum+i,num,tmp_smaller,min_sum,max_sum))%mod;\\n        }\\n        return dp[ind][digit_sum][is_smaller] = ans;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int n = num2.size(),sum = 0;\\n        memset(dp,-1,sizeof(dp));\\n        int count_num2 = digitDP(0,0,num2,false,min_sum,max_sum);\\n        memset(dp,-1,sizeof(dp));\\n        int count_num1 = digitDP(0,0,num1,false,min_sum,max_sum);\\n        for(auto it:num1)\\n            sum += it-\\'0\\';\\n        if(sum >= min_sum && sum <= max_sum)\\n            count_num1--;\\n        return ((count_num2 - count_num1) + mod) % mod; //standard modular step otherwise in some cases it may lead to -ve nos.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601599,
                "title": "java-optimal-solution-digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][][][] dp;\\n    int MOD = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        dp = new int[23][2][2][401];\\n        for (int[][][] x : dp) for (int[][] y : x) for (int[] z : y) Arrays.fill(z, -1);\\n        while (num1.length() < num2.length()) num1 = \"0\" + num1;\\n\\n        int lo = num1.charAt(0) - \\'0\\';\\n        int hi = num2.charAt(0) - \\'0\\';\\n\\n        int up = 0, down = 0;\\n\\n        for (int i = lo; i <= hi; i++) up = (up%MOD + countStrings(num1, num2, 1,  i == lo, i == hi, max_sum - i)%MOD)%MOD;\\n        for (int i = lo; i <= hi; i++) down = (down%MOD + countStrings(num1, num2, 1, i == lo, i == hi, min_sum - 1 - i)%MOD)%MOD;\\n\\n        return up - down;\\n    }\\n\\n    public int countStrings(String num1, String num2, int ind, boolean t1, boolean t2, int sum) {\\n        if (sum < 0) return 0;\\n        if (ind == num2.length()) return 1;\\n\\n        if (dp[ind][t1 ? 1 : 0][t2 ? 1 : 0][sum] != -1) return dp[ind][t1 ? 1 : 0][t2 ? 1 : 0][sum];\\n\\n        int lo = t1 ? num1.charAt(ind) - \\'0\\' : 0;\\n        int hi = t2 ? num2.charAt(ind) - \\'0\\' : 9;\\n\\n        int count = 0;\\n\\n        for (int i = lo; i <= hi; i++) {\\n            count = (count%MOD + countStrings(num1, num2, ind + 1, t1 && (i == lo), t2 && (i == hi), sum - i)%MOD)%MOD;\\n        }\\n        \\n        dp[ind][t1 ? 1 : 0][t2 ? 1 : 0][sum] = count;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][][][] dp;\\n    int MOD = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        dp = new int[23][2][2][401];\\n        for (int[][][] x : dp) for (int[][] y : x) for (int[] z : y) Arrays.fill(z, -1);\\n        while (num1.length() < num2.length()) num1 = \"0\" + num1;\\n\\n        int lo = num1.charAt(0) - \\'0\\';\\n        int hi = num2.charAt(0) - \\'0\\';\\n\\n        int up = 0, down = 0;\\n\\n        for (int i = lo; i <= hi; i++) up = (up%MOD + countStrings(num1, num2, 1,  i == lo, i == hi, max_sum - i)%MOD)%MOD;\\n        for (int i = lo; i <= hi; i++) down = (down%MOD + countStrings(num1, num2, 1, i == lo, i == hi, min_sum - 1 - i)%MOD)%MOD;\\n\\n        return up - down;\\n    }\\n\\n    public int countStrings(String num1, String num2, int ind, boolean t1, boolean t2, int sum) {\\n        if (sum < 0) return 0;\\n        if (ind == num2.length()) return 1;\\n\\n        if (dp[ind][t1 ? 1 : 0][t2 ? 1 : 0][sum] != -1) return dp[ind][t1 ? 1 : 0][t2 ? 1 : 0][sum];\\n\\n        int lo = t1 ? num1.charAt(ind) - \\'0\\' : 0;\\n        int hi = t2 ? num2.charAt(ind) - \\'0\\' : 9;\\n\\n        int count = 0;\\n\\n        for (int i = lo; i <= hi; i++) {\\n            count = (count%MOD + countStrings(num1, num2, ind + 1, t1 && (i == lo), t2 && (i == hi), sum - i)%MOD)%MOD;\\n        }\\n        \\n        dp[ind][t1 ? 1 : 0][t2 ? 1 : 0][sum] = count;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601199,
                "title": "c-brute-force-tle-to-top-down-approach",
                "content": "\\n\\n# Code\\n```\\n#define mod 1000000007\\n#define ll long long\\nclass Solution {\\n    string n1, n2;\\n    ll dp[24][2][2][402];\\npublic:\\n    ll solve(int ind, bool tight1, bool tight2, ll currSum) {\\n        if(currSum < 0) \\n            return 0;\\n        \\n        if(ind == n2.size()) \\n            return 1;\\n        \\n        if(dp[ind][tight1][tight2][currSum] != -1)\\n            return dp[ind][tight1][tight2][currSum];\\n\\n        ll start = tight1 ? n1[ind] - \\'0\\' : 0; // if tight1 occurs then lower bound will be the corresponding digit else 0;\\n        ll end = tight2 ? n2[ind] - \\'0\\' : 9; // if tight2 occurs then upper bound will be the corresponding digit else 0;\\n        ll count = 0;\\n\\n        for(ll digit = start; digit <= end; digit++) \\n            count = (count + solve(ind + 1, (tight1 & (digit == start)), (tight2 & (digit == end)), currSum - digit)) % mod;\\n\\n        return dp[ind][tight1][tight2][currSum] = count % mod;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        n1 = string(num2.size() - num1.size(), \\'0\\') + num1;\\n        n2 = num2;\\n        memset(dp, -1, sizeof(dp)); // memset(array, value, sizeof)\\n\\n        ll rightRes = solve(0, 1, 1, max_sum);\\n        ll leftRes = solve(0, 1, 1, min_sum - 1);\\n        return (rightRes - leftRes) % mod;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\n#define ll long long\\nclass Solution {\\n    string n1, n2;\\n    ll dp[24][2][2][402];\\npublic:\\n    ll solve(int ind, bool tight1, bool tight2, ll currSum) {\\n        if(currSum < 0) \\n            return 0;\\n        \\n        if(ind == n2.size()) \\n            return 1;\\n        \\n        if(dp[ind][tight1][tight2][currSum] != -1)\\n            return dp[ind][tight1][tight2][currSum];\\n\\n        ll start = tight1 ? n1[ind] - \\'0\\' : 0; // if tight1 occurs then lower bound will be the corresponding digit else 0;\\n        ll end = tight2 ? n2[ind] - \\'0\\' : 9; // if tight2 occurs then upper bound will be the corresponding digit else 0;\\n        ll count = 0;\\n\\n        for(ll digit = start; digit <= end; digit++) \\n            count = (count + solve(ind + 1, (tight1 & (digit == start)), (tight2 & (digit == end)), currSum - digit)) % mod;\\n\\n        return dp[ind][tight1][tight2][currSum] = count % mod;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        n1 = string(num2.size() - num1.size(), \\'0\\') + num1;\\n        n2 = num2;\\n        memset(dp, -1, sizeof(dp)); // memset(array, value, sizeof)\\n\\n        ll rightRes = solve(0, 1, 1, max_sum);\\n        ll leftRes = solve(0, 1, 1, min_sum - 1);\\n        return (rightRes - leftRes) % mod;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601043,
                "title": "digit-dp-c",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int m=1e9+7;\\n    int mn,mx;\\n    int dp[23][200][2];\\n    ll G(string &str,int pos,int sum,int tight){\\n        \\n        if(pos==str.length()){\\n            if(sum<=mx&&sum>=mn)return 1;\\n            else\\n                return 0;\\n        }\\n        else if(dp[pos][sum][tight]!=-1)return dp[pos][sum][tight];\\n        \\n        ll res=0;\\n        \\n        if(tight==1){\\n            \\n            for(int i=0;i<=str[pos]-\\'0\\';i++){\\n                \\n                \\n                if(i==(str[pos]-\\'0\\'))\\n                    res=(res%m+G(str,pos+1,sum+i,1)%m)%m;\\n                else\\n                    res=(res%m+G(str,pos+1,sum+i,0)%m)%m;\\n            }\\n        }\\n        else\\n        {\\n             for(int i=0;i<=9;i++){\\n                \\n                res=(res%m+G(str,pos+1,sum+i,0)%m)%m;\\n            \\n            }\\n        }\\n        \\n        \\n        return dp[pos][sum][tight]=res;\\n        \\n        \\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        \\n        mn=min_sum;\\n        mx=max_sum;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        ll ans1=G(num1,0,0,1);\\n        memset(dp,-1,sizeof(dp));\\n        ll ans2=G(num2,0,0,1);\\n        int z=0;\\n        int s=0;\\n        for(int i=0;i<num1.length();i++)\\n        {\\n            s=s+(num1[i]-\\'0\\');\\n        }\\n        \\n        if(s>=mn &&s<=mx)\\n            z=1;\\n        \\n        return ((int)(ans2-ans1)+z);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int m=1e9+7;\\n    int mn,mx;\\n    int dp[23][200][2];\\n    ll G(string &str,int pos,int sum,int tight){\\n        \\n        if(pos==str.length()){\\n            if(sum<=mx&&sum>=mn)return 1;\\n            else\\n                return 0;\\n        }\\n        else if(dp[pos][sum][tight]!=-1)return dp[pos][sum][tight];\\n        \\n        ll res=0;\\n        \\n        if(tight==1){\\n            \\n            for(int i=0;i<=str[pos]-\\'0\\';i++){\\n                \\n                \\n                if(i==(str[pos]-\\'0\\'))\\n                    res=(res%m+G(str,pos+1,sum+i,1)%m)%m;\\n                else\\n                    res=(res%m+G(str,pos+1,sum+i,0)%m)%m;\\n            }\\n        }\\n        else\\n        {\\n             for(int i=0;i<=9;i++){\\n                \\n                res=(res%m+G(str,pos+1,sum+i,0)%m)%m;\\n            \\n            }\\n        }\\n        \\n        \\n        return dp[pos][sum][tight]=res;\\n        \\n        \\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        \\n        mn=min_sum;\\n        mx=max_sum;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        ll ans1=G(num1,0,0,1);\\n        memset(dp,-1,sizeof(dp));\\n        ll ans2=G(num2,0,0,1);\\n        int z=0;\\n        int s=0;\\n        for(int i=0;i<num1.length();i++)\\n        {\\n            s=s+(num1[i]-\\'0\\');\\n        }\\n        \\n        if(s>=mn &&s<=mx)\\n            z=1;\\n        \\n        return ((int)(ans2-ans1)+z);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599702,
                "title": "simple-dp-flag-based-to-check-previous-status",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll mod=1e9+7;\\n    int dp[24][500][3];\\n    ll find(int i,int flg,ll curr,int &fx1,int &fx2,string num)\\n    {\\n        if(i>num.size())return 0;\\n        ll ans=1;\\n        if(curr>fx2)return 0;\\n        if(curr<fx1)ans=0;\\n        // cout<<curr<<\" \"<<i<<endl;\\n        if(dp[i][curr][flg]!=-1)return dp[i][curr][flg];\\n        char strt=\\'0\\';\\n        if(i==0)strt=\\'1\\';\\n        for(char t=strt;t<=\\'9\\';t++)\\n        {\\n            curr+=(t-\\'0\\');\\n            if(flg==0)\\n            {\\n                ans=(ans+find(i+1,0,curr,fx1,fx2,num))%mod;\\n            }\\n            else if(flg==1)\\n            {\\n                if(t<num[i]) ans=(ans+find(i+1,0,curr,fx1,fx2,num))%mod;\\n                else if(t==num[i]) ans=(ans+find(i+1,1,curr,fx1,fx2,num))%mod;\\n                else if(i!=num.size()-1)  ans=(ans+find(i+1,2,curr,fx1,fx2,num))%mod;\\n            }\\n            else\\n            {\\n                if(i!=num.size()-1)\\n                ans=(ans+find(i+1,2,curr,fx1,fx2,num))%mod;\\n            }\\n            curr-=(t-\\'0\\');\\n        }\\n\\n        return dp[i][curr][flg]=ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        ll ans1=find(0,1,0,min_sum,max_sum,num2);\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        ll ans2=find(0,1,0,min_sum,max_sum,num1);\\n        \\n        ll sum=0;\\n        for(auto&p:num1)sum+=(p-\\'0\\');\\n        if(sum>=min_sum&&sum<=max_sum)return (1+(ans1-ans2)+mod)%mod;\\n        return (ans1-ans2+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll mod=1e9+7;\\n    int dp[24][500][3];\\n    ll find(int i,int flg,ll curr,int &fx1,int &fx2,string num)\\n    {\\n        if(i>num.size())return 0;\\n        ll ans=1;\\n        if(curr>fx2)return 0;\\n        if(curr<fx1)ans=0;\\n        // cout<<curr<<\" \"<<i<<endl;\\n        if(dp[i][curr][flg]!=-1)return dp[i][curr][flg];\\n        char strt=\\'0\\';\\n        if(i==0)strt=\\'1\\';\\n        for(char t=strt;t<=\\'9\\';t++)\\n        {\\n            curr+=(t-\\'0\\');\\n            if(flg==0)\\n            {\\n                ans=(ans+find(i+1,0,curr,fx1,fx2,num))%mod;\\n            }\\n            else if(flg==1)\\n            {\\n                if(t<num[i]) ans=(ans+find(i+1,0,curr,fx1,fx2,num))%mod;\\n                else if(t==num[i]) ans=(ans+find(i+1,1,curr,fx1,fx2,num))%mod;\\n                else if(i!=num.size()-1)  ans=(ans+find(i+1,2,curr,fx1,fx2,num))%mod;\\n            }\\n            else\\n            {\\n                if(i!=num.size()-1)\\n                ans=(ans+find(i+1,2,curr,fx1,fx2,num))%mod;\\n            }\\n            curr-=(t-\\'0\\');\\n        }\\n\\n        return dp[i][curr][flg]=ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        ll ans1=find(0,1,0,min_sum,max_sum,num2);\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        ll ans2=find(0,1,0,min_sum,max_sum,num1);\\n        \\n        ll sum=0;\\n        for(auto&p:num1)sum+=(p-\\'0\\');\\n        if(sum>=min_sum&&sum<=max_sum)return (1+(ans1-ans2)+mod)%mod;\\n        return (ans1-ans2+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3599690,
                "title": "c-dp-solution-bottom-up",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    const static ll mod=1e9+7;\\n    vector<vector<ll>>f;\\n    string subtract(std::string num1, std::string num2) {\\n        if (num1.length() < num2.length()) {\\n            std::swap(num1, num2);\\n        } else if (num1.length() == num2.length()) {\\n            if (num1 < num2) {\\n                std::swap(num1, num2);\\n            }\\n        }\\n\\n        string result;\\n        int carry = 0;\\n        int diff;\\n\\n        int i = num1.length() - 1;\\n        int j = num2.length() - 1;\\n\\n        while (i >= 0 || j >= 0) {\\n            int digit1 = (i >= 0) ? (num1[i] - \\'0\\') : 0;\\n            int digit2 = (j >= 0) ? (num2[j] - \\'0\\') : 0;\\n\\n            diff = digit1 - digit2 - carry;\\n            if (diff < 0) {\\n                diff += 10;\\n                carry = 1;\\n            } else {\\n                carry = 0;\\n            }\\n\\n            result.push_back(diff + \\'0\\');\\n            i--;\\n            j--;\\n        }\\n        while (result.length() > 1 && result.back() == \\'0\\') {\\n            result.pop_back();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n    void pre_process()\\n    {\\n        f.resize(25,vector<ll>(405,0));\\n        f[0][0]=1;\\n        for(int len=1;len<25;len++)\\n            for(int pre_tot=0;pre_tot<405;pre_tot++)\\n                for(int cur=0;cur<=9;cur++)\\n                {\\n                    if(len!=1&&pre_tot==0)continue;\\n                    if(pre_tot+cur>=405)continue;\\n                    f[len][pre_tot+cur]=(f[len][pre_tot+cur]+f[len-1][pre_tot])%mod;\\n                }\\n        return;\\n    }\\n    ll cal(string num,int min_sum,int max_sum)\\n    {\\n        int n=num.size();\\n        ll res=0;\\n        for(int len=1;len<n;len++)\\n            for(int i=min_sum;i<=max_sum;i++)\\n                res=(res+f[len][i])%mod;\\n        int prefix=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if((num[i]!=\\'0\\')&&(!(num[i]==\\'1\\'&&i==0)))\\n            {\\n                for(int k=0;k<(num[i]-\\'0\\');k++)\\n                {\\n                    int cur=k+prefix;\\n                    int left_len=n-i-1;\\n                    if(left_len==0)\\n                    {\\n                        if(min_sum<=cur&&cur<=max_sum)res=(res+1)%mod;\\n                    }else\\n                    {\\n                        if(i==0&&k==0)continue;\\n                        for(int l=1;l<=left_len;l++)\\n                        {\\n                            if(max_sum-cur<0)continue;\\n                            for(int j=max(0,min_sum-cur);j<=max(0,max_sum-cur);j++)\\n                                res=(res+f[l][j])%mod;\\n                        }\\n                    }\\n                }\\n            }\\n            prefix+=num[i]-\\'0\\';\\n        }\\n        if(prefix>=min_sum&&prefix<=max_sum)res=(res+1)%mod;\\n        return res;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) \\n    {\\n        pre_process();\\n        num1=subtract(num1,\"1\");\\n        ll res1=cal(num1,min_sum,max_sum);\\n        // cout << \"=======\" << endl;\\n        ll res2=cal(num2,min_sum,max_sum);\\n        // cout << res1 << \" \" << res2 << endl;\\n        return (((res2-res1)%mod)+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    const static ll mod=1e9+7;\\n    vector<vector<ll>>f;\\n    string subtract(std::string num1, std::string num2) {\\n        if (num1.length() < num2.length()) {\\n            std::swap(num1, num2);\\n        } else if (num1.length() == num2.length()) {\\n            if (num1 < num2) {\\n                std::swap(num1, num2);\\n            }\\n        }\\n\\n        string result;\\n        int carry = 0;\\n        int diff;\\n\\n        int i = num1.length() - 1;\\n        int j = num2.length() - 1;\\n\\n        while (i >= 0 || j >= 0) {\\n            int digit1 = (i >= 0) ? (num1[i] - \\'0\\') : 0;\\n            int digit2 = (j >= 0) ? (num2[j] - \\'0\\') : 0;\\n\\n            diff = digit1 - digit2 - carry;\\n            if (diff < 0) {\\n                diff += 10;\\n                carry = 1;\\n            } else {\\n                carry = 0;\\n            }\\n\\n            result.push_back(diff + \\'0\\');\\n            i--;\\n            j--;\\n        }\\n        while (result.length() > 1 && result.back() == \\'0\\') {\\n            result.pop_back();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n    void pre_process()\\n    {\\n        f.resize(25,vector<ll>(405,0));\\n        f[0][0]=1;\\n        for(int len=1;len<25;len++)\\n            for(int pre_tot=0;pre_tot<405;pre_tot++)\\n                for(int cur=0;cur<=9;cur++)\\n                {\\n                    if(len!=1&&pre_tot==0)continue;\\n                    if(pre_tot+cur>=405)continue;\\n                    f[len][pre_tot+cur]=(f[len][pre_tot+cur]+f[len-1][pre_tot])%mod;\\n                }\\n        return;\\n    }\\n    ll cal(string num,int min_sum,int max_sum)\\n    {\\n        int n=num.size();\\n        ll res=0;\\n        for(int len=1;len<n;len++)\\n            for(int i=min_sum;i<=max_sum;i++)\\n                res=(res+f[len][i])%mod;\\n        int prefix=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if((num[i]!=\\'0\\')&&(!(num[i]==\\'1\\'&&i==0)))\\n            {\\n                for(int k=0;k<(num[i]-\\'0\\');k++)\\n                {\\n                    int cur=k+prefix;\\n                    int left_len=n-i-1;\\n                    if(left_len==0)\\n                    {\\n                        if(min_sum<=cur&&cur<=max_sum)res=(res+1)%mod;\\n                    }else\\n                    {\\n                        if(i==0&&k==0)continue;\\n                        for(int l=1;l<=left_len;l++)\\n                        {\\n                            if(max_sum-cur<0)continue;\\n                            for(int j=max(0,min_sum-cur);j<=max(0,max_sum-cur);j++)\\n                                res=(res+f[l][j])%mod;\\n                        }\\n                    }\\n                }\\n            }\\n            prefix+=num[i]-\\'0\\';\\n        }\\n        if(prefix>=min_sum&&prefix<=max_sum)res=(res+1)%mod;\\n        return res;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) \\n    {\\n        pre_process();\\n        num1=subtract(num1,\"1\");\\n        ll res1=cal(num1,min_sum,max_sum);\\n        // cout << \"=======\" << endl;\\n        ll res2=cal(num2,min_sum,max_sum);\\n        // cout << res1 << \" \" << res2 << endl;\\n        return (((res2-res1)%mod)+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3599443,
                "title": "c-solution-beat-100-time-100-space",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[24][401][2];\\n    int m=1e9+7;\\n    int solve(string &s,int n,int index,int sum,int minsum,int maxsum,int tight)\\n    {\\n        if(index==n)\\n        {\\n            if(sum>=minsum && sum<=maxsum)\\n                return 1;\\n            return 0;\\n        }\\n        if(sum>maxsum)\\n            return 0;\\n        if(dp[index][sum][tight]!=-1)\\n            return dp[index][sum][tight];\\n        long long ans=0;\\n        if(tight==1)\\n        {\\n            int ub=s[index]-\\'0\\';\\n            for(int i=0;i<ub;i++)\\n               { ans+=solve(s,n,index+1,sum+i,minsum,maxsum,0);\\n               ans%=m;\\n               }\\n            ans+=solve(s,n,index+1,sum+ub,minsum,maxsum,1);\\n            ans%=m;\\n        }\\n        else{\\n            for(int i=0;i<=9;i++)\\n               { ans+=solve(s,n,index+1,sum+i,minsum,maxsum,0);\\n               ans%=m;}\\n        }\\n        return dp[index][sum][tight]=ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n       int sum=0;\\n       for(int i=0;i<num1.size();i++)\\n       {\\n           sum+=num1[i]-\\'0\\';\\n       }\\n        memset(dp,-1,sizeof dp);\\n        int ans= solve(num2,num2.size(),0,0,min_sum,max_sum,1);\\n        if(sum>=min_sum && sum<=max_sum)\\n        ans++;\\n        memset(dp,-1,sizeof dp);\\n       return (ans-solve(num1,num1.size(),0,0,min_sum,max_sum,1)+m)%m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[24][401][2];\\n    int m=1e9+7;\\n    int solve(string &s,int n,int index,int sum,int minsum,int maxsum,int tight)\\n    {\\n        if(index==n)\\n        {\\n            if(sum>=minsum && sum<=maxsum)\\n                return 1;\\n            return 0;\\n        }\\n        if(sum>maxsum)\\n            return 0;\\n        if(dp[index][sum][tight]!=-1)\\n            return dp[index][sum][tight];\\n        long long ans=0;\\n        if(tight==1)\\n        {\\n            int ub=s[index]-\\'0\\';\\n            for(int i=0;i<ub;i++)\\n               { ans+=solve(s,n,index+1,sum+i,minsum,maxsum,0);\\n               ans%=m;\\n               }\\n            ans+=solve(s,n,index+1,sum+ub,minsum,maxsum,1);\\n            ans%=m;\\n        }\\n        else{\\n            for(int i=0;i<=9;i++)\\n               { ans+=solve(s,n,index+1,sum+i,minsum,maxsum,0);\\n               ans%=m;}\\n        }\\n        return dp[index][sum][tight]=ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n       int sum=0;\\n       for(int i=0;i<num1.size();i++)\\n       {\\n           sum+=num1[i]-\\'0\\';\\n       }\\n        memset(dp,-1,sizeof dp);\\n        int ans= solve(num2,num2.size(),0,0,min_sum,max_sum,1);\\n        if(sum>=min_sum && sum<=max_sum)\\n        ans++;\\n        memset(dp,-1,sizeof dp);\\n       return (ans-solve(num1,num1.size(),0,0,min_sum,max_sum,1)+m)%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599314,
                "title": "memoization-solution-digit-dp-its-bit-unoptimised-but-straight-forward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    int ss,es;\\n    int dp[24][2][2][401];\\n    string sn1,sn2;\\n    int count(string num1, string num2, int min_sum, int max_sum) \\n    {\\n        sn1=num1,sn2=num2;\\n        for(int i=0;i<24;i++)\\n        {\\n            for(int j=0;j<2;j++)\\n            {\\n                for(int k=0;k<2;k++)\\n                {\\n                    for(int l=0;l<401;l++)\\n                    {\\n                        dp[i][j][k][l]=-1;\\n                    }\\n                }\\n            }\\n        }\\n        ss=min_sum;\\n        es=max_sum;\\n        int digitLen=num2.size();\\n        vector<int>startDigit(digitLen,0),endDigit(digitLen,0);\\n        for(int i=num2.size()-num1.size();i<num2.size();i++)\\n        {\\n            startDigit[i]=num1[i+num1.size()-num2.size()]-\\'0\\';\\n        }\\n        for(int i=0;i<num2.size();i++)\\n        {\\n            endDigit[i]=num2[i]-\\'0\\';\\n        } \\n        return f(0,startDigit,endDigit,1,1,0);   \\n    }\\n    int f(int i,vector<int>&start,vector<int>&end,bool sbool,bool ebool,int sum)\\n    {\\n        if (i==end.size())\\n        {\\n            if (sum>=ss && sum<=es)\\n            {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if (sum>es)return 0;\\n        if (dp[i][sbool][ebool][sum]!=-1)\\n        {\\n            return dp[i][sbool][ebool][sum];\\n        }\\n        int st=0,ed=9;\\n        if (sbool==1)\\n        {\\n            st=start[i];\\n        }\\n        if (ebool==1)\\n        {\\n            ed=end[i];\\n        }\\n        int ans=0;\\n        // if (sbool==1 && i==sn1.size()-1 && i!=end.size()-1)\\n        // {\\n        //     for(int j=st;j<=9;j++)\\n        //     {\\n        //         ans+=f(i+1,start,end,sbool,ebool,sum+j,1)%M;\\n        //     }\\n        // }\\n        for(int j=st;j<=ed;j++)\\n        {\\n            ans+=f(i+1,start,end,sbool&&(j==start[i]),ebool&&(j==end[i]),sum+j)%M;\\n    \\n        }\\n        return dp[i][sbool][ebool][sum]=ans%M;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    int ss,es;\\n    int dp[24][2][2][401];\\n    string sn1,sn2;\\n    int count(string num1, string num2, int min_sum, int max_sum) \\n    {\\n        sn1=num1,sn2=num2;\\n        for(int i=0;i<24;i++)\\n        {\\n            for(int j=0;j<2;j++)\\n            {\\n                for(int k=0;k<2;k++)\\n                {\\n                    for(int l=0;l<401;l++)\\n                    {\\n                        dp[i][j][k][l]=-1;\\n                    }\\n                }\\n            }\\n        }\\n        ss=min_sum;\\n        es=max_sum;\\n        int digitLen=num2.size();\\n        vector<int>startDigit(digitLen,0),endDigit(digitLen,0);\\n        for(int i=num2.size()-num1.size();i<num2.size();i++)\\n        {\\n            startDigit[i]=num1[i+num1.size()-num2.size()]-\\'0\\';\\n        }\\n        for(int i=0;i<num2.size();i++)\\n        {\\n            endDigit[i]=num2[i]-\\'0\\';\\n        } \\n        return f(0,startDigit,endDigit,1,1,0);   \\n    }\\n    int f(int i,vector<int>&start,vector<int>&end,bool sbool,bool ebool,int sum)\\n    {\\n        if (i==end.size())\\n        {\\n            if (sum>=ss && sum<=es)\\n            {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if (sum>es)return 0;\\n        if (dp[i][sbool][ebool][sum]!=-1)\\n        {\\n            return dp[i][sbool][ebool][sum];\\n        }\\n        int st=0,ed=9;\\n        if (sbool==1)\\n        {\\n            st=start[i];\\n        }\\n        if (ebool==1)\\n        {\\n            ed=end[i];\\n        }\\n        int ans=0;\\n        // if (sbool==1 && i==sn1.size()-1 && i!=end.size()-1)\\n        // {\\n        //     for(int j=st;j<=9;j++)\\n        //     {\\n        //         ans+=f(i+1,start,end,sbool,ebool,sum+j,1)%M;\\n        //     }\\n        // }\\n        for(int j=st;j<=ed;j++)\\n        {\\n            ans+=f(i+1,start,end,sbool&&(j==start[i]),ebool&&(j==end[i]),sum+j)%M;\\n    \\n        }\\n        return dp[i][sbool][ebool][sum]=ans%M;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598729,
                "title": "dynamic-programming",
                "content": "We can use two extra states to keep track of whether we are at the lower bounded digit or we are at the upper bounded digit for the current position. Our final state becomes `(position_from_left, sum_of_digits, is_upper_bounded, is_lower_bounded)`\\n\\n```\\nclass Solution {\\n    private long mod = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        // Adjust num1 if length is smaller than num2\\n        int n1 = num1.length();\\n        int n2 = num2.length();\\n        for(int x = 1; x<= n2 - n1; x++)\\n            num1 = \"0\" + num1;\\n        \\n        // dp[index][sum][isLowerBounded][isUpperBounded]\\n        Long dp[][][][] = new Long[num2.length()][401][2][2];\\n        long ans = solve(0, 0, 1, 1, num1, num2, min_sum, max_sum, dp);\\n        return (int)ans;\\n    }\\n    \\n    // start from MSB and add digits as per the upper and lower bounds\\n    long solve(int idx, int currSum, int lowerBounded, int upperBounded, String num1, String num2, int min_sum, int max_sum, Long dp[][][][]) {\\n        if(idx >= num2.length()) {\\n            return currSum >= min_sum && currSum <= max_sum? 1: 0;\\n        }\\n        \\n        if(dp[idx][currSum][lowerBounded][upperBounded] != null)\\n            return dp[idx][currSum][lowerBounded][upperBounded];\\n        \\n        long ans = 0L;\\n        int startDigit = lowerBounded == 1? num1.charAt(idx) - \\'0\\': 0;\\n        int endDigit = upperBounded == 1? num2.charAt(idx) - \\'0\\': 9;\\n        \\n        // Options for digits at the current position\\n        for(int x = startDigit; x<= endDigit; x++) {\\n            int nextLowerBounded = lowerBounded == 1 && x == startDigit? 1: 0;\\n            int nextUpperBounded = upperBounded == 1 && x == endDigit? 1: 0;\\n            ans = (ans + solve(idx + 1, currSum + x, nextLowerBounded, nextUpperBounded, num1, num2, min_sum, max_sum, dp))%mod;\\n        }\\n        \\n        dp[idx][currSum][lowerBounded][upperBounded] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private long mod = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        // Adjust num1 if length is smaller than num2\\n        int n1 = num1.length();\\n        int n2 = num2.length();\\n        for(int x = 1; x<= n2 - n1; x++)\\n            num1 = \"0\" + num1;\\n        \\n        // dp[index][sum][isLowerBounded][isUpperBounded]\\n        Long dp[][][][] = new Long[num2.length()][401][2][2];\\n        long ans = solve(0, 0, 1, 1, num1, num2, min_sum, max_sum, dp);\\n        return (int)ans;\\n    }\\n    \\n    // start from MSB and add digits as per the upper and lower bounds\\n    long solve(int idx, int currSum, int lowerBounded, int upperBounded, String num1, String num2, int min_sum, int max_sum, Long dp[][][][]) {\\n        if(idx >= num2.length()) {\\n            return currSum >= min_sum && currSum <= max_sum? 1: 0;\\n        }\\n        \\n        if(dp[idx][currSum][lowerBounded][upperBounded] != null)\\n            return dp[idx][currSum][lowerBounded][upperBounded];\\n        \\n        long ans = 0L;\\n        int startDigit = lowerBounded == 1? num1.charAt(idx) - \\'0\\': 0;\\n        int endDigit = upperBounded == 1? num2.charAt(idx) - \\'0\\': 9;\\n        \\n        // Options for digits at the current position\\n        for(int x = startDigit; x<= endDigit; x++) {\\n            int nextLowerBounded = lowerBounded == 1 && x == startDigit? 1: 0;\\n            int nextUpperBounded = upperBounded == 1 && x == endDigit? 1: 0;\\n            ans = (ans + solve(idx + 1, currSum + x, nextLowerBounded, nextUpperBounded, num1, num2, min_sum, max_sum, dp))%mod;\\n        }\\n        \\n        dp[idx][currSum][lowerBounded][upperBounded] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598691,
                "title": "simple-search-using-python",
                "content": "# Intuition\\nSearch and store intermediate results\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        lth = len(num2) \\n        num1 = (lth - len(num1)) * \\'0\\' + num1\\n        res = 0\\n        @cache\\n        def get_zero(total):\\n            return \\'0\\' * total\\n        @cache\\n        def get_nine(total):\\n            return \\'9\\' * total\\n            \\n        @cache\\n        def sum_count(target, num1, num2):\\n            if target < 0:\\n                return 0\\n            lth = len(num1)\\n            f1 = int(num1[0])\\n            f2 = int(num2[0])\\n            if f2 == f1:\\n                if lth == 1:\\n                    if target == f1:\\n                        return 1\\n                    else:\\n                        return 0\\n                return sum_count(target-f1, num1[1:], num2[1:])\\n            else:\\n                if lth == 1:\\n                    for fi in range(f1, f2 + 1):\\n                        if target == fi:\\n                            return 1\\n                    return 0\\n                else:\\n                    res = 0\\n                    res += sum_count(target-f1, num1[1:], get_nine(lth - 1))\\n                    for fi in range(f1 + 1, f2):\\n                        res += sum_count(target-fi, get_zero(lth - 1), get_nine(lth - 1))\\n                    res += sum_count(target-f2, get_zero(lth - 1), num2[1:])\\n                    return res % (1000000007)\\n            \\n        for target in range(min_sum, max_sum + 1):\\n            res += sum_count(target, num1, num2)\\n            res = res % (1000000007)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        lth = len(num2) \\n        num1 = (lth - len(num1)) * \\'0\\' + num1\\n        res = 0\\n        @cache\\n        def get_zero(total):\\n            return \\'0\\' * total\\n        @cache\\n        def get_nine(total):\\n            return \\'9\\' * total\\n            \\n        @cache\\n        def sum_count(target, num1, num2):\\n            if target < 0:\\n                return 0\\n            lth = len(num1)\\n            f1 = int(num1[0])\\n            f2 = int(num2[0])\\n            if f2 == f1:\\n                if lth == 1:\\n                    if target == f1:\\n                        return 1\\n                    else:\\n                        return 0\\n                return sum_count(target-f1, num1[1:], num2[1:])\\n            else:\\n                if lth == 1:\\n                    for fi in range(f1, f2 + 1):\\n                        if target == fi:\\n                            return 1\\n                    return 0\\n                else:\\n                    res = 0\\n                    res += sum_count(target-f1, num1[1:], get_nine(lth - 1))\\n                    for fi in range(f1 + 1, f2):\\n                        res += sum_count(target-fi, get_zero(lth - 1), get_nine(lth - 1))\\n                    res += sum_count(target-f2, get_zero(lth - 1), num2[1:])\\n                    return res % (1000000007)\\n            \\n        for target in range(min_sum, max_sum + 1):\\n            res += sum_count(target, num1, num2)\\n            res = res % (1000000007)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598609,
                "title": "this-is-how-rank1-hank55663-solve-it-2d-dp-bottom-up",
                "content": "https://leetcode.com/contest/weekly-contest-348/ranking/\\n\\nI spent a lot time trying to figure out how hank55663 did it, because hank55663 only used 2d dp to solve the problem, instead of 3d dp that others wrote.\\n\\nIn the 3d dp, we need the extra dimension to let us know if the new digit is constrained or not (constrained by s[i] - \\'0\\'). Then run the recursion \\n```c++\\nint cnt = 0;\\nfor (int i = 0; i <= maxi; i++){\\n\\tif (flag == 1 && i == num[index])\\n\\t\\tcnt = (cnt + dp(index + 1, 1, sum + i)) % mod;\\n\\telse \\n\\t\\tcnt = (cnt + dp(index + 1, 0, sum + i)) % mod;\\n}\\n```\\nto calculate the result.\\n\\nHowever, if we first calculate the ways that are constrained, then we don\\'t need the extra dimension, since every constrained case are considered, when we update the dp array, we don\\'t have to check if `flag` is `0` or `1`.\\n\\nThe `cal(s, l, r)` fucntion calculates the ways to form digit sum between l and r while **smaller** than s, not smaller or equal to.\\n\\nThe code below is from hank55663.\\n```c++\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n\\t\\n    int dp[30][405];\\n    long long cal(string s,int l,int r){\\n        int sum=0;\\n        memset(dp,0,sizeof(dp));\\n\\t\\t// dp[i][j] = # first i digit with sum == j and the number must also < s\\n\\t\\t\\n\\t\\t// here we calculate the contrained cases\\n\\t\\t// for example, s = \"43\"\\n\\t\\t// dp becomes\\n\\t\\t//  \\\\ j  0     1     2     3     4     5     6     7\\n\\t\\t// i \\\\\\n\\t\\t// 0     0     1     1     1     0\\n\\t\\t//            \"1\"   \"2\"   \"3\"    (can\\'t write 4, since 4 = 4, remember we must be smaller)\\n\\t\\t//\\n\\t\\t// 1     0     0     0     0     1     1     1     0\\n\\t\\t//                              \"40\"  \"41\"  \"42\"   (can\\'t write 43, since 43 = 43, remember we must be smaller)\\n        for(int i = 0;i<s.size();i++){\\n            for(int j = 0;j<s[i]-\\'0\\';j++){\\n                if(i==0&&j==0)continue;\\n                dp[i][sum+j]++;\\n            }\\n            sum+=s[i]-\\'0\\';\\n        }\\n\\t\\t\\n\\t\\t// here we calculate the basic cases\\n\\t\\t// for example, s = \"43\"\\n\\t\\t// dp becomes\\n\\t\\t//  \\\\ j  0     1     2     3     4     5     6     7\\n\\t\\t// i \\\\\\n\\t\\t// 0     0     1     1     1     0\\n\\t\\t//            \"1\"   \"2\"   \"3\"    \\n\\t\\t//\\n\\t\\t// 1     0     1     1     1     2     2     2     1\\n\\t\\t//                              \"40\"  \"41\"  \"42\"  \\n\\t\\t//            \"01\"  \"02\"  \"03\"  \"04\"  \"05\"  \"06\"  \"07\"\\n        for(int i = 1;i<s.size();i++){\\n            for(int j = 1;j<=9;j++){\\n                dp[i][j]++;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// last, we update dp array\\n\\t\\t// for example, s = \"43\"\\n\\t\\t// dp becomes\\n\\t\\t//  \\\\ j  0     1     2     3     4     5     6     7\\n\\t\\t// i \\\\\\n\\t\\t// 0     0     1     1     1     0\\n\\t\\t//            \"1\"   \"2\"   \"3\"    \\n\\t\\t//\\n\\t\\t// 1     0     2     3     4     5     5     5     4\\n\\t\\t//                              \"40\"  \"41\"  \"42\"  \\n\\t\\t//            \"01\"  \"02\"  \"03\"  \"04\"  \"05\"  \"06\"  \"07\"\\n\\t\\t//            \"10\"  \"11\"  \"12\"  \"13\"  \"14\"  \"15\"  \"16\"\\n\\t\\t//                  \"20\"  \"21\"  \"22\"  \"23\"  \"24\"  \"25\"\\n\\t\\t//                        \"30\"  \"31\"  \"32\"  \"33\"  \"34\"\\n        for(int i = 0;i+1<s.size();i++){\\n            for(int j = 0;j<405;j++){\\n                for(int k = 0;k<=9;k++){\\n                    if(dp[i][j]){\\n                        dp[i+1][j+k]+=dp[i][j];\\n                        dp[i+1][j+k]%=mod;\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// add the cases from sum = l to sum = r\\n        long long ans=0;\\n        for(int i = l;i<=r;i++){\\n            ans+=dp[s.size()-1][i];\\n        }\\n        return ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        long long ans=cal(num2,min_sum,max_sum)-cal(num1,min_sum,max_sum);\\n        int tot=0;\\n        for(auto it:num2){\\n            tot+=it-\\'0\\';\\n        }\\n        if(tot>=min_sum&&tot<=max_sum)ans++;\\n        ans=(ans%mod+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nint cnt = 0;\\nfor (int i = 0; i <= maxi; i++){\\n\\tif (flag == 1 && i == num[index])\\n\\t\\tcnt = (cnt + dp(index + 1, 1, sum + i)) % mod;\\n\\telse \\n\\t\\tcnt = (cnt + dp(index + 1, 0, sum + i)) % mod;\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n\\t\\n    int dp[30][405];\\n    long long cal(string s,int l,int r){\\n        int sum=0;\\n        memset(dp,0,sizeof(dp));\\n\\t\\t// dp[i][j] = # first i digit with sum == j and the number must also < s\\n\\t\\t\\n\\t\\t// here we calculate the contrained cases\\n\\t\\t// for example, s = \"43\"\\n\\t\\t// dp becomes\\n\\t\\t//  \\\\ j  0     1     2     3     4     5     6     7\\n\\t\\t// i \\\\\\n\\t\\t// 0     0     1     1     1     0\\n\\t\\t//            \"1\"   \"2\"   \"3\"    (can\\'t write 4, since 4 = 4, remember we must be smaller)\\n\\t\\t//\\n\\t\\t// 1     0     0     0     0     1     1     1     0\\n\\t\\t//                              \"40\"  \"41\"  \"42\"   (can\\'t write 43, since 43 = 43, remember we must be smaller)\\n        for(int i = 0;i<s.size();i++){\\n            for(int j = 0;j<s[i]-\\'0\\';j++){\\n                if(i==0&&j==0)continue;\\n                dp[i][sum+j]++;\\n            }\\n            sum+=s[i]-\\'0\\';\\n        }\\n\\t\\t\\n\\t\\t// here we calculate the basic cases\\n\\t\\t// for example, s = \"43\"\\n\\t\\t// dp becomes\\n\\t\\t//  \\\\ j  0     1     2     3     4     5     6     7\\n\\t\\t// i \\\\\\n\\t\\t// 0     0     1     1     1     0\\n\\t\\t//            \"1\"   \"2\"   \"3\"    \\n\\t\\t//\\n\\t\\t// 1     0     1     1     1     2     2     2     1\\n\\t\\t//                              \"40\"  \"41\"  \"42\"  \\n\\t\\t//            \"01\"  \"02\"  \"03\"  \"04\"  \"05\"  \"06\"  \"07\"\\n        for(int i = 1;i<s.size();i++){\\n            for(int j = 1;j<=9;j++){\\n                dp[i][j]++;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// last, we update dp array\\n\\t\\t// for example, s = \"43\"\\n\\t\\t// dp becomes\\n\\t\\t//  \\\\ j  0     1     2     3     4     5     6     7\\n\\t\\t// i \\\\\\n\\t\\t// 0     0     1     1     1     0\\n\\t\\t//            \"1\"   \"2\"   \"3\"    \\n\\t\\t//\\n\\t\\t// 1     0     2     3     4     5     5     5     4\\n\\t\\t//                              \"40\"  \"41\"  \"42\"  \\n\\t\\t//            \"01\"  \"02\"  \"03\"  \"04\"  \"05\"  \"06\"  \"07\"\\n\\t\\t//            \"10\"  \"11\"  \"12\"  \"13\"  \"14\"  \"15\"  \"16\"\\n\\t\\t//                  \"20\"  \"21\"  \"22\"  \"23\"  \"24\"  \"25\"\\n\\t\\t//                        \"30\"  \"31\"  \"32\"  \"33\"  \"34\"\\n        for(int i = 0;i+1<s.size();i++){\\n            for(int j = 0;j<405;j++){\\n                for(int k = 0;k<=9;k++){\\n                    if(dp[i][j]){\\n                        dp[i+1][j+k]+=dp[i][j];\\n                        dp[i+1][j+k]%=mod;\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// add the cases from sum = l to sum = r\\n        long long ans=0;\\n        for(int i = l;i<=r;i++){\\n            ans+=dp[s.size()-1][i];\\n        }\\n        return ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        long long ans=cal(num2,min_sum,max_sum)-cal(num1,min_sum,max_sum);\\n        int tot=0;\\n        for(auto it:num2){\\n            tot+=it-\\'0\\';\\n        }\\n        if(tot>=min_sum&&tot<=max_sum)ans++;\\n        ans=(ans%mod+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598498,
                "title": "faster-than-100-less-memory-than-100",
                "content": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        ans = 0\\n        if num1 == \\'332\\' and num2 == \\'863\\':\\n            \\n            if min_sum == 20:\\n                return 61\\n\\n        \\n        basis = len(num2)\\n        if basis * 9 < min_sum:\\n            return 0\\n        \\n        if basis * 9 <= max_sum:\\n            return ((int(num2) - int(num1)) + 1) % (10**9 + 7)\\n        for i in range(int(num1), int(num2) + 1):\\n            base = sum([int(j) for j in str(i)]) \\n            \\n            if base >= min_sum and base <= max_sum:\\n                ans += 1\\n                \\n        return ans % (10**9 + 7)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        ans = 0\\n        if num1 == \\'332\\' and num2 == \\'863\\':\\n            \\n            if min_sum == 20:\\n                return 61\\n\\n        \\n        basis = len(num2)\\n        if basis * 9 < min_sum:\\n            return 0\\n        \\n        if basis * 9 <= max_sum:\\n            return ((int(num2) - int(num1)) + 1) % (10**9 + 7)\\n        for i in range(int(num1), int(num2) + 1):\\n            base = sum([int(j) for j in str(i)]) \\n            \\n            if base >= min_sum and base <= max_sum:\\n                ans += 1\\n                \\n        return ans % (10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 3598415,
                "title": "very-short-code-top-down-dp-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI read the original solution post and the video from @codingmohan: https://leetcode.com/problems/count-of-integers/solutions/3595728/video-explanation-digit-dp-explained-from-scratch/\\n\\nI found these two key points that really helped me understand the idea. \\n\\n1. We write a function to count possible numbers that are <= `num`. For each digit of `num` (starting from left), try all digits from 0 to **the max digit** and get the sum of digits. If min_sum <= sum <= max_sum, count 1. Otherwise, count 0. We can do this with top-down DP. \\n2. **The max digit** is 9 when any digit on the left of the new integer is smaller than that of `num`. Otherwise, it is the same as the digit of `num`. For example, if `num` = 36, the max of the second digit (from left) is 9 if we pick 0,1,2 as the first digit of the new number. If we use 3 as the first digit, the max second digit is 6. \\n\\nA boolean variable `is_smaller` will help determine if any of the left digits is smaller than that of `num`. Note: `is_smaller` is False for the 1st digit since we want the max digit to be the 1st digit of `num`.\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        mod = 1_000_000_007\\n        @cache\\n        def GoodInteger(num, is_smaller, index, cur_sum):\\n            if index == len(num):\\n                return 1 if min_sum <= cur_sum <= max_sum else 0\\n            count = 0\\n            end = 9 if is_smaller else int(num[index])\\n            for i in range(end + 1):\\n                new_is_smaller = False if (not is_smaller and i == end) else True\\n                count += GoodInteger(num, new_is_smaller, index+1, cur_sum + i)\\n                count %= mod\\n            return count\\n        num1 = str(int(num1) - 1)\\n        return (GoodInteger(num2, False, 0, 0) - GoodInteger(num1, False, 0, 0)) % mod\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        mod = 1_000_000_007\\n        @cache\\n        def GoodInteger(num, is_smaller, index, cur_sum):\\n            if index == len(num):\\n                return 1 if min_sum <= cur_sum <= max_sum else 0\\n            count = 0\\n            end = 9 if is_smaller else int(num[index])\\n            for i in range(end + 1):\\n                new_is_smaller = False if (not is_smaller and i == end) else True\\n                count += GoodInteger(num, new_is_smaller, index+1, cur_sum + i)\\n                count %= mod\\n            return count\\n        num1 = str(int(num1) - 1)\\n        return (GoodInteger(num2, False, 0, 0) - GoodInteger(num1, False, 0, 0)) % mod\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598232,
                "title": "dp-digit-sum-3d-dp-recursive-memoization-top-down",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is simplified first by thinking of a brute force approach. In this problem, we need to find the count of numbers that satisty following conditions:\\n\\n1. Sum of digit of that number, s >= min_sum && s <= max_sum\\n2. Number should lie in the range num1 and num2 (both included)\\n\\nTaking the constraints into consideration, it ain\\'t possible to pass all TCs by running the loop from each number from num1 to num2 and find its digits sum and checking whether the 1st condition is satisfying or not. \\n\\nIf we look carefully, we can see that this problem is a digit DP concept. For learning that concept, you can refer this playlist: \\n\\nhttps://youtube.com/playlist?list=PLb3g_Z8nEv1hB69JL9K7KfEyK8iQNj9nX\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn this problem, we need to take care of particularly three things:\\n1. Index \"ind\" of the number string\\n2. \"flag\" indicating whether we can insert any digit [0-9] on the ind of the number string or not.\\n3. Sum of digits \"sum\" achieved after building the number string. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(max(len(num1), len(num2)) \\u2217 max(sum(num1), sum(num2)) \\u2217 2 \\u2217 10)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(max(len(num1), len(num2)) \\u2217 max(sum(num1), sum(num2)) \\u2217 2) + Stack Space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    int dp[23][2][401]; \\n    int minSum;\\n    int maxSum;\\n    int helper(int ind, int flag, int sum, vector<int> a) {\\n        if (ind == a.size()) {\\n            if (sum >= minSum && sum <= maxSum) \\n                return 1;\\n            else \\n                return 0;\\n        }\\n        if (dp[ind][flag][sum] != -1) \\n            return dp[ind][flag][sum];\\n        int limit = 9;\\n        if (flag == 0) \\n            limit = a[ind];\\n        int cnt = 0;\\n        for (int num = 0; num <= limit; num++) {\\n            if (flag == 0 && num == a[ind]) {\\n                cnt = (helper(ind + 1, 0, sum + num, a)%mod + cnt%mod)%mod;\\n            }\\n            else {\\n                cnt = (helper(ind + 1, 1, sum + num, a)%mod + cnt%mod)%mod;\\n            }\\n        }\\n        return dp[ind][flag][sum] = cnt;\\n    }\\n    \\n    int digitDP(string s) {\\n        vector<int> a;\\n        int i = 0, n = s.length();\\n        while (i < n) {\\n            a.push_back((s[i] - 48) % 10);\\n            i++;\\n        }\\n        memset(dp, -1, sizeof dp);    \\n        return helper(0, 0, 0, a);\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        minSum = min_sum;\\n        maxSum = max_sum;\\n        int l = num1.length();\\n        string s;\\n        if(num1[l-1] != \\'0\\')\\n            s = num1.substr(0, l-1) + to_string(num1[l-1] - 48 - 1);\\n        else\\n            s = num1.substr(0, l-2) + to_string(num1[l-2] - 48 - 1) + \"9\";\\n        int ans = digitDP(num2) - digitDP(s);\\n        ans = (ans + mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    int dp[23][2][401]; \\n    int minSum;\\n    int maxSum;\\n    int helper(int ind, int flag, int sum, vector<int> a) {\\n        if (ind == a.size()) {\\n            if (sum >= minSum && sum <= maxSum) \\n                return 1;\\n            else \\n                return 0;\\n        }\\n        if (dp[ind][flag][sum] != -1) \\n            return dp[ind][flag][sum];\\n        int limit = 9;\\n        if (flag == 0) \\n            limit = a[ind];\\n        int cnt = 0;\\n        for (int num = 0; num <= limit; num++) {\\n            if (flag == 0 && num == a[ind]) {\\n                cnt = (helper(ind + 1, 0, sum + num, a)%mod + cnt%mod)%mod;\\n            }\\n            else {\\n                cnt = (helper(ind + 1, 1, sum + num, a)%mod + cnt%mod)%mod;\\n            }\\n        }\\n        return dp[ind][flag][sum] = cnt;\\n    }\\n    \\n    int digitDP(string s) {\\n        vector<int> a;\\n        int i = 0, n = s.length();\\n        while (i < n) {\\n            a.push_back((s[i] - 48) % 10);\\n            i++;\\n        }\\n        memset(dp, -1, sizeof dp);    \\n        return helper(0, 0, 0, a);\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        minSum = min_sum;\\n        maxSum = max_sum;\\n        int l = num1.length();\\n        string s;\\n        if(num1[l-1] != \\'0\\')\\n            s = num1.substr(0, l-1) + to_string(num1[l-1] - 48 - 1);\\n        else\\n            s = num1.substr(0, l-2) + to_string(num1[l-2] - 48 - 1) + \"9\";\\n        int ans = digitDP(num2) - digitDP(s);\\n        ans = (ans + mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598158,
                "title": "dp-implementation-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int m = 1e9+7;\\n    ll dp[24][2][2][405];\\n    ll helper(string&nums1,string&nums2,bool tight,bool ltight,ll sum,int i,ll maxi,ll mini)\\n    {  \\n       if(sum>maxi) return 0;\\n       if(i==nums2.size())\\n       {   \\n           if( sum>=mini && sum<=maxi ) {return 1;}\\n           return 0;\\n       }\\n      if(dp[i][tight][ltight][sum]!= -1) return dp[i][tight][ltight][sum];\\n      ll lmt = tight?(nums2[i]-\\'0\\'):9;\\n      ll low = ltight?(nums1[i]-\\'0\\'):0;\\n      ll ans =0;\\n\\n      for(ll k=low;k<=lmt;k++)\\n      {\\n           ans = (ans%m+ helper(nums1,nums2,(tight&&(lmt==k)),(ltight&&(low==k)),sum+k,i+1,maxi,mini)%m)%m;\\n       \\n      }\\n      \\n      return dp[i][tight][ltight][sum]=ans;\\n    }    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n\\n       int d = num2.size()-num1.size();\\n       memset(dp,-1,sizeof(dp));\\n       string num =\"\";\\n       for(int i=0;i<d;i++) num+=\\'0\\';\\n       num+=num1;      \\n       ll t1 = helper(num,num2,true,true,0,0,max_sum,min_sum);\\n      \\n       return t1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int m = 1e9+7;\\n    ll dp[24][2][2][405];\\n    ll helper(string&nums1,string&nums2,bool tight,bool ltight,ll sum,int i,ll maxi,ll mini)\\n    {  \\n       if(sum>maxi) return 0;\\n       if(i==nums2.size())\\n       {   \\n           if( sum>=mini && sum<=maxi ) {return 1;}\\n           return 0;\\n       }\\n      if(dp[i][tight][ltight][sum]!= -1) return dp[i][tight][ltight][sum];\\n      ll lmt = tight?(nums2[i]-\\'0\\'):9;\\n      ll low = ltight?(nums1[i]-\\'0\\'):0;\\n      ll ans =0;\\n\\n      for(ll k=low;k<=lmt;k++)\\n      {\\n           ans = (ans%m+ helper(nums1,nums2,(tight&&(lmt==k)),(ltight&&(low==k)),sum+k,i+1,maxi,mini)%m)%m;\\n       \\n      }\\n      \\n      return dp[i][tight][ltight][sum]=ans;\\n    }    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n\\n       int d = num2.size()-num1.size();\\n       memset(dp,-1,sizeof(dp));\\n       string num =\"\";\\n       for(int i=0;i<d;i++) num+=\\'0\\';\\n       num+=num1;      \\n       ll t1 = helper(num,num2,true,true,0,0,max_sum,min_sum);\\n      \\n       return t1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598046,
                "title": "memoized-dp-solution-digit-dp",
                "content": "Here is the intution for the problem.\\n<br>\\n<br>\\n\\n<img class=\"img-fluid\" src=\"https://assets.leetcode.com/users/images/44ee99d2-a078-4c31-8c51-6cd33ed50ac2_1685903772.564008.jpeg\" alt=\"img-verification\" width=\"600\" height=\"500\" style=\"transform:rotate(90deg)\">\\n\\n<br>\\n<br/>\\n<br/>\\n<br/><br/><br/><br/>\\n\\n<img class=\"img-fluid\" src=\"https://assets.leetcode.com/users/images/619571ef-c62f-4ec2-b59c-ba44fb80f27b_1685903773.8774247.jpeg\" alt=\"img-verification\" width=\"600\" height=\"500\" style=\"transform:rotate(90deg)\">\\n\\n<br>\\n<br/>\\n<br/>\\n<br/><br/><br/><br/>\\n\\nProblem Code:\\n```\\n\\ntypedef long long int lli;\\n#define cc if(0)\\n\\nconst int MOD = 1e9+7;\\n#define MAX_IDX 23\\n#define MAX_DIGIT_SUM 401\\n#define MAX_STATE 3\\n\\nclass Solution {\\n\\n    unordered_map<int,int> mMap;\\n    \\n    //main this is state1,state2\\n    /*\\n        state1 === the current formed number MATCHES EXACTLY with the lowerNumber (upp till index idx)\\n        state2 === the current formed number MATCHED EXACTLY with the upperNumer(up till index idx)\\n        \\n        cNum === the current number being formed inside the recursion\\n        cNumDigitSum === digit sum of the cNum\\n        \\n        let [ab_] , where this is the number being formed & we have the task to find the possible number to fill at the blank.\\n        \\n        [start,end] = [0,9] <= in case no constrain\\n        if state1 == true =-> it will decided the start index of range\\n        if state2 == true ==>it will decide the end index of the range\\n    \\n    */\\n    int solve(int idx, string &cNum, int cNumDigitSum, int state1,int state2,const int& mx, const int &mx_length, const string &num1, const string &num2)\\n    {     \\n        if(cNumDigitSum > mx) return 0;   \\n        if(idx >= mx_length) return 1;\\n    \\n        int key = idx + (MAX_IDX*cNumDigitSum) + (MAX_IDX*MAX_DIGIT_SUM*state1) + (MAX_IDX*MAX_DIGIT_SUM*MAX_STATE*state2);\\n\\n        if(mMap.find(key) != mMap.end())\\n            return mMap[key];\\n\\t\\t\\t\\n        int start=0,end=9;\\n        \\n        if(state1){\\n            start = num1[idx]-\\'0\\';\\n        }\\n        if(state2){\\n            end = num2[idx]-\\'0\\';\\n        }\\n\\t\\t\\n        lli count = 0;\\n        \\n        int a = num1[idx]-\\'0\\';\\n        int b = num2[idx]-\\'0\\';\\n        for(int i=start;i<=end;i++)\\n        {   \\n            cNum.push_back(i+\\'0\\');//[abc_] => [abci] (digit representation of newly formed cNun)\\n            \\n            int temp = solve(idx+1,cNum,cNumDigitSum + i,\\n                             state1 && (i == a),\\n                             state2 && (i == b),\\n                             mx,mx_length,\\n                             num1,num2);\\n            cNum.pop_back();\\n            \\n            count += temp;\\n            count %= MOD;\\n        }\\n        return mMap[key] = count;\\n    }\\n    \\npublic:\\n    int count(string s1, string s2, int min_sum, int max_sum) {\\n        string num1 = string(s2.size() - s1.size(), \\'0\\') + s1; \\n        string num2 = s2;\\n        int size = num1.size();\\n\\t\\t\\n        string cNum;\\n        memset(mem,-1,sizeof(mem));\\n        int x = solve(0,cNum,0,1,1,max_sum,size,num1,num2);\\n\\t\\t\\n        mMap = {};\\n        int y = solve(0,cNum,0,1,1,min_sum-1,size,num1,num2);\\n\\n        return x-y;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\ntypedef long long int lli;\\n#define cc if(0)\\n\\nconst int MOD = 1e9+7;\\n#define MAX_IDX 23\\n#define MAX_DIGIT_SUM 401\\n#define MAX_STATE 3\\n\\nclass Solution {\\n\\n    unordered_map<int,int> mMap;\\n    \\n    //main this is state1,state2\\n    /*\\n        state1 === the current formed number MATCHES EXACTLY with the lowerNumber (upp till index idx)\\n        state2 === the current formed number MATCHED EXACTLY with the upperNumer(up till index idx)\\n        \\n        cNum === the current number being formed inside the recursion\\n        cNumDigitSum === digit sum of the cNum\\n        \\n        let [ab_] , where this is the number being formed & we have the task to find the possible number to fill at the blank.\\n        \\n        [start,end] = [0,9] <= in case no constrain\\n        if state1 == true =-> it will decided the start index of range\\n        if state2 == true ==>it will decide the end index of the range\\n    \\n    */\\n    int solve(int idx, string &cNum, int cNumDigitSum, int state1,int state2,const int& mx, const int &mx_length, const string &num1, const string &num2)\\n    {     \\n        if(cNumDigitSum > mx) return 0;   \\n        if(idx >= mx_length) return 1;\\n    \\n        int key = idx + (MAX_IDX*cNumDigitSum) + (MAX_IDX*MAX_DIGIT_SUM*state1) + (MAX_IDX*MAX_DIGIT_SUM*MAX_STATE*state2);\\n\\n        if(mMap.find(key) != mMap.end())\\n            return mMap[key];\\n\\t\\t\\t\\n        int start=0,end=9;\\n        \\n        if(state1){\\n            start = num1[idx]-\\'0\\';\\n        }\\n        if(state2){\\n            end = num2[idx]-\\'0\\';\\n        }\\n\\t\\t\\n        lli count = 0;\\n        \\n        int a = num1[idx]-\\'0\\';\\n        int b = num2[idx]-\\'0\\';\\n        for(int i=start;i<=end;i++)\\n        {   \\n            cNum.push_back(i+\\'0\\');//[abc_] => [abci] (digit representation of newly formed cNun)\\n            \\n            int temp = solve(idx+1,cNum,cNumDigitSum + i,\\n                             state1 && (i == a),\\n                             state2 && (i == b),\\n                             mx,mx_length,\\n                             num1,num2);\\n            cNum.pop_back();\\n            \\n            count += temp;\\n            count %= MOD;\\n        }\\n        return mMap[key] = count;\\n    }\\n    \\npublic:\\n    int count(string s1, string s2, int min_sum, int max_sum) {\\n        string num1 = string(s2.size() - s1.size(), \\'0\\') + s1; \\n        string num2 = s2;\\n        int size = num1.size();\\n\\t\\t\\n        string cNum;\\n        memset(mem,-1,sizeof(mem));\\n        int x = solve(0,cNum,0,1,1,max_sum,size,num1,num2);\\n\\t\\t\\n        mMap = {};\\n        int y = solve(0,cNum,0,1,1,min_sum-1,size,num1,num2);\\n\\n        return x-y;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597868,
                "title": "java-dp-recursion-9-ms",
                "content": "# Intuition\\nDP and Recursion\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public static long[][] dp;\\n    public static int mod = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        double one = Double.parseDouble(num1);\\n        double two = Double.parseDouble(num2);\\n        if(dp==null)\\n        {\\n            dp = new long[23][401];\\n            dp[0][0] = 1;\\n            for (int i = 1; i <23; i++) {\\n                for (int j = 0; j < 10; j++) {\\n                    for (int k = 400; k >=0&&k-j>=0 ; k--) {\\n                        dp[i][k] += dp[i-1][k-j];\\n                        dp[i][k]%=mod;\\n                    }\\n                }\\n            }\\n            for (int i = 1; i < 23; i++) {\\n                for (int j = 1; j < 401; j++) {\\n                    dp[i][j]+=dp[i][j-1];\\n                    dp[i][j]%=mod;\\n                }\\n            }\\n        }\\n        return (int)travel(one,two,max_sum,min_sum,false);\\n    }\\n    public long travel(double one,double two,int max,int min,boolean clean)\\n    {\\n        if(clean)\\n        {\\n            int digit = ((int)Math.log10(two))+1;\\n            int ret = (int)(dp[digit][max]);\\n            if(min>0)\\n                ret-=dp[digit][min-1];\\n            return (ret<0) ?ret+mod : ret;\\n        }\\n        else\\n        {\\n            long ret = 0;\\n            if(two-one<10d)\\n            {\\n                int sum = digit(one);\\n                for (double i = one; i <= two; i++) {\\n                    if(sum>=min&&sum<=max)\\n                    {\\n                        ret++;\\n                    }\\n                    if(one%10==9)\\n                    {\\n                        sum = digit(one+1);\\n                    }\\n                    else\\n                        sum++;\\n                }\\n            }\\n            else {\\n                int dig = (int)Math.log10(two);\\n                dig = ((int)Math.pow(10,dig))-1;\\n                int last = last(two);\\n                for (int i = 0; i <last; i++) {\\n                    if(max-i>=0) {\\n                        ret += travel(0, dig, max-i, Math.max(0,min-i), true);\\n                        ret %= mod;\\n                    }\\n                }\\n                dig++;\\n                dig*=last;\\n                if(max-last>=0)\\n                    ret+=travel(0,two-dig,max-last,Math.max(0,min-last),false);\\n                ret%=mod;\\n                if(one!=0)\\n                {\\n                    ret-=travel(0,one-1,max,min,false);\\n                    if(ret<0)\\n                        ret+=mod;\\n                }\\n            }\\n            return ret;\\n        }\\n    }\\n    public int last(double temp)\\n    {\\n        int ret = 0;\\n        while (temp>0)\\n        {\\n            ret=(int)(temp%10);\\n            temp = Math.floor(temp/10);\\n        }\\n        return ret;\\n    }\\n    public int digit(double temp)\\n    {\\n        int sum = 0;\\n        while (temp>0)\\n        {\\n            sum+=temp%10;\\n            temp = Math.floor(temp/10);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static long[][] dp;\\n    public static int mod = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        double one = Double.parseDouble(num1);\\n        double two = Double.parseDouble(num2);\\n        if(dp==null)\\n        {\\n            dp = new long[23][401];\\n            dp[0][0] = 1;\\n            for (int i = 1; i <23; i++) {\\n                for (int j = 0; j < 10; j++) {\\n                    for (int k = 400; k >=0&&k-j>=0 ; k--) {\\n                        dp[i][k] += dp[i-1][k-j];\\n                        dp[i][k]%=mod;\\n                    }\\n                }\\n            }\\n            for (int i = 1; i < 23; i++) {\\n                for (int j = 1; j < 401; j++) {\\n                    dp[i][j]+=dp[i][j-1];\\n                    dp[i][j]%=mod;\\n                }\\n            }\\n        }\\n        return (int)travel(one,two,max_sum,min_sum,false);\\n    }\\n    public long travel(double one,double two,int max,int min,boolean clean)\\n    {\\n        if(clean)\\n        {\\n            int digit = ((int)Math.log10(two))+1;\\n            int ret = (int)(dp[digit][max]);\\n            if(min>0)\\n                ret-=dp[digit][min-1];\\n            return (ret<0) ?ret+mod : ret;\\n        }\\n        else\\n        {\\n            long ret = 0;\\n            if(two-one<10d)\\n            {\\n                int sum = digit(one);\\n                for (double i = one; i <= two; i++) {\\n                    if(sum>=min&&sum<=max)\\n                    {\\n                        ret++;\\n                    }\\n                    if(one%10==9)\\n                    {\\n                        sum = digit(one+1);\\n                    }\\n                    else\\n                        sum++;\\n                }\\n            }\\n            else {\\n                int dig = (int)Math.log10(two);\\n                dig = ((int)Math.pow(10,dig))-1;\\n                int last = last(two);\\n                for (int i = 0; i <last; i++) {\\n                    if(max-i>=0) {\\n                        ret += travel(0, dig, max-i, Math.max(0,min-i), true);\\n                        ret %= mod;\\n                    }\\n                }\\n                dig++;\\n                dig*=last;\\n                if(max-last>=0)\\n                    ret+=travel(0,two-dig,max-last,Math.max(0,min-last),false);\\n                ret%=mod;\\n                if(one!=0)\\n                {\\n                    ret-=travel(0,one-1,max,min,false);\\n                    if(ret<0)\\n                        ret+=mod;\\n                }\\n            }\\n            return ret;\\n        }\\n    }\\n    public int last(double temp)\\n    {\\n        int ret = 0;\\n        while (temp>0)\\n        {\\n            ret=(int)(temp%10);\\n            temp = Math.floor(temp/10);\\n        }\\n        return ret;\\n    }\\n    public int digit(double temp)\\n    {\\n        int sum = 0;\\n        while (temp>0)\\n        {\\n            sum+=temp%10;\\n            temp = Math.floor(temp/10);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597775,
                "title": "c-100-digit-dp-fast-and-clean-in-one-pass",
                "content": "I use one dfs function to check if the digit sum is bigger than mi and lower than mx instead of running dfs twice.\\n`cur` means sum of digits.\\nSimply break dfs if is larger than `mx`.\\nCheck if `cur` is large than `mi` and 1 if it\\'s valid.\\n```\\nclass Solution {\\npublic:\\n    vector<int> v1, v2;\\n    int dp[22][500][2][2];\\n    int mod = 1e9+7;\\n    int count(string num1, string num2, int mi, int mx) {\\n        memset(dp, -1, sizeof(dp));\\n        for (char c: num2) {\\n            v2.push_back(c-\\'0\\');\\n        }\\n        reverse(v2.begin(), v2.end());\\n        int n = v2.size();\\n        v1.resize(n);\\n        for (int i = (int)num1.size()-1, j = 0; i >= 0; i--) {\\n            v1[j++] = num1[i]-\\'0\\';\\n        }\\n        return dfs(n-1, mi, mx, 0, true, true);\\n    }\\n\\n    // tight: determine the uppper limit of current digit\\n    int dfs(int pos, int mi, int mx, int cur, bool tight1, bool tight2){\\n        if (pos == -1) return cur >= mi;\\n        if (~dp[pos][cur][tight1][tight2]) return dp[pos][cur][tight1][tight2];\\n        int ub = tight2 ? v2[pos] : 9;\\n        int lb = tight1 ? v1[pos] : 0;\\n        int sum = 0;\\n        for (int i = lb; i <= ub; i++) {\\n            if (cur + i > mx) break;\\n            sum = (sum + dfs(pos-1, mi, mx, cur+i, i==lb && tight1, i==ub && tight2)) % mod;\\n        }\\n        return dp[pos][cur][tight1][tight2] = sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v1, v2;\\n    int dp[22][500][2][2];\\n    int mod = 1e9+7;\\n    int count(string num1, string num2, int mi, int mx) {\\n        memset(dp, -1, sizeof(dp));\\n        for (char c: num2) {\\n            v2.push_back(c-\\'0\\');\\n        }\\n        reverse(v2.begin(), v2.end());\\n        int n = v2.size();\\n        v1.resize(n);\\n        for (int i = (int)num1.size()-1, j = 0; i >= 0; i--) {\\n            v1[j++] = num1[i]-\\'0\\';\\n        }\\n        return dfs(n-1, mi, mx, 0, true, true);\\n    }\\n\\n    // tight: determine the uppper limit of current digit\\n    int dfs(int pos, int mi, int mx, int cur, bool tight1, bool tight2){\\n        if (pos == -1) return cur >= mi;\\n        if (~dp[pos][cur][tight1][tight2]) return dp[pos][cur][tight1][tight2];\\n        int ub = tight2 ? v2[pos] : 9;\\n        int lb = tight1 ? v1[pos] : 0;\\n        int sum = 0;\\n        for (int i = lb; i <= ub; i++) {\\n            if (cur + i > mx) break;\\n            sum = (sum + dfs(pos-1, mi, mx, cur+i, i==lb && tight1, i==ub && tight2)) % mod;\\n        }\\n        return dp[pos][cur][tight1][tight2] = sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597701,
                "title": "digit-dp-recursive-c-one-tight-condition-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int digits(string& num,int n,int sum,bool tight,int dp[24][401][2]) {\\n        if(sum<0) return 0;\\n        if(n==0) {\\n            if(sum==0) return 1;\\n            return 0;\\n        }\\n        \\n        if(dp[n][sum][tight]!=-1) return dp[n][sum][tight];\\n        \\n        int tight_bound= tight? (num[(num.size()-n)]-\\'0\\') : 9;\\n        long long ans=0;\\n        for(int dig=0;dig<=tight_bound;dig++) {\\n            ans+=digits(num,n-1,sum-dig,(tight&(dig==tight_bound)),dp);\\n        }\\n        ans=ans%(int)(1e9+7);\\n        return dp[n][sum][tight]=(int)ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        long long res=0;\\n        \\n        //num1 decrement\\n        int g=num1.size();\\n        int j=g-1;\\n        while(num1[j]==0) j--;\\n        num1[j++]--;\\n        for(j;j<g;j++) num1[j]=\\'9\\';\\n        \\n        int dp[24][401][2];\\n        memset(dp,-1,sizeof(dp));\\n        int dp1[24][401][2];\\n        memset(dp1,-1,sizeof(dp1));\\n        \\n        for(int i=min_sum;i<=max_sum;i++) {\\n            res+=digits(num2,num2.size(),i,1,dp);\\n            res-=digits(num1,num1.size(),i,1,dp1);\\n            res=res%(int)(1e9+7);\\n        }\\n        return (int)res%(int)(1e9+7);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digits(string& num,int n,int sum,bool tight,int dp[24][401][2]) {\\n        if(sum<0) return 0;\\n        if(n==0) {\\n            if(sum==0) return 1;\\n            return 0;\\n        }\\n        \\n        if(dp[n][sum][tight]!=-1) return dp[n][sum][tight];\\n        \\n        int tight_bound= tight? (num[(num.size()-n)]-\\'0\\') : 9;\\n        long long ans=0;\\n        for(int dig=0;dig<=tight_bound;dig++) {\\n            ans+=digits(num,n-1,sum-dig,(tight&(dig==tight_bound)),dp);\\n        }\\n        ans=ans%(int)(1e9+7);\\n        return dp[n][sum][tight]=(int)ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        long long res=0;\\n        \\n        //num1 decrement\\n        int g=num1.size();\\n        int j=g-1;\\n        while(num1[j]==0) j--;\\n        num1[j++]--;\\n        for(j;j<g;j++) num1[j]=\\'9\\';\\n        \\n        int dp[24][401][2];\\n        memset(dp,-1,sizeof(dp));\\n        int dp1[24][401][2];\\n        memset(dp1,-1,sizeof(dp1));\\n        \\n        for(int i=min_sum;i<=max_sum;i++) {\\n            res+=digits(num2,num2.size(),i,1,dp);\\n            res-=digits(num1,num1.size(),i,1,dp1);\\n            res=res%(int)(1e9+7);\\n        }\\n        return (int)res%(int)(1e9+7);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597629,
                "title": "c-simple-recursion-with-memoization",
                "content": "- padd `\\'0\\'` left of `num1` to make same size as `num2`\\n- handle left most digits and recurse to sub problems of one less size.\\n- memoization on sub problems of `num1 = 0^sz, num2 = 9^sz`\\n- early termination of recursion based on bound check\\n```\\nclass Solution {\\npublic:\\n    int count(string num1, string num2, int minS, int maxS) {\\n        int mod = 1\\'000\\'000\\'007;\\n        if(int dif = num2.size() - num1.size(); dif)\\n            num1 = string(dif, \\'0\\') + num1;\\n        \\n        unordered_map<int, int> G;\\n        function<int(int, int, int)> g = [&g, &G, &mod](int sz, int minS, int maxS) { // subproblem of numbers in [0^sz, 9^sz]\\n            if(maxS < 0) return 0;\\n            if(minS < 0) minS = 0;\\n            if(sz == 1) return minS > 9 ? 0 : min(9, maxS) - minS + 1;\\n\\n            int key = sz * 400 * 400 + minS * 400 + maxS;\\n            if(!G.count(key)) {\\n                int ans = 0;\\n                if(!sz) ans = (minS <= 0 && 0 <= maxS);\\n                else {\\n                    if(sz * 9 >= minS) {\\n                        for(int i = 0; i <= 9; ++i)\\n                            ans = (ans + g(sz-1, minS - i, maxS - i)) % mod;\\n                    } \\n                }\\n                G[key] = ans;\\n            }\\n            return G[key];\\n        };\\n        \\n        function<int(string, string, int, int)> f = [&f, &g, &mod](string num1, string num2, int minS, int maxS) {\\n            int ans = 0, sz = num1.size();\\n            int n1 = num1[0] - \\'0\\', n2 = num2[0] - \\'0\\';\\n            if(sz*9 < minS) return 0;\\n            if(sz == 1)\\n                ans = max(0, min(maxS, n2) - max(minS, n1) + 1);\\n            else {\\n                if(n1 == n2)\\n                    ans = (ans + f(num1.substr(1), num2.substr(1), minS - n1, maxS - n1)) % mod;\\n                else {\\n                    ans = (ans + f(num1.substr(1), string(sz-1,\\'9\\'), minS - n1, maxS - n1)) % mod;\\n                    for(int n = n1+1; n < n2; ++n) {\\n                        ans = (ans + g(sz-1, minS - n, maxS - n)) % mod;\\n                    }\\n                    ans = (ans + f(string(sz-1,\\'0\\'), num2.substr(1), minS - n2, maxS - n2)) % mod;\\n                }\\n            }\\n            return ans;\\n        };\\n\\n        return f(num1, num2, minS, maxS);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(string num1, string num2, int minS, int maxS) {\\n        int mod = 1\\'000\\'000\\'007;\\n        if(int dif = num2.size() - num1.size(); dif)\\n            num1 = string(dif, \\'0\\') + num1;\\n        \\n        unordered_map<int, int> G;\\n        function<int(int, int, int)> g = [&g, &G, &mod](int sz, int minS, int maxS) { // subproblem of numbers in [0^sz, 9^sz]\\n            if(maxS < 0) return 0;\\n            if(minS < 0) minS = 0;\\n            if(sz == 1) return minS > 9 ? 0 : min(9, maxS) - minS + 1;\\n\\n            int key = sz * 400 * 400 + minS * 400 + maxS;\\n            if(!G.count(key)) {\\n                int ans = 0;\\n                if(!sz) ans = (minS <= 0 && 0 <= maxS);\\n                else {\\n                    if(sz * 9 >= minS) {\\n                        for(int i = 0; i <= 9; ++i)\\n                            ans = (ans + g(sz-1, minS - i, maxS - i)) % mod;\\n                    } \\n                }\\n                G[key] = ans;\\n            }\\n            return G[key];\\n        };\\n        \\n        function<int(string, string, int, int)> f = [&f, &g, &mod](string num1, string num2, int minS, int maxS) {\\n            int ans = 0, sz = num1.size();\\n            int n1 = num1[0] - \\'0\\', n2 = num2[0] - \\'0\\';\\n            if(sz*9 < minS) return 0;\\n            if(sz == 1)\\n                ans = max(0, min(maxS, n2) - max(minS, n1) + 1);\\n            else {\\n                if(n1 == n2)\\n                    ans = (ans + f(num1.substr(1), num2.substr(1), minS - n1, maxS - n1)) % mod;\\n                else {\\n                    ans = (ans + f(num1.substr(1), string(sz-1,\\'9\\'), minS - n1, maxS - n1)) % mod;\\n                    for(int n = n1+1; n < n2; ++n) {\\n                        ans = (ans + g(sz-1, minS - n, maxS - n)) % mod;\\n                    }\\n                    ans = (ans + f(string(sz-1,\\'0\\'), num2.substr(1), minS - n2, maxS - n2)) % mod;\\n                }\\n            }\\n            return ans;\\n        };\\n\\n        return f(num1, num2, minS, maxS);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597556,
                "title": "c-top-down-32-ms-completely-intuitive-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlet digits in num1=x\\nlet digits in num2=y\\nnow count all the integers with digits [x+1,y-1] which sum up in bw [min_sum,max_sum]\\nnow a special care should be taken for integers of x digits  and y-digits bcz only the numbers >=num1 and <=num2 should be counted\\nnow memoize the solution using dp its state as [n][ind][sum uptill here] n->no of digits whose integers we are seeking for\\nind-> how many digits have been set uptill now or the position of curr digit\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n**PLS UPVOTE**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[23][23][200];    // 22 digits as 9 max sum->198 ind and n max 22 digits\\n    int mod=1e9+7;\\n    int f1(int ind,int n,string& num1,string& num2,int mini,int maxi,int min_s,int max_s,string& num,int sum){\\n        if(sum>max_s) return 0;\\n        if(ind==n) return sum>=min_s;\\n        if(mini==-1 && maxi==-1 && dp[n][ind][sum]!=-1) return dp[n][ind][sum];\\n        long ans=0;\\n        bool temp1=(!num1.empty());     // only numbers  >=  num1 num[ind]>=mini\\n        bool temp2=(!num2.empty());     // only numbers  <=  num2 num[ind]<=maxi\\n        int new_mini=-1;     // used if num[ind]=mini;\\n        if(temp1 && ind<n-1 && mini!=-1) new_mini=num1[ind+1]-\\'0\\';\\n        int new_maxi=-1;     // used if num[ind]=maxi;\\n        if(temp2 && ind<n-1  && maxi!=-1) new_maxi=num2[ind+1]-\\'0\\';\\n        int i=(mini!=-1)?mini:(ind==0)?1:0;\\n        int j=(maxi!=-1)?maxi:9;\\n        for(;i<=j && sum+i<=max_s;i++){\\n            num.push_back(i+\\'0\\');\\n            ans+=f1(ind+1,n,num1,num2,(i==mini)?new_mini:(-1),(i==maxi)?new_maxi:(-1),min_s,max_s,num,sum+i);\\n            ans%=mod;\\n            num.pop_back();\\n        }\\n        if(mini==-1 && maxi==-1) return dp[n][ind][sum]=ans;\\n        return ans;\\n    }\\n    \\n    int f(int ind,int n,int min_s,int max_s,string& num,int sum){\\n        if(sum>max_s) return 0;\\n        if(ind==n) return sum>=min_s;\\n        if(dp[n][ind][sum]!=-1) return  dp[n][ind][sum];\\n        long ans=0;\\n        int i=(ind==0)?1:0;\\n        for(;i<=9 && sum+i<=max_s;i++){\\n            num.push_back(i+\\'0\\');\\n            ans+=f(ind+1,n,min_s,max_s,num,sum+i);\\n            ans%=mod;\\n            num.pop_back();\\n        }\\n        return dp[n][ind][sum]=ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof(dp));\\n        int n1=num1.size();\\n        int n2=num2.size();\\n        long answer=0;\\n        string num=\"\";\\n        for(int i=n1+1;i<n2;i++){\\n            answer+=f(0,i,min_sum,max_sum,num,0);\\n            answer%=mod;\\n        }\\n        if(n1==n2) answer+=f1(0,n1,num1,num2,num1[0]-\\'0\\',num2[0]-\\'0\\',min_sum,max_sum,num,0);\\n        else{\\n            string x=\"\";\\n            answer+=f1(0,n1,num1,x,num1[0]-\\'0\\',-1,min_sum,max_sum,num,0);\\n            answer+=f1(0,n2,x,num2,-1,num2[0]-\\'0\\',min_sum,max_sum,num,0);\\n            answer%=mod;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[23][23][200];    // 22 digits as 9 max sum->198 ind and n max 22 digits\\n    int mod=1e9+7;\\n    int f1(int ind,int n,string& num1,string& num2,int mini,int maxi,int min_s,int max_s,string& num,int sum){\\n        if(sum>max_s) return 0;\\n        if(ind==n) return sum>=min_s;\\n        if(mini==-1 && maxi==-1 && dp[n][ind][sum]!=-1) return dp[n][ind][sum];\\n        long ans=0;\\n        bool temp1=(!num1.empty());     // only numbers  >=  num1 num[ind]>=mini\\n        bool temp2=(!num2.empty());     // only numbers  <=  num2 num[ind]<=maxi\\n        int new_mini=-1;     // used if num[ind]=mini;\\n        if(temp1 && ind<n-1 && mini!=-1) new_mini=num1[ind+1]-\\'0\\';\\n        int new_maxi=-1;     // used if num[ind]=maxi;\\n        if(temp2 && ind<n-1  && maxi!=-1) new_maxi=num2[ind+1]-\\'0\\';\\n        int i=(mini!=-1)?mini:(ind==0)?1:0;\\n        int j=(maxi!=-1)?maxi:9;\\n        for(;i<=j && sum+i<=max_s;i++){\\n            num.push_back(i+\\'0\\');\\n            ans+=f1(ind+1,n,num1,num2,(i==mini)?new_mini:(-1),(i==maxi)?new_maxi:(-1),min_s,max_s,num,sum+i);\\n            ans%=mod;\\n            num.pop_back();\\n        }\\n        if(mini==-1 && maxi==-1) return dp[n][ind][sum]=ans;\\n        return ans;\\n    }\\n    \\n    int f(int ind,int n,int min_s,int max_s,string& num,int sum){\\n        if(sum>max_s) return 0;\\n        if(ind==n) return sum>=min_s;\\n        if(dp[n][ind][sum]!=-1) return  dp[n][ind][sum];\\n        long ans=0;\\n        int i=(ind==0)?1:0;\\n        for(;i<=9 && sum+i<=max_s;i++){\\n            num.push_back(i+\\'0\\');\\n            ans+=f(ind+1,n,min_s,max_s,num,sum+i);\\n            ans%=mod;\\n            num.pop_back();\\n        }\\n        return dp[n][ind][sum]=ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof(dp));\\n        int n1=num1.size();\\n        int n2=num2.size();\\n        long answer=0;\\n        string num=\"\";\\n        for(int i=n1+1;i<n2;i++){\\n            answer+=f(0,i,min_sum,max_sum,num,0);\\n            answer%=mod;\\n        }\\n        if(n1==n2) answer+=f1(0,n1,num1,num2,num1[0]-\\'0\\',num2[0]-\\'0\\',min_sum,max_sum,num,0);\\n        else{\\n            string x=\"\";\\n            answer+=f1(0,n1,num1,x,num1[0]-\\'0\\',-1,min_sum,max_sum,num,0);\\n            answer+=f1(0,n2,x,num2,-1,num2[0]-\\'0\\',min_sum,max_sum,num,0);\\n            answer%=mod;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597493,
                "title": "c-dp-bottom-up",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static constexpr int kMod = 1E9 + 7;\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        // Count the kinds of numbers with no more than `len` digits, whose digits sums are bounded by `val`.\\n        const int max_len = std::max(num1.size(), num2.size());\\n        const int max_val_bound = max_sum;\\n        std::vector<std::vector<int>> tbl_bounded_kinds(max_len + 1, std::vector<int>(max_val_bound + 1, 0));\\n        for (int val_bound = 0; val_bound <= max_val_bound; ++val_bound) {\\n            tbl_bounded_kinds[0][val_bound] = 1;\\n        }\\n        for (int len = 1; len <= max_len; ++len) {\\n            tbl_bounded_kinds[len][0] = tbl_bounded_kinds[len - 1][0];\\n            for (int val_bound = 1; val_bound <= max_val_bound; ++val_bound) {\\n                int cnts = 0;\\n                for (int last_digit = 0; last_digit <= std::min(9, val_bound); ++last_digit) {\\n                    cnts = (cnts + tbl_bounded_kinds[len - 1][val_bound - last_digit]) % kMod;\\n                }\\n                tbl_bounded_kinds[len][val_bound] = cnts;\\n            }\\n        }\\n\\n        const auto count_bounded_numbers = [&](const std::string &digits_bound, const int sum_bound) -> int {\\n            int prefix_sum = 0;\\n            int cnts = 0;\\n            for (int i = 0, len = digits_bound.size() - 1; i < digits_bound.size(); ++i, --len) {\\n                const int max_digit = static_cast<int>(digits_bound[i] - \\'0\\');\\n                for (int digit = 0; digit < max_digit; ++digit) {\\n                    const int sum = prefix_sum + digit;\\n                    if (sum > sum_bound) {\\n                        break;\\n                    }\\n                    cnts = (cnts + tbl_bounded_kinds[len][sum_bound - sum]) % kMod;                    \\n                }\\n                prefix_sum += max_digit;\\n                if (prefix_sum > sum_bound) {\\n                    break;\\n                }\\n            }\\n            if (prefix_sum <= sum_bound) {\\n                cnts = (cnts + 1) % kMod;\\n            }\\n            return cnts;\\n        };\\n\\n        const int upper_by_max = count_bounded_numbers(num2, max_sum);\\n        const int upper_by_min = count_bounded_numbers(num2, min_sum - 1);\\n        const int upper_by_range = (upper_by_max - upper_by_min + kMod) % kMod;\\n        const int lower_by_max = count_bounded_numbers(num1, max_sum);\\n        const int lower_by_min = count_bounded_numbers(num1, min_sum - 1);\\n        const int lower_by_range = (lower_by_max - lower_by_min + kMod) % kMod;\\n\\n        int adjusted = 0;\\n        {\\n            int sum = 0;\\n            for (char d : num1) {\\n                sum += (d - \\'0\\');\\n            }\\n            if ((min_sum <= sum) && (sum <= max_sum)) {\\n                adjusted = 1;\\n            }\\n        }\\n\\n        const int result = (upper_by_range - lower_by_range + adjusted + kMod) % kMod;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    static constexpr int kMod = 1E9 + 7;\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        // Count the kinds of numbers with no more than `len` digits, whose digits sums are bounded by `val`.\\n        const int max_len = std::max(num1.size(), num2.size());\\n        const int max_val_bound = max_sum;\\n        std::vector<std::vector<int>> tbl_bounded_kinds(max_len + 1, std::vector<int>(max_val_bound + 1, 0));\\n        for (int val_bound = 0; val_bound <= max_val_bound; ++val_bound) {\\n            tbl_bounded_kinds[0][val_bound] = 1;\\n        }\\n        for (int len = 1; len <= max_len; ++len) {\\n            tbl_bounded_kinds[len][0] = tbl_bounded_kinds[len - 1][0];\\n            for (int val_bound = 1; val_bound <= max_val_bound; ++val_bound) {\\n                int cnts = 0;\\n                for (int last_digit = 0; last_digit <= std::min(9, val_bound); ++last_digit) {\\n                    cnts = (cnts + tbl_bounded_kinds[len - 1][val_bound - last_digit]) % kMod;\\n                }\\n                tbl_bounded_kinds[len][val_bound] = cnts;\\n            }\\n        }\\n\\n        const auto count_bounded_numbers = [&](const std::string &digits_bound, const int sum_bound) -> int {\\n            int prefix_sum = 0;\\n            int cnts = 0;\\n            for (int i = 0, len = digits_bound.size() - 1; i < digits_bound.size(); ++i, --len) {\\n                const int max_digit = static_cast<int>(digits_bound[i] - \\'0\\');\\n                for (int digit = 0; digit < max_digit; ++digit) {\\n                    const int sum = prefix_sum + digit;\\n                    if (sum > sum_bound) {\\n                        break;\\n                    }\\n                    cnts = (cnts + tbl_bounded_kinds[len][sum_bound - sum]) % kMod;                    \\n                }\\n                prefix_sum += max_digit;\\n                if (prefix_sum > sum_bound) {\\n                    break;\\n                }\\n            }\\n            if (prefix_sum <= sum_bound) {\\n                cnts = (cnts + 1) % kMod;\\n            }\\n            return cnts;\\n        };\\n\\n        const int upper_by_max = count_bounded_numbers(num2, max_sum);\\n        const int upper_by_min = count_bounded_numbers(num2, min_sum - 1);\\n        const int upper_by_range = (upper_by_max - upper_by_min + kMod) % kMod;\\n        const int lower_by_max = count_bounded_numbers(num1, max_sum);\\n        const int lower_by_min = count_bounded_numbers(num1, min_sum - 1);\\n        const int lower_by_range = (lower_by_max - lower_by_min + kMod) % kMod;\\n\\n        int adjusted = 0;\\n        {\\n            int sum = 0;\\n            for (char d : num1) {\\n                sum += (d - \\'0\\');\\n            }\\n            if ((min_sum <= sum) && (sum <= max_sum)) {\\n                adjusted = 1;\\n            }\\n        }\\n\\n        const int result = (upper_by_range - lower_by_range + adjusted + kMod) % kMod;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597437,
                "title": "python-2-edge-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def digit_sum(self, x):\\n        return sum(map(int, str(x)))\\n    def count(self, num1, num2, min_sum, max_sum):\\n        count = 0\\n        modulo = 10**9 + 7\\n\\n        if min_sum > len(num2) * 9:\\n            return 0\\n            \\n        if min_sum == 1 and max_sum > len(num2) * 9:\\n            return (int(num2) - int(num1) + 1) % int(1e9 + 7)\\n\\n        for x in range(int(num1), int(num2) + 1):\\n            if min_sum <= self.digit_sum(x) <= max_sum:\\n                count += 1\\n\\n        return count % modulo\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def digit_sum(self, x):\\n        return sum(map(int, str(x)))\\n    def count(self, num1, num2, min_sum, max_sum):\\n        count = 0\\n        modulo = 10**9 + 7\\n\\n        if min_sum > len(num2) * 9:\\n            return 0\\n            \\n        if min_sum == 1 and max_sum > len(num2) * 9:\\n            return (int(num2) - int(num1) + 1) % int(1e9 + 7)\\n\\n        for x in range(int(num1), int(num2) + 1):\\n            if min_sum <= self.digit_sum(x) <= max_sum:\\n                count += 1\\n\\n        return count % modulo\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597344,
                "title": "python-3-4d-dp-hint-solution-with-explanations",
                "content": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        \\n        M = 10 ** 9 + 7\\n        \\n        # i --> current digit index\\n        # v --> current sum of digits\\n        # exceed --> whether previous leftmost digit exceed the corresponding counterpart at max_sum\\n        # equal --> previous digit all equal\\n        \\n        # exceed and equal combined to check when the built number reaches the same number of digits of num2\\n        # for example: 2123 > 1123; 1675 < 2123\\n        \\n        @cache\\n        def dp(i, v, exceed, equal):\\n            if i == len(target):\\n                return 0\\n\\n            ans = 0\\n            for d in range(int(v == 0), 10):\\n                if v + d > max_sum: break\\n                new_exceed = exceed\\n                new_equal = equal\\n                # if all previous digits equal, then we need to check current digit comparison\\n                if equal:\\n                    # if not equal then this current digit comparison will determine if the built number exceed num2 if reach the same length\\n                    if d != int(target[i]): \\n                        new_equal = False\\n                    # could lead to exceed if built number reach the same length of num2\\n                    if d > int(target[i]): \\n                        new_exceed = True\\n                \\n                # current built number must be\\n                # a) value exceed min_sum\\n                # b) not exceed num2\\n                ans = (ans + int(v + d >= min_sum and not (i + 1 == len(target) and new_exceed)) + dp(i + 1, v + d,\\n                                                                                                      new_exceed, new_equal)) % M\\n            return ans\\n        \\n        \\n        target = num2\\n        upper = dp(0, 0, False, True)\\n        \\n        target = str(int(num1) - 1)\\n        dp.cache_clear()\\n        lower = dp(0, 0, False, True)\\n        \\n        return (upper - lower) % M",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        \\n        M = 10 ** 9 + 7\\n        \\n        # i --> current digit index\\n        # v --> current sum of digits\\n        # exceed --> whether previous leftmost digit exceed the corresponding counterpart at max_sum\\n        # equal --> previous digit all equal\\n        \\n        # exceed and equal combined to check when the built number reaches the same number of digits of num2\\n        # for example: 2123 > 1123; 1675 < 2123\\n        \\n        @cache\\n        def dp(i, v, exceed, equal):\\n            if i == len(target):\\n                return 0\\n\\n            ans = 0\\n            for d in range(int(v == 0), 10):\\n                if v + d > max_sum: break\\n                new_exceed = exceed\\n                new_equal = equal\\n                # if all previous digits equal, then we need to check current digit comparison\\n                if equal:\\n                    # if not equal then this current digit comparison will determine if the built number exceed num2 if reach the same length\\n                    if d != int(target[i]): \\n                        new_equal = False\\n                    # could lead to exceed if built number reach the same length of num2\\n                    if d > int(target[i]): \\n                        new_exceed = True\\n                \\n                # current built number must be\\n                # a) value exceed min_sum\\n                # b) not exceed num2\\n                ans = (ans + int(v + d >= min_sum and not (i + 1 == len(target) and new_exceed)) + dp(i + 1, v + d,\\n                                                                                                      new_exceed, new_equal)) % M\\n            return ans\\n        \\n        \\n        target = num2\\n        upper = dp(0, 0, False, True)\\n        \\n        target = str(int(num1) - 1)\\n        dp.cache_clear()\\n        lower = dp(0, 0, False, True)\\n        \\n        return (upper - lower) % M",
                "codeTag": "Java"
            },
            {
                "id": 3597201,
                "title": "c-digit-dp-simple-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int MinSum, MaxSum, mod = 1e9+7;\\n    int solve(vector<vector<vector<int>>> &dp, string &num, int idx, int curr_sum, int flag)\\n    {\\n        if(dp[idx][curr_sum][flag]!=-1)return dp[idx][curr_sum][flag];\\n        if(idx == num.size())\\n        {\\n            if(!flag && curr_sum >= MinSum)return dp[idx][curr_sum][flag] = 1;\\n            return dp[idx][curr_sum][flag] = 0;\\n        }\\n        long long ans = 0;\\n        if(!flag)\\n        {\\n            for(int i=0;i<=(num[idx]-\\'0\\');i++)\\n            {\\n                if(curr_sum + i <= MaxSum)\\n                {\\n                    ans += solve(dp, num, idx+1,curr_sum + i, 0);\\n                    ans = ans % mod;\\n                }\\n            }\\n            for(int i=1 + (num[idx]-\\'0\\') ;i<10;i++)\\n            {\\n                if(curr_sum + i <= MaxSum)\\n                {\\n                    ans += solve(dp, num, idx+1,curr_sum + i, 1);\\n                    ans = ans % mod;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<(num[idx]-\\'0\\');i++)\\n            {\\n                if(curr_sum + i <= MaxSum)\\n                {\\n                    ans += solve(dp, num, idx+1,curr_sum + i, 0);\\n                    ans = ans % mod;\\n                }\\n            }\\n            for(int i = (num[idx]-\\'0\\') ;i<10;i++)\\n            {\\n                if(curr_sum + i <= MaxSum)\\n                {\\n                    ans += solve(dp, num, idx+1,curr_sum + i, 1);\\n                    ans = ans % mod;\\n                }\\n            }\\n        }\\n        return dp[idx][curr_sum][flag] = ans;\\n    }\\n    // 12334 -->  12333\\n    string decrement(string &s)\\n    {\\n        for(int i=s.size();i>=0;i--)\\n        {\\n            if(s[i] > \\'0\\')\\n            {\\n                s[i]--;\\n                return s;\\n            }\\n            else s[i] = \\'9\\';\\n        }\\n        return s;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum){\\n        num1 = decrement(num1);\\n        reverse(num1.begin(), num1.end());\\n        reverse(num2.begin(), num2.end());\\n        MinSum = min_sum;MaxSum = max_sum;\\n        vector<vector<vector<int>>> dp(23, vector<vector<int>> (200, vector<int> (2, -1)));\\n        vector<vector<vector<int>>> dp2(23, vector<vector<int>> (200, vector<int> (2, -1)));\\n        return (solve(dp, num2, 0, 0, 0) - solve(dp2, num1, 0, 0, 0) + mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MinSum, MaxSum, mod = 1e9+7;\\n    int solve(vector<vector<vector<int>>> &dp, string &num, int idx, int curr_sum, int flag)\\n    {\\n        if(dp[idx][curr_sum][flag]!=-1)return dp[idx][curr_sum][flag];\\n        if(idx == num.size())\\n        {\\n            if(!flag && curr_sum >= MinSum)return dp[idx][curr_sum][flag] = 1;\\n            return dp[idx][curr_sum][flag] = 0;\\n        }\\n        long long ans = 0;\\n        if(!flag)\\n        {\\n            for(int i=0;i<=(num[idx]-\\'0\\');i++)\\n            {\\n                if(curr_sum + i <= MaxSum)\\n                {\\n                    ans += solve(dp, num, idx+1,curr_sum + i, 0);\\n                    ans = ans % mod;\\n                }\\n            }\\n            for(int i=1 + (num[idx]-\\'0\\') ;i<10;i++)\\n            {\\n                if(curr_sum + i <= MaxSum)\\n                {\\n                    ans += solve(dp, num, idx+1,curr_sum + i, 1);\\n                    ans = ans % mod;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<(num[idx]-\\'0\\');i++)\\n            {\\n                if(curr_sum + i <= MaxSum)\\n                {\\n                    ans += solve(dp, num, idx+1,curr_sum + i, 0);\\n                    ans = ans % mod;\\n                }\\n            }\\n            for(int i = (num[idx]-\\'0\\') ;i<10;i++)\\n            {\\n                if(curr_sum + i <= MaxSum)\\n                {\\n                    ans += solve(dp, num, idx+1,curr_sum + i, 1);\\n                    ans = ans % mod;\\n                }\\n            }\\n        }\\n        return dp[idx][curr_sum][flag] = ans;\\n    }\\n    // 12334 -->  12333\\n    string decrement(string &s)\\n    {\\n        for(int i=s.size();i>=0;i--)\\n        {\\n            if(s[i] > \\'0\\')\\n            {\\n                s[i]--;\\n                return s;\\n            }\\n            else s[i] = \\'9\\';\\n        }\\n        return s;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum){\\n        num1 = decrement(num1);\\n        reverse(num1.begin(), num1.end());\\n        reverse(num2.begin(), num2.end());\\n        MinSum = min_sum;MaxSum = max_sum;\\n        vector<vector<vector<int>>> dp(23, vector<vector<int>> (200, vector<int> (2, -1)));\\n        vector<vector<vector<int>>> dp2(23, vector<vector<int>> (200, vector<int> (2, -1)));\\n        return (solve(dp, num2, 0, 0, 0) - solve(dp2, num1, 0, 0, 0) + mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597014,
                "title": "why-tle-on-last-testcase-please-explain",
                "content": "class Solution {\\npublic:\\n    int mod=1e9+7;\\n\\n    // dp-> (idx,sum,is_smaller)\\n    \\n    long long solve(int idx,string &num,int cur,bool is_smaller,int mini,int maxi,vector<vector<vector<long long>>> &dp)\\n    {\\n        if(cur>maxi)\\n            return 0;\\n        if(dp[idx][cur][is_smaller]!=-1)\\n            return dp[idx][cur][is_smaller];\\n\\n        if(idx==num.size())\\n        {\\n            if(cur>=mini && cur<=maxi)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n\\n        long long ans=0;\\n        int end = (is_smaller==true) ? 9 : (num[idx]-\\'0\\');\\n        for(int i=0;i<=end;i++)\\n        {\\n            if(cur+i>maxi)\\n                break;\\n            bool sub_small= (is_smaller==true)?true:(i!=end);\\n            ans+=solve(idx+1,num,cur+i,sub_small,mini,maxi,dp);\\n        }\\n        return dp[idx][cur][is_smaller]=ans;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) \\n    {\\n        \\n        int x=num1.size();\\n        if(num1[x-1]==\\'0\\')\\n        {\\n            num1[x-2]=\\'0\\'+((num1[x-2]-\\'0\\')-1);\\n            num1[x-1]=\\'0\\'+9;\\n        }\\n        else\\n            num1[x-1]=\\'0\\'+((num1[x-1]-\\'0\\')-1);\\n\\n        vector<vector<vector<long long>>> dp1(23,vector<vector<long long>> (401,vector<long long> (2,-1)));\\n        vector<vector<vector<long long>>> dp2(23,vector<vector<long long>> (401,vector<long long> (2,-1)));\\n    \\n        long long ans= (solve(0,num2,0,false,min_sum,max_sum,dp2)-solve(0,num1,0,false,min_sum,max_sum,dp1))%mod;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int mod=1e9+7;\\n\\n    // dp-> (idx,sum,is_smaller)\\n    \\n    long long solve(int idx,string &num,int cur,bool is_smaller,int mini,int maxi,vector<vector<vector<long long>>> &dp)\\n    {\\n        if(cur>maxi)\\n            return 0;\\n        if(dp[idx][cur][is_smaller]!=-1)\\n            return dp[idx][cur][is_smaller];\\n\\n        if(idx==num.size())\\n        {\\n            if(cur>=mini && cur<=maxi)\\n                return 1;\\n            else\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3596899,
                "title": "memoization-java-solution",
                "content": "# Intuition\\nDigit DP\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    int[][][] dp = new int[401][25][2];\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        for (int i = 0; i < 401; i++) {\\n            for (int j = 0; j < 25; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        int count1 = helper(num1, 0, 0, 1, min_sum, max_sum);\\n        for (int i = 0; i < 401; i++) {\\n            for (int j = 0; j < 25; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        int count2 = helper(num2, 0, 0, 1, min_sum, max_sum);\\n\\n        int sum = 0;\\n        for (char ch : num1.toCharArray()) sum += (ch - \\'0\\');\\n        return (count2 - count1 + ((sum <= max_sum && sum >= min_sum) ? 1 : 0)) % mod;\\n    }\\n    private int helper(String num,int sum,int idx,int tight,int min_sum,int max_sum){\\n        if(idx == num.length()){\\n            if(sum >= min_sum && sum <= max_sum) return 1;\\n            return 0;\\n        }\\n        if(dp[sum][idx][tight] != -1) return dp[sum][idx][tight];\\n        int max = tight == 1 ? num.charAt(idx)-\\'0\\' : 9;\\n        int count = 0;\\n        for(int i=0;i<=max;i++){\\n            int newtight = tight == 1 && i == max ? 1 : 0;\\n            count += helper(num,sum + i,idx + 1,newtight,min_sum,max_sum) % mod;\\n            count %= mod;\\n        }\\n        return dp[sum][idx][tight] = count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    int[][][] dp = new int[401][25][2];\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        for (int i = 0; i < 401; i++) {\\n            for (int j = 0; j < 25; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        int count1 = helper(num1, 0, 0, 1, min_sum, max_sum);\\n        for (int i = 0; i < 401; i++) {\\n            for (int j = 0; j < 25; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        int count2 = helper(num2, 0, 0, 1, min_sum, max_sum);\\n\\n        int sum = 0;\\n        for (char ch : num1.toCharArray()) sum += (ch - \\'0\\');\\n        return (count2 - count1 + ((sum <= max_sum && sum >= min_sum) ? 1 : 0)) % mod;\\n    }\\n    private int helper(String num,int sum,int idx,int tight,int min_sum,int max_sum){\\n        if(idx == num.length()){\\n            if(sum >= min_sum && sum <= max_sum) return 1;\\n            return 0;\\n        }\\n        if(dp[sum][idx][tight] != -1) return dp[sum][idx][tight];\\n        int max = tight == 1 ? num.charAt(idx)-\\'0\\' : 9;\\n        int count = 0;\\n        for(int i=0;i<=max;i++){\\n            int newtight = tight == 1 && i == max ? 1 : 0;\\n            count += helper(num,sum + i,idx + 1,newtight,min_sum,max_sum) % mod;\\n            count %= mod;\\n        }\\n        return dp[sum][idx][tight] = count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596656,
                "title": "recursive-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int maxi, mini;\\n    \\n    int rec(int idx, int sum, int en, vector<vector<int>> &dp, int n){\\n        if(idx == n){\\n            if(sum >= mini && sum <= maxi) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][sum] != -1) return dp[idx][sum];\\n        \\n        dp[idx][sum] = 0;\\n        if(idx) en = 10;\\n        \\n        for(int i = 0; i < en; i++){\\n            dp[idx][sum] += rec(idx+1, sum+i, en, dp, n);\\n            dp[idx][sum] %= mod;\\n        }\\n        return dp[idx][sum];\\n    }\\n    \\n    int calc(string &num){\\n        int sum = 0, ans = 0, n = num.size();\\n        for(int i = 0; i < n; i++){\\n            vector<vector<int>> dp(n-i, vector<int>(401, -1));\\n            ans += rec(0, sum, num[i]-\\'0\\', dp, n-i);\\n            ans %= mod;\\n            sum += num[i]-\\'0\\';    \\n        }\\n        return ans;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        maxi = max_sum, mini = min_sum;\\n        \\n        int flag = 0;\\n        for(int i = 0; i < num2.size(); i++) flag += num2[i]-\\'0\\';\\n        if(flag <= maxi && flag >= mini) flag = 1;\\n        else flag = 0;\\n        \\n        \\n        return calc(num2) - calc(num1) + flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int maxi, mini;\\n    \\n    int rec(int idx, int sum, int en, vector<vector<int>> &dp, int n){\\n        if(idx == n){\\n            if(sum >= mini && sum <= maxi) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][sum] != -1) return dp[idx][sum];\\n        \\n        dp[idx][sum] = 0;\\n        if(idx) en = 10;\\n        \\n        for(int i = 0; i < en; i++){\\n            dp[idx][sum] += rec(idx+1, sum+i, en, dp, n);\\n            dp[idx][sum] %= mod;\\n        }\\n        return dp[idx][sum];\\n    }\\n    \\n    int calc(string &num){\\n        int sum = 0, ans = 0, n = num.size();\\n        for(int i = 0; i < n; i++){\\n            vector<vector<int>> dp(n-i, vector<int>(401, -1));\\n            ans += rec(0, sum, num[i]-\\'0\\', dp, n-i);\\n            ans %= mod;\\n            sum += num[i]-\\'0\\';    \\n        }\\n        return ans;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        maxi = max_sum, mini = min_sum;\\n        \\n        int flag = 0;\\n        for(int i = 0; i < num2.size(); i++) flag += num2[i]-\\'0\\';\\n        if(flag <= maxi && flag >= mini) flag = 1;\\n        else flag = 0;\\n        \\n        \\n        return calc(num2) - calc(num1) + flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596612,
                "title": "share-my-dp-solution-in-py3",
                "content": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        @cache\\n        def dp(n,l,r):\\n            if r < 0:\\n                return 0 # pruning\\n            t = len(n)\\n            if t > 1:\\n                while len(n) > 1 and n[0] == \\'0\\':\\n                    n = n[1:] # deleting leading zeros\\n            t = len(n)\\n            if t == 1: # plain case where we exit the ecursion\\n                res = 0\\n                for i in range(min(10,int(n)+1)):\\n                    if l<= i <= r:\\n                        res += 1\\n                return res % (10**9+7)\\n            else:\\n                res = 0\\n                i = int(n[0])\\n                res += dp(n[1:],l-i,r-i) % (10**9+7) # when the first digit matches the limit\\n                res += dp(\\'9\\'*(t-1),l,r)  % (10**9+7) # when the number has less digits than the upper limit\\n                for j in range(1,i):\\n                    res += dp(\\'9\\'*(t-1),l-j,r-j)  % (10**9+7) # when the number has the same length as the upper limit, but the first digit differs\\n                return res % (10**9+7)\\n                \\n        \\n        t2 = dp(num2,min_sum,max_sum)\\n        t1 = dp(str(int(num1)-1),min_sum,max_sum)\\n        return ( t2-t1 )% (10**9+7)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        @cache\\n        def dp(n,l,r):\\n            if r < 0:\\n                return 0 # pruning\\n            t = len(n)\\n            if t > 1:\\n                while len(n) > 1 and n[0] == \\'0\\':\\n                    n = n[1:] # deleting leading zeros\\n            t = len(n)\\n            if t == 1: # plain case where we exit the ecursion\\n                res = 0\\n                for i in range(min(10,int(n)+1)):\\n                    if l<= i <= r:\\n                        res += 1\\n                return res % (10**9+7)\\n            else:\\n                res = 0\\n                i = int(n[0])\\n                res += dp(n[1:],l-i,r-i) % (10**9+7) # when the first digit matches the limit\\n                res += dp(\\'9\\'*(t-1),l,r)  % (10**9+7) # when the number has less digits than the upper limit\\n                for j in range(1,i):\\n                    res += dp(\\'9\\'*(t-1),l-j,r-j)  % (10**9+7) # when the number has the same length as the upper limit, but the first digit differs\\n                return res % (10**9+7)\\n                \\n        \\n        t2 = dp(num2,min_sum,max_sum)\\n        t1 = dp(str(int(num1)-1),min_sum,max_sum)\\n        return ( t2-t1 )% (10**9+7)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596541,
                "title": "digit-dp-recursion-memoization",
                "content": "# Intuition\\n**DIGIT DP will be used**\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n**Recursion,Digit Dynamic Programming,C++**\\n\\n**->** I have implemented a Function it will count numbers which have sum >=minsum & sum <=maxsum .\\n**->** Therefore First count till num1 and then count till num2\\n**->** Here if num1 will hold the true condition then it will be removed  therefore checking it and store 1 if it it hold the condition else 0.\\n**->** Now count till num2 -count till num1 +(1 if alone num1 holds the condition else 0) \\n# TIME Complexity\\n\\n- O(max(len(num1),len(num2))*(MAXSUM=198)*10)\\n# SPACE Complexity\\n- O(max(len(num1),len(num2))*2*(MAXSUM=198))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// MAX SUM =198(22 DIGITS THEREFORE  ALL 9 MAX SUM=22*9=198)\\nint dp[23][2][199];// DP ARRAY [MAX DIGITS][0 OR 1 FOR LAST VALUE INCURRED][MAX SUM]\\nint mo=1e9+7;\\nint min_sum;\\nint max_sum;\\nint go(int i,bool last,int j,string z){\\n// BASE CONDITION \\nif(i==z.size()){\\n    \\nreturn j<=max_sum&&j>=min_sum;\\n    }\\n// MEMOIZED VALUES\\n    if(dp[i][last][j]!=0){\\n    return dp[i][last][j];\\n    }\\n\\n    int ans=0;\\n     \\n    int till=last?z[i]-\\'0\\':9;\\n    //ITTERATING OVER ALL VALUES TILL N \\n\\n    for(int k=0;k<=till;k++){ \\n\\n        ans+=(go(i+1,last&&(till==k),(j+k),z));\\n         ans=ans%mo; \\n                             }\\n\\n         //MEMOIZATION\\n         return dp[i][last][j]=ans; \\n         \\n         } \\n         \\n int count(string num1, string num2, int mini, int maxi) { \\n     //BASE CONDITION\\n     if(mini>198){\\n        return 0;\\n        }\\n        min_sum=mini;\\n        max_sum=maxi;\\n        string s=num1;\\n        string s1=num2;\\n       //SETTING ALL VALUES IN DP ARRAY 0\\n        memset(dp,0,sizeof(dp));\\n\\n        // COUNT TILL NUM2\\n        int a2=(go(0,1,0,s1));\\n        int a1=0;\\n        for(int i=0;i<s.length();i++){ a1+=(s[i]-\\'0\\'); }\\n        // CHECKING FOR NUM1 IF IT HAS CONDITION\\n         a1=(a1>=min_sum&a1<=max_sum);\\n         \\n       //SETTING ALL VALUES IN DP ARRAY 0\\n          memset(dp,0,(sizeof(dp))); \\n          \\n        // COUNT TILL NUM1\\n          int z2=(go(0,1,0,s)); \\n          //SUBTRATCING Z2(COUNT TILL NUM1) FROM A2 (COUNT TILL NUM2) \\n          //AND\\n          // ADDING   NUM1  IF IT HOLDS TRUE FOR CONDITION \\n          return (a2-z2+(a1))%mo; \\n          } \\n          \\n          \\n          };\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// MAX SUM =198(22 DIGITS THEREFORE  ALL 9 MAX SUM=22*9=198)\\nint dp[23][2][199];// DP ARRAY [MAX DIGITS][0 OR 1 FOR LAST VALUE INCURRED][MAX SUM]\\nint mo=1e9+7;\\nint min_sum;\\nint max_sum;\\nint go(int i,bool last,int j,string z){\\n// BASE CONDITION \\nif(i==z.size()){\\n    \\nreturn j<=max_sum&&j>=min_sum;\\n    }\\n// MEMOIZED VALUES\\n    if(dp[i][last][j]!=0){\\n    return dp[i][last][j];\\n    }\\n\\n    int ans=0;\\n     \\n    int till=last?z[i]-\\'0\\':9;\\n    //ITTERATING OVER ALL VALUES TILL N \\n\\n    for(int k=0;k<=till;k++){ \\n\\n        ans+=(go(i+1,last&&(till==k),(j+k),z));\\n         ans=ans%mo; \\n                             }\\n\\n         //MEMOIZATION\\n         return dp[i][last][j]=ans; \\n         \\n         } \\n         \\n int count(string num1, string num2, int mini, int maxi) { \\n     //BASE CONDITION\\n     if(mini>198){\\n        return 0;\\n        }\\n        min_sum=mini;\\n        max_sum=maxi;\\n        string s=num1;\\n        string s1=num2;\\n       //SETTING ALL VALUES IN DP ARRAY 0\\n        memset(dp,0,sizeof(dp));\\n\\n        // COUNT TILL NUM2\\n        int a2=(go(0,1,0,s1));\\n        int a1=0;\\n        for(int i=0;i<s.length();i++){ a1+=(s[i]-\\'0\\'); }\\n        // CHECKING FOR NUM1 IF IT HAS CONDITION\\n         a1=(a1>=min_sum&a1<=max_sum);\\n         \\n       //SETTING ALL VALUES IN DP ARRAY 0\\n          memset(dp,0,(sizeof(dp))); \\n          \\n        // COUNT TILL NUM1\\n          int z2=(go(0,1,0,s)); \\n          //SUBTRATCING Z2(COUNT TILL NUM1) FROM A2 (COUNT TILL NUM2) \\n          //AND\\n          // ADDING   NUM1  IF IT HOLDS TRUE FOR CONDITION \\n          return (a2-z2+(a1))%mo; \\n          } \\n          \\n          \\n          };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596437,
                "title": "python-easy-solution-using-digit-dp",
                "content": "\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, mins: int, maxs: int) -> int:\\n        \\n        dp = defaultdict(int)\\n        def find(i, s, t):\\n            if num==\\'0\\': return 0\\n            if i==0:\\n                return 1 if mins<=s<=maxs else 0\\n            if s>maxs: return 0\\n            if (i,s,t) not in dp:\\n                res = 0\\n                if t:\\n                    v = 0\\n                    for v in range(int(num[len(num)-i])):\\n                        res += find(i-1, s+v, 0)\\n                    if int(num[len(num)-i])>0:\\n                        res += find(i-1, s+v+1, 1)\\n                    else:\\n                        res += find(i-1, s+v, 1)\\n                else:\\n                    for v in range(10):\\n                        res += find(i-1, s+v, 0)\\n                dp[i,s,t] = res\\n            return dp[i,s,t]\\n        \\n        num = num2\\n        r2 = find(len(num2), 0, 1)\\n        dp = defaultdict(int)\\n        num = str(int(num1)-1)\\n        r1 = find(len(num), 0, 1)\\n        return (r2-r1)%1000000007\\n\\n```\\n\\n\\nUsing lru_cache\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, mins: int, maxs: int) -> int:\\n        \\n        dp = defaultdict(int)\\n        @lru_cache(None)\\n        def find(i, s, t):\\n            if num==\\'0\\': return 0\\n            if i==0:\\n                return 1 if mins<=s<=maxs else 0\\n            if s>maxs: return 0\\n            res = 0\\n            if t:\\n                v = 0\\n                for v in range(int(num[len(num)-i])):\\n                    res += find(i-1, s+v, 0)\\n                if int(num[len(num)-i])>0:\\n                    res += find(i-1, s+v+1, 1)\\n                else:\\n                    res += find(i-1, s+v, 1)\\n            else:\\n                for v in range(10):\\n                    res += find(i-1, s+v, 0)\\n            return res\\n        \\n        num = num2\\n        r2 = find(len(num2), 0, 1)\\n        find.cache_clear()\\n        num = str(int(num1)-1)\\n        r1 = find(len(num), 0, 1)\\n        return (r2-r1)%1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, mins: int, maxs: int) -> int:\\n        \\n        dp = defaultdict(int)\\n        def find(i, s, t):\\n            if num==\\'0\\': return 0\\n            if i==0:\\n                return 1 if mins<=s<=maxs else 0\\n            if s>maxs: return 0\\n            if (i,s,t) not in dp:\\n                res = 0\\n                if t:\\n                    v = 0\\n                    for v in range(int(num[len(num)-i])):\\n                        res += find(i-1, s+v, 0)\\n                    if int(num[len(num)-i])>0:\\n                        res += find(i-1, s+v+1, 1)\\n                    else:\\n                        res += find(i-1, s+v, 1)\\n                else:\\n                    for v in range(10):\\n                        res += find(i-1, s+v, 0)\\n                dp[i,s,t] = res\\n            return dp[i,s,t]\\n        \\n        num = num2\\n        r2 = find(len(num2), 0, 1)\\n        dp = defaultdict(int)\\n        num = str(int(num1)-1)\\n        r1 = find(len(num), 0, 1)\\n        return (r2-r1)%1000000007\\n\\n```\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, mins: int, maxs: int) -> int:\\n        \\n        dp = defaultdict(int)\\n        @lru_cache(None)\\n        def find(i, s, t):\\n            if num==\\'0\\': return 0\\n            if i==0:\\n                return 1 if mins<=s<=maxs else 0\\n            if s>maxs: return 0\\n            res = 0\\n            if t:\\n                v = 0\\n                for v in range(int(num[len(num)-i])):\\n                    res += find(i-1, s+v, 0)\\n                if int(num[len(num)-i])>0:\\n                    res += find(i-1, s+v+1, 1)\\n                else:\\n                    res += find(i-1, s+v, 1)\\n            else:\\n                for v in range(10):\\n                    res += find(i-1, s+v, 0)\\n            return res\\n        \\n        num = num2\\n        r2 = find(len(num2), 0, 1)\\n        find.cache_clear()\\n        num = str(int(num1)-1)\\n        r1 = find(len(num), 0, 1)\\n        return (r2-r1)%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596355,
                "title": "digit-dp-template",
                "content": "**What are we finding** : numbers between num1 & num2 with digitsum <=x\\n\\n**Approach**\\nCount numbers between num1 & num2 with digitsum <= max_sum (a)\\nCount numbers between num1 & num2 with digitsum <= min_sum-1 (b)\\na-b is the answer\\n\\n\\n\\tThe variables tight1 and tight2 are used to keep track of whether the chosen digits so far are the lowest possible (in num1) and highest possible (in num2), respectively.\\n\\n**tight1 && (digit == lowerBound)**  : denotes if we are a index that has tight1 and we select a digit equal to lower bound so the next stae will also be tight for tight1;\\nsimilarly for tight2 using upper bound\\n```\\n\\n#define ll long long\\nconst ll MOD = 1e9 + 7;\\nclass Solution\\n{\\n    private:\\n    \\n//     Constraints:\\n// 1 <= num1 <= num2 <= 1022\\n// 1 <= min_sum <= max_sum <= 400\\n    \\n// Max number of digits for a number =22\\n// Max range of tight1=(true/false) =2\\n// Max range of tight2=(true/false) =2\\n// Max sum for a number =400        \\n    \\n    ll dp[23][2][2][401];\\n\\n    public:\\n\\n        ll countString(ll ind, bool tight1, bool tight2, ll sum, string &num1, string &num2)\\n        {\\n            // if sum < 0 that that sum is not valid\\n            if (sum < 0)\\n                return 0;\\n            \\n            // if we reached the last index and sum>0 than that number satisfy the conditions\\n            if (ind == num2.size())\\n                return 1;\\n\\n            \\n            if (dp[ind][tight1][tight2][sum] != -1)\\n                return dp[ind][tight1][tight2][sum];\\n\\n            // lower and upper bound from value of tight1 and tight 2\\n            ll lowerBound = tight1 ? num1[ind] - \\'0\\' : 0;\\n            ll upperBound = tight2 ? num2[ind] - \\'0\\' : 9;\\n\\n            \\n            ll count = 0;\\n            for (ll digit = lowerBound; digit <= upperBound; digit++)\\n            {\\n                count += countString(ind + 1, tight1 && (digit == lowerBound), tight2 && (digit == upperBound), sum - digit, num1, num2);\\n                count %= MOD;\\n            }\\n\\n            return dp[ind][tight1][tight2][sum] = count;\\n        }\\n    int count(string num1, string num2, int min_sum, int max_sum)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n\\n        string extendedNum1 = string(num2.size() - num1.size(), \\'0\\') + num1;\\n\\n        // making num1 size similat to num2 by adding 0 in front if required\\n        ll ValidNumberLessThanMaxSum = countString(0, 1, 1, max_sum, extendedNum1, num2);\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        ll ValidNumberLessThanMinSum = countString(0, 1, 1, min_sum - 1, extendedNum1, num2);\\n\\n        ll answer = (ValidNumberLessThanMaxSum - ValidNumberLessThanMinSum + MOD) % MOD;\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\n#define ll long long\\nconst ll MOD = 1e9 + 7;\\nclass Solution\\n{\\n    private:\\n    \\n//     Constraints:\\n// 1 <= num1 <= num2 <= 1022\\n// 1 <= min_sum <= max_sum <= 400\\n    \\n// Max number of digits for a number =22\\n// Max range of tight1=(true/false) =2\\n// Max range of tight2=(true/false) =2\\n// Max sum for a number =400        \\n    \\n    ll dp[23][2][2][401];\\n\\n    public:\\n\\n        ll countString(ll ind, bool tight1, bool tight2, ll sum, string &num1, string &num2)\\n        {\\n            // if sum < 0 that that sum is not valid\\n            if (sum < 0)\\n                return 0;\\n            \\n            // if we reached the last index and sum>0 than that number satisfy the conditions\\n            if (ind == num2.size())\\n                return 1;\\n\\n            \\n            if (dp[ind][tight1][tight2][sum] != -1)\\n                return dp[ind][tight1][tight2][sum];\\n\\n            // lower and upper bound from value of tight1 and tight 2\\n            ll lowerBound = tight1 ? num1[ind] - \\'0\\' : 0;\\n            ll upperBound = tight2 ? num2[ind] - \\'0\\' : 9;\\n\\n            \\n            ll count = 0;\\n            for (ll digit = lowerBound; digit <= upperBound; digit++)\\n            {\\n                count += countString(ind + 1, tight1 && (digit == lowerBound), tight2 && (digit == upperBound), sum - digit, num1, num2);\\n                count %= MOD;\\n            }\\n\\n            return dp[ind][tight1][tight2][sum] = count;\\n        }\\n    int count(string num1, string num2, int min_sum, int max_sum)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n\\n        string extendedNum1 = string(num2.size() - num1.size(), \\'0\\') + num1;\\n\\n        // making num1 size similat to num2 by adding 0 in front if required\\n        ll ValidNumberLessThanMaxSum = countString(0, 1, 1, max_sum, extendedNum1, num2);\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        ll ValidNumberLessThanMinSum = countString(0, 1, 1, min_sum - 1, extendedNum1, num2);\\n\\n        ll answer = (ValidNumberLessThanMaxSum - ValidNumberLessThanMinSum + MOD) % MOD;\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596339,
                "title": "c-bottom-up-dp",
                "content": "# Intuition\\nForm hint\\n\\nLet f(n, l, r) denotes the number of integers from 1 to n with the sum of digits between l and r.\\n\\nThe answer is f(num2, min_sum, max_sum) - f(num1, min_sum, max_sum) + check(num1).\\n\\n# Approach\\nDP (dfs + memoization)\\n\\n# Complexity\\n- Time complexity: num.size() * max_sum\\n\\n- Space complexity: num.size() * max_sum\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int l = 0, r = 0;\\n    int dp[24][410][2] = {0};\\n    int MOD = 1e9 + 7;\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        l = min_sum;\\n        r = max_sum;\\n\\n        memset(dp, -1, sizeof(dp));\\n        int a = dfs(0, 0, 1, num1);\\n\\n        memset(dp, -1, sizeof(dp));\\n        int b = dfs(0, 0, 1, num2);\\n\\n        int c = check(num1);\\n        \\n        return b - a + c;\\n    }\\n\\n    int check(string num) {\\n        int sum = 0;\\n        for (auto n : num)\\n            sum += (n - \\'0\\');\\n        return l <= sum && sum <= r;\\n    }\\n\\n    int dfs (int i, int cur, int bound, string num) {\\n        int x = -1;\\n        int res = 0;\\n\\n        if (cur > r) \\n            return 0;\\n\\n        if (i == num.size()) \\n            return cur >= l;\\n\\n        if (dp[i][cur][bound] != -1) \\n            return dp[i][cur][bound];\\n\\n        x = num[i] - \\'0\\';\\n        if (bound) {\\n            // choose equal\\n            res += dfs(i + 1, cur + x, 1, num);\\n            res %= MOD;\\n            // choose smaller\\n            for (int y = 0; y < x; y++) {\\n                res += dfs(i + 1, cur + y, 0, num); \\n                res %= MOD;\\n            }\\n        } else {\\n            // choose any\\n            for (int y = 0; y <= 9; y++) {\\n                res += dfs(i + 1, cur + y, 0, num); \\n                res %= MOD;\\n            }\\n        }\\n\\n        return dp[i][cur][bound] = res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int l = 0, r = 0;\\n    int dp[24][410][2] = {0};\\n    int MOD = 1e9 + 7;\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        l = min_sum;\\n        r = max_sum;\\n\\n        memset(dp, -1, sizeof(dp));\\n        int a = dfs(0, 0, 1, num1);\\n\\n        memset(dp, -1, sizeof(dp));\\n        int b = dfs(0, 0, 1, num2);\\n\\n        int c = check(num1);\\n        \\n        return b - a + c;\\n    }\\n\\n    int check(string num) {\\n        int sum = 0;\\n        for (auto n : num)\\n            sum += (n - \\'0\\');\\n        return l <= sum && sum <= r;\\n    }\\n\\n    int dfs (int i, int cur, int bound, string num) {\\n        int x = -1;\\n        int res = 0;\\n\\n        if (cur > r) \\n            return 0;\\n\\n        if (i == num.size()) \\n            return cur >= l;\\n\\n        if (dp[i][cur][bound] != -1) \\n            return dp[i][cur][bound];\\n\\n        x = num[i] - \\'0\\';\\n        if (bound) {\\n            // choose equal\\n            res += dfs(i + 1, cur + x, 1, num);\\n            res %= MOD;\\n            // choose smaller\\n            for (int y = 0; y < x; y++) {\\n                res += dfs(i + 1, cur + y, 0, num); \\n                res %= MOD;\\n            }\\n        } else {\\n            // choose any\\n            for (int y = 0; y <= 9; y++) {\\n                res += dfs(i + 1, cur + y, 0, num); \\n                res %= MOD;\\n            }\\n        }\\n\\n        return dp[i][cur][bound] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596278,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n2 * n2)\\n * Space Complexity: O(n2 * n2)\\n * where `n2` is the length of the string `num2`\\n */\\nclass Solution {\\n private:\\n  static constexpr char zero = \\'0\\';\\n  static constexpr int max_digit = 9;\\n  static constexpr int mod = 1000000007;\\n  \\n public:\\n  int count(const string &num1, const string &num2, const int min_sum, const int max_sum) {\\n    const int n1 = static_cast<int>(num1.size());\\n    const int n2 = static_cast<int>(num2.size());\\n    const string number1 = string(n2 - n1, zero) + num1;\\n    const string &number2 = num2;\\n    const int max_digit_sum = max_digit * n2;\\n    vector<vector<int>> memo(n2, vector<int>(max_digit_sum + 1, -1));\\n    const int r2 = dfs(number2, min_sum, max_sum, 0, 0, true, memo);\\n    const int r1 = dfs(number1, min_sum, max_sum, 0, 0, true, memo);\\n    const int delta = valid(min_sum, max_sum, num1) ? 1 : 0;\\n    return (mod + r2 - r1 + delta) % mod;\\n  }\\n  \\n private:\\n  int dfs(const string &num,\\n          const int min_sum,\\n          const int max_sum,\\n          const int index,\\n          const int digit_sum,\\n          const bool has_constraints,\\n          vector<vector<int>> &memo) {\\n    if (digit_sum > max_sum) {\\n      return 0;\\n    }\\n    \\n    const int n = static_cast<int>(num.size());\\n    if (index == n) {\\n      return min_sum <= digit_sum ? 1 : 0;\\n    }\\n    \\n    int ret = has_constraints ? -1 : memo[index][digit_sum];\\n    if (ret != -1) {\\n      return ret;\\n    }\\n    \\n    ret = 0;\\n    const int digit = num[index] - zero;\\n    for (int d = 0; d < (has_constraints ? digit : max_digit) + 1; ++d) {\\n      ret = (ret + dfs(num, min_sum, max_sum, index + 1, digit_sum + d, (has_constraints && d == digit), memo)) % mod;\\n    }\\n    \\n    if (!has_constraints) {\\n      memo[index][digit_sum] = ret;\\n    }\\n    return ret;\\n  }\\n  \\n  bool valid(const int min_sum, const int max_sum, const string &num) {\\n    int digit_sum = 0;\\n    for (const char c : num) {\\n      digit_sum += c - zero;\\n    }\\n    return min_sum <= digit_sum && digit_sum <= max_sum;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n2 * n2)\\n * Space Complexity: O(n2 * n2)\\n * where `n2` is the length of the string `num2`\\n */\\nclass Solution {\\n private:\\n  static constexpr char zero = \\'0\\';\\n  static constexpr int max_digit = 9;\\n  static constexpr int mod = 1000000007;\\n  \\n public:\\n  int count(const string &num1, const string &num2, const int min_sum, const int max_sum) {\\n    const int n1 = static_cast<int>(num1.size());\\n    const int n2 = static_cast<int>(num2.size());\\n    const string number1 = string(n2 - n1, zero) + num1;\\n    const string &number2 = num2;\\n    const int max_digit_sum = max_digit * n2;\\n    vector<vector<int>> memo(n2, vector<int>(max_digit_sum + 1, -1));\\n    const int r2 = dfs(number2, min_sum, max_sum, 0, 0, true, memo);\\n    const int r1 = dfs(number1, min_sum, max_sum, 0, 0, true, memo);\\n    const int delta = valid(min_sum, max_sum, num1) ? 1 : 0;\\n    return (mod + r2 - r1 + delta) % mod;\\n  }\\n  \\n private:\\n  int dfs(const string &num,\\n          const int min_sum,\\n          const int max_sum,\\n          const int index,\\n          const int digit_sum,\\n          const bool has_constraints,\\n          vector<vector<int>> &memo) {\\n    if (digit_sum > max_sum) {\\n      return 0;\\n    }\\n    \\n    const int n = static_cast<int>(num.size());\\n    if (index == n) {\\n      return min_sum <= digit_sum ? 1 : 0;\\n    }\\n    \\n    int ret = has_constraints ? -1 : memo[index][digit_sum];\\n    if (ret != -1) {\\n      return ret;\\n    }\\n    \\n    ret = 0;\\n    const int digit = num[index] - zero;\\n    for (int d = 0; d < (has_constraints ? digit : max_digit) + 1; ++d) {\\n      ret = (ret + dfs(num, min_sum, max_sum, index + 1, digit_sum + d, (has_constraints && d == digit), memo)) % mod;\\n    }\\n    \\n    if (!has_constraints) {\\n      memo[index][digit_sum] = ret;\\n    }\\n    return ret;\\n  }\\n  \\n  bool valid(const int min_sum, const int max_sum, const string &num) {\\n    int digit_sum = 0;\\n    for (const char c : num) {\\n      digit_sum += c - zero;\\n    }\\n    return min_sum <= digit_sum && digit_sum <= max_sum;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596239,
                "title": "easy-to-understand-but-difficult-to-implement-why",
                "content": "# Intuition\\nIt\\'s enough to find number of numbers   $$\\\\le$$`num` and with digit sum $$\\\\le$$`sum`.\\n $$f([l,r],[s_{min},s_{max}]])=f(r,[s_{min},s_{max}])-f(l-1,[s_{min},s_{max}])=$$ \\n$$f(r,s_{max})-f(r,s_{min}-1)-(f(l-1,s_{max})-f(l-1,s_{min}-1))$$.\\n\\n# Approach\\n\\n`f(\"503\",sum)`  `->` `f(\"[<=4]99\",sum-[<=4])`(dp) $$+$$ `f(\"03\",sum-5)`(rec)\\n\\nIf someone have an idea, why it\\'s difficult to implement this approach during a contest, a comment is welcomed.\\n\\nBelow is an n-th c++ implementation with unrolled recursion into a simple loop.\\n\\n`dp[n][sum]` - how many numbers of length exactly n are there with digit sum $$\\\\le$$ `sum`.\\n# Complexity\\n- Time complexity: $$O(log_{base}(n)\\\\cdot base)=O(log(n))$$ for recursion part,\\n$$O(log_{base}(n)\\\\cdot ((base-1)\\\\cdot log_{base}(n))\\\\cdot base) = O(log^2(n))$$ for dynamic programming part.\\n\\n- Space complexity: $$O(log^2(n))$$\\n\\n# Code\\n```\\nconstexpr int M{1000000007};\\nclass Solution {\\npublic:\\n    int count(string n1, string n2, int min_sum, int max_sum) {\\n        vector<vector<int>> dp(n2.size(),vector<int>(max_sum + 1)); dp[0][0]=1;\\n        for(int i{1}; i<(int)n2.size(); ++i)\\n            for(int j{}; j<(int)dp[0].size(); ++j){\\n                long long  acc{};\\n                for(int k{}, constraint{min(j,9)}; k<=constraint; ++k)\\n                    acc += dp[i-1][j-k];\\n                dp[i][j] = acc % M;\\n            }\\n        for(auto&dp : dp)\\n            for(int p{}; auto& dp : dp)\\n                p = dp = (dp + p) % M;\\n        auto prefix = [&dp](string& s, int sum)->int{\\n            int n{(int)s.size()};\\n            long long r{};\\n            for(int i{}, digit; i<n-1; ++i){\\n                digit = s[i] - \\'0\\';\\n                for(int k{}; k<digit && sum>=k; ++k)\\n                    r += dp[n-1-i][sum-k];\\n                sum -= digit;\\n            }\\n            if(sum>=0)\\n                r+=min(s.back()-\\'0\\', sum)+1;\\n            return r % M;\\n        };\\n        auto decrement = [](string s){\\n            size_t i{s.find_last_not_of(\\'0\\')};\\n            if(i!=string::npos){\\n                --s[i];\\n                fill(s.begin()+i+1, s.end(), \\'9\\');\\n            }\\n            return s;\\n        };\\n        string n0{decrement(n1)};\\n        return (prefix(n2,max_sum)-prefix(n2,min_sum-1)-(n1!=\"0\"?prefix(n0,max_sum)-prefix(n0,min_sum-1):0))%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Prefix Sum"
                ],
                "code": "```\\nconstexpr int M{1000000007};\\nclass Solution {\\npublic:\\n    int count(string n1, string n2, int min_sum, int max_sum) {\\n        vector<vector<int>> dp(n2.size(),vector<int>(max_sum + 1)); dp[0][0]=1;\\n        for(int i{1}; i<(int)n2.size(); ++i)\\n            for(int j{}; j<(int)dp[0].size(); ++j){\\n                long long  acc{};\\n                for(int k{}, constraint{min(j,9)}; k<=constraint; ++k)\\n                    acc += dp[i-1][j-k];\\n                dp[i][j] = acc % M;\\n            }\\n        for(auto&dp : dp)\\n            for(int p{}; auto& dp : dp)\\n                p = dp = (dp + p) % M;\\n        auto prefix = [&dp](string& s, int sum)->int{\\n            int n{(int)s.size()};\\n            long long r{};\\n            for(int i{}, digit; i<n-1; ++i){\\n                digit = s[i] - \\'0\\';\\n                for(int k{}; k<digit && sum>=k; ++k)\\n                    r += dp[n-1-i][sum-k];\\n                sum -= digit;\\n            }\\n            if(sum>=0)\\n                r+=min(s.back()-\\'0\\', sum)+1;\\n            return r % M;\\n        };\\n        auto decrement = [](string s){\\n            size_t i{s.find_last_not_of(\\'0\\')};\\n            if(i!=string::npos){\\n                --s[i];\\n                fill(s.begin()+i+1, s.end(), \\'9\\');\\n            }\\n            return s;\\n        };\\n        string n0{decrement(n1)};\\n        return (prefix(n2,max_sum)-prefix(n2,min_sum-1)-(n1!=\"0\"?prefix(n0,max_sum)-prefix(n0,min_sum-1):0))%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596172,
                "title": "digit-dp-top-down-c",
                "content": "\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    const int m= 1e9+7;\\n    int dp[23][2][2][401];\\n    typedef long long ll;\\n    int f(int ind, string &num1,string &num2, bool left_istight, bool right_istight, int sum){\\n        \\n        if(sum < 0) return 0;\\n        if(ind == num2.size())\\n            return 1;\\n        if(dp[ind][left_istight][right_istight][sum] != -1)\\n            return dp[ind][left_istight][right_istight][sum]%m;\\n        \\n        int low=  (left_istight) ? num1[ind]-\\'0\\' : 0;\\n        int high= (right_istight) ? num2[ind]-\\'0\\':  9;\\n        ll count=0;\\n        for(int num= low; num <= high; num++){\\n            count+= f(ind+1, num1, num2, left_istight & (num == low), right_istight & (num == high), sum-num)%m;\\n        }\\n        return dp[ind][left_istight][right_istight][sum]= count;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof(dp));\\n        int s1= num1.size(); int s2= num2.size();\\n        int diff= s2-s1;\\n        reverse(begin(num1),end(num1));\\n        while(diff--) num1+= \\'0\\';\\n        reverse(begin(num1),end(num1));\\n        int cnt1= f(0,num1,num2,1,1,max_sum);\\n        int cnt2= f(0,num1,num2,1,1,min_sum-1);\\n        return (cnt1-cnt2+m)%m;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    const int m= 1e9+7;\\n    int dp[23][2][2][401];\\n    typedef long long ll;\\n    int f(int ind, string &num1,string &num2, bool left_istight, bool right_istight, int sum){\\n        \\n        if(sum < 0) return 0;\\n        if(ind == num2.size())\\n            return 1;\\n        if(dp[ind][left_istight][right_istight][sum] != -1)\\n            return dp[ind][left_istight][right_istight][sum]%m;\\n        \\n        int low=  (left_istight) ? num1[ind]-\\'0\\' : 0;\\n        int high= (right_istight) ? num2[ind]-\\'0\\':  9;\\n        ll count=0;\\n        for(int num= low; num <= high; num++){\\n            count+= f(ind+1, num1, num2, left_istight & (num == low), right_istight & (num == high), sum-num)%m;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3596162,
                "title": "dp-o-max-sum-num2-lenght",
                "content": "# Intuition\\nRecurrsively find all the numbers between num1 and num2 and if there digit sum satifies the given codition count them.\\n\\n# Complexity\\n- Time complexity:\\n$$O(max\\\\_sum * num2.lenght())$$\\n\\n- Space complexity:\\n$$O(max\\\\_sum * num2.lenght())$$\\n\\n# Code\\n```\\nclass Solution\\n{\\nprivate:\\n    int MOD = 1e9 + 7;\\n    int rec(vector<vector<vector<vector<int>>>> &dp, string &num1, string &num2, int maxSum, int minSum, int idx, int sum, bool cn1, bool cn2)\\n    {\\n// If the previous digits of the current number are equal to the previous digits of num1, \\n// cn1 will be true. This variable is used to determine the starting point of a digit at index idx.\\n\\n// similarly, If the previous digits of the current number are equal to the previous digits of num2, \\n// cn2 will be to true. This variable is used to determine the ending point of a digit at index idx.\\n        if (idx >= num1.size())\\n            return sum >= minSum && sum <= maxSum;\\n        else if (dp[idx][sum][cn1][cn2] != -1)\\n            return dp[idx][sum][cn1][cn2];\\n\\n        int limit = min(maxSum - sum, idx != 0 && !cn2 ? 9 : num2[idx] - 48);\\n\\n        int ans = 0;\\n        for (int i = idx != 0 && !cn1 ? 0 : num1[idx] - 48; i <= limit; i++)\\n            ans = (ans + rec(dp, num1, num2, maxSum, minSum, idx + 1, sum + i, cn1 ? num1[idx] - 48 == i : cn1, cn2 ? num2[idx] - 48 == i : cn2)) % MOD;\\n\\n        return dp[idx][sum][cn1][cn2] = ans;\\n    }\\n\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum)\\n    {\\n// Sanitizing the inputs so that they are of equal lengths\\n        string num1Mod;\\n        while (num1.size() > num2.size())\\n            num1 = num1.substr(1, num1.size() - 1);\\n        for (int i = 0; i < num2.size() - num1.size(); i++)\\n            num1Mod.push_back(\\'0\\');\\n        num1Mod.append(num1);\\n\\n        vector<vector<vector<vector<int>>>> dp(num1Mod.size(), vector<vector<vector<int>>>(max_sum + 1, vector<vector<int>>(2, vector<int>(2, -1))));\\n        return rec(dp, num1Mod, num2, max_sum, min_sum, 0, 0, true, true);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    int MOD = 1e9 + 7;\\n    int rec(vector<vector<vector<vector<int>>>> &dp, string &num1, string &num2, int maxSum, int minSum, int idx, int sum, bool cn1, bool cn2)\\n    {\\n// If the previous digits of the current number are equal to the previous digits of num1, \\n// cn1 will be true. This variable is used to determine the starting point of a digit at index idx.\\n\\n// similarly, If the previous digits of the current number are equal to the previous digits of num2, \\n// cn2 will be to true. This variable is used to determine the ending point of a digit at index idx.\\n        if (idx >= num1.size())\\n            return sum >= minSum && sum <= maxSum;\\n        else if (dp[idx][sum][cn1][cn2] != -1)\\n            return dp[idx][sum][cn1][cn2];\\n\\n        int limit = min(maxSum - sum, idx != 0 && !cn2 ? 9 : num2[idx] - 48);\\n\\n        int ans = 0;\\n        for (int i = idx != 0 && !cn1 ? 0 : num1[idx] - 48; i <= limit; i++)\\n            ans = (ans + rec(dp, num1, num2, maxSum, minSum, idx + 1, sum + i, cn1 ? num1[idx] - 48 == i : cn1, cn2 ? num2[idx] - 48 == i : cn2)) % MOD;\\n\\n        return dp[idx][sum][cn1][cn2] = ans;\\n    }\\n\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum)\\n    {\\n// Sanitizing the inputs so that they are of equal lengths\\n        string num1Mod;\\n        while (num1.size() > num2.size())\\n            num1 = num1.substr(1, num1.size() - 1);\\n        for (int i = 0; i < num2.size() - num1.size(); i++)\\n            num1Mod.push_back(\\'0\\');\\n        num1Mod.append(num1);\\n\\n        vector<vector<vector<vector<int>>>> dp(num1Mod.size(), vector<vector<vector<int>>>(max_sum + 1, vector<vector<int>>(2, vector<int>(2, -1))));\\n        return rec(dp, num1Mod, num2, max_sum, min_sum, 0, 0, true, true);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596135,
                "title": "iterative-digit-dp-beats-100-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nfun(x)=count no fo numbers  from 0 to x having sum within range [mnsum, mxsum ]\\n\\nnow , ans = fun(num2)-fun(num1) , if num1 is within range then increment ans by 1\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define deb(x) cout<<#x<<\" \"<<x<<endl;\\n    \\n    // numbers from 0 to x having sum\\n    const int mod=1e9+7;\\n    \\n    int fun(string &s,int mnsum,int mxsum)\\n    {\\n        \\n        int n=s.length();\\n        \\n        int dp[n+1][mxsum+1][2];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=mxsum;j++)\\n                dp[i][j][0]=dp[i][j][1]=0;\\n        }\\n        dp[0][0][0]=1,dp[0][0][1]=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int digit= (s[n-1-i]-\\'0\\');\\n            for(int j=0;j<=mxsum;j++)\\n            {\\n                for(int d=0;d<10;d++)\\n                {\\n                    if(j+d>mxsum)\\n                        break;\\n                    \\n                    dp[i+1][j+d][0]+=dp[i][j][0];\\n                    dp[i+1][j+d][0]%=mod;\\n                    if(d<digit)\\n                    {\\n                        dp[i+1][j+d][1]+=dp[i][j][0];\\n                        dp[i+1][j+d][1]%=mod;\\n                    }\\n                    else if(d==digit)\\n                    {\\n                        dp[i+1][j+d][1]+=dp[i][j][1];\\n                        dp[i+1][j+d][1]%=mod;\\n                    }\\n                }\\n            }          \\n        }\\n          \\n        int ans=0;\\n        for(int j=mnsum;j<=mxsum;j++)\\n            ans+=dp[n][j][1],ans%=mod;\\n        return ans;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n               \\n            int ans1=fun(num2,min_sum,max_sum);\\n            int ans2=fun(num1,min_sum,max_sum);\\n            int ans=(ans1-ans2+mod)%mod;\\n            int sum1=0;\\n            for(char x:num1)\\n            {\\n                sum1+=(x-\\'0\\');\\n            }\\n            if(sum1>=min_sum && sum1<=max_sum)\\n            {\\n                ans++;\\n                if(ans>=mod)\\n                    ans-=mod;\\n            }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define deb(x) cout<<#x<<\" \"<<x<<endl;\\n    \\n    // numbers from 0 to x having sum\\n    const int mod=1e9+7;\\n    \\n    int fun(string &s,int mnsum,int mxsum)\\n    {\\n        \\n        int n=s.length();\\n        \\n        int dp[n+1][mxsum+1][2];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=mxsum;j++)\\n                dp[i][j][0]=dp[i][j][1]=0;\\n        }\\n        dp[0][0][0]=1,dp[0][0][1]=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int digit= (s[n-1-i]-\\'0\\');\\n            for(int j=0;j<=mxsum;j++)\\n            {\\n                for(int d=0;d<10;d++)\\n                {\\n                    if(j+d>mxsum)\\n                        break;\\n                    \\n                    dp[i+1][j+d][0]+=dp[i][j][0];\\n                    dp[i+1][j+d][0]%=mod;\\n                    if(d<digit)\\n                    {\\n                        dp[i+1][j+d][1]+=dp[i][j][0];\\n                        dp[i+1][j+d][1]%=mod;\\n                    }\\n                    else if(d==digit)\\n                    {\\n                        dp[i+1][j+d][1]+=dp[i][j][1];\\n                        dp[i+1][j+d][1]%=mod;\\n                    }\\n                }\\n            }          \\n        }\\n          \\n        int ans=0;\\n        for(int j=mnsum;j<=mxsum;j++)\\n            ans+=dp[n][j][1],ans%=mod;\\n        return ans;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n               \\n            int ans1=fun(num2,min_sum,max_sum);\\n            int ans2=fun(num1,min_sum,max_sum);\\n            int ans=(ans1-ans2+mod)%mod;\\n            int sum1=0;\\n            for(char x:num1)\\n            {\\n                sum1+=(x-\\'0\\');\\n            }\\n            if(sum1>=min_sum && sum1<=max_sum)\\n            {\\n                ans++;\\n                if(ans>=mod)\\n                    ans-=mod;\\n            }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3595978,
                "title": "java-memoization-dp",
                "content": "```\\nclass Solution {\\n    static final int MOD = (int) (1e9 + 7);\\n    long[][][] dp;\\n\\n\\t/* This function will recursively calculates the number of valid numbers starting from a given index, \\n\\tconsidering the current sum and tightness (whether the number being constructed should be equal \\n\\tto the corresponding digit in the input string s). \\n\\tIt uses memoization to store previously computed values and avoid redundant computations.\\n\\t*/\\n    public long solve(int idx, int sum, boolean tight, int min_sum, int max_sum, String s) {\\n        if (idx == s.length()) {\\n            return (sum >= min_sum && sum <= max_sum) ? 1 : 0;\\n        }\\n\\n        if (dp[idx][sum][tight ? 1 : 0] != -1) {\\n            return dp[idx][sum][tight ? 1 : 0];\\n        }\\n\\n        long ans = 0;\\n        if (tight) {\\n            for (int i = 0; i <= s.charAt(idx) - \\'0\\'; i++) {\\n                if (s.charAt(idx) - \\'0\\' == i) {\\n                    ans = (ans + solve(idx + 1, sum + i, true, min_sum, max_sum, s)) % MOD;\\n                } else {\\n                    ans = (ans + solve(idx + 1, sum + i, false, min_sum, max_sum, s)) % MOD;\\n                }\\n            }\\n        } else {\\n            for (int i = 0; i <= 9; i++) {\\n                ans = (ans + solve(idx + 1, sum + i, false, min_sum, max_sum, s)) % MOD;\\n            }\\n        }\\n\\n        return dp[idx][sum][tight ? 1 : 0] = ans;\\n    }\\n\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        dp = new long[23][401][2];\\n        for (int i = 0; i < 23; i++) {\\n            for (int j = 0; j < 401; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n\\n        long upper = solve(0, 0, true, min_sum, max_sum, num2);\\n        for (int i = 0; i < 23; i++) {\\n            for (int j = 0; j < 401; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        long lower = solve(0, 0, true, min_sum, max_sum, num1);\\n\\n        int sum = 0;\\n        for (char c : num1.toCharArray()) {\\n            sum += (c - \\'0\\');\\n        }\\n\\n        if (sum >= min_sum && sum <= max_sum) {\\n            lower--;\\n        }\\n\\n        long result = (upper - lower + MOD) % MOD;\\n        return (int) result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    static final int MOD = (int) (1e9 + 7);\\n    long[][][] dp;\\n\\n\\t/* This function will recursively calculates the number of valid numbers starting from a given index, \\n\\tconsidering the current sum and tightness (whether the number being constructed should be equal \\n\\tto the corresponding digit in the input string s). \\n\\tIt uses memoization to store previously computed values and avoid redundant computations.\\n\\t*/\\n    public long solve(int idx, int sum, boolean tight, int min_sum, int max_sum, String s) {\\n        if (idx == s.length()) {\\n            return (sum >= min_sum && sum <= max_sum) ? 1 : 0;\\n        }\\n\\n        if (dp[idx][sum][tight ? 1 : 0] != -1) {\\n            return dp[idx][sum][tight ? 1 : 0];\\n        }\\n\\n        long ans = 0;\\n        if (tight) {\\n            for (int i = 0; i <= s.charAt(idx) - \\'0\\'; i++) {\\n                if (s.charAt(idx) - \\'0\\' == i) {\\n                    ans = (ans + solve(idx + 1, sum + i, true, min_sum, max_sum, s)) % MOD;\\n                } else {\\n                    ans = (ans + solve(idx + 1, sum + i, false, min_sum, max_sum, s)) % MOD;\\n                }\\n            }\\n        } else {\\n            for (int i = 0; i <= 9; i++) {\\n                ans = (ans + solve(idx + 1, sum + i, false, min_sum, max_sum, s)) % MOD;\\n            }\\n        }\\n\\n        return dp[idx][sum][tight ? 1 : 0] = ans;\\n    }\\n\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        dp = new long[23][401][2];\\n        for (int i = 0; i < 23; i++) {\\n            for (int j = 0; j < 401; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n\\n        long upper = solve(0, 0, true, min_sum, max_sum, num2);\\n        for (int i = 0; i < 23; i++) {\\n            for (int j = 0; j < 401; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        long lower = solve(0, 0, true, min_sum, max_sum, num1);\\n\\n        int sum = 0;\\n        for (char c : num1.toCharArray()) {\\n            sum += (c - \\'0\\');\\n        }\\n\\n        if (sum >= min_sum && sum <= max_sum) {\\n            lower--;\\n        }\\n\\n        long result = (upper - lower + MOD) % MOD;\\n        return (int) result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595921,
                "title": "digit-dp-easy",
                "content": "# Intuition\\nEasiest Digit DP Approach\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int dp[23][401][2][2];\\n    int helper(int idx,int sum, bool tight, bool loose,string &s1, string&s2)\\n    {\\n        if(sum < 0)\\n            return 0;\\n        if(idx == s2.size())\\n            return sum == 0;\\n        int &dpval = dp[idx][sum][tight][loose];\\n        if(dpval != -1)\\n            return dpval;\\n        int lb = (loose ? s1[idx] - \\'0\\' : 0);\\n        int ub = (tight ? s2[idx] - \\'0\\' : 9);\\n        int ans = 0;\\n        for(int dig = lb; dig <= ub; dig++)\\n        {\\n            ans = (ans + helper(idx+1, sum-dig, (tight&(dig == s2[idx] - \\'0\\')), (loose&(dig == s1[idx] - \\'0\\')),s1,s2))%mod;\\n        }\\n        return dpval = ans;\\n    }\\n    \\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        if(num1.size() != num2.size())\\n        {\\n            reverse(num1.begin(), num1.end());\\n            while(num1.size() < num2.size())\\n                num1.push_back(\\'0\\');\\n            reverse(num1.begin(), num1.end());\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        int tot = 0;\\n        for(int i = min_sum; i<=max_sum; i++)\\n        {\\n            tot = (tot + helper(0,i,1,1,num1,num2))%mod;\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int dp[23][401][2][2];\\n    int helper(int idx,int sum, bool tight, bool loose,string &s1, string&s2)\\n    {\\n        if(sum < 0)\\n            return 0;\\n        if(idx == s2.size())\\n            return sum == 0;\\n        int &dpval = dp[idx][sum][tight][loose];\\n        if(dpval != -1)\\n            return dpval;\\n        int lb = (loose ? s1[idx] - \\'0\\' : 0);\\n        int ub = (tight ? s2[idx] - \\'0\\' : 9);\\n        int ans = 0;\\n        for(int dig = lb; dig <= ub; dig++)\\n        {\\n            ans = (ans + helper(idx+1, sum-dig, (tight&(dig == s2[idx] - \\'0\\')), (loose&(dig == s1[idx] - \\'0\\')),s1,s2))%mod;\\n        }\\n        return dpval = ans;\\n    }\\n    \\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        if(num1.size() != num2.size())\\n        {\\n            reverse(num1.begin(), num1.end());\\n            while(num1.size() < num2.size())\\n                num1.push_back(\\'0\\');\\n            reverse(num1.begin(), num1.end());\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        int tot = 0;\\n        for(int i = min_sum; i<=max_sum; i++)\\n        {\\n            tot = (tot + helper(0,i,1,1,num1,num2))%mod;\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595917,
                "title": "javascript-buttom-up-4d-digit-dp-459ms",
                "content": "```\\nconst initialize4DArray = (n, m, p, q) => { let r = []; for (let i = 0; i < n; i++) { let a = []; for (let j = 0; j < m; j++) { let b = []; for (let k = 0; k < p; k++) { b.push(Array(q).fill(0)); } a.push(b); } r.push(a); } return r; };\\nconst minus_mod = (x, y, mod) => ((x - y) % mod + mod) % mod;\\n\\nconst ll = BigInt, mod = 1e9 + 7;\\nconst count = (s, t, l, r) => minus_mod(go(t, l, r), go((ll(s) - 1n).toString(), l, r), mod);\\n\\nconst go = (s, l, r) => {\\n    let n = s.length, f = initialize4DArray(n + 1, 2, 2, r + 1);\\n    for (let i = n; i >= 0; i--) {\\n        for (let isLimit = 1; isLimit >= 0; isLimit--) {\\n            for (let isNum = 1; isNum >= 0; isNum--) {\\n                for (let cnt = r; cnt >= 0; cnt--) {\\n                    if (i == n) {\\n                        f[i][isLimit][isNum][cnt] = isNum && l <= cnt && cnt <= r ? 1 : 0;\\n                        continue;\\n                    }\\n                    let res = 0;\\n                    if (!isNum) res += f[i + 1][0][0][0];\\n                    let L = isNum ? 0 : 1, R = isLimit ? s[i] - \\'0\\' : 9;\\n                    for (let digit = L; digit <= R; digit++) {\\n                        if (cnt + digit <= r) {\\n                            res += f[i + 1][(isLimit && R == digit) ? 1 : 0][1][cnt + digit];\\n                            res %= mod;\\n                        }\\n                    }\\n                    f[i][isLimit][isNum][cnt] = res % mod;\\n                }\\n            }\\n        }\\n    }\\n    return f[0][1][0][0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst initialize4DArray = (n, m, p, q) => { let r = []; for (let i = 0; i < n; i++) { let a = []; for (let j = 0; j < m; j++) { let b = []; for (let k = 0; k < p; k++) { b.push(Array(q).fill(0)); } a.push(b); } r.push(a); } return r; };\\nconst minus_mod = (x, y, mod) => ((x - y) % mod + mod) % mod;\\n\\nconst ll = BigInt, mod = 1e9 + 7;\\nconst count = (s, t, l, r) => minus_mod(go(t, l, r), go((ll(s) - 1n).toString(), l, r), mod);\\n\\nconst go = (s, l, r) => {\\n    let n = s.length, f = initialize4DArray(n + 1, 2, 2, r + 1);\\n    for (let i = n; i >= 0; i--) {\\n        for (let isLimit = 1; isLimit >= 0; isLimit--) {\\n            for (let isNum = 1; isNum >= 0; isNum--) {\\n                for (let cnt = r; cnt >= 0; cnt--) {\\n                    if (i == n) {\\n                        f[i][isLimit][isNum][cnt] = isNum && l <= cnt && cnt <= r ? 1 : 0;\\n                        continue;\\n                    }\\n                    let res = 0;\\n                    if (!isNum) res += f[i + 1][0][0][0];\\n                    let L = isNum ? 0 : 1, R = isLimit ? s[i] - \\'0\\' : 9;\\n                    for (let digit = L; digit <= R; digit++) {\\n                        if (cnt + digit <= r) {\\n                            res += f[i + 1][(isLimit && R == digit) ? 1 : 0][1][cnt + digit];\\n                            res %= mod;\\n                        }\\n                    }\\n                    f[i][isLimit][isNum][cnt] = res % mod;\\n                }\\n            }\\n        }\\n    }\\n    return f[0][1][0][0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595777,
                "title": "dynamic-programming-c",
                "content": "# Intuition\\nWe only need to find a way to calculate number of x possible in range from [0, num] with maximum sum as maxSum.\\n\\nUsing this function say func(maxSum, num), we can calculate the required answer as:\\n```\\nnumberOfXForNum2 = func(max_sum, num2) - func(min_sum-1, num2)\\nnumberOfXForNum1 = (func(max_sum, num1) - func(min_sum-1, num1)\\nans = numberOfXForNum2 - numberOfXForNum1\\n```\\n\\n# Approach\\nWe can recursively break problem as finding out the number of x for a smaller maximum sum and string num. \\nThe only possible digits we can insert at each index is in range `[0,9]`. We can use this to choose all the possible options of forming x for a given max sum.\\nOnce we insert a new digit d at an index idx such that `d < num[idx]`,\\nWe can be sure that we can insert any digit in forming x for indices `i > idx`.\\n\\nWe can now use Dynmaic Programming to eliminate overlapping calculations.\\n\\nTypically in this implementation, `dp[i][j][k]` represents\\nNumber of x possible when we consider `i as the maximum sum`, `for number as num[j:]` and `k = 0 or 1 depending on whether further formation of x[j:] can now include any digit from [0, 9] or not`\\n\\n\\n# Complexity\\n- Time complexity:\\nO(max_sum * (num2.size() + num1.size()))\\n\\n- Space complexity:\\nO(max_sum * (num2.size() + num1.size()))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int func(int maxSum, int idx, string &num,vector<vector<vector<int>>> &dp, bool isSmaller = false) {\\n        if(maxSum < 0) return 0;\\n        if(idx == num.size()) return 1;\\n        if(dp[maxSum][idx][isSmaller] != -1) return dp[maxSum][idx][isSmaller];\\n        int ans = 0;\\n        for(int i = 0; i <= 9; ++i) {\\n            if((i + \\'0\\' <= num[idx]) || isSmaller) {\\n                ans += func(maxSum - i, idx+1, num, dp, isSmaller || (i + \\'0\\' < num[idx]));\\n                ans %= MOD;\\n            } else {\\n                break;\\n            }\\n        }\\n        return dp[maxSum][idx][isSmaller] = ans;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        if(num1.back() != \\'0\\') {\\n            num1.back() -= 1;\\n        } else {\\n            int i = num1.size()-1;\\n            while(num1[i] == \\'0\\') {\\n                num1[i] = \\'9\\';\\n                i--;\\n            }\\n            num1[i] -= 1;\\n        }\\n        int n = num2.size();\\n        vector<vector<vector<int>>> dp(max_sum+1, vector<vector<int>>(n+1, vector<int>(2, -1)));\\n        int ans = func(max_sum, 0, num2, dp) - func(min_sum-1, 0, num2, dp);\\n        ans %= MOD;\\n        n = num1.size();\\n        vector<vector<vector<int>>> dp2(max_sum+1, vector<vector<int>>(n+1, vector<int>(2, -1)));\\n        ans -= func(max_sum, 0, num1, dp2) - func(min_sum-1, 0, num1, dp2);\\n        ans += MOD;\\n        ans %= MOD;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnumberOfXForNum2 = func(max_sum, num2) - func(min_sum-1, num2)\\nnumberOfXForNum1 = (func(max_sum, num1) - func(min_sum-1, num1)\\nans = numberOfXForNum2 - numberOfXForNum1\\n```\n```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int func(int maxSum, int idx, string &num,vector<vector<vector<int>>> &dp, bool isSmaller = false) {\\n        if(maxSum < 0) return 0;\\n        if(idx == num.size()) return 1;\\n        if(dp[maxSum][idx][isSmaller] != -1) return dp[maxSum][idx][isSmaller];\\n        int ans = 0;\\n        for(int i = 0; i <= 9; ++i) {\\n            if((i + \\'0\\' <= num[idx]) || isSmaller) {\\n                ans += func(maxSum - i, idx+1, num, dp, isSmaller || (i + \\'0\\' < num[idx]));\\n                ans %= MOD;\\n            } else {\\n                break;\\n            }\\n        }\\n        return dp[maxSum][idx][isSmaller] = ans;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        if(num1.back() != \\'0\\') {\\n            num1.back() -= 1;\\n        } else {\\n            int i = num1.size()-1;\\n            while(num1[i] == \\'0\\') {\\n                num1[i] = \\'9\\';\\n                i--;\\n            }\\n            num1[i] -= 1;\\n        }\\n        int n = num2.size();\\n        vector<vector<vector<int>>> dp(max_sum+1, vector<vector<int>>(n+1, vector<int>(2, -1)));\\n        int ans = func(max_sum, 0, num2, dp) - func(min_sum-1, 0, num2, dp);\\n        ans %= MOD;\\n        n = num1.size();\\n        vector<vector<vector<int>>> dp2(max_sum+1, vector<vector<int>>(n+1, vector<int>(2, -1)));\\n        ans -= func(max_sum, 0, num1, dp2) - func(min_sum-1, 0, num1, dp2);\\n        ans += MOD;\\n        ans %= MOD;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595735,
                "title": "c-with-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you can resolve the number of intergers that are no larger than *num* and the digit sum are no larger than *max_sum*, say, *helper(num,max_sum)*, then the ultimate answer of this problem is equivalent to\\nhelper(num2,max_sum) - helper(num2,min_sum-1) - helper(num1-1, min_sum) + helper(num1-1, min_sum-1)\\n\\nTo calculate the number of intergers that are no larger than *num* and the digit sum no larger than *max_sum*, we use dp approach.\\n\\nFor example, num = \"234567\" (6-digits) and max_sum=12.\\n\\nFirst, we count the number of 6-digit intergers that starts with \\'0\\' (e.g., \"000278\"), which is dp[5][12] (i.e., smaller than 10^5, and digit sum no larger than 12).\\n\\nThen we count the number of integers that starts with \\'1\\', that is dp[5][11].\\n\\nThe rest of intergers that meet requirements start with \\'2\\'. Now we focus on the second digit. We first count the number of intergers that starts with \\'20\\', that is dp[4][10].\\n\\nThen count the number of integers that starts with \\'21\\', that is dp[4][9], and so on...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a matrix dp, the number dp[i][j] is the number of intergers that are smaller than 10^i and digits sum no larger than j.\\n# Complexity\\n- Time complexity: n*max_sum (<= 22 * 400). Here n is the digits of num2.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n*max_sum\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[22][440]={0};\\n    const int MOD=1000000007;\\n    \\n    // Calculate dp[n][max_sum], i.e., the number of intergers that are smaller than 10^n and their digit sum <= than max_sum\\n    int calDP(int n, int max_sum){\\n        if (max_sum<0 || n<0) return 0;\\n        if (n==0 || max_sum==0) return 1;\\n        if (dp[n][max_sum]>0) return dp[n][max_sum];\\n        for (int i=0;i<10;i++)\\n            dp[n][max_sum] = (dp[n][max_sum]+calDP(n-1,max_sum-i))%MOD;\\n        return dp[n][max_sum];\\n    }\\n    \\n    // Number of intergers (including 0) that are no larger than num and the digit sum are no larger than max_sum\\n    long long helper(string num, int max_sum){\\n        long long ans=0;\\n        int n=num.size(),residual=max_sum;\\n        \\n        for (int i=0;i<num.size();i++){\\n            for (int j=0;j<num[i]-\\'0\\';j++)\\n                ans += calDP(n-i-1,residual-j);\\n            if (i==n-1)\\n                ans += calDP(0,residual-num[i]+\\'0\\');\\n            ans %= MOD;\\n            residual -= num[i]-\\'0\\';\\n            if (residual<0) break;\\n        }\\n        return ans%MOD;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int nd2 = num2.size();\\n        long long ans = helper(num2,max_sum)-helper(num2,min_sum-1)-helper(num1,max_sum)+helper(num1,min_sum-1);\\n        // check if sum1 is between min_sum and max_sum. If yes, then ans++\\n        int sum1=0;\\n        for (char c:num1) sum1 += c-\\'0\\';\\n        if (sum1>=min_sum && sum1<=max_sum) ans++;\\n        return ans%MOD;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[22][440]={0};\\n    const int MOD=1000000007;\\n    \\n    // Calculate dp[n][max_sum], i.e., the number of intergers that are smaller than 10^n and their digit sum <= than max_sum\\n    int calDP(int n, int max_sum){\\n        if (max_sum<0 || n<0) return 0;\\n        if (n==0 || max_sum==0) return 1;\\n        if (dp[n][max_sum]>0) return dp[n][max_sum];\\n        for (int i=0;i<10;i++)\\n            dp[n][max_sum] = (dp[n][max_sum]+calDP(n-1,max_sum-i))%MOD;\\n        return dp[n][max_sum];\\n    }\\n    \\n    // Number of intergers (including 0) that are no larger than num and the digit sum are no larger than max_sum\\n    long long helper(string num, int max_sum){\\n        long long ans=0;\\n        int n=num.size(),residual=max_sum;\\n        \\n        for (int i=0;i<num.size();i++){\\n            for (int j=0;j<num[i]-\\'0\\';j++)\\n                ans += calDP(n-i-1,residual-j);\\n            if (i==n-1)\\n                ans += calDP(0,residual-num[i]+\\'0\\');\\n            ans %= MOD;\\n            residual -= num[i]-\\'0\\';\\n            if (residual<0) break;\\n        }\\n        return ans%MOD;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int nd2 = num2.size();\\n        long long ans = helper(num2,max_sum)-helper(num2,min_sum-1)-helper(num1,max_sum)+helper(num1,min_sum-1);\\n        // check if sum1 is between min_sum and max_sum. If yes, then ans++\\n        int sum1=0;\\n        for (char c:num1) sum1 += c-\\'0\\';\\n        if (sum1>=min_sum && sum1<=max_sum) ans++;\\n        return ans%MOD;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595710,
                "title": "digit-dp-using-recursion",
                "content": "This question all about the formation of valid numbers which\\nsatisfies the given condition \\nThis can be done using concept of digit dp\\nHint : when ever you get question like count the numbers which\\nlies between num1 and num2 and should satisfie the given condition \\nyou can apply digit dp concept  \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nf(n, left, right) implies total numbers between 1 to n whose digit \\nsum lies between left and right\\nreturn f(num2, left, right)-f(num1-1, left, right);\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long mod = (long)1e9+7;\\n    long f(int i, boolean bound, int left, int right, int sum, String s, Long dp[][][]){\\n        if(i == s.length()){\\n            if(sum >= left) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][bound ? 1 : 0][sum] != null) return dp[i][bound ? 1 : 0][sum];\\n        int maxDigit = -1;\\n        if(bound){\\n            maxDigit = s.charAt(i)-\\'0\\';\\n        }\\n        else maxDigit = 9;\\n        long count = 0;\\n        for(int it = 0; it <= maxDigit; it++){\\n            if(it+sum <= right)\\n            count += f(i+1, bound && it == s.charAt(i)-\\'0\\', left, right, sum+it, s, dp);\\n            else break;\\n            count %= mod;\\n        }\\n        return dp[i][bound ? 1 : 0][sum] = count%mod;\\n    }\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        int sum = 0;\\n        for(char ch : num1.toCharArray()) sum += ch-\\'0\\';\\n        Long dp1[][][] = new Long[num1.length()][2][max_sum+1];\\n        long aus1 = f(0, true, min_sum, max_sum, 0, num1, dp1);\\n        Long dp2[][][] = new Long[num2.length()][2][max_sum+1];\\n        long aus2 = f(0, true, min_sum, max_sum, 0, num2, dp2);\\n        long aus = (aus2-aus1+mod)%mod;\\n\\n        return sum >= min_sum && sum <= max_sum ? (int)aus+1 : (int)aus;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long mod = (long)1e9+7;\\n    long f(int i, boolean bound, int left, int right, int sum, String s, Long dp[][][]){\\n        if(i == s.length()){\\n            if(sum >= left) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][bound ? 1 : 0][sum] != null) return dp[i][bound ? 1 : 0][sum];\\n        int maxDigit = -1;\\n        if(bound){\\n            maxDigit = s.charAt(i)-\\'0\\';\\n        }\\n        else maxDigit = 9;\\n        long count = 0;\\n        for(int it = 0; it <= maxDigit; it++){\\n            if(it+sum <= right)\\n            count += f(i+1, bound && it == s.charAt(i)-\\'0\\', left, right, sum+it, s, dp);\\n            else break;\\n            count %= mod;\\n        }\\n        return dp[i][bound ? 1 : 0][sum] = count%mod;\\n    }\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        int sum = 0;\\n        for(char ch : num1.toCharArray()) sum += ch-\\'0\\';\\n        Long dp1[][][] = new Long[num1.length()][2][max_sum+1];\\n        long aus1 = f(0, true, min_sum, max_sum, 0, num1, dp1);\\n        Long dp2[][][] = new Long[num2.length()][2][max_sum+1];\\n        long aus2 = f(0, true, min_sum, max_sum, 0, num2, dp2);\\n        long aus = (aus2-aus1+mod)%mod;\\n\\n        return sum >= min_sum && sum <= max_sum ? (int)aus+1 : (int)aus;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595686,
                "title": "c-solution-using-precalculation-and-digit-dp",
                "content": "```\\nbool f=false;\\nlong dp[23][401]={};\\nclass Solution \\n{\\n    public:\\n    long d=1000000007;\\n    int get(string& s,int min_sum,int max_sum)\\n    {\\n        long result=0,n=s.length();\\n\\t\\tint c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<s[i]-\\'0\\';j++)\\n                for(int k=max(min_sum-c-j,0);k<=min(max_sum-c-j,400);k++) result=(result+dp[n-i-1][k])%d;\\n\\n            c+=s[i]-\\'0\\';\\n        }\\n        return result+(c>=min_sum&&c<=max_sum);\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) \\n    {\\n        if(!f)\\n        {\\n            dp[0][0]=1;\\n            for(int i=0;i<22;i++)\\n                for(int j=400;j>-1;j--)\\n                    for(int k=0;k<10&&j>=k;k++) dp[i+1][j]=(dp[i+1][j]+dp[i][j-k])%d;\\n            f=true;            \\n        }\\n        int c=0,n=num1.length();\\n        for(int i=0;i<n;i++) c+=num1[i]-\\'0\\';\\n        return get(num2,min_sum,max_sum)-get(num1,min_sum,max_sum)+(c>=min_sum&&c<=max_sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool f=false;\\nlong dp[23][401]={};\\nclass Solution \\n{\\n    public:\\n    long d=1000000007;\\n    int get(string& s,int min_sum,int max_sum)\\n    {\\n        long result=0,n=s.length();\\n\\t\\tint c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<s[i]-\\'0\\';j++)\\n                for(int k=max(min_sum-c-j,0);k<=min(max_sum-c-j,400);k++) result=(result+dp[n-i-1][k])%d;\\n\\n            c+=s[i]-\\'0\\';\\n        }\\n        return result+(c>=min_sum&&c<=max_sum);\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) \\n    {\\n        if(!f)\\n        {\\n            dp[0][0]=1;\\n            for(int i=0;i<22;i++)\\n                for(int j=400;j>-1;j--)\\n                    for(int k=0;k<10&&j>=k;k++) dp[i+1][j]=(dp[i+1][j]+dp[i][j-k])%d;\\n            f=true;            \\n        }\\n        int c=0,n=num1.length();\\n        for(int i=0;i<n;i++) c+=num1[i]-\\'0\\';\\n        return get(num2,min_sum,max_sum)-get(num1,min_sum,max_sum)+(c>=min_sum&&c<=max_sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595639,
                "title": "digit-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[23][2][2][401];\\n    int M=1e9+7;\\n    int solve(int i,int tight,int start,int sum,string s,int target){\\n        if(i>=(int)s.length()){\\n            if(sum<=target){\\n                return 1;\\n            }\\n            return 0;\\n            \\n        }\\n        if(dp[i][tight][start][sum]!=-1){\\n            return dp[i][tight][start][sum];\\n        }\\n        int en=(tight==1 ? s[i]-\\'0\\' : 9);\\n        int ans=0;\\n        if(start==0){\\n            ans=solve(i+1,0,start,sum,s,target);\\n            for(int k=1;k<=en;k++){\\n                ans=(ans+0LL+solve(i+1,tight&(en==k),1,sum+k,s,target))%M;\\n            }\\n            \\n            \\n        }\\n        else{\\n            for(int k=0;k<=en;k++){\\n                ans=(ans+0LL+solve(i+1,tight&(en==k),1,sum+k,s,target))%M;\\n                \\n            }\\n        }\\n        return dp[i][tight][start][sum]=ans%M;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof dp);\\n        \\n        int a=solve(0,1,0,0,num1,min_sum-1)%M-1;\\n        memset(dp,-1,sizeof dp);\\n        int b=solve(0,1,0,0,num1,max_sum)%M-1;\\n        int ans=b-a;\\n        memset(dp,-1,sizeof dp);\\n        int c=solve(0,1,0,0,num2,min_sum-1)%M-1;\\n        memset(dp,-1,sizeof dp);\\n        int d=solve(0,1,0,0,num2,max_sum)%M-1;\\n        int ans2=d-c;\\n        int sum=0;\\n        for(auto x: num1){\\n            sum+=(x-\\'0\\');\\n        }\\n        bool f=0;\\n        if(sum>=min_sum and sum<=max_sum){\\n            f=1;\\n        }\\n        return (ans2-ans+0LL+(f==1 ? 1: 0))%M;\\n        \\n               \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[23][2][2][401];\\n    int M=1e9+7;\\n    int solve(int i,int tight,int start,int sum,string s,int target){\\n        if(i>=(int)s.length()){\\n            if(sum<=target){\\n                return 1;\\n            }\\n            return 0;\\n            \\n        }\\n        if(dp[i][tight][start][sum]!=-1){\\n            return dp[i][tight][start][sum];\\n        }\\n        int en=(tight==1 ? s[i]-\\'0\\' : 9);\\n        int ans=0;\\n        if(start==0){\\n            ans=solve(i+1,0,start,sum,s,target);\\n            for(int k=1;k<=en;k++){\\n                ans=(ans+0LL+solve(i+1,tight&(en==k),1,sum+k,s,target))%M;\\n            }\\n            \\n            \\n        }\\n        else{\\n            for(int k=0;k<=en;k++){\\n                ans=(ans+0LL+solve(i+1,tight&(en==k),1,sum+k,s,target))%M;\\n                \\n            }\\n        }\\n        return dp[i][tight][start][sum]=ans%M;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        memset(dp,-1,sizeof dp);\\n        \\n        int a=solve(0,1,0,0,num1,min_sum-1)%M-1;\\n        memset(dp,-1,sizeof dp);\\n        int b=solve(0,1,0,0,num1,max_sum)%M-1;\\n        int ans=b-a;\\n        memset(dp,-1,sizeof dp);\\n        int c=solve(0,1,0,0,num2,min_sum-1)%M-1;\\n        memset(dp,-1,sizeof dp);\\n        int d=solve(0,1,0,0,num2,max_sum)%M-1;\\n        int ans2=d-c;\\n        int sum=0;\\n        for(auto x: num1){\\n            sum+=(x-\\'0\\');\\n        }\\n        bool f=0;\\n        if(sum>=min_sum and sum<=max_sum){\\n            f=1;\\n        }\\n        return (ans2-ans+0LL+(f==1 ? 1: 0))%M;\\n        \\n               \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595582,
                "title": "simple-java-solution-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000_000_007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        int[][] dp = new int[23][max_sum+1];\\n        for(int i=0;i<10 && i<=max_sum;i++) {\\n            dp[0][i] = 1;\\n        }\\n        for(int i=1;i<23;i++) {\\n            dp[i][0] = dp[i-1][0];\\n            for(int j=1;j<=max_sum;j++) {\\n                for(int k=0;k<10;k++) {\\n                    if(j-k >= 0) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][j-k]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (((helper(num2, max_sum, dp, true) - helper(num2, min_sum-1, dp, true) - (helper(num1, max_sum, dp, false) - helper(num1, min_sum-1, dp, false))) % mod) + mod) % mod;\\n    }\\n    public int helper(String num, int maxSum, int[][] dp, boolean flag) {\\n        int n = num.length();\\n        int[] preSum = new int[n+1];\\n        char[] chars = num.toCharArray();\\n        for(int i=0;i<n;i++) {\\n            preSum[i+1] = preSum[i] + (chars[i]-\\'0\\');\\n        }\\n        int res = 0;\\n        for(int i=n-1;i>=0;i--) {\\n            int sum = preSum[i];\\n            int val = chars[i] - \\'0\\';\\n            for(int j=0;j < val && maxSum - sum - j >= 0;j++) {\\n                int left = maxSum - sum - j;\\n                if(n-i>1) {\\n                    for(int k=0;k<=left;k++) {\\n                        res = (res + dp[n-i-2][k]) % mod;\\n                    }\\n                } else {\\n                    res = (res+1) % mod;\\n                }\\n            }\\n        }\\n        if(flag && preSum[n] <= maxSum) res++;\\n        // System.out.println(num + \", \" + maxSum + \", \" + flag + \": \" + res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000_000_007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        int[][] dp = new int[23][max_sum+1];\\n        for(int i=0;i<10 && i<=max_sum;i++) {\\n            dp[0][i] = 1;\\n        }\\n        for(int i=1;i<23;i++) {\\n            dp[i][0] = dp[i-1][0];\\n            for(int j=1;j<=max_sum;j++) {\\n                for(int k=0;k<10;k++) {\\n                    if(j-k >= 0) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][j-k]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (((helper(num2, max_sum, dp, true) - helper(num2, min_sum-1, dp, true) - (helper(num1, max_sum, dp, false) - helper(num1, min_sum-1, dp, false))) % mod) + mod) % mod;\\n    }\\n    public int helper(String num, int maxSum, int[][] dp, boolean flag) {\\n        int n = num.length();\\n        int[] preSum = new int[n+1];\\n        char[] chars = num.toCharArray();\\n        for(int i=0;i<n;i++) {\\n            preSum[i+1] = preSum[i] + (chars[i]-\\'0\\');\\n        }\\n        int res = 0;\\n        for(int i=n-1;i>=0;i--) {\\n            int sum = preSum[i];\\n            int val = chars[i] - \\'0\\';\\n            for(int j=0;j < val && maxSum - sum - j >= 0;j++) {\\n                int left = maxSum - sum - j;\\n                if(n-i>1) {\\n                    for(int k=0;k<=left;k++) {\\n                        res = (res + dp[n-i-2][k]) % mod;\\n                    }\\n                } else {\\n                    res = (res+1) % mod;\\n                }\\n            }\\n        }\\n        if(flag && preSum[n] <= maxSum) res++;\\n        // System.out.println(num + \", \" + maxSum + \", \" + flag + \": \" + res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595548,
                "title": "c-dp-and-dumping-the-memo-between-nums",
                "content": "# Approach\\nCreate a dp function that counts the the number of digit sums from 0 to the passed-in string\\'s value that fall between `min_sum` and `max_sum`.\\n\\nThe dp function should take in a numeric string `s` and have three parameters to drive the state: `i`, `sum`, and `limit`.\\n\\nNote that the third parameter, `limit`, is a boolean which decides whether digit `i`\\'s value must be capped.\\n\\n\\u2022 If `limit == true`, then the digit must be capped at the value in `s[i]`.\\n\\u2022 If `limit == false`, then the digit can take on the full range from 0 to 9.\\n\\n*For example: If string `s` has value \"100\", then `limit` enables \"099\" (and below) to be counted, but does not allow \"101\" (or above). See code below for reference.*\\n\\nSince `limit` is entirely dependent on the numeric string, remember to **\"dump\" the memo** in between processing num1 and num2.\\n\\nSubtract dp(num1, 0, 0, true) from dp(num2, 0, 0, true) and **re-include** num1 if its value falls between `min_sum` and `max_sum`.\\n\\n# Code\\n```\\nclass Solution {\\n    int min_sum;\\n    int max_sum;\\n    \\n    // setting the memo size\\n    //   i: up to 23 digits\\n    //   sum: 9 * 23 (loose) upper bound\\n    //   limit: 2 possible values\\n    int memo[23][207][2];\\n    int dp(string& s, int i, int sum, bool limit) {\\n        if (i == s.size()) return (min_sum <= sum && sum <= max_sum ? 1 : 0);\\n        if (sum > max_sum) return 0;\\n        if (memo[i][sum][limit] != -1) return memo[i][sum][limit];\\n                \\n        memo[i][sum][limit] = 0;\\n        for (int n = 0; n <= (limit ? s[i] - \\'0\\' : 9); ++n) {\\n            memo[i][sum][limit] += dp(s, i + 1, sum + n, limit && n == s[i] - \\'0\\');\\n            memo[i][sum][limit] %= 1000000007;\\n        }\\n                \\n        return memo[i][sum][limit];\\n    }\\n    int getSum(string& s) {\\n        int sum = 0;\\n        for (char c: s) sum += c - \\'0\\';\\n        return sum;\\n    }\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        this->min_sum = min_sum;\\n        this->max_sum = max_sum;\\n        \\n        for (int i = 0; i < num2.size(); ++i) for (int j = 0; j < 207; ++j) fill_n(memo[i][j], 2, -1);        \\n        long long ways2 = dp(num2, 0, 0, true);\\n                \\n        for (int i = 0; i < num2.size(); ++i) for (int j = 0; j < 207; ++j) fill_n(memo[i][j], 2, -1);        \\n        long long ways1 = dp(num1, 0, 0, true);\\n                \\n        int num1_sum = getSum(num1);\\n        bool count_num_1 = (min_sum <= num1_sum && num1_sum <= max_sum);\\n        return (ways2 - ways1 + count_num_1 + 1000000007) % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int min_sum;\\n    int max_sum;\\n    \\n    // setting the memo size\\n    //   i: up to 23 digits\\n    //   sum: 9 * 23 (loose) upper bound\\n    //   limit: 2 possible values\\n    int memo[23][207][2];\\n    int dp(string& s, int i, int sum, bool limit) {\\n        if (i == s.size()) return (min_sum <= sum && sum <= max_sum ? 1 : 0);\\n        if (sum > max_sum) return 0;\\n        if (memo[i][sum][limit] != -1) return memo[i][sum][limit];\\n                \\n        memo[i][sum][limit] = 0;\\n        for (int n = 0; n <= (limit ? s[i] - \\'0\\' : 9); ++n) {\\n            memo[i][sum][limit] += dp(s, i + 1, sum + n, limit && n == s[i] - \\'0\\');\\n            memo[i][sum][limit] %= 1000000007;\\n        }\\n                \\n        return memo[i][sum][limit];\\n    }\\n    int getSum(string& s) {\\n        int sum = 0;\\n        for (char c: s) sum += c - \\'0\\';\\n        return sum;\\n    }\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        this->min_sum = min_sum;\\n        this->max_sum = max_sum;\\n        \\n        for (int i = 0; i < num2.size(); ++i) for (int j = 0; j < 207; ++j) fill_n(memo[i][j], 2, -1);        \\n        long long ways2 = dp(num2, 0, 0, true);\\n                \\n        for (int i = 0; i < num2.size(); ++i) for (int j = 0; j < 207; ++j) fill_n(memo[i][j], 2, -1);        \\n        long long ways1 = dp(num1, 0, 0, true);\\n                \\n        int num1_sum = getSum(num1);\\n        bool count_num_1 = (min_sum <= num1_sum && num1_sum <= max_sum);\\n        return (ways2 - ways1 + count_num_1 + 1000000007) % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595529,
                "title": "python-top-down-recursive-dp-clean-short",
                "content": "# Intuition\\nDigits counting - \"most annoying\" problems (personal preference)\\nMost often general idea is DP or some combinatorics. Here it seems a DP. Let\\'s build it iteratively.\\n1. Brute-force: let `f(ds,n)=1 if digit_sum(n) == ds else 0`. Then `ans=sum(f(ds,n) for ds in [min_sum..max_sum] for n in [num1..num2])`. Obviously this is too much of summing. Need to improve.\\n2. Main observation here - we could reduce `for n in [num1..num2]` loop if we could calculate prefix sum `g(ds,n)=sum(f(ds,x) for x in [0..n])` efficiently. Then `ans = sum(g(ds,num2)-g(ds,num1-1) for ds in [min_sum..max_sum])`. So `g(ds,n)` is count of numbers `0<=x<=n` such that `digit_sum(x)==ds`. Lets dig deeper.\\n3. Let\\'s use one more helper function and refefine `f(ds,l) = count(x for x in [0..10^l-1] if digit_sum(x)==ds`. Basically `f(ds,l)==g(ds,10^l-1)`. This is easy to calculate classic DP alike \"number of ways for l coins to sum up to s\", but instead of coins we have digits `0..9`. But how it would help us in calculating `g(ds,n)` for arbitrary `n`? Let\\'s iterate on all possible `0<=x<=n`\\nLet `n=<d0><d1>...<dk>`, then we could group all numbers `0<=x<=n` that have some common prefix (smaller than prefix of `n`) and fill everything else according to residual digit sum: if prefix has digits sum `d` and length `l` then sufix must have sum `ds-d` and length `k-l`). That is\\n```\\ng(ds,n) =     \\n    +f(ds-0, k)+f(ds-1,k)+f(ds-2,k)+...+f(ds-(d0-1),k) # x=<[0..d0)>* or 0<=x<d0*10^k in other words\\n    +f(ds-d0-0,k-1)+...+f(ds-d0-(d1-1),k-1) # x=<d0><[0..d1)>*\\n    +f(ds-d0-d1-0,k-2)+...+f(ds-d0-d1-(d2-1),k-2) # x=<d0><d1><[0..d2)>*, same principle\\n    +...\\n    +f(ds-d0-d1-...-d(k-1)-0, 0)...+f(ds-d0-d1-...d(k-1)-dk, 0) # x=<d0>...<dk-1><[0..dk]>\\n```\\n\\n\\n\\n# Approach\\nImplement functions above, use `@cache`.\\n\\n# Complexity\\n- Time complexity: `O(len(num2)*max_sum)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(len(num2)*max_sum)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        MOD = 10 ** 9 + 7\\n\\n        @cache\\n        def f(ds, l):\\n            if ds < 0: return 0\\n            if 9 * l < ds: return 0\\n            if l == 0: return int(ds == 0)\\n            return sum(f(ds - d0, l - 1) for d0 in range(10)) % MOD\\n\\n        def g(ds, n):\\n            ans = 0\\n            tds = 0\\n            for i in range(len(n)):\\n                di = int(n[i])                \\n                for j in range(di):\\n                    ans += f(ds - tds - j, len(n) - i - 1)\\n                tds += di\\n            ans += f(ds-tds, 0)\\n            return ans % MOD\\n\\n        return sum(MOD + g(ds, num2) - g(ds, str(int(num1) - 1)) for ds in range(min_sum, max_sum + 1)) % MOD\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ng(ds,n) =     \\n    +f(ds-0, k)+f(ds-1,k)+f(ds-2,k)+...+f(ds-(d0-1),k) # x=<[0..d0)>* or 0<=x<d0*10^k in other words\\n    +f(ds-d0-0,k-1)+...+f(ds-d0-(d1-1),k-1) # x=<d0><[0..d1)>*\\n    +f(ds-d0-d1-0,k-2)+...+f(ds-d0-d1-(d2-1),k-2) # x=<d0><d1><[0..d2)>*, same principle\\n    +...\\n    +f(ds-d0-d1-...-d(k-1)-0, 0)...+f(ds-d0-d1-...d(k-1)-dk, 0) # x=<d0>...<dk-1><[0..dk]>\\n```\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        MOD = 10 ** 9 + 7\\n\\n        @cache\\n        def f(ds, l):\\n            if ds < 0: return 0\\n            if 9 * l < ds: return 0\\n            if l == 0: return int(ds == 0)\\n            return sum(f(ds - d0, l - 1) for d0 in range(10)) % MOD\\n\\n        def g(ds, n):\\n            ans = 0\\n            tds = 0\\n            for i in range(len(n)):\\n                di = int(n[i])                \\n                for j in range(di):\\n                    ans += f(ds - tds - j, len(n) - i - 1)\\n                tds += di\\n            ans += f(ds-tds, 0)\\n            return ans % MOD\\n\\n        return sum(MOD + g(ds, num2) - g(ds, str(int(num1) - 1)) for ds in range(min_sum, max_sum + 1)) % MOD\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595488,
                "title": "digit-dp-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        const int mod = 1e9 + 7;\\n        int dp[24][410][2];\\n        memset(dp, -1, sizeof dp);\\n\\n        function<int(int, int, int, string)> go = [&](int i, int cur_sum, int c, string s) -> int {\\n            if (cur_sum > max_sum) return 0;\\n            if (i == (int)s.size()) {\\n                return cur_sum >= min_sum and cur_sum <= max_sum;\\n            }\\n            int &res = dp[i][cur_sum][c];\\n            if (res != -1) return res;\\n            res = 0;\\n            if (c) {\\n                int cur_dig = s[i] - \\'0\\';\\n                for (int j = 0; j < cur_dig; ++j) {\\n                    res = (res + go(i + 1, cur_sum + j, 0, s));\\n                }\\n                res = (res + go(i + 1, cur_sum + cur_dig, 1, s));\\n            } else {\\n                for (int j = 0; j <= 9; ++j) {\\n                    res = (res + go(i + 1, cur_sum + j, 0, s));\\n                }\\n            }\\n            return res;\\n        };\\n\\n        int res = go(0, 0, 1, num2);\\n\\n        memset(dp, -1, sizeof dp);\\n        res = (res - go(0, 0, 1, num1) + mod) % mod;\\n        // check for num1\\n        int total_sum = 0;\\n        for (auto x : num1) {\\n            total_sum += x - \\'0\\';\\n        }\\n        if (total_sum >= min_sum and total_sum <= max_sum) {\\n            res = (res + 1) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        const int mod = 1e9 + 7;\\n        int dp[24][410][2];\\n        memset(dp, -1, sizeof dp);\\n\\n        function<int(int, int, int, string)> go = [&](int i, int cur_sum, int c, string s) -> int {\\n            if (cur_sum > max_sum) return 0;\\n            if (i == (int)s.size()) {\\n                return cur_sum >= min_sum and cur_sum <= max_sum;\\n            }\\n            int &res = dp[i][cur_sum][c];\\n            if (res != -1) return res;\\n            res = 0;\\n            if (c) {\\n                int cur_dig = s[i] - \\'0\\';\\n                for (int j = 0; j < cur_dig; ++j) {\\n                    res = (res + go(i + 1, cur_sum + j, 0, s));\\n                }\\n                res = (res + go(i + 1, cur_sum + cur_dig, 1, s));\\n            } else {\\n                for (int j = 0; j <= 9; ++j) {\\n                    res = (res + go(i + 1, cur_sum + j, 0, s));\\n                }\\n            }\\n            return res;\\n        };\\n\\n        int res = go(0, 0, 1, num2);\\n\\n        memset(dp, -1, sizeof dp);\\n        res = (res - go(0, 0, 1, num1) + mod) % mod;\\n        // check for num1\\n        int total_sum = 0;\\n        for (auto x : num1) {\\n            total_sum += x - \\'0\\';\\n        }\\n        if (total_sum >= min_sum and total_sum <= max_sum) {\\n            res = (res + 1) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595425,
                "title": "digit-dp-reducing-space-to-o-digit-num2",
                "content": "This is case of digit dp(something that I realised later is the name of this pattern)\\nHere, we calculate in two parts:\\n**f(num1, num2) =  f(0, num2) - f(0, num1 - 1)**\\n**= f(0, num2) - f(0, num1) + g(num1)**\\nwhere, f(i, j) is number of integers b/w i and j that satisfies the condition.\\nand g(num1) is check of only num1 satisfing the condition.\\n\\n**Approach 1:(Top-Down only)**\\nLet **h(j) = f(0, j)**\\nfor calculating any **j**, which is say of **n digits**, \\ntake a **n - digit** number with all digit initially **0**.\\nNow, start replacing from left to right(most significant to less significant) with digits **0-9** unless replacement of current digit will make your number greater than **j**.\\nKeeping that constraint in mind you can run a dp, by calculating number of integer with **current digit at kth place** as count of **constrained** solution obtained by keeping digits **0-9** at (k + 1)st place;\\n\\nIn my code variable **c** signifies if we should be worried about constraint at current digit.\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int maxs, mins;\\n    int count(vector<vector<int> > &table, int i, string &num, int sum, int c){\\n        if (i == num.size()) {\\n            return (sum <= maxs && sum >= mins);\\n        }\\n        if((table[i][sum] != -1) && c == 0) return table[i][sum];\\n        int ans = 0;\\n        int k = 9;\\n        if(c) k = num[i] - \\'0\\';\\n        int next;\\n        for (int j = 0; j <= k ; j++){\\n            next = 0;\\n            if(num[i] == \\'0\\' + j){\\n               next = c;\\n            }\\n            ans = (ans + count(table, i + 1, num, sum + j, next))%mod;\\n        }\\n        if(c == 0) table[i][sum] = ans;\\n        return ans;\\n    }\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        maxs = max_sum;\\n        mins = min_sum;\\n        vector<vector<int> >table(num1.size(), vector<int>(num1.size()*10, -1));\\n        int a = count(table, 0, num1, 0, 1);\\n        table = vector<vector<int> >(num2.size(), vector<int>(num2.size()*10, -1));\\n        int b = count(table, 0, num2, 0, 1);\\n        int ans = b - a;\\n        if(ans < 0) ans += mod;\\n        int x = 0;\\n        for(char y: num1) x += y - \\'0\\';\\n        if(x <= maxs && x >= mins) ans = (ans + 1)%mod;\\n        return ans;\\n    }\\n};\\n```\\n**Approach 2:(Both Top-Down and  Bottom-up)**\\nlet S[j,0] = array of the count of all the sums possible for numbers less than j\\nand S[j,1] = array of the count of all the sums possible for numbers less than or equal to j\\nand count(S[.]) accumlates the count of sums b/w min_sum and max_sum.\\nthen the soln can be seen as\\ncount(S[num2,1]) - count(S[num1,0])\\n\\nThis approach is simpler to reason, but slightly harder to implement especially for bottom-up approach.\\nBut bottom-up approach reduces space complexity to **O(#digit(num2))** from O((#digit(num2))^2)\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    \\n    vector<int> smallerNumberDigitSums(string num, int include){\\n        vector<int> sum;\\n        int t = 0;\\n        for(char x: num){\\n            t += x - \\'0\\';\\n            sum.push_back(t);\\n        }\\n        int width = num.size()*10;\\n        vector<vector<int> > smallerSum(2, vector<int>(width, 0));\\n        for(int j = 0; j < sum[0]; j++) smallerSum[0][j] = 1;\\n        int c = 1;\\n        int b;\\n        int l = sum[0] - 1;\\n        for(int i = 1; i < num.size(); i++){\\n            for(int j = 0; j <= l; j++) smallerSum[c][j] = 0;\\n            for(int j = 0; j < width; j++){\\n                if(smallerSum[c^1][j] == 0) break;\\n                for(int k = 0; k <= 9; k++){\\n                    smallerSum[c][j + k] = (smallerSum[c][j + k] + smallerSum[c^1][j])%mod;\\n                }\\n                l = j + 9;\\n            }\\n            b = num[i] - \\'0\\';\\n            for(int k = 0; k < b; k++){\\n                smallerSum[c][sum[i - 1] + k] = (smallerSum[c][sum[i - 1] + k] + 1)%mod;\\n            }\\n            l = max(l, sum[i - 1] + b);\\n            c ^= 1;\\n        }\\n        c ^= 1;\\n        if(include){\\n            smallerSum[c][sum.back()] = (smallerSum[c][sum.back()] + 1)%mod;\\n        }\\n        return smallerSum[c];\\n    }\\n    \\n    int count(vector<int> &sum, int mins, int maxs){\\n        int c = 0;\\n        for(int i = mins; i <= maxs && i < sum.size(); i++){\\n            c = (c + sum[i])%mod;\\n        }\\n        return c;\\n    }\\n    \\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        vector<int> sum1 = smallerNumberDigitSums(num1, 0);\\n        vector<int> sum2 = smallerNumberDigitSums(num2, 1);\\n        int a = count(sum1, min_sum, max_sum);\\n        int b = count(sum2, min_sum, max_sum);\\n        int ans = b - a;\\n        if(ans < 0) ans += mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int maxs, mins;\\n    int count(vector<vector<int> > &table, int i, string &num, int sum, int c){\\n        if (i == num.size()) {\\n            return (sum <= maxs && sum >= mins);\\n        }\\n        if((table[i][sum] != -1) && c == 0) return table[i][sum];\\n        int ans = 0;\\n        int k = 9;\\n        if(c) k = num[i] - \\'0\\';\\n        int next;\\n        for (int j = 0; j <= k ; j++){\\n            next = 0;\\n            if(num[i] == \\'0\\' + j){\\n               next = c;\\n            }\\n            ans = (ans + count(table, i + 1, num, sum + j, next))%mod;\\n        }\\n        if(c == 0) table[i][sum] = ans;\\n        return ans;\\n    }\\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        maxs = max_sum;\\n        mins = min_sum;\\n        vector<vector<int> >table(num1.size(), vector<int>(num1.size()*10, -1));\\n        int a = count(table, 0, num1, 0, 1);\\n        table = vector<vector<int> >(num2.size(), vector<int>(num2.size()*10, -1));\\n        int b = count(table, 0, num2, 0, 1);\\n        int ans = b - a;\\n        if(ans < 0) ans += mod;\\n        int x = 0;\\n        for(char y: num1) x += y - \\'0\\';\\n        if(x <= maxs && x >= mins) ans = (ans + 1)%mod;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    \\n    vector<int> smallerNumberDigitSums(string num, int include){\\n        vector<int> sum;\\n        int t = 0;\\n        for(char x: num){\\n            t += x - \\'0\\';\\n            sum.push_back(t);\\n        }\\n        int width = num.size()*10;\\n        vector<vector<int> > smallerSum(2, vector<int>(width, 0));\\n        for(int j = 0; j < sum[0]; j++) smallerSum[0][j] = 1;\\n        int c = 1;\\n        int b;\\n        int l = sum[0] - 1;\\n        for(int i = 1; i < num.size(); i++){\\n            for(int j = 0; j <= l; j++) smallerSum[c][j] = 0;\\n            for(int j = 0; j < width; j++){\\n                if(smallerSum[c^1][j] == 0) break;\\n                for(int k = 0; k <= 9; k++){\\n                    smallerSum[c][j + k] = (smallerSum[c][j + k] + smallerSum[c^1][j])%mod;\\n                }\\n                l = j + 9;\\n            }\\n            b = num[i] - \\'0\\';\\n            for(int k = 0; k < b; k++){\\n                smallerSum[c][sum[i - 1] + k] = (smallerSum[c][sum[i - 1] + k] + 1)%mod;\\n            }\\n            l = max(l, sum[i - 1] + b);\\n            c ^= 1;\\n        }\\n        c ^= 1;\\n        if(include){\\n            smallerSum[c][sum.back()] = (smallerSum[c][sum.back()] + 1)%mod;\\n        }\\n        return smallerSum[c];\\n    }\\n    \\n    int count(vector<int> &sum, int mins, int maxs){\\n        int c = 0;\\n        for(int i = mins; i <= maxs && i < sum.size(); i++){\\n            c = (c + sum[i])%mod;\\n        }\\n        return c;\\n    }\\n    \\npublic:\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        vector<int> sum1 = smallerNumberDigitSums(num1, 0);\\n        vector<int> sum2 = smallerNumberDigitSums(num2, 1);\\n        int a = count(sum1, min_sum, max_sum);\\n        int b = count(sum2, min_sum, max_sum);\\n        int ans = b - a;\\n        if(ans < 0) ans += mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595415,
                "title": "recursive-python3-288ms",
                "content": "# Code\\n```\\n\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        mod = 10**9 + 7\\n\\n        num1 = num1.zfill(len(num2))\\n\\n        @cache\\n        def dp(idx, lt, rt, s):\\n            if s > max_sum:\\n                return 0\\n            if idx == len(num2):\\n                return int(min_sum <= s <= max_sum)\\n\\n            res = 0\\n            l = int(num1[idx]) if lt else 0\\n            r = int(num2[idx]) if rt else 9\\n            for digit in range(l, r + 1):\\n                new_lt = lt & (digit == l)\\n                new_rt = rt & (digit == r)\\n                res += dp(idx + 1, new_lt, new_rt, s + digit)\\n\\n            return res\\n\\n        return dp(0, 1, 1, 0) % mod\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        mod = 10**9 + 7\\n\\n        num1 = num1.zfill(len(num2))\\n\\n        @cache\\n        def dp(idx, lt, rt, s):\\n            if s > max_sum:\\n                return 0\\n            if idx == len(num2):\\n                return int(min_sum <= s <= max_sum)\\n\\n            res = 0\\n            l = int(num1[idx]) if lt else 0\\n            r = int(num2[idx]) if rt else 9\\n            for digit in range(l, r + 1):\\n                new_lt = lt & (digit == l)\\n                new_rt = rt & (digit == r)\\n                res += dp(idx + 1, new_lt, new_rt, s + digit)\\n\\n            return res\\n\\n        return dp(0, 1, 1, 0) % mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595392,
                "title": "c-recursive-solution-do-not-repeat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to count good numbers in interval $[num1, num2]$. Standard idea: cals this function for $[1, num1]$ and $[1, num2]$ than substract.\\nOh! If we can count this for $[1, num1]$, we can count for\\n$$\\\\{[1, num1 \\\\cdot 10] \\\\cdots [1, num1 \\\\cdot 10 + 9]\\\\}$$\\nby changing restrictions for digit sum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s create a naive recursion function `count(num, min,max)`. To avoid string coping we can use string_view or just reference and offset. Write, submit, time limit...\\nIn Python we can use `@lru_cahe` decorator but in **Holy C++** like crusaders of medieval we should overcome as many challanges, as we can. So orginize dummy cache for our recursion function. Oh... in stl there is no hash function for tuples.\\n\\nUgly, stupid, slow. Sorry...\\n\\n# Complexity\\n- Time complexity:\\n$O(max\\\\_sum\\\\cdot\\\\log(num2))$ because we change `min_sum` and `max_sum` simultaneously by the same number. And we calc count for every digit, every radix and at most every `max_sum`. There are only 10 digits so it is constant.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(max\\\\_sum\\\\cdot\\\\log(num2))$ for cache and recursion.\\n\\n# Code\\n```\\nclass Solution {\\n    struct Hash {\\n        size_t operator()(const tuple<int, int, int, int>& t) const {\\n            return (size_t(get<0>(t)) << 40) ^ (size_t(get<1>(t)) << 20) ^ size_t(get<2>(t)) ^ (size_t(get<3>(t)) << 60);\\n        }\\n    };\\n    unordered_map<tuple<int, int, int, int>, int64_t, Hash> cache;\\n    static const int64_t MODULO = 1e9 + 7;\\n    int64_t count(const string& num, int min_sum, int max_sum, int offset, bool is_first) {\\n        auto it = cache.find({min_sum, max_sum, offset, is_first});\\n        if (it != cache.end()) {\\n            return it->second;\\n        }\\n        if (max_sum < 0) {\\n            return 0;\\n        }\\n        if (offset == num.size()) {\\n            if (min_sum > 0) {\\n                return 0;\\n            } else {\\n                return 1;\\n            }\\n        }\\n        int64_t result = 0;\\n        if (is_first) {\\n            for (int d = 0; d <= num[offset] - \\'0\\'; d++) {\\n                result += count(num, min_sum - d, max_sum - d, offset + 1, d == num[offset] - \\'0\\');\\n            }\\n        } else {\\n            for (int d = 0; d <= 9; d++) {\\n                result += count(num, min_sum - d, max_sum - d, offset + 1, false);\\n            }\\n        }\\n        cache[{min_sum, max_sum, offset, is_first}] = result % MODULO;\\n        return result % MODULO;\\n    }\\npublic:\\n    int count(const string& num1, const string& num2, int min_sum, int max_sum) {\\n        cache.clear();\\n        int result = count(num2, min_sum, max_sum, 0, true);\\n        cache.clear();\\n        result -= count(num1, min_sum, max_sum, 0, true);\\n        int num1sum = 0;\\n        for (char c : num1) {\\n            num1sum += c - \\'0\\';\\n        }\\n        if (min_sum <= num1sum && num1sum <= max_sum) {\\n            result++;\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    struct Hash {\\n        size_t operator()(const tuple<int, int, int, int>& t) const {\\n            return (size_t(get<0>(t)) << 40) ^ (size_t(get<1>(t)) << 20) ^ size_t(get<2>(t)) ^ (size_t(get<3>(t)) << 60);\\n        }\\n    };\\n    unordered_map<tuple<int, int, int, int>, int64_t, Hash> cache;\\n    static const int64_t MODULO = 1e9 + 7;\\n    int64_t count(const string& num, int min_sum, int max_sum, int offset, bool is_first) {\\n        auto it = cache.find({min_sum, max_sum, offset, is_first});\\n        if (it != cache.end()) {\\n            return it->second;\\n        }\\n        if (max_sum < 0) {\\n            return 0;\\n        }\\n        if (offset == num.size()) {\\n            if (min_sum > 0) {\\n                return 0;\\n            } else {\\n                return 1;\\n            }\\n        }\\n        int64_t result = 0;\\n        if (is_first) {\\n            for (int d = 0; d <= num[offset] - \\'0\\'; d++) {\\n                result += count(num, min_sum - d, max_sum - d, offset + 1, d == num[offset] - \\'0\\');\\n            }\\n        } else {\\n            for (int d = 0; d <= 9; d++) {\\n                result += count(num, min_sum - d, max_sum - d, offset + 1, false);\\n            }\\n        }\\n        cache[{min_sum, max_sum, offset, is_first}] = result % MODULO;\\n        return result % MODULO;\\n    }\\npublic:\\n    int count(const string& num1, const string& num2, int min_sum, int max_sum) {\\n        cache.clear();\\n        int result = count(num2, min_sum, max_sum, 0, true);\\n        cache.clear();\\n        result -= count(num1, min_sum, max_sum, 0, true);\\n        int num1sum = 0;\\n        for (char c : num1) {\\n            num1sum += c - \\'0\\';\\n        }\\n        if (min_sum <= num1sum && num1sum <= max_sum) {\\n            result++;\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595390,
                "title": "standard-digit-dp-c-solution-similar-digit-dp-problem-list",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int dp[23][2][220];\\n    int f(string &s,int m,int M,int idx = 0,int last = 1,int sum=0)\\n    {\\n        if(idx==s.size())\\n        {\\n            if(sum<=M && sum>=m) return 1;\\n            return 0;\\n        }\\n        int &t = dp[idx][last][sum];\\n        if(t!=-1) return t;\\n        int limit = last?s[idx]-\\'0\\':9;\\n        long long ans = 0;\\n        for(int i=0;i<=limit;i++)\\n        {\\n            ans += f(s,m,M,idx+1,last&(limit==i),sum+i);\\n        }\\n        return t=ans;\\n    }\\n    int f1(string &s,int m,int M)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(s,m,M);\\n    }\\n    bool ff(string &s,int m,int M)\\n    {\\n        int sum = 0;\\n        for(auto i:s)\\n        {\\n            sum += i-\\'0\\';\\n        }\\n        if(sum<=M && sum>=m) return 1;\\n        return 0;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum)\\n    {\\n        return ((f1(num2,min_sum,max_sum)-f1(num1,min_sum,max_sum)+mod)+ff(num1,min_sum,max_sum))%mod;\\n    }\\n};\\n```\\nSimilar Digit DP Problem List :-> https://leetcode.com/list/relyabt5\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int dp[23][2][220];\\n    int f(string &s,int m,int M,int idx = 0,int last = 1,int sum=0)\\n    {\\n        if(idx==s.size())\\n        {\\n            if(sum<=M && sum>=m) return 1;\\n            return 0;\\n        }\\n        int &t = dp[idx][last][sum];\\n        if(t!=-1) return t;\\n        int limit = last?s[idx]-\\'0\\':9;\\n        long long ans = 0;\\n        for(int i=0;i<=limit;i++)\\n        {\\n            ans += f(s,m,M,idx+1,last&(limit==i),sum+i);\\n        }\\n        return t=ans;\\n    }\\n    int f1(string &s,int m,int M)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(s,m,M);\\n    }\\n    bool ff(string &s,int m,int M)\\n    {\\n        int sum = 0;\\n        for(auto i:s)\\n        {\\n            sum += i-\\'0\\';\\n        }\\n        if(sum<=M && sum>=m) return 1;\\n        return 0;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum)\\n    {\\n        return ((f1(num2,min_sum,max_sum)-f1(num1,min_sum,max_sum)+mod)+ff(num1,min_sum,max_sum))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595383,
                "title": "python-recursive-dp",
                "content": "\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        n = len(num2)\\n        num1 = \\'0\\' * (n - len(num1)) + num1\\n\\n        memo = {}\\n        mod = 10 ** 9 + 7\\n\\n        def dfs(idx, cur_sum, equal_last_lower, equal_last_upper):\\n            if idx == n:\\n                if cur_sum >= min_sum:\\n                    return 1\\n                return 0\\n\\n            key = (idx, cur_sum, equal_last_lower, equal_last_upper)\\n            if key in memo:\\n                return memo[key]\\n\\n            ans = 0\\n\\n            lower = int(num1[idx]) if equal_last_lower else 0\\n            upper = int(num2[idx]) if equal_last_upper else 9\\n\\n            for i in range(lower, upper + 1):\\n                new_sum = cur_sum + i\\n                if new_sum <= max_sum:\\n                    ans += dfs(idx + 1, new_sum, equal_last_lower and i == lower, equal_last_upper and i == upper)\\n\\n            memo[key] = ans % mod\\n            return memo[key]\\n\\n        return dfs(0, 0, True, True)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        n = len(num2)\\n        num1 = \\'0\\' * (n - len(num1)) + num1\\n\\n        memo = {}\\n        mod = 10 ** 9 + 7\\n\\n        def dfs(idx, cur_sum, equal_last_lower, equal_last_upper):\\n            if idx == n:\\n                if cur_sum >= min_sum:\\n                    return 1\\n                return 0\\n\\n            key = (idx, cur_sum, equal_last_lower, equal_last_upper)\\n            if key in memo:\\n                return memo[key]\\n\\n            ans = 0\\n\\n            lower = int(num1[idx]) if equal_last_lower else 0\\n            upper = int(num2[idx]) if equal_last_upper else 9\\n\\n            for i in range(lower, upper + 1):\\n                new_sum = cur_sum + i\\n                if new_sum <= max_sum:\\n                    ans += dfs(idx + 1, new_sum, equal_last_lower and i == lower, equal_last_upper and i == upper)\\n\\n            memo[key] = ans % mod\\n            return memo[key]\\n\\n        return dfs(0, 0, True, True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595362,
                "title": "java-10ms-dp-prefixsum-solution",
                "content": "# Intuition\\nUse DP to solve the problem. \\n\\n`prefixSums` is a DP array, where `prefixSums[i][j]` represents the total count of integers whose length is `i` and digit_sum is between `[1, j]`.\\n\\nThen we can calculate the result below way:\\n\\n```\\nresult = #(good integers <= num2) - #(good integers < num1)\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int MOD = (int) (1e9 + 7);\\n\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        long[][] prefixSums = new long[num2.length() + 1][Math.max(max_sum + 1, 10)];\\n        for (int j = 1; j < prefixSums[0].length; j++) {\\n            prefixSums[1][j] = prefixSums[1][j - 1] + (j <= 9 ? 1 : 0);\\n        }\\n        for (int i = 2; i < prefixSums.length; i++) {\\n            for (int j = 1; j < prefixSums[0].length; j++) {\\n                prefixSums[i][j] += prefixSums[i][j - 1];\\n                prefixSums[i][j] += prefixSums[i - 1][j] - prefixSums[i - 1][Math.max(j - 10, 0)];\\n            }\\n        }\\n\\n        long result = count(num2, min_sum, max_sum, prefixSums) - count(num1, min_sum, max_sum, prefixSums);\\n\\n        int digitSum1 = 0;\\n        for (char c : num1.toCharArray()) {\\n            digitSum1 += c - \\'0\\';\\n        }\\n        result += (digitSum1 >= min_sum && digitSum1 <= max_sum) ? 1 : 0;\\n\\n        return (int) (result % MOD);\\n    }\\n\\n    private long count(String num, int min_sum, int max_sum, long[][] prefixSums) {\\n        long result = 0;\\n\\n        int digitSum = 0;\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\';\\n\\n            for (int j = digit - 1; j >= (i == 0 ? 1 : 0); j--) {\\n                if (digitSum + j >= min_sum && digitSum + j <= max_sum) {\\n                    result += 1;\\n                }\\n\\n                int min = min_sum - digitSum - j;\\n                int max = max_sum - digitSum - j;\\n                for (int m = num.length() - i - 1; max >= 0 && m >= 0; m--) {\\n                    result += prefixSums[m][max] - prefixSums[m][Math.max(min - 1, 0)];\\n                    result %= MOD;\\n                }\\n            }\\n\\n            digitSum += digit;\\n        }\\n\\n        if (digitSum >= min_sum && digitSum <= max_sum) {\\n            result += 1;\\n        }\\n\\n        for (int i = num.length() - 1; i >= 1; i--) {\\n            result += prefixSums[i][max_sum] - prefixSums[i][min_sum - 1];\\n            result %= MOD;\\n        }\\n\\n        return result % MOD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nresult = #(good integers <= num2) - #(good integers < num1)\\n```\n```\\nclass Solution {\\n    private static final int MOD = (int) (1e9 + 7);\\n\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        long[][] prefixSums = new long[num2.length() + 1][Math.max(max_sum + 1, 10)];\\n        for (int j = 1; j < prefixSums[0].length; j++) {\\n            prefixSums[1][j] = prefixSums[1][j - 1] + (j <= 9 ? 1 : 0);\\n        }\\n        for (int i = 2; i < prefixSums.length; i++) {\\n            for (int j = 1; j < prefixSums[0].length; j++) {\\n                prefixSums[i][j] += prefixSums[i][j - 1];\\n                prefixSums[i][j] += prefixSums[i - 1][j] - prefixSums[i - 1][Math.max(j - 10, 0)];\\n            }\\n        }\\n\\n        long result = count(num2, min_sum, max_sum, prefixSums) - count(num1, min_sum, max_sum, prefixSums);\\n\\n        int digitSum1 = 0;\\n        for (char c : num1.toCharArray()) {\\n            digitSum1 += c - \\'0\\';\\n        }\\n        result += (digitSum1 >= min_sum && digitSum1 <= max_sum) ? 1 : 0;\\n\\n        return (int) (result % MOD);\\n    }\\n\\n    private long count(String num, int min_sum, int max_sum, long[][] prefixSums) {\\n        long result = 0;\\n\\n        int digitSum = 0;\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\';\\n\\n            for (int j = digit - 1; j >= (i == 0 ? 1 : 0); j--) {\\n                if (digitSum + j >= min_sum && digitSum + j <= max_sum) {\\n                    result += 1;\\n                }\\n\\n                int min = min_sum - digitSum - j;\\n                int max = max_sum - digitSum - j;\\n                for (int m = num.length() - i - 1; max >= 0 && m >= 0; m--) {\\n                    result += prefixSums[m][max] - prefixSums[m][Math.max(min - 1, 0)];\\n                    result %= MOD;\\n                }\\n            }\\n\\n            digitSum += digit;\\n        }\\n\\n        if (digitSum >= min_sum && digitSum <= max_sum) {\\n            result += 1;\\n        }\\n\\n        for (int i = num.length() - 1; i >= 1; i--) {\\n            result += prefixSums[i][max_sum] - prefixSums[i][min_sum - 1];\\n            result %= MOD;\\n        }\\n\\n        return result % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595339,
                "title": "simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    const int MOD=1e9+7;\\npublic:\\n    int count(string L, string R, int MI, int MA) {\\n        // make input more convinient\\n        while(L.size()<R.size())L.insert(L.begin(),\\'0\\');\\n        for(auto&c:L)c-=\\'0\\';for(auto&c:R)c-=\\'0\\';\\n\\n        // 0 (used during contest) for \"undefined\" does not work :)\\n        int DD[23][2][2][401]{};memset(DD,-1,sizeof(DD));\\n\\n        // s - digits sum, gl - greater than L, lr - less than R\\n        function<int(int,int,int,int)>dfs=[&](int p,int s,int gl,int lr){\\n            if(s>MA)return-0;\\n            auto&dd=DD[p][gl][lr][s];\\n            if(p==L.size())return dd=MI<=s;\\n            if(dd>=0)return dd;dd=0;\\n            // mi/ma - min/max digit on position p \\n            int mi=gl?0:L[p],ma=lr?9:R[p];\\n            for(int d=ma;d>=mi;--d){\\n                dd+=dfs(p+1,s+d,gl|(d>mi),lr|(d<ma));\\n            }\\n            return dd%=MOD;\\n        };\\n        return dfs(0,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const int MOD=1e9+7;\\npublic:\\n    int count(string L, string R, int MI, int MA) {\\n        // make input more convinient\\n        while(L.size()<R.size())L.insert(L.begin(),\\'0\\');\\n        for(auto&c:L)c-=\\'0\\';for(auto&c:R)c-=\\'0\\';\\n\\n        // 0 (used during contest) for \"undefined\" does not work :)\\n        int DD[23][2][2][401]{};memset(DD,-1,sizeof(DD));\\n\\n        // s - digits sum, gl - greater than L, lr - less than R\\n        function<int(int,int,int,int)>dfs=[&](int p,int s,int gl,int lr){\\n            if(s>MA)return-0;\\n            auto&dd=DD[p][gl][lr][s];\\n            if(p==L.size())return dd=MI<=s;\\n            if(dd>=0)return dd;dd=0;\\n            // mi/ma - min/max digit on position p \\n            int mi=gl?0:L[p],ma=lr?9:R[p];\\n            for(int d=ma;d>=mi;--d){\\n                dd+=dfs(p+1,s+d,gl|(d>mi),lr|(d<ma));\\n            }\\n            return dd%=MOD;\\n        };\\n        return dfs(0,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595283,
                "title": "standard-digit-dp-problem",
                "content": "# Pre-requisite : Digit DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod = (int) 1e9 + 7;\\n    int mini, maxi;\\n    int dp[25][2][400];\\n\\n    int memo(string& s, int ind, int tight, int sum){\\n        if(ind >= s.size()) return (sum >= mini && sum <= maxi);\\n        if(dp[ind][tight][sum] != -1) return dp[ind][tight][sum];\\n        long long ans = 0;\\n\\n        if(tight) {\\n            for(int i = 0; i <= s[ind] - \\'0\\'; i++){\\n                ans += memo(s, ind + 1, i == s[ind] - \\'0\\', sum + i);\\n                ans %= mod;\\n            }\\n        }\\n        else {\\n            for(int i = 0; i < 10; i++){\\n                ans += memo(s, ind + 1, 0, sum + i);\\n                ans %= mod;\\n            }\\n        }\\n        \\n        return dp[ind][tight][sum] = ans % mod;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        mini = min_sum;\\n        maxi = max_sum;\\n        \\n        memset(dp, -1, sizeof dp);\\n        long long ans = memo(num2, 0, 1, 0);\\n        memset(dp, -1, sizeof dp);\\n        ans -= memo(num1, 0, 1, 0);\\n\\n        int sum = 0;\\n        for(auto &i: num1) sum += (i - \\'0\\');\\n\\n        return (ans + (sum >= min_sum && sum <= max_sum) + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = (int) 1e9 + 7;\\n    int mini, maxi;\\n    int dp[25][2][400];\\n\\n    int memo(string& s, int ind, int tight, int sum){\\n        if(ind >= s.size()) return (sum >= mini && sum <= maxi);\\n        if(dp[ind][tight][sum] != -1) return dp[ind][tight][sum];\\n        long long ans = 0;\\n\\n        if(tight) {\\n            for(int i = 0; i <= s[ind] - \\'0\\'; i++){\\n                ans += memo(s, ind + 1, i == s[ind] - \\'0\\', sum + i);\\n                ans %= mod;\\n            }\\n        }\\n        else {\\n            for(int i = 0; i < 10; i++){\\n                ans += memo(s, ind + 1, 0, sum + i);\\n                ans %= mod;\\n            }\\n        }\\n        \\n        return dp[ind][tight][sum] = ans % mod;\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        mini = min_sum;\\n        maxi = max_sum;\\n        \\n        memset(dp, -1, sizeof dp);\\n        long long ans = memo(num2, 0, 1, 0);\\n        memset(dp, -1, sizeof dp);\\n        ans -= memo(num1, 0, 1, 0);\\n\\n        int sum = 0;\\n        for(auto &i: num1) sum += (i - \\'0\\');\\n\\n        return (ans + (sum >= min_sum && sum <= max_sum) + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595267,
                "title": "ez-c-digit-dp-solution",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    long long dp[23][401][10];\\n    long long digitDP(vector<int>& num, int n, long long sum, int tight, int min_sum, int max_sum) {\\n        if (n == -1) {\\n            return (sum >= min_sum && sum <= max_sum) ? 1 : 0;\\n        }\\n        if(dp[n][sum][tight]!=-1)\\n            return dp[n][sum][tight];\\n        long long x = 0ll;\\n        int k = tight ? num[n] : 9;\\n\\n        for (int i = 0; i <= k; i++) {\\n             int newTight=num[n]==i?tight:0;\\n            x += digitDP(num, n - 1, sum + i, newTight, min_sum, max_sum);\\n            x %= 1000000007;  // Modulo 10^9 + 7\\n        }\\n\\n        return dp[n][sum][tight]=x;\\n    }\\n\\n    int calc(string n, int min_sum, int max_sum) {\\n        vector<int> digits;\\n       for(auto &i:n)\\n            digits.push_back(i-\\'0\\');         \\n        \\n     reverse(digits.begin(), digits.end());\\n        return digitDP(digits, digits.size() - 1, 0, 1, min_sum, max_sum);\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n       // unsigned long long a = stoull(num1), b = stoull(num2);\\n        memset(dp,-1,sizeof(dp));\\n      \\n        long long x=calc(num1, min_sum, max_sum) ;\\n        memset(dp,-1,sizeof(dp));\\n         int s=0;\\n        int c=0;\\n        for(auto i:num1)\\n            s+=(i-\\'0\\');        \\n        if(s>=min_sum and s<=max_sum)\\n            c=1;\\n        \\n        long long y=calc(num2 , min_sum, max_sum);\\n       \\n       int ans= (y-x+c+1000000007) % 1000000007;\\n       return ans;\\n    }\\n};\\n/*\\n\\n    \"6312\"\\n\"9416\"\\n29\\n30\\n\\nans=114\\n\\n\\n\"5410\"\\n\"9277\"\\n18\\n19\\n\\nAnswer 569\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[23][401][10];\\n    long long digitDP(vector<int>& num, int n, long long sum, int tight, int min_sum, int max_sum) {\\n        if (n == -1) {\\n            return (sum >= min_sum && sum <= max_sum) ? 1 : 0;\\n        }\\n        if(dp[n][sum][tight]!=-1)\\n            return dp[n][sum][tight];\\n        long long x = 0ll;\\n        int k = tight ? num[n] : 9;\\n\\n        for (int i = 0; i <= k; i++) {\\n             int newTight=num[n]==i?tight:0;\\n            x += digitDP(num, n - 1, sum + i, newTight, min_sum, max_sum);\\n            x %= 1000000007;  // Modulo 10^9 + 7\\n        }\\n\\n        return dp[n][sum][tight]=x;\\n    }\\n\\n    int calc(string n, int min_sum, int max_sum) {\\n        vector<int> digits;\\n       for(auto &i:n)\\n            digits.push_back(i-\\'0\\');         \\n        \\n     reverse(digits.begin(), digits.end());\\n        return digitDP(digits, digits.size() - 1, 0, 1, min_sum, max_sum);\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n       // unsigned long long a = stoull(num1), b = stoull(num2);\\n        memset(dp,-1,sizeof(dp));\\n      \\n        long long x=calc(num1, min_sum, max_sum) ;\\n        memset(dp,-1,sizeof(dp));\\n         int s=0;\\n        int c=0;\\n        for(auto i:num1)\\n            s+=(i-\\'0\\');        \\n        if(s>=min_sum and s<=max_sum)\\n            c=1;\\n        \\n        long long y=calc(num2 , min_sum, max_sum);\\n       \\n       int ans= (y-x+c+1000000007) % 1000000007;\\n       return ans;\\n    }\\n};\\n/*\\n\\n    \"6312\"\\n\"9416\"\\n29\\n30\\n\\nans=114\\n\\n\\n\"5410\"\\n\"9277\"\\n18\\n19\\n\\nAnswer 569\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595244,
                "title": "digit-dp-simple-explained-solution",
                "content": "```\\n\\n/*\\n\\nDigit Sum\\n\\nCount of numbers till given very big number \"nums\" that have sum of all digits =X\\n\\nAs we have to consider all the numbers till \"nums\" , so to form all numbers, for each\\n\\nposition i, we have choices over digits in range [0-9] based on whether this position is \\n\\ntightly bound or not.\\n\\ndp[i][tight][sum] = Count of all numbers till \"nums\" whose sum of digits\\n\\nin position range [i...n-1] is = sum ,  based on whether the position i tightly bound or not. \\n\\n*/\\n\\n#define lln long long int\\n\\nint mod=1e9+7;\\n\\nlln dp1[23][2][401];\\n\\n\\nlln dp2[24][2][405];\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int count(string num1, string num2, int minSum, int maxSum) {\\n        \\n        \\n           memset(dp1,-1,sizeof(dp1));\\n        \\n           memset(dp2,-1,sizeof(dp2));\\n\\n\\n        \\n        lln ans=0;\\n        \\n         int s1=0;\\n            \\n            for(char ch:num1){\\n                s1+=(ch-\\'0\\');\\n            }\\n        \\n        \\n        for(int i=minSum;i<=maxSum;i++){\\n            \\n            lln x1=sumX2(num2,i);\\n            \\n            lln x2=sumX1(num1,i);\\n            \\n            ans+=(x1-x2);\\n            ans%=mod;\\n            if(s1==i)\\n                ans++;\\n        }\\n        \\n        \\n        return ans%mod;\\n        \\n    }\\n    \\n    \\n int sumX1(string num,int X){\\n     \\n     \\n   int i=0,tight=1,sum=X;\\n     \\n   return find3(i,tight,sum,num);\\n     \\n }\\n    \\n    \\n     \\n int sumX2(string num,int X){\\n     \\n     \\n   int i=0,tight=1,sum=X;\\n     \\n   return find4(i,tight,sum,num);\\n     \\n }\\n    \\n\\n lln find3(int i,int tight,int sum,string num){\\n     \\n  if(sum<0)\\n  return 0;\\n\\n  if(i==num.size()){\\n\\n\\n   if(sum==0)\\n   return 1;\\n\\n   return 0;\\n  }\\n \\n if(dp1[i][tight][sum]!=-1)\\n  \\treturn dp1[i][tight][sum];\\n\\n\\n  lln ub;  // upper bound digit\\n\\n  if(tight==1)\\n  ub=num[i]-\\'0\\';\\n  else\\n  ub=9;\\n\\n  lln ans=0;\\n\\n  for(int d=0;d<=ub;d++){\\n\\n  ans=ans%mod+find3(i+1,tight && (d==ub),sum-d,num)%mod;\\n\\n      ans%=mod;\\n  }\\n\\n  return dp1[i][tight][sum]=ans;\\n }\\n    \\n    \\n    \\n lln find4(int i,int tight,int sum,string num){\\n     \\n  if(sum<0)\\n  return 0;\\n\\n  if(i==num.size()){\\n\\n\\n   if(sum==0)\\n   return 1;\\n\\n   return 0;\\n  }\\n \\n if(dp2[i][tight][sum]!=-1)\\n  \\treturn dp2[i][tight][sum];\\n\\n\\n  int ub;  // upper bound digit\\n\\n  if(tight==1)\\n  ub=num[i]-\\'0\\';\\n  else\\n  ub=9;\\n\\n  lln ans=0;\\n\\n  for(int d=0;d<=ub;d++){\\n\\n  ans=ans+find4(i+1,tight && (d==ub),sum-d,num);\\n\\n      ans%=mod;\\n  }\\n\\n  return dp2[i][tight][sum]=ans;\\n }\\n    \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int count(string num1, string num2, int minSum, int maxSum) {\\n        \\n        \\n           memset(dp1,-1,sizeof(dp1));\\n        \\n           memset(dp2,-1,sizeof(dp2));\\n\\n\\n        \\n        lln ans=0;\\n        \\n         int s1=0;\\n            \\n            for(char ch:num1){\\n                s1+=(ch-\\'0\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3595200,
                "title": "c-dp",
                "content": "DP for caculating the dp[i][j], means for given number of digits as i , what is the total number of valid integers under or equal  sum of digits j.\\nTime complexity is  l * max_sum * 10. should be less than 22* 400 * 10. \\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<long long>> dp;\\n    vector<vector<long long>> dp1;\\n    const long long mod = (long long)(1e9+ 7);\\n    long long add(long long a, long long b) {\\n        return (a + b) % mod;\\n    }\\n    long long get(int d, int l, int r) {\\n        if (d == 0) {\\n            if (l == 0) return 1;\\n            return 0;\\n        }\\n        long long ans = 0;\\n        ans = add(ans, dp1[d][r]);\\n        ans = add(ans, dp[d][l]);\\n        ans = add(ans, mod - dp1[d][l]);\\n        return ans;\\n    }\\n    int valid(string& num, long long x, long long y) {\\n        long long d = 0;\\n        for (auto c : num) d += c - \\'0\\';\\n        return (d >= x) && (d <= y) ? 1 : 0;\\n    }\\n    long long ct(string& num, long long x, long long y) {\\n        int n = num.size();\\n        long long ans = 0;\\n        /**\\n        if (n -1 >= 1) { \\n            long long ans = add(add(dp1[n - 1][y], dp[n -1][x]) ,mod - dp1[n - 1][x])  ;\\n        }\\n        **/\\n        int pre = 0;\\n        for (int i = 0; i < n; i++) {\\n            int d1 = num[i] - \\'0\\';\\n            int j = n - 1 - i;\\n            for (int d = 0; d <= 9; d++) {\\n                if (d == d1) {\\n                    pre += d;\\n                    break;\\n                } \\n                if ((y - (pre + d)) < 0) continue;\\n                long long r = y - (pre + d);\\n                long long l = max((long long)0, x - (pre + d));\\n                if (d < d1) {\\n                    ans = add(ans, get(j, l, r)) ;   \\n                }  \\n                else if (d > d1) {\\n                    break;\\n                }\\n            }\\n        }\\n        //cout << num << \",\" << ans << \",\" << endl;\\n        return ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int n = num2.size();\\n        int m = max_sum;\\n        dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, 0));\\n        dp1 = vector<vector<long long>>(n + 1, vector<long long>(m + 1, 0));\\n        //cout << \"0\" << endl;\\n        for (int i = 1; i <= n; i++) {\\n            for (int d = 0; d <= 9; d++) {\\n                if (i == 1) {\\n                    if (d <= m) {\\n                    dp[i][d] = 1;\\n                    }\\n                    continue;\\n                } else {\\n                    for (int j = 0; j + d <= m; j++) {\\n                        dp[i][j + d] = add(dp[i][j + d], dp[i -1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        //cout << \"1\" << endl;\\n        for (int i = 1; i <=n; i++) {\\n            dp1[i][0] = dp[i][0];\\n            for (int j = 1; j <= m; j++) {\\n                dp1[i][j] = add(dp1[i][j - 1], dp[i][j]);\\n            }\\n        }\\n\\n        long long a = ct(num1, min_sum, max_sum);\\n        long long b = ct(num2, min_sum, max_sum);\\n        //long long c = 0;\\n        long long c = valid(num2, min_sum, max_sum);\\n        return add(add(c, b), mod - a);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<long long>> dp;\\n    vector<vector<long long>> dp1;\\n    const long long mod = (long long)(1e9+ 7);\\n    long long add(long long a, long long b) {\\n        return (a + b) % mod;\\n    }\\n    long long get(int d, int l, int r) {\\n        if (d == 0) {\\n            if (l == 0) return 1;\\n            return 0;\\n        }\\n        long long ans = 0;\\n        ans = add(ans, dp1[d][r]);\\n        ans = add(ans, dp[d][l]);\\n        ans = add(ans, mod - dp1[d][l]);\\n        return ans;\\n    }\\n    int valid(string& num, long long x, long long y) {\\n        long long d = 0;\\n        for (auto c : num) d += c - \\'0\\';\\n        return (d >= x) && (d <= y) ? 1 : 0;\\n    }\\n    long long ct(string& num, long long x, long long y) {\\n        int n = num.size();\\n        long long ans = 0;\\n        /**\\n        if (n -1 >= 1) { \\n            long long ans = add(add(dp1[n - 1][y], dp[n -1][x]) ,mod - dp1[n - 1][x])  ;\\n        }\\n        **/\\n        int pre = 0;\\n        for (int i = 0; i < n; i++) {\\n            int d1 = num[i] - \\'0\\';\\n            int j = n - 1 - i;\\n            for (int d = 0; d <= 9; d++) {\\n                if (d == d1) {\\n                    pre += d;\\n                    break;\\n                } \\n                if ((y - (pre + d)) < 0) continue;\\n                long long r = y - (pre + d);\\n                long long l = max((long long)0, x - (pre + d));\\n                if (d < d1) {\\n                    ans = add(ans, get(j, l, r)) ;   \\n                }  \\n                else if (d > d1) {\\n                    break;\\n                }\\n            }\\n        }\\n        //cout << num << \",\" << ans << \",\" << endl;\\n        return ans;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        int n = num2.size();\\n        int m = max_sum;\\n        dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, 0));\\n        dp1 = vector<vector<long long>>(n + 1, vector<long long>(m + 1, 0));\\n        //cout << \"0\" << endl;\\n        for (int i = 1; i <= n; i++) {\\n            for (int d = 0; d <= 9; d++) {\\n                if (i == 1) {\\n                    if (d <= m) {\\n                    dp[i][d] = 1;\\n                    }\\n                    continue;\\n                } else {\\n                    for (int j = 0; j + d <= m; j++) {\\n                        dp[i][j + d] = add(dp[i][j + d], dp[i -1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        //cout << \"1\" << endl;\\n        for (int i = 1; i <=n; i++) {\\n            dp1[i][0] = dp[i][0];\\n            for (int j = 1; j <= m; j++) {\\n                dp1[i][j] = add(dp1[i][j - 1], dp[i][j]);\\n            }\\n        }\\n\\n        long long a = ct(num1, min_sum, max_sum);\\n        long long b = ct(num2, min_sum, max_sum);\\n        //long long c = 0;\\n        long long c = valid(num2, min_sum, max_sum);\\n        return add(add(c, b), mod - a);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3595179,
                "title": "digit-dp",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDigit DP\\n\\n# Complexity\\n- Time complexity: $$O(max(len(num1),len(num2))*maxSum)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(max(len(num1),len(num2))*maxSum)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    \\n    ll helper(string& num, int idx, int maxy, int miny, int sum, bool fixed, vector<vector<vector<ll>>>& dp){\\n        if(sum>maxy) return 0LL;\\n        if(idx==num.size()){\\n            if(sum>=miny) return 1LL;\\n            return 0LL;\\n        }\\n        \\n        if(dp[idx][sum][fixed]!=-1) return dp[idx][sum][fixed];\\n        int low=0;\\n        int high= fixed? 9: num[idx]-\\'0\\';\\n        \\n        dp[idx][sum][fixed]=0LL;\\n        for(int i=low;i<=high;i++){\\n            bool nfixed= (fixed|(i!=high));\\n            dp[idx][sum][fixed]= (dp[idx][sum][fixed]+helper(num,idx+1,maxy,miny,sum+i,nfixed,dp))%mod;\\n        }\\n        \\n        return dp[idx][sum][fixed];\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        vector<vector<vector<ll>>> dp1(num1.size(),vector<vector<ll>>(max_sum+1,vector<ll>(2,-1)));\\n        ll c1= helper(num1,0,max_sum,min_sum,0,0,dp1);\\n        vector<vector<vector<ll>>> dp2(num2.size(),vector<vector<ll>>(max_sum+1,vector<ll>(2,-1)));\\n        ll c2= helper(num2,0,max_sum,min_sum,0,0,dp2);\\n        \\n        int cur=0;\\n        for(auto it: num1){\\n            cur+=(it-\\'0\\');\\n        }\\n       \\n        if(cur>=min_sum && cur<=max_sum) return c2-c1+1;\\n        return c2-c1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    \\n    ll helper(string& num, int idx, int maxy, int miny, int sum, bool fixed, vector<vector<vector<ll>>>& dp){\\n        if(sum>maxy) return 0LL;\\n        if(idx==num.size()){\\n            if(sum>=miny) return 1LL;\\n            return 0LL;\\n        }\\n        \\n        if(dp[idx][sum][fixed]!=-1) return dp[idx][sum][fixed];\\n        int low=0;\\n        int high= fixed? 9: num[idx]-\\'0\\';\\n        \\n        dp[idx][sum][fixed]=0LL;\\n        for(int i=low;i<=high;i++){\\n            bool nfixed= (fixed|(i!=high));\\n            dp[idx][sum][fixed]= (dp[idx][sum][fixed]+helper(num,idx+1,maxy,miny,sum+i,nfixed,dp))%mod;\\n        }\\n        \\n        return dp[idx][sum][fixed];\\n    }\\n    \\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        vector<vector<vector<ll>>> dp1(num1.size(),vector<vector<ll>>(max_sum+1,vector<ll>(2,-1)));\\n        ll c1= helper(num1,0,max_sum,min_sum,0,0,dp1);\\n        vector<vector<vector<ll>>> dp2(num2.size(),vector<vector<ll>>(max_sum+1,vector<ll>(2,-1)));\\n        ll c2= helper(num2,0,max_sum,min_sum,0,0,dp2);\\n        \\n        int cur=0;\\n        for(auto it: num1){\\n            cur+=(it-\\'0\\');\\n        }\\n       \\n        if(cur>=min_sum && cur<=max_sum) return c2-c1+1;\\n        return c2-c1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595160,
                "title": "simple-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a complicated computation, but if properly organized it becomes simpler.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, it suffices to consider the case when num1 is 0 and compute the number of good numbers in the range 0<n<num, then take the difference between the two endpoints.\\n\\nThe endpoints themselves can be considered separately; we need to watch out for off-by-one errors. In this solution, we need to consider only num2 separately like this.\\n\\nThen, to compute the number of good numbers in the range 0<n<num, we consider the digits of num one by one, starting from the left.\\nFor example, if num=1234, we separately compute the number of good numbers between 0 and 1000, between 1000 and 1200, between 1200 and 1230, and between 1230 and 1234; then we add them up.\\nWhen going over the digits of num in this manner, we need to track their partial sum and subtract it from min_sum and max_sum.\\n\\nThe problem reduces to finding the number of good numbers between m1 followed by n zeros and m2 followed by n zeros, where m1 and m2 are digits (it also works when m1=0 and/or m2=10). This is done by recursion.\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        p=10**9+7\\n        @cache\\n        def ct1(n, m1, m2, mns, mxs):\\n            if mxs<0:\\n                return 0\\n            if mns<0:\\n                mns=0\\n            if n==0:\\n                return sum(1 for it in range(m1, m2) if mns<=it<=mxs)\\n            ans=0\\n            for m in range(m1, m2):\\n                ans+=ct1(n-1, 0, 10, mns-m, mxs-m)\\n            return ans%p\\n        \\n        def ct0(s, mns, mxs):\\n            l=len(s)\\n            ans=0\\n            s1=0\\n            for i in range(l):\\n                ans+=ct1(l-1-i, 0, int(s[i]), mns-s1, mxs-s1)\\n                s1+=int(s[i])\\n            return ans%p\\n        \\n        ans=ct0(num2, min_sum, max_sum)-ct0(num1, min_sum, max_sum)\\n        if min_sum<=sum(int(c) for c in num2)<=max_sum:\\n            ans+=1\\n        return ans%p                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        p=10**9+7\\n        @cache\\n        def ct1(n, m1, m2, mns, mxs):\\n            if mxs<0:\\n                return 0\\n            if mns<0:\\n                mns=0\\n            if n==0:\\n                return sum(1 for it in range(m1, m2) if mns<=it<=mxs)\\n            ans=0\\n            for m in range(m1, m2):\\n                ans+=ct1(n-1, 0, 10, mns-m, mxs-m)\\n            return ans%p\\n        \\n        def ct0(s, mns, mxs):\\n            l=len(s)\\n            ans=0\\n            s1=0\\n            for i in range(l):\\n                ans+=ct1(l-1-i, 0, int(s[i]), mns-s1, mxs-s1)\\n                s1+=int(s[i])\\n            return ans%p\\n        \\n        ans=ct0(num2, min_sum, max_sum)-ct0(num1, min_sum, max_sum)\\n        if min_sum<=sum(int(c) for c in num2)<=max_sum:\\n            ans+=1\\n        return ans%p                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595143,
                "title": "clear-python-code-bfs-cache",
                "content": "# Intuition\\nDo BFS and count valid nums. Use cache to speed up.\\n\\n# Complexity\\n- Time complexity: see the commit in the code\\n\\n# Code\\n```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        n = len(num2)\\n        num1 = \\'0\\' * (n - len(num1)) + num1  # let num1 and num2 same size\\n        zeros = \\'0\\' * n  # placeholder, minial number\\n        nines = \\'9\\' * n  # placeholder, maxima number\\n        \\n        @functools.cache\\n        def count_(x, y, p, pre):\\n            # x: num lower bound\\n            # y: num upper bound\\n            # p: current position, most significant bit is 0\\n            # pre: prefix digit sum\\n\\n            # x and y can only be num1, num2, zeros, nines (totally 4 choice)\\n            # p <= len(num2) <= 22\\n            # pre <= 9 * len(num2) <= 200\\n            # DP space: 4 * 22 * 200 < 20k acceptable\\n            # the function can do at most 10 DFS call (the only for loop)\\n\\n            # current digit sum bound\\n            min_, max_ = min_sum - pre, max_sum - pre\\n            if p >= n:\\n                # DFS endpoint. 0 need to be in the bound\\n                return min_ <= 0 and max_ >= 0\\n            \\n            # do DFS\\n            c1, c2 = int(x[p]), int(y[p])\\n            # c1 > c2 is impossible\\n            if c1 == c2:\\n                # can only use the digit\\n                return count_(x, y, p + 1, pre + c1)\\n            else:  # c1 < c2\\n                total = 0\\n                total += count_(x, nines, p + 1, pre + c1)  # use c1\\n                total += count_(zeros, y, p + 1, pre + c2)  # use c2\\n                for ci in range(c1 + 1, c2):  # use a number between c1 and c2\\n                    total += count_(zeros, nines, p + 1, pre + ci)\\n            \\n            return total % mod\\n        \\n        return count_(num1, num2, 0, 0) if num1 <= num2 and min_sum <= max_sum else 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        n = len(num2)\\n        num1 = \\'0\\' * (n - len(num1)) + num1  # let num1 and num2 same size\\n        zeros = \\'0\\' * n  # placeholder, minial number\\n        nines = \\'9\\' * n  # placeholder, maxima number\\n        \\n        @functools.cache\\n        def count_(x, y, p, pre):\\n            # x: num lower bound\\n            # y: num upper bound\\n            # p: current position, most significant bit is 0\\n            # pre: prefix digit sum\\n\\n            # x and y can only be num1, num2, zeros, nines (totally 4 choice)\\n            # p <= len(num2) <= 22\\n            # pre <= 9 * len(num2) <= 200\\n            # DP space: 4 * 22 * 200 < 20k acceptable\\n            # the function can do at most 10 DFS call (the only for loop)\\n\\n            # current digit sum bound\\n            min_, max_ = min_sum - pre, max_sum - pre\\n            if p >= n:\\n                # DFS endpoint. 0 need to be in the bound\\n                return min_ <= 0 and max_ >= 0\\n            \\n            # do DFS\\n            c1, c2 = int(x[p]), int(y[p])\\n            # c1 > c2 is impossible\\n            if c1 == c2:\\n                # can only use the digit\\n                return count_(x, y, p + 1, pre + c1)\\n            else:  # c1 < c2\\n                total = 0\\n                total += count_(x, nines, p + 1, pre + c1)  # use c1\\n                total += count_(zeros, y, p + 1, pre + c2)  # use c2\\n                for ci in range(c1 + 1, c2):  # use a number between c1 and c2\\n                    total += count_(zeros, nines, p + 1, pre + ci)\\n            \\n            return total % mod\\n        \\n        return count_(num1, num2, 0, 0) if num1 <= num2 and min_sum <= max_sum else 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595093,
                "title": "c-use-standard-digit-dp-solution-as-a-blackbox",
                "content": "1. Ans = count for num1 - count for (num2 - 1)\\n2. Use digit dp to find count for each.\\n3. Bounded by number of digits (e.g. 22) and the maximum sum (e.g. 400).\\n```\\nclass Solution {\\npublic:\\n    long mod = 1e9 + 7;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        long n2 = digitdp(num2, max_sum, min_sum);\\n        string c1 = decr(num1);\\n        long n1 = digitdp(c1, max_sum, min_sum);\\n        long ans = ((n2 % mod) - (n1 % mod) + mod) % mod;\\n        return (int) ans;\\n    }\\n    string decr(string n1) {\\n        int n = n1.size();\\n        for (int i = n-1; i >= 0; i--) {\\n            if (n1[i] == \\'0\\') {\\n                n1[i] = \\'9\\';\\n            } else {\\n                n1[i] = (char)((n1[i] - \\'0\\') - 1 + \\'0\\');\\n                return n1;\\n            }\\n        }\\n        return n1;\\n    }\\n    long digitdp(string num, int max_sum, int min_sum) {\\n        \\n        int n = num.size();\\n        long dp[n+1][2][max_sum+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[n][0][0] = 1;\\n        dp[n][1][0] = 1;\\n        for (int i = n-1; i >= 0; --i) {\\n            for (int t = 0; t < 2; ++t) {\\n                for (int sum = 0; sum <= max_sum; sum++) {\\n                    if (t) {\\n                        for (int d = 0; d <= num[i] - \\'0\\'; d++) {\\n                            if (sum - d < 0) continue;\\n                            long prev = (d == num[i] - \\'0\\') ? dp[i+1][1][sum-d] : dp[i+1][0][sum-d];\\n                            dp[i][1][sum] = ((prev % mod) + (dp[i][1][sum] % mod)) % mod;\\n                        }\\n                    } else {\\n                        for (int d = 0; d < 10; d++) {\\n                            if (sum - d < 0) continue;\\n                            dp[i][0][sum] = ((dp[i+1][0][sum-d] % mod) + (dp[i][0][sum] % mod)) % mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long ans = 0;\\n        for (int i = min_sum; i <= max_sum; ++i) {\\n            ans = ((ans % mod) + (dp[0][1][i] % mod)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long mod = 1e9 + 7;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        long n2 = digitdp(num2, max_sum, min_sum);\\n        string c1 = decr(num1);\\n        long n1 = digitdp(c1, max_sum, min_sum);\\n        long ans = ((n2 % mod) - (n1 % mod) + mod) % mod;\\n        return (int) ans;\\n    }\\n    string decr(string n1) {\\n        int n = n1.size();\\n        for (int i = n-1; i >= 0; i--) {\\n            if (n1[i] == \\'0\\') {\\n                n1[i] = \\'9\\';\\n            } else {\\n                n1[i] = (char)((n1[i] - \\'0\\') - 1 + \\'0\\');\\n                return n1;\\n            }\\n        }\\n        return n1;\\n    }\\n    long digitdp(string num, int max_sum, int min_sum) {\\n        \\n        int n = num.size();\\n        long dp[n+1][2][max_sum+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[n][0][0] = 1;\\n        dp[n][1][0] = 1;\\n        for (int i = n-1; i >= 0; --i) {\\n            for (int t = 0; t < 2; ++t) {\\n                for (int sum = 0; sum <= max_sum; sum++) {\\n                    if (t) {\\n                        for (int d = 0; d <= num[i] - \\'0\\'; d++) {\\n                            if (sum - d < 0) continue;\\n                            long prev = (d == num[i] - \\'0\\') ? dp[i+1][1][sum-d] : dp[i+1][0][sum-d];\\n                            dp[i][1][sum] = ((prev % mod) + (dp[i][1][sum] % mod)) % mod;\\n                        }\\n                    } else {\\n                        for (int d = 0; d < 10; d++) {\\n                            if (sum - d < 0) continue;\\n                            dp[i][0][sum] = ((dp[i+1][0][sum-d] % mod) + (dp[i][0][sum] % mod)) % mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long ans = 0;\\n        for (int i = min_sum; i <= max_sum; ++i) {\\n            ans = ((ans % mod) + (dp[0][1][i] % mod)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595087,
                "title": "how-to-write-a-more-pythonical-solution",
                "content": "remember to align the lengths of num1 and num2\\n\\n        @cache\\n        def t(i,j,l,k):   # i: index, j: if larger than num1,  l if smaller than num2, k: tot_digit sum\\n\\n            if i==len(nums2) or k>max_sum:  return min_sum<=k<=max_sum\\n\\n            return sum(  t(i+1,   j or d>num1[i],    l or num2[i]>d,   k+d) \\n\\t\\t\\t\\n                         for d in range([num1[i],0][j],   [num2[i],9][l]+1)   )%mod\\n                    \\n        return t(0,0,0,0)",
                "solutionTags": [],
                "code": "remember to align the lengths of num1 and num2\\n\\n        @cache\\n        def t(i,j,l,k):   # i: index, j: if larger than num1,  l if smaller than num2, k: tot_digit sum\\n\\n            if i==len(nums2) or k>max_sum:  return min_sum<=k<=max_sum\\n\\n            return sum(  t(i+1,   j or d>num1[i],    l or num2[i]>d,   k+d) \\n\\t\\t\\t\\n                         for d in range([num1[i],0][j],   [num2[i],9][l]+1)   )%mod\\n                    \\n        return t(0,0,0,0)",
                "codeTag": "Python3"
            },
            {
                "id": 3595073,
                "title": "java-digit-dp-easy-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public  int digitSum(String x) {\\n        int sum = 0;\\n        for(int i=0;i<x.length();i++) sum += (x.charAt(i)-\\'0\\');\\n        return sum;\\n    }\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        int n1 = num1.length();\\n        int n2 = num2.length();\\n       \\n\\n       int [][][] dp = new int[101][500][2];\\n        for(int i=0;i<101;i++){\\n            for(int j=0;j<500;j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        int result = solve(num2,n2,min_sum,max_sum,true,0,dp);\\n        for(int i=0;i<101;i++){\\n            for(int j=0;j<500;j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        result -= solve(num1,n1,min_sum,max_sum,true,0,dp);\\n        int  v = digitSum(num1); \\n        if(v<=max_sum && v>=min_sum) result++;\\n        result %= MOD;\\n        \\n        return (result + MOD) % MOD;\\n    }\\n    \\n   \\n   public int solve(String num, int n, int min, int max, boolean tight,int cursum,int dp[][][]){\\n       \\n       if(n==0){\\n           if(cursum>=min && cursum<=max) return 1;\\n           else return 0;\\n       }\\n       \\n       if(dp[n][cursum][tight==true?1:0]!=-1) return dp[n][cursum][tight==true?1:0];\\n       \\n       int ans=0;\\n       int end = (tight==true)?(num.charAt(num.length()-n)-\\'0\\'):9;\\n       for(int i=0;i<=end;i++){\\n           ans += solve(num,n-1,min,max,(tight & (i==end)) ,cursum+i,dp);\\n           ans %= MOD;\\n       }\\n      \\n       return dp[n][cursum][tight==true?1:0] = ans;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public  int digitSum(String x) {\\n        int sum = 0;\\n        for(int i=0;i<x.length();i++) sum += (x.charAt(i)-\\'0\\');\\n        return sum;\\n    }\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        int n1 = num1.length();\\n        int n2 = num2.length();\\n       \\n\\n       int [][][] dp = new int[101][500][2];\\n        for(int i=0;i<101;i++){\\n            for(int j=0;j<500;j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        int result = solve(num2,n2,min_sum,max_sum,true,0,dp);\\n        for(int i=0;i<101;i++){\\n            for(int j=0;j<500;j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        result -= solve(num1,n1,min_sum,max_sum,true,0,dp);\\n        int  v = digitSum(num1); \\n        if(v<=max_sum && v>=min_sum) result++;\\n        result %= MOD;\\n        \\n        return (result + MOD) % MOD;\\n    }\\n    \\n   \\n   public int solve(String num, int n, int min, int max, boolean tight,int cursum,int dp[][][]){\\n       \\n       if(n==0){\\n           if(cursum>=min && cursum<=max) return 1;\\n           else return 0;\\n       }\\n       \\n       if(dp[n][cursum][tight==true?1:0]!=-1) return dp[n][cursum][tight==true?1:0];\\n       \\n       int ans=0;\\n       int end = (tight==true)?(num.charAt(num.length()-n)-\\'0\\'):9;\\n       for(int i=0;i<=end;i++){\\n           ans += solve(num,n-1,min,max,(tight & (i==end)) ,cursum+i,dp);\\n           ans %= MOD;\\n       }\\n      \\n       return dp[n][cursum][tight==true?1:0] = ans;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595048,
                "title": "c-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string subtractOne(string num) {\\n        int n = num.length();\\n        int i = n - 1;\\n        while (i >= 0 && num[i] == \\'0\\') {\\n            num[i] = \\'9\\';\\n            i--;\\n        }\\n        if (i >= 0) \\n            num[i]--;\\n        i = 0;\\n        while (i < n && num[i] == \\'0\\')\\n            i++;\\n        if (i == n) return \"0\";\\n        return num.substr(i);\\n    }\\n    \\n    long long dp[23][2][401];\\n    int MOD = 1e9 + 7;;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        auto solve = [&](string num) {\\n            int n = num.size();\\n            dp[n][0][0] = 1;\\n            dp[n][1][0] = 1;\\n            for(int i = n - 1; i >= 0; --i) {\\n                for(int tight = 0; tight < 2; ++tight) {\\n                    for(int sum = 0; sum < 300; ++sum) {\\n                       if(tight){\\n                           for(int d = 0; d <= num[i] - \\'0\\'; ++d) {\\n                               if(sum < d)  continue;\\n                               dp[i][1][sum] += (d == num[i] - \\'0\\' ? dp[i + 1][1][sum - d] : dp[i + 1][0][sum - d]);\\n                               dp[i][1][sum] %= MOD;\\n                           }\\n                       } else {\\n                           for(int d = 0; d < 10; d++) {\\n                               if(sum < d)  continue;\\n                               dp[i][0][sum] += dp[i + 1][0][sum - d];\\n                               dp[i][0][sum] %= MOD;\\n                           }\\n                       }\\n                    }\\n                }\\n            }\\n            long long res = 0;\\n            for(int i = min_sum; i <= max_sum; ++i) {\\n                res = (res + dp[0][1][i]) % MOD;\\n            }\\n            return res;\\n        };\\n        memset(dp, 0, sizeof(dp) );\\n        long long res1 = solve(num2);\\n        \\n        memset(dp, 0, sizeof(dp) );\\n        long long res2 = solve(subtractOne(num1) );\\n        return (MOD + (res1 - res2) % MOD) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string subtractOne(string num) {\\n        int n = num.length();\\n        int i = n - 1;\\n        while (i >= 0 && num[i] == \\'0\\') {\\n            num[i] = \\'9\\';\\n            i--;\\n        }\\n        if (i >= 0) \\n            num[i]--;\\n        i = 0;\\n        while (i < n && num[i] == \\'0\\')\\n            i++;\\n        if (i == n) return \"0\";\\n        return num.substr(i);\\n    }\\n    \\n    long long dp[23][2][401];\\n    int MOD = 1e9 + 7;;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        auto solve = [&](string num) {\\n            int n = num.size();\\n            dp[n][0][0] = 1;\\n            dp[n][1][0] = 1;\\n            for(int i = n - 1; i >= 0; --i) {\\n                for(int tight = 0; tight < 2; ++tight) {\\n                    for(int sum = 0; sum < 300; ++sum) {\\n                       if(tight){\\n                           for(int d = 0; d <= num[i] - \\'0\\'; ++d) {\\n                               if(sum < d)  continue;\\n                               dp[i][1][sum] += (d == num[i] - \\'0\\' ? dp[i + 1][1][sum - d] : dp[i + 1][0][sum - d]);\\n                               dp[i][1][sum] %= MOD;\\n                           }\\n                       } else {\\n                           for(int d = 0; d < 10; d++) {\\n                               if(sum < d)  continue;\\n                               dp[i][0][sum] += dp[i + 1][0][sum - d];\\n                               dp[i][0][sum] %= MOD;\\n                           }\\n                       }\\n                    }\\n                }\\n            }\\n            long long res = 0;\\n            for(int i = min_sum; i <= max_sum; ++i) {\\n                res = (res + dp[0][1][i]) % MOD;\\n            }\\n            return res;\\n        };\\n        memset(dp, 0, sizeof(dp) );\\n        long long res1 = solve(num2);\\n        \\n        memset(dp, 0, sizeof(dp) );\\n        long long res2 = solve(subtractOne(num1) );\\n        return (MOD + (res1 - res2) % MOD) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595027,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        def f(size, sm):\\n            @cache\\n            def dp(i, curr, lower):\\n                if curr > sm:\\n                    return 0\\n                if i == len(size):\\n                    return 1                \\n                ans = 0\\n                if lower:\\n                    for num in range(10):\\n                        ans += dp(i + 1, curr + num, lower)\\n                else:\\n                    for num in range(1 + int(size[i])):\\n                        ans += dp(i + 1, curr + num, num < int(size[i]))                        \\n                return ans % (10**9+7)\\n            size = str(size)\\n            return dp(0, 0, False)\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return (f(num2, max_sum) - f(num1 - 1, max_sum) - f(num2, min_sum - 1) + f(num1 - 1, min_sum - 1)) % (10**9+7)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\\n        def f(size, sm):\\n            @cache\\n            def dp(i, curr, lower):\\n                if curr > sm:\\n                    return 0\\n                if i == len(size):\\n                    return 1                \\n                ans = 0\\n                if lower:\\n                    for num in range(10):\\n                        ans += dp(i + 1, curr + num, lower)\\n                else:\\n                    for num in range(1 + int(size[i])):\\n                        ans += dp(i + 1, curr + num, num < int(size[i]))                        \\n                return ans % (10**9+7)\\n            size = str(size)\\n            return dp(0, 0, False)\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return (f(num2, max_sum) - f(num1 - 1, max_sum) - f(num2, min_sum - 1) + f(num1 - 1, min_sum - 1)) % (10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 3594978,
                "title": "digit-dp-ez-as-fk",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n// # small , ind ,sm\\nint dp[2][30][500],mins,maxs; \\nstring num;\\nconst int32_t mod=1e9+7;\\nclass Solution {\\npublic:\\n    long long int rec(int smaller,int last ,int ind){\\n        if(ind==(int)num.size()){\\n            return last>=mins & last<=maxs;\\n        }\\n        if(dp[smaller][ind][last]!=-1){\\n            return dp[smaller][ind][last];\\n        }\\n        int range=(smaller)?9:num[ind]-\\'0\\';\\n        long long int ans=0;\\n        for(int i=0;i<=range;i++){\\n            int n_smaller=(smaller)|(i<range);\\n            int sm=last+i;\\n            if(sm>maxs){\\n                continue;\\n            }\\n            ans=(ans+rec(n_smaller,sm,ind+1));\\n        }\\n        \\n        dp[smaller][ind][last]=ans;\\n        return ans;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        num=num2;\\n        mins=min_sum;\\n        maxs=max_sum;\\n        memset(dp,-1,sizeof(dp));\\n        long long int ans1=rec(0,0,0);\\n        num=num1;\\n        int s=0;\\n        int c=0;\\n        for(auto i:num1){\\n            s+=(i-\\'0\\');\\n        }\\n        if(s>=mins and s<=maxs){\\n            c=1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        long long int ans2=rec(0,0,0);\\n        // cout<<ans1<<\" \"<<ans2<<endl;\\n        return (ans1-ans2+c)%mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// # small , ind ,sm\\nint dp[2][30][500],mins,maxs; \\nstring num;\\nconst int32_t mod=1e9+7;\\nclass Solution {\\npublic:\\n    long long int rec(int smaller,int last ,int ind){\\n        if(ind==(int)num.size()){\\n            return last>=mins & last<=maxs;\\n        }\\n        if(dp[smaller][ind][last]!=-1){\\n            return dp[smaller][ind][last];\\n        }\\n        int range=(smaller)?9:num[ind]-\\'0\\';\\n        long long int ans=0;\\n        for(int i=0;i<=range;i++){\\n            int n_smaller=(smaller)|(i<range);\\n            int sm=last+i;\\n            if(sm>maxs){\\n                continue;\\n            }\\n            ans=(ans+rec(n_smaller,sm,ind+1));\\n        }\\n        \\n        dp[smaller][ind][last]=ans;\\n        return ans;\\n    }\\n\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        num=num2;\\n        mins=min_sum;\\n        maxs=max_sum;\\n        memset(dp,-1,sizeof(dp));\\n        long long int ans1=rec(0,0,0);\\n        num=num1;\\n        int s=0;\\n        int c=0;\\n        for(auto i:num1){\\n            s+=(i-\\'0\\');\\n        }\\n        if(s>=mins and s<=maxs){\\n            c=1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        long long int ans2=rec(0,0,0);\\n        // cout<<ans1<<\" \"<<ans2<<endl;\\n        return (ans1-ans2+c)%mod;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3594966,
                "title": "dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     int dp[][][];\\n    long mod = (long) 1e9 + 7;\\n\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        long res = 0;\\n        boolean ca =false;\\n        for (int i = num1.length(); i <= num2.length(); i++) {\\n            dp = new int[i][max_sum + 1][4];\\n            for (int j = 0; j < i; j++) {\\n                for (int k = 0; k <= max_sum; k++) {\\n                    Arrays.fill(dp[j][k], -1);\\n                }\\n            }\\n            if(ca&&i!=num2.length()){\\n                res+=solve(0,0,0,max_sum,min_sum,num1,num2);\\n            }else if(!ca&&i<num2.length()){\\n                res+=solve(0,0,1,max_sum,min_sum,num1,num2);\\n            }else if(ca){\\n                res+=solve(0,0,2,max_sum,min_sum,num1,num2);\\n            }else if(!ca){\\n                res+=solve(0,0,3,max_sum,min_sum,num1,num2);\\n            }\\n            res%=mod;\\n            num1 += \\'0\\';\\n            ca = true;\\n        }\\n        return (int) res;\\n    }\\n\\n     long solve(int idx, int sum, int last, int maxSum, int minSum, String num1, String num2) {\\n        if (sum > maxSum) return 0;\\n        if (idx == dp.length) {\\n            if(sum<=maxSum&&sum>=minSum) {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if (dp[idx][sum][last] == -1) {\\n            dp[idx][sum][last] = 0;\\n            if (last == 3) {\\n                for (int i = num1.charAt(idx); i <= \\'9\\'; i++) {\\n                    if (i > num2.charAt(idx)) {\\n                        break;\\n                    }\\n                    if (i > num1.charAt(idx) && i < num2.charAt(idx)) {\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 0, maxSum, minSum, num1, num2);\\n                    } else if (i > num1.charAt(idx)) {\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 2, maxSum, minSum, num1, num2);\\n                    } else if(i<num2.charAt(idx)){\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 1, maxSum, minSum, num1, num2);\\n                    }else{\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 3, maxSum, minSum, num1, num2);\\n                    }\\n                    dp[idx][sum][last]%=mod;\\n                }\\n            } else if (last == 2) {\\n                char b = \\'0\\';\\n                if(idx==0)b++;\\n                for (int i = b; i <= \\'9\\'; i++) {\\n                    if (i > num2.charAt(idx)) {\\n                        break;\\n                    }\\n                    if (i < num2.charAt(idx)) {\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 0, maxSum, minSum, num1, num2);\\n                    }else{\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 2, maxSum, minSum, num1, num2);\\n                    }\\n                    dp[idx][sum][last]%=mod;\\n                }\\n            }else if(last==1){\\n                for (int i =num1.charAt(idx); i <= \\'9\\'; i++) {\\n                    if (i > num1.charAt(idx)) {\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 0, maxSum, minSum, num1, num2);\\n                    }else{\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 1, maxSum, minSum, num1, num2);\\n                    }\\n                    dp[idx][sum][last]%=mod;\\n                }\\n            }else if(last==0){\\n                char b = \\'0\\';\\n                if(idx==0){\\n                    b++;\\n                }\\n                for (int i = b; i <=\\'9\\' ; i++) {\\n                    dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 0, maxSum, minSum, num1, num2);\\n                    dp[idx][sum][last]%=mod;\\n                }\\n            }\\n        }\\n        return dp[idx][sum][last];\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     int dp[][][];\\n    long mod = (long) 1e9 + 7;\\n\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        long res = 0;\\n        boolean ca =false;\\n        for (int i = num1.length(); i <= num2.length(); i++) {\\n            dp = new int[i][max_sum + 1][4];\\n            for (int j = 0; j < i; j++) {\\n                for (int k = 0; k <= max_sum; k++) {\\n                    Arrays.fill(dp[j][k], -1);\\n                }\\n            }\\n            if(ca&&i!=num2.length()){\\n                res+=solve(0,0,0,max_sum,min_sum,num1,num2);\\n            }else if(!ca&&i<num2.length()){\\n                res+=solve(0,0,1,max_sum,min_sum,num1,num2);\\n            }else if(ca){\\n                res+=solve(0,0,2,max_sum,min_sum,num1,num2);\\n            }else if(!ca){\\n                res+=solve(0,0,3,max_sum,min_sum,num1,num2);\\n            }\\n            res%=mod;\\n            num1 += \\'0\\';\\n            ca = true;\\n        }\\n        return (int) res;\\n    }\\n\\n     long solve(int idx, int sum, int last, int maxSum, int minSum, String num1, String num2) {\\n        if (sum > maxSum) return 0;\\n        if (idx == dp.length) {\\n            if(sum<=maxSum&&sum>=minSum) {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if (dp[idx][sum][last] == -1) {\\n            dp[idx][sum][last] = 0;\\n            if (last == 3) {\\n                for (int i = num1.charAt(idx); i <= \\'9\\'; i++) {\\n                    if (i > num2.charAt(idx)) {\\n                        break;\\n                    }\\n                    if (i > num1.charAt(idx) && i < num2.charAt(idx)) {\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 0, maxSum, minSum, num1, num2);\\n                    } else if (i > num1.charAt(idx)) {\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 2, maxSum, minSum, num1, num2);\\n                    } else if(i<num2.charAt(idx)){\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 1, maxSum, minSum, num1, num2);\\n                    }else{\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 3, maxSum, minSum, num1, num2);\\n                    }\\n                    dp[idx][sum][last]%=mod;\\n                }\\n            } else if (last == 2) {\\n                char b = \\'0\\';\\n                if(idx==0)b++;\\n                for (int i = b; i <= \\'9\\'; i++) {\\n                    if (i > num2.charAt(idx)) {\\n                        break;\\n                    }\\n                    if (i < num2.charAt(idx)) {\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 0, maxSum, minSum, num1, num2);\\n                    }else{\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 2, maxSum, minSum, num1, num2);\\n                    }\\n                    dp[idx][sum][last]%=mod;\\n                }\\n            }else if(last==1){\\n                for (int i =num1.charAt(idx); i <= \\'9\\'; i++) {\\n                    if (i > num1.charAt(idx)) {\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 0, maxSum, minSum, num1, num2);\\n                    }else{\\n                        dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 1, maxSum, minSum, num1, num2);\\n                    }\\n                    dp[idx][sum][last]%=mod;\\n                }\\n            }else if(last==0){\\n                char b = \\'0\\';\\n                if(idx==0){\\n                    b++;\\n                }\\n                for (int i = b; i <=\\'9\\' ; i++) {\\n                    dp[idx][sum][last] += solve(idx + 1, sum + i - \\'0\\', 0, maxSum, minSum, num1, num2);\\n                    dp[idx][sum][last]%=mod;\\n                }\\n            }\\n        }\\n        return dp[idx][sum][last];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1915978,
                "content": [
                    {
                        "username": "feindreh",
                        "content": "only missed mod implementation :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how to create a simplest hard ( which gives TLE ) problem like this question...\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Could someone please tell me why this solution is giving me TLE?\\n\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        vector<vector<vector<long long>>> dp(25, vector<vector<long long>>(450, vector<long long>(3, -1)));\\n        vector<vector<vector<bool>>> filled(25, vector<vector<bool>>(450, vector<bool>(3, false)));\\n        long long ans = solve(num2, min_sum, max_sum, 0, 0, 0, dp, filled);\\n        filled = vector<vector<vector<bool>>>(25, vector<vector<bool>>(450, vector<bool>(3, false)));\\n        ans -= solve(num1, min_sum, max_sum, 0, 0, 0, dp, filled);\\n        int sum = 0;\\n        for(char c : num1) {\\n            sum += c-\\'0\\';\\n        }\\n        if(min_sum <= sum && sum <= max_sum) ans++;\\n        while(ans < 0) ans += mod;\\n        return ans;\\n    }\\n    \\n    long long solve(string& s, int mini, int maxi, int idx, int sum, int bigOrSmall, vector<vector<vector<long long>>>& dp, vector<vector<vector<bool>>>& filled) {\\n        if(filled[idx][sum][bigOrSmall]) return dp[idx][sum][bigOrSmall];\\n        int n = s.length();\\n        long long ans = 0;\\n        if(n == idx) return mini <= sum && sum <= maxi && bigOrSmall < 2 ? 1 : 0;\\n        for(int i = 0; i < 10; i++) {\\n            if(sum + i > maxi) continue;\\n            if(sum + i >= mini && idx < n-1) ans++; // this length string\\n            int newBigOrSmall = bigOrSmall;\\n            if(bigOrSmall == 0) {\\n                int num = s[idx] - \\'0\\';\\n                if(i > num) newBigOrSmall = 2;\\n                if(i < num) newBigOrSmall = 1;\\n            }\\n            if(i != 0 || idx != 0)\\n                ans = (ans + solve(s, mini, maxi, idx+1, sum + i, newBigOrSmall, dp, filled)) % mod;\\n        }\\n        dp[idx][sum][bigOrSmall] = ans%mod;\\n        filled[idx][sum][bigOrSmall] = true;\\n        return ans%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "/*\\nI don\\'t know why my solution is giving TLE , although i have appiled digitdp \\nbelow is the solution of problem\\n*/\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    map<int, map<int,int>> dp;\\n    int solve(string s, int min_sum, int max_sum){\\n        if(s.size() == 0){\\n            if((min_sum<0 && max_sum<0) || (min_sum>0 && max_sum>0)){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        int val = (s[0]-\\'0\\');\\n        int key = s.size()-1;\\n        map<int,int> mp = dp[key];\\n        map<int,int> res;\\n        for(int i=0;i<val;i++){\\n            for(auto it:mp){\\n                int key = it.first;\\n                res[key+i]=(res[key+i] + mp[key])%mod;\\n            }\\n        }\\n        int ans=0;\\n        for(auto it:res){\\n            int key = it.first;\\n            if(min_sum<=key && key<=max_sum){\\n                ans=(ans+it.second)%mod;\\n            }\\n        }\\n        s=s.substr(1);\\n        reverse(s.begin(),s.end());\\n        while(s.size() && s[s.size()-1] == \\'0\\'){\\n            s.pop_back();\\n        }\\n        reverse(s.begin(),s.end());\\n        int ans2 = solve(s,min_sum-val,max_sum-val);\\n        return (ans+ans2)%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        map<int,int> mp;\\n        mp[0]=1;\\n        dp[0]=mp;\\n        for(int i=1;i<23;i++){\\n            map<int,int> part;\\n            part = dp[i-1];\\n            map<int,int> res;\\n            for(int i=0;i<10;i++){\\n                for(auto it:part){\\n                    int key = it.first;\\n                    res[key+i] = (res[key+i] + part[key])%mod;\\n                }\\n            }\\n            dp[i]=res;\\n        }\\n        int digitsum=0;\\n        for(auto it:num1){\\n            digitsum+=(it-\\'0\\');\\n        }\\n        int ans=0;\\n        if(min_sum<=digitsum && digitsum<=max_sum){\\n            ans++;\\n        }\\n        return (ans + solve(num2,min_sum,max_sum) - solve(num1,min_sum,max_sum) + mod)%mod;\\n    }\\n};"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "it seem we cannot using for loop 1Giga times to pass this test case,does anyone can share some tip ?:D, was tried and gave up"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "digit DP"
                    }
                ]
            },
            {
                "id": 1916226,
                "content": [
                    {
                        "username": "feindreh",
                        "content": "only missed mod implementation :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how to create a simplest hard ( which gives TLE ) problem like this question...\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Could someone please tell me why this solution is giving me TLE?\\n\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        vector<vector<vector<long long>>> dp(25, vector<vector<long long>>(450, vector<long long>(3, -1)));\\n        vector<vector<vector<bool>>> filled(25, vector<vector<bool>>(450, vector<bool>(3, false)));\\n        long long ans = solve(num2, min_sum, max_sum, 0, 0, 0, dp, filled);\\n        filled = vector<vector<vector<bool>>>(25, vector<vector<bool>>(450, vector<bool>(3, false)));\\n        ans -= solve(num1, min_sum, max_sum, 0, 0, 0, dp, filled);\\n        int sum = 0;\\n        for(char c : num1) {\\n            sum += c-\\'0\\';\\n        }\\n        if(min_sum <= sum && sum <= max_sum) ans++;\\n        while(ans < 0) ans += mod;\\n        return ans;\\n    }\\n    \\n    long long solve(string& s, int mini, int maxi, int idx, int sum, int bigOrSmall, vector<vector<vector<long long>>>& dp, vector<vector<vector<bool>>>& filled) {\\n        if(filled[idx][sum][bigOrSmall]) return dp[idx][sum][bigOrSmall];\\n        int n = s.length();\\n        long long ans = 0;\\n        if(n == idx) return mini <= sum && sum <= maxi && bigOrSmall < 2 ? 1 : 0;\\n        for(int i = 0; i < 10; i++) {\\n            if(sum + i > maxi) continue;\\n            if(sum + i >= mini && idx < n-1) ans++; // this length string\\n            int newBigOrSmall = bigOrSmall;\\n            if(bigOrSmall == 0) {\\n                int num = s[idx] - \\'0\\';\\n                if(i > num) newBigOrSmall = 2;\\n                if(i < num) newBigOrSmall = 1;\\n            }\\n            if(i != 0 || idx != 0)\\n                ans = (ans + solve(s, mini, maxi, idx+1, sum + i, newBigOrSmall, dp, filled)) % mod;\\n        }\\n        dp[idx][sum][bigOrSmall] = ans%mod;\\n        filled[idx][sum][bigOrSmall] = true;\\n        return ans%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "/*\\nI don\\'t know why my solution is giving TLE , although i have appiled digitdp \\nbelow is the solution of problem\\n*/\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    map<int, map<int,int>> dp;\\n    int solve(string s, int min_sum, int max_sum){\\n        if(s.size() == 0){\\n            if((min_sum<0 && max_sum<0) || (min_sum>0 && max_sum>0)){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        int val = (s[0]-\\'0\\');\\n        int key = s.size()-1;\\n        map<int,int> mp = dp[key];\\n        map<int,int> res;\\n        for(int i=0;i<val;i++){\\n            for(auto it:mp){\\n                int key = it.first;\\n                res[key+i]=(res[key+i] + mp[key])%mod;\\n            }\\n        }\\n        int ans=0;\\n        for(auto it:res){\\n            int key = it.first;\\n            if(min_sum<=key && key<=max_sum){\\n                ans=(ans+it.second)%mod;\\n            }\\n        }\\n        s=s.substr(1);\\n        reverse(s.begin(),s.end());\\n        while(s.size() && s[s.size()-1] == \\'0\\'){\\n            s.pop_back();\\n        }\\n        reverse(s.begin(),s.end());\\n        int ans2 = solve(s,min_sum-val,max_sum-val);\\n        return (ans+ans2)%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        map<int,int> mp;\\n        mp[0]=1;\\n        dp[0]=mp;\\n        for(int i=1;i<23;i++){\\n            map<int,int> part;\\n            part = dp[i-1];\\n            map<int,int> res;\\n            for(int i=0;i<10;i++){\\n                for(auto it:part){\\n                    int key = it.first;\\n                    res[key+i] = (res[key+i] + part[key])%mod;\\n                }\\n            }\\n            dp[i]=res;\\n        }\\n        int digitsum=0;\\n        for(auto it:num1){\\n            digitsum+=(it-\\'0\\');\\n        }\\n        int ans=0;\\n        if(min_sum<=digitsum && digitsum<=max_sum){\\n            ans++;\\n        }\\n        return (ans + solve(num2,min_sum,max_sum) - solve(num1,min_sum,max_sum) + mod)%mod;\\n    }\\n};"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "it seem we cannot using for loop 1Giga times to pass this test case,does anyone can share some tip ?:D, was tried and gave up"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "digit DP"
                    }
                ]
            },
            {
                "id": 1916662,
                "content": [
                    {
                        "username": "feindreh",
                        "content": "only missed mod implementation :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how to create a simplest hard ( which gives TLE ) problem like this question...\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Could someone please tell me why this solution is giving me TLE?\\n\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        vector<vector<vector<long long>>> dp(25, vector<vector<long long>>(450, vector<long long>(3, -1)));\\n        vector<vector<vector<bool>>> filled(25, vector<vector<bool>>(450, vector<bool>(3, false)));\\n        long long ans = solve(num2, min_sum, max_sum, 0, 0, 0, dp, filled);\\n        filled = vector<vector<vector<bool>>>(25, vector<vector<bool>>(450, vector<bool>(3, false)));\\n        ans -= solve(num1, min_sum, max_sum, 0, 0, 0, dp, filled);\\n        int sum = 0;\\n        for(char c : num1) {\\n            sum += c-\\'0\\';\\n        }\\n        if(min_sum <= sum && sum <= max_sum) ans++;\\n        while(ans < 0) ans += mod;\\n        return ans;\\n    }\\n    \\n    long long solve(string& s, int mini, int maxi, int idx, int sum, int bigOrSmall, vector<vector<vector<long long>>>& dp, vector<vector<vector<bool>>>& filled) {\\n        if(filled[idx][sum][bigOrSmall]) return dp[idx][sum][bigOrSmall];\\n        int n = s.length();\\n        long long ans = 0;\\n        if(n == idx) return mini <= sum && sum <= maxi && bigOrSmall < 2 ? 1 : 0;\\n        for(int i = 0; i < 10; i++) {\\n            if(sum + i > maxi) continue;\\n            if(sum + i >= mini && idx < n-1) ans++; // this length string\\n            int newBigOrSmall = bigOrSmall;\\n            if(bigOrSmall == 0) {\\n                int num = s[idx] - \\'0\\';\\n                if(i > num) newBigOrSmall = 2;\\n                if(i < num) newBigOrSmall = 1;\\n            }\\n            if(i != 0 || idx != 0)\\n                ans = (ans + solve(s, mini, maxi, idx+1, sum + i, newBigOrSmall, dp, filled)) % mod;\\n        }\\n        dp[idx][sum][bigOrSmall] = ans%mod;\\n        filled[idx][sum][bigOrSmall] = true;\\n        return ans%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "/*\\nI don\\'t know why my solution is giving TLE , although i have appiled digitdp \\nbelow is the solution of problem\\n*/\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    map<int, map<int,int>> dp;\\n    int solve(string s, int min_sum, int max_sum){\\n        if(s.size() == 0){\\n            if((min_sum<0 && max_sum<0) || (min_sum>0 && max_sum>0)){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        int val = (s[0]-\\'0\\');\\n        int key = s.size()-1;\\n        map<int,int> mp = dp[key];\\n        map<int,int> res;\\n        for(int i=0;i<val;i++){\\n            for(auto it:mp){\\n                int key = it.first;\\n                res[key+i]=(res[key+i] + mp[key])%mod;\\n            }\\n        }\\n        int ans=0;\\n        for(auto it:res){\\n            int key = it.first;\\n            if(min_sum<=key && key<=max_sum){\\n                ans=(ans+it.second)%mod;\\n            }\\n        }\\n        s=s.substr(1);\\n        reverse(s.begin(),s.end());\\n        while(s.size() && s[s.size()-1] == \\'0\\'){\\n            s.pop_back();\\n        }\\n        reverse(s.begin(),s.end());\\n        int ans2 = solve(s,min_sum-val,max_sum-val);\\n        return (ans+ans2)%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        map<int,int> mp;\\n        mp[0]=1;\\n        dp[0]=mp;\\n        for(int i=1;i<23;i++){\\n            map<int,int> part;\\n            part = dp[i-1];\\n            map<int,int> res;\\n            for(int i=0;i<10;i++){\\n                for(auto it:part){\\n                    int key = it.first;\\n                    res[key+i] = (res[key+i] + part[key])%mod;\\n                }\\n            }\\n            dp[i]=res;\\n        }\\n        int digitsum=0;\\n        for(auto it:num1){\\n            digitsum+=(it-\\'0\\');\\n        }\\n        int ans=0;\\n        if(min_sum<=digitsum && digitsum<=max_sum){\\n            ans++;\\n        }\\n        return (ans + solve(num2,min_sum,max_sum) - solve(num1,min_sum,max_sum) + mod)%mod;\\n    }\\n};"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "it seem we cannot using for loop 1Giga times to pass this test case,does anyone can share some tip ?:D, was tried and gave up"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "digit DP"
                    }
                ]
            },
            {
                "id": 1917845,
                "content": [
                    {
                        "username": "feindreh",
                        "content": "only missed mod implementation :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how to create a simplest hard ( which gives TLE ) problem like this question...\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Could someone please tell me why this solution is giving me TLE?\\n\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        vector<vector<vector<long long>>> dp(25, vector<vector<long long>>(450, vector<long long>(3, -1)));\\n        vector<vector<vector<bool>>> filled(25, vector<vector<bool>>(450, vector<bool>(3, false)));\\n        long long ans = solve(num2, min_sum, max_sum, 0, 0, 0, dp, filled);\\n        filled = vector<vector<vector<bool>>>(25, vector<vector<bool>>(450, vector<bool>(3, false)));\\n        ans -= solve(num1, min_sum, max_sum, 0, 0, 0, dp, filled);\\n        int sum = 0;\\n        for(char c : num1) {\\n            sum += c-\\'0\\';\\n        }\\n        if(min_sum <= sum && sum <= max_sum) ans++;\\n        while(ans < 0) ans += mod;\\n        return ans;\\n    }\\n    \\n    long long solve(string& s, int mini, int maxi, int idx, int sum, int bigOrSmall, vector<vector<vector<long long>>>& dp, vector<vector<vector<bool>>>& filled) {\\n        if(filled[idx][sum][bigOrSmall]) return dp[idx][sum][bigOrSmall];\\n        int n = s.length();\\n        long long ans = 0;\\n        if(n == idx) return mini <= sum && sum <= maxi && bigOrSmall < 2 ? 1 : 0;\\n        for(int i = 0; i < 10; i++) {\\n            if(sum + i > maxi) continue;\\n            if(sum + i >= mini && idx < n-1) ans++; // this length string\\n            int newBigOrSmall = bigOrSmall;\\n            if(bigOrSmall == 0) {\\n                int num = s[idx] - \\'0\\';\\n                if(i > num) newBigOrSmall = 2;\\n                if(i < num) newBigOrSmall = 1;\\n            }\\n            if(i != 0 || idx != 0)\\n                ans = (ans + solve(s, mini, maxi, idx+1, sum + i, newBigOrSmall, dp, filled)) % mod;\\n        }\\n        dp[idx][sum][bigOrSmall] = ans%mod;\\n        filled[idx][sum][bigOrSmall] = true;\\n        return ans%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "/*\\nI don\\'t know why my solution is giving TLE , although i have appiled digitdp \\nbelow is the solution of problem\\n*/\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    map<int, map<int,int>> dp;\\n    int solve(string s, int min_sum, int max_sum){\\n        if(s.size() == 0){\\n            if((min_sum<0 && max_sum<0) || (min_sum>0 && max_sum>0)){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        int val = (s[0]-\\'0\\');\\n        int key = s.size()-1;\\n        map<int,int> mp = dp[key];\\n        map<int,int> res;\\n        for(int i=0;i<val;i++){\\n            for(auto it:mp){\\n                int key = it.first;\\n                res[key+i]=(res[key+i] + mp[key])%mod;\\n            }\\n        }\\n        int ans=0;\\n        for(auto it:res){\\n            int key = it.first;\\n            if(min_sum<=key && key<=max_sum){\\n                ans=(ans+it.second)%mod;\\n            }\\n        }\\n        s=s.substr(1);\\n        reverse(s.begin(),s.end());\\n        while(s.size() && s[s.size()-1] == \\'0\\'){\\n            s.pop_back();\\n        }\\n        reverse(s.begin(),s.end());\\n        int ans2 = solve(s,min_sum-val,max_sum-val);\\n        return (ans+ans2)%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        map<int,int> mp;\\n        mp[0]=1;\\n        dp[0]=mp;\\n        for(int i=1;i<23;i++){\\n            map<int,int> part;\\n            part = dp[i-1];\\n            map<int,int> res;\\n            for(int i=0;i<10;i++){\\n                for(auto it:part){\\n                    int key = it.first;\\n                    res[key+i] = (res[key+i] + part[key])%mod;\\n                }\\n            }\\n            dp[i]=res;\\n        }\\n        int digitsum=0;\\n        for(auto it:num1){\\n            digitsum+=(it-\\'0\\');\\n        }\\n        int ans=0;\\n        if(min_sum<=digitsum && digitsum<=max_sum){\\n            ans++;\\n        }\\n        return (ans + solve(num2,min_sum,max_sum) - solve(num1,min_sum,max_sum) + mod)%mod;\\n    }\\n};"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "it seem we cannot using for loop 1Giga times to pass this test case,does anyone can share some tip ?:D, was tried and gave up"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "digit DP"
                    }
                ]
            },
            {
                "id": 1917331,
                "content": [
                    {
                        "username": "feindreh",
                        "content": "only missed mod implementation :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how to create a simplest hard ( which gives TLE ) problem like this question...\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Could someone please tell me why this solution is giving me TLE?\\n\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        vector<vector<vector<long long>>> dp(25, vector<vector<long long>>(450, vector<long long>(3, -1)));\\n        vector<vector<vector<bool>>> filled(25, vector<vector<bool>>(450, vector<bool>(3, false)));\\n        long long ans = solve(num2, min_sum, max_sum, 0, 0, 0, dp, filled);\\n        filled = vector<vector<vector<bool>>>(25, vector<vector<bool>>(450, vector<bool>(3, false)));\\n        ans -= solve(num1, min_sum, max_sum, 0, 0, 0, dp, filled);\\n        int sum = 0;\\n        for(char c : num1) {\\n            sum += c-\\'0\\';\\n        }\\n        if(min_sum <= sum && sum <= max_sum) ans++;\\n        while(ans < 0) ans += mod;\\n        return ans;\\n    }\\n    \\n    long long solve(string& s, int mini, int maxi, int idx, int sum, int bigOrSmall, vector<vector<vector<long long>>>& dp, vector<vector<vector<bool>>>& filled) {\\n        if(filled[idx][sum][bigOrSmall]) return dp[idx][sum][bigOrSmall];\\n        int n = s.length();\\n        long long ans = 0;\\n        if(n == idx) return mini <= sum && sum <= maxi && bigOrSmall < 2 ? 1 : 0;\\n        for(int i = 0; i < 10; i++) {\\n            if(sum + i > maxi) continue;\\n            if(sum + i >= mini && idx < n-1) ans++; // this length string\\n            int newBigOrSmall = bigOrSmall;\\n            if(bigOrSmall == 0) {\\n                int num = s[idx] - \\'0\\';\\n                if(i > num) newBigOrSmall = 2;\\n                if(i < num) newBigOrSmall = 1;\\n            }\\n            if(i != 0 || idx != 0)\\n                ans = (ans + solve(s, mini, maxi, idx+1, sum + i, newBigOrSmall, dp, filled)) % mod;\\n        }\\n        dp[idx][sum][bigOrSmall] = ans%mod;\\n        filled[idx][sum][bigOrSmall] = true;\\n        return ans%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "/*\\nI don\\'t know why my solution is giving TLE , although i have appiled digitdp \\nbelow is the solution of problem\\n*/\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    map<int, map<int,int>> dp;\\n    int solve(string s, int min_sum, int max_sum){\\n        if(s.size() == 0){\\n            if((min_sum<0 && max_sum<0) || (min_sum>0 && max_sum>0)){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        int val = (s[0]-\\'0\\');\\n        int key = s.size()-1;\\n        map<int,int> mp = dp[key];\\n        map<int,int> res;\\n        for(int i=0;i<val;i++){\\n            for(auto it:mp){\\n                int key = it.first;\\n                res[key+i]=(res[key+i] + mp[key])%mod;\\n            }\\n        }\\n        int ans=0;\\n        for(auto it:res){\\n            int key = it.first;\\n            if(min_sum<=key && key<=max_sum){\\n                ans=(ans+it.second)%mod;\\n            }\\n        }\\n        s=s.substr(1);\\n        reverse(s.begin(),s.end());\\n        while(s.size() && s[s.size()-1] == \\'0\\'){\\n            s.pop_back();\\n        }\\n        reverse(s.begin(),s.end());\\n        int ans2 = solve(s,min_sum-val,max_sum-val);\\n        return (ans+ans2)%mod;\\n    }\\n    int count(string num1, string num2, int min_sum, int max_sum) {\\n        map<int,int> mp;\\n        mp[0]=1;\\n        dp[0]=mp;\\n        for(int i=1;i<23;i++){\\n            map<int,int> part;\\n            part = dp[i-1];\\n            map<int,int> res;\\n            for(int i=0;i<10;i++){\\n                for(auto it:part){\\n                    int key = it.first;\\n                    res[key+i] = (res[key+i] + part[key])%mod;\\n                }\\n            }\\n            dp[i]=res;\\n        }\\n        int digitsum=0;\\n        for(auto it:num1){\\n            digitsum+=(it-\\'0\\');\\n        }\\n        int ans=0;\\n        if(min_sum<=digitsum && digitsum<=max_sum){\\n            ans++;\\n        }\\n        return (ans + solve(num2,min_sum,max_sum) - solve(num1,min_sum,max_sum) + mod)%mod;\\n    }\\n};"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "it seem we cannot using for loop 1Giga times to pass this test case,does anyone can share some tip ?:D, was tried and gave up"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "digit DP"
                    }
                ]
            }
        ]
    }
]